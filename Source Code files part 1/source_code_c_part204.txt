ndif

#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
#define SIZECHARS(x)    ARRAYSIZE(x)
#define CSTRLEN(x)      (SIZECHARS(x)-1)

DWORD
__inline
_pSpUtilsGetLastError(

#if ASSERTS_ON
    IN PCSTR Filename,
    IN DWORD Line
#else
    VOID
#endif

    )
/*++

Routine Description:

    This inline routine retrieves a Win32 error, and guarantees that the error
    isn't NO_ERROR.  This routine should not be called unless the preceding
    call failed, and GetLastError() is supposed to contain the problem's cause.

Arguments:

    If asserts are turned on, this function takes the (ANSI) Filename of the 
    source file that called the failing function, and also the DWORD Line
    number where the call was made.  This makes it much easier to debug
    scenarios where the failing function didn't set last error when it was
    supposed to.

Return Value:

    Win32 error code retrieved via GetLastError(), or ERROR_UNIDENTIFIED_ERROR
    if GetLastError() returned NO_ERROR.

--*/
{
    DWORD Err = GetLastError();

#if ASSERTS_ON
    if(Err == NO_ERROR) { 
        _pSpUtilsAssertFail(Filename,
                            Line,
                            "GetLastError() != NO_ERROR"
                           ); 
    }
#endif

    return ((Err == NO_ERROR) ? ERROR_UNIDENTIFIED_ERROR : Err);
}

//
// Macro to simplify calling of a function that reports error status via
// GetLastError().  This macro allows the caller to specify what Win32 error
// code should be returned if the function reports success.  (If the default of
// NO_ERROR is desired, use the GLE_FN_CALL macro instead.)
//
// The "prototype" of this macro is as follows:
//
// DWORD
// GLE_FN_CALL_WITH_SUCCESS(
//     SuccessfulStatus, // Win32 error code to return if function succeeded
//     FailureIndicator, // value returned by function to indicate failure (e.g., FALSE, NULL, INVALID_HANDLE_VALUE)
//     FunctionCall      // actual call to the function
// );
//

#if ASSERTS_ON

#define GLE_FN_CALL_WITH_SUCCESS(SuccessfulStatus,            \
                                 FailureIndicator,            \
                                 FunctionCall)                \
                                                              \
            (SetLastError(NO_ERROR),                          \
             (((FunctionCall) != (FailureIndicator))          \
                 ? (SuccessfulStatus)                         \
                 : _pSpUtilsGetLastError(__FILE__, __LINE__)))
#else

#define GLE_FN_CALL_WITH_SUCCESS(SuccessfulStatus,         \
                                 FailureIndicator,         \
                                 FunctionCall)             \
                                                           \
            (SetLastError(NO_ERROR),                       \
             (((FunctionCall) != (FailureIndicator))       \
                 ? (SuccessfulStatus)                      \
                 : _pSpUtilsGetLastError()))
                 
#endif

//
// Macro to simplify calling of a function that reports error status via
// GetLastError().  If the function call is successful, NO_ERROR is returned.
// (To specify an alternate value returned upon success, use the
// GLE_FN_CALL_WITH_SUCCESS macro instead.)
//
// The "prototype" of this macro is as follows:
//
// DWORD
// GLE_FN_CALL(
//     FailureIndicator, // value returned by function to indicate failure (e.g., FALSE, NULL, INVALID_HANDLE_VALUE)
//     FunctionCall      // actual call to the function
// );
//

#define GLE_FN_CALL(FailureIndicator, FunctionCall)                           \
            GLE_FN_CALL_WITH_SUCCESS(NO_ERROR, FailureIndicator, FunctionCall)

VOID
_pSpUtilsExceptionHandler(
    IN  DWORD  ExceptionCode,
    IN  DWORD  AccessViolationError,
    OUT PDWORD Win32ErrorCode        OPTIONAL
    );

LONG
_pSpUtilsExceptionFilter(
    DWORD ExceptionCode
    );

BOOL
_pSpUtilsMemoryInitialize(
    VOID
    );

BOOL
_pSpUtilsMemoryUninitialize(
    VOID
    );

VOID
_pSpUtilsDebugPrintEx(
    DWORD Level,
    PCTSTR format,
    ...                                 OPTIONAL
    );

//
// internally turn on the extra memory debug code if requested
//
#if MEM_DBG
#undef pSetupCheckedMalloc
#undef pSetupCheckInternalHeap
#undef pSetupMallocWithTag
#define pSetupCheckedMalloc(Size) pSetupDebugMalloc(Size,__FILE__,__LINE__)
#define pSetupCheckInternalHeap() pSetupHeapCheck()
#define pSetupMallocWithTag(Size,Tag) pSetupDebugMallocWithTag(Size,__FILE__,__LINE__,Tag)
#endif

//
// internal tags
//
#ifdef UNICODE
#define MEMTAG_STATICSTRINGTABLE  (0x5353484a) // JHSS
#define MEMTAG_STRINGTABLE        (0x5453484a) // JHST
#define MEMTAG_STRINGDATA         (0x4453484a) // JHSD
#else
#define MEMTAG_STATICSTRINGTABLE  (0x7373686a) // jhss
#define MEMTAG_STRINGTABLE        (0x7473686a) // jhst
#define MEMTAG_STRINGDATA         (0x6473686a) // jhsd
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\unicode\precomp.h ===
#include "setupntp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\extended\precomp.h ===
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\ansi\precomp.h ===
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\unicode\precomp.h ===
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\unicode\makefile.inc ===
!include ..\makefile.inc

PRIVLIB= $(O)\spapip.lib

$(O)\setupapi.lib: $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\spapip.def $(LIBRARY_OBJS)
    -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\spapip.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\spapip.def: ..\setupapi.def
	$(C_PREPROCESSOR) ..\setupapi.def -DSPAPIP > $@

msg.h msg00001.bin msg.rc: ..\msg.mc
	mc -v ..\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\strtab.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    strtab.h

Abstract:

    String table functions in sputils that setupapi needs to know about
    but nobody else does

Author:

    Jamie Hunter (JamieHun) Jun-27-2000

Revision History:

--*/

#ifdef SPUTILSW
//
// name mangling so the names don't conflict with any in sputilsa.lib
//
#define _pSpUtilsStringTableLookUpString _pSpUtilsStringTableLookUpStringW
#define _pSpUtilsStringTableGetExtraData _pSpUtilsStringTableGetExtraDataW
#define _pSpUtilsStringTableSetExtraData _pSpUtilsStringTableSetExtraDataW
#define _pSpUtilsStringTableAddString    _pSpUtilsStringTableAddStringW
#define _pSpUtilsStringTableEnum         _pSpUtilsStringTableEnumW
#define _pSpUtilsStringTableStringFromId _pSpUtilsStringTableStringFromIdW
#define _pSpUtilsStringTableTrim         _pSpUtilsStringTableTrimW
#define _pSpUtilsStringTableInitialize   _pSpUtilsStringTableInitializeW
#define _pSpUtilsStringTableDestroy      _pSpUtilsStringTableDestroyW
#define _pSpUtilsStringTableDuplicate    _pSpUtilsStringTableDuplicateW
#define _pSpUtilsStringTableInitializeFromMemoryMappedFile _pSpUtilsStringTableInitializeFromMemoryMappedFileW
#define _pSpUtilsStringTableGetDataBlock _pSpUtilsStringTableGetDataBlockW
#define _pSpUtilsStringTableLock         _pSpUtilsStringTableLockW
#define _pSpUtilsStringTableUnlock       _pSpUtilsStringTableUnlockW
#endif // SPUTILSW

//
// Define an additional private flag for the pStringTable APIs.
// Private flags are added from MSB down; public flags are added
// from LSB up.
//
#define STRTAB_ALREADY_LOWERCASE 0x80000000

//
// Don't change this in a hurry - it requires all INF files to be recompiled
// There might even be other dependencies
//
#define HASH_BUCKET_COUNT 509

//
// Private string table functions that don't do locking.  These are
// to be used for optimization purposes by components that already have
// a locking mechanism (e.g., HINF, HDEVINFO).
//
LONG
_pSpUtilsStringTableLookUpString(
    IN     PVOID   StringTable,
    IN OUT PTSTR   String,
    OUT    PDWORD  StringLength,
    OUT    PDWORD  HashValue,           OPTIONAL
    OUT    PVOID  *FindContext,         OPTIONAL
    IN     DWORD   Flags,
    OUT    PVOID   ExtraData,           OPTIONAL
    IN     UINT    ExtraDataBufferSize  OPTIONAL
    );

LONG
_pSpUtilsStringTableAddString(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags,
    IN     PVOID ExtraData,     OPTIONAL
    IN     UINT  ExtraDataSize  OPTIONAL
    );

BOOL
_pSpUtilsStringTableGetExtraData(
    IN  PVOID StringTable,
    IN  LONG  StringId,
    OUT PVOID ExtraData,
    IN  UINT  ExtraDataBufferSize
    );

BOOL
_pSpUtilsStringTableSetExtraData(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN PVOID ExtraData,
    IN UINT  ExtraDataSize
    );

BOOL
_pSpUtilsStringTableEnum(
    IN  PVOID                StringTable,
    OUT PVOID                ExtraDataBuffer,     OPTIONAL
    IN  UINT                 ExtraDataBufferSize, OPTIONAL
    IN  PSTRTAB_ENUM_ROUTINE Callback,
    IN  LPARAM               lParam               OPTIONAL
    );

PTSTR
_pSpUtilsStringTableStringFromId(
    IN PVOID StringTable,
    IN LONG  StringId
    );

PVOID
_pSpUtilsStringTableDuplicate(
    IN PVOID StringTable
    );

VOID
_pSpUtilsStringTableDestroy(
    IN PVOID StringTable
    );

VOID
_pSpUtilsStringTableTrim(
    IN PVOID StringTable
    );

PVOID
_pSpUtilsStringTableInitialize(
    IN UINT ExtraDataSize   OPTIONAL
    );

DWORD
_pSpUtilsStringTableGetDataBlock(
    IN  PVOID  StringTable,
    OUT PVOID *StringTableBlock
    );

BOOL
_pSpUtilsStringTableLock(
    IN PVOID StringTable
    );

VOID
_pSpUtilsStringTableUnlock(
    IN PVOID StringTable
    );


//
// PNF String table routines
//
PVOID
_pSpUtilsStringTableInitializeFromMemoryMappedFile(
    IN PVOID DataBlock,
    IN DWORD DataBlockSize,
    IN LCID  Locale,
    IN UINT ExtraDataSize
    );

//
// names expected by setupapi (we use the munged names above to stop accidental link errors)
//
#define pStringTableLookUpString        _pSpUtilsStringTableLookUpString
#define pStringTableAddString           _pSpUtilsStringTableAddString
#define pStringTableGetExtraData        _pSpUtilsStringTableGetExtraData
#define pStringTableSetExtraData        _pSpUtilsStringTableSetExtraData
#define pStringTableEnum                _pSpUtilsStringTableEnum
#define pStringTableStringFromId        _pSpUtilsStringTableStringFromId
#define pStringTableDuplicate           _pSpUtilsStringTableDuplicate
#define pStringTableDestroy             _pSpUtilsStringTableDestroy
#define pStringTableTrim                _pSpUtilsStringTableTrim
#define pStringTableInitialize          _pSpUtilsStringTableInitialize
#define pStringTableGetDataBlock        _pSpUtilsStringTableGetDataBlock
#define InitializeStringTableFromMemoryMappedFile _pSpUtilsStringTableInitializeFromMemoryMappedFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\wowreg32\rc_ids.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rc_ids.h

Abstract:

    Header for wowreg32 resources

Author:

    Jamie Hunter 31/10/2000

--*/




#define     IDS_WRONGUSE         1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\sputils.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sputils.c

Abstract:

    Core sputils library file

Author:

    Jamie Hunter (JamieHun) Jun-27-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef ULONG (__cdecl *PFNDbgPrintEx)(IN ULONG ComponentId,IN ULONG Level,IN PCH Format, ...);
static PFNDbgPrintEx pfnDbgPrintEx = NULL;
static BOOL fInitDebug = FALSE;

static LONG RefCount = 0;                    // when this falls back to zero, release all resources
static BOOL SucceededInit = FALSE;

#define COUNTING 1

#if COUNTING
static DWORD pSpCheckHead = 0xaabbccdd;
static LONG pSpFailCount = 0;
static LONG pSpInitCount = 0;
static LONG pSpUninitCount = 0;
static LONG pSpConflictCount = 0;
static BOOL pSpDoneInit = FALSE;
static BOOL pSpFailedInit = FALSE;
static DWORD pSpCheckTail = 0xddccbbaa;
#endif

//
// At some point, a thread, process or module will call  pSetupInitializeUtils,
// and follow by a call to pSetupUninitializeUtils when done (cleanup)
//
// prior to this point, there's been no initialization other than static
// constants (above) pSetupInitializeUtils and pSetupUninitializeUtils must be
// mut-ex with each other and themselves
// thread A may call pSetupInitializeUtils while thread B is calling
// pSetupUninitializeUtils, the init in this case must succeed
// we can't use a single mutex or event object, since it must be cleaned up
// when pSetupUninitializeUtils succeeds
// we can't use a simple user-mode spin-lock, since priorities may be different,
// and it's just plain ugly using Sleep(0)
// so we have the _AcquireInitMutex and _ReleaseInitMutex implementations below
// it's guarenteed that when _AcquireInitMutex returns, it is not using any
// resources to hold the lock
// it will hold an event object if the thread is blocked, per blocked thread.
// This is ok since the number of blocked threads at any time will be few.
//
// It works as follows:
//
// a linked list of requests is maintained, with head at pWaitHead
// The head is interlocked, and when an item is inserted at pWaitHead
// it's entries must be valid, and can no longer be touched until
// the mutex is acquired.
//
// if the request is the very first, it need not block, will not block,
// as (at worst) the other thread has just removed it's request from the head
// and is about to return. The thread that inserts the first request into the
// list automatically owns the mutex.
//
// if the request is anything but the first, it will have an event object
// that will eventually be signalled, and at that point owns the mutex.
//
// the Thread that owns the mutex may modify anything on the wait-list,
// including pWaitHead.
//
// If the thread that owns the mutex is pWaitHead at the point it's releasing
// mutex, it does not need to signal anyone. This is protected by
// InterlockedCompareExchangePointer. If it finds itself in this state, the next
// pSetupInitializeUtils will automatically obtain the mutex, also protected
// by InterlockedCompareExchangePointer.
//
// If there are waiting entries in the list, then the tail-most waiting entry is
// signalled, at which point the related thread now owns the mutex.
//

#ifdef UNICODE

typedef struct _LinkWaitList {
    HANDLE hEvent; // for this item
    struct _LinkWaitList *pNext; // from Head to Tail
    struct _LinkWaitList *pPrev; // from Tail to Head
} LinkWaitList;

static LinkWaitList * pWaitHead = NULL;      // insert new wait items here

static
BOOL
_AcquireInitMutex(
    OUT LinkWaitList *pEntry
    )
/*++

Routine Description:

    Atomically acquire process mutex
    with no pre-requisite initialization other than
    static globals.
    Each blocked call will require an event to be created.

    Requests cannot be nested per thread (deadlock will occur)

Arguments:

    pEntry - structure to hold mutex information. This structure
                must persist until call to _ReleaseInitMutex.

    Global:pWaitHead - atomic linked list of mutex requests

Return Value:

    TRUE if mutex acquired.
    FALSE on failure (no resources)

--*/
{
    LinkWaitList *pTop;
    DWORD res;
    pEntry->pPrev = NULL;
    pEntry->pNext = NULL;
    pEntry->hEvent = NULL;
    //
    // fast lock, this will only succeed if we're the first and we have no reason to wait
    // this saves us needlessly creating an event
    //
    if(!InterlockedCompareExchangePointer(&pWaitHead,pEntry,NULL)) {
        return TRUE;
    }

#if COUNTING
    InterlockedIncrement(&pSpConflictCount);
#endif
    //
    // someone has (or, at least a moment ago, had) the lock, so we need an event
    //
    pEntry->hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if(!pEntry->hEvent) {
        return FALSE;
    }
    //
    // once pEntry is added to list, it cannot be touched until
    // WaitSingleObject is satisfied (unless we were the first)
    // if pWaitHead changes in the middle of the loop, we'll repeat again
    //
    do {
        pTop = pWaitHead;
        pEntry->pNext = pTop;
    } while (pTop != InterlockedCompareExchangePointer(&pWaitHead,pEntry,pTop));
    if(pTop) {
        //
        // we're not the first on the list
        // the owner of pTop will signal our event, wait for it.
        //
        res = WaitForSingleObject(pEntry->hEvent,INFINITE);
    } else {
        res = WAIT_OBJECT_0;
    }
    //
    // don't need event any more, the fact we've been signalled indicates we've
    // now got the lock there's no race condition wrt pEntry
    // (however someone can still insert themselves at head pointing to us)
    //
    CloseHandle(pEntry->hEvent);
    pEntry->hEvent = NULL;
    if(res != WAIT_OBJECT_0) {
        MYASSERT(res == WAIT_OBJECT_0);
        return FALSE;
    }
    return TRUE;
}

static
VOID
_ReleaseInitMutex(
    IN LinkWaitList *pEntry
    )
/*++

Routine Description:

    release process mutex previously acquired by _AcquireInitMutex
    thread must own the mutex
    no resources required for this action.
    This call may only be done once for each _AcquireInitMutex

Arguments:

    pEntry - holding mutex information. This structure
                must have been initialized by _AcquireInitMutex.

    Global:pWaitHead - atomic linked list of mutex requests

Return Value:

    none.

--*/
{
    LinkWaitList *pHead;
    LinkWaitList *pWalk;
    LinkWaitList *pPrev;

    MYASSERT(!pEntry->pNext);
    pHead = InterlockedCompareExchangePointer(&pWaitHead,NULL,pEntry);
    if(pHead == pEntry) {
        //
        // we were at head of list as well as at tail of list
        // list has now been reset to NULL
        // and may even already contain an entry due to a pLock call
        return;
    }
    if(!pEntry->pPrev) {
        //
        // we need to walk down list from pHead to pEntry
        // at the same time, remember back links
        // so we don't need to do this every time
        // note, we will never get here if pHead==pEntry
        //
        MYASSERT(pHead);
        MYASSERT(!pHead->pPrev);
        for(pWalk = pHead;pWalk != pEntry;pWalk = pWalk->pNext) {
            MYASSERT(pWalk->pNext);
            MYASSERT(!pWalk->pNext->pPrev);
            pWalk->pNext->pPrev = pWalk;
        }
    }
    pPrev = pEntry->pPrev;
    pPrev->pNext = NULL; // aids debugging, even in free build.
    SetEvent(pPrev->hEvent);
    return;
}

#else
//
// ANSI functions *MUST* work on Win95
// to support install of Whistler
// InterlockedCompareExchange(Pointer)
// is not supported
// so we'll use something simple/functional instead
// that uses the supported InterlockedExchange
//
static LONG SimpleCritSec = FALSE;
typedef PVOID LinkWaitList;

static
BOOL
_AcquireInitMutex(
    OUT LinkWaitList *pEntry
    )
{
    while(InterlockedExchange(&SimpleCritSec,TRUE) == TRUE) {
        //
        // release our timeslice
        // we should rarely be spinning here
        // starvation can occur in some circumstances
        // if initializing threads are of different priorities
        //
        Sleep(0);
    }
    return TRUE;
}

static
VOID
_ReleaseInitMutex(
    IN LinkWaitList *pEntry
    )
{
    if(InterlockedExchange(&SimpleCritSec,FALSE) == FALSE) {
        MYASSERT(0 && SimpleCritSec);
    }
}

#endif

BOOL
pSetupInitializeUtils(
    VOID
    )
/*++

Routine Description:

    Initialize this library
    balance each successful call to this function with
    equal number of calls to pSetupUninitializeUtils

Arguments:

    none

Return Value:

    TRUE if init succeeded, FALSE otherwise

--*/
{
    LinkWaitList Lock;

    if(!_AcquireInitMutex(&Lock)) {
#if COUNTING
        InterlockedIncrement(&pSpFailCount);
#endif
        return FALSE;
    }
#if COUNTING
    InterlockedIncrement(&pSpInitCount);
#endif
    RefCount++;
    if(RefCount==1) {
        pSpDoneInit = TRUE;
        SucceededInit = _pSpUtilsMemoryInitialize();
        if(!SucceededInit) {
            pSpFailedInit = TRUE;
            _pSpUtilsMemoryUninitialize();
        }
    }
    _ReleaseInitMutex(&Lock);
    return SucceededInit;
}

BOOL
pSetupUninitializeUtils(
    VOID
    )
/*++

Routine Description:

    Uninitialize this library
    This should be called for each successful call to
    pSetupInitializeUtils

Arguments:

    none

Return Value:

    TRUE if cleanup succeeded, FALSE otherwise

--*/
{
    LinkWaitList Lock;
#if COUNTING
    InterlockedIncrement(&pSpUninitCount);
#endif
    if(!SucceededInit) {
        return FALSE;
    }
    if(!_AcquireInitMutex(&Lock)) {
        return FALSE;
    }
    RefCount--;
    if(RefCount == 0) {
        _pSpUtilsMemoryUninitialize();
        SucceededInit = FALSE;
    }
    _ReleaseInitMutex(&Lock);
    return TRUE;
}

VOID
_pSpUtilsAssertFail(
    IN PCSTR FileName,
    IN UINT LineNumber,
    IN PCSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    LPSTR Msg;
    DWORD msglen;
    DWORD sz;

    //
    // obtain module name
    //
    sz = GetModuleFileNameA(NULL,Name,MAX_PATH);
    if((sz == 0) || (sz > MAX_PATH)) {
        strcpy(Name,"?");
    }
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }
    msglen = strlen(p)+strlen(FileName)+strlen(Condition)+128;
    //
    // assert might be out of memory condition
    // stack alloc is more likely to succeed than memory alloc
    //
    try {
        Msg = (LPSTR)_alloca(msglen);
        wsprintfA(
            Msg,
            "SPUTILS: Assertion failure at line %u in file %s!%s: %s\r\n",
            LineNumber,
            p,
            FileName,
            Condition
            );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Msg = "SpUTILS ASSERT!!!! (out of stack)\r\n";
    }

    OutputDebugStringA(Msg);
    DebugBreak();
}

VOID
pSetupDebugPrintEx(
    DWORD Level,
    PCTSTR format,
    ...                                 OPTIONAL
    )

/*++

Routine Description:

    Send a formatted string to the debugger.
    Note that this is expected to work cross-platform, but use preferred debugger

Arguments:

    format - standard printf format string.

Return Value:

    NONE.

--*/

{
    TCHAR buf[1026];    // bigger than max size
    va_list arglist;

    if (!fInitDebug) {
        pfnDbgPrintEx = (PFNDbgPrintEx)GetProcAddress(GetModuleHandle(TEXT("NTDLL")), "DbgPrintEx");
        fInitDebug = TRUE;
    }

    va_start(arglist, format);
    wvsprintf(buf, format, arglist);

    if (pfnDbgPrintEx) {
#ifdef UNICODE
        (*pfnDbgPrintEx)(DPFLTR_SETUP_ID, Level, "%ls",buf);
#else
        (*pfnDbgPrintEx)(DPFLTR_SETUP_ID, Level, "%s",buf);
#endif
    } else {
        OutputDebugString(buf);
    }
}

LONG
_pSpUtilsExceptionFilter(
    DWORD ExceptionCode
    )
/*++

Routine Description:

    This routine acts as the exception filter for SpUtils.  We will handle all
    exceptions except for the following:

    EXCEPTION_SPAPI_UNRECOVERABLE_STACK_OVERFLOW
        This means we previously tried to reinstate the guard page after a
        stack overflow, but couldn't.  We have no choice but to let the
        exception trickle all the way back out.

    EXCEPTION_POSSIBLE_DEADLOCK
        We are not allowed to handle this exception which fires when the
        deadlock detection gflags option has been enabled.

Arguments:

    ExceptionCode - Specifies the exception that occurred (i.e., as returned
        by GetExceptionCode)

Return Value:

    If the exception should be handled, the return value is
    EXCEPTION_EXECUTE_HANDLER.

    Otherwise, the return value is EXCEPTION_CONTINUE_SEARCH.

--*/
{
    if((ExceptionCode == EXCEPTION_SPAPI_UNRECOVERABLE_STACK_OVERFLOW) ||
       (ExceptionCode == EXCEPTION_POSSIBLE_DEADLOCK)) {

        return EXCEPTION_CONTINUE_SEARCH;
    } else {
        return EXCEPTION_EXECUTE_HANDLER;
    }
}


VOID
_pSpUtilsExceptionHandler(
    IN  DWORD  ExceptionCode,
    IN  DWORD  AccessViolationError,
    OUT PDWORD Win32ErrorCode        OPTIONAL
    )
/*++

Routine Description:

    This routine, called from inside an exception handler block, provides
    common exception handling functionality to be used throughout SpUtils.
    It has knowledge of which exceptions require extra work (e.g., stack
    overflow), and also optionally returns a Win32 error code that represents
    the exception.  (The caller specifies the error to be used when an access
    violation occurs.)

Arguments:

    ExceptionCode - Specifies the exception that occurred (i.e., as returned
        by GetExceptionCode)

    AccessViolationError - Specifies the Win32 error code to be returned via
        the optional Win32ErrorCode OUT parameter when the exception
        encountered was EXCEPTION_ACCESS_VIOLATION.

    Win32ErrorCode - Optionally, supplies the address of a DWORD that receives
        the Win32 error code corresponding to the exception (taking into
        account the AccessViolationError code supplied above, if applicable).

Return Value:

    None

--*/
{
    DWORD Err;

    //
    // Exception codes we should never attempt to handle...
    //
    MYASSERT(ExceptionCode != EXCEPTION_SPAPI_UNRECOVERABLE_STACK_OVERFLOW);
    MYASSERT(ExceptionCode != EXCEPTION_POSSIBLE_DEADLOCK);

    if(ExceptionCode == STATUS_STACK_OVERFLOW) {

        if(_resetstkoflw()) {
            Err = ERROR_STACK_OVERFLOW;
        } else {
            //
            // Couldn't recover from stack overflow!
            //
            RaiseException(EXCEPTION_SPAPI_UNRECOVERABLE_STACK_OVERFLOW,
                           EXCEPTION_NONCONTINUABLE,
                           0,
                           NULL
                          );
            //
            // We should never get here, but initialize Err to make code
            // analysis tools happy...
            //
            Err = ERROR_UNRECOVERABLE_STACK_OVERFLOW;
        }

    } else {
        //
        // Except for a couple of special cases (for backwards-compatibility),
        // we have to report an "unknown exception", since the function we'd
        // like to use (RtlNtStatusToDosErrorNoTeb) isn't available for use by
        // clients of sputils.
        //
        switch(ExceptionCode) {

            case EXCEPTION_ACCESS_VIOLATION :
                Err = AccessViolationError;
                break;

            case EXCEPTION_IN_PAGE_ERROR :
                Err = ERROR_READ_FAULT;
                break;

            default :
                Err = ERROR_UNKNOWN_EXCEPTION;
                break;
        }
    }

    if(Win32ErrorCode) {
        *Win32ErrorCode = Err;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\sputils\strtab.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    strtab.c

Abstract:

    String table functions for Windows NT Setup API dll

    A string table is a block of memory that contains a bunch of strings.
    Hashing is used, and each hash table entry points to a linked list
    of strings within the string table. Strings within each linked list
    are sorted in ascending order. A node in the linked list consists of
    a pointer to the next node, followed by the string itself. Nodes
    are manually aligned to start on DWORD boundaries so we don't have to
    resort to using unaligned pointers.

Author:

    Ted Miller (tedm) Jan-11-1995

Revision History:

    Jamie Hunter (JamieHun) Jan-15-1997 fixed minor bug regarding use of STRTAB_NEW_EXTRADATA
    Jamie Hunter (JamieHun) Feb-8-2000  improved string table growth algorithm
    Jamie Hunter (JamieHun) Jun-27-2000 moved to sputils static library

--*/

#include "precomp.h"
#pragma hdrstop


//
// Values used for the initial and growth size
// of the string table data area
//
// We start out with 6K, but remember that this includes the hash buckets.
// After you subtract their part of the buffer, you're left with ~4K bytes.
// STRING_TABLE_NEW_SIZE_ADJUST - determines approximate increase
// STRING_TABLE_NEW_SIZE - will increase oldsize by at least STRING_TABLE_GROWTH_SIZE
// and a multiple of STRING_TABLE_GROWTH_SIZE
// if string table gets very big, we limit growth to STRING_TABLE_GROWTH_CAP bytes.
//
#define STRING_TABLE_INITIAL_SIZE   6144
#define STRING_TABLE_GROWTH_SIZE    2048
#define STRING_TABLE_GROWTH_CAP     0x100000
#define STRING_TABLE_NEW_SIZE_ADJUST(oldsize) ((oldsize)/3*2)
#define STRING_TABLE_NEW_SIZE(oldsize) \
            (oldsize+min((((DWORD)(STRING_TABLE_NEW_SIZE_ADJUST(oldsize)/STRING_TABLE_GROWTH_SIZE)+1)*STRING_TABLE_GROWTH_SIZE),STRING_TABLE_GROWTH_CAP))


//
// WARNING:
//
// Don't change this structure, various file formats depend upon it
//
#include "pshpack1.h"

#ifdef SPUTILSW
//
// name mangling so the names don't conflict with any in sputilsa.lib
//
#define _STRING_NODE                     _STRING_NODE_W
#define STRING_NODE                      STRING_NODE_W
#define PSTRING_NODE                     PSTRING_NODE_W
#define _STRING_TABLE                    _STRING_TABLE_W
#define STRING_TABLE                     STRING_TABLE_W
#define PSTRING_TABLE                    PSTRING_TABLE_W
#endif // SPUTILSW

typedef struct _STRING_NODE {
    //
    // This is stored as an offset instead of a pointer
    // because the table can move as it's built
    // The offset is from the beginning of the table
    //
    LONG NextOffset;
    //
    // This field must be last
    //
    TCHAR String[ANYSIZE_ARRAY];
} STRING_NODE, *PSTRING_NODE;

#include "poppack.h"

//
// in-memory details about the string table
//
typedef struct _STRING_TABLE {
    PUCHAR Data;    // First HASH_BUCKET_COUNT DWORDS are StringNodeOffset array.
    DWORD DataSize;
    DWORD BufferSize;
    MYLOCK Lock;
    UINT ExtraDataSize;
    LCID Locale;
} STRING_TABLE, *PSTRING_TABLE;

#define LockTable(table)    BeginSynchronizedAccess(&((table)->Lock))
#define UnlockTable(table)  EndSynchronizedAccess(&((table)->Lock))


#ifdef UNICODE

#define FixedCompareString      CompareString

#else

#include <locale.h>
#include <mbctype.h>

static
INT
FixedCompareString (
    IN      LCID Locale,
    IN      DWORD Flags,
    IN      PCSTR FirstString,
    IN      INT Count1,
    IN      PCSTR SecondString,
    IN      INT Count2
    )
{
    LCID OldLocale;
    INT Result = 0;

    //
    // This routine uses the C runtime to compare the strings, because
    // the Win32 APIs are broken on some versions of Win95
    //

    OldLocale = GetThreadLocale();

    if (OldLocale != Locale) {
        SetThreadLocale (Locale);
        setlocale(LC_ALL,"");
    }

    __try {
        if (Count1 == -1) {
            Count1 = strlen (FirstString);
        }

        if (Count2 == -1) {
            Count2 = strlen (SecondString);
        }

        //
        // The C runtime compares strings differently than the CompareString
        // API.  Most importantly, the C runtime considers uppercase to be
        // less than lowercase; the CompareString API is the opposite.
        //

        if (Flags & NORM_IGNORECASE) {
            Result = _mbsnbicmp (FirstString, SecondString, min (Count1, Count2));
        } else {
            Result = _mbsnbcmp (FirstString, SecondString, min (Count1, Count2));
        }

        //
        // We now convert the C runtime result into the CompareString result.
        // This means making the comparison a Z to A ordering, with lowercase
        // coming before uppercase. The length comparison does not get reversed.
        //

        if(Result == _NLSCMPERROR) {

            Result = 0;                         // zero returned if _mbsnbicmp could not compare

        } else if (Result < 0) {

            Result = CSTR_GREATER_THAN;

        } else if (Result == 0) {

            if (Count1 < Count2) {
                Result = CSTR_LESS_THAN;         // first string shorter than second
            } else if (Count1 > Count2) {
                Result = CSTR_GREATER_THAN;      // first string longer than second
            } else {
                Result = CSTR_EQUAL;
            }

        } else {
            Result = CSTR_LESS_THAN;
        }
    }
    __except (TRUE) {
        Result = 0;
    }

    if (OldLocale != Locale) {
        SetThreadLocale (OldLocale);
        setlocale(LC_ALL,"");
    }

    return Result;
}

#endif

static
DWORD
_StringTableCheckFlags(
    IN DWORD FlagsIn
    )
/*++

Routine Description:

    Pre-process flags, called by exported routines we want to handle the
    combination of CASE_INSENSITIVE, CASE_SENSITIVE and BUFFER_WRITEABLE
    and keep all other flags as is.

Arguments:

    FlagsIn - flags as supplied

Return Value:

    Flags out

--*/

{
    DWORD FlagsOut;
    DWORD FlagsSpecial;

    //
    // we're just interested in these flags for the switch
    //
    FlagsSpecial = FlagsIn & (STRTAB_CASE_SENSITIVE | STRTAB_BUFFER_WRITEABLE);

    //
    // strip these off FlagsIn to create initial FlagsOut
    //
    FlagsOut = FlagsIn ^ FlagsSpecial;

    switch (FlagsSpecial) {

    case STRTAB_CASE_INSENSITIVE :
    case STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE :
        //
        // these cases ok
        //
        FlagsOut |= FlagsSpecial;
        break;

    default :
        //
        // any other combination is treated as STRTAB_CASE_SENSITIVE (and so
        // WRITEABLE doesn't matter)
        //
        FlagsOut |= STRTAB_CASE_SENSITIVE;
    }

    return FlagsOut;
}

static
VOID
_ComputeHashValue(
    IN  PTSTR  String,
    OUT PDWORD StringLength,
    IN  DWORD  Flags,
    OUT PDWORD HashValue
    )

/*++

Routine Description:

    Compute a hash value for a given string.

    The algorithm simply adds up the unicode values for each
    character in the string and then takes the result mod the
    number of hash buckets.

Arguments:

    String - supplies the string for which a hash value is desired.

    StringLength - receives the number of characters in the string,
        not including the terminating nul.

    Flags - supplies flags controlling how the hashing is to be done.  May be
        a combination of the following values (all other bits ignored):

        STRTAB_BUFFER_WRITEABLE  - The caller-supplied buffer may be written to during
                                   the string look-up.  Specifying this flag improves the
                                   performance of this API for case-insensitive string
                                   additions.  This flag is ignored for case-sensitive
                                   string additions.

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

    HashValue - receives the hash value.

Return Value:

    None.

--*/

{
    DWORD Length;
    DWORD Value = 0;
    PCTSTR p, q;
    DWORD Char;

    try {

        if((Flags & (STRTAB_BUFFER_WRITEABLE | STRTAB_ALREADY_LOWERCASE)) == STRTAB_BUFFER_WRITEABLE) {
            //
            // Then the buffer is writeable, but isn't yet lower-case.  Take care of that right now.
            //

#ifndef UNICODE
            _mbslwr (String);
#else
            CharLower(String);
#endif

            Flags |= STRTAB_ALREADY_LOWERCASE;
        }

//
// Define a macro to ensure we don't get sign-extension when adding up character values.
//
#ifdef UNICODE
    #define DWORD_FROM_TCHAR(x)   ((DWORD)((WCHAR)(x)))
#else
    #define DWORD_FROM_TCHAR(x)   ((DWORD)((UCHAR)(x)))
#endif

        p = String;

        if(Flags & STRTAB_ALREADY_LOWERCASE) {

            while (*p) {
                Value += DWORD_FROM_TCHAR (*p);
                p++;
            }

        } else {
            //
            // Make sure we don't get sign-extension on extended chars
            // in String -- otherwise we get values like 0xffffffe4 passed
            // to CharLower(), which thinks it's a pointer and faults.
            //

#ifdef UNICODE
            //
            // The WCHAR case is trivial
            //

            while (*p) {
                Value += DWORD_FROM_TCHAR(CharLower((PWSTR)(WORD) (*p)));
                p++;
            }

#else
            //
            // The DBCS case is a mess because of the possibility of CharLower
            // altering a two-byte character
            // Standardize to use _mbslwr as that is used elsewhere
            // ie, if we did _mbslwr, & called this function with
            // flag set to say "already lower", vs we called function
            // with buffer writable, vs calling with neither
            // we should ensure we get same hash in each case
            // it may fail, but at least it will fail *universally* and
            // generate the same hash
            //
            PTSTR copy = pSetupDuplicateString(String);
            if(copy) {
                //
                // do conversion on copied string
                //
                _mbslwr(copy);
                p = copy;
                while (*p) {
                    Value += DWORD_FROM_TCHAR (*p);
                    p++;
                }
                pSetupFree(copy);
                p = String+lstrlen(String);
            } else {
                //
                // we had a memory failure
                //
                *HashValue = 0;
                *StringLength = 0;
                leave;
            }
#endif

        }

        *HashValue = Value % HASH_BUCKET_COUNT;
        *StringLength = (DWORD)(p - String);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Inbound string was bogus
        //

        *HashValue = 0;
        *StringLength = 0;
        MYASSERT(FALSE);
    }
}


BOOL
_pSpUtilsStringTableLock(
    IN PVOID StringTable
    )

/*++

Routine Description:

    This routine acquires the lock for the specified string table (it's
    implemented as a function call for uses in setupapi where locking needs to
    be explicitly controlled).

Arguments:

    StringTable - supplies handle to string table to be locked.

Return Value:

    If the lock was successfully acquired, the return value is TRUE.
    Otherwise, the return value is FALSE.

--*/

{
    return LockTable((PSTRING_TABLE)StringTable);
}


VOID
_pSpUtilsStringTableUnlock(
    IN PVOID StringTable
    )

/*++

Routine Description:

    This routine releases the lock (previously acquired via
    _pSpUtilsStringTableLock) for the specified string table.

Arguments:

    StringTable - supplies handle to string table to be unlocked.

Return Value:

    None.

--*/

{
    UnlockTable((PSTRING_TABLE)StringTable);
}


LONG
_pSpUtilsStringTableLookUpString(
    IN     PVOID   StringTable,
    IN OUT PTSTR   String,
    OUT    PDWORD  StringLength,
    OUT    PDWORD  HashValue,           OPTIONAL
    OUT    PVOID  *FindContext,         OPTIONAL
    IN     DWORD   Flags,
    OUT    PVOID   ExtraData,           OPTIONAL
    IN     UINT    ExtraDataBufferSize  OPTIONAL
    )

/*++

Routine Description:

    Locates a string in the string table, if present.
    If the string is not present, this routine may optionally tell its
    caller where the search stopped. This is useful for maintaining a
    sorted order for the strings.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be looked up

    StringLength - receives number of characters in the string, not
        including the terminating nul.

    HashValue - Optionally, receives hash value for the string.

    FindContext - Optionally, receives the context at which the search was
        terminated.

        (NOTE: This is actually a PSTRING_NODE pointer, that is used
        during new string addition.  Since this routine has wider exposure
        than just internal string table usage, this parameter is made into
        a PVOID, so no one else has to have access to string table-internal
        structures.

        On return, this variable receives a pointer to the string node of
        the node where the search stopped. If the string was found, then
        this is a pointer to the string's node. If the string was not found,
        then this is a pointer to the last string node whose string is
        'less' (based on lstrcmpi) than the string we're looking for.
        Note that this value may be NULL.)

    Flags - supplies flags controlling how the string is to be located.  May be
        a combination of the following values:

        STRTAB_CASE_INSENSITIVE  - Search for the string case-insensitively.

        STRTAB_CASE_SENSITIVE    - Search for the string case-sensitively.  This flag
                                   overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE  - The caller-supplied buffer may be written to during
                                   the string look-up.  Specifying this flag improves the
                                   performance of this API for case-insensitive string
                                   additions.  This flag is ignored for case-sensitive
                                   string additions.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

    ExtraData - if specified, receives extra data associated with the string
        if the string is found.

    ExtraDataBufferSize - if ExtraData is specified, then this parameter
        specifies the size of the buffer, in bytes. As much extra data as will fit
        is stored here.

Return Value:

    The return value is a value that uniquely identifies the string
    within the string table, namely the offset of the string node
    within the string table.

    If the string could not be found the value is -1.

--*/

{
    PSTRING_NODE node,prev;
    int i;
    PSTRING_TABLE stringTable = StringTable;
    DWORD hashValue;
    PSTRING_NODE FinalNode;
    LONG rc = -1;
    LCID Locale;
    DWORD CompareFlags;
    BOOL CollateEnded = FALSE;

    //
    // If this is a case-sensitive lookup, then we want to reset the STRTAB_BUFFER_WRITEABLE
    // flag, if present, since otherwise the string will get replaced with its all-lowercase
    // counterpart.
    //
    if(Flags & STRTAB_CASE_SENSITIVE) {
        Flags &= ~STRTAB_BUFFER_WRITEABLE;
    }

    //
    // Compute hash value
    //
    _ComputeHashValue(String,StringLength,Flags,&hashValue);

    if(((PLONG)(stringTable->Data))[hashValue] == -1) {
        //
        // The string table contains no strings at the computed hash value.
        //
        FinalNode = NULL;
        goto clean0;
    }

    //
    // We know there's at least one string in the table with the computed
    // hash value, so go find it. There's no previous node yet.
    //
    node = (PSTRING_NODE)(stringTable->Data + ((PLONG)(stringTable->Data))[hashValue]);
    prev = NULL;

    //
    // Go looking through the string nodes for that hash value,
    // looking through the string.
    //
    Locale = stringTable->Locale;

    CompareFlags = (Flags & STRTAB_CASE_SENSITIVE) ? 0 : NORM_IGNORECASE;

    while(1) {

        if(i = FixedCompareString(Locale,CompareFlags,String,-1,node->String,-1)) {
            i -= 2;
        } else {
            //
            // Failure, try system default locale
            //
            if(i = FixedCompareString(LOCALE_SYSTEM_DEFAULT,CompareFlags,String,-1,node->String,-1)) {
                i -= 2;
            } else {
                //
                // Failure, just use CRTs
                //
                // This could give wrong collation?? If it does, we're stuck with it now.
                //
                i = (Flags & STRTAB_CASE_SENSITIVE)
                  ? _tcscmp(String,node->String)
                  : _tcsicmp(String,node->String);
            }
        }

        if(i == 0) {
            FinalNode = node;
            rc = (LONG)((PUCHAR)node - stringTable->Data);
            break;
        }

        //
        // If the string we are looking for is 'less' than the current
        // string, mark it's position so we can insert a new string before here
        // (ANSI) but keep searching (UNICODE) we can abort - old behaviour
        //
        if((i < 0) && !CollateEnded) {
            CollateEnded = TRUE;
            FinalNode = prev;
#if UNICODE
            break;
#endif
        }

        //
        // The string we are looking for is 'greater' than the current string.
        // Keep looking, unless we've reached the end of the table.
        //
        if(node->NextOffset == -1) {
            if(!CollateEnded)
            {
                //
                // unless we found a more ideal position
                // return the end of the list
                //
                FinalNode = node;
            }
            break;
        } else {
            prev = node;
            node = (PSTRING_NODE)(stringTable->Data + node->NextOffset);
        }
    }

clean0:

    if((rc != -1) && ExtraData) {
        //
        // Extra data is stored immediately following the string.
        //
        CopyMemory(
            ExtraData,
            FinalNode->String + *StringLength + 1,
            min(ExtraDataBufferSize,stringTable->ExtraDataSize)
            );
    }

    if(HashValue) {
        *HashValue = hashValue;
    }
    if(FindContext) {
        *FindContext = FinalNode;
    }

    return rc;
}


LONG
pSetupStringTableLookUpString(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags
    )

/*++

Routine Description:

    Locates a string in the string table, if present.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be looked up.  If STRTAB_BUFFER_WRITEABLE is
        specified and a case-insensitive lookup is requested, then this buffer
        will be all lower-case upon return.

    Flags - supplies flags controlling how the string is to be located.  May be
        a combination of the following values:

        STRTAB_CASE_INSENSITIVE  - Search for the string case-insensitively.

        STRTAB_CASE_SENSITIVE    - Search for the string case-sensitively.  This flag
                                   overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE  - The caller-supplied buffer may be written to during
                                   the string look-up.  Specifying this flag improves the
                                   performance of this API for case-insensitive string
                                   additions.  This flag is ignored for case-sensitive
                                   string additions.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

Return Value:

    The return value is a value that uniquely identifies the string
    within the string table.

    If the string could not be found the value is -1.

--*/

{
    DWORD StringLength, PrivateFlags, AlreadyLcFlag;
    LONG rc = -1;
    BOOL locked = FALSE;

    try {
        if (!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        PrivateFlags = _StringTableCheckFlags(Flags);

        rc = _pSpUtilsStringTableLookUpString(
                                     StringTable,
                                     String,
                                     &StringLength,
                                     NULL,
                                     NULL,
                                     PrivateFlags,
                                     NULL,
                                     0
                                     );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        rc = -1;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return (rc);
}


LONG
pSetupStringTableLookUpStringEx(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags,
       OUT PVOID ExtraData,             OPTIONAL
    IN     UINT  ExtraDataBufferSize    OPTIONAL
    )

/*++

Routine Description:

    Locates a string in the string table, if present.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be looked up.  If STRTAB_BUFFER_WRITEABLE is
        specified and a case-insensitive lookup is requested, then this buffer
        will be all lower-case upon return.

    Flags - supplies flags controlling how the string is to be located.  May be
        a combination of the following values:

        STRTAB_CASE_INSENSITIVE  - Search for the string case-insensitively.

        STRTAB_CASE_SENSITIVE    - Search for the string case-sensitively.  This flag
                                   overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE  - The caller-supplied buffer may be written to during
                                   the string look-up.  Specifying this flag improves the
                                   performance of this API for case-insensitive string
                                   additions.  This flag is ignored for case-sensitive
                                   string additions.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

    ExtraData - if specified, receives extra data associated with the string
        if the string is found.

    ExtraDataBufferSize - if ExtraData is specified, then this parameter
        specifies the size of the buffer, in bytes. As much extra data as will fit
        is stored here.

Return Value:

    The return value is a value that uniquely identifies the string
    within the string table.

    If the string could not be found the value is -1.

--*/

{
    DWORD StringLength, PrivateFlags, AlreadyLcFlag;
    LONG rc = -1;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        PrivateFlags = _StringTableCheckFlags(Flags);

        rc = _pSpUtilsStringTableLookUpString(
                                     StringTable,
                                     String,
                                     &StringLength,
                                     NULL,
                                     NULL,
                                     PrivateFlags,
                                     ExtraData,
                                     ExtraDataBufferSize
                                     );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        rc = -1;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return (rc);
}


BOOL
pSetupStringTableGetExtraData(
    IN  PVOID StringTable,
    IN  LONG  StringId,
    OUT PVOID ExtraData,
    IN  UINT  ExtraDataBufferSize
    )

/*++

Routine Description:

    Get arbitrary data associated with a string table entry.

Arguments:

    StringTable - supplies handle to string table containing the string
        whose associated data is to be returned.

    String - supplies the id of the string whose associated data is to be returned.

    ExtraData - receives the data associated with the string. Data is truncated
        to fit, if necessary.

    ExtraDataBufferSize - supplies the size in bytes of the buffer specified
        by ExtraData. If this value is smaller than the extra data size for
        the string table, data is truncated to fit.

Return Value:

    Boolean value indicating outcome.

--*/

{
    BOOL b = FALSE;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        b = _pSpUtilsStringTableGetExtraData(StringTable,StringId,ExtraData,ExtraDataBufferSize);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return(b);
}


BOOL
_pSpUtilsStringTableGetExtraData(
    IN  PVOID StringTable,
    IN  LONG  StringId,
    OUT PVOID ExtraData,
    IN  UINT  ExtraDataBufferSize
    )

/*++

Routine Description:

    Get arbitrary data associated with a string table entry.
    THIS ROUTINE DOES NOT DO LOCKING and IT DOES NOT HANDLE EXCEPTIONS!

Arguments:

    StringTable - supplies handle to string table containing the string
        whose associated data is to be returned.

    String - supplies the id of the string whose associated data is to be returned.

    ExtraData - receives the data associated with the string. Data is truncated
        to fit, if necessary.

    ExtraDataBufferSize - supplies the size in bytes of the buffer specified
        by ExtraData. If this value is smaller than the extra data size for
        the string table, data is truncated to fit.

Return Value:

    Boolean value indicating outcome.

--*/

{
    PSTRING_TABLE stringTable = StringTable;
    PSTRING_NODE stringNode;
    PVOID p;

    stringNode = (PSTRING_NODE)(stringTable->Data + StringId);
    p = stringNode->String + lstrlen(stringNode->String) + 1;

    CopyMemory(ExtraData,p,min(ExtraDataBufferSize,stringTable->ExtraDataSize));

    return(TRUE);
}


BOOL
pSetupStringTableSetExtraData(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN PVOID ExtraData,
    IN UINT  ExtraDataSize
    )

/*++

Routine Description:

    Associate arbitrary data with a string table entry.

Arguments:

    StringTable - supplies handle to string table containing the string
        with which the data is to be associated.

    String - supplies the id of the string with which the data is to be associated.

    ExtraData - supplies the data to be associated with the string.

    ExtraDataSize - specifies the size in bytes of the data. If the data is
        larger than the extra data size for this string table, then the routine fails.

Return Value:

    Boolean value indicating outcome.

--*/

{
    BOOL b = FALSE;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        b = _pSpUtilsStringTableSetExtraData(StringTable,StringId,ExtraData,ExtraDataSize);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return(b);
}


BOOL
_pSpUtilsStringTableSetExtraData(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN PVOID ExtraData,
    IN UINT  ExtraDataSize
    )

/*++

Routine Description:

    Associate arbitrary data with a string table entry.

Arguments:

    StringTable - supplies handle to string table containing the string
        with which the data is to be associated.

    String - supplies the id of the string with which the data is to be associated.

    ExtraData - supplies the data to be associated with the string.

    ExtraDataSize - specifies the size in bytes of the data. If the data is
        larger than the extra data size for this string table, then the routine fails.

Return Value:

    Boolean value indicating outcome.

--*/

{
    PSTRING_TABLE stringTable = StringTable;
    PSTRING_NODE stringNode;
    BOOL b;
    PVOID p;

    if(ExtraDataSize <= stringTable->ExtraDataSize) {

        stringNode = (PSTRING_NODE)(stringTable->Data + StringId);

        p = stringNode->String + lstrlen(stringNode->String) + 1;

        ZeroMemory(p,stringTable->ExtraDataSize);
        CopyMemory(p,ExtraData,ExtraDataSize);

        b = TRUE;

    } else {
        b = FALSE;
    }

    return(b);
}


LONG
_pSpUtilsStringTableAddString(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags,
    IN     PVOID ExtraData,     OPTIONAL
    IN     UINT  ExtraDataSize  OPTIONAL
    )

/*++

Routine Description:

    Adds a string to the string table if the string is not already
    in the string table.  (Does not do locking!)

    If the string is to be added case-insensitively, then it is
    lower-cased, and added case-sensitively.  Since lower-case characters
    are 'less than' lower case ones (according to lstrcmp), this ensures that
    a case-insensitive string will always appear in front of any of its
    case-sensitive counterparts.  This ensures that we always find the correct
    string ID for things like section names.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be added

    Flags - supplies flags controlling how the string is to be added, and
        whether the caller-supplied buffer may be modified.  May be a combination
        of the following values:

        STRTAB_CASE_INSENSITIVE  - Add the string case-insensitively.  The
                                   specified string will be added to the string
                                   table as all lower-case.  This flag is overridden
                                   if STRTAB_CASE_SENSITIVE is specified.

        STRTAB_CASE_SENSITIVE    - Add the string case-sensitively.  This flag
                                   overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE  - The caller-supplied buffer may be written to during
                                   the string-addition process.  Specifying this flag
                                   improves the performance of this API for case-
                                   insensitive string additions.  This flag is ignored
                                   for case-sensitive string additions.

        STRTAB_NEW_EXTRADATA     - if the string already exists in the table
                                   and ExtraData is specified (see below) then
                                   the new ExtraData overwrites any existing extra data.
                                   Otherwise any existing extra data is left alone.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

    ExtraData - if supplied, specifies extra data to be associated with the string
        in the string table. If the string already exists in the table, the Flags
        field controls whether the new data overwrites existing data already
        associated with the string.

    ExtraDataSize - if ExtraData is supplied, then this value supplies the size
        in bytes of the buffer pointed to by ExtraData. If the data is larger than
        the extra data size for the string table, the routine fails.

Return Value:

    The return value uniquely identifes the string within the string table.
    It is -1 if the string was not in the string table but could not be added
    (out of memory).

--*/

{
    LONG rc;
    PSTRING_TABLE stringTable = StringTable;
    DWORD StringLength;
    DWORD HashValue;
    PSTRING_NODE PreviousNode,NewNode;
    DWORD SpaceRequired;
    PTSTR TempString = String;
    BOOL FreeTempString = FALSE;
    PVOID p;
    DWORD sz;

    if (!(Flags & STRTAB_CASE_SENSITIVE)) {
        //
        // not case sensitive ( = insensitive)
        //
        if (!(Flags & STRTAB_ALREADY_LOWERCASE)) {
            //
            // not already lowercase
            //
            if (!(Flags & STRTAB_BUFFER_WRITEABLE)) {
                //
                // not writable
                //
                //
                // Then the string is to be added case-insensitively, but the caller
                // doesn't want us to write to their buffer.  Allocate one of our own.
                //
                if (TempString = pSetupDuplicateString(String)) {
                    FreeTempString = TRUE;
                } else {
                    //
                    // We couldn't allocate space for our duplicated string.  Since we'll
                    // only consider exact matches (where the strings are all lower-case),
                    // we're stuck, since we can't lower-case the buffer in place.
                    //
                    return -1;
                }
            }
            //
            // Lower-case the buffer.
            //
#ifndef UNICODE
            _mbslwr (TempString);
#else
            CharLower(TempString);
#endif
        }

        //
        // we know that the string is now lower-case
        // we no longer need "Writable" flag
        // searches will be case sensitive
        //
        Flags &= ~ (STRTAB_BUFFER_WRITEABLE | STRTAB_CASE_INSENSITIVE);
        Flags |= STRTAB_CASE_SENSITIVE | STRTAB_ALREADY_LOWERCASE;
    }

    try {
        if (ExtraData && (ExtraDataSize > stringTable->ExtraDataSize)) {
            //
            // Force us into the exception handler -- sort of a non-local goto.
            //
            RaiseException(0,0,0,NULL);
        }

        //
        // The string might already be in there.
        //
        rc = _pSpUtilsStringTableLookUpString(
                                     StringTable,
                                     TempString,
                                     &StringLength,
                                     &HashValue,
                                     &PreviousNode,
                                     Flags,
                                     NULL,
                                     0
                                     );

        if (rc != -1) {
            if (ExtraData && (Flags & STRTAB_NEW_EXTRADATA)) {
                //
                // Overwrite extra data. We know the data is small enough to fit
                // because we checked for this above.
                //
                p = PreviousNode->String + StringLength + 1;

                ZeroMemory(p,stringTable->ExtraDataSize);
                CopyMemory(p,ExtraData,ExtraDataSize);
            }

            if (FreeTempString) {
                pSetupFree(TempString);
            }
            return (rc);
        }

        //
        // Figure out how much space is required to hold this entry.
        // This is the size of a STRING_NODE plus the length of the string
        // plus space for extra per-element data.
        //
        SpaceRequired = offsetof(STRING_NODE,String)
                        + ((StringLength+1)*sizeof(TCHAR))
                        + stringTable->ExtraDataSize;

        //
        // Make sure things stay aligned within the table
        //
        if (SpaceRequired % sizeof(DWORD)) {
            SpaceRequired += sizeof(DWORD) - (SpaceRequired % sizeof(DWORD));
        }

        while(stringTable->DataSize + SpaceRequired > stringTable->BufferSize) {
            //
            // Grow the string table.
            // do this exponentially so that tables with a lot of items
            // added won't cause lots of reallocs
            //
            sz = STRING_TABLE_NEW_SIZE(stringTable->BufferSize);
            if (sz < stringTable->BufferSize) {
                sz = stringTable->DataSize + SpaceRequired;
            }
            p = pSetupReallocWithTag(stringTable->Data,sz,MEMTAG_STRINGDATA);
            if (!p) {
                //
                // we've run out of room, this could be because we asked
                // for too big of a re-alloc
                // if we're in this state, we're probably going to
                // have problems later anyway, but for now, let's
                // try and proceed with exactly what we need
                //
                sz = stringTable->DataSize + SpaceRequired;
                p = pSetupReallocWithTag(stringTable->Data,sz,MEMTAG_STRINGDATA);
                if (!p) {
                    //
                    // nope, this didn't help
                    //
                    if (FreeTempString) {
                        pSetupFree(TempString);
                    }
                    return (-1);
                }
            }
            //
            // Adjust previous node pointer.
            //
            if (PreviousNode) {
                PreviousNode = (PSTRING_NODE)((PUCHAR)p + ((PUCHAR)PreviousNode-(PUCHAR)stringTable->Data));
            }
            stringTable->Data = p;
            stringTable->BufferSize = sz;
        }
        //
        // Stick the string and extra data, if any, in the string table buffer.
        //
        NewNode = (PSTRING_NODE)(stringTable->Data + stringTable->DataSize);

        if (PreviousNode) {
            NewNode->NextOffset = PreviousNode->NextOffset;
            PreviousNode->NextOffset = (LONG)((LONG_PTR)NewNode - (LONG_PTR)stringTable->Data);
        } else {
            NewNode->NextOffset = ((PLONG)(stringTable->Data))[HashValue];
            ((PLONG)(stringTable->Data))[HashValue] = (LONG)((LONG_PTR)NewNode - (LONG_PTR)stringTable->Data);
        }

        lstrcpy(NewNode->String,TempString);

        p = NewNode->String + StringLength + 1;

        ZeroMemory(p,stringTable->ExtraDataSize);
        if (ExtraData) {
            CopyMemory(p,ExtraData,ExtraDataSize);
        }

        stringTable->DataSize += SpaceRequired;

        rc = (LONG)((LONG_PTR)NewNode - (LONG_PTR)stringTable->Data);

    }except(EXCEPTION_EXECUTE_HANDLER) {
        rc = -1;
    }

    if (FreeTempString) {
        pSetupFree(TempString);
    }

    return rc;
}


LONG
pSetupStringTableAddString(
    IN PVOID StringTable,
    IN PTSTR String,
    IN DWORD Flags
    )

/*++

Routine Description:

    Adds a string to the string table if the string is not already
    in the string table.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be added

    Flags - supplies flags controlling how the string is to be added, and
        whether the caller-supplied buffer may be modified.  May be a combination
        of the following values:

        STRTAB_CASE_INSENSITIVE - Add the string case-insensitively.  The
                                  specified string will be added to the string
                                  table as all lower-case.  This flag is overridden
                                  if STRTAB_CASE_SENSITIVE is specified.

        STRTAB_CASE_SENSITIVE   - Add the string case-sensitively.  This flag
                                  overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE - The caller-supplied buffer may be written to during
                                  the string-addition process.  Specifying this flag
                                  improves the performance of this API for case-
                                  insensitive string additions.  This flag is ignored
                                  for case-sensitive string additions.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

Return Value:

    The return value uniquely identifes the string within the string table.
    It is -1 if the string was not in the string table but could not be added
    (out of memory).

--*/

{
    LONG rc = -1;
    BOOL locked = FALSE;
    DWORD PrivateFlags;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        PrivateFlags = _StringTableCheckFlags(Flags);

        rc = _pSpUtilsStringTableAddString(StringTable, String, PrivateFlags, NULL, 0);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        rc = -1;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return(rc);
}


LONG
pSetupStringTableAddStringEx(
    IN PVOID StringTable,
    IN PTSTR String,
    IN DWORD Flags,
    IN PVOID ExtraData,     OPTIONAL
    IN UINT  ExtraDataSize  OPTIONAL
    )

/*++

Routine Description:

    Adds a string to the string table if the string is not already
    in the string table.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be added

    Flags - supplies flags controlling how the string is to be added, and
        whether the caller-supplied buffer may be modified.  May be a combination
        of the following values:

        STRTAB_CASE_INSENSITIVE - Add the string case-insensitively.  The
                                  specified string will be added to the string
                                  table as all lower-case.  This flag is overridden
                                  if STRTAB_CASE_SENSITIVE is specified.

        STRTAB_CASE_SENSITIVE   - Add the string case-sensitively.  This flag
                                  overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE - The caller-supplied buffer may be written to during
                                  the string-addition process.  Specifying this flag
                                  improves the performance of this API for case-
                                  insensitive string additions.  This flag is ignored
                                  for case-sensitive string additions.

        STRTAB_NEW_EXTRADATA    - If the string already exists in the table
                                  and ExtraData is specified (see below) then
                                  the new ExtraData overwrites any existing extra data.
                                  Otherwise any existing extra data is left alone.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

    ExtraData - if supplied, specifies extra data to be associated with the string
        in the string table. If the string already exists in the table, the Flags
        field controls whether the new data overwrites existing data already
        associated with the string.

    ExtraDataSize - if ExtraData is supplied, then this value supplies the size
        in bytes of the buffer pointed to by ExtraData. If the data is larger than
        the extra data size for the string table, the routine fails.

Return Value:

    The return value uniquely identifes the string within the string table.
    It is -1 if the string was not in the string table but could not be added
    (out of memory).

--*/

{
    LONG rc = -1;
    BOOL locked = FALSE;
    DWORD PrivateFlags;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        PrivateFlags = _StringTableCheckFlags(Flags);

        rc = _pSpUtilsStringTableAddString(StringTable, String, PrivateFlags, ExtraData, ExtraDataSize);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        rc = -1;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return (rc);
}


BOOL
pSetupStringTableEnum(
    IN  PVOID                StringTable,
    OUT PVOID                ExtraDataBuffer,     OPTIONAL
    IN  UINT                 ExtraDataBufferSize, OPTIONAL
    IN  PSTRTAB_ENUM_ROUTINE Callback,
    IN  LPARAM               lParam               OPTIONAL
    )

/*++

Routine Description:

    For every string in a string table, inform a callback routine of
    the stirng's id, it's value, and any associated data.

Arguments:

    StringTable - supplies a pointer to the string table to be enumerated.

    ExtraDataBuffer - supplies the address of a buffer to be passed to
        the callback routine for each string, which will be filled in
        with the associated data of each string.

    ExtraDataBufferSize - if ExtraDataBuffer is specified then this
        supplies the size of that buffer in bytes. If this value is
        smaller than the size of the extra data for the string table,
        the enumeration fails.

    Callback - supplies the routine to be notified of each string.

    lParam - supplies an optional parameter meaningful to the caller
        which is passed on to the callback unchanged.

Return Value:

    Boolean value indicating outcome. TRUE unless ExtraDataBufferSize
    is too small.

--*/

{
    BOOL b = FALSE;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        b = _pSpUtilsStringTableEnum(StringTable,ExtraDataBuffer,ExtraDataBufferSize,Callback,lParam);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }

    return(b);
}


BOOL
_pSpUtilsStringTableEnum(
    IN  PVOID                StringTable,
    OUT PVOID                ExtraDataBuffer,     OPTIONAL
    IN  UINT                 ExtraDataBufferSize, OPTIONAL
    IN  PSTRTAB_ENUM_ROUTINE Callback,
    IN  LPARAM               lParam               OPTIONAL
    )

/*++

Routine Description:

    For every string in a string table, inform a callback routine of
    the stirng's id, its value, and any associated data.

    THIS ROUTINE DOES NOT DO LOCKING.

Arguments:

    StringTable - supplies a pointer to the string table to be enumerated.

    ExtraDataBuffer - supplies the address of a buffer to be passed to
        the callback routine for each string, which will be filled in
        with the associated data of each string.

    ExtraDataBufferSize - if ExtraDataBuffer is specified then this
        supplies the size of that buffer in bytes. If this value is
        smaller than the size of the extra data for the string table,
        the enumeration fails.

    Callback - supplies the routine to be notified of each string.

    lParam - supplies an optional parameter meaningful to the caller
        which is passed on to the callback unchanged.

Return Value:

    Boolean value indicating outcome. TRUE unless ExtraDataBufferSize
    is too small.

--*/

{
    UINT u;
    PSTRING_TABLE stringTable = StringTable;
    PSTRING_NODE stringNode;
    LONG FirstOffset;
    BOOL b;

    //
    // Validate buffer size.
    //
    if(ExtraDataBuffer && (ExtraDataBufferSize < stringTable->ExtraDataSize)) {
        return(FALSE);
    }

    for(b=TRUE,u=0; b && (u<HASH_BUCKET_COUNT); u++) {

        FirstOffset = ((PLONG)stringTable->Data)[u];

        if(FirstOffset == -1) {
            continue;
        }

        stringNode = (PSTRING_NODE)(stringTable->Data + FirstOffset);

        do {

            if(ExtraDataBuffer) {
                CopyMemory(
                    ExtraDataBuffer,
                    stringNode->String + lstrlen(stringNode->String) + 1,
                    stringTable->ExtraDataSize
                    );
            }

            b = Callback(
                    StringTable,
                    (LONG)((PUCHAR)stringNode - stringTable->Data),
                    stringNode->String,
                    ExtraDataBuffer,
                    ExtraDataBuffer ? stringTable->ExtraDataSize : 0,
                    lParam
                    );

            stringNode = (stringNode->NextOffset == -1)
                       ? NULL
                       : (PSTRING_NODE)(stringTable->Data + stringNode->NextOffset);

        } while(b && stringNode);
    }

    return(TRUE);
}


PTSTR
_pSpUtilsStringTableStringFromId(
    IN PVOID StringTable,
    IN LONG  StringId
    )

/*++

Routine Description:

    Given a string ID returned when a string was added or looked up,
    return a pointer to the actual string.  (This is exactly the same
    as pSetupStringTableStringFromId, except that it doesn't do locking.)

Arguments:

    StringTable - supplies a pointer to the string table containing the
        string to be retrieved.

    StringId - supplies a string id returned from pSetupStringTableAddString
        or pSetupStringTableLookUpString.

Return Value:

    Pointer to string data. The caller must not write into or otherwise
    alter the string.

--*/

{
    return ((PSTRING_NODE)(((PSTRING_TABLE)StringTable)->Data + StringId))->String;
}


PTSTR
pSetupStringTableStringFromId(
    IN PVOID StringTable,
    IN LONG  StringId
    )

/*++

Routine Description:

    Given a string ID returned when a string was added or looked up,
    return a pointer to the actual string.

Arguments:

    StringTable - supplies a pointer to the string table containing the
        string to be retrieved.

    StringId - supplies a string id returned from pSetupStringTableAddString
        or pSetupStringTableLookUpString.

Return Value:

    Pointer to string data. The caller must not write into or otherwise
    alter the string.

    This function is fundamentally not thread-safe
    since the ptr we return could be modified by another thread
    if string table is accessed by more than one thread
    Hence new API below pSetupStringTableStringFromIdEx

--*/

{
    PTSTR p = NULL;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        p = ((PSTRING_NODE)(((PSTRING_TABLE)StringTable)->Data + StringId))->String;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        p = NULL;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        locked = locked;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }

    return(p);
}


BOOL
pSetupStringTableStringFromIdEx(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN OUT PTSTR pBuffer,
    IN OUT PULONG pBufSize
    )

/*++

Routine Description:

    Given a string ID returned when a string was added or looked up,
    return a pointer to the actual string.

Arguments:

    StringTable - supplies a pointer to the string table containing the
        string to be retrieved.

    StringId - supplies a string id returned from pSetupStringTableAddString
        or pSetupStringTableLookUpString.

    pBuffer - points to a buffer that will be filled out with the string
        to be retrieved

    pBufSize - supplies a pointer to an input/output parameter that contains
        the size of the buffer on entry, and the number of chars. written on
        exit.

Return Value:

    TRUE if the string was written. pBufSize contains the length of the string
    FALSE if the buffer was invalid, or the string ID was invalid, or the buffer
          wasn't big enough. If pBufSize non-zero, then it is the required bufsize.
          currently caller can tell the difference between invalid param and buffer
          size by checking pBufSize

--*/

{
    PTSTR p;
    ULONG len;
    PSTRING_TABLE stringTable = (PSTRING_TABLE)StringTable;
    DWORD status = ERROR_INVALID_DATA;
    BOOL locked = FALSE;

    try {
        if  (!pBufSize) {
            status = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(!LockTable(stringTable)) {
            if (pBuffer != NULL && *pBufSize > 0) {
                pBuffer[0]=0;
            }
            *pBufSize = 0;
            status = ERROR_INVALID_HANDLE;
            leave;
        }
        locked = TRUE;

        //
        // CFGMGR calls this with an ID passed by it's caller
        // we have to check bounds here (while table is locked)
        // the check has to do:
        //
        // (1) StringId must be > 0 (0 is hash-bucket 0)
        // (2) StringId must be < size of string table
        // This should catch common errors but isn't perfect.
        //
        // the check is here since Id validity requires access to Opaque pointer
        //
        if(StringId <= 0 || StringId >= (LONG)(stringTable->DataSize)) {
            if (pBuffer != NULL && *pBufSize > 0) {
                pBuffer[0]=0;
            }
            *pBufSize = 0;
            status = ERROR_INVALID_PARAMETER;
            leave;
        }

        len = lstrlen( ((PSTRING_NODE)(stringTable->Data + StringId))->String);
        len ++; // account for terminating NULL

        if (len > *pBufSize || pBuffer == NULL) {
            if (pBuffer != NULL && *pBufSize > 0) {
                pBuffer[0]=0;
            }
            *pBufSize = len;
            status = ERROR_INSUFFICIENT_BUFFER;
            leave;

        }
        lstrcpy (pBuffer,((PSTRING_NODE)(stringTable->Data + StringId))->String);

        *pBufSize = len;

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_INVALID_DATA;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }

    if(status == NO_ERROR) {
        //
        // if success, return TRUE without modifying error code
        //
        return TRUE;
    }
    //
    // if error, we may be interested in cause
    //
    // SetLastError(status); // left disabled till I know this is safe to do
    return FALSE;
}

VOID
_pSpUtilsStringTableTrim(
    IN PVOID StringTable
    )

/*++

Routine Description:

    Free any memory currently allocated for the string table
    but not currently used.

    This is useful after all strings have been added to a string table
    because the string table grows by a fixed block size as it's being built.

    THIS ROUTINE DOES NOT DO LOCKING!

Arguments:

    StringTable - supplies a string table handle returned from
        a call to pSetupStringTableInitialize().

Return Value:

    None.

--*/

{
    PSTRING_TABLE stringTable = StringTable;
    PVOID p;

    //
    // If the realloc failed the original block is not freed,
    // so we don't really care.
    //

    if(p = pSetupReallocWithTag(stringTable->Data, stringTable->DataSize, MEMTAG_STRINGDATA)) {
        stringTable->Data = p;
        stringTable->BufferSize = stringTable->DataSize;
    }
}


PVOID
pSetupStringTableInitialize(
    VOID
    )

/*++

Routine Description:

    Create and initialize a string table.

Arguments:

    None.

Return Value:

    NULL if the string table could not be created (out of memory).
    Otherwise returns an opaque value that references the string
    table in other StringTable calls.

Remarks:

    This routine returns a string table with synchronization locks
    required by all public StringTable APIs.  If the string table
    is to be enclosed in a structure that has its own locking
    (e.g., HINF, HDEVINFO), then the private version of this API
    may be called, which will not create locks for the string table.

--*/

{
    PSTRING_TABLE StringTable;

    if(StringTable = (PSTRING_TABLE)_pSpUtilsStringTableInitialize(0)) {

        if(InitializeSynchronizedAccess(&StringTable->Lock)) {
            return StringTable;
        }

        _pSpUtilsStringTableDestroy(StringTable);
    }

    return NULL;
}


PVOID
pSetupStringTableInitializeEx(
    IN UINT ExtraDataSize,  OPTIONAL
    IN UINT Reserved
    )

/*++

Routine Description:

    Create and initialize a string table, where each string can have
    some arbitrary data associated with it.

Arguments:

    ExtraDataSize - supplies maximum size of arbitrary data that can be
        associated with strings in the string table that will be created.

    Reserved - unused, must be 0.

Return Value:

    NULL if the string table could not be created (out of memory).
    Otherwise returns an opaque value that references the string
    table in other StringTable calls.

Remarks:

    This routine returns a string table with synchronization locks
    required by all public StringTable APIs.  If the string table
    is to be enclosed in a structure that has its own locking
    (e.g., HINF, HDEVINFO), then the private version of this API
    may be called, which will not create locks for the string table.

--*/

{
    PSTRING_TABLE StringTable;

    if(Reserved) {
        return(NULL);
    }

    if(StringTable = (PSTRING_TABLE)_pSpUtilsStringTableInitialize(ExtraDataSize)) {

        if(InitializeSynchronizedAccess(&StringTable->Lock)) {
            return StringTable;
        }

        _pSpUtilsStringTableDestroy(StringTable);
    }

    return NULL;
}


PVOID
_pSpUtilsStringTableInitialize(
    IN UINT ExtraDataSize   OPTIONAL
    )

/*++

Routine Description:

    Create and initialize a string table. Each string can optionally have
    some arbitrary data associated with it.

    THIS ROUTINE DOES NOT INITIALIZE STRING TABLE SYNCHRONIZATION LOCKS!

Arguments:

    ExtraDataSize - supplies maximum size of arbitrary data that can be
        associated with strings in the string table that will be created.

Return Value:

    NULL if the string table could not be created (out of memory).
    Otherwise returns an opaque value that references the string
    table in other StringTable calls.

Remarks:

    The string table returned from this API may not be used as-is with the
    public StringTable APIs--it must have its synchronization locks initialized
    by the public form of this API.

--*/

{
    UINT u;
    PSTRING_TABLE stringTable;
    LCID locale;

    //
    // Allocate a string table
    //
    if(stringTable = pSetupMallocWithTag(sizeof(STRING_TABLE),MEMTAG_STRINGTABLE)) {

        ZeroMemory(stringTable,sizeof(STRING_TABLE));

        stringTable->ExtraDataSize = ExtraDataSize;
        locale = GetThreadLocale();
        //
        // changes here may need to be reflected in _pSpUtilsStringTableInitializeFromMemoryMappedFile
        //
        if(PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_TURKISH) {
            //
            // Turkish has a problem with i and dotted i's.
            // Do comparison in English (default sort)
            //
            stringTable->Locale = MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT);
        } else {
            //
            // string tables always use default sorting algorithm
            //
            stringTable->Locale = MAKELCID(LANGIDFROMLCID(locale),SORT_DEFAULT);
        }

        //
        // Allocate space for the string table data.
        //
        if(stringTable->Data = pSetupMallocWithTag(STRING_TABLE_INITIAL_SIZE,MEMTAG_STRINGDATA)) {

            stringTable->BufferSize = STRING_TABLE_INITIAL_SIZE;

            //
            // Initialize the hash table
            //
            for(u=0; u<HASH_BUCKET_COUNT; u++) {
                ((PLONG)(stringTable->Data))[u] = -1;
            }

            //
            // Set the DataSize to the size of the StringNodeOffset list, so
            // we'll start adding new strings after it.
            //
            stringTable->DataSize = HASH_BUCKET_COUNT * sizeof(LONG);

            return(stringTable);
        }

        pSetupFreeWithTag(stringTable,MEMTAG_STRINGTABLE);
    }

    return(NULL);
}


VOID
pSetupStringTableDestroy(
    IN PVOID StringTable
    )

/*++

Routine Description:

    Destroy a string table, freeing all resources it uses.

Arguments:

    StringTable - supplies a string table handle returned from
        a call to pSetupStringTableInitialize().

Return Value:

    None.

--*/

{
    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }

        DestroySynchronizedAccess(&(((PSTRING_TABLE)StringTable)->Lock));

        _pSpUtilsStringTableDestroy(StringTable);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
    }
}


VOID
_pSpUtilsStringTableDestroy(
    IN PVOID StringTable
    )

/*++

Routine Description:

    Destroy a string table, freeing all resources it uses.
    THIS ROUTINE DOES NOT DO LOCKING!

Arguments:

    StringTable - supplies a string table handle returned from
        a call to pSetupStringTableInitialize() or _pSpUtilsStringTableInitializeFromMemoryMappedFile

Return Value:

    None.

--*/

{
    if (((PSTRING_TABLE)StringTable)->BufferSize) {
        pSetupFreeWithTag(((PSTRING_TABLE)StringTable)->Data,MEMTAG_STRINGDATA);
        pSetupFreeWithTag(StringTable,MEMTAG_STRINGTABLE);
    } else {
        pSetupFreeWithTag(StringTable,MEMTAG_STATICSTRINGTABLE);
    }
}


PVOID
pSetupStringTableDuplicate(
    IN PVOID StringTable
    )

/*++

Routine Description:

    Create an independent duplicate of a string table.

Arguments:

    StringTable - supplies a string table handle of string table to duplicate.

Return Value:

    Handle for new string table, NULL if out of memory.

--*/

{
    PSTRING_TABLE New = NULL;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        if(New = (PSTRING_TABLE)_pSpUtilsStringTableDuplicate(StringTable)) {

            if(!InitializeSynchronizedAccess(&New->Lock)) {
                _pSpUtilsStringTableDestroy(New);
                New = NULL;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        New = NULL;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }

    return New;
}


PVOID
_pSpUtilsStringTableDuplicate(
    IN PVOID StringTable
    )

/*++

Routine Description:

    Create an independent duplicate of a string table.
    THIS ROUTINE DOES NOT DO LOCKING!

Arguments:

    StringTable - supplies a string table handle of string table to duplicate.

Return Value:

    Handle for new string table, NULL if out of memory or buffer copy failure.

Remarks:

    This routine does not initialize synchronization locks for the duplicate--these
    fields are initialized to NULL.

--*/

{
    PSTRING_TABLE New;
    PSTRING_TABLE stringTable = StringTable;
    BOOL Success;

    if(New = pSetupMallocWithTag(sizeof(STRING_TABLE),MEMTAG_STRINGTABLE)) {

        CopyMemory(New,StringTable,sizeof(STRING_TABLE));

        //
        // Allocate space for the string table data.
        //
        if(New->Data = pSetupMallocWithTag(stringTable->DataSize,MEMTAG_STRINGDATA)) {
            //
            // Surround memory copy in try/except, since we may be dealing with
            // a string table contained in a PNF, in which case the buffer is
            // in a memory-mapped file.
            //
            Success = TRUE; // assume success unless we get an inpage error...
            try {
                CopyMemory(New->Data, stringTable->Data, stringTable->DataSize);
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Success = FALSE;
            }

            if(Success) {
                New->BufferSize = New->DataSize;
                ZeroMemory(&New->Lock, sizeof(MYLOCK));
                return New;
            }

            pSetupFreeWithTag(New->Data,MEMTAG_STRINGDATA);
        }

        pSetupFreeWithTag(New,MEMTAG_STRINGTABLE);
    }

    return NULL;
}

PVOID
_pSpUtilsStringTableInitializeFromMemoryMappedFile(
    IN PVOID DataBlock,
    IN DWORD DataBlockSize,
    IN LCID  Locale,
    IN UINT ExtraDataSize
    )
{
    PSTRING_TABLE StringTable;
    BOOL WasLoaded = TRUE;

    //
    // Allocate a string table
    //
    if(!(StringTable = pSetupMallocWithTag(sizeof(STRING_TABLE),MEMTAG_STATICSTRINGTABLE))) {
        return NULL;
    }

    try {
        StringTable->Data = (PUCHAR)DataBlock;
        StringTable->DataSize = DataBlockSize;
        StringTable->BufferSize = 0; // no allocated buffer
        //
        // Clear the Lock structure, because mem-mapped string tables can only be accessed
        // internally
        //
        StringTable->Lock.Handles[0] = StringTable->Lock.Handles[1] = NULL;
        StringTable->ExtraDataSize = ExtraDataSize;

        if(PRIMARYLANGID(LANGIDFROMLCID(Locale)) == LANG_TURKISH) {
            //
            // Turkish has a problem with i and dotted i's.
            // Do comparison in English.
            //
            StringTable->Locale = MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT);
        } else {
            StringTable->Locale = MAKELCID(LANGIDFROMLCID(Locale),SORT_DEFAULT);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        WasLoaded = FALSE;
    }

    if(WasLoaded) {
        return StringTable;
    } else {
        pSetupFreeWithTag(StringTable,MEMTAG_STATICSTRINGTABLE);
        return NULL;
    }
}

DWORD
_pSpUtilsStringTableGetDataBlock(
    IN  PVOID  StringTable,
    OUT PVOID *StringTableBlock
    )
{
    *StringTableBlock = (PVOID)(((PSTRING_TABLE)StringTable)->Data);

    return ((PSTRING_TABLE)StringTable)->DataSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\test\cmtest.h ===
//
// Menu defines
//
#define IDM_CONNECT_TEST      1000
#define IDM_DEVICE_LIST       1001
#define IDM_SERVICE_LIST      1002
#define IDM_RELATIONS_LIST    1003
#define IDM_DEVICE_OPS        1004
#define IDM_DEVNODE_KEY       1005
#define IDM_CLASS_LIST        1006
#define IDM_REGRESSION        1007
#define IDM_EXIT              1008

#define IDM_INIT_DETECTION    1100
#define IDM_REPORTLOGON       1101
#define IDM_PNPISA_DETECT     1102
#define IDM_DEVINSTALL        1103
#define IDM_SET_ASSOCIATIONS  1104
#define IDM_CLEAR_ASSOCIATIONS 1105
#define IDM_GET_PROPERTIES    1106
#define IDM_REGISTER_NOTIFY   1107
#define IDM_UNREGISTER_NOTIFY 1108

//
// CONNECT_DIALOG IDs
//
#define CONNECT_DIALOG                 2000
#define ID_RAD_LOCAL                   2001
#define ID_RAD_REMOTE                  2002
#define ID_ED_MACHINE                  2003

//
// DEVLIST_DIALOG IDs
//
#define DEVLIST_DIALOG                 2100
#define ID_LB_ENUMERATORS              2101
#define ID_LB_DEVICES                  2102
#define ID_LB_INSTANCES                2103

//
// DEVICE_DIALOG IDs
//
#define DEVICE_DIALOG                  2200
#define ID_LB_DEVICEIDS                2202
#define ID_BT_PARENT                   2203
#define ID_BT_CHILD                    2204
#define ID_BT_SIBLING                  2205
#define ID_ST_RELATED                  2206
#define ID_BT_REGPROP                  2207
#define ID_BT_SOFTWAREKEY              2208
#define ID_BT_DISABLE                  2209
#define ID_BT_ENABLE                   2210
#define ID_BT_MOVETO                   2211
#define ID_BT_SETUP                    2212
#define ID_BT_QUERY_REMOVE             2213
#define ID_BT_REMOVE                   2214
#define ID_BT_REENUMERATE              2215
#define ID_BT_HWPROFFLAG               2216
#define ID_BT_GETSTATUS                2217
#define ID_BT_SETPROBLEM               2218
#define ID_ST_STATUS                   2219
#define ID_ST_PROBLEM                  2220
#define ID_BT_RESOURCEPICKER           2221
#define ID_BT_CREATE                   2222

//
// CLASS_DIALOG IDs
//
#define CLASS_DIALOG                   2300
#define ID_LB_CLASSES                  2301
#define ID_BT_CLASSNAME                2302
#define ID_BT_CLASSKEY                 2303
#define ID_ST_CLASSNAME                2304

//
// CLASSKEY_DIALOG IDs
//
#define CLASSKEY_DIALOG                2400
#define ID_CHK_ALL_ACCESS              2401
#define ID_CHK_CREATE_LINK             2402
#define ID_CHK_CREATE_SUB_KEY          2403
#define ID_CHK_ENUMERATE_SUB_KEYS      2404
#define ID_CHK_EXECUTE                 2405
#define ID_CHK_NOTIFY                  2406
#define ID_CHK_QUERY_VALUE             2407
#define ID_CHK_READ                    2408
#define ID_CHK_SET_VALUE               2409
#define ID_CHK_WRITE                   2410
#define ID_CHK_CREATE                  2411
#define ID_ED_VALUENAME                2412
#define ID_ED_VALUEDATA                2413
#define ID_BT_QUERYVALUE               2414
#define ID_BT_SETVALUE                 2415
#define ID_ST_CLASSGUID                2416

//
// SOFTWAREKEY_DIALOG IDs
//
#define SOFTWAREKEY_DIALOG             2500
#define ID_ED_SUBKEY                   2501
#define ID_RAD_MACHINE                 2502
#define ID_RAD_USER                    2503
#define ID_RAD_CONFIG                  2504
#define ID_ED_PROFILE                  2505
#define ID_BT_CLEAR                    2506

//
// DEVNODEKEY_DIALOG IDs
//
#define DEVNODEKEY_DIALOG              2600
#define ID_RD_HW                       2601
#define ID_RD_SW                       2602
#define ID_RD_USER                     2603
#define ID_RD_CONFIG                   2604
#define ID_RD_NEITHER                  2605
#define ID_BT_OPENDEVKEY               2606
#define ID_BT_DELDEVKEY                2607
#define ID_ED_DEVICEID                 2608

//
// CREATE_DIALOG IDs
//
#define CREATE_DIALOG                  2700
#define ID_RD_NORMAL                   2701
#define ID_RD_NOWAIT                   2702
#define ID_CHK_PHANTOM                 2703
#define ID_ST_PARENT                   2704
#define ID_CHK_GENERATEID              2705

//
// SERVICES_DIALOG IDs
//
#define SERVICE_DIALOG                 2800
#define ID_ED_SERVICE                  2801
#define ID_LB_SERVICE                  2802
#define ID_BT_SERVICE                  2803

//
// REGRESSION_DIALOG IDs
//
#define REGRESSION_DIALOG              2900
#define ID_LB_REGRESSION               2901
#define ID_CHK_RANGE                   2902
#define ID_CHK_CLASS                   2903
#define ID_CHK_TRAVERSE                2904
#define ID_CHK_HWPROF                  2905
#define ID_CHK_DEVLIST                 2906
#define ID_CHK_LOGCONF                 2907
#define ID_BT_START                    2908
#define ID_CHK_PROPERTIES              2909
#define ID_CHK_DEVCLASS                2910

//
// RELATIONS_DIALOG IDs
//
#define RELATIONS_DIALOG               3000
#define ID_LB_TARGETS                  3001
#define ID_LB_RELATIONS                3002
#define ID_BT_BUS                      3003
#define ID_BT_REMOVAL                  3004
#define ID_BT_EJECTION                 3005
#define ID_BT_POWER                    3006

//
// Prototypes
//

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
INT_PTR CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ConnectDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DeviceListDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DeviceDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ClassDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ClassKeyDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK SoftwareKeyDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK DevKeyDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK CreateDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ServiceListDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK RelationsListDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK RegressionDlgProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\test\devinst.c ===
/**------------------------------------------------------------------
   devinst.c
------------------------------------------------------------------**/


//
// Includes
//
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include <malloc.h>

#include "cmtest.h"

//
// Private Prototypes
//

FillRelationsListBox(
    HWND  hDlg,
    ULONG RelationType
    );

BOOL
FillEnumeratorListBox(
   HWND hDlg
   );

BOOL
FillDeviceListBox(
   HWND hDlg
   );
BOOL
FillInstanceListBox(
   HWND hDlg
   );

BOOL
FillDeviceInstanceListBox(
   HWND hDlg
   );

BOOL
GetSelectedEnumerator(
   HWND   hDlg,
   LPTSTR szDevice
   );

BOOL
GetSelectedDevice(
   HWND   hDlg,
   LPTSTR szDevice
   );

BOOL
GetSelectedDevNode(
   HWND     hDlg,
   PDEVNODE pdnDevNode
   );

VOID
CallPnPIsaDetect(
    HWND   hDlg,
    LPTSTR pszDevice
    );

//
// Globals
//
extern HINSTANCE hInst;
extern TCHAR     szDebug[MAX_PATH];
extern TCHAR     szAppName[MAX_PATH];
extern HMACHINE  hMachine;


/**----------------------------------------------------------------------**/
INT_PTR CALLBACK
DeviceListDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDevice[MAX_DEVICE_ID_LEN+1];
   DEVNODE     dnDevNode;
   ULONG       ulStatus, ulProblem;

   switch (message) {
      case WM_SHOWWINDOW:
         FillEnumeratorListBox(hDlg);
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {
            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;

            case ID_LB_ENUMERATORS:
               if (HIWORD(wParam) == LBN_SELCHANGE) {
                  FillDeviceListBox(hDlg);
               }
               break;

         case ID_LB_DEVICES:
            if (HIWORD(wParam) == LBN_SELCHANGE) {
               FillInstanceListBox(hDlg);
            }
            break;


      }
      break;
   }
   return (FALSE);

} // DeviceListDlgProc


/**----------------------------------------------------------------------**/
INT_PTR CALLBACK
ServiceListDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szService[MAX_PATH];
   LPTSTR      pBuffer, p;
   ULONG       ulSize;

   switch (message) {

      case WM_COMMAND:
         switch(LOWORD(wParam)) {
            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;

            case ID_BT_SERVICE:
               GetDlgItemText(hDlg, ID_ED_SERVICE, szService, MAX_PATH);

               //
               // get device list size for this service
               //
               Status = CM_Get_Device_ID_List_Size_Ex(&ulSize, szService,
                        CM_GETIDLIST_FILTER_SERVICE, hMachine);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Get_Device_ID_List_Size failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               pBuffer = (PTSTR)LocalAlloc(LPTR, ulSize * sizeof(TCHAR));
               if (pBuffer == NULL) {
                  MessageBeep(0);
                  return FALSE;
               }

               //
               // to verify the null terminators are correct, fill with 1's
               //
               memset(pBuffer, 1, ulSize * sizeof(TCHAR));

               //
               // get device list for this service
               //
               Status = CM_Get_Device_ID_List_Ex(szService, pBuffer, ulSize,
                        CM_GETIDLIST_FILTER_SERVICE, hMachine);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Get_Device_ID_List failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               SendDlgItemMessage(
                     hDlg, ID_LB_SERVICE, LB_RESETCONTENT, 0, 0);

               p = (LPTSTR)pBuffer;
               while (*p != '\0') {

                  SendDlgItemMessage(
                        hDlg, ID_LB_SERVICE, LB_ADDSTRING, 0,
                        (LPARAM)(LPCTSTR)p);

                  while (*p != '\0') {
                     p++;               // skip to next substring
                  }
                  p++;                 // skip over null terminator
               }

               SendDlgItemMessage(hDlg, ID_LB_SERVICE, LB_SETSEL, TRUE, 0);
               LocalFree(pBuffer);
               break;
      }

      break;
   }
   return (FALSE);

} // ServiceListDlgProc



/**----------------------------------------------------------------------**/
INT_PTR CALLBACK
RelationsListDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    TCHAR       szDevice[MAX_DEVICE_ID_LEN];
    LPTSTR      pBuffer, p;
    ULONG       Size;
    LONG        Index;

    switch (message) {

        case WM_INITDIALOG:
            //
            // Fill list box with all known device instances so user can just
            // point at the device instance they want to query relations for.
            //
            SendDlgItemMessage(hDlg, ID_LB_TARGETS, LB_RESETCONTENT, 0, 0);

            Status = CM_Get_Device_ID_List_Size_Ex(&Size, NULL,
                                                   CM_GETIDLIST_FILTER_NONE, hMachine);
            if (Status != CR_SUCCESS) {
                return FALSE;
            }
       
            pBuffer = (PTSTR)malloc(Size * sizeof(TCHAR));
            if (pBuffer == NULL) {
                return FALSE;
            }
       
            Status = CM_Get_Device_ID_List_Ex(NULL, pBuffer, Size,
                                              CM_GETIDLIST_FILTER_NONE, hMachine);       
            if (Status != CR_SUCCESS) {
                return FALSE;
            }
       
            for (p = pBuffer; *p; p += lstrlen(p) + 1) {
                SendDlgItemMessage(hDlg, ID_LB_TARGETS, LB_ADDSTRING, 0,
                                   (LPARAM)(LPCTSTR)p);
            }
       
            SendDlgItemMessage(hDlg, ID_LB_TARGETS, LB_SETSEL, TRUE, 0);
            free(pBuffer);
            return TRUE;
       

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDOK:
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case ID_BT_BUS:
                    FillRelationsListBox(hDlg, CM_GETIDLIST_FILTER_BUSRELATIONS);
                    break;

                case ID_BT_POWER:
                    FillRelationsListBox(hDlg, CM_GETIDLIST_FILTER_POWERRELATIONS);
                    break;

                case ID_BT_REMOVAL:
                    FillRelationsListBox(hDlg, CM_GETIDLIST_FILTER_REMOVALRELATIONS);
                    break;

                case ID_BT_EJECTION:
                    FillRelationsListBox(hDlg, CM_GETIDLIST_FILTER_EJECTRELATIONS);
                    break;
            }
            break;
    }
    return (FALSE);

} // RelationsListDlgProc



FillRelationsListBox(
    HWND  hDlg,
    ULONG RelationType
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    TCHAR       szDevice[MAX_DEVICE_ID_LEN];
    LPTSTR      pBuffer, p;
    ULONG       Size;
    LONG        Index;
    
    SendDlgItemMessage(hDlg, ID_LB_RELATIONS, LB_RESETCONTENT, 0, 0);
            
    //
    // Which device instance was selected
    //
    Index = SendDlgItemMessage(hDlg, ID_LB_TARGETS, LB_GETCURSEL, 0, 0);
    if (Index == LB_ERR || Index == 0) {
        return FALSE;
    }
         
    SendDlgItemMessage(hDlg, ID_LB_TARGETS, LB_GETTEXT, (WPARAM)Index,
                       (LPARAM)(LPCTSTR)szDevice);
         
    //
    // How big a buffer to hold the relations list?
    //
    Status = CM_Get_Device_ID_List_Size_Ex(&Size, szDevice, RelationType, hMachine);
    if (Status != CR_SUCCESS) {
        wsprintf(szDebug, TEXT("CM_Get_Device_ID_List_Size failed (%xh)"), Status);
        MessageBox(hDlg, szDebug, szAppName, MB_OK);
        return FALSE;
    }

    pBuffer = (PTSTR)malloc(Size * sizeof(TCHAR));
    if (pBuffer == NULL) {
        return FALSE;
    }

    //
    // to verify the null terminators are correct, fill with 1's
    //
    memset(pBuffer, 1, Size * sizeof(TCHAR));

    //
    // Retrieve and display the relations list
    //
    Status = CM_Get_Device_ID_List_Ex(szDevice, pBuffer, Size, RelationType, hMachine);
    if (Status != CR_SUCCESS) {
        wsprintf(szDebug, TEXT("CM_Get_Device_ID_List failed (%xh)"), Status);
        MessageBox(hDlg, szDebug, szAppName, MB_OK);
        return FALSE;
    }

    for (p = pBuffer; *p; p += lstrlen(p) + 1) {
        SendDlgItemMessage(hDlg, ID_LB_RELATIONS, LB_ADDSTRING, 0,
                           (LPARAM)(LPCTSTR)p);
    }

    free(pBuffer);
    return TRUE;

} // FillRelationsListBox


/**----------------------------------------------------------------------**/
INT_PTR CALLBACK
DeviceDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDevice[MAX_DEVICE_ID_LEN+1];
   DEVNODE     dnDevNode;
   ULONG       ulStatus, ulProblem;
   ULONG       err;

   switch (message) {
      case WM_SHOWWINDOW:
         FillDeviceInstanceListBox(hDlg);
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {
            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;

            case ID_BT_SOFTWAREKEY:
               DialogBox(hInst, MAKEINTRESOURCE(SOFTWAREKEY_DIALOG), hDlg,
                     SoftwareKeyDlgProc);
               break;

            case ID_BT_ENABLE:
               if (!GetSelectedDevNode(hDlg, &dnDevNode)) {
                  MessageBeep(0);
                  break;
               }

               Status = CM_Enable_DevNode_Ex(dnDevNode, 0, hMachine);
               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Enable_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  break;
               }
               break;


            case ID_BT_DISABLE:
               if (!GetSelectedDevNode(hDlg, &dnDevNode)) {
                  MessageBeep(0);
                  break;
               }

               Status = CM_Disable_DevNode_Ex(dnDevNode, 0, hMachine);
               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Disable_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  break;
               }
               break;

            case ID_BT_CREATE:
               GetSelectedDevice(hDlg, szDevice);
               DialogBoxParam(hInst, MAKEINTRESOURCE(CREATE_DIALOG), hDlg,
                        CreateDlgProc, (LPARAM)(LPCTSTR)szDevice);
               break;

            case ID_BT_GETSTATUS:
               if (!GetSelectedDevNode(hDlg, &dnDevNode)) {
                  MessageBeep(0);
                  break;
               }

               Status = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                     dnDevNode, 0, hMachine);
               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Get_DevNode_Status failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  break;
               }

               wsprintf(szDebug, TEXT("%08xh"), ulStatus);
               SetDlgItemText(hDlg, ID_ST_STATUS, szDebug);
               wsprintf(szDebug, TEXT("%08xh"), ulProblem);
               SetDlgItemText(hDlg, ID_ST_PROBLEM, szDebug);
               break;

            case ID_BT_SETPROBLEM:
                if (!GetSelectedDevNode(hDlg, &dnDevNode)) {
                    MessageBeep(0);
                    break;
                }

                ulProblem = GetDlgItemInt(hDlg, ID_ST_PROBLEM, &err, FALSE);
                Status = CM_Set_DevNode_Problem_Ex(dnDevNode, ulProblem, 0, hMachine);
                if (Status != CR_SUCCESS) {
                    wsprintf(szDebug, TEXT("CM_Get_DevNode_Status failed (%xh)"), Status);
                    MessageBox(hDlg, szDebug, szAppName, MB_OK);
                }
                break;
            
            case ID_BT_QUERY_REMOVE:
                GetSelectedDevNode(hDlg, &dnDevNode);
                Status = CM_Query_Remove_SubTree(dnDevNode, CM_QUERY_REMOVE_UI_OK);
                if (Status != CR_SUCCESS) {
                   wsprintf(szDebug, TEXT("CM_Get_Query_Remove_SubTree failed (%xh)"), Status);
                   MessageBox(hDlg, szDebug, szAppName, MB_OK);
                   break;
                }                
                break;

            case ID_BT_REMOVE:
                GetSelectedDevNode(hDlg, &dnDevNode);
                Status = CM_Remove_SubTree(dnDevNode, CM_REMOVE_UI_OK);
                if (Status != CR_SUCCESS) {
                   wsprintf(szDebug, TEXT("CM_Get_Query_Remove_SubTree failed (%xh)"), Status);
                   MessageBox(hDlg, szDebug, szAppName, MB_OK);
                   break;
                }                
                break;

            case ID_BT_RESOURCEPICKER:
                GetSelectedDevice(hDlg, szDevice);
                CallPnPIsaDetect(hDlg, szDevice);
                break;
      }
      break;
   }
   return (FALSE);

} // DeviceDlgProc


/**----------------------------------------------------------------------**/
INT_PTR CALLBACK
DevKeyDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDeviceID[MAX_DEVICE_ID_LEN];
   DEVNODE     dnDevNode;
   ULONG       ulFlags, ulProfile, ulValue;
   HKEY        hKey = NULL;

   switch (message) {
      case WM_INITDIALOG:
         CheckDlgButton(hDlg, ID_RD_HW, 1);
         CheckDlgButton(hDlg, ID_RD_USER, 1);
         SetDlgItemInt(hDlg, ID_ED_PROFILE, 0xFFFFFFFF, FALSE);
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {

            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;


            case ID_BT_OPENDEVKEY:
               GetDlgItemText(hDlg, ID_ED_DEVICEID, szDeviceID, MAX_DEVICE_ID_LEN);

               Status = CM_Locate_DevNode_Ex(&dnDevNode, szDeviceID, 0, hMachine);
               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Locate_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               ulFlags = 0;

               if (IsDlgButtonChecked(hDlg, ID_RD_HW)) {
                  ulFlags |= CM_REGISTRY_HARDWARE;
               } else {
                  ulFlags |= CM_REGISTRY_SOFTWARE;
               }

               if (IsDlgButtonChecked(hDlg, ID_RD_USER)) {
                  ulFlags |= CM_REGISTRY_USER;
               }
               else if (IsDlgButtonChecked(hDlg, ID_RD_CONFIG)) {
                  ulFlags |= CM_REGISTRY_CONFIG;
                  ulProfile = (ULONG)GetDlgItemInt(hDlg, ID_ED_PROFILE, NULL, TRUE);
               }

               Status = CM_Open_DevNode_Key_Ex(
                     dnDevNode, KEY_READ | KEY_WRITE, ulProfile,
                     RegDisposition_OpenAlways, &hKey, ulFlags, hMachine);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Open_DevNode_Key failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               ulValue = 13;
               RegSetValueEx(hKey, TEXT("CustomValue"), 0, REG_DWORD,
                     (LPBYTE)&ulValue, 4);
               RegCloseKey(hKey);
               break;

         case ID_BT_DELDEVKEY:
            GetDlgItemText(hDlg, ID_ED_DEVICEID, szDeviceID, MAX_DEVICE_ID_LEN);

            Status = CM_Locate_DevNode_Ex(&dnDevNode, szDeviceID, 0, hMachine);
            if (Status != CR_SUCCESS) {
               wsprintf(szDebug, TEXT("CM_Locate_DevNode failed (%xh)"), Status);
               MessageBox(hDlg, szDebug, szAppName, MB_OK);
               return FALSE;
            }

            ulFlags = 0;

            if (IsDlgButtonChecked(hDlg, ID_RD_HW)) {
               ulFlags |= CM_REGISTRY_HARDWARE;
            } else {
               ulFlags |= CM_REGISTRY_SOFTWARE;
            }

            if (IsDlgButtonChecked(hDlg, ID_RD_USER)) {
               ulFlags |= CM_REGISTRY_USER;
            }
            else if (IsDlgButtonChecked(hDlg, ID_RD_CONFIG)) {
               ulFlags |= CM_REGISTRY_CONFIG;
               ulProfile = (ULONG)GetDlgItemInt(hDlg, ID_ED_PROFILE, NULL, TRUE);
            }

            Status = CM_Delete_DevNode_Key_Ex(
                  dnDevNode, ulProfile, ulFlags, hMachine);

            if (Status != CR_SUCCESS) {
               wsprintf(szDebug, TEXT("CM_Delete_DevNode_Key failed (%xh)"), Status);
               MessageBox(hDlg, szDebug, szAppName, MB_OK);
               return FALSE;
            }
      }
      break;
   }
   return (FALSE);

} // DevKeyDlgProc


/**----------------------------------------------------------------------**/
BOOL
FillEnumeratorListBox(
   HWND hDlg
   )
{
   CONFIGRET   Status;
   ULONG       ulIndex, Size;
   TCHAR       szEnumerator[MAX_PATH];

   SendDlgItemMessage(
         hDlg, ID_LB_ENUMERATORS, LB_RESETCONTENT, 0, 0);

   SendDlgItemMessage(
         hDlg, ID_LB_ENUMERATORS, LB_ADDSTRING, 0,
         (LPARAM)(LPCTSTR)TEXT("(All)"));

   ulIndex = 0;
   Status = CR_SUCCESS;

   while (Status == CR_SUCCESS) {

      Size = MAX_PATH;
      Status = CM_Enumerate_Enumerators_Ex(
            ulIndex, szEnumerator, &Size, 0, hMachine);

      if (Status == CR_NO_SUCH_VALUE) {
         // no more enumerators, break out of the loop
         break;
      }

      if (Status != CR_SUCCESS) {
         wsprintf(szDebug, TEXT("CM_Enumerate_Enumerators failed (%xh)"), Status);
         MessageBox(hDlg, szDebug, szAppName, MB_OK);
         return FALSE;
      }

      SendDlgItemMessage(
            hDlg, ID_LB_ENUMERATORS, LB_ADDSTRING, 0,
            (LPARAM)(LPCTSTR)szEnumerator);

      ulIndex++;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_ENUMERATORS, LB_SETSEL, TRUE, 0);

   return TRUE;

} // FillEnumeratorListBox


/**----------------------------------------------------------------------**/
BOOL
FillDeviceListBox(
   HWND hDlg
   )
{
   CONFIGRET   Status;
   ULONG       Size, i;
   TCHAR       szEnumerator[MAX_PATH];
   TCHAR       szDevice[MAX_DEVICE_ID_LEN];
   PTSTR       pBuffer, p;

   if (!GetSelectedEnumerator(hDlg, szEnumerator)) {
      MessageBeep(0);
      return FALSE;
   }

   if (*szEnumerator == '\0') {
      Status = CM_Get_Device_ID_List_Size_Ex(&Size, NULL,
                                CM_GETIDLIST_FILTER_NONE, hMachine);
   }
   else {
      Status = CM_Get_Device_ID_List_Size_Ex(&Size, szEnumerator,
                                CM_GETIDLIST_FILTER_ENUMERATOR, hMachine);
   }

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List_Size failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   i = Size * sizeof(TCHAR);

   pBuffer = (PTSTR)malloc(i);
   if (pBuffer == NULL) {
      MessageBeep(0);
      return FALSE;
   }

   if (*szEnumerator == '\0') {
      Status = CM_Get_Device_ID_List_Ex(NULL, pBuffer, Size,
                                CM_GETIDLIST_FILTER_NONE, hMachine);
   }
   else {
      Status = CM_Get_Device_ID_List_Ex(szEnumerator, pBuffer, Size,
                                CM_GETIDLIST_FILTER_ENUMERATOR, hMachine);
   }

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_DEVICES, LB_RESETCONTENT, 0, 0);

   for (p = pBuffer; *p; p += lstrlen(p) + 1) {

       SendDlgItemMessage(
             hDlg, ID_LB_DEVICES, LB_ADDSTRING, 0,
             (LPARAM)(LPCTSTR)p);
   }

   SendDlgItemMessage(
         hDlg, ID_LB_DEVICES, LB_SETSEL, TRUE, 0);

   free(pBuffer);

   return TRUE;

} // FillDeviceListBox


/**----------------------------------------------------------------------**/
BOOL
FillInstanceListBox(
   HWND hDlg
   )
{
   CONFIGRET   Status;
   ULONG       Size;
   TCHAR       szDevice[MAX_DEVICE_ID_LEN];
   PTSTR       pBuffer, p;
   LONG        Index;


   Index = SendDlgItemMessage(
         hDlg, ID_LB_DEVICES, LB_GETCURSEL, 0, 0);
   if (Index == LB_ERR) {
      MessageBeep(0);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_DEVICES, LB_GETTEXT, (WPARAM)Index,
         (LPARAM)(LPCTSTR)szDevice);

   // truncate the instance part
   p = szDevice;
   while (*p != '\\') p++;
   p++;
   while (*p != '\\') p++;
   *p = '\0';

   Status = CM_Get_Device_ID_List_Size_Ex(&Size, szDevice,
                             CM_GETIDLIST_FILTER_ENUMERATOR, hMachine);

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List_Size failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   pBuffer = (PTSTR)LocalAlloc(LPTR, Size * sizeof(TCHAR));
   if (pBuffer == NULL) {
      MessageBeep(0);
      return FALSE;
   }

   Status = CM_Get_Device_ID_List_Ex(szDevice, pBuffer, Size,
                             CM_GETIDLIST_FILTER_ENUMERATOR, hMachine);

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_INSTANCES, LB_RESETCONTENT, 0, 0);

   p = (LPTSTR)pBuffer;
   while (*p != '\0') {

      SendDlgItemMessage(
            hDlg, ID_LB_INSTANCES, LB_ADDSTRING, 0,
            (LPARAM)(LPCTSTR)p);

      while (*p != '\0') {
         p++;               // skip to next substring
      }
      p++;                 // skip over null terminator
   }

   SendDlgItemMessage(
         hDlg, ID_LB_INSTANCES, LB_SETSEL, TRUE, 0);

   LocalFree(pBuffer);

   return TRUE;

} // FillInstanceListBox


/**----------------------------------------------------------------------**/
BOOL
FillDeviceInstanceListBox(
   HWND hDlg
   )
{
   CONFIGRET   Status;
   ULONG       Size;
   TCHAR       szDevice[MAX_DEVICE_ID_LEN];
   PTSTR       pBuffer, p;

   //
   // get device list size for all enumerators
   //
   Status = CM_Get_Device_ID_List_Size_Ex(&Size, NULL,
                        CM_GETIDLIST_FILTER_NONE, hMachine);

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List_Size failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   pBuffer = (PTSTR)LocalAlloc(LPTR, Size * sizeof(TCHAR));
   if (pBuffer == NULL) {
      MessageBeep(0);
      return FALSE;
   }

   //
   // to verify the null terminators are correct, fill with 1's
   //
   memset(pBuffer, 1, Size * sizeof(TCHAR));

   //
   // get device list for all enumerators
   //
   Status = CM_Get_Device_ID_List_Ex(NULL, pBuffer, Size,
                        CM_GETIDLIST_FILTER_NONE, hMachine);

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_DEVICEIDS, LB_RESETCONTENT, 0, 0);

   p = (LPTSTR)pBuffer;
   while (*p != '\0') {

      SendDlgItemMessage(
            hDlg, ID_LB_DEVICEIDS, LB_ADDSTRING, 0,
            (LPARAM)(LPCTSTR)p);

      while (*p != '\0') {
         p++;               // skip to next substring
      }
      p++;                 // skip over null terminator
   }

   SendDlgItemMessage(hDlg, ID_LB_DEVICEIDS, LB_SETSEL, TRUE, 0);
   LocalFree(pBuffer);
   return TRUE;

} // FillDeviceInstanceListBox


/**----------------------------------------------------------------------**/
BOOL
GetSelectedEnumerator(
   HWND   hDlg,
   LPTSTR szEnumerator
   )
{
   LONG  Index;

   Index = SendDlgItemMessage(
         hDlg, ID_LB_ENUMERATORS, LB_GETCURSEL, 0, 0);
   if (Index == LB_ERR) {
      MessageBeep(0);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_ENUMERATORS, LB_GETTEXT, (WPARAM)Index,
         (LPARAM)(LPCTSTR)szEnumerator);

   if (lstrcmpi(szEnumerator, TEXT("(All)")) == 0) {
      *szEnumerator = '\0';    // if All selected, then no Enumerator specified
   }
   return TRUE;

} // GetSeletectedEnumerator


/**----------------------------------------------------------------------**/
BOOL
GetSelectedDevice(
   HWND   hDlg,
   LPTSTR szDevice
   )
{
   LONG  Index;

   Index = SendDlgItemMessage(
         hDlg, ID_LB_DEVICEIDS, LB_GETCURSEL, 0, 0);
   if (Index == LB_ERR || Index == 0) {
      MessageBeep(0);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_DEVICEIDS, LB_GETTEXT, (WPARAM)Index,
         (LPARAM)(LPCTSTR)szDevice);

   return TRUE;

} // GetSeletectedDevice


/**----------------------------------------------------------------------**/
BOOL
GetSelectedDevNode(
   HWND     hDlg,
   PDEVNODE pdnDevNode
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDevice[MAX_DEVICE_ID_LEN];

   if (!GetSelectedDevice(hDlg, szDevice)) {
      return FALSE;
   }

   Status = CM_Locate_DevNode_Ex(pdnDevNode, szDevice, 0, hMachine);

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Locate_DevNode failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   return TRUE;

} // GetSelectedDevNode



/**----------------------------------------------------------------------**/
INT_PTR CALLBACK
SoftwareKeyDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;

   switch (message) {
      case WM_INITDIALOG:
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {
            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;

            default:
               break;
         }
   }
   return (FALSE);

} // SoftwareKeyDlgProc



/**----------------------------------------------------------------------**/
INT_PTR CALLBACK
CreateDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDeviceID[MAX_DEVICE_ID_LEN];
   TCHAR       szParentID[MAX_DEVICE_ID_LEN];
   DEVNODE     dnDevNode, dnParentDevNode;
   ULONG       ulFlags;

   switch (message) {

      case WM_INITDIALOG:
         SetDlgItemText(hDlg, ID_ST_PARENT, (LPCTSTR)lParam);
         CheckDlgButton(hDlg, ID_RD_NORMAL, 1);
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {

            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;


            case ID_BT_CREATE:
               SetDlgItemText(hDlg, ID_ST_STATUS, TEXT(""));
               GetDlgItemText(hDlg, ID_ED_DEVICEID, szDeviceID, MAX_DEVICE_ID_LEN);
               GetDlgItemText(hDlg, ID_ST_PARENT, szParentID, MAX_DEVICE_ID_LEN);

               ulFlags = CM_CREATE_DEVNODE_NORMAL;

               if (IsDlgButtonChecked(hDlg, ID_CHK_GENERATEID)) {
                  ulFlags |= CM_CREATE_DEVNODE_GENERATE_ID;
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_PHANTOM)) {
                  ulFlags |= CM_CREATE_DEVNODE_PHANTOM;
               }

               Status = CM_Locate_DevNode(
                  &dnParentDevNode, szParentID, 0);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Locate_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               Status = CM_Create_DevNode(
                   &dnDevNode, szDeviceID, dnParentDevNode, ulFlags);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Create_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               memset(szDeviceID, 0, MAX_DEVICE_ID_LEN * sizeof(TCHAR));

               Status = CM_Get_Device_ID(
                  dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN, 0);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Create_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               wsprintf(szDebug, TEXT("%s created"),
                  szDeviceID);
               SetDlgItemText(hDlg, ID_ST_STATUS, szDebug);
               break;
      }
      break;
   }
   return (FALSE);

} // CreateDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\test\class.c ===
/**------------------------------------------------------------------
   class.c
------------------------------------------------------------------**/


//
// Includes
//
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include "cmtest.h"

//
// Private Prototypes
//

BOOL
FillClassListBox(
   HWND hDlg
   );

BOOL
GetSelectedClass(
   HWND   hDlg,
   LPTSTR szClassGuid
   );

REGSAM
GetAccessMask(
   HWND    hDlg
   );

//
// Globals
//
extern HINSTANCE hInst;
extern TCHAR     szDebug[MAX_PATH];
extern TCHAR     szAppName[MAX_PATH];
extern HMACHINE  hMachine;



/**----------------------------------------------------------------------**/
INT_PTR CALLBACK
ClassDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status;
   ULONG       Size;
   LONG        Index;
   TCHAR       szClassGuid[MAX_GUID_STRING_LEN];
   TCHAR       szClassName[MAX_CLASS_NAME_LEN];


   switch (message) {
      case WM_INITDIALOG:
         if (!FillClassListBox(hDlg)) {
            EndDialog(hDlg, FALSE);
         }
         return TRUE;

   case WM_COMMAND:
      switch(LOWORD(wParam)) {

         case IDOK:
            EndDialog(hDlg, TRUE);
            return TRUE;

         case ID_LB_CLASSES:
            if (HIWORD(wParam) != LBN_DBLCLK) {
               break;
            }
            // if DBLCK, fall through to getting the classname

         case ID_BT_CLASSNAME:
            /*
            if (!GetSelectedClass(hDlg, szClassName)) {
               break;
            }

            Size = MAX_CLASS_NAME_LEN;
            Status = CM_Get_Class_Name_Ex(
                  &ClassGuid, szClassName, &Size, 0, hMachine);

            if (Status != CR_SUCCESS) {
               wsprintf(szDebug,
                     TEXT("CM_Get_Class_Name failed (%xh)"), Status);
               MessageBox(hDlg, szDebug, szAppName, MB_OK);
               EndDialog(hDlg, FALSE);
            }

            SetDlgItemText(hDlg, ID_ST_CLASSNAME, szClassName);
            */
            break;

         case ID_BT_CLASSKEY:
            if (!GetSelectedClass(hDlg, szClassName)) {
               break;
            }

            DialogBoxParam(hInst, MAKEINTRESOURCE(CLASSKEY_DIALOG), hDlg,
                     ClassKeyDlgProc, (LPARAM)(LPCTSTR)szClassName);
            break;

         default:
            break;
      }

   }
   return FALSE;

} // ClassDlgProc



/**----------------------------------------------------------------------**/
BOOL CALLBACK
ClassKeyDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status;
   REGSAM      rsAccess;
   ULONG       ulDisp, ulSize;
   TCHAR       szClassGuid[MAX_PATH];
   TCHAR       szValueName[MAX_PATH];
   TCHAR       szValueData[MAX_PATH];
   LONG        RegStatus;
   HKEY        hKey;
   GUID        ClassGuid;


   switch (message) {
      case WM_INITDIALOG:
         SetDlgItemText(hDlg, ID_ST_CLASSGUID, (LPCTSTR)lParam);
         return TRUE;

   case WM_COMMAND:
      switch(LOWORD(wParam)) {

         case IDOK:
            EndDialog(hDlg, TRUE);
            return TRUE;

         case ID_BT_QUERYVALUE:
            GetDlgItemText(hDlg, ID_ST_CLASSGUID, szClassGuid, MAX_PATH);
            rsAccess = GetAccessMask(hDlg);
            if (IsDlgButtonChecked(hDlg, ID_CHK_CREATE)) {
               ulDisp = RegDisposition_OpenAlways;
            }
            else {
               ulDisp = RegDisposition_OpenExisting;
            }

            Status = CM_Open_Class_Key_Ex(
                     &ClassGuid, NULL, rsAccess, ulDisp, &hKey, 0, hMachine);

            if (Status != CR_SUCCESS) {
               wsprintf(szDebug,
                     TEXT("CM_Open_Class_Key failed (%xh)"), Status);
               MessageBox(hDlg, szDebug, szAppName, MB_OK);
               EndDialog(hDlg, FALSE);
            }

            GetDlgItemText(hDlg, ID_ED_VALUENAME, szValueName, MAX_PATH);
            RegStatus = RegQueryValueEx(hKey, szValueName, NULL, NULL,
                     (LPBYTE)szValueData, &ulSize);
            if (RegStatus == ERROR_SUCCESS) {
               SetDlgItemText(hDlg, ID_ED_VALUEDATA, szValueData);
            }
            else {
               MessageBeep(0);
            }
            RegCloseKey(hKey);
            break;

         case ID_BT_SETVALUE:
            GetDlgItemText(hDlg, ID_ST_CLASSGUID, szClassGuid, MAX_PATH);
            rsAccess = GetAccessMask(hDlg);
            if (IsDlgButtonChecked(hDlg, ID_CHK_CREATE)) {
               ulDisp = RegDisposition_OpenAlways;
            }
            else {
               ulDisp = RegDisposition_OpenExisting;
            }

            Status = CM_Open_Class_Key_Ex(
                     &ClassGuid, NULL, rsAccess, ulDisp, &hKey, 0, hMachine);

            if (Status != CR_SUCCESS) {
               wsprintf(szDebug,
                     TEXT("CM_Open_Class_Key failed (%xh)"), Status);
               MessageBox(hDlg, szDebug, szAppName, MB_OK);
               EndDialog(hDlg, FALSE);
            }

            GetDlgItemText(hDlg, ID_ED_VALUENAME, szValueName, MAX_PATH);
            GetDlgItemText(hDlg, ID_ED_VALUEDATA, szValueData, MAX_PATH);
            RegStatus = RegSetValueEx(hKey, szValueName, 0, REG_SZ,
                     (LPBYTE)szValueData,
                     (lstrlen(szValueData)+1) * sizeof(TCHAR));
            if (RegStatus != ERROR_SUCCESS) {
               MessageBeep(0);
            }
            RegCloseKey(hKey);
            break;

         default:
            break;
      }
   }
   return FALSE;

} // ClassKeyDlgProc


/**----------------------------------------------------------------------**/
BOOL
FillClassListBox(
   HWND hDlg
   )
{
   CONFIGRET   Status;
   ULONG       ulIndex, Size;
   GUID        ClassGuid;
   TCHAR       szClassGuid[MAX_CLASS_NAME_LEN];

   SendDlgItemMessage(
         hDlg, ID_LB_CLASSES, LB_RESETCONTENT, 0, 0);

   SendDlgItemMessage(
         hDlg, ID_LB_CLASSES, LB_ADDSTRING, 0,
         (LPARAM)(LPCTSTR)TEXT("(Root)"));

   ulIndex = 0;
   Status = CR_SUCCESS;

   while (Status == CR_SUCCESS) {

      Status = CM_Enumerate_Classes_Ex(
            ulIndex, &ClassGuid, 0, hMachine);

      if (Status == CR_NO_SUCH_VALUE) {
         // no more classes, break out of the look
         break;
      }

      if (Status != CR_SUCCESS) {
         wsprintf(szDebug, TEXT("CM_Enumerate_Classes failed (%xh)"), Status);
         MessageBox(hDlg, szDebug, szAppName, MB_OK);
         return FALSE;
      }

      Size = MAX_CLASS_NAME_LEN;
      Status = CM_Get_Class_Name_Ex(
            &ClassGuid, szClassGuid, &Size, 0, hMachine);

      if (Status != CR_SUCCESS) {
         wsprintf(szDebug, TEXT("CM_Get_Class_Name failed (%xh)"), Status);
         MessageBox(hDlg, szDebug, szAppName, MB_OK);
         return FALSE;
      }

      SendDlgItemMessage(
            hDlg, ID_LB_CLASSES, LB_ADDSTRING, 0,
            (LPARAM)(LPCTSTR)szClassGuid);

      ulIndex++;
   }

   return TRUE;

} // FillClassListBox


/**----------------------------------------------------------------------**/
BOOL
GetSelectedClass(
   HWND   hDlg,
   LPTSTR szClassName
   )
{
   LONG  Index;

   Index = SendDlgItemMessage(
         hDlg, ID_LB_CLASSES, LB_GETCURSEL, 0, 0);
   if (Index == LB_ERR || Index == 0) {
      MessageBeep(0);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_CLASSES, LB_GETTEXT, (WPARAM)Index,
         (LPARAM)(LPCTSTR)szClassName);

   if (lstrcmpi(szClassName, TEXT("Root")) == 0) {
      *szClassName = '\0';    // if Root selected, then no class specified
   }
   return TRUE;

} // GetSeletectedClass


/**----------------------------------------------------------------------**/
REGSAM
GetAccessMask(
   HWND    hDlg
   )
{
   REGSAM rsAccess = 0;

   if (IsDlgButtonChecked(hDlg, ID_CHK_ALL_ACCESS)) {
      rsAccess |= KEY_ALL_ACCESS;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_CREATE_LINK)) {
      rsAccess |= KEY_CREATE_LINK;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_CREATE_SUB_KEY)) {
      rsAccess |= KEY_CREATE_SUB_KEY;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_ENUMERATE_SUB_KEYS)) {
      rsAccess |= KEY_ENUMERATE_SUB_KEYS;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_EXECUTE)) {
      rsAccess |= KEY_EXECUTE;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_NOTIFY)) {
      rsAccess |= KEY_NOTIFY;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_QUERY_VALUE)) {
      rsAccess |= KEY_QUERY_VALUE;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_READ)) {
      rsAccess |= KEY_READ;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_SET_VALUE)) {
      rsAccess |= KEY_SET_VALUE;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_WRITE)) {
      rsAccess |= KEY_WRITE;
   }

   return rsAccess;

} // GetAccessMask
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\test\regress.c ===
/**------------------------------------------------------------------
   regress.c
------------------------------------------------------------------**/


//
// Includes
//
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include <malloc.h>
#include <regstr.h>
#include "cmtest.h"

//
// Private Prototypes
//
VOID
RegressionTest_Range(
    HWND  hDlg
    );

VOID
RegressionTest_Class(
    HWND  hDlg
    );

VOID
RegressionTest_Traverse(
    HWND  hDlg
    );

VOID
RegressionTest_HardwareProfile(
    HWND  hDlg
    );

VOID
RegressionTest_DeviceList(
    HWND  hDlg
    );

VOID
RegressionTest_LogConf(
    HWND  hDlg
    );

VOID
RegressionTest_CreateDevNode(
    HWND  hDlg
    );

VOID
RegressionTest_Properties(
    HWND  hDlg
    );

VOID
RegressionTest_DeviceClass(
    HWND  hDlg
    );

BOOL
DisplayRange(
    IN HWND  hDlg,
    IN RANGE_LIST rlh
    );

BOOL
TraverseAndCheckParents (
    DEVNODE dnParent
    );


//
// Globals
//

TCHAR szPresentDeviceID[] =         TEXT("Test\\Present\\0000");
TCHAR szNonExistantDeviceID[] =     TEXT("Test\\XXX\\0000");
TCHAR szInvalidDeviceID[] =         TEXT("Test\\0000");
TCHAR szNotFoundDeviceID[] =        TEXT("Test\\NotFound\\0000");
TCHAR szMovedDeviceID[] =           TEXT("Test\\Moved\\0000");
TCHAR szNoBaseDeviceID[] =          TEXT("Test\\NoBaseDevice\\0000");
TCHAR szMissingParentDeviceID[] =   TEXT("Test\\ParentMissing\\0000");
TCHAR szNotFoundParentDeviceID[] =  TEXT("Test\\ParentNotFound\\0000");
TCHAR szMovedParentDeviceID[] =     TEXT("Test\\ParentMoved\\0000");
TCHAR szNoAttachedDeviceID[] =      TEXT("Test\\NoAttachedComponents\\0000");
TCHAR szMissingChildDeviceID[] =    TEXT("Test\\ChildMissing\\0000");
TCHAR szNotFoundChildDeviceID[] =   TEXT("Test\\ChildNotFound\\0000");
TCHAR szMovedChildDeviceID[] =      TEXT("Test\\ChildMoved\\0000");
TCHAR szValid2ndChildDeviceID[] =   TEXT("Test\\Valid2ndChild\\0000");
TCHAR szMissingSiblingDeviceID[] =  TEXT("Test\\SiblingMissing\\0000");
TCHAR szNotFoundSiblingDeviceID[] = TEXT("Test\\SiblingNotFound\\0000");
TCHAR szMovedSiblingDeviceID[] =    TEXT("Test\\SiblingMoved\\0000");
TCHAR szValid3rdChildDeviceID[] =   TEXT("Test\\Valid3rdChild\\0000");
TCHAR szEnabledDeviceID[] =         TEXT("Test\\Enabled\\0000");
TCHAR szDisabledDeviceID[] =        TEXT("Test\\Disabled\\0000");
TCHAR szCreateDeviceID[] =          TEXT("Test\\Create\\0000");
TCHAR szDoNotCreateDeviceID[] =     TEXT("Test\\DoNotCreate\\0000");
TCHAR szPhantomDeviceID[] =         TEXT("Test\\Phantom\\0000");
TCHAR szRemoveDeviceID[] =          TEXT("Test\\Remove\\0000");
TCHAR szClassGuid_0[] =             TEXT("{00000000-0000-0000-0000-000000000000}");
TCHAR szClassGuid_None[] =          TEXT("{99999999-9999-9999-9999-999999999999}");

TCHAR szDev_MovedTo[] =             TEXT("TEST\\MovedTo\\0000");
TCHAR szDev_MovedFrom[] =           TEXT("TEXT\\MovedFrom\\0000");

extern HMACHINE  hMachine;


/**----------------------------------------------------------------------**/
INT_PTR CALLBACK
RegressionDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDeviceID[MAX_DEVICE_ID_LEN];
   TCHAR       szParentID[MAX_DEVICE_ID_LEN];
   DEVNODE     dnDevNode, dnParentDevNode;
   ULONG       ulFlags;

   switch (message) {

      case WM_INITDIALOG:
         SetDlgItemText(hDlg, ID_ST_PARENT, (LPCTSTR)lParam);
         CheckDlgButton(hDlg, ID_RD_NORMAL, 1);
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {

            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;

            case ID_BT_CLEAR:
               SendDlgItemMessage(
                     hDlg, ID_LB_REGRESSION, LB_RESETCONTENT, 0, 0);
               break;

            case ID_BT_START:
               if (IsDlgButtonChecked(hDlg, ID_CHK_RANGE)) {
                  RegressionTest_Range(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_CLASS)) {
                  RegressionTest_Class(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_TRAVERSE)) {
                  RegressionTest_Traverse(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_HWPROF)) {
                  RegressionTest_HardwareProfile(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_DEVLIST)) {
                  RegressionTest_DeviceList(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_LOGCONF)) {
                  RegressionTest_LogConf(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_CREATE)) {
                  RegressionTest_CreateDevNode(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_PROPERTIES)) {
                  RegressionTest_Properties(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_DEVCLASS)) {
                  RegressionTest_DeviceClass(hDlg);
               }
         }
         break;
   }
   return FALSE;

} // RegressionDlgProc


//-----------------------------------------------------------------------------
VOID
RegressionTest_Range(
      HWND  hDlg
      )
{
   CONFIGRET      Status = CR_SUCCESS;
   RANGE_LIST     rlh1, rlh2, rlh3;
   RANGE_ELEMENT  rElement;
   DWORDLONG      ullStart, ullEnd;
   TCHAR          szMsg[MAX_PATH], szMsg1[MAX_PATH];


   lstrcpy(szMsg, TEXT("1. Create Range List: "));
   Status = CM_Create_Range_List(&rlh1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }

   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //------------------------------------------------------
   // Add range test
   //------------------------------------------------------

   lstrcpy(szMsg, TEXT("2. Add Ranges: "));
   Status = CM_Add_Range(12, 15, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(12,15) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   Status = CM_Add_Range(7, 9, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(7,9) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   Status = CM_Add_Range(21, 25, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(21,25) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // A1
   Status = CM_Add_Range(4, 5, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(4,5) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // A2
   Status = CM_Add_Range(11, 13, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(11,13) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // A3
   Status = CM_Add_Range(20, 26, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(20,26) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // B1
   Status = CM_Add_Range(6, 8, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(6,8) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // B2
   Status = CM_Add_Range(14, 16, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(14,16) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // special cases
   Status = CM_Add_Range(10, 14, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(10,14) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // add "join" cases
   DoneAddingRanges:

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   // conflict cases
   Status = CM_Add_Range(2, 4, rlh1, CM_ADD_RANGE_DONOTADDIFCONFLICT);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("(2,4) Should've Failed due to conflict"));
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Add_Range(20, 22, rlh1, CM_ADD_RANGE_DONOTADDIFCONFLICT);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("(20,22) Should've Failed due to conflict"));
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Add_Range(10, 12, rlh1, CM_ADD_RANGE_DONOTADDIFCONFLICT);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("(10,12) Should've Failed due to conflict"));
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Add_Range(26, 28, rlh1, CM_ADD_RANGE_DONOTADDIFCONFLICT);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("(26,28) Should've Failed due to conflict"));
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Add_Range(18, 30, rlh1, CM_ADD_RANGE_DONOTADDIFCONFLICT);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("(18,30) Should've Failed due to conflict"));
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }


   //------------------------------------------------------
   // Duplicate range list test
   //------------------------------------------------------

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("_____Duplicate Range List Test__________"));

   Status = CM_Create_Range_List(&rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Create_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg1);
      return;
   }

   // new range is empty
   Status = CM_Dup_Range_List(rlh1, rlh2, 0);
   if (Status != CR_SUCCESS) {
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)TEXT("Dup failed to empty range list"));
      return;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Original Range:"));
   DisplayRange(hDlg, rlh1);

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Duplicated Range:"));
   DisplayRange(hDlg, rlh2);


   // new range is not empty
   Status = CM_Dup_Range_List(rlh1, rlh2, 0);
   if (Status != CR_SUCCESS) {
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)TEXT("Dup failed to non-empty range list"));
      return;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Original Range:"));
   DisplayRange(hDlg, rlh1);

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Duplicated Range:"));
   DisplayRange(hDlg, rlh2);



   //------------------------------------------------------
   // Delete range list test
   //------------------------------------------------------

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("_____Delete Range Test__________"));


   Status = CM_Delete_Range(1,3, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (1,3)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(17,19, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (17,19)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(27,30, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (27,30)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(3,6, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (3,6)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(13,16, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (13,16)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(8,10, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (8,10)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(9,21, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (9,21)"));
   DisplayRange(hDlg, rlh2);


   // special cases

   Status = CM_Delete_Range(0,DWORD_MAX, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (0,DWORD_MAX)"));
   DisplayRange(hDlg, rlh2);

   // re-dup range list 2 again, it's currently empty

   CM_Dup_Range_List(rlh1, rlh2, 0);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Resetting range list to:"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(0,DWORDLONG_MAX, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (0,DWORDLONG_MAX)"));
   DisplayRange(hDlg, rlh2);



   //------------------------------------------------------
   // Test range available
   //------------------------------------------------------

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("______Test Range Available____________"));
   DisplayRange(hDlg, rlh1);


   Status = CM_Test_Range_Available(0, 2, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (0,2) is available (expected)"));
   } else {
      wsprintf(szMsg, TEXT("Range (0,2) not available (%d)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(17, 19, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (17,19) is available (expected)"));
   } else {
      wsprintf(szMsg, TEXT("Range (17,19) not available (%d)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(30, 40, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (30,40) is available (expected)"));
   } else {
      wsprintf(szMsg, TEXT("Range (30,40) not available (%d)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(3, 4, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (3,4) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (3,4) not available, %d (expected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(26, 50, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (26,50) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (26,50) not available, %d (expected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(16, 20, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (16,20) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (16,20) not available, %d (epxected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(3, 21, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (3,21) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (3,21) not available, %d (expected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(5, 24, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (5,24) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (5,24) not available, %d (expected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(24, 25, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (24,25) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (24,25) not available, %d (expected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //------------------------------------------------------
   // Invert Range test
   //------------------------------------------------------


   Status = CM_Create_Range_List(&rlh3, 0);

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Original range to invert:"));
   DisplayRange(hDlg, rlh1);


   Status = CM_Invert_Range_List(rlh1, rlh2, 100, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Invert_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Inverting into empty range:"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Invert_Range_List(rlh1, rlh2, 25, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Invert_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Inverting into non-empty range, MAX=25:"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Invert_Range_List(rlh1, rlh2, 50, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Invert_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Inverting into non-empty range, MAX=50:"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Invert_Range_List(rlh3, rlh2, 1000, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Invert_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Inverting from empty range, MAX = 1000:"));
   DisplayRange(hDlg, rlh2);



   //------------------------------------------------------
   // Free range list test
   //------------------------------------------------------

   Status = CM_Free_Range_List(rlh1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Free_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Free_Range_List(rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Free_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Free_Range_List(rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Free_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Free_Range_List(rlh3, 0);
   if (Status != CR_INVALID_RANGE_LIST) {
       lstrcpy(szMsg, TEXT("Error: freeing already free list should have failed"));
   } else {
       lstrcpy(szMsg, TEXT("Freeing a freed list caused expected error"));
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)szMsg);



   //------------------------------------------------------
   // Intersection test
   //------------------------------------------------------

   CM_Create_Range_List(&rlh1, 0);
   CM_Add_Range(1, 3, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(13, 18, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(25, 27, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(30, 36, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(42, 45, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(48, 52, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   DisplayRange(hDlg, rlh1);

   CM_Create_Range_List(&rlh2, 0);
   CM_Add_Range(8, 9, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(12, 14, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(17, 19, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(32, 34, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(40, 50, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   DisplayRange(hDlg, rlh2);

   CM_Create_Range_List(&rlh3, 0);

   Status = CM_Intersect_Range_List(rlh1, rlh2, rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Intersect_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Expected intersection: (13,14)(17,18)(32,34)(42,45)(48,50):"));
   DisplayRange(hDlg, rlh3);


   //------------------------------------------------------
   // Merge (union) test
   //------------------------------------------------------

   // use same rlh1 and rlh2 from the intersection test, non-emptry rlh3
   Status = CM_Merge_Range_List(rlh1, rlh2, rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Merge_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Expected union: (1,3)(8,9)(12,19)(25,27)(30,36)(40,52)"));
   DisplayRange(hDlg, rlh3);


   // both ranges empty
   CM_Free_Range_List(rlh1, 0);
   CM_Free_Range_List(rlh2, 0);
   CM_Create_Range_List(&rlh1, 0);
   CM_Create_Range_List(&rlh2, 0);

   Status = CM_Merge_Range_List(rlh1, rlh2, rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Merge_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Expected union: none"));
   DisplayRange(hDlg, rlh3);


   // first range empty
   CM_Add_Range(8, 9, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(12, 14, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(17, 19, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(32, 34, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(40, 50, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);

   Status = CM_Merge_Range_List(rlh1, rlh2, rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Merge_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Expected union: (8,9)(12,14)(17,19)(32,34)(40,50)"));
   DisplayRange(hDlg, rlh3);


   // second range empty
   CM_Free_Range_List(rlh2, 0);
   CM_Create_Range_List(&rlh2, 0);

   CM_Add_Range(1, 3, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(13, 18, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(25, 27, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(30, 36, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(42, 45, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(48, 52, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);

   Status = CM_Merge_Range_List(rlh1, rlh2, rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Merge_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Expected union: (1,3)(13,18)(25,27)(30,36)(42,45)(48,52)"));
   DisplayRange(hDlg, rlh3);


   CM_Free_Range_List(rlh1, 0);
   CM_Free_Range_List(rlh2, 0);
   CM_Free_Range_List(rlh3, 0);


   //------------------------------------------------------
   // Find Range test
   //------------------------------------------------------


   CM_Create_Range_List(&rlh1, 0);

   // should be a hit on the first try

   CM_Add_Range(10, 20, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);

   Status = CM_Find_Range(&ullStart, 256, 512, 0xFFFFFFFFFFFFFFF0, 1024, rlh1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Test_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   wsprintf(szMsg, TEXT("Found Range at %d (expecting 256)"), (DWORD)ullStart);
   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   // should find it but after skipping one range

   CM_Add_Range(300, 320, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);

   Status = CM_Find_Range(&ullStart, 256, 512, 0xFFFFFFFFFFFFFFF0, 1024, rlh1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Test_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   wsprintf(szMsg, TEXT("Found Range at %d (expecting 336)"), (DWORD)ullStart);
   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   // should fail the find

   CM_Add_Range(500, 600, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);

   Status = CM_Find_Range(&ullStart, 256, 512, 0xFFFFFFFFFFFFFFF0, 1024, rlh1, 0);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("CM_Test_Range should have Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Test range failed as expected"));



   CM_Free_Range_List(rlh1, 0);


   //---------------------------------------------------------------------
   // Special Test 1 - error condition found by LeslieF
   //---------------------------------------------------------------------

   CM_Create_Range_List(&rlh1, 0);      // Create range list.
   CM_Add_Range(0, 50, rlh1, CM_ADD_RANGE_ADDIFCONFLICT); // Add range [0-50].
   CM_Delete_Range(0, 9, rlh1, 0);      // Delete the range [0-9].
   CM_Delete_Range(21, 29, rlh1, 0);        // Delete the range [21-29].
   CM_Delete_Range(41, 50, rlh1, 0);        // Delete the range [41-50].

   // There should be two ranges left [10-20] and [30-40].
   CM_First_Range(rlh1, &ullStart, &ullEnd, &rElement, 0);
   CM_Next_Range(&rElement, &ullStart, &ullEnd, 0);

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Special Test 1, expected (10,20),(30,40)"));
   DisplayRange(hDlg, rlh1);
   CM_Free_Range_List(rlh1, 0);

   //---------------------------------------------------------------------
   // Special Test 2 - error condition found by LeslieF
   //---------------------------------------------------------------------

   Status = CM_Dup_Range_List(0, 0,0);
   if (Status == CR_INVALID_RANGE_LIST) {
      SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
             (LPARAM)(LPTSTR)TEXT("Special Test 2 - passed"));
   } else {
      SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
             (LPARAM)(LPTSTR)TEXT("Special Test 2 - failed"));
   }

   //---------------------------------------------------------------------
   // Special Test 3 - error condition found by LeslieF
   //---------------------------------------------------------------------

   Status = CM_Find_Range(NULL, 0, 0, 0, 0, 0, 0);
   if (Status == CR_INVALID_RANGE_LIST) {
      SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
             (LPARAM)(LPTSTR)TEXT("Special Test 3 - passed"));
   } else {
      SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
             (LPARAM)(LPTSTR)TEXT("Special Test 3 - failed"));
   }

   //---------------------------------------------------------------------
   // Special Test 4 - error condition found by LeslieF
   //---------------------------------------------------------------------

   CM_Create_Range_List(&rlh1, 0);
   CM_Free_Range_List(rlh1, 0);
   CM_Free_Range_List(rlh1, 0);

   //---------------------------------------------------------------------
   // Special Test 5 - error condition found by LeslieF
   //---------------------------------------------------------------------

   CM_Intersect_Range_List(0, 0, 0, 0);
   CM_Invert_Range_List(0, 0, 0, 0);
   CM_Merge_Range_List(0, 0, 0, 0);


   //---------------------------------------------------------------------
   // Special Test 6 - error condition found by LeslieF
   //---------------------------------------------------------------------

    CM_Create_Range_List(&rlh1, 0);
    CM_Create_Range_List(&rlh2, 0);
    // Add range [10-20].
    CM_Add_Range(10, 20, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    // Add range [30-40].
    CM_Add_Range(30, 40, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    // Duplicate range list.
    CM_Dup_Range_List(rlh1, rlh2, 0);
    // There should be two ranges in rlh2, [10-20] and [30-40].
    // Get the first.
    CM_First_Range(rlh2, &ullStart, &ullEnd, &rElement, 0);
    // Get the next.
    CM_Next_Range(&rElement, &ullStart, &ullEnd, 0);  // *** Returns CR_FAILURE *** Should return CR_SUCCESS
    // Free the range lists.
    CM_Free_Range_List(rlh1, 0);
    CM_Free_Range_List(rlh2, 0);


    // Example2:
    CM_Create_Range_List(&rlh1, 0);
    CM_Create_Range_List(&rlh2, 0);
    // Add range [10-20][30-40].
    CM_Add_Range(10, 20, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    CM_Add_Range(30, 40, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    // Invert range list.
    CM_Invert_Range_List(rlh1, rlh2, 40, 0);
    // There should be two ranges [0-9] and [21-29].
    // Get the first.
    CM_First_Range(rlh2, &ullStart, &ullEnd, &rElement, 0);
    // Get the next.
    CM_Next_Range(&rElement, &ullStart, &ullEnd, 0);  // *** Returns CR_FAILURE *** Should return CR_SUCCESS
    // Free the range lists.
    CM_Free_Range_List(rlh1, 0);
    CM_Free_Range_List(rlh2, 0);


   //---------------------------------------------------------------------
   // Special Test 7 - error condition found by LeslieF
   //---------------------------------------------------------------------

    CM_Create_Range_List(&rlh1, 0);
    CM_Add_Range(10, 20, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    CM_Add_Range(30, 40, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    Status = CM_Test_Range_Available(9, 21, rlh1, 0);
    if (Status != CR_FAILURE) {
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
               (LPARAM)(LPTSTR)TEXT("Special Test 7 - failed"));
    }
    CM_Free_Range_List(rlh1, 0);


   //---------------------------------------------------------------------
   // Special Test 8 - error condition found by Bogdan
   //---------------------------------------------------------------------


   CM_Create_Range_List(&rlh1, 0);
   CM_Create_Range_List(&rlh2, 0);

   CM_Add_Range(0, 10, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_First_Range(rlh1, &ullStart, &ullEnd, &rElement, 0);

   if (ullStart != 0 || ullEnd != 10) {
       SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)TEXT("Special Test 8 - failure 1"));
   }
   // As expected, ullStart = 0 and ullEnd = 10

   CM_Invert_Range_List(rlh1, rlh2, 20, 0);
   CM_First_Range(rlh2, &ullStart, &ullEnd, &rElement, 0);
// Expected ullStart = 11, ullEnd = 20, but ullStart = 0 and ullEnd = 0xFFFFFFFFFFFFFFFFF
// The next range is correct one [11, 20]

   //CM_Next_Range(&rElement, &ullStart, &ullEnd, 0);


   CM_Free_Range_List(rlh1, 0);
   CM_Free_Range_List(rlh2, 0);
   CM_Free_Range_List(rlh2, 0); // test deleting already deleted range list


   return;

} // RegressionTest_Range



//-----------------------------------------------------------------------------
VOID
RegressionTest_Class(
      HWND  hDlg
      )
{
    CONFIGRET   Status = CR_SUCCESS;
    GUID        ClassGuid;
    UUID        ClassUuid;
    TCHAR       szClass[MAX_CLASS_NAME_LEN];
    DEVNODE     dnDevNode;
    TCHAR       szMsg[MAX_PATH], szMsg1[MAX_PATH];
    ULONG       ulStatus=0, ulProblem=0, ulLength = 0, ulSize = 0, i = 0;
    PTSTR       pBuffer = NULL;
    HKEY        hKey = NULL, hKey1 = NULL;


    #if 0
    i = 0;
    while (Status == CR_SUCCESS) {

        Status = CM_Enumerate_Classes_Ex(i, &ClassGuid, 0, hMachine);

        if (Status == CR_SUCCESS) {

            ulLength = MAX_CLASS_NAME_LEN;

            Status = CM_Get_Class_Name(&ClassGuid, szClass, &ulLength, 0);

            if (Status == CR_SUCCESS) {

                wsprintf(szMsg, TEXT("Class %d, Name: %s"), i, szClass);
                SendDlgItemMessage(
                     hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                     (LPARAM)(LPTSTR)szMsg);
            }
        }
        i++;
    }

    return;




   Status = CM_Locate_DevNode(&dnDevNode, NULL, 0);
   if (Status != CR_SUCCESS) {
      MessageBox(hDlg, TEXT("Locate Root failed"), TEXT("Test"), MB_OK);
      return;
   }

   Status = CM_Reenumerate_DevNode(dnDevNode, 0);
   if (Status != CR_SUCCESS) {
      MessageBox(hDlg, TEXT("Reenumeration of Root Failed"), TEXT("Test"), MB_OK);
   }



   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Test\\A1\\0000"), 0);
   if (Status != CR_SUCCESS) {
      return;
   }


   lstrcpy(szMsg, TEXT("1. Reenumerate Test\\A1\\0000: "));
   Status = CM_Reenumerate_DevNode(dnDevNode, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Test\\A2\\0001"), 0);
   if (Status != CR_SUCCESS) {
      return;
   }


   lstrcpy(szMsg, TEXT("2. QueryRemove SubTree Test\\A2\\0001: "));
   Status = CM_Query_Remove_SubTree(dnDevNode, CM_QUERY_REMOVE_UI_OK);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("3. Remove SubTree Test\\A2\\0001: "));
   Status = CM_Remove_SubTree(dnDevNode, CM_REMOVE_UI_OK);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   #endif

   lstrcpy(szMsg, TEXT("Test Delete Class Key only, no other keys exist"));

   UuidFromString(TEXT("00000000-0000-0000-0000-000000000000"), &ClassGuid);


   Status = CM_Open_Class_Key(&ClassGuid, TEXT("Madeup class"), KEY_ALL_ACCESS,
                              RegDisposition_OpenAlways, &hKey, 0);

   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Open_Class_Key Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("CM_Open_Class_Key Passed"));

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg1);
   RegCloseKey(hKey);



   Status = CM_Delete_Class_Key(&ClassGuid, CM_DELETE_CLASS_ONLY);

   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test Delete Class Key only, subkeys exist"));

   UuidFromString(TEXT("00000000-0000-0000-0000-000000000001"), &ClassGuid);

   Status = CM_Delete_Class_Key(&ClassGuid, CM_DELETE_CLASS_ONLY);

   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test Delete Class Key, subkeys too"));

   UuidFromString(TEXT("00000000-0000-0000-0000-000000000002"), &ClassGuid);

   Status = CM_Open_Class_Key(&ClassGuid, NULL, KEY_ALL_ACCESS,
                              RegDisposition_OpenAlways, &hKey, 0);

   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Open_Class_Key Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("CM_Open_Class_Key Passed"));

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg1);

   RegCreateKeyEx(hKey, TEXT("Subkey1"), 0, NULL, REG_OPTION_NON_VOLATILE,
                  KEY_ALL_ACCESS, NULL, &hKey1, NULL);

   MessageBox(NULL, TEXT("Does 0000...0002\\SubKey1 exist?"), TEXT("Test"), MB_OK);
   RegCloseKey(hKey);
   RegCloseKey(hKey1);



   Status = CM_Delete_Class_Key(&ClassGuid, CM_DELETE_CLASS_SUBKEYS);

   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Root\\Device001\\0000"), 0);
   if (Status != CR_SUCCESS) {
      return;
   }


   lstrcpy(szMsg, TEXT("4. Get Status for Test\\A2\\0001: "));
   Status = CM_Get_DevNode_Status(&ulStatus, &ulProblem, dnDevNode, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed, Status=%xh, Problem=%xh"), ulStatus, ulProblem);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);
   return;

} // RegressionTest_Class



//-----------------------------------------------------------------------------
VOID
RegressionTest_Traverse(
      HWND  hDlg
      )
{
   CONFIGRET Status = CR_SUCCESS;
   TCHAR     szMsg[MAX_PATH], szMsg1[MAX_PATH];
   DEVNODE   dnDevNode, dnRootDevNode, dnChildDevNode, dnParentDevNode;
   TCHAR     Buffer[512];
   ULONG     ulDepth;


   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____TRAVERSE REGRESSION TEST_____"));

   /*
   lstrcpy(szMsg, TEXT("1. Get parent of invalid devnode: "));
   Status = CM_Get_Parent(&dnDevNode, 1, 0);
   if (Status != CR_INVALID_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("2. Get parent of root: "));
   CM_Locate_DevNode(&dnRootDevNode, NULL, 0);
   Status = CM_Get_Parent(&dnDevNode, dnRootDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("3. Get parent with no BaseDevicePath value: "));
   CM_Locate_DevNode(&dnDevNode, szNoBaseDeviceID, 0);
   Status = CM_Get_Parent(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("4. Get parent that doesn't exist in registry: "));
   CM_Locate_DevNode(&dnDevNode, szMissingParentDeviceID, 0);
   Status = CM_Get_Parent(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("5. Get parent that isn't marked as found: "));
   CM_Locate_DevNode(&dnDevNode, szNotFoundParentDeviceID, 0);
   Status = CM_Get_Parent(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   wsprintf(szMsg, TEXT("6. Get parent that has been moved: "));
   CM_Locate_DevNode(&dnDevNode, szMovedParentDeviceID, 0);
   Status = CM_Get_Parent(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("7. Get valid parent: "));
   Status = CM_Locate_DevNode(&dnDevNode, szPresentDeviceID, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed Locate (%xh)"), Status);
   }
   else {
      Status = CM_Get_Parent(&dnParentDevNode, dnDevNode, 0);
      if (Status != CR_SUCCESS) {
         wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
      }
      else wsprintf(szMsg1, TEXT("Passed (DevNode=%xh)"), dnDevNode);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("8. Get child of invalid devnode: "));
   Status = CM_Get_Child(&dnDevNode, 1, 0);
   if (Status != CR_INVALID_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("9. Get child with no AttachedComponents: "));
   CM_Locate_DevNode(&dnDevNode, szNoAttachedDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("10. Get child that doesn't exist in registry: "));
   CM_Locate_DevNode(&dnDevNode, szMissingChildDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("11. Get child that isn't marked as found: "));
   CM_Locate_DevNode(&dnDevNode, szNotFoundChildDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("12. Get child that has been moved: "));
   CM_Locate_DevNode(&dnDevNode, szMovedChildDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("13. First child isn't valid: "));
   CM_Locate_DevNode(&dnDevNode, szValid2ndChildDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("14. Get valid child: "));
   Status = CM_Get_Child(&dnChildDevNode, dnParentDevNode, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("15. Get sibling of invalid devnode: "));
   Status = CM_Get_Sibling(&dnDevNode, 1, 0);
   if (Status != CR_INVALID_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("16. Get sibling of Root: "));
   Status = CM_Get_Sibling(&dnDevNode, dnRootDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("17. Get sibling with no AttachedComponents: "));
   CM_Locate_DevNode(&dnDevNode, szNoAttachedDeviceID, 0);
   Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("18. Get sibling that doesn't exist in registry: "));
   CM_Locate_DevNode(&dnDevNode, szMissingSiblingDeviceID, 0);
   CM_Get_Child(&dnDevNode, dnDevNode, 0);
   Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("19. Get sibling that isn't marked as found: "));
   CM_Locate_DevNode(&dnDevNode, szNotFoundSiblingDeviceID, 0);
   CM_Get_Child(&dnDevNode, dnDevNode, 0);
   Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("20. Get sibling that has been moved: "));
   CM_Locate_DevNode(&dnDevNode, szMovedSiblingDeviceID, 0);
   CM_Get_Child(&dnDevNode, dnDevNode, 0);
   Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   wsprintf(szMsg, TEXT("21. First sibling isn't valid: "));
   CM_Locate_DevNode(&dnDevNode, szValid3rdChildDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Get Child Failed (%xh)"), Status);
   } else {
      Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);
      if (Status != CR_SUCCESS) {
         wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
      }
      else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);
   */

   wsprintf(szMsg, TEXT("Finding all children of %s:"), szPresentDeviceID);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   CM_Locate_DevNode(&dnDevNode, szPresentDeviceID, 0);
   CM_Get_Child(&dnDevNode, dnDevNode, 0);
   CM_Get_Device_ID(dnDevNode, Buffer, MAX_PATH, 0);
   wsprintf(szMsg, TEXT("   Child DeviceID = %s (DevNode = %d)"),
         Buffer, dnDevNode);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   while (Status == CR_SUCCESS) {
      Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);

      if (Status == CR_SUCCESS) {
         CM_Get_Device_ID(dnDevNode, Buffer, MAX_PATH, 0);
         wsprintf(szMsg, TEXT("   Sibling DeviceID = %s (DevNode = %d)"),
               Buffer, dnDevNode);

         SendDlgItemMessage(
               hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
               (LPARAM)(LPTSTR)szMsg);
      }
   }

   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg, TEXT("CM_Get_Sibling failed (%xh)"), Status);

      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }


   //----------------------------------------------------------------
   // Do recursive traversal test
   //----------------------------------------------------------------


    // Create a new node.
    Status = CM_Locate_DevNode_Ex(&dnRootDevNode, NULL, 0, hMachine);
    if (Status == CR_SUCCESS) {
        if (TraverseAndCheckParents(dnRootDevNode)) {

            SendDlgItemMessage(
                  hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                  (LPARAM)(LPTSTR)TEXT("Recursive Traversal Test: PASSED"));

        } else {

            SendDlgItemMessage(
                  hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                  (LPARAM)(LPTSTR)TEXT("Recursive Traversal Test: FAILED"));
        }

    } else {
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)TEXT("Locate Root DevNode: FAILED"));
    }



   //----------------------------------------------------------------
   // Get Depth Test
   //----------------------------------------------------------------

   lstrcpy(szMsg, TEXT("Get Depth of Root: "));
   CM_Locate_DevNode_Ex(&dnDevNode, NULL, 0, hMachine);
   Status = CM_Get_Depth_Ex(&ulDepth, dnDevNode, 0, hMachine);
   if (Status != CR_SUCCESS  || ulDepth != 0) {
      wsprintf(szMsg1, TEXT("Failed, Depth = %d (%xh)"), ulDepth, Status);
   }
   else wsprintf(szMsg1, TEXT("Passed, Depth = %d (%xh)"), ulDepth, Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Get Depth of 1st Level Node: "));
   CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device001\\0000"), 0, hMachine);
   Status = CM_Get_Depth_Ex(&ulDepth, dnDevNode, 0, hMachine);
   if (Status != CR_SUCCESS  || ulDepth != 1) {
      wsprintf(szMsg1, TEXT("Failed, Depth = %d (%xh)"), ulDepth, Status);
   }
   else wsprintf(szMsg1, TEXT("Passed, Depth = %d (%xh)"), ulDepth, Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Get Depth of 2nd Level Node: "));
   CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device002\\0000"), 0, hMachine);
   Status = CM_Get_Depth_Ex(&ulDepth, dnDevNode, 0, hMachine);
   if (Status != CR_SUCCESS  || ulDepth != 2) {
      wsprintf(szMsg1, TEXT("Failed, Depth = %d (%xh)"), ulDepth, Status);
   }
   else wsprintf(szMsg1, TEXT("Passed, Depth = %d (%xh)"), ulDepth, Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   return;

} // RegressionTest_Traverse



//-----------------------------------------------------------------------------
VOID
RegressionTest_HardwareProfile(
    HWND  hDlg
    )
{
    CONFIGRET Status;
    TCHAR     szMsg[MAX_PATH], szMsg1[MAX_PATH];
    DEVNODE   dnDevNode;
    TCHAR     Buffer[512];
    HWPROFILEINFO     HWProfileInfo;
    ULONG     ulValue = 0, Index =0;
    ULONG   C0 = CSCONFIGFLAG_DO_NOT_CREATE;
    ULONG   C1 = CSCONFIGFLAG_DO_NOT_START;
    ULONG   C2 = CSCONFIGFLAG_DISABLED;


    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____HARDWARE PROFILES REGRESSION TEST_____"));


    /*
    lstrcpy(szMsg, TEXT("Get HwProf Flags for Missing Device ID: "));
    Status = CM_Get_HW_Prof_Flags(szNonExistantDeviceID, 0, &ulValue, 0);
    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, ulValue);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Get Hw Profile for invalid config: "));
    Status = CM_Get_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 13, &ulValue, 0);
    if (Status != CR_REGISTRY_ERROR) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, ulValue);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);



    //---------------------------------------------------------------
    // Profile 1
    //---------------------------------------------------------------

    lstrcpy(szMsg, TEXT("Set HwProf Flags for config 1: "));
    Status = CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 1, C1, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, C1);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, C1);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Get Hw Profile for config 1: "));
    ulValue = 0;
    Status = CM_Get_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 1, &ulValue, 0);
    if (Status != CR_SUCCESS || C1 != ulValue) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, ulValue);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, ulValue);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);



    //---------------------------------------------------------------
    // Profile 2
    //---------------------------------------------------------------

    lstrcpy(szMsg, TEXT("Set HwProf Flags for config 2: "));
    Status = CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 2, C2, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, C2);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, C2);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Get Hw Profile for config 2: "));
    ulValue = 0;
    Status = CM_Get_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 2, &ulValue, 0);
    if (Status != CR_SUCCESS || C2 != ulValue) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, ulValue);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, ulValue);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);


    //---------------------------------------------------------------
    // Current Profile
    //---------------------------------------------------------------

    lstrcpy(szMsg, TEXT("Set HwProf Flags for current config: "));
    Status = CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 0, C0, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, C0);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, C0);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Get Hw Profile for current config: "));
    ulValue = 0;
    Status = CM_Get_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 0, &ulValue, 0);
    if (Status != CR_SUCCESS || C0 != ulValue) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, ulValue);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, ulValue);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);

    */

    //---------------------------------------------------------------
    // Test CM_Get_HW_Prof_Info
    //---------------------------------------------------------------

    lstrcpy(szMsg, TEXT("Get HwProf Info test:"));

    Status = CM_Get_Hardware_Profile_Info_Ex(0xFFFFFFFF, &HWProfileInfo, 0, hMachine);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

    wsprintf(szMsg, TEXT("   Current (%u) HW Profile: %s, Flags=%xh"),
            HWProfileInfo.HWPI_ulHWProfile,
            HWProfileInfo.HWPI_szFriendlyName,
            HWProfileInfo.HWPI_dwFlags);

    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);


    Index = 0;
    Status = CR_SUCCESS;

    while (Status == CR_SUCCESS) {

        Status = CM_Get_Hardware_Profile_Info(Index, &HWProfileInfo, 0);

        if (Status == CR_SUCCESS) {

            wsprintf(szMsg, TEXT("   HW Profile %u: %s, Flags=%xh"),
                HWProfileInfo.HWPI_ulHWProfile,
                HWProfileInfo.HWPI_szFriendlyName,
                HWProfileInfo.HWPI_dwFlags);

            SendDlgItemMessage(
                hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                (LPARAM)(LPTSTR)szMsg);
        }
        Index++;
    }


   // reset to pre-test conditions
   CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 0, 0, 0);
   CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 1, 0, 0);
   CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 2, 0, 0);

   return;

} // RegressionTest_HardwareProfile



//-----------------------------------------------------------------------------
VOID
RegressionTest_DeviceList(
      HWND  hDlg
      )
{
    CONFIGRET   Status = CR_SUCCESS;
    PTSTR       pBuffer = NULL, p = NULL;
    ULONG       ulSize = 0;
    TCHAR       szMsg[MAX_PATH], szMsg1[MAX_PATH];
    TCHAR       pDeviceID[MAX_PATH];
    GUID        InterfaceGuid;
    TCHAR       szAlias[MAX_PATH];


    lstrcpy(szMsg, TEXT("Test Device ID List Size:"));

    Status = CM_Get_Device_ID_List_Size_Ex(&ulSize, NULL,
                             CM_GETIDLIST_FILTER_NONE, hMachine);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Test Device ID List:"));

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    Status = CM_Get_Device_ID_List_Ex(NULL, pBuffer, ulSize,
                              CM_GETIDLIST_FILTER_NONE, hMachine);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Device ID List (small buffer):"));

    Status = CM_Get_Device_ID_List_Ex(NULL, pBuffer, ulSize/2,
                              CM_GETIDLIST_FILTER_NONE, NULL);

    if (Status != CR_BUFFER_SMALL) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

    free(pBuffer);


    // initialize device instance and interface guid for tests

    lstrcpy(pDeviceID, TEXT("Root\\PnPTest\\0000"));
    UuidFromString(TEXT("aaaaaaa2-e3f0-101b-8488-00aa003e5601"), &InterfaceGuid);

    // Test 1.  No DevNode, Get Present

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)TEXT("Test 1 - No Devnode, Get-present"));
/*
    Status = CM_Get_Interface_Device_List_Size(&ulSize, &InterfaceGuid, 0,
                        CM_GET_INTERFACE_DEVICE_LIST_PRESENT);

    if (Status == CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Size = %d"), ulSize);
    } else {
        wsprintf(szMsg, TEXT("Error getting size, %d"), Status);
    }
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);
*/
ulSize = 0x53;

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    Status = CM_Get_Device_Interface_List(&InterfaceGuid, 0, pBuffer, ulSize,
                        CM_GET_DEVICE_INTERFACE_LIST_PRESENT);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Status = %d"), Status);

        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {

        for (p = pBuffer; *p; p += lstrlen(pBuffer) + 1) {

            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);
        }
    }

    free(pBuffer);


    // Test 2. Devnode specified, Get Present

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)TEXT("Test 2 - Devnode, Get-present"));

    Status = CM_Get_Device_Interface_List_Size(&ulSize, &InterfaceGuid, pDeviceID,
                        CM_GET_DEVICE_INTERFACE_LIST_PRESENT);

    if (Status == CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Size = %d"), ulSize);
    } else {
        wsprintf(szMsg, TEXT("Error getting size, %d"), Status);
    }
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    Status = CM_Get_Device_Interface_List(&InterfaceGuid, pDeviceID, pBuffer, ulSize,
                        CM_GET_DEVICE_INTERFACE_LIST_PRESENT);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Status = %d"), Status);

        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {
        for (p = pBuffer; *p; p += lstrlen(pBuffer) + 1) {

            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);
        }
    }

    free(pBuffer);


    // Test 3. No Devnode, Get All

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)TEXT("Test 3 - No Devnode, Get-all"));

    Status = CM_Get_Device_Interface_List_Size(&ulSize, &InterfaceGuid, 0,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    if (Status == CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Size = %d"), ulSize);
    } else {
        wsprintf(szMsg, TEXT("Error getting size, %d"), Status);
    }
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    Status = CM_Get_Device_Interface_List(&InterfaceGuid, 0, pBuffer, ulSize,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Status = %d"), Status);

        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {
        for (p = pBuffer; *p; p += lstrlen(pBuffer) + 1) {

            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);

            ulSize = MAX_PATH; 
            Status = CM_Get_Device_Interface_Alias(p, &InterfaceGuid, szAlias, &ulSize, 0);
            if (Status == CR_SUCCESS) {
                wsprintf(szMsg, TEXT("Alias: %s"), szAlias);
                SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                                       (LPARAM)(LPTSTR)szMsg);
            } else {
                wsprintf(szMsg, TEXT("Error getting alias, %d"), Status);
                SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                                       (LPARAM)(LPTSTR)szMsg);
            }
        }
    }

    free(pBuffer);


    // Test 4. Devnode specified, Get All

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)TEXT("Test 4 - Devnode, Get-all"));

    Status = CM_Get_Device_Interface_List_Size(&ulSize, &InterfaceGuid, pDeviceID,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    if (Status == CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Size = %d"), ulSize);
    } else {
        wsprintf(szMsg, TEXT("Error getting size, %d"), Status);
    }
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    Status = CM_Get_Device_Interface_List(&InterfaceGuid, pDeviceID, pBuffer, ulSize,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Status = %d"), Status);

        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {
        for (p = pBuffer; *p; p += lstrlen(pBuffer) + 1) {

            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);
        }
    }

    free(pBuffer);


    // Test 5. Get aliases

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)TEXT("Test 5 - Get aliases"));
    
    CM_Get_Device_Interface_List_Size(&ulSize, &InterfaceGuid, pDeviceID,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    CM_Get_Device_Interface_List(&InterfaceGuid, pDeviceID, pBuffer, ulSize,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    for (p = pBuffer; *p; p += lstrlen(pBuffer) + 1) {
        ulSize = MAX_PATH; 
        Status = CM_Get_Device_Interface_Alias(p, &InterfaceGuid, szAlias, &ulSize, 0);
        if (Status == CR_SUCCESS) {        
            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                                   (LPARAM)(LPTSTR)szAlias);
        } else {
            wsprintf(szMsg, TEXT("Error getting alias, %d"), Status);
            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                                   (LPARAM)(LPTSTR)szMsg);
        }
    }

    free(pBuffer);

    return;

} // RegressionTest_DeviceList



//-----------------------------------------------------------------------------
VOID
RegressionTest_CreateDevNode(
      HWND  hDlg
      )
{
   CONFIGRET   Status = CR_SUCCESS;
   DEVNODE     dnDevNode, dnParent, dnDevNode1, dnTemp;
   TCHAR       szMsg[MAX_PATH], szMsg1[MAX_PATH], szTemp[MAX_PATH];
   ULONG       ulSize = 0;


   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____CreateDevNode REGRESSION TEST_____"));


   lstrcpy(szMsg, TEXT("1. Locate Root DevNode: "));
   Status = CM_Locate_DevNode(&dnParent, NULL, CM_LOCATE_DEVNODE_NORMAL);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("2. Create Root\\CreateTest\\0000: "));
   Status = CM_Create_DevNode(&dnDevNode, TEXT("Root\\CreateTest\\0000"),
         dnParent, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("3. Locate Root\\CreateTest\\0000: "));
   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Root\\CreateTest\\0000"),
         CM_LOCATE_DEVNODE_NORMAL);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("4. Test generate id with bad device: "));
   Status = CM_Create_DevNode(&dnTemp, TEXT("Create\\Test"),
         dnParent, CM_CREATE_DEVNODE_GENERATE_ID);
   if (Status != CR_INVALID_DEVICE_ID) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("5. Create based on CreateTest1: "));
   Status = CM_Create_DevNode(&dnDevNode1, TEXT("CreateTest1"),
         dnParent, CM_CREATE_DEVNODE_GENERATE_ID);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("6. Create Phantom Root\\CreateTest2\\0000: "));
   Status = CM_Create_DevNode(&dnTemp, TEXT("Root\\CreateTest2\\0000"),
         dnParent, CM_CREATE_DEVNODE_PHANTOM);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("7. Uninstall phantom Root\\CreateTest2\\0000: "));
   Status = CM_Uninstall_DevNode(dnTemp, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("8. Uninstall real Root\\CreateTest1\\0000: "));
   Status = CM_Uninstall_DevNode(dnDevNode1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("8. Cancel remove or real Root\\CreateTest1\\0000: "));
   Status = CM_Locate_DevNode(&dnDevNode1, TEXT("Root\\CreateTest1\\0000"), CM_LOCATE_DEVNODE_CANCELREMOVE);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("9. Register device driver for Root\\Device001\\0000: "));
   Status = CM_Locate_DevNode(&dnDevNode1, TEXT("Root\\Device001\\0000"), CM_LOCATE_DEVNODE_NORMAL);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
       Status = CM_Register_Device_Driver(dnDevNode1,
                            CM_REGISTER_DEVICE_DRIVER_DISABLEABLE | CM_REGISTER_DEVICE_DRIVER_REMOVABLE);
       if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
       } else {
           wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
       }
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("REG1. test devnode handle consistency: "));

   // create device id with generated instance
   CM_Create_DevNode(&dnDevNode, TEXT("GenerateID"), dnParent,
                     CM_CREATE_DEVNODE_NORMAL | CM_CREATE_DEVNODE_GENERATE_ID);

  // Get back the device id
  CM_Get_Device_ID(dnDevNode, szTemp, MAX_PATH - 1, 0);

  wsprintf(szMsg, TEXT("   Generated device instance: %s"), szTemp);
  SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

  CM_Locate_DevNode(&dnDevNode1, szTemp, 0);

  if (dnDevNode != dnDevNode1) {

      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)TEXT("Created and located devnode handles don't match (error)"));
  } else {

      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)TEXT("Created and located devnode handles match (expected)"));
  }


    // if not generating an instance, the devinst must be a full valid devinst
    // with the three component parts.

    lstrcpy(szMsg, TEXT("REG2. Invalid device instance, no generate: "));

    Status = CM_Create_DevNode(&dnDevNode, TEXT("BadDevInst"), dnParent,
                               CM_CREATE_DEVNODE_NORMAL);

    if (Status == CR_INVALID_DEVINST) {
        lstrcat(szMsg, TEXT("Failed (expected)"));
    } else {
        lstrcat(szMsg, TEXT("Error: should've failed"));
    }

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);



   /*
   lstrcpy(szMsg, TEXT("9. Move CreateTest\\0000 to CreateTest1\\0000: "));
   Status = CM_Move_DevNode(dnDevNode, dnDevNode1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);
   */

   return;

} // RegressionTest_CreateDevNode


//-----------------------------------------------------------------------------
VOID
RegressionTest_Properties(
      HWND  hDlg
      )
{
   CONFIGRET   Status = CR_SUCCESS;
   DEVNODE     dnDevNode;
   TCHAR       szMsg[MAX_PATH], szMsg1[MAX_PATH], pszString[MAX_PATH];
   LPTSTR      p = NULL;
   ULONG       ulValue = 0, ulSize = 0, ulType = 0;
   TCHAR       pData[1024];


   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____Properties REGRESSION TEST_____"));

   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Root\\Device001\\0000"),
         CM_LOCATE_DEVNODE_NORMAL);
   if (Status != CR_SUCCESS) {
      return;
   }


   CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_FRIENDLYNAME, NULL, 0, 0);

   lstrcpy(szMsg, TEXT("Set/Get CM_DRP_FRIENDLYNAME: "));

   lstrcpy(pszString, TEXT("FriendlyName"));
   ulSize = (lstrlen(pszString) + 1) * sizeof(TCHAR);

   Status = CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_FRIENDLYNAME,
        pszString, ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      pszString[0] = '\0';
      Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_FRIENDLYNAME,
            &ulType, pszString, &ulSize, 0);
      if (Status != CR_SUCCESS) {
         wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
      }
      else wsprintf(szMsg1, TEXT("Passed, %s, %d"), pszString, ulType);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);




   CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_DEVICEDESC, NULL, 0, 0);

   lstrcpy(szMsg, TEXT("Set/Get DeviceDesc: "));

   lstrcpy(pszString, TEXT("DeviceDesc"));
   ulSize = (lstrlen(pszString) + 1) * sizeof(TCHAR);

   Status = CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_DEVICEDESC,
        pszString, ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      pszString[0] = '\0';
      Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_DEVICEDESC,
            &ulType, pszString, &ulSize, 0);
      if (Status != CR_SUCCESS) {
         wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
      }
      else wsprintf(szMsg1, TEXT("Passed, %s, %d"), pszString, ulType);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_CONFIGFLAGS, NULL, 0, 0);

   lstrcpy(szMsg, TEXT("Set/Get CM_DRP_CONFIGFLAGS: "));

   ulValue = 0x0008;
   ulSize = sizeof(DWORD);

   Status = CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_CONFIGFLAGS,
        &ulValue, ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      ulValue = 0;
      Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_CONFIGFLAGS,
            &ulType, &ulValue, &ulSize, 0);
      if (Status != CR_SUCCESS) {
         wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
      }
      else wsprintf(szMsg1, TEXT("Passed, %d, %d"), ulValue, ulType);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


    //
    // CM_DRP_LOCATION_INFORMATION
    //
    lstrcpy(szMsg, TEXT("CM_DRP_LOCATION_INFORMATION: "));

    lstrcpy(pszString, TEXT("Madeup location"));
    ulSize = (lstrlen(pszString) + 1) * sizeof(TCHAR);

    Status = CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_LOCATION_INFORMATION,
                                              pszString, ulSize, 0);
    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    } else {
        pszString[0] = '\0';
        Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_LOCATION_INFORMATION,
                                                  &ulType, pszString, &ulSize, 0);
        if (Status != CR_SUCCESS) {
            wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        } else {
            wsprintf(szMsg1, TEXT("Passed, %s, %d"), pszString, ulType);
        }
    }

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    //
    // CM_DRP_UPPER_FILTERS
    //
    lstrcpy(szMsg, TEXT("CM_DRP_LOWERFILTERS: "));

    ulSize = MAX_PATH/sizeof(WCHAR);
    pszString[0] = '\0';
    Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_LOWERFILTERS,
                                                  &ulType, pszString, &ulSize, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {
        wsprintf(szMsg1, TEXT("Passed, %d"), ulType);

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);

        for (p = pszString; *p; p += lstrlen(p) + 1) {
            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);
        }
    }

    //
    // CM_DRP_UPPER_FILTERS
    //
    lstrcpy(szMsg, TEXT("CM_DRP_UPPERFILTERS: "));

    ulSize = MAX_PATH/sizeof(WCHAR);
    pszString[0] = '\0';
    Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_UPPERFILTERS,
                                                  &ulType, pszString, &ulSize, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {
        wsprintf(szMsg1, TEXT("Passed, %d"), ulType);

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);

        for (p = pszString; *p; p += lstrlen(p) + 1) {
            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);
        }
    }


    //
    // CM_DRP_CAPABILITIES
    //
    lstrcpy(szMsg, TEXT("CM_DRP_CAPABILITIES: "));

    ulSize = sizeof(DWORD);
    ulValue = 0;
    Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_CAPABILITIES,
                                              &ulType, &ulValue, &ulSize, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    } else {
        wsprintf(szMsg1, TEXT("Passed, value = %d, %d"), ulValue, ulType);
    }

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    //
    // CM_DRP_UI_NUMBER
    //
    lstrcpy(szMsg, TEXT("CM_DRP_UI_NUMBER: "));

    ulSize = sizeof(DWORD);
    ulValue = 0;
    Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_UI_NUMBER,
                                              &ulType, &ulValue, &ulSize, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    } else {
        wsprintf(szMsg1, TEXT("Passed, value = %d, %d"), ulValue, ulType);
    }

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    //
    // Another special test, go to a real devnode made by pnptest for this property
    // since it's not in the registry: CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME
    //
    Status = CM_Locate_DevNode(&dnDevNode, TEXT("PnPTest\\Pdo0\\Root&LEGACY_PNPTEST&0000&1111"),
          CM_LOCATE_DEVNODE_NORMAL);
    if (Status != CR_SUCCESS) {
       return;
    }

    lstrcpy(szMsg, TEXT("CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME: "));

    ulSize = MAX_PATH/sizeof(WCHAR);
    pszString[0] = '\0';
    Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                                  &ulType, pszString, &ulSize, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    } else {
        wsprintf(szMsg1, TEXT("Passed, %s, %d"), pszString, ulType);
    }

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);




   //----------------------------------------------------------------
   // Add_ID test
   //----------------------------------------------------------------


   // clear hardware id property
   CM_Set_DevNode_Registry_Property_Ex(dnDevNode, CM_DRP_HARDWAREID, NULL,
                                       0, 0, hMachine);

   lstrcpy(szMsg, TEXT("Add Hardware ID (SomeHardwareID\\0001): "));

   Status = CM_Add_ID_Ex(dnDevNode, TEXT("SomeHardwareID\\0001"),
                         CM_ADD_ID_HARDWARE, hMachine);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Add Hardware ID (AnotherHardwareID\\0002): "));

   Status = CM_Add_ID_Ex(dnDevNode, TEXT("AnotherHardwareID\\0002"),
                         CM_ADD_ID_HARDWARE, hMachine);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);


   ulSize = 1024;
   Status = CM_Get_DevNode_Registry_Property_Ex(dnDevNode, CM_DRP_HARDWAREID,
         &ulType, pData, &ulSize, 0, hMachine);

   lstrcpy(szMsg, TEXT("Current HardwareID: "));
   for (p = pData; *p; p += lstrlen(p) + 1) {
       lstrcat(szMsg, p);
       lstrcat(szMsg, TEXT(" "));
   }

   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



      // clear compatible id property
   CM_Set_DevNode_Registry_Property_Ex(dnDevNode, CM_DRP_COMPATIBLEIDS, NULL,
                                       0, 0, hMachine);

   lstrcpy(szMsg, TEXT("Add Compatible ID (SomeCompatibleID\\0001): "));

   Status = CM_Add_ID_Ex(dnDevNode, TEXT("SomeCompatibleID\\0001"),
                         CM_ADD_ID_COMPATIBLE, hMachine);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Add Compatible ID (AnotherCompatibleID\\0002): "));

   Status = CM_Add_ID_Ex(dnDevNode, TEXT("AnotherCompatibleID\\0002"),
                         CM_ADD_ID_COMPATIBLE, hMachine);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);


   ulSize = 1024;
   Status = CM_Get_DevNode_Registry_Property_Ex(dnDevNode, CM_DRP_COMPATIBLEIDS,
         &ulType, pData, &ulSize, 0, hMachine);

   lstrcpy(szMsg, TEXT("Current CompatibleID: "));
   for (p = pData; *p; p += lstrlen(p) + 1) {
       lstrcat(szMsg, p);
       lstrcat(szMsg, TEXT(" "));
   }

   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



   /*
   lstrcpy(szMsg, TEXT("Read CM_DRP_DEVICEDESC: "));
   ulSize = MAX_PATH;
   Status = CM_Get_DevNode_Registry_Property(
         dnDevNode, CM_DRP_DEVICEDESC, &ulType, pszString, &ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed, %s %d"), pszString, ulType);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("2. Read CM_DRP_HARDWAREID: "));
   ulSize = MAX_PATH;
   Status = CM_Get_DevNode_Registry_Property(
         dnDevNode, CM_DRP_HARDWAREID, &ulType, pszString, &ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed, %d, "), ulType);
      for (p = pszString; *p; p += lstrlen(p)+1) {
         lstrcat(szMsg1, p);
      }
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("3. Read CM_DRP_COMPATIBLEIDS: "));
   ulSize = MAX_PATH;
   Status = CM_Get_DevNode_Registry_Property(
         dnDevNode, CM_DRP_COMPATIBLEIDS, &ulType, pszString, &ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed, %d, "), ulType);
      for (p = pszString; *p; p += lstrlen(p)+1) {
         lstrcat(szMsg1, p);
      }
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("4. Read CM_DRP_CONFIGFLAGS: "));
   ulSize = sizeof(ULONG);
   Status = CM_Get_DevNode_Registry_Property(
        dnDevNode, CM_DRP_CONFIGFLAGS, &ulType, &ulValue, &ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed, %d %d"), ulValue, ulType);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

   */


   return;

} // RegressionTest_Properties


//-----------------------------------------------------------------------------
VOID
RegressionTest_DeviceClass(
    HWND  hDlg
    )
{
    CONFIGRET Status;
    TCHAR     szMsg[MAX_PATH], szMsg1[MAX_PATH];
    TCHAR     szDevice[MAX_PATH], szReference[MAX_PATH], szInterfaceDevice[MAX_PATH];
    DEVNODE   dnDevNode;
    TCHAR     Buffer[512];
    PTSTR     pBuffer = NULL;
    GUID      InterfaceGuid;
    ULONG     ulSize;

    lstrcpy(szDevice, TEXT("PnPTest\\Pdo0\\Root&LEGACY_PNPTEST&0000&1111"));
    //UuidFromString(TEXT("aaaaaaa2-e3f0-101b-8488-00aa003e5601"), &InterfaceGuid);
    UuidFromString(TEXT("11111111-2222-3333-4444-555555555555"), &InterfaceGuid);

    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____DEVICE CLASS REGRESSION TEST_____"));

    //
    // get a devinst handle for this device instance
    //

    Status = CM_Locate_DevNode(&dnDevNode, szDevice, CM_LOCATE_DEVNODE_NORMAL);
    if (Status != CR_SUCCESS) {
       return;
    }

    //
    // Register a device class assocation with a ref string
    //

    lstrcpy(szReference, TEXT("RefStringA"));
    ulSize = MAX_PATH;
    Status = CM_Register_Device_Interface(dnDevNode, &InterfaceGuid,
                                                   szReference, szInterfaceDevice,
                                                   &ulSize, 0);

    if (Status == CR_SUCCESS) {
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szInterfaceDevice);
    } else {
        wsprintf(szMsg, TEXT("Error registering dev class association, %d"), Status);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    }

    //
    // Unregister the device class association
    //

    Status = CM_Unregister_Device_Interface(szInterfaceDevice, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Error unregistering dev class association, %d"), Status);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    }

    //
    // Register a device class association without a ref string
    //

    ulSize = MAX_PATH;
    Status = CM_Register_Device_Interface(dnDevNode, &InterfaceGuid,
                                                   NULL, szInterfaceDevice,
                                                   &ulSize, 0);

    if (Status == CR_SUCCESS) {
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szInterfaceDevice);
    } else {
        wsprintf(szMsg, TEXT("Error registering dev class association, %d"), Status);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    }

    //
    // Unregister the device class association
    //

    Status = CM_Unregister_Device_Interface(szInterfaceDevice, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Error unregistering dev class association, %d"), Status);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    }


    return;

} // RegressionTest_DeviceClass



BOOL
DisplayRange(
   IN HWND  hDlg,
   IN RANGE_LIST rlh
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   DWORDLONG   ulStart = 0, ulEnd = 0;
   TCHAR       szMsg[MAX_PATH], szTemp[MAX_PATH];
   RANGE_LIST  rlh1;
   RANGE_ELEMENT rlElement;


   Status = CM_First_Range(rlh, &ulStart, &ulEnd, &rlElement, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_First_Range failed (%xh)"), Status);
      goto Clean0;
   }

   wsprintf(szMsg, TEXT("(%d,%d)"), (DWORD)ulStart, (DWORD)ulEnd);


   while (Status == CR_SUCCESS) {
      Status = CM_Next_Range(&rlElement, &ulStart, &ulEnd, 0);
      if (Status == CR_SUCCESS) {
         wsprintf(szTemp, TEXT(",(%d,%d)"), (DWORD)ulStart, (DWORD)ulEnd);
         lstrcat(szMsg, szTemp);
      }
   }

   Clean0:

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   return TRUE;

} // DisplayRange




BOOL
TraverseAndCheckParents (
    DEVNODE dnParent
    )
{
    CONFIGRET configRet;
    DEVNODE   dnChild, dnDevNode;

    // Get first child.
    configRet = CM_Get_Child_Ex(&dnChild, dnParent, 0, hMachine);

    if ((configRet != CR_SUCCESS) && (configRet != CR_NO_SUCH_DEVNODE)) {
        MessageBox(NULL, TEXT("CM_Get_Child failed"), TEXT("Traversal Test"), MB_OK);
        return FALSE;
    }

    // Check to see that the parent is correct and iterate thru the siblings.
    while (configRet == CR_SUCCESS) {
        configRet = CM_Get_Parent_Ex(&dnDevNode, dnChild, 0, hMachine);
        if (configRet == CR_SUCCESS) {
            if (dnDevNode != dnParent) {
                // No parent, or not the correct parent.
                MessageBox(NULL, TEXT("Not correct parent"), TEXT("Traversal Test"), MB_OK);
                return FALSE;
            }
        } else {
            MessageBox(NULL, TEXT("CM_Get_Parent failed"), TEXT("Traversal Test"), MB_OK);
            return FALSE;
        }

        // Recursively traverse the hardware tree.
        if (!TraverseAndCheckParents(dnChild)) {
            return FALSE;
        }

        // Iterate thru the siblings.
        configRet = CM_Get_Sibling_Ex(&dnChild, dnChild, 0, hMachine);

        if ((configRet != CR_SUCCESS) && (configRet != CR_NO_SUCH_DEVNODE)) {
            MessageBox(NULL, TEXT("CM_Get_Sibling failed"), TEXT("Traversal Test"), MB_OK);
            return FALSE;
        }
    }

    return TRUE;

} // TraverseAndCheckParents
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\wowreg32\wowreg.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wowreg.c

Abstract:

    This is the surragate process for registration of 32 dlls from a 64 bit process.
    And vice-versa.

    The parent process passes relevent IPC data on the cmdline, and the surragate
    process then coordinates the registration of this data with the parent process.

Author:

    Andrew Ritz (andrewr) 3-Feb-2000

Revision History:

    Andrew Ritz (andrewr) 3-Feb-2000 - Created It

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <stdio.h>
#include <setupapi.h>
#include <spapip.h>
#include <ole2.h>
#include <rc_ids.h>

#ifndef UNICODE
#error UNICODE assumed
#endif

#ifndef _WIN64
#include <wow64t.h>
#endif

#include "..\unicode\msg.h"
#include "memory.h"
#include "..\sputils\locking.h"
#include "childreg.h"
#include "cntxtlog.h"


#define DLLINSTALL      "DllInstall"
#define DLLREGISTER     "DllRegisterServer"
#define DLLUNREGISTER   "DllUnregisterServer"

typedef struct _OLE_CONTROL_DATA {
    LPTSTR              FullPath;
    UINT                RegType;
    PVOID               LogContext;

    BOOL                Register; // or unregister

    LPCTSTR             Argument;

} OLE_CONTROL_DATA, *POLE_CONTROL_DATA;

#if DBG

VOID
WowRegAssertFailed(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    LPSTR Msg;
    DWORD MsgLen;
    DWORD GlobalSetupFlags = pSetupGetGlobalFlags();

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(NULL,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    MsgLen = strlen(p)+strlen(FileName)+strlen(Condition)+128;
    try {

        Msg = _alloca(MsgLen);

        wsprintfA(
            Msg,
            "Assertion failure at line %u in file %s!%s: %s%s",
            LineNumber,
            p,
            FileName,
            Condition,
            (GlobalSetupFlags & PSPGF_NONINTERACTIVE) ? "\r\n" : "\n\nCall DebugBreak()?"
            );

        OutputDebugStringA(Msg);

        if(GlobalSetupFlags & PSPGF_NONINTERACTIVE) {
            i = IDYES;
        } else {
            i = MessageBoxA(
                    NULL,
                    Msg,
                    p,
                    MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
                    );
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        OutputDebugStringA("WOWREG32 ASSERT!!!! (out of stack)\r\n");
        i=IDYES;
    }
    if(i == IDYES) {
        DebugBreak();
    }
}

#define MYASSERT(x)     if(!(x)) { WowRegAssertFailed(__FILE__,__LINE__,#x); }

#else
#define MYASSERT(x)
#endif

VOID
DebugPrintEx(
    DWORD Level,
    PCTSTR format,
    ...                                 OPTIONAL
    )

/*++

Routine Description:

    Send a formatted string to the debugger.

Arguments:

    format - standard printf format string.

Return Value:

    NONE.

--*/

{
    TCHAR buf[1026];    // bigger than max size
    va_list arglist;

    va_start(arglist, format);
    wvsprintf(buf, format, arglist);
    DbgPrintEx(DPFLTR_SETUP_ID, Level, (PCH)"%ws",buf);
}

BOOL
RegisterUnregisterControl(
    PWOW_IPC_REGION_TOSURRAGATE pControlDataFromRegion,
    PDWORD FailureCode);


#define IDLE_TIMER                    1000*60  // 60 seconds
//
// Keep statistics...
//
INT    RegisteredControls = 0;

PWSTR  RegionName;
PWSTR  SignalReadyEvent;
PWSTR  SignalCompleteEvent;
PWSTR  ThisProgramName;
#ifndef _WIN64
BOOL   Wow64 = FALSE;
#endif


BOOL
ParseArgs(
    IN int   argc,
    IN PWSTR *argv
    )
{
    int i;

    ThisProgramName = argv[0];


    if(argc != 7) { // program name plus 3 required switches and their input
        return(FALSE);
    }

    for (i = 0; i < argc; i++) {
        if (0 == _wcsicmp(argv[i],SURRAGATE_REGIONNAME_SWITCH)) {
            RegionName = argv[i+1];
        }

        if (0 == _wcsicmp(argv[i],SURRAGATE_SIGNALREADY_SWITCH)) {
            SignalReadyEvent = argv[i+1];
        }

        if (0 == _wcsicmp(argv[i],SURRAGATE_SIGNALCOMPLETE_SWITCH)) {
            SignalCompleteEvent = argv[i+1];
        }
    }

    if (!SignalCompleteEvent || !SignalReadyEvent || !RegionName) {
        return(FALSE);
    }

    return(TRUE);

}

void
Usage(
    VOID
    )
{
    TCHAR Buffer[2048];
    if(LoadString(GetModuleHandle(NULL),IDS_WRONGUSE,Buffer,sizeof(Buffer)/sizeof(TCHAR))) {
        _ftprintf( stderr,TEXT("%s\n"),Buffer);
    }
}

int
__cdecl
main(
    IN int   argc,
    IN char *argvA[]
    )
{
    BOOL b;
    PWSTR *argv;
    HANDLE hReady = NULL;
    HANDLE hComplete = NULL;
    HANDLE hFileMap = NULL;
    PVOID  Region = NULL;
    PWOW_IPC_REGION_TOSURRAGATE pInput;
    PWOW_IPC_REGION_FROMSURRAGATE pOutput;
    HANDLE hEvent[1];
    DWORD WaitResult, FailureCode;

#ifndef _WIN64
    {
        ULONG_PTR       ul = 0;
        NTSTATUS        st;
        st = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessWow64Information,
                                       &ul,
                                       sizeof(ul),
                                       NULL);

        if (NT_SUCCESS(st) && (0 != ul)) {
            // 32-bit code running on Win64
            Wow64 = TRUE;
        }
    }
#endif

    //
    // Assume failure.
    //
    b = FALSE;

    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if (!argv) {
        //
        // out of memory ?
        //
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: Low Memory\n");
        goto exit;
    }


    if(!ParseArgs(argc,argv)) {
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: Invalid Usage\n");
        Usage();
        goto exit;
    }


    //
    // open the region and the named events
    //

    hFileMap = OpenFileMapping(
          FILE_MAP_READ| FILE_MAP_WRITE,
          FALSE,
          RegionName
          );
    if (!hFileMap) {
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: OpenFileMapping (%s) failed, ec = %x\n", RegionName, GetLastError());
        goto exit;
    }

    Region = MapViewOfFile(
                  hFileMap,
                  FILE_MAP_READ | FILE_MAP_WRITE,
                  0,
                  0,
                  0
                  );
    if (!Region) {
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: MapViewOfFile failed, ec = %x\n", GetLastError());
        goto exit;
    }

    hReady = OpenEvent(EVENT_MODIFY_STATE | SYNCHRONIZE,FALSE, SignalReadyEvent);
    if (!hReady) {
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: OpenEvent (%s) failed, ec = %x\n", SignalReadyEvent, GetLastError());
        goto exit;
    }

    hComplete = OpenEvent(EVENT_MODIFY_STATE | SYNCHRONIZE,FALSE, SignalCompleteEvent);
    if (!hComplete) {
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: OpenEvent (%s) failed, ec = %x\n", SignalCompleteEvent, GetLastError());
        goto exit;
    }

    pInput  = (PWOW_IPC_REGION_TOSURRAGATE)   Region;
    pOutput = (PWOW_IPC_REGION_FROMSURRAGATE) Region;

    //
    // the process is now initialized.  we now wait for either our event to be
    // signalled or for our idle timer to fire, in which case we will exit the
    // program
    //
    hEvent[0] = hReady;

    while (1) {

        do {
            WaitResult = MsgWaitForMultipleObjectsEx(
                                                1,
                                                &hEvent[0],
                                                IDLE_TIMER,
                                                QS_ALLINPUT,
                                                MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);

            if (WaitResult == WAIT_OBJECT_0 + 1) {
                MSG msg;

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        } while(WaitResult != WAIT_TIMEOUT &&
                WaitResult != WAIT_OBJECT_0 &&
                WaitResult != WAIT_FAILED);


        if (WaitResult == WAIT_TIMEOUT) {
            //
            // we hit the idle timer, so let the process unwind and go away now.
            //
            //
            // it doesn't matter too much, but make the return code "false" if the
            // process has gone away without ever registering any controls.
            //
            b = (RegisteredControls != 0);

            break;

        }

        MYASSERT(WaitResult == WAIT_OBJECT_0);

        //
        // reset our event so we only process each control one time
        //
        ResetEvent(hReady);

        //
        // register the control
        //
        b = RegisterUnregisterControl(pInput,&FailureCode);
#ifdef PRERELEASE
        if (!b) {
            DebugPrintEx(
                DPFLTR_ERROR_LEVEL,
                L"First call to register control failed, trying again.\n"
                L"If you have a debugger attached to this process, it will"
                L" now call DebugBreak() so that you can debug this registration failure\n" );
            if (IsDebuggerPresent()) {
                DebugBreak();
            }
            b = RegisterUnregisterControl(pInput,&FailureCode);
        }
#endif

        //
        // write an output status.  Note that you cannot access pInput after
        // this point because pOutput and pInput are overloaded views of the
        // same memory region.
        //
        pOutput->Win32Error = b ? ERROR_SUCCESS : GetLastError();
        pOutput->FailureCode= b ? SPREG_SUCCESS : FailureCode;

        //
        // set an event to tell the parent process to read our status and give
        // us the next control to register.
        //
        SetEvent(hComplete);

        if (b) {
            RegisteredControls += 1;
        }


    }

    fprintf( stdout,"Registered %d controls\n", RegisteredControls );

    DebugPrintEx(
            DPFLTR_INFO_LEVEL,
            L"WOWREG32: registered %d controls\n", RegisteredControls);

exit:
    if (Region) {
        UnmapViewOfFile( Region );
    }

    if (hFileMap) {
        CloseHandle(hFileMap);
    }

    if (hReady) {
        CloseHandle(hReady);
    }

    if (hComplete) {
        CloseHandle(hComplete);
    }


    return(b);
}


DWORD
pSetupRegisterDllInstall(
    IN POLE_CONTROL_DATA OleControlData,
    IN HMODULE ControlDll,
    IN PDWORD ExtendedStatus
    )
/*++

Routine Description:

    call the "DllInstall" entrypoint for the specified dll

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA structure for the dll
                     to be registered

    ControlDll - module handle to the dll to be registered

    ExtendedStatus - receives updated SPREG_* flag indicating outcome


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HRESULT (__stdcall *InstallRoutine) (BOOL bInstall, LPCTSTR pszCmdLine);
    HRESULT InstallStatus;

    DWORD d = NO_ERROR;

    //
    // parameter validation
    //
    if (!ControlDll) {
        *ExtendedStatus = SPREG_UNKNOWN;
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get function pointer to "DllInstall" entrypoint
    //
    InstallRoutine = NULL; // shut up PreFast
    try {
        (FARPROC)InstallRoutine = GetProcAddress(
            ControlDll, DLLINSTALL );
    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ExceptionPointers) {
        //
        // something went wrong...record an error
        //
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_INTERNAL_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...exception in GetProcAddress handled\n");

        *ExtendedStatus = SPREG_GETPROCADDR;

    } else if(InstallRoutine) {
        //
        // now call the function
        //
        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: installing...\n");

        *ExtendedStatus = SPREG_DLLINSTALL;
        try {

            InstallStatus = InstallRoutine(OleControlData->Register, OleControlData->Argument);

            if(FAILED(InstallStatus)) {

                d = InstallStatus;

                WriteLogEntry(
                    OleControlData->LogContext,
                    SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                    MSG_LOG_OLE_CONTROL_API_FAILED,
                    NULL,
                    OleControlData->FullPath,
                    TEXT(DLLINSTALL)
                    );
                WriteLogError(OleControlData->LogContext,
                              SETUP_LOG_ERROR,
                              d);

            } else if(InstallStatus != S_OK) {
                WriteLogEntry(OleControlData->LogContext,
                    SETUP_LOG_WARNING,
                    MSG_LOG_OLE_CONTROL_API_WARN,
                    NULL,
                    OleControlData->FullPath,
                    TEXT(DLLINSTALL),
                    InstallStatus
                    );
            } else {
                WriteLogEntry(
                    OleControlData->LogContext,
                    SETUP_LOG_VERBOSE,
                    MSG_LOG_OLE_CONTROL_API_OK,
                    NULL,
                    OleControlData->FullPath,
                    TEXT(DLLINSTALL)
                    );
            }
        } except (
            ExceptionPointers = GetExceptionInformation(),
            EXCEPTION_EXECUTE_HANDLER) {

            d = ExceptionPointers->ExceptionRecord->ExceptionCode;

            WriteLogEntry(
                OleControlData->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_OLE_CONTROL_API_EXCEPTION,
                NULL,
                OleControlData->FullPath,
                TEXT(DLLINSTALL)
                );

            DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...exception in DllInstall handled\n");

        }

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...installed\n");
    } else {
        *ExtendedStatus = SPREG_GETPROCADDR;
    }

    return d;

}

DWORD
pSetupRegisterDllRegister(
    IN POLE_CONTROL_DATA OleControlData,
    IN HMODULE ControlDll,
    IN PDWORD ExtendedStatus
    )
/*++

Routine Description:

    call the "DllRegisterServer" or "DllUnregisterServer" entrypoint for the
    specified dll

Arguments:

    OleControlData - contains data about dll to be registered
    ControlDll - module handle to the dll to be registered

    ExtendedStatus - receives an extended status depending on the outcome of
                     this operation


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HRESULT (__stdcall *RegisterRoutine) (VOID);
    HRESULT RegisterStatus;

    DWORD d = NO_ERROR;

    //
    // parameter validation
    //
    if (!ControlDll) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get the function pointer to the actual routine we want to call
    //
    RegisterRoutine = NULL; // shut up preFast
    try {
        (FARPROC)RegisterRoutine = GetProcAddress(
            ControlDll, OleControlData->Register ? DLLREGISTER : DLLUNREGISTER);
    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ExceptionPointers) {

        //
        // something went wrong, horribly wrong
        //
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_INTERNAL_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...exception in GetProcAddress handled\n");

        *ExtendedStatus = SPREG_GETPROCADDR;

    } else if(RegisterRoutine) {

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: registering...\n");
        *ExtendedStatus = SPREG_REGSVR;
        try {

            RegisterStatus = RegisterRoutine();

            if(FAILED(RegisterStatus)) {

                d = RegisterStatus;

                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_OLE_CONTROL_API_FAILED,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                              );

                WriteLogError(OleControlData->LogContext,
                              SETUP_LOG_ERROR,
                              d);
            } else if(RegisterStatus != S_OK) {
                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_OLE_CONTROL_API_WARN,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER),
                              RegisterStatus
                              );
            } else {
                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_VERBOSE,
                              MSG_LOG_OLE_CONTROL_API_OK,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                              );
            }

        } except (
            ExceptionPointers = GetExceptionInformation(),
            EXCEPTION_EXECUTE_HANDLER) {

            d = ExceptionPointers->ExceptionRecord->ExceptionCode;

            WriteLogEntry(
                OleControlData->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_OLE_CONTROL_API_EXCEPTION,
                NULL,
                OleControlData->FullPath,
                OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                );
            DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...exception in DllRegisterServer handled\n");

        }

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...registered\n");

    } else {

        d = GetLastError();

        WriteLogEntry(OleControlData->LogContext,
                      SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                      MSG_LOG_OLE_CONTROL_NOT_REGISTERED_GETPROC_FAILED,
                      NULL,
                      OleControlData->FullPath,
                      OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                      );

        WriteLogError(OleControlData->LogContext,
                      SETUP_LOG_ERROR,
                      d);


        *ExtendedStatus = SPREG_GETPROCADDR;

    }

    return d;
}

DWORD
pSetupRegisterLoadDll(
    IN  POLE_CONTROL_DATA OleControlData,
    OUT HMODULE *ControlDll
    )
/*++

Routine Description:

    get the module handle to the specified dll

Arguments:

    OleControlData - contains path to dll to be loaded

    ControlDll - module handle for the dll


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;

    DWORD d = NO_ERROR;

    DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: loading dll...\n");

#ifndef _WIN64
    if(Wow64) {
        //
        // don't remap directory the directory that the caller provided
        //
        Wow64DisableFilesystemRedirector(OleControlData->FullPath);
    }
#endif

    try {

        *ControlDll = LoadLibrary(OleControlData->FullPath);

    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }

#ifndef _WIN64
    if(Wow64) {
        //
        // re-enable the redirection on this file
        //
        Wow64EnableFilesystemRedirector();
    }
#endif

    if(ExceptionPointers) {

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_LOADLIBRARY_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...exception in LoadLibrary handled\n");
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

    } else if (!*ControlDll) {
        d = GetLastError();

        //
        // LoadLibrary failed.
        // File not found is not an error. We want to know about
        // other errors though.
        //

        d = GetLastError();

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...dll not loaded (%u)\n",d);

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
            MSG_LOG_OLE_CONTROL_LOADLIBRARY_FAILED,
            NULL,
            OleControlData->FullPath
            );
        WriteLogError(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            d
            );

    } else {
        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...dll loaded\n");
    }

    return d;

}

BOOL
RegisterUnregisterControl(
    PWOW_IPC_REGION_TOSURRAGATE RegistrationData,
    PDWORD  FailureCode
    )
/*++

Routine Description:

    main registration routine for registering a dll.

Arguments:

    RegistrationData - pointer to WOW_IPC_REGION_TOSURRAGATE structure indicating
                       file to be processed
    FailureCode      - SPREG_* code indicating outcome of operation.

Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HMODULE ControlDll = NULL;
    PTSTR Extension;
    DWORD d = NO_ERROR;
    DWORD Count;
    OLE_CONTROL_DATA OleControlData;
    WCHAR Path[MAX_PATH];
    PWSTR p;

    //
    // could use CoInitializeEx as an optimization as OleInitialize is
    // probably overkill...but this is probably just a perf hit at
    // worst
    //
    DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: calling OleInitialize\n");

    OleControlData.FullPath = RegistrationData->FullPath;
    OleControlData.Argument = RegistrationData->Argument;
    OleControlData.LogContext = NULL;
    OleControlData.Register = RegistrationData->Register;
    OleControlData.RegType = RegistrationData->RegType;

    wcscpy(Path,RegistrationData->FullPath);
    p = wcsrchr(Path,'\\');
    if (p) {
       *p = L'\0';
    }

    SetCurrentDirectory( Path );

    d = (DWORD)OleInitialize(NULL);
    if (d != NO_ERROR) {
        *FailureCode = SPREG_UNKNOWN;
        DebugPrintEx(DPFLTR_ERROR_LEVEL,L"WOWREG32: OleInitialize failed, ec = 0x%08x\n", d);
        goto clean0;
    }



    DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: back from OleInitialize\n");

        try {
            //
            // protect everything in TRY-EXCEPT, we're calling unknown code (DLL's)
            //
            d = pSetupRegisterLoadDll( &OleControlData, &ControlDll );

            if (d == NO_ERROR) {

                //
                // We successfully loaded it.  Now call the appropriate routines.
                //
                //
                // On register, do DLLREGISTER, then DLLINSTALL
                // On unregister, do DLLINSTALL, then DLLREGISTER
                //
                if (OleControlData.Register) {

                    if (OleControlData.RegType & FLG_REGSVR_DLLREGISTER && (d == NO_ERROR) ) {

                        d = pSetupRegisterDllRegister(
                                            &OleControlData,
                                            ControlDll,
                                            FailureCode );

                    }

                    if (OleControlData.RegType & FLG_REGSVR_DLLINSTALL && (d == NO_ERROR) ) {

                        d = pSetupRegisterDllInstall(
                                            &OleControlData,
                                            ControlDll,
                                            FailureCode );
                    }

                } else {

                    if (OleControlData.RegType & FLG_REGSVR_DLLINSTALL && (d == NO_ERROR) ) {

                        d = pSetupRegisterDllInstall(
                                            &OleControlData,
                                            ControlDll,
                                            FailureCode );
                    }

                    if (OleControlData.RegType & FLG_REGSVR_DLLREGISTER && (d == NO_ERROR) ) {

                        d = pSetupRegisterDllRegister(
                                            &OleControlData,
                                            ControlDll,
                                            FailureCode );

                    }


                }

            } else {
                ControlDll = NULL;
                *FailureCode = SPREG_LOADLIBRARY;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // If our exception was an AV, then use Win32 invalid param error, otherwise, assume it was
            // an inpage error dealing with a mapped-in file.
            //
            d = ERROR_INVALID_DATA;
            *FailureCode = SPREG_UNKNOWN;
        }

        if (ControlDll) {
            FreeLibrary(ControlDll);
        }

    OleUninitialize();

    DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: back from OleUninitialize, exit RegisterUnregisterDll\n");

clean0:

    if (d == NO_ERROR) {
        *FailureCode = SPREG_SUCCESS;
    }

    SetLastError(d);

    return (d == NO_ERROR);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\test\cmtest.c ===
/**------------------------------------------------------------------
   cmtest.c
------------------------------------------------------------------**/


//
// Includes
//
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include "cmtest.h"
#include "pnptest.h"
#include <objbase.h>
#include <initguid.h>
#include <winioctl.h>
#include <dbt.h>
#include <pnpmgr.h>

//
// external prototypes
//
CONFIGRET
CMP_Init_Detection(
    IN ULONG    ulPrivateID
    );

CONFIGRET
CMP_Report_LogOn(
    IN ULONG    ulPrivateID,
    IN ULONG    ProccesID
    );

VOID
ConnectTest(
    HWND hWnd
    );

VOID
CallPnPIsaDetect(
    HWND   hDlg,
    LPTSTR pszDevice
    );

VOID
DumpDeviceChangeData(
    HWND   hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

//
// Private Prototypes
//


//
// Globals
//
HINSTANCE hInst;
TCHAR     szAppName[] = TEXT("CMTest");
TCHAR     szDebug[MAX_PATH];
TCHAR     szMachineName[MAX_PATH];
HMACHINE  hMachine = NULL;

DEFINE_GUID(FunctionClassGuid1, 0xAAAAAAA1L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0x01);
typedef BOOL (WINAPI *FP_DEVINSTALL)(HWND, LPCWSTR, BOOL, PDWORD);

//
// FROM NTOS\DD\WDM\DDK\INC\HIDCLASS.H
//
DEFINE_GUID( GUID_CLASS_INPUT, 0x4D1E55B2L, 0xF16F, 0x11CF, 0x88, 0xCB, 0x00, \
             0x11, 0x11, 0x00, 0x00, 0x30);

#define GUID_CLASS_INPUT_STR    TEXT("4D1E55B2-F16F-11CF-88CB-001111000030")


/**----------------------------------------------------------------------**/
int APIENTRY
WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR lpCmdLine,
   int nCmdShow
   )
{
   MSG msg;

   if (!InitApplication(hInstance)) {
         return FALSE;
   }

   if (!InitInstance(hInstance, nCmdShow)) {
      return FALSE;
   }

   while (GetMessage(&msg, NULL, 0, 0)) {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
   }

   return msg.wParam;

} // WinMain


/**----------------------------------------------------------------------**/
BOOL
InitApplication(
   HINSTANCE hInstance
   )
{
   WNDCLASS  wc;

   wc.style         = CS_HREDRAW | CS_VREDRAW;
   wc.lpfnWndProc   = MainWndProc;
   wc.cbClsExtra    = 0;
   wc.cbWndExtra    = 0;
   wc.hInstance     = hInstance;
   wc.hIcon         = LoadIcon (hInstance, szAppName);
   wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
   wc.lpszMenuName  = szAppName;
   wc.lpszClassName = szAppName;

   return RegisterClass(&wc);

} // InitApplication


/**----------------------------------------------------------------------**/
BOOL
InitInstance(
   HINSTANCE hInstance,
   int nCmdShow
   )
{
   HWND  hWnd;
   WORD  CMVersion;
   ULONG CMState = 0;
   TCHAR szTitle[MAX_PATH];

   hInst = hInstance;

   CMVersion = CM_Get_Version();

   if (CM_Get_Global_State(&CMState, 0) != CR_SUCCESS) {
      MessageBeep(0);
   }

   wsprintf(szTitle, TEXT("CM API Test Harness - CM State = %x, CM Version %d.%d"),
            CMState, HIBYTE(CMVersion), LOBYTE(CMVersion));

   hWnd = CreateWindow(
      szAppName,
      szTitle,
      WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
      NULL,
      NULL,
      hInstance,
      NULL);

   if (!hWnd) {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;

} // InitInstance


/**----------------------------------------------------------------------**/
LRESULT CALLBACK
MainWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HANDLE hTestFile = NULL;
    DWORD size = 0;
    ULONG status, ulType, i;
    HDEVNOTIFY hDevNotify;
    HDEVNOTIFY hNotify[64];
    HDEVNOTIFY hNotifyDevNode = NULL;
    HANDLE hFile[64];
    DEV_BROADCAST_DEVICEINTERFACE FilterData;
    DEV_BROADCAST_HANDLE HandleData;
    BOOL bStatus = TRUE;
    FP_DEVINSTALL fpDevInstall = NULL;
    HMODULE       hModule = NULL;
    BOOL          bReboot = FALSE;
    GUID InterfaceGuid;
    LPTSTR pBuffer, p;
    TCHAR szDeviceId[MAX_PATH];
    DEVNODE dnDevNode;
    LPBYTE buffer;
    static ULONG count = 0;

    switch (message) {
        case WM_CREATE:
            DialogBox(hInst, MAKEINTRESOURCE(CONNECT_DIALOG), hWnd,
                      ConnectDlgProc);
            break;


        case WM_DEVICECHANGE:
            MessageBeep(0);
            DumpDeviceChangeData(hWnd, wParam, lParam);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {

                case IDM_CONNECT_TEST:
                    ConnectTest(hWnd);
                    break;

                case IDM_DEVICE_LIST:
                    DialogBox(hInst, MAKEINTRESOURCE(DEVLIST_DIALOG), hWnd,
                              DeviceListDlgProc);
                    break;

                case IDM_SERVICE_LIST:
                    DialogBox(hInst, MAKEINTRESOURCE(SERVICE_DIALOG), hWnd,
                              ServiceListDlgProc);
                    break;

                case IDM_RELATIONS_LIST:
                    DialogBox(hInst, MAKEINTRESOURCE(RELATIONS_DIALOG), hWnd,
                              RelationsListDlgProc);
                    break;
            
                case IDM_DEVICE_OPS:
                    DialogBox(hInst, MAKEINTRESOURCE(DEVICE_DIALOG), hWnd,
                              DeviceDlgProc);
                    break;

                case IDM_DEVNODE_KEY:
                    DialogBox(hInst, MAKEINTRESOURCE(DEVNODEKEY_DIALOG), hWnd,
                              DevKeyDlgProc);
                    break;

                case IDM_CLASS_LIST:
                    DialogBox(hInst, MAKEINTRESOURCE(CLASS_DIALOG), hWnd,
                              ClassDlgProc);
                    break;

                case IDM_REGRESSION:
                    DialogBox(hInst, MAKEINTRESOURCE(REGRESSION_DIALOG), hWnd,
                              RegressionDlgProc);
                    break;

                case IDM_EXIT:
                    DestroyWindow(hWnd);
                    break;

                case IDM_INIT_DETECTION:
                    CMP_Init_Detection(0x07020420);
                    break;

                case IDM_REPORTLOGON:
                    CMP_Report_LogOn(0x07020420, GetCurrentProcessId());
                    break;

                case IDM_PNPISA_DETECT:
                    CallPnPIsaDetect(hWnd, TEXT("Root\\Device001\\0000"));
                    break;

                case IDM_DEVINSTALL:
                    hModule = LoadLibrary(TEXT("newdev.cpl"));
                    if (hModule == NULL) {
                        OutputDebugString(TEXT("LoadLibrary of newdev.cpl failed\n"));
                        break;
                    }
         
                    if (!(fpDevInstall = (FP_DEVINSTALL)GetProcAddress(hModule, "InstallDevInst"))) {
                        OutputDebugString(TEXT("GetProcAddress failed\n"));
                        break;;
                    }
         
                    if (!(fpDevInstall)(NULL, L"PnPTest\\Pdo0\\Root&LEGACY_PNPTEST&0000&1111", FALSE, &bReboot)) {
                        OutputDebugString(TEXT("InstallDevInst failed\n"));
                    }
                    FreeLibrary(hModule);
                    break;


                //-----------------------------------------------------------
                // Notification
                //-----------------------------------------------------------

                case IDM_REGISTER_NOTIFY:
                
                    //
                    // Register for notification on pnptest interface devices
                    //
                    #if 0
                    wsprintf(szDebug, TEXT("CMTEST: Registering window %d for pnptest interface notification\n"), hWnd);
                    OutputDebugString(szDebug);

                    FilterData.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
                    FilterData.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
                    FilterData.dbcc_reserved = 0;
                    memcpy(&FilterData.dbcc_classguid, &FunctionClassGuid1, sizeof(GUID));
                    FilterData.dbcc_name[0] = 0x0;

                    hDevNotify = RegisterDeviceNotification(hWnd,
                                                            &FilterData,
                                                            DEVICE_NOTIFY_WINDOW_HANDLE);
                    #endif

                    //
                    // Register for notification on HID target devices
                    //
                
                    wsprintf(szDebug, TEXT("CMTEST: Registering window %d for hid target notification\n"), hWnd);
                    OutputDebugString(szDebug);

                    count = 0;
                    pBuffer = malloc(2048 * sizeof(TCHAR));
                    CM_Get_Device_Interface_List((LPGUID)&GUID_CLASS_INPUT, NULL, pBuffer, 2048,
                                                 CM_GET_DEVICE_INTERFACE_LIST_PRESENT);
                                
                    for (p = pBuffer; *p; p += lstrlen(p) + 1) {
                    
                        hFile[count] = CreateFile(p, GENERIC_READ | GENERIC_WRITE,
                                                  FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    
                        if (hFile[count] != INVALID_HANDLE_VALUE) {
                        
                            wsprintf(szDebug, TEXT("    %s\n"), p);
                            OutputDebugString(szDebug);
    
                            HandleData.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
                            HandleData.dbch_devicetype = DBT_DEVTYP_HANDLE;
                            HandleData.dbch_reserved = 0;
                            HandleData.dbch_handle = hFile[count];
                        
                            hNotify[count] = RegisterDeviceNotification(hWnd,
                                                                        &HandleData,
                                                                        DEVICE_NOTIFY_WINDOW_HANDLE);
                            count++;
                        } else {
                            status = GetLastError();
                        }
                    }
                    free(pBuffer);

                    //
                    // Register for notification on storage target devices
                    //
                
                    wsprintf(szDebug, TEXT("CMTEST: Registering window %d for storage target notification\n"), hWnd);
                    OutputDebugString(szDebug);

                    pBuffer = malloc(2048 * sizeof(TCHAR));
                    CM_Get_Device_Interface_List((LPGUID)&VolumeClassGuid, NULL, pBuffer, 2048,
                                                 CM_GET_DEVICE_INTERFACE_LIST_PRESENT);
                                
                    for (p = pBuffer; *p; p += lstrlen(p) + 1) {
                    
                        hFile[count] = CreateFile(p, GENERIC_READ | GENERIC_WRITE,
                                                  FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    
                        if (hFile[count] != INVALID_HANDLE_VALUE) {
                        
                            wsprintf(szDebug, TEXT("    %s\n"), p);
                            OutputDebugString(szDebug);
    
                            HandleData.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
                            HandleData.dbch_devicetype = DBT_DEVTYP_HANDLE;
                            HandleData.dbch_reserved = 0;
                            HandleData.dbch_handle = hFile[count];
                        
                            hNotify[count] = RegisterDeviceNotification(hWnd,
                                                                        &HandleData,
                                                                        DEVICE_NOTIFY_WINDOW_HANDLE);
                            count++;
                        } else {
                            status = GetLastError();
                        }
                    }
                    break;

                case IDM_UNREGISTER_NOTIFY:
                    #if 0
                    bStatus = UnregisterDeviceNotification(hDevNotify);
                    #endif

                    for (i = 0; i < count; i++) {
                        if (hNotify[i]) {
                            bStatus = UnregisterDeviceNotification(hNotify[i]);
                        }
                        if (hFile[i]) {
                            CloseHandle(hFile[i]);
                        }
                    }
                    break;

                case IDM_SET_ASSOCIATIONS:
                    hTestFile = CreateFile(L"\\\\.\\PnPTest", GENERIC_READ | GENERIC_WRITE,
                                           FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    if (hTestFile == INVALID_HANDLE_VALUE) {
                        status = GetLastError();
                    }
                    DeviceIoControl(hTestFile, (DWORD)IOCTL_SET, NULL, 0, NULL, 0, &size, NULL);
                    CloseHandle(hTestFile);
                    break;

                case IDM_CLEAR_ASSOCIATIONS:
                    hTestFile = CreateFile(L"\\\\.\\PnPTest", GENERIC_READ | GENERIC_WRITE,
                                           FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    DeviceIoControl(hTestFile, (DWORD)IOCTL_CLEAR, NULL, 0, NULL, 0, &size, NULL);
                    CloseHandle(hTestFile);
                    break;

                case IDM_GET_PROPERTIES:
                    lstrcpy(szDeviceId, TEXT("Root\\LEGACY_PNPTEST\\0000"));
                    UuidFromString(TEXT("aaaaaaa2-e3f0-101b-8488-00aa003e5601"), &InterfaceGuid);
                    pBuffer = malloc(1024);
                    CM_Get_Device_Interface_List(&InterfaceGuid, szDeviceId, pBuffer, 512,
                                                 CM_GET_DEVICE_INTERFACE_LIST_PRESENT);

                    // use first returned interface device of that class
                    hTestFile = CreateFile(pBuffer, GENERIC_READ | GENERIC_WRITE,
                                           FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    if (hTestFile == INVALID_HANDLE_VALUE) {
                        status = GetLastError();
                    }
                    DeviceIoControl(hTestFile, (DWORD)IOCTL_GET_PROP, NULL, 0, NULL, 0, &size, NULL);
                    CloseHandle(hTestFile);
                
                    CM_Locate_DevNode(&dnDevNode, TEXT("Root\\LEGACY_PNPTEST\\0000"), CM_LOCATE_DEVNODE_NORMAL);
                
                    buffer = malloc(1024);
                    size = 1024;
                    status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_BUSTYPEGUID,
                                                              &ulType, buffer, &size, 0);            
                    size = 1024;
                    status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_LEGACYBUSTYPE,
                                                              &ulType, buffer, &size, 0);                
                    size = 1024;
                    status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_BUSNUMBER,
                                                              &ulType, buffer, &size, 0);
                    free(pBuffer);
                    free(buffer);
                    break;
            
                default:
                    return DefWindowProc(hWnd, message, wParam, lParam);
            }
            break;

        case WM_DESTROY:
            if (hMachine != NULL) {
                CM_Disconnect_Machine(hMachine);
            }
            PostQuitMessage(0);
            break;

        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;

} // MainWndProc



/**----------------------------------------------------------------------**/
INT_PTR CALLBACK
ConnectDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status;
   WORD        CMLocalVersion, CMRemoteVersion;
   ULONG       CMState = 0;
   TCHAR       szTitle[MAX_PATH];


   switch (message) {
      case WM_INITDIALOG:
         CheckRadioButton(hDlg, ID_RAD_LOCAL, ID_RAD_REMOTE, ID_RAD_LOCAL);
         return TRUE;

   case WM_COMMAND:
      switch(LOWORD(wParam)) {

         case ID_RAD_LOCAL:
         case ID_RAD_REMOTE:
            CheckRadioButton(hDlg, ID_RAD_LOCAL, ID_RAD_REMOTE, LOWORD(wParam));
            break;

         case IDOK:
            if (IsDlgButtonChecked(hDlg, ID_RAD_LOCAL)) {
               hMachine = NULL;
            }
            else {
               // a NULL machine name just returns local machine handle
               GetDlgItemText(hDlg, ID_ED_MACHINE, szMachineName, MAX_PATH);
               Status = CM_Connect_Machine(szMachineName, &hMachine);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Connect_Machine failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  hMachine = NULL;
                  EndDialog(hDlg, FALSE);
                  return TRUE;
               }

               CMLocalVersion = CM_Get_Version();
               CMRemoteVersion = CM_Get_Version_Ex(hMachine);

               Status = CM_Get_Global_State(&CMState, 0);
               if (Status != CR_SUCCESS) {
                  MessageBeep(0);
               }

               wsprintf(szTitle,
                     TEXT("CM API Test Harness - CM State = %x, CM Version Local %d.%d, Remote %d.%d"),
                     CMState,
                     HIBYTE(CMLocalVersion), LOBYTE(CMLocalVersion),
                     HIBYTE(CMRemoteVersion), LOBYTE(CMRemoteVersion));

               SendMessage(GetParent(hDlg), WM_SETTEXT, 0, (LPARAM)(LPSTR)szTitle);

            }
            EndDialog(hDlg, TRUE);
            return TRUE;

         default:
            break;
      }

   }
   return FALSE;

} // ConnectDlgProc


VOID
ConnectTest(
    HWND hWnd
    )
{
    CONFIGRET Status = CR_SUCCESS;
    TCHAR     szDeviceID[MAX_DEVICE_ID_LEN], szComputerName[MAX_PATH];
    ULONG     ulSize = 0;
    DEVINST   dnDevNode;
    HMACHINE  hMachine;


    //---------------------------------------------------------------
    // 1. Text implicit local machine call
    //---------------------------------------------------------------

    szDeviceID[0] = 0x0;

    Status = CM_Locate_DevNode(&dnDevNode, TEXT("Root\\Device001\\0000"),
          CM_LOCATE_DEVNODE_NORMAL);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    Status = CM_Get_Device_ID(dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN, 0);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    if (lstrcmpi(szDeviceID, TEXT("Root\\Device001\\0000")) != 0) {
        goto Clean0;
    }


    //---------------------------------------------------------------
    // 2. Test implicit local machine call using _Ex routines
    //---------------------------------------------------------------

    szDeviceID[0] = 0x0;

    Status = CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device001\\0000"),
          CM_LOCATE_DEVNODE_NORMAL, NULL);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    Status = CM_Get_Device_ID_Ex(dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN, 0, NULL);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    if (lstrcmpi(szDeviceID, TEXT("Root\\Device001\\0000")) != 0) {
        goto Clean0;
    }


    //---------------------------------------------------------------
    // 3. Test connecting to NULL (local) machine
    //---------------------------------------------------------------

    Status = CM_Connect_Machine(NULL, &hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    szDeviceID[0] = 0x0;

    Status = CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device001\\0000"),
                                  CM_LOCATE_DEVNODE_NORMAL, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    Status = CM_Get_Device_ID_Ex(dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN,
                                 0, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    if (lstrcmpi(szDeviceID, TEXT("Root\\Device001\\0000")) != 0) {
        goto Clean0;
    }

    Status = CM_Disconnect_Machine(hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    //---------------------------------------------------------------
    // 4. Test explicit local machine call
    //---------------------------------------------------------------

    ulSize = MAX_PATH;
    GetComputerName(szComputerName, &ulSize);

    if (szComputerName[0] != TEXT('\\')) {

        TCHAR szTemp[MAX_PATH];

        lstrcpy(szTemp, szComputerName);
        lstrcpy(szComputerName, TEXT("\\\\"));
        lstrcat(szComputerName, szTemp);
    }

    Status = CM_Connect_Machine(szComputerName, &hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    szDeviceID[0] = 0x0;

    Status = CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device001\\0000"),
                                  CM_LOCATE_DEVNODE_NORMAL, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    Status = CM_Get_Device_ID_Ex(dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN,
                                 0, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    if (lstrcmpi(szDeviceID, TEXT("Root\\Device001\\0000")) != 0) {
        goto Clean0;
    }

    Status = CM_Disconnect_Machine(hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }


    //---------------------------------------------------------------
    // 5. Test remote machine call
    //---------------------------------------------------------------

    Status = CM_Connect_Machine(TEXT("\\\\PAULAT_PPC1X"), &hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    szDeviceID[0] = 0x0;

    Status = CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device001\\0000"),
                                  CM_LOCATE_DEVNODE_NORMAL, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    Status = CM_Get_Device_ID_Ex(dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN,
                                 0, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    if (lstrcmpi(szDeviceID, TEXT("Root\\Device001\\0000")) != 0) {
        goto Clean0;
    }

    Status = CM_Disconnect_Machine(hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }



    Clean0:

    if (Status == CR_SUCCESS) {
        MessageBox(hWnd, TEXT("Connect Test Passed"), TEXT("Connect Test"), MB_OK);
    } else {
        MessageBox(hWnd, TEXT("Connect Test Failed"), TEXT("Connect Test"), MB_OK);
    }

    return;

} // ConnectTest



BOOL
CALLBACK
AddPropSheetPageProc(
    IN HPROPSHEETPAGE hpage,
    IN LPARAM lParam
   )
{
    *((HPROPSHEETPAGE *)lParam) = hpage;
    return TRUE;
}



VOID
CallPnPIsaDetect(
    HWND hDlg,
    LPTSTR pszDevice
    )
{
    HMODULE         hLib = NULL;
    SP_DEVINFO_DATA DeviceInfoData;
    HDEVINFO        hDevInfo;
    FARPROC         PropSheetExtProc;
    PROPSHEETHEADER PropHeader;
    HPROPSHEETPAGE  hPages[2];

    SP_PROPSHEETPAGE_REQUEST PropParams;

    #if 0
    hLib = LoadLibrary(TEXT("setupapi.dll"));
    fproc = GetProcAddress(hLib, TEXT("DbgSelectDeviceResources"));
    Status = (fproc)(pszDevice);
    FreeLibrary(hLib);
    #endif

    //
    // Create a device info element and device info data set.
    //
    hDevInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        goto Clean0;
    }

    DeviceInfoData.cbSize  = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiOpenDeviceInfo(hDevInfo,
                               pszDevice,
                               NULL,
                               0,
                               &DeviceInfoData)) {
        goto Clean0;
    }

    //
    // Now get the resource selection page from setupapi.dll
    //
    if(!(hLib = GetModuleHandle(TEXT("setupapi.dll"))) ||
       !(PropSheetExtProc = GetProcAddress(hLib, "ExtensionPropSheetPageProc"))) {

        goto Clean0;
    }

    PropParams.cbSize = sizeof(SP_PROPSHEETPAGE_REQUEST);
    PropParams.PageRequested  = SPPSR_SELECT_DEVICE_RESOURCES;
    PropParams.DeviceInfoSet  = hDevInfo;
    PropParams.DeviceInfoData = &DeviceInfoData;

    if(!PropSheetExtProc(&PropParams, AddPropSheetPageProc, &hPages[0])) {
        goto Clean0;
    }

    //
    // create the property sheet
    //
    PropHeader.dwSize      = sizeof(PROPSHEETHEADER);
    PropHeader.dwFlags     = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    PropHeader.hwndParent  = NULL;
    PropHeader.hInstance   = hInst;
    PropHeader.pszIcon     = NULL;
    PropHeader.pszCaption  = L"Device";
    PropHeader.nPages      = 1;
    PropHeader.phpage      = hPages;
    PropHeader.nStartPage  = 0;
    PropHeader.pfnCallback = NULL;

    PropertySheet(&PropHeader);

    SetupDiDestroyDeviceInfoList(hDevInfo);

    Clean0:
        ;

    return;

} // CallPnPIsaDetect


VOID
DumpDeviceChangeData(
    HWND   hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    TCHAR szDbg[MAX_PATH];

    OutputDebugString(TEXT("CMTEST: WM_DEVICECHANGE message received\n"));

    switch (wParam) {
        case DBT_DEVICEARRIVAL:
            OutputDebugString(TEXT("   DBT_DEVICEARRIVAL event\n"));
            break;

        case DBT_DEVICEREMOVECOMPLETE:
            OutputDebugString(TEXT("   DBT_DEVICEREMOVECOMPLETE event\n"));
            break;

        case DBT_DEVICEQUERYREMOVE:
            OutputDebugString(TEXT("   DBT_DEVICEQUERYREMOVE event\n"));
            break;

        case DBT_DEVICEQUERYREMOVEFAILED:
            OutputDebugString(TEXT("   DBT_DEVICEQUERYREMOVEFAILED event\n"));
            break;

        case DBT_DEVICEREMOVEPENDING:
            OutputDebugString(TEXT("   DBT_DEVICEREMOVEPENDING event\n"));
            break;

        case DBT_DEVICETYPESPECIFIC:
            OutputDebugString(TEXT("   DBT_DEVICETYPESPECIFIC event\n"));
            break;

        case DBT_CUSTOMEVENT:
            OutputDebugString(TEXT("   DBT_CUSTOMEVENT event\n"));
            break;

        default:
            break;

    }

    switch (((PDEV_BROADCAST_HDR)lParam)->dbch_devicetype) {
        case DBT_DEVTYP_DEVICEINTERFACE:  {
            PDEV_BROADCAST_DEVICEINTERFACE p = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;
            LPTSTR pString;
            OutputDebugString(TEXT("   DBT_DEVTYP_DEVICEINTERFACE\n"));
            wsprintf(szDbg,   TEXT("   %s\n"), p->dbcc_name);
            OutputDebugString(szDbg);
            UuidToString(&p->dbcc_classguid, &pString);
            wsprintf(szDbg,   TEXT("   %s\n"), pString);
            OutputDebugString(szDbg);
            break;
        }
        case DBT_DEVTYP_HANDLE:
            OutputDebugString(TEXT("         DBT_DEVTYP_HANDLE\n"));
            break;

        default:
            break;
    }

    wsprintf(szDbg,   TEXT("        wParam = %d\n"));
    OutputDebugString(szDbg);

} // DumpDeviceChangeData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\test\pnptest\pnptest.h ===
#define PNPTEST_IOCTL_INDEX  0x950

#define IOCTL_SET       CTL_CODE(FILE_DEVICE_CONTROLLER,    \
                                 PNPTEST_IOCTL_INDEX,       \
                                 METHOD_BUFFERED,           \
                                 FILE_ANY_ACCESS)

#define IOCTL_CLEAR     CTL_CODE(FILE_DEVICE_CONTROLLER,    \
                                 PNPTEST_IOCTL_INDEX+1,     \
                                 METHOD_BUFFERED,           \
                                 FILE_ANY_ACCESS)

#define IOCTL_GET_PROP  CTL_CODE(FILE_DEVICE_CONTROLLER,    \
                                 PNPTEST_IOCTL_INDEX+2,     \
                                 METHOD_BUFFERED,           \
                                 FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\test\tlogconf.c ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include <malloc.h>
#include "cmtest.h"



VOID 
SpecialCase_LogConf(
    DEVNODE dnDevNode
    );


//-----------------------------------------------------------------------------
VOID
RegressionTest_LogConf(
      HWND  hDlg
      )
{
   CONFIGRET Status;
   TCHAR     szMsg[MAX_PATH], szMsg1[MAX_PATH];
   DEVNODE   dnDevNode;
   LOG_CONF  TempLC, BootLC1, BootLC2, BootLC3;
   LOG_CONF  BasicLC1, BasicLC2, BasicLC3;
   RES_DES   ResDes, ResDes1, ResDes2, ResDes3;
   PCS_DES   pResourceData;
   ULONG     ulSize = 0;
   BYTE      i;
   PMEM_RESOURCE pMemRes = NULL;
   PIO_RESOURCE  pIoRes = NULL;
   PCS_RESOURCE  pCs1Res = NULL, pCs2Res = NULL;
   PIRQ_RESOURCE pIrqRes = NULL;
   PDMA_RESOURCE pDmaRes = NULL;
   BYTE       LegacyData[512];
   RESOURCEID ResType;
   LPBYTE    pBuffer = NULL, pData = NULL;
   PRIORITY Priority = 0;

   //
   // free, free handle, modify, get size, get data
   //

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____LOGCONF-RESDES REGRESSION TEST_____"));

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("Testing Device ID: Root\\Device001\\0000"));

   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Root\\Device001\\0000"), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Locate_DevNode Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }


    SpecialCase_LogConf(dnDevNode);
    return;


   //------------------------------------------------------
   // Add/Get Boot Configs
   //------------------------------------------------------


   lstrcpy(szMsg, TEXT("Test empty boot 1 config: "));
   Status = CM_Add_Empty_Log_Conf(&BootLC1, dnDevNode, LCPRI_BOOTCONFIG,
            BOOT_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test add empty boot 2 config: "));
   Status = CM_Add_Empty_Log_Conf(&BootLC2, dnDevNode, LCPRI_BOOTCONFIG,
            BOOT_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   Status = CM_Free_Log_Conf_Handle(BootLC1);
   Status = CM_Free_Log_Conf_Handle(BootLC2);


   lstrcpy(szMsg, TEXT("Test get first boot config: "));
   Status = CM_Get_First_Log_Conf(&BootLC1, dnDevNode, BOOT_LOG_CONF);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Get_First_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get next boot config: "));
   Status = CM_Get_Next_Log_Conf(&BootLC2, BootLC1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get next (nonexistent) boot config: "));
   Status = CM_Get_Next_Log_Conf(&TempLC, BootLC2, 0);
   if (Status != CR_NO_MORE_LOG_CONF) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get priority of boot config: "));
   Status = CM_Get_Log_Conf_Priority(BootLC1, &Priority, 0);
   if (Status != CR_INVALID_LOG_CONF) {
       wsprintf(szMsg1, TEXT("Passed, should have failed! (%d)\n"), Status);
   } else {
       wsprintf(szMsg1, TEXT("Failed as expected (%d)\n"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //------------------------------------------------------
   // Add/Get Basic Configs
   //------------------------------------------------------

   lstrcpy(szMsg, TEXT("Test empty basic 1 config: "));
   Status = CM_Add_Empty_Log_Conf(&BasicLC1, dnDevNode, LCPRI_NORMAL,
            BASIC_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test add empty basic 2 config: "));
   Status = CM_Add_Empty_Log_Conf(&BasicLC2, dnDevNode, LCPRI_NORMAL,
            BASIC_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   Status = CM_Free_Log_Conf_Handle(BasicLC1);
   Status = CM_Free_Log_Conf_Handle(BasicLC2);


   lstrcpy(szMsg, TEXT("Test get first basic config: "));
   Status = CM_Get_First_Log_Conf(&BasicLC1, dnDevNode, BASIC_LOG_CONF);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Get_First_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get next basic config: "));
   Status = CM_Get_Next_Log_Conf(&BasicLC2, BasicLC1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get next (nonexistent) basic config: "));
   Status = CM_Get_Next_Log_Conf(&TempLC, BasicLC3, 0);
   if (Status != CR_NO_MORE_LOG_CONF) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Test get priority of basic config: "));
   Status = CM_Get_Log_Conf_Priority(BasicLC2, &Priority, 0);
   if (Status == CR_SUCCESS) {
       if (Priority == LCPRI_NORMAL) {
          wsprintf(szMsg1, TEXT("Passed\n"));
       } else {
           wsprintf(szMsg1, TEXT("Failed, priority should be %x (%x)\n"), LCPRI_NORMAL, Priority);
       }
   } else {
       wsprintf(szMsg1, TEXT("Failed (%d)\n"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //----------------------------------------------------------
   // Test adding res des 's
   //----------------------------------------------------------

   lstrcpy(szMsg, TEXT("Test add MEMORY res des to LC1: "));

   pMemRes = malloc(sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE));

   pMemRes->MEM_Header.MD_Count      = 2;
   pMemRes->MEM_Header.MD_Type       = MType_Range;
   pMemRes->MEM_Header.MD_Alloc_Base = (DWORDLONG)0xD8000;
   pMemRes->MEM_Header.MD_Alloc_End  = (DWORDLONG)0xD9000;
   pMemRes->MEM_Header.MD_Flags      = fMD_ROM | fMD_32 | fMD_ReadAllowed;
   pMemRes->MEM_Header.MD_Reserved   = 0;

   pMemRes->MEM_Data[0].MR_Align     = 8; //?
   pMemRes->MEM_Data[0].MR_nBytes    = 4096;
   pMemRes->MEM_Data[0].MR_Min       = (DWORDLONG)0xD8000;
   pMemRes->MEM_Data[0].MR_Max       = (DWORDLONG)0xDC000;
   pMemRes->MEM_Data[0].MR_Flags     = fMD_ROM | fMD_32 | fMD_ReadAllowed;
   pMemRes->MEM_Data[0].MR_Reserved  = 0;

   pMemRes->MEM_Data[1].MR_Align     = 8; //?
   pMemRes->MEM_Data[1].MR_nBytes    = 4096;
   pMemRes->MEM_Data[1].MR_Min       = (DWORDLONG)0xE0000;
   pMemRes->MEM_Data[1].MR_Max       = (DWORDLONG)0xE4000;
   pMemRes->MEM_Data[1].MR_Flags     = fMD_ROM | fMD_32 | fMD_ReadAllowed;
   pMemRes->MEM_Data[1].MR_Reserved  = 0;

   Status = CM_Add_Res_Des(&ResDes, BootLC1, ResType_Mem, pMemRes,
                           sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Add_Res_Des(&ResDes, BasicLC1, ResType_Mem, pMemRes,
                           sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);




   lstrcpy(szMsg, TEXT("Test add CS res des to LC2: "));

   pCs2Res = malloc(sizeof(CS_RESOURCE) + 47);       //48-1

   pCs2Res->CS_Header.CSD_SignatureLength  = 16;
   pCs2Res->CS_Header.CSD_LegacyDataOffset = 16;
   pCs2Res->CS_Header.CSD_LegacyDataSize   = 32;
   pCs2Res->CS_Header.CSD_Flags            = 0;

   CM_Enumerate_Classes(0, &(pCs2Res->CS_Header.CSD_ClassGuid), 0);

   for (i = 0; i < 16; i++) {
       pCs2Res->CS_Header.CSD_Signature[i] = i;
   }

   for (i = 0; i < 32; i++) {
       LegacyData[i] = 50;
   }

   memcpy(pCs2Res->CS_Header.CSD_Signature + pCs2Res->CS_Header.CSD_SignatureLength,
          LegacyData, 32);

   Status = CM_Add_Res_Des(&ResDes, BootLC2, ResType_ClassSpecific, pCs2Res,
                           sizeof(CS_RESOURCE) + 47, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test add PORT res des to LC2: "));

   pIoRes = malloc(sizeof(IO_RESOURCE) + sizeof(IO_RANGE));

   pIoRes->IO_Header.IOD_Count        = 2;
   pIoRes->IO_Header.IOD_Type         = IOType_Range;
   pIoRes->IO_Header.IOD_Alloc_Base   = (DWORDLONG)0x300;
   pIoRes->IO_Header.IOD_Alloc_End    = (DWORDLONG)0x330;
   pIoRes->IO_Header.IOD_DesFlags     = 0;

   pIoRes->IO_Data[0].IOR_Align      = 8; //?
   pIoRes->IO_Data[0].IOR_nPorts     = 0x30;
   pIoRes->IO_Data[0].IOR_Min        = (DWORDLONG)0x300;
   pIoRes->IO_Data[0].IOR_Max        = (DWORDLONG)0x430;
   pIoRes->IO_Data[0].IOR_RangeFlags = 0;
   pIoRes->IO_Data[0].IOR_Alias      = 0;

   pIoRes->IO_Data[1].IOR_Align      = 8; //?
   pIoRes->IO_Data[1].IOR_nPorts     = 0x30;
   pIoRes->IO_Data[1].IOR_Min        = (DWORDLONG)0x200;
   pIoRes->IO_Data[1].IOR_Max        = (DWORDLONG)0x300;
   pIoRes->IO_Data[1].IOR_RangeFlags = 0;
   pIoRes->IO_Data[1].IOR_Alias      = 0;

   Status = CM_Add_Res_Des(&ResDes, BootLC2, ResType_IO, pIoRes,
                           sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Add_Res_Des(&ResDes, BasicLC2, ResType_IO, pIoRes,
                           sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);




   lstrcpy(szMsg, TEXT("Test add CS res des to LC1: "));

   pCs1Res = malloc(sizeof(CS_RESOURCE) + 15);       //16-1

   pCs1Res->CS_Header.CSD_SignatureLength  = 16;
   pCs1Res->CS_Header.CSD_LegacyDataOffset = 0;
   pCs1Res->CS_Header.CSD_LegacyDataSize   = 0;
   pCs1Res->CS_Header.CSD_Flags            = 0;

   CM_Enumerate_Classes(0, &(pCs1Res->CS_Header.CSD_ClassGuid), 0);

   for (i = 0; i < 16; i++) {
       pCs1Res->CS_Header.CSD_Signature[i] = i;
   }

   Status = CM_Add_Res_Des(&ResDes, BootLC1, ResType_ClassSpecific, pCs1Res,
                           sizeof(CS_RESOURCE) + 15, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test add second CS res des to LC2: "));

   Status = CM_Add_Res_Des(&ResDes, BootLC2, ResType_ClassSpecific, pCs2Res,
                           sizeof(CS_RESOURCE) + 47, 0);
   if (Status != CR_INVALID_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   //----------------------------------------------------------------
   // Add 3rd empty configs - priority last
   //----------------------------------------------------------------

   lstrcpy(szMsg, TEXT("Test add 3rd empty boot config: "));
   Status = CM_Add_Empty_Log_Conf(&BootLC3, dnDevNode, LCPRI_BOOTCONFIG,
            BOOT_LOG_CONF | PRIORITY_EQUAL_LAST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Test add 3rd empty basic config: "));
   Status = CM_Add_Empty_Log_Conf(&BasicLC3, dnDevNode, LCPRI_NORMAL,
            BASIC_LOG_CONF | PRIORITY_EQUAL_LAST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get priority of 3rd boot config: "));
   Status = CM_Get_Log_Conf_Priority(BootLC3, &Priority, 0);
   if (Status == CR_SUCCESS) {
       if (Priority == LCPRI_BOOTCONFIG) {
          wsprintf(szMsg1, TEXT("Passed\n"));
       } else {
           wsprintf(szMsg1, TEXT("Failed, priority should be %x (%x)\n"), LCPRI_BOOTCONFIG, Priority);
       }
   } else {
       wsprintf(szMsg1, TEXT("Failed (%d)\n"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //----------------------------------------------------------------
   // Add DMA resource to LC3
   //----------------------------------------------------------------

   lstrcpy(szMsg, TEXT("Test add DMA res des to LC3: "));

   pDmaRes = malloc(sizeof(DMA_RESOURCE));

   pDmaRes->DMA_Header.DD_Count      = 1;
   pDmaRes->DMA_Header.DD_Type       = DType_Range;
   pDmaRes->DMA_Header.DD_Flags      = fDD_DWORD;
   pDmaRes->DMA_Header.DD_Alloc_Chan = (DWORDLONG)0x3;

   pDmaRes->DMA_Data[0].DR_Min       = 1;
   pDmaRes->DMA_Data[0].DR_Max       = 3;
   pDmaRes->DMA_Data[0].DR_Flags     = fDD_DWORD;


   Status = CM_Add_Res_Des(&ResDes, BootLC3, ResType_DMA, pDmaRes,
                           sizeof(DMA_RESOURCE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   Status = CM_Add_Res_Des(&ResDes, BasicLC3, ResType_DMA, pDmaRes,
                           sizeof(DMA_RESOURCE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //----------------------------------------------------------------
   // Add IRQ resource to LC3
   //----------------------------------------------------------------

   lstrcpy(szMsg, TEXT("Test add IRQ res des to LC3: "));

   pIrqRes = malloc(sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2);

   pIrqRes->IRQ_Header.IRQD_Count      = 3;
   pIrqRes->IRQ_Header.IRQD_Type       = IRQType_Range;
   pIrqRes->IRQ_Header.IRQD_Flags      = fDD_DWORD;
   pIrqRes->IRQ_Header.IRQD_Alloc_Num  = (DWORDLONG)11;
   pIrqRes->IRQ_Header.IRQD_Affinity   = 0;

   pIrqRes->IRQ_Data[0].IRQR_Min       = 1;
   pIrqRes->IRQ_Data[0].IRQR_Max       = 3;
   pIrqRes->IRQ_Data[0].IRQR_Flags     = fIRQD_Exclusive | fIRQD_Level;

   pIrqRes->IRQ_Data[1].IRQR_Min       = 5;
   pIrqRes->IRQ_Data[1].IRQR_Max       = 7;
   pIrqRes->IRQ_Data[1].IRQR_Flags     = fIRQD_Exclusive | fIRQD_Level;

   pIrqRes->IRQ_Data[2].IRQR_Min       = 9;
   pIrqRes->IRQ_Data[2].IRQR_Max       = 11;
   pIrqRes->IRQ_Data[2].IRQR_Flags     = fIRQD_Exclusive | fIRQD_Level;


   Status = CM_Add_Res_Des(&ResDes, BootLC3, ResType_IRQ, pIrqRes,
                           sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Add_Res_Des(&ResDes, BasicLC3, ResType_IRQ, pIrqRes,
                           sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

MessageBox(hDlg, TEXT("Check registry contents"), TEXT("CMTEST"), MB_OK);

   //----------------------------------------------------------------
   // Delete an lc that still has rd's in it (then recreate it)
   //----------------------------------------------------------------


   lstrcpy(szMsg, TEXT("Test free Boot Config LC2: "));
   Status = CM_Free_Log_Conf(BootLC2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   CM_Free_Log_Conf_Handle(BootLC1);

   lstrcpy(szMsg, TEXT("Recreate Boot LC2 (will be first): "));
   Status = CM_Add_Empty_Log_Conf(&BootLC1, dnDevNode, LCPRI_BOOTCONFIG,
            BOOT_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Re-add CS to LC2: "));

   Status = CM_Add_Res_Des(&ResDes, BootLC1, ResType_ClassSpecific, pCs2Res,
                           sizeof(CS_RESOURCE) + 47, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Re-add IO to LC2: "));

   Status = CM_Add_Res_Des(&ResDes, BootLC1, ResType_IO, pIoRes,
                           sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   // free handles and retreive them again in order
   CM_Free_Log_Conf_Handle(BootLC1);
   CM_Free_Log_Conf_Handle(BootLC2);
   CM_Free_Log_Conf_Handle(BootLC3);

   CM_Get_First_Log_Conf(&BootLC1, dnDevNode, BOOT_LOG_CONF);
   CM_Get_Next_Log_Conf(&BootLC2, BootLC1, 0);
   CM_Get_Next_Log_Conf(&BootLC3, BootLC2, 0);



   lstrcpy(szMsg, TEXT("Test free Basic Config LC2: "));
   Status = CM_Free_Log_Conf(BasicLC2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   CM_Free_Log_Conf_Handle(BasicLC1);

   lstrcpy(szMsg, TEXT("Recreate LC2 (will be first): "));
   Status = CM_Add_Empty_Log_Conf(&BasicLC1, dnDevNode, LCPRI_NORMAL,
            BASIC_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Attempt adding a CS: "));

   Status = CM_Add_Res_Des(&ResDes, BasicLC1, ResType_ClassSpecific, pCs2Res,
                           sizeof(CS_RESOURCE) + 47, 0);
   if (Status != CR_INVALID_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Re-add IO to LC2: "));

   Status = CM_Add_Res_Des(&ResDes, BasicLC1, ResType_IO, pIoRes,
                           sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   // free handles and retreive them again in order
   CM_Free_Log_Conf_Handle(BasicLC1);
   CM_Free_Log_Conf_Handle(BasicLC2);
   CM_Free_Log_Conf_Handle(BasicLC3);

   CM_Get_First_Log_Conf(&BasicLC1, dnDevNode, BASIC_LOG_CONF);
   CM_Get_Next_Log_Conf(&BasicLC2, BasicLC1, 0);
   CM_Get_Next_Log_Conf(&BasicLC3, BasicLC2, 0);



MessageBox(hDlg, TEXT("Check registry contents"), TEXT("CMTEST"), MB_OK);

   //----------------------------------------------------------------
   // Get-next test
   //----------------------------------------------------------------


   lstrcpy(szMsg, TEXT("Get first res des from Boot LC1: "));

   Status = CM_Get_Next_Res_Des(&ResDes1, BootLC1, ResType_All, &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Boot LC1 (all): "));

   Status = CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Boot LC1 (all): "));

   Status = CM_Get_Next_Res_Des(&ResDes3, ResDes2, ResType_All, &ResType, 0);
   if (Status != CR_NO_MORE_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Boot LC2 (ClassSpecific): "));

   Status = CM_Get_Next_Res_Des(&ResDes1, BootLC2, ResType_ClassSpecific,
                    &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Boot LC2 (DMA): "));

   Status = CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_DMA, &ResType, 0);
   if (Status != CR_NO_MORE_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);




   lstrcpy(szMsg, TEXT("Get first res des from Basic LC3: "));

   Status = CM_Get_Next_Res_Des(&ResDes1, BasicLC3, ResType_All, &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Basic LC3 (all): "));

   Status = CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   SendDlgItemMessage(
      hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
      (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Basic LC3 (all): "));

   Status = CM_Get_Next_Res_Des(&ResDes3, ResDes2, ResType_All, &ResType, 0);
   if (Status != CR_NO_MORE_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get first res des from Basic LC3 (IRQ): "));

   Status = CM_Get_Next_Res_Des(&ResDes1, BasicLC3, ResType_IRQ,
                    &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Basic LC1 (IRQ): "));

   Status = CM_Get_Next_Res_Des(&ResDes2, BasicLC1, ResType_IRQ, &ResType, 0);
   if (Status != CR_NO_MORE_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   //----------------------------------------------------------------
   // Get data size and data for all
   //----------------------------------------------------------------

    // reset some fields for comparison
    pMemRes->MEM_Header.MD_Count      = 0;
    pMemRes->MEM_Data[0].MR_Align     = 0;
    pMemRes->MEM_Data[0].MR_nBytes    = 0;
    pMemRes->MEM_Data[0].MR_Min       = 0;
    pMemRes->MEM_Data[0].MR_Max       = 0;
    pMemRes->MEM_Data[0].MR_Flags     = 0;
    pMemRes->MEM_Data[0].MR_Reserved  = 0;


    CM_Get_Next_Res_Des(&ResDes1, BootLC2, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (memcmp(pData, pMemRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC2-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC2-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset fields back to original values
    pMemRes->MEM_Header.MD_Count      = 2;
    pMemRes->MEM_Data[0].MR_Align     = 8; //?
    pMemRes->MEM_Data[0].MR_nBytes    = 4096;
    pMemRes->MEM_Data[0].MR_Min       = (DWORDLONG)0xD8000;
    pMemRes->MEM_Data[0].MR_Max       = (DWORDLONG)0xDC000;
    pMemRes->MEM_Data[0].MR_Flags     = fMD_ROM | fMD_32 | fMD_ReadAllowed;
    pMemRes->MEM_Data[0].MR_Reserved  = 0;



    CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (memcmp(pData, pCs1Res, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC2-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC2-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



    // reset some fields for comparison
    pIoRes->IO_Header.IOD_Count       = 0;
    pIoRes->IO_Data[0].IOR_Align      = 0;
    pIoRes->IO_Data[0].IOR_nPorts     = 0;
    pIoRes->IO_Data[0].IOR_Min        = 0;
    pIoRes->IO_Data[0].IOR_Max        = 0;
    pIoRes->IO_Data[0].IOR_RangeFlags = 0;
    pIoRes->IO_Data[0].IOR_Alias      = 0;

    CM_Get_Next_Res_Des(&ResDes1, BootLC1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (memcmp(pData, pIoRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC1-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC1-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset fields back to original values
    pIoRes->IO_Header.IOD_Count       = 2;
    pIoRes->IO_Data[0].IOR_Align      = 8; //?
    pIoRes->IO_Data[0].IOR_nPorts     = 0x30;
    pIoRes->IO_Data[0].IOR_Min        = (DWORDLONG)0x300;
    pIoRes->IO_Data[0].IOR_Max        = (DWORDLONG)0x430;
    pIoRes->IO_Data[0].IOR_RangeFlags = 0;
    pIoRes->IO_Data[0].IOR_Alias      = 0;



    CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (ulSize != (sizeof(CS_RESOURCE) + 47) ||
            memcmp(pData, pCs2Res, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC1-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC1-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



    // reset some fields for comparison
    pDmaRes->DMA_Header.DD_Count  = 0;
    pDmaRes->DMA_Data[0].DR_Min   = 0;
    pDmaRes->DMA_Data[0].DR_Max   = 0;
    pDmaRes->DMA_Data[0].DR_Flags = 0;

    CM_Get_Next_Res_Des(&ResDes1, BootLC3, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (memcmp(pData, pDmaRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC3-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC3-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset fields back to original values
    pDmaRes->DMA_Header.DD_Count  = 1;
    pDmaRes->DMA_Data[0].DR_Min   = 1;
    pDmaRes->DMA_Data[0].DR_Max   = 3;
    pDmaRes->DMA_Data[0].DR_Flags = fDD_DWORD;



    // reset some fields for comparison
    pIrqRes->IRQ_Header.IRQD_Count  = 0;
    pIrqRes->IRQ_Data[0].IRQR_Min   = 0;
    pIrqRes->IRQ_Data[0].IRQR_Max   = 0;
    pIrqRes->IRQ_Data[0].IRQR_Flags = 0;

    CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (memcmp(pData, pIrqRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC3-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC3-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset fields back to original values
    pIrqRes->IRQ_Header.IRQD_Count  = 3;
    pIrqRes->IRQ_Data[0].IRQR_Min   = 1;
    pIrqRes->IRQ_Data[0].IRQR_Max   = 3;
    pIrqRes->IRQ_Data[0].IRQR_Flags = fIRQD_Exclusive | fIRQD_Level;




    // null out header for comparison
    pMemRes->MEM_Header.MD_Alloc_Base = 0;
    pMemRes->MEM_Header.MD_Alloc_End  = 0;
    pMemRes->MEM_Header.MD_Flags      = 0;
    pMemRes->MEM_Header.MD_Reserved   = 0;

    CM_Get_Next_Res_Des(&ResDes1, BasicLC2, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (ulSize != (sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE)) ||
            memcmp(pData, pMemRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BASIC LC2-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BASIC LC2-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pMemRes->MEM_Header.MD_Alloc_Base = (DWORDLONG)0xD8000;
    pMemRes->MEM_Header.MD_Alloc_End  = (DWORDLONG)0xD9000;
    pMemRes->MEM_Header.MD_Flags      = fMD_ROM | fMD_32 | fMD_ReadAllowed;
    pMemRes->MEM_Header.MD_Reserved   = 0;



    // null out header for comparison
    pIoRes->IO_Header.IOD_Alloc_Base   = 0;
    pIoRes->IO_Header.IOD_Alloc_End    = 0;
    pIoRes->IO_Header.IOD_DesFlags     = 0;

    CM_Get_Next_Res_Des(&ResDes1, BasicLC1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (ulSize != (sizeof(IO_RESOURCE) + sizeof(IO_RANGE)) ||
            memcmp(pData, pIoRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BASIC LC1-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BASIC LC1-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pIoRes->IO_Header.IOD_Alloc_Base   = (DWORDLONG)0x300;
    pIoRes->IO_Header.IOD_Alloc_End    = (DWORDLONG)0x330;
    pIoRes->IO_Header.IOD_DesFlags     = 0;



    // null out header for comparison
    pDmaRes->DMA_Header.DD_Flags      = 0;
    pDmaRes->DMA_Header.DD_Alloc_Chan = 0;

    CM_Get_Next_Res_Des(&ResDes1, BasicLC3, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (ulSize != sizeof(DMA_RESOURCE) ||
            memcmp(pData, pDmaRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BASIC LC3-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BASIC LC3-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pDmaRes->DMA_Header.DD_Flags      = fDD_DWORD;
    pDmaRes->DMA_Header.DD_Alloc_Chan = (DWORDLONG)0x3;



    // null out header for comparison
    pIrqRes->IRQ_Header.IRQD_Flags      = 0;
    pIrqRes->IRQ_Header.IRQD_Alloc_Num  = 0;
    pIrqRes->IRQ_Header.IRQD_Affinity   = 0;

    CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (ulSize != sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2 ||
            memcmp(pData, pIrqRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BASIC LC3-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BASIC LC3-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pIrqRes->IRQ_Header.IRQD_Flags     = fDD_DWORD;
    pIrqRes->IRQ_Header.IRQD_Alloc_Num = (DWORDLONG)11;
    pIrqRes->IRQ_Header.IRQD_Affinity  = 0;


    //---------------------------------------------------------------
    // Modify data test
    //---------------------------------------------------------------


    wsprintf(szMsg, TEXT("Modify Boot LC3-RD2 (shrink): "));

    CM_Get_Next_Res_Des(&ResDes2, BootLC3, ResType_IRQ, &ResType, 0);

    Status = CM_Modify_Res_Des(&ResDes2, ResDes2, ResType_IO, pIoRes,
                               sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);

    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);

    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (memcmp(pData, pIoRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC3-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC3-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);




    wsprintf(szMsg, TEXT("Modify Basic LC3-RD2 (shrink): "));

    CM_Get_Next_Res_Des(&ResDes2, BasicLC3, ResType_IRQ, &ResType, 0);

    Status = CM_Modify_Res_Des(&ResDes2, ResDes2, ResType_IO, pIoRes,
                               sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);

    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);

    // null out header for comparison
    pIoRes->IO_Header.IOD_Alloc_Base   = 0;
    pIoRes->IO_Header.IOD_Alloc_End    = 0;
    pIoRes->IO_Header.IOD_DesFlags     = 0;

    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (ulSize != sizeof(IO_RESOURCE) + sizeof(IO_RANGE)) {
        wsprintf(szMsg, TEXT("LC3-RD2 Data size is NOT correct"));
    } else if (memcmp(pData, pIoRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("LC3-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("LC3-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pIoRes->IO_Header.IOD_Alloc_Base   = (DWORDLONG)0x300;
    pIoRes->IO_Header.IOD_Alloc_End    = (DWORDLONG)0x330;
    pIoRes->IO_Header.IOD_DesFlags     = 0;




    wsprintf(szMsg, TEXT("Modify Boot LC1-RD1 (grow): "));

    CM_Get_Next_Res_Des(&ResDes1, BootLC1, ResType_All, &ResType, 0);

    Status = CM_Modify_Res_Des(&ResDes1, ResDes1, ResType_IRQ, pIrqRes,
                               sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2, 0);

    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);

    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (memcmp(pData, pIrqRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC2-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC2-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



    wsprintf(szMsg, TEXT("Modify Basic LC1-RD1 (grow): "));

    CM_Get_Next_Res_Des(&ResDes1, BasicLC1, ResType_All, &ResType, 0);

    Status = CM_Modify_Res_Des(&ResDes1, ResDes1, ResType_IRQ, pIrqRes,
                               sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2, 0);

    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);

    // null out header for comparison
    pIrqRes->IRQ_Header.IRQD_Flags      = 0;
    pIrqRes->IRQ_Header.IRQD_Alloc_Num  = 0;

    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (memcmp(pData, pIrqRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BASIC LC2-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BASIC LC2-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pIrqRes->IRQ_Header.IRQD_Flags     = fDD_DWORD;
    pIrqRes->IRQ_Header.IRQD_Alloc_Num = (DWORDLONG)11;



    wsprintf(szMsg, TEXT("Modify Boot LC2-RD2 (shrink CS): "));

    CM_Get_Next_Res_Des(&ResDes2, BootLC2, ResType_ClassSpecific, &ResType, 0);

    Status = CM_Modify_Res_Des(&ResDes2, ResDes2, ResType_ClassSpecific, pCs1Res,
                               sizeof(CS_RESOURCE) + 15, 0);

    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);

    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (ulSize != sizeof(CS_RESOURCE) + 15 ||
            memcmp(pData, pCs1Res, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC2-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC2-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



MessageBox(hDlg, TEXT("Check registry contents"), TEXT("CMTEST"), MB_OK);

    //---------------------------------------------------------------
    // Free res des test
    //---------------------------------------------------------------

    // delete rd2 and rd1 from lc2
    CM_Get_Next_Res_Des(&ResDes2, BootLC2, ResType_ClassSpecific, &ResType, 0);
    CM_Free_Res_Des(&ResDes1, ResDes2, 0);
    CM_Free_Res_Des(&BootLC2, ResDes1, 0);

    // delete rd1 from lc3
    CM_Get_Next_Res_Des(&ResDes1, BootLC3, ResType_All, &ResType, 0);
    CM_Free_Res_Des(&BootLC3, ResDes1, 0);

    // delete rd2 from lc3
    CM_Get_Next_Res_Des(&ResDes1, BootLC3, ResType_All, &ResType, 0);
    CM_Free_Res_Des(&BootLC3, ResDes1, 0);

    // delete rd2 and rd1 from lc1
    CM_Get_Next_Res_Des(&ResDes2, BootLC1, ResType_ClassSpecific, &ResType, 0);
    CM_Free_Res_Des(&ResDes1, ResDes2, 0);
    CM_Free_Res_Des(&BootLC1, ResDes1, 0);


MessageBox(hDlg, TEXT("Check registry contents"), TEXT("CMTEST"), MB_OK);

    //---------------------------------------------------------------
    // Free LC Test
    //---------------------------------------------------------------

    if (MessageBox(hDlg,
        TEXT("Free all the log confs that were just created?"),
        TEXT("CMTest"), MB_YESNO) == IDYES) {


        lstrcpy(szMsg, TEXT("Test free Boot Config LC2: "));
        Status = CM_Free_Log_Conf(BootLC2, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);


        lstrcpy(szMsg, TEXT("Test free Boot Config LC3: "));
        Status = CM_Free_Log_Conf(BootLC3, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);


        lstrcpy(szMsg, TEXT("Test free Boot Config LC1: "));
        Status = CM_Free_Log_Conf(BootLC1, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);



        lstrcpy(szMsg, TEXT("Test free Basic Config LC2: "));
        Status = CM_Free_Log_Conf(BasicLC2, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);


        lstrcpy(szMsg, TEXT("Test free Basic Config LC3: "));
        Status = CM_Free_Log_Conf(BasicLC3, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);


        lstrcpy(szMsg, TEXT("Test free Basic Config LC1: "));
        Status = CM_Free_Log_Conf(BasicLC1, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);
    }



   //----------------------------------------------------------------
   // Free Log config handles
   //----------------------------------------------------------------


    lstrcpy(szMsg, TEXT("Test free handle LC1: "));

    Status = CM_Free_Log_Conf_Handle(BootLC1);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else lstrcpy(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
           hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
           (LPARAM)(LPTSTR)szMsg);



    lstrcpy(szMsg, TEXT("Test free handle LC2: "));

    Status = CM_Free_Log_Conf_Handle(BootLC2);
    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else lstrcpy(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Test free handle LC3: "));

    Status = CM_Free_Log_Conf_Handle(BootLC3);
    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else lstrcpy(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Test freeing already freed handle: "));

    Status = CM_Free_Log_Conf_Handle(BootLC2);
    if (Status != CR_INVALID_LOG_CONF) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else lstrcpy(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
           hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
           (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Test freeing invalid config handle: "));

    BootLC2 = 1;

    Status = CM_Free_Log_Conf_Handle(BootLC2);
    if (Status != CR_FAILURE) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else lstrcpy(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
           hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
           (LPARAM)(LPTSTR)szMsg);



   if (pMemRes != NULL) free(pMemRes);
   if (pIoRes != NULL) free(pIoRes);
   if (pCs1Res != NULL) free(pCs1Res);
   if (pCs2Res != NULL) free(pCs2Res);
   if (pDmaRes != NULL) free(pDmaRes);
   if (pIrqRes != NULL) free(pIrqRes);

   return;

} // RegressionTest_LogConf



VOID 
SpecialCase_LogConf(
    DEVNODE dnDevNode
    )
{
    CONFIGRET Status;
    LOG_CONF  BootLC1, BasicLC1;
    RES_DES   ResDes;
    PCS_DES   pResourceData;
    ULONG     ulSize = 0;
    BYTE      i;
    PMEM_RESOURCE pMemRes = NULL;
    PCS_RESOURCE  pCs1Res = NULL;
    RESOURCEID ResourceID;
    LPBYTE    pBuffer = NULL, pData = NULL;

    //
    // fill out an arbitrary class specific structure
    //

    pCs1Res = malloc(sizeof(CS_RESOURCE) + 15);       //16-1
 
    pCs1Res->CS_Header.CSD_SignatureLength  = 16;
    pCs1Res->CS_Header.CSD_LegacyDataOffset = 0;
    pCs1Res->CS_Header.CSD_LegacyDataSize   = 0;
    pCs1Res->CS_Header.CSD_Flags            = 0;
 
    CM_Enumerate_Classes(0, &(pCs1Res->CS_Header.CSD_ClassGuid), 0);
 
    for (i = 0; i < 16; i++) {
        pCs1Res->CS_Header.CSD_Signature[i] = i;
    }
 

    CM_Add_Empty_Log_Conf(&BootLC1, dnDevNode, LCPRI_BOOTCONFIG, BOOT_LOG_CONF);

    CM_Add_Res_Des(&ResDes, BootLC1, ResType_ClassSpecific, pCs1Res, sizeof(CS_RESOURCE)+15, 0);
    CM_Free_Res_Des(NULL, ResDes, 0);

    // This last one returns CR_INVALID_RES_DES.

    CM_Get_Next_Res_Des(&ResDes, BootLC1, ResType_ClassSpecific, NULL, 0);
    CM_Free_Res_Des( NULL, ResDes, 0);
    // This last one returns CR_INVALID_RES_DES.
 

    //Paula, once we're here: is it OK that now for the last resource freed the result will be CR_SUCESS instead CR_NO_MORE_RES_DES ?   

    /*
1. If you try to free the first res des in a BASIC (FILTERED, OVERRIDE) log conf, this will 
succees with CR_SUCCESS every time, even it's the only res des added (a subsequent 
CM_Get_Next_Res_Des(..., lcLogConf, ...) will return CR_NO_MORE_RES_DES).

2. If there are two res des for the same log conf (I tried with two identical memory 
res des, each with MD_Count == 1, BASIC log conf) and you free the first one, when you 
try to retrieve the remaining one (with CM_Get_Next_Res_Des(...,lcLogConf,...) the 
resource type field (pResourceId) is set to 0, causing the next free to fail. More precisely:
*/


    pMemRes = malloc(sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE));
 
    pMemRes->MEM_Header.MD_Count      = 2;
    pMemRes->MEM_Header.MD_Type       = MType_Range;
    pMemRes->MEM_Header.MD_Alloc_Base = (DWORDLONG)0xD8000;
    pMemRes->MEM_Header.MD_Alloc_End  = (DWORDLONG)0xD9000;
    pMemRes->MEM_Header.MD_Flags      = fMD_ROM | fMD_32 | fMD_ReadAllowed;
    pMemRes->MEM_Header.MD_Reserved   = 0;
 
    pMemRes->MEM_Data[0].MR_Align     = 8; //?
    pMemRes->MEM_Data[0].MR_nBytes    = 4096;
    pMemRes->MEM_Data[0].MR_Min       = (DWORDLONG)0xD8000;
    pMemRes->MEM_Data[0].MR_Max       = (DWORDLONG)0xDC000;
    pMemRes->MEM_Data[0].MR_Flags     = fMD_ROM | fMD_32 | fMD_ReadAllowed;
    pMemRes->MEM_Data[0].MR_Reserved  = 0;
 
    pMemRes->MEM_Data[1].MR_Align     = 8; //?
    pMemRes->MEM_Data[1].MR_nBytes    = 4096;
    pMemRes->MEM_Data[1].MR_Min       = (DWORDLONG)0xE0000;
    pMemRes->MEM_Data[1].MR_Max       = (DWORDLONG)0xE4000;
    pMemRes->MEM_Data[1].MR_Flags     = fMD_ROM | fMD_32 | fMD_ReadAllowed;
    pMemRes->MEM_Data[1].MR_Reserved  = 0;
 
    CM_Add_Empty_Log_Conf(&BasicLC1, dnDevNode, LCPRI_NORMAL, BASIC_LOG_CONF);

    CM_Add_Res_Des(&ResDes, BasicLC1, ResType_Mem, pMemRes, sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE), 0);
    CM_Free_Res_Des_Handle(ResDes);
    
    CM_Add_Res_Des(&ResDes, BasicLC1, ResType_Mem, pMemRes, sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE), 0);
    CM_Free_Res_Des_Handle(ResDes);
    
    CM_Get_Next_Res_Des(&ResDes,  BasicLC1, ResType_All,  &ResourceID, 0);
    //
    //  returns CR_SUCCESS, ridRseourceID is 1 (memory)
    //
    CM_Free_Res_Des(&ResDes, ResDes, 0);

    //
    // returns CR_SUCCESS
    //

    CM_Get_Next_Res_Des(&ResDes,  BasicLC1, ResType_All,  &ResourceID, 0);
    //
    // This one returns CR_SUCCESS, but ridResourceID is 0, so the next free will fail
    //
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon\cmds.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devcon.cpp

Abstract:

    Device Console
    command-line interface for managing devices

@@BEGIN_DDKSPLIT
Author:

    Jamie Hunter (JamieHun) Nov-30-2000

Revision History:

@@END_DDKSPLIT
--*/

#include "devcon.h"

struct GenericContext {
    DWORD count;
    DWORD control;
    BOOL  reboot;
    LPCTSTR strSuccess;
    LPCTSTR strReboot;
    LPCTSTR strFail;
};

#define FIND_DEVICE         0x00000001 // display device
#define FIND_STATUS         0x00000002 // display status of device
#define FIND_RESOURCES      0x00000004 // display resources of device
#define FIND_DRIVERFILES    0x00000008 // display drivers used by device
#define FIND_HWIDS          0x00000010 // display hw/compat id's used by device
#define FIND_DRIVERNODES    0x00000020 // display driver nodes for a device.
#define FIND_CLASS          0x00000040 // display device's setup class
#define FIND_STACK          0x00000080 // display device's driver-stack

struct SetHwidContext {
    int argc_right;
    LPTSTR * argv_right;
    DWORD prop;
    int skipped;
    int modified;
};

int cmdHelp(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    HELP command
    allow HELP or HELP <command>

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine (ignored)
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    DWORD helptext = 0;
    int dispIndex;
    LPCTSTR cmd = NULL;
    BOOL unknown = FALSE;

    if(argc) {
        //
        // user passed in a command for help on... long help
        //
        for(dispIndex = 0;DispatchTable[dispIndex].cmd;dispIndex++) {
            if(_tcsicmp(argv[0],DispatchTable[dispIndex].cmd)==0) {
                cmd = DispatchTable[dispIndex].cmd;
                helptext = DispatchTable[dispIndex].longHelp;
                break;
            }
        }
        if(!cmd) {
            unknown = TRUE;
            cmd = argv[0];
        }
    }

    if(helptext) {
        //
        // long help
        //
        FormatToStream(stdout,helptext,BaseName,cmd);
    } else {
        //
        // help help
        //
        FormatToStream(stdout,unknown ? MSG_HELP_OTHER : MSG_HELP_LONG,BaseName,cmd);
        //
        // enumerate through each command and display short help for each
        //
        for(dispIndex = 0;DispatchTable[dispIndex].cmd;dispIndex++) {
            if(DispatchTable[dispIndex].shortHelp) {
                FormatToStream(stdout,DispatchTable[dispIndex].shortHelp,DispatchTable[dispIndex].cmd);
            }
        }
    }
    return EXIT_OK;
}

int cmdClasses(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    CLASSES command
    lists classes on (optionally) specified machine
    format as <name>: <destination>

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - ignored

Return Value:

    EXIT_xxxx

--*/
{
    DWORD reqGuids = 128;
    DWORD numGuids;
    LPGUID guids = NULL;
    DWORD index;
    int failcode = EXIT_FAIL;

    guids = new GUID[reqGuids];
    if(!guids) {
        goto final;
    }
    if(!SetupDiBuildClassInfoListEx(0,guids,reqGuids,&numGuids,Machine,NULL)) {
        do {
            if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                goto final;
            }
            delete [] guids;
            reqGuids = numGuids;
            guids = new GUID[reqGuids];
            if(!guids) {
                goto final;
            }
        } while(!SetupDiBuildClassInfoListEx(0,guids,reqGuids,&numGuids,Machine,NULL));
    }
    FormatToStream(stdout,Machine?MSG_CLASSES_HEADER:MSG_CLASSES_HEADER_LOCAL,numGuids,Machine);
    for(index=0;index<numGuids;index++) {
        TCHAR className[MAX_CLASS_NAME_LEN];
        TCHAR classDesc[LINE_LEN];
        if(!SetupDiClassNameFromGuidEx(&guids[index],className,MAX_CLASS_NAME_LEN,NULL,Machine,NULL)) {
            lstrcpyn(className,TEXT("?"),MAX_CLASS_NAME_LEN);
        }
        if(!SetupDiGetClassDescriptionEx(&guids[index],classDesc,LINE_LEN,NULL,Machine,NULL)) {
            lstrcpyn(classDesc,className,LINE_LEN);
        }
        _tprintf(TEXT("%-20s: %s\n"),className,classDesc);
    }

    failcode = EXIT_OK;

final:

    if(guids) {
        delete [] guids;
    }
    return failcode;
}

int cmdListClass(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    LISTCLASS <name>....
    lists all devices for each specified class
    there can be more than one physical class for a class name (shouldn't be
    though) in such cases, list each class
    if machine given, list devices for that machine

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - list of class names

Return Value:

    EXIT_xxxx

--*/
{
    BOOL classListed = FALSE;
    BOOL devListed = FALSE;
    DWORD reqGuids = 16;
    int argIndex;
    int failcode = EXIT_FAIL;
    LPGUID guids = NULL;
    HDEVINFO devs = INVALID_HANDLE_VALUE;

    if(!argc) {
        return EXIT_USAGE;
    }

    guids = new GUID[reqGuids];
    if(!guids) {
        goto final;
    }

    for(argIndex = 0;argIndex<argc;argIndex++) {
        DWORD numGuids;
        DWORD index;

        if(!(argv[argIndex] && argv[argIndex][0])) {
            continue;
        }

        //
        // there could be one to many name to GUID mapping
        //
        while(!SetupDiClassGuidsFromNameEx(argv[argIndex],guids,reqGuids,&numGuids,Machine,NULL)) {
            if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                goto final;
            }
            delete [] guids;
            reqGuids = numGuids;
            guids = new GUID[reqGuids];
            if(!guids) {
                goto final;
            }
        }
        if(numGuids == 0) {
            FormatToStream(stdout,Machine?MSG_LISTCLASS_NOCLASS:MSG_LISTCLASS_NOCLASS_LOCAL,argv[argIndex],Machine);
            continue;
        }
        for(index = 0;index<numGuids;index++) {
            TCHAR className[MAX_CLASS_NAME_LEN];
            TCHAR classDesc[LINE_LEN];
            DWORD devCount = 0;
            SP_DEVINFO_DATA devInfo;
            DWORD devIndex;

            devs = SetupDiGetClassDevsEx(&guids[index],NULL,NULL,DIGCF_PRESENT,NULL,Machine,NULL);
            if(devs != INVALID_HANDLE_VALUE) {
                //
                // count number of devices
                //
                devInfo.cbSize = sizeof(devInfo);
                while(SetupDiEnumDeviceInfo(devs,devCount,&devInfo)) {
                    devCount++;
                }
            }

            if(!SetupDiClassNameFromGuidEx(&guids[index],className,MAX_CLASS_NAME_LEN,NULL,Machine,NULL)) {
                lstrcpyn(className,TEXT("?"),MAX_CLASS_NAME_LEN);
            }
            if(!SetupDiGetClassDescriptionEx(&guids[index],classDesc,LINE_LEN,NULL,Machine,NULL)) {
                lstrcpyn(classDesc,className,LINE_LEN);
            }

            //
            // how many devices?
            //
            if (!devCount) {
                FormatToStream(stdout,Machine?MSG_LISTCLASS_HEADER_NONE:MSG_LISTCLASS_HEADER_NONE_LOCAL,className,classDesc,Machine);
            } else {
                FormatToStream(stdout,Machine?MSG_LISTCLASS_HEADER:MSG_LISTCLASS_HEADER_LOCAL,devCount,className,classDesc,Machine);
                for(devIndex=0;SetupDiEnumDeviceInfo(devs,devIndex,&devInfo);devIndex++) {
                    DumpDevice(devs,&devInfo);
                }
            }
            if(devs != INVALID_HANDLE_VALUE) {
                SetupDiDestroyDeviceInfoList(devs);
                devs = INVALID_HANDLE_VALUE;
            }
        }
    }

    failcode = 0;

final:

    if(guids) {
        delete [] guids;
    }

    if(devs != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(devs);
    }

    return failcode;
}

int FindCallback(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Index,LPVOID Context)
/*++

Routine Description:

    Callback for use by Find/FindAll
    just simply display the device

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext *pFindContext = (GenericContext*)Context;

    if(!pFindContext->control) {
        DumpDevice(Devs,DevInfo);
        pFindContext->count++;
        return EXIT_OK;
    }
    if(!DumpDeviceWithInfo(Devs,DevInfo,NULL)) {
        return EXIT_OK;
    }
    if(pFindContext->control&FIND_DEVICE) {
        DumpDeviceDescr(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_CLASS) {
        DumpDeviceClass(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_STATUS) {
        DumpDeviceStatus(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_RESOURCES) {
        DumpDeviceResources(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_DRIVERFILES) {
        DumpDeviceDriverFiles(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_STACK) {
        DumpDeviceStack(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_HWIDS) {
        DumpDeviceHwIds(Devs,DevInfo);
    }
    if (pFindContext->control&FIND_DRIVERNODES) {
        DumpDeviceDriverNodes(Devs,DevInfo);
    }
    pFindContext->count++;
    return EXIT_OK;
}

int cmdFind(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    FIND <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = 0;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdFindAll(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    FINDALL <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump to stdout
    like find, but also show not-present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = 0;
    failcode = EnumerateDevices(BaseName,Machine,0,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdStatus(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    STATUS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump status to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_STATUS;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}


int cmdResources(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    RESOURCES <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump resources to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_RESOURCES;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}


int cmdDriverFiles(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    STATUS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump driver files to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers (FIND_DRIVERFILES)
        //
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_DRIVERFILES;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdDriverNodes(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    STATUS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump drivernodes to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers (FIND_DRIVERNODES)
        //
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_DRIVERNODES;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdHwIds(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    HWIDS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump hw/compat id's to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_HWIDS;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdStack(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    STACK <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump device class and stack to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_CLASS | FIND_STACK;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}




int ControlCallback(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Index,LPVOID Context)
/*++

Routine Description:

    Callback for use by Enable/Disable/Restart
    Invokes DIF_PROPERTYCHANGE with correct parameters
    uses SetupDiCallClassInstaller so cannot be done for remote devices
    Don't use CM_xxx API's, they bypass class/co-installers and this is bad.

    In Enable case, we try global first, and if still disabled, enable local

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    SP_PROPCHANGE_PARAMS pcp;
    GenericContext *pControlContext = (GenericContext*)Context;
    SP_DEVINSTALL_PARAMS devParams;

    switch(pControlContext->control) {
        case DICS_ENABLE:
            //
            // enable both on global and config-specific profile
            // do global first and see if that succeeded in enabling the device
            // (global enable doesn't mark reboot required if device is still
            // disabled on current config whereas vice-versa isn't true)
            //
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            pcp.StateChange = pControlContext->control;
            pcp.Scope = DICS_FLAG_GLOBAL;
            pcp.HwProfile = 0;
            //
            // don't worry if this fails, we'll get an error when we try config-
            // specific.
            if(SetupDiSetClassInstallParams(Devs,DevInfo,&pcp.ClassInstallHeader,sizeof(pcp))) {
               SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,Devs,DevInfo);
            }
            //
            // now enable on config-specific
            //
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            pcp.StateChange = pControlContext->control;
            pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
            pcp.HwProfile = 0;
            break;

        default:
            //
            // operate on config-specific profile
            //
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            pcp.StateChange = pControlContext->control;
            pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
            pcp.HwProfile = 0;
            break;

    }

    if(!SetupDiSetClassInstallParams(Devs,DevInfo,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,Devs,DevInfo)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DumpDeviceWithInfo(Devs,DevInfo,pControlContext->strFail);
    } else {
        //
        // see if device needs reboot
        //
        devParams.cbSize = sizeof(devParams);
        if(SetupDiGetDeviceInstallParams(Devs,DevInfo,&devParams) && (devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT))) {
                DumpDeviceWithInfo(Devs,DevInfo,pControlContext->strReboot);
                pControlContext->reboot = TRUE;
        } else {
            //
            // appears to have succeeded
            //
            DumpDeviceWithInfo(Devs,DevInfo,pControlContext->strSuccess);
        }
        pControlContext->count++;
    }
    return EXIT_OK;
}

int cmdEnable(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    ENABLE <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, attempt to enable global, and if needed, config specific

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx (EXIT_REBOOT if reboot is required)

--*/
{
    GenericContext context;
    TCHAR strEnable[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_ENABLED,strEnable,ARRAYSIZE(strEnable))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_ENABLED_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_ENABLE_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.control = DICS_ENABLE; // DICS_PROPCHANGE DICS_ENABLE DICS_DISABLE
    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strEnable;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,ControlCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_ENABLE_TAIL_NONE);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_ENABLE_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_ENABLE_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdDisable(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    DISABLE <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, attempt to disable global

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx (EXIT_REBOOT if reboot is required)

--*/
{
    GenericContext context;
    TCHAR strDisable[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_DISABLED,strDisable,ARRAYSIZE(strDisable))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_DISABLED_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_DISABLE_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.control = DICS_DISABLE; // DICS_PROPCHANGE DICS_ENABLE DICS_DISABLE
    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strDisable;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,ControlCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_DISABLE_TAIL_NONE);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_DISABLE_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_DISABLE_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdRestart(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    RESTART <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, attempt to restart by issueing a PROPCHANGE

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx (EXIT_REBOOT if reboot is required)

--*/
{
    GenericContext context;
    TCHAR strRestarted[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_RESTARTED,strRestarted,ARRAYSIZE(strRestarted))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_REQUIRES_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_RESTART_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.control = DICS_PROPCHANGE;
    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strRestarted;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,ControlCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_RESTART_TAIL_NONE);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_RESTART_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_RESTART_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdReboot(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    REBOOT
    reboot local machine

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - ignored

Return Value:

    EXIT_xxxx

--*/
{
    if(Machine) {
        //
        // must be local machine
        //
        return EXIT_USAGE;
    }
    FormatToStream(stdout,MSG_REBOOT);
    return Reboot() ? EXIT_OK : EXIT_FAIL;
}


int cmdUpdate(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:
    UPDATE
    update driver for existing device(s)

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    HMODULE newdevMod = NULL;
    int failcode = EXIT_FAIL;
    UpdateDriverForPlugAndPlayDevicesProto UpdateFn;
    BOOL reboot = FALSE;
    LPCTSTR hwid = NULL;
    LPCTSTR inf = NULL;
    DWORD flags = 0;
    DWORD res;
    TCHAR InfPath[MAX_PATH];

    if(Machine) {
        //
        // must be local machine
        //
        return EXIT_USAGE;
    }
    if(argc<2) {
        //
        // at least HWID required
        //
        return EXIT_USAGE;
    }
    inf = argv[0];
    if(!inf[0]) {
        return EXIT_USAGE;
    }

    hwid = argv[1];
    if(!hwid[0]) {
        return EXIT_USAGE;
    }
    //
    // Inf must be a full pathname
    //
    res = GetFullPathName(inf,MAX_PATH,InfPath,NULL);
    if((res >= MAX_PATH) || (res == 0)) {
        //
        // inf pathname too long
        //
        return EXIT_FAIL;
    }
    if(GetFileAttributes(InfPath)==(DWORD)(-1)) {
        //
        // inf doesn't exist
        //
        return EXIT_FAIL;
    }
    inf = InfPath;
    flags |= INSTALLFLAG_FORCE;

    //
    // make use of UpdateDriverForPlugAndPlayDevices
    //
    newdevMod = LoadLibrary(TEXT("newdev.dll"));
    if(!newdevMod) {
        goto final;
    }
    UpdateFn = (UpdateDriverForPlugAndPlayDevicesProto)GetProcAddress(newdevMod,UPDATEDRIVERFORPLUGANDPLAYDEVICES);
    if(!UpdateFn)
    {
        goto final;
    }

    FormatToStream(stdout,inf ? MSG_UPDATE_INF : MSG_UPDATE,hwid,inf);

    if(!UpdateFn(NULL,hwid,inf,flags,&reboot)) {
        goto final;
    }

    FormatToStream(stdout,MSG_UPDATE_OK);

    failcode = reboot ? EXIT_REBOOT : EXIT_OK;

final:

    if(newdevMod) {
        FreeLibrary(newdevMod);
    }

    return failcode;
}

int cmdInstall(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    INSTALL
    install a device manually

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    HDEVINFO DeviceInfoSet = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DeviceInfoData;
    GUID ClassGUID;
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    TCHAR hwIdList[LINE_LEN+4];
    TCHAR InfPath[MAX_PATH];
    DWORD err;
    int failcode = EXIT_FAIL;
    BOOL reboot = FALSE;
    LPCTSTR hwid = NULL;
    LPCTSTR inf = NULL;
    DWORD flags = 0;
    DWORD len;

    if(Machine) {
        //
        // must be local machine
        //
        return EXIT_USAGE;
    }
    if(argc<2) {
        //
        // at least HWID required
        //
        return EXIT_USAGE;
    }
    inf = argv[0];
    if(!inf[0]) {
        return EXIT_USAGE;
    }

    hwid = argv[1];
    if(!hwid[0]) {
        return EXIT_USAGE;
    }

    //
    // Inf must be a full pathname
    //
    if(GetFullPathName(inf,MAX_PATH,InfPath,NULL) >= MAX_PATH) {
        //
        // inf pathname too long
        //
        return EXIT_FAIL;
    }

    //
    // List of hardware ID's must be double zero-terminated
    //
    ZeroMemory(hwIdList,sizeof(hwIdList));
    lstrcpyn(hwIdList,hwid,LINE_LEN);

    //
    // Use the INF File to extract the Class GUID.
    //
    if (!SetupDiGetINFClass(InfPath,&ClassGUID,ClassName,sizeof(ClassName)/sizeof(ClassName[0]),0))
    {
        goto final;
    }

    //
    // Create the container for the to-be-created Device Information Element.
    //
    DeviceInfoSet = SetupDiCreateDeviceInfoList(&ClassGUID,0);
    if(DeviceInfoSet == INVALID_HANDLE_VALUE)
    {
        goto final;
    }

    //
    // Now create the element.
    // Use the Class GUID and Name from the INF file.
    //
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiCreateDeviceInfo(DeviceInfoSet,
        ClassName,
        &ClassGUID,
        NULL,
        0,
        DICD_GENERATE_ID,
        &DeviceInfoData))
    {
        goto final;
    }

    //
    // Add the HardwareID to the Device's HardwareID property.
    //
    if(!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
        &DeviceInfoData,
        SPDRP_HARDWAREID,
        (LPBYTE)hwIdList,
        (lstrlen(hwIdList)+1+1)*sizeof(TCHAR)))
    {
        goto final;
    }

    //
    // Transform the registry element into an actual devnode
    // in the PnP HW tree.
    //
    if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
        DeviceInfoSet,
        &DeviceInfoData))
    {
        goto final;
    }

    FormatToStream(stdout,MSG_INSTALL_UPDATE);
    //
    // update the driver for the device we just created
    //
    failcode = cmdUpdate(BaseName,Machine,argc,argv);

final:

    if (DeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    }

    return failcode;
}

int cmdUpdateNI(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:
    UPDATE (non interactive version)
    update driver for existing device(s)

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    //
    // turn off interactive mode while doing the update
    //
    HMODULE setupapiMod = NULL;
    SetupSetNonInteractiveModeProto SetNIFn;
    int res;
    BOOL prev;

    setupapiMod = LoadLibrary(TEXT("setupapi.dll"));
    if(!setupapiMod) {
        return cmdUpdate(BaseName,Machine,argc,argv);
    }
    SetNIFn = (SetupSetNonInteractiveModeProto)GetProcAddress(setupapiMod,SETUPSETNONINTERACTIVEMODE);
    if(!SetNIFn)
    {
        FreeLibrary(setupapiMod);
        return cmdUpdate(BaseName,Machine,argc,argv);
    }
    prev = SetNIFn(TRUE);
    res = cmdUpdate(BaseName,Machine,argc,argv);
    SetNIFn(prev);
    FreeLibrary(setupapiMod);
    return res;
}

int RemoveCallback(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Index,LPVOID Context)
/*++

Routine Description:

    Callback for use by Remove
    Invokes DIF_REMOVE
    uses SetupDiCallClassInstaller so cannot be done for remote devices
    Don't use CM_xxx API's, they bypass class/co-installers and this is bad.

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    SP_REMOVEDEVICE_PARAMS rmdParams;
    GenericContext *pControlContext = (GenericContext*)Context;
    SP_DEVINSTALL_PARAMS devParams;
    LPCTSTR action = NULL;

    //
    // need hardware ID before trying to remove, as we wont have it after
    //
    TCHAR devID[MAX_DEVICE_ID_LEN];
    LPTSTR desc;
    BOOL b = TRUE;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfo->DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        //
        // skip this
        //
        return EXIT_OK;
    }

    rmdParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    rmdParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
    rmdParams.Scope = DI_REMOVEDEVICE_GLOBAL;
    rmdParams.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(Devs,DevInfo,&rmdParams.ClassInstallHeader,sizeof(rmdParams)) ||
       !SetupDiCallClassInstaller(DIF_REMOVE,Devs,DevInfo)) {
        //
        // failed to invoke DIF_REMOVE
        //
        action = pControlContext->strFail;
    } else {
        //
        // see if device needs reboot
        //
        devParams.cbSize = sizeof(devParams);
        if(SetupDiGetDeviceInstallParams(Devs,DevInfo,&devParams) && (devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT))) {
            //
            // reboot required
            //
            action = pControlContext->strReboot;
            pControlContext->reboot = TRUE;
        } else {
            //
            // appears to have succeeded
            //
            action = pControlContext->strSuccess;
        }
        pControlContext->count++;
    }
    _tprintf(TEXT("%-60s: %s\n"),devID,action);

    return EXIT_OK;
}

int cmdRemove(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    REMOVE
    remove devices

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    TCHAR strRemove[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_REMOVED,strRemove,ARRAYSIZE(strRemove))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_REMOVED_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_REMOVE_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strRemove;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,RemoveCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_REMOVE_TAIL_NONE);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_REMOVE_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_REMOVE_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdRescan(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    RESCAN
    rescan for new devices

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{

    //
    // reenumerate from the root of the devnode tree
    // totally CM based
    //
    int failcode = EXIT_FAIL;
    HMACHINE machineHandle = NULL;
    DEVINST devRoot;

    if(Machine) {
        if(CM_Connect_Machine(Machine,&machineHandle) != CR_SUCCESS) {
            return failcode;
        }
    }

    if(CM_Locate_DevNode_Ex(&devRoot,NULL,CM_LOCATE_DEVNODE_NORMAL,machineHandle) != CR_SUCCESS) {
        goto final;
    }

    FormatToStream(stdout,Machine ? MSG_RESCAN : MSG_RESCAN_LOCAL);

    if(CM_Reenumerate_DevNode_Ex(devRoot, 0, machineHandle) != CR_SUCCESS) {
        goto final;
    }

    FormatToStream(stdout,MSG_RESCAN_OK);

    failcode = EXIT_OK;

final:
    if(machineHandle) {
        CM_Disconnect_Machine(machineHandle);
    }

    return failcode;
}

int cmdClassFilter(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    CLASSFILTER <name> <type> <subcmds>
    Allows tweaking of class filters
    Useful for filter driver development and for Product Support

    <subcmds> is a list of the following:
    @service - sets 'after' to the first match of service after 'after'
               (reset to -1 after any other command)
    !service - deletes first match of 'service' after 'after'
    -service - insert new service directly prior to 'after', or at start
    +service - insert new service directly after 'after', or at end

    if no <subcmds> given, list the services

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - list of class names

Return Value:

    EXIT_xxxx

--*/
{
    int failcode = EXIT_FAIL;
    int argIndex;
    DWORD numGuids;
    GUID guid;
    LPTSTR regval = NULL;
    HKEY hk = (HKEY)INVALID_HANDLE_VALUE;
    LPTSTR * multiVal = NULL;
    int after;
    bool modified = false;
    int span;
    SC_HANDLE SCMHandle = NULL;
    SC_HANDLE ServHandle = NULL;

    if((argc<2) || !argv[0][0]) {
        return EXIT_USAGE;
    }

    //
    // just take the first guid for the name
    //
    if(!SetupDiClassGuidsFromNameEx(argv[0],&guid,1,&numGuids,Machine,NULL)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto final;
        }
    }
    if(numGuids == 0) {
        goto final;
    }
    if(_tcsicmp(argv[1],TEXT("upper"))==0) {
        regval = REGSTR_VAL_UPPERFILTERS;
    } else if(_tcsicmp(argv[1],TEXT("lower"))==0) {
        regval = REGSTR_VAL_LOWERFILTERS;
    } else {
        failcode = EXIT_USAGE;
        goto final;
    }

    hk = SetupDiOpenClassRegKeyEx(&guid,
                                  KEY_READ | (argc>2 ? KEY_WRITE : 0),
                                  DIOCR_INSTALLER,
                                  Machine,
                                  NULL
                                 );
    if(hk == INVALID_HANDLE_VALUE) {
        goto final;
    }
    multiVal = GetRegMultiSz(hk,regval);

    if(argc<=2) {
        //
        // just display
        //
        FormatToStream(stdout,MSG_CLASSFILTER_UNCHANGED);
        DumpArray(1,multiVal);
        failcode = EXIT_OK;
        goto final;
    }
    after = -1; // for the @service expressions
    span =  1;

    if(!multiVal) {
        multiVal = CopyMultiSz(NULL);
        if(!multiVal) {
            goto final;
        }
    }

    for(argIndex=2;argIndex<argc;argIndex++) {
        if((argv[argIndex] == NULL) ||
           (!argv[argIndex])) {
            failcode = EXIT_USAGE;
            break;
        }

        int op = argv[argIndex][0];
        LPTSTR serv = argv[argIndex]+1;
        int mark = 0;
        int cnt;
        int ent;
        LPTSTR * tmpArray;

        if(op == TEXT('=')) {
            after = -1;
            span = 1;
            op = serv[0];
            if(!op) {
                continue;
            }
            serv++;
        }

        if(!serv[0]) {
            failcode = EXIT_USAGE;
            goto final;
        }

        if((op == TEXT('@')) || (op == TEXT('!'))) {
            //
            // need to find specified service in list
            //
            for(after+=span;multiVal[after];after++) {
                if(_tcsicmp(multiVal[after],serv)==0) {
                    break;
                }
            }
            if(!multiVal[after]) {
                goto final;
            }
            if(op == TEXT('@')) {
                //
                // all we needed to do for '@'
                //
                span = 1; // span of 1
                continue;
            }
            //
            // we're modifying
            //
            int c;
            for(c = after;multiVal[c];c++) {
                multiVal[c] = multiVal[c+1];
            }
            LPTSTR * newArray = CopyMultiSz(multiVal);
            if(!newArray) {
                goto final;
            }
            DelMultiSz(multiVal);
            multiVal = newArray;
            span = 0; // span of 0 (deleted)
            modified = true;
            continue;
        }

        if(op == '+') {
            //
            // insert after
            //
            if(after<0) {
                int c;
                for(c = 0;multiVal[c];c++) {
                    // nothing
                }
                mark = c;
            }
            else {
                mark = after+span;
            }
        } else if(op == '-') {
            //
            // insert before
            //
            if(after<0) {
                mark = 0;
            } else {
                mark = after;
            }
        } else {
            //
            // not valid
            //
            failcode = EXIT_USAGE;
            goto final;
        }
        //
        // sanity - see if service exists
        //
        if(!(SCMHandle = OpenSCManager(Machine, NULL, GENERIC_READ))) {
            goto final;
        }
        ServHandle = OpenService(SCMHandle,serv,GENERIC_READ);
        if(ServHandle) {
            CloseServiceHandle(ServHandle);
        }
        CloseServiceHandle(SCMHandle);
        if(!ServHandle) {
            goto final;
        }

        //
        // need an array a little bigger
        //
        for(cnt = 0;multiVal[cnt];cnt++) {
            // nothing
        }

        tmpArray = new LPTSTR[cnt+2];
        if(!tmpArray) {
            goto final;
        }
        for(ent=0;ent<mark;ent++) {
            tmpArray[ent] = multiVal[ent];
        }
        tmpArray[ent] = serv;
        for(;ent<cnt;ent++) {
            tmpArray[ent+1] = multiVal[ent];
        }
        tmpArray[ent+1] = NULL;
        LPTSTR * newArray = CopyMultiSz(tmpArray);
        delete [] tmpArray;
        if(!newArray) {
            goto final;
        }
        DelMultiSz(multiVal);
        multiVal = newArray;
        modified = true;
        span = 1;
        after = mark;
    }

    if(modified) {
        if(multiVal[0]) {
            int len = 0;
            LPTSTR multiSz = multiVal[-1];
            LPTSTR p = multiSz;
            while(*p) {
                p+=lstrlen(p)+1;
            }
            p++; // skip past null
            len = (p-multiSz)*sizeof(TCHAR);
            LONG err = RegSetValueEx(hk,regval,0,REG_MULTI_SZ,(LPBYTE)multiSz,len);
            if(err==NO_ERROR) {
                FormatToStream(stdout,MSG_CLASSFILTER_CHANGED);
                DumpArray(1,multiVal);
                failcode = EXIT_REBOOT;
            }
        } else {
            LONG err = RegDeleteValue(hk,regval);
            if((err == NO_ERROR) || (err == ERROR_FILE_NOT_FOUND)) {
                FormatToStream(stdout,MSG_CLASSFILTER_CHANGED);
                failcode = EXIT_REBOOT;
            }
        }
    } else {
        FormatToStream(stdout,MSG_CLASSFILTER_UNCHANGED);
        DumpArray(1,multiVal);
        failcode = EXIT_OK;
    }

final:

    if(multiVal) {
        DelMultiSz(multiVal);
    }
    if(hk != (HKEY)INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    return failcode;
}

int SetHwidCallback(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Index,LPVOID Context)
/*++

Routine Description:

    Callback for use by SetHwid

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - SetHwidContext

Return Value:

    EXIT_xxxx

--*/
{
    SP_REMOVEDEVICE_PARAMS rmdParams;
    SetHwidContext *pControlContext = (SetHwidContext*)Context;
    SP_DEVINSTALL_PARAMS devParams;
    ULONG status;
    ULONG problem;
    LPTSTR * hwlist = NULL;
    bool modified = false;
    int result = EXIT_FAIL;

    //
    // processes the sub-commands on each callback
    // not most efficient way of doing things, but perf isn't important
    //
    TCHAR devID[MAX_DEVICE_ID_LEN];
    BOOL b = TRUE;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfo->DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS) ||
            (CM_Get_DevNode_Status_Ex(&status,&problem,DevInfo->DevInst,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        //
        // skip this
        //
        return EXIT_OK;
    }
    //
    // this is how to verify it's root enumerated
    //
    if(!(status & DN_ROOT_ENUMERATED)) {
        _tprintf(TEXT("%-60s: "),devID);
        FormatToStream(stdout,MSG_SETHWID_NOTROOT);
        pControlContext->skipped++;
        return EXIT_OK;
    }
    hwlist = GetDevMultiSz(Devs,DevInfo,pControlContext->prop);
    if(hwlist == NULL) {
        hwlist = CopyMultiSz(NULL);
        if(hwlist == NULL) {
            return EXIT_FAIL;
        }
    }

    //
    // modify hwid list (only relevent for root-enumerated devices)
    //
    int i;
    int mark = -1;

    for(i=0;i<pControlContext->argc_right;i++) {
        LPTSTR op = pControlContext->argv_right[i];
        if(op[0] == TEXT('=')) {
            //
            // clear the hwid list first
            //
            hwlist[0] = NULL;
            mark = 0;
            op++;
        } else if(op[0] == TEXT('+')) {
            //
            // insert as better match
            //
            mark = 0;
            op++;
        } else if(op[0] == TEXT('-')) {
            //
            // insert as worse match
            //
            mark = -1;
            op++;
        } else if(op[0] == TEXT('!')) {
            //
            // delete
            //
            mark = -2;
            op++;
        } else {
            //
            // treat as a hardware id
            //
        }
        if(!*op) {
            result = EXIT_USAGE;
            goto final;
        }
        int cnt;
        for(cnt = 0;hwlist[cnt];cnt++) {
            // nothing
        }
        if((mark == -1) || (mark>cnt)) {
            mark = cnt;
        }
        LPTSTR * tmpArray = new LPTSTR[cnt+2];
        if(!tmpArray) {
            goto final;
        }
        int dst = 0;
        int ent;
        for(ent=0;ent<mark;ent++) {
            if(_tcsicmp(hwlist[ent],op)==0) {
                continue;
            }
            tmpArray[dst++] = hwlist[ent];
        }
        if(mark>=0) {
            tmpArray[dst++] = op;
        }
        for(;ent<cnt;ent++) {
            if(_tcsicmp(hwlist[ent],op)==0) {
                continue;
            }
            tmpArray[dst++] = hwlist[ent];
        }
        tmpArray[dst] = NULL;
        LPTSTR * newArray = CopyMultiSz(tmpArray);
        delete [] tmpArray;
        if(!newArray) {
            goto final;
        }
        DelMultiSz(hwlist);
        hwlist = newArray;
        modified = true;
        mark++;
    }

    //
    // re-set the hwid list
    //
    if(modified) {
        if(hwlist[0]) {
            int len = 0;
            LPTSTR multiSz = hwlist[-1];
            LPTSTR p = multiSz;
            while(*p) {
                p+=lstrlen(p)+1;
            }
            p++; // skip past final null
            len = (p-multiSz)*sizeof(TCHAR);
            if(!SetupDiSetDeviceRegistryProperty(Devs,
                                                 DevInfo,
                                                 pControlContext->prop,
                                                 (LPBYTE)multiSz,
                                                 len)) {
                result = EXIT_FAIL;
                goto final;
            }
        } else {
            //
            // delete list
            //
            if(!SetupDiSetDeviceRegistryProperty(Devs,
                                                 DevInfo,
                                                 pControlContext->prop,
                                                 NULL,
                                                 0)) {
                result = EXIT_FAIL;
                goto final;
            }
        }
    }
    result = EXIT_OK;
    pControlContext->modified++;
    _tprintf(TEXT("%-60s: "),devID);
    for(mark=0;hwlist[mark];mark++) {
        if(mark > 0) {
            _tprintf(TEXT(","));
        }
        _tprintf(TEXT("%s"),hwlist[mark]);
    }
    _tprintf(TEXT("\n"));

    //
    // cleanup
    //

  final:

    if(hwlist) {
        DelMultiSz(hwlist);
    }

    return result;
}

int cmdSetHwid(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    SETHWID
    changes the hardware ID's of the listed root-enumerated devices
    This demonstrates how to differentiate between root-enumerated and
    non root-enumerated devices.
    It also demonstrates how to get/set hardware ID's of root-enumerated
    devices.

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    SetHwidContext context;
    int failcode = EXIT_FAIL;

    if(!SplitCommandLine(argc,argv,context.argc_right,context.argv_right)
       || (argc == 0)
       || (context.argc_right == 0)) {
        //
        // arguments required both left and right of ':='
        //
        return EXIT_USAGE;
    }
    context.skipped = 0;
    context.modified = 0;
    context.prop = SPDRP_HARDWAREID;

    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,SetHwidCallback,&context);

    if(failcode == EXIT_OK) {

        if(context.skipped) {
            FormatToStream(stdout,MSG_SETHWID_TAIL_SKIPPED,context.skipped,context.modified);
        } else if(context.modified) {
            FormatToStream(stdout,MSG_SETHWID_TAIL_MODIFIED,context.modified);
        } else {
            FormatToStream(stdout,MSG_SETHWID_TAIL_NONE);
        }
    }
    return failcode;
}






DispatchEntry DispatchTable[] = {
    { TEXT("classfilter"),  cmdClassFilter, MSG_CLASSFILTER_SHORT, MSG_CLASSFILTER_LONG },
    { TEXT("classes"),      cmdClasses,     MSG_CLASSES_SHORT,     MSG_CLASSES_LONG },
    { TEXT("disable"),      cmdDisable,     MSG_DISABLE_SHORT,     MSG_DISABLE_LONG },
    { TEXT("driverfiles"),  cmdDriverFiles, MSG_DRIVERFILES_SHORT, MSG_DRIVERFILES_LONG },
    { TEXT("drivernodes"),  cmdDriverNodes, MSG_DRIVERNODES_SHORT, MSG_DRIVERNODES_LONG },
    { TEXT("enable"),       cmdEnable,      MSG_ENABLE_SHORT,      MSG_ENABLE_LONG },
    { TEXT("find"),         cmdFind,        MSG_FIND_SHORT,        MSG_FIND_LONG },
    { TEXT("findall"),      cmdFindAll,     MSG_FINDALL_SHORT,     MSG_FINDALL_LONG },
    { TEXT("help"),         cmdHelp,        MSG_HELP_SHORT,        0 },
    { TEXT("hwids"),        cmdHwIds,       MSG_HWIDS_SHORT,       MSG_HWIDS_LONG },
    { TEXT("install"),      cmdInstall,     MSG_INSTALL_SHORT,     MSG_INSTALL_LONG },
    { TEXT("listclass"),    cmdListClass,   MSG_LISTCLASS_SHORT,   MSG_LISTCLASS_LONG },
    { TEXT("reboot"),       cmdReboot,      MSG_REBOOT_SHORT,      MSG_REBOOT_LONG },
    { TEXT("remove"),       cmdRemove,      MSG_REMOVE_SHORT,      MSG_REMOVE_LONG },
    { TEXT("rescan"),       cmdRescan,      MSG_RESCAN_SHORT,      MSG_RESCAN_LONG },
    { TEXT("resources"),    cmdResources,   MSG_RESOURCES_SHORT,   MSG_RESOURCES_LONG },
    { TEXT("restart"),      cmdRestart,     MSG_RESTART_SHORT,     MSG_RESTART_LONG },
    { TEXT("sethwid"),      cmdSetHwid,     MSG_SETHWID_SHORT,     MSG_SETHWID_LONG },
    { TEXT("stack"),        cmdStack,       MSG_STACK_SHORT,       MSG_STACK_LONG },
    { TEXT("status"),       cmdStatus,      MSG_STATUS_SHORT,      MSG_STATUS_LONG },
    { TEXT("update"),       cmdUpdate,      MSG_UPDATE_SHORT,      MSG_UPDATE_LONG },
    { TEXT("updateni"),     cmdUpdateNI,    MSG_UPDATENI_SHORT,    MSG_UPDATENI_LONG },
    { TEXT("?"),            cmdHelp,        0,                     0 },
    { NULL,NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon\rc_ids.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rc_ids.h

Abstract:

    Header for devcon resources

@@BEGIN_DDKSPLIT
Author:

    Jamie Hunter 11/30/2000

@@END_DDKSPLIT
--*/

#define IDS_ENABLED         3000
#define IDS_ENABLED_REBOOT  3001
#define IDS_ENABLE_FAILED   3002
#define IDS_DISABLED        3003
#define IDS_DISABLED_REBOOT 3004
#define IDS_DISABLE_FAILED  3005
#define IDS_RESTARTED       3006
#define IDS_REQUIRES_REBOOT 3007
#define IDS_RESTART_FAILED  3008
#define IDS_REMOVED         3009
#define IDS_REMOVED_REBOOT  3010
#define IDS_REMOVE_FAILED   3011
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon\devcon.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devcon.h

Abstract:

    Device Console header

@@BEGIN_DDKSPLIT
Author:

    Jamie Hunter (JamieHun) Nov-30-2000

Revision History:

@@END_DDKSPLIT
--*/

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <regstr.h>
#include <cfgmgr32.h>
#include <string.h>
#include <malloc.h>
#include <newdev.h>

#include "msg.h"
#include "rc_ids.h"

typedef int (*DispatchFunc)(LPCTSTR BaseName,LPCTSTR Machine,int argc,LPTSTR argv[]);
typedef int (*CallbackFunc)(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Index,LPVOID Context);

typedef struct {
    LPCTSTR         cmd;
    DispatchFunc    func;
    DWORD           shortHelp;
    DWORD           longHelp;
} DispatchEntry;

extern DispatchEntry DispatchTable[];

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

#define INSTANCEID_PREFIX_CHAR TEXT('@') // character used to prefix instance ID's
#define CLASS_PREFIX_CHAR      TEXT('=') // character used to prefix class name
#define WILD_CHAR              TEXT('*') // wild character
#define QUOTE_PREFIX_CHAR      TEXT('\'') // prefix character to ignore wild characters
#define SPLIT_COMMAND_SEP      TEXT(":=") // whole word, indicates end of id's

void FormatToStream(FILE * stream,DWORD fmt,...);
void Padding(int pad);
bool SplitCommandLine(int & argc,LPTSTR * & argv,int & argc_right,LPTSTR * & argv_right);
int EnumerateDevices(LPCTSTR BaseName,LPCTSTR Machine,DWORD Flags,int argc,LPTSTR argv[],CallbackFunc Callback,LPVOID Context);
LPTSTR GetDeviceStringProperty(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Prop);
LPTSTR GetDeviceDescription(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
LPTSTR * GetDevMultiSz(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Prop);
LPTSTR * GetRegMultiSz(HKEY hKey,LPCTSTR Val);
LPTSTR * GetMultiSzIndexArray(LPTSTR MultiSz);
void DelMultiSz(LPTSTR * Array);
LPTSTR * CopyMultiSz(LPTSTR * Array);

BOOL DumpArray(int pad,LPTSTR * Array);
BOOL DumpDevice(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceClass(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceDescr(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceStatus(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceResources(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceDriverFiles(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceDriverNodes(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceHwIds(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceWithInfo(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,LPCTSTR Info);
BOOL DumpDeviceStack(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL Reboot();


//
// UpdateDriverForPlugAndPlayDevices
//
typedef BOOL (WINAPI *UpdateDriverForPlugAndPlayDevicesProto)(HWND hwndParent,
                                                         LPCTSTR HardwareId,
                                                         LPCTSTR FullInfPath,
                                                         DWORD InstallFlags,
                                                         PBOOL bRebootRequired OPTIONAL
                                                         );
typedef BOOL (WINAPI *SetupSetNonInteractiveModeProto)(IN BOOL NonInteractiveFlag
                                                      );


#ifdef _UNICODE
#define UPDATEDRIVERFORPLUGANDPLAYDEVICES "UpdateDriverForPlugAndPlayDevicesW"
#else
#define UPDATEDRIVERFORPLUGANDPLAYDEVICES "UpdateDriverForPlugAndPlayDevicesA"
#endif
#define SETUPSETNONINTERACTIVEMODE "SetupSetNonInteractiveMode"


//
// exit codes
//
#define EXIT_OK      (0)
#define EXIT_REBOOT  (1)
#define EXIT_FAIL    (2)
#define EXIT_USAGE   (3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon\devcon.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devcon.cpp

Abstract:

    Device Console
    command-line interface for managing devices

@@BEGIN_DDKSPLIT
Author:

    Jamie Hunter (JamieHun) Nov-30-2000

Revision History:

@@END_DDKSPLIT
--*/

#include "devcon.h"

struct IdEntry {
    LPCTSTR String;     // string looking for
    LPCTSTR Wild;       // first wild character if any
    BOOL    InstanceId;
};

void FormatToStream(FILE * stream,DWORD fmt,...)
/*++

Routine Description:

    Format text to stream using a particular msg-id fmt
    Used for displaying localizable messages

Arguments:

    stream              - file stream to output to, stdout or stderr
    fmt                 - message id
    ...                 - parameters %1...

Return Value:

    none

--*/
{
    va_list arglist;
    LPTSTR locbuffer = NULL;
    DWORD count;

    va_start(arglist, fmt);
    count = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ALLOCATE_BUFFER,
                          NULL,
                          fmt,
                          0,              // LANGID
                          (LPTSTR) &locbuffer,
                          0,              // minimum size of buffer
                          &arglist);

    if(locbuffer) {
        if(count) {
            int c;
            int back = 0;
            //
            // strip any trailing "\r\n"s and replace by a single "\n"
            //
            while(((c = *CharPrev(locbuffer,locbuffer+count)) == TEXT('\r')) ||
                  (c == TEXT('\n'))) {
                count--;
                back++;
            }
            if(back) {
                locbuffer[count++] = TEXT('\n');
                locbuffer[count] = TEXT('\0');
            }
            //
            // now write to apropriate stream
            //
            _fputts(locbuffer,stream);
        }
        LocalFree(locbuffer);
    }
}

void Padding(int pad)
/*++

Routine Description:

    Insert padding into line before text

Arguments:

    pad - number of padding tabs to insert

Return Value:

    none

--*/
{
    int c;

    for(c=0;c<pad;c++) {
        fputs("    ",stdout);
    }
}


void Usage(LPCTSTR BaseName)
/*++

Routine Description:

    Display simple usage text

Arguments:

    BaseName            - name of executable

Return Value:

    none

--*/
{
    FormatToStream(stderr,MSG_USAGE,BaseName);
}

void CommandUsage(LPCTSTR BaseName,LPCTSTR Cmd)
/*++

Routine Description:

    Invalid command usage
    Display how to get help on command

Arguments:

    BaseName            - name of executable

Return Value:

    none

--*/
{
    FormatToStream(stderr,MSG_COMMAND_USAGE,BaseName,Cmd);
}

void Failure(LPCTSTR BaseName,LPCTSTR Cmd)
/*++

Routine Description:

    Display simple error text for general failure

Arguments:

    BaseName            - name of executable

Return Value:

    none

--*/
{
    FormatToStream(stderr,MSG_FAILURE,BaseName,Cmd);
}

BOOL Reboot()
/*++

Routine Description:

    Attempt to reboot computer

Arguments:

    none

Return Value:

    TRUE if API suceeded

--*/
{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    //
    // we need to "turn on" reboot privilege
    // if any of this fails, try reboot anyway
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        goto final;
    }

    if(!LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&Luid)) {
        CloseHandle(Token);
        goto final;
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

final:

    //
    // attempt reboot - inform system that this is planned hardware install
    //
    return ExitWindowsEx(EWX_REBOOT, REASON_PLANNED_FLAG|REASON_HWINSTALL);
}

LPTSTR GetDeviceStringProperty(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Prop)
/*++

Routine Description:

    Return a string property for a device, otherwise NULL

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )
    Prop     - string property to obtain

Return Value:

    string containing description

--*/
{
    LPTSTR buffer;
    DWORD size;
    DWORD reqSize;
    DWORD dataType;
    DWORD szChars;

    size = 1024; // initial guess
    buffer = new TCHAR[(size/sizeof(TCHAR))+1];
    if(!buffer) {
        return NULL;
    }
    while(!SetupDiGetDeviceRegistryProperty(Devs,DevInfo,Prop,&dataType,(LPBYTE)buffer,size,&reqSize)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto failed;
        }
        if(dataType != REG_SZ) {
            goto failed;
        }
        size = reqSize;
        delete [] buffer;
        buffer = new TCHAR[(size/sizeof(TCHAR))+1];
        if(!buffer) {
            goto failed;
        }
    }
    szChars = reqSize/sizeof(TCHAR);
    buffer[szChars] = TEXT('\0');
    return buffer;

failed:
    if(buffer) {
        delete [] buffer;
    }
    return NULL;
}

LPTSTR GetDeviceDescription(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Return a string containing a description of the device, otherwise NULL
    Always try friendly name first

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    string containing description

--*/
{
    LPTSTR desc;
    desc = GetDeviceStringProperty(Devs,DevInfo,SPDRP_FRIENDLYNAME);
    if(!desc) {
        desc = GetDeviceStringProperty(Devs,DevInfo,SPDRP_DEVICEDESC);
    }
    return desc;
}

IdEntry GetIdType(LPCTSTR Id)
/*++

Routine Description:

    Determine if this is instance id or hardware id and if there's any wildcards
    instance ID is prefixed by '@'
    wildcards are '*'


Arguments:

    Id - ptr to string to check

Return Value:

    IdEntry

--*/
{
    IdEntry Entry;

    Entry.InstanceId = FALSE;
    Entry.Wild = NULL;
    Entry.String = Id;

    if(Entry.String[0] == INSTANCEID_PREFIX_CHAR) {
        Entry.InstanceId = TRUE;
        Entry.String = CharNext(Entry.String);
    }
    if(Entry.String[0] == QUOTE_PREFIX_CHAR) {
        //
        // prefix to treat rest of string literally
        //
        Entry.String = CharNext(Entry.String);
    } else {
        //
        // see if any wild characters exist
        //
        Entry.Wild = _tcschr(Entry.String,WILD_CHAR);
    }
    return Entry;
}

LPTSTR * GetMultiSzIndexArray(LPTSTR MultiSz)
/*++

Routine Description:

    Get an index array pointing to the MultiSz passed in

Arguments:

    MultiSz - well formed multi-sz string

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR scan;
    LPTSTR * array;
    int elements;

    for(scan = MultiSz, elements = 0; scan[0] ;elements++) {
        scan += lstrlen(scan)+1;
    }
    array = new LPTSTR[elements+2];
    if(!array) {
        return NULL;
    }
    array[0] = MultiSz;
    array++;
    if(elements) {
        for(scan = MultiSz, elements = 0; scan[0]; elements++) {
            array[elements] = scan;
            scan += lstrlen(scan)+1;
        }
    }
    array[elements] = NULL;
    return array;
}

LPTSTR * CopyMultiSz(LPTSTR * Array)
/*++

Routine Description:

    Creates a new array from old
    old array need not have been allocated by GetMultiSzIndexArray

Arguments:

    Array - array of strings, last entry is NULL

Return Value:

    MultiSz array allocated by GetMultiSzIndexArray

--*/
{
    LPTSTR multiSz = NULL;
    int len = 0;
    int c;
    if(Array) {
        for(c=0;Array[c];c++) {
            len+=lstrlen(Array[c])+1;
        }
    }
    len+=1; // final Null
    multiSz = new TCHAR[len];
    if(!multiSz) {
        return NULL;
    }
    len = 0;
    if(Array) {
        for(c=0;Array[c];c++) {
            lstrcpy(multiSz+len,Array[c]);
            len+=lstrlen(multiSz+len)+1;
        }
    }
    multiSz[len] = TEXT('\0');
    LPTSTR * pRes = GetMultiSzIndexArray(multiSz);
    if(pRes) {
        return pRes;
    }
    delete [] multiSz;
    return NULL;
}

void DelMultiSz(LPTSTR * Array)
/*++

Routine Description:

    Deletes the string array allocated by GetDevMultiSz/GetRegMultiSz/GetMultiSzIndexArray

Arguments:

    Array - pointer returned by GetMultiSzIndexArray

Return Value:

    None

--*/
{
    if(Array) {
        Array--;
        if(Array[0]) {
            delete [] Array[0];
        }
        delete [] Array;
    }
}

LPTSTR * GetDevMultiSz(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Prop)
/*++

Routine Description:

    Get a multi-sz device property
    and return as an array of strings

Arguments:

    Devs    - HDEVINFO containing DevInfo
    DevInfo - Specific device
    Prop    - SPDRP_HARDWAREID or SPDRP_COMPATIBLEIDS

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR buffer;
    DWORD size;
    DWORD reqSize;
    DWORD dataType;
    LPTSTR * array;
    DWORD szChars;

    size = 8192; // initial guess, nothing magic about this
    buffer = new TCHAR[(size/sizeof(TCHAR))+2];
    if(!buffer) {
        return NULL;
    }
    while(!SetupDiGetDeviceRegistryProperty(Devs,DevInfo,Prop,&dataType,(LPBYTE)buffer,size,&reqSize)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto failed;
        }
        if(dataType != REG_MULTI_SZ) {
            goto failed;
        }
        size = reqSize;
        delete [] buffer;
        buffer = new TCHAR[(size/sizeof(TCHAR))+2];
        if(!buffer) {
            goto failed;
        }
    }
    szChars = reqSize/sizeof(TCHAR);
    buffer[szChars] = TEXT('\0');
    buffer[szChars+1] = TEXT('\0');
    array = GetMultiSzIndexArray(buffer);
    if(array) {
        return array;
    }

failed:
    if(buffer) {
        delete [] buffer;
    }
    return NULL;
}

LPTSTR * GetRegMultiSz(HKEY hKey,LPCTSTR Val)
/*++

Routine Description:

    Get a multi-sz from registry
    and return as an array of strings

Arguments:

    hKey    - Registry Key
    Val     - Value to query

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR buffer;
    DWORD size;
    DWORD reqSize;
    DWORD dataType;
    LPTSTR * array;
    DWORD szChars;
    LONG regErr;

    size = 8192; // initial guess, nothing magic about this
    buffer = new TCHAR[(size/sizeof(TCHAR))+2];
    if(!buffer) {
        return NULL;
    }
    reqSize = size;
    while((regErr = RegQueryValueEx(hKey,Val,NULL,&dataType,(PBYTE)buffer,&reqSize) != NO_ERROR)) {
        if(GetLastError() != ERROR_MORE_DATA) {
            goto failed;
        }
        if(dataType != REG_MULTI_SZ) {
            goto failed;
        }
        size = reqSize;
        delete [] buffer;
        buffer = new TCHAR[(size/sizeof(TCHAR))+2];
        if(!buffer) {
            goto failed;
        }
    }
    szChars = reqSize/sizeof(TCHAR);
    buffer[szChars] = TEXT('\0');
    buffer[szChars+1] = TEXT('\0');

    array = GetMultiSzIndexArray(buffer);
    if(array) {
        return array;
    }

failed:
    if(buffer) {
        delete [] buffer;
    }
    return NULL;
}

BOOL WildCardMatch(LPCTSTR Item,const IdEntry & MatchEntry)
/*++

Routine Description:

    Compare a single item against wildcard
    I'm sure there's better ways of implementing this
    Other than a command-line management tools
    it's a bad idea to use wildcards as it implies
    assumptions about the hardware/instance ID
    eg, it might be tempting to enumerate root\* to
    find all root devices, however there is a CfgMgr
    API to query status and determine if a device is
    root enumerated, which doesn't rely on implementation
    details.

Arguments:

    Item - item to find match for eg a\abcd\c
    MatchEntry - eg *\*bc*\*

Return Value:

    TRUE if any match, otherwise FALSE

--*/
{
    LPCTSTR scanItem;
    LPCTSTR wildMark;
    LPCTSTR nextWild;
    size_t matchlen;

    //
    // before attempting anything else
    // try and compare everything up to first wild
    //
    if(!MatchEntry.Wild) {
        return _tcsicmp(Item,MatchEntry.String) ? FALSE : TRUE;
    }
    if(_tcsnicmp(Item,MatchEntry.String,MatchEntry.Wild-MatchEntry.String) != 0) {
        return FALSE;
    }
    wildMark = MatchEntry.Wild;
    scanItem = Item + (MatchEntry.Wild-MatchEntry.String);

    for(;wildMark[0];) {
        //
        // if we get here, we're either at or past a wildcard
        //
        if(wildMark[0] == WILD_CHAR) {
            //
            // so skip wild chars
            //
            wildMark = CharNext(wildMark);
            continue;
        }
        //
        // find next wild-card
        //
        nextWild = _tcschr(wildMark,WILD_CHAR);
        if(nextWild) {
            //
            // substring
            //
            matchlen = nextWild-wildMark;
        } else {
            //
            // last portion of match
            //
            size_t scanlen = lstrlen(scanItem);
            matchlen = lstrlen(wildMark);
            if(scanlen < matchlen) {
                return FALSE;
            }
            return _tcsicmp(scanItem+scanlen-matchlen,wildMark) ? FALSE : TRUE;
        }
        if(_istalpha(wildMark[0])) {
            //
            // scan for either lower or uppercase version of first character
            //
            TCHAR u = _totupper(wildMark[0]);
            TCHAR l = _totlower(wildMark[0]);
            while(scanItem[0] && scanItem[0]!=u && scanItem[0]!=l) {
                scanItem = CharNext(scanItem);
            }
            if(!scanItem[0]) {
                //
                // ran out of string
                //
                return FALSE;
            }
        } else {
            //
            // scan for first character (no case)
            //
            scanItem = _tcschr(scanItem,wildMark[0]);
            if(!scanItem) {
                //
                // ran out of string
                //
                return FALSE;
            }
        }
        //
        // try and match the sub-string at wildMark against scanItem
        //
        if(_tcsnicmp(scanItem,wildMark,matchlen)!=0) {
            //
            // nope, try again
            //
            scanItem = CharNext(scanItem);
            continue;
        }
        //
        // substring matched
        //
        scanItem += matchlen;
        wildMark += matchlen;
    }
    return (wildMark[0] ? FALSE : TRUE);
}

BOOL WildCompareHwIds(LPTSTR * Array,const IdEntry & MatchEntry)
/*++

Routine Description:

    Compares all strings in Array against Id
    Use WildCardMatch to do real compare

Arguments:

    Array - pointer returned by GetDevMultiSz
    MatchEntry - string to compare against

Return Value:

    TRUE if any match, otherwise FALSE

--*/
{
    if(Array) {
        while(Array[0]) {
            if(WildCardMatch(Array[0],MatchEntry)) {
                return TRUE;
            }
            Array++;
        }
    }
    return FALSE;
}

bool SplitCommandLine(int & argc,LPTSTR * & argv,int & argc_right,LPTSTR * & argv_right)
/*++

Routine Description:

    Splits a command line into left and right of :=
    this is used for some of the more complex commands

Arguments:

    argc/argv - in/out
                - in, specifies the existing argc/argv
                - out, specifies the argc/argv to left of :=
    arc_right/argv_right - out
                - specifies the argc/argv to right of :=

Return Value:

    true - ":=" appears in line, false otherwise

--*/
{
    int i;
    for(i = 0;i<argc;i++) {
        if(_tcsicmp(argv[i],SPLIT_COMMAND_SEP)==0) {
            argc_right = argc-(i+1);
            argv_right = argv+(i+1);
            argc = i;
            return true;
        }
    }
    argc_right = 0;
    argv_right = argv+argc;
    return false;
}

int EnumerateDevices(LPCTSTR BaseName,LPCTSTR Machine,DWORD Flags,int argc,LPTSTR argv[],CallbackFunc Callback,LPVOID Context)
/*++

Routine Description:

    Generic enumerator for devices that will be passed the following arguments:
    <id> [<id>...]
    =<class> [<id>...]
    where <id> can either be @instance-id, or hardware-id and may contain wildcards
    <class> is a class name

Arguments:

    BaseName - name of executable
    Machine  - name of machine to enumerate
    Flags    - extra enumeration flags (eg DIGCF_PRESENT)
    argc/argv - remaining arguments on command line
    Callback - function to call for each hit
    Context  - data to pass function for each hit

Return Value:

    EXIT_xxxx

--*/
{
    HDEVINFO devs = INVALID_HANDLE_VALUE;
    IdEntry * templ = NULL;
    DWORD err;
    int failcode = EXIT_FAIL;
    int retcode;
    int argIndex;
    DWORD devIndex;
    SP_DEVINFO_DATA devInfo;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
    BOOL doSearch = FALSE;
    BOOL match;
    BOOL all = FALSE;
    GUID cls;
    DWORD numClass = 0;
    int skip = 0;


    if(!argc) {
        return EXIT_USAGE;
    }

    templ = new IdEntry[argc];
    if(!templ) {
        goto final;
    }

    //
    // determine if a class is specified
    //
    if(argc>skip && argv[skip][0]==CLASS_PREFIX_CHAR && argv[skip][1]) {
        if(!SetupDiClassGuidsFromNameEx(argv[skip]+1,&cls,1,&numClass,Machine,NULL) &&
            GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto final;
        }
        if(!numClass) {
            failcode = EXIT_OK;
            goto final;
        }
        skip++;
    }
    if(argc>skip && argv[skip][0]==WILD_CHAR && !argv[skip][1]) {
        //
        // catch convinient case of specifying a single argument '*'
        //
        all = TRUE;
        skip++;
    } else if(argc<=skip) {
        //
        // at least one parameter, but no <id>'s
        //
        all = TRUE;
    }

    //
    // determine if any instance id's were specified
    //
    // note, if =<class> was specified with no id's
    // we'll mark it as not doSearch
    // but will go ahead and add them all
    //
    for(argIndex=skip;argIndex<argc;argIndex++) {
        templ[argIndex] = GetIdType(argv[argIndex]);
        if(templ[argIndex].Wild || !templ[argIndex].InstanceId) {
            //
            // anything other than simple InstanceId's require a search
            //
            doSearch = TRUE;
        }
    }
    if(doSearch || all) {
        //
        // add all id's to list
        // if there's a class, filter on specified class
        //
        devs = SetupDiGetClassDevsEx(numClass ? &cls : NULL,
                                     NULL,
                                     NULL,
                                     (numClass ? 0 : DIGCF_ALLCLASSES) | Flags,
                                     NULL,
                                     Machine,
                                     NULL);

    } else {
        //
        // blank list, we'll add instance id's by hand
        //
        devs = SetupDiCreateDeviceInfoListEx(numClass ? &cls : NULL,
                                             NULL,
                                             Machine,
                                             NULL);
    }
    if(devs == INVALID_HANDLE_VALUE) {
        goto final;
    }
    for(argIndex=skip;argIndex<argc;argIndex++) {
        //
        // add explicit instances to list (even if enumerated all,
        // this gets around DIGCF_PRESENT)
        // do this even if wildcards appear to be detected since they
        // might actually be part of the instance ID of a non-present device
        //
        if(templ[argIndex].InstanceId) {
            SetupDiOpenDeviceInfo(devs,templ[argIndex].String,NULL,0,NULL);
        }
    }

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(devs,&devInfoListDetail)) {
        goto final;
    }

    //
    // now enumerate them
    //
    if(all) {
        doSearch = FALSE;
    }

    devInfo.cbSize = sizeof(devInfo);
    for(devIndex=0;SetupDiEnumDeviceInfo(devs,devIndex,&devInfo);devIndex++) {

        if(doSearch) {
            for(argIndex=skip,match=FALSE;(argIndex<argc) && !match;argIndex++) {
                TCHAR devID[MAX_DEVICE_ID_LEN];
                LPTSTR *hwIds = NULL;
                LPTSTR *compatIds = NULL;
                //
                // determine instance ID
                //
                if(CM_Get_Device_ID_Ex(devInfo.DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS) {
                    devID[0] = TEXT('\0');
                }

                if(templ[argIndex].InstanceId) {
                    //
                    // match on the instance ID
                    //
                    if(WildCardMatch(devID,templ[argIndex])) {
                        match = TRUE;
                    }
                } else {
                    //
                    // determine hardware ID's
                    // and search for matches
                    //
                    hwIds = GetDevMultiSz(devs,&devInfo,SPDRP_HARDWAREID);
                    compatIds = GetDevMultiSz(devs,&devInfo,SPDRP_COMPATIBLEIDS);

                    if(WildCompareHwIds(hwIds,templ[argIndex]) ||
                        WildCompareHwIds(compatIds,templ[argIndex])) {
                        match = TRUE;
                    }
                }
                DelMultiSz(hwIds);
                DelMultiSz(compatIds);
            }
        } else {
            match = TRUE;
        }
        if(match) {
            retcode = Callback(devs,&devInfo,devIndex,Context);
            if(retcode) {
                failcode = retcode;
                goto final;
            }
        }
    }

    failcode = EXIT_OK;

final:
    if(templ) {
        delete [] templ;
    }
    if(devs != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(devs);
    }
    return failcode;

}

int
__cdecl
_tmain(int argc, LPTSTR argv[])
/*++

Routine Description:

    Main entry point
    interpret -m:<machine>
    and hand off execution to command

Arguments:

    argc/argv - parameters passed to executable

Return Value:

    EXIT_xxxx

--*/
{
    LPCTSTR cmd;
    LPCTSTR baseName;
    LPCTSTR machine = NULL;
    int dispIndex;
    int firstArg = 1;
    int retval = EXIT_USAGE;
    BOOL autoReboot = FALSE;

    //
    // syntax:
    //
    // [options] [-]command [<arg> [<arg>]]
    //
    // options:
    // -m:<machine>  - remote
    // -r            - auto reboot
    //
    baseName = _tcsrchr(argv[0],TEXT('\\'));
    if(!baseName) {
        baseName = argv[0];
    } else {
        baseName = CharNext(baseName);
    }
    while((argc > firstArg) && ((argv[firstArg][0] == TEXT('-')) || (argv[firstArg][0] == TEXT('/')))) {
        if((argv[firstArg][1]==TEXT('m')) || (argv[firstArg][1]==TEXT('M'))) {
            if((argv[firstArg][2]!=TEXT(':')) || (argv[firstArg][3]==TEXT('\0'))) {
                //
                // don't recognize this switch
                //
                break;
            }
            machine = argv[firstArg]+3;
        } else if((argv[firstArg][1]==TEXT('r')) || (argv[firstArg][1]==TEXT('R'))) {
            if((argv[firstArg][2]!=TEXT('\0')) ) {
                //
                // don't recognize this switch
                //
                break;
            } else {
                autoReboot = TRUE;
            }
        } else {
            //
            // don't recognize this switch
            //
            break;
        }
        firstArg++;
    }

    if((argc-firstArg) < 1) {
        //
        // after switches, must at least be command
        //
        Usage(baseName);
        return EXIT_USAGE;
    }
    cmd = argv[firstArg];
    if((cmd[0]==TEXT('-')) || (cmd[0]==TEXT('/'))) {
        //
        // command may begin '-' or '/'
        // eg, people might do devcon -help
        //
        cmd = CharNext(cmd);
    }
    firstArg++;
    for(dispIndex = 0;DispatchTable[dispIndex].cmd;dispIndex++) {
        if(_tcsicmp(cmd,DispatchTable[dispIndex].cmd)==0) {
            retval = DispatchTable[dispIndex].func(baseName,machine,argc-firstArg,argv+firstArg);
            switch(retval) {
                case EXIT_USAGE:
                    CommandUsage(baseName,DispatchTable[dispIndex].cmd);
                    break;
                case EXIT_REBOOT:
                    if(autoReboot) {
                        Reboot();
                    }
                    break;
                case EXIT_OK:
                    break;
                default:
                    Failure(baseName,DispatchTable[dispIndex].cmd);
                    break;
            }
            return retval;
        }
    }
    Usage(baseName);
    return EXIT_USAGE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon\dump.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    dump.cpp

Abstract:

    Device Console
    dump information out about a particular device

@@BEGIN_DDKSPLIT
Author:

    Jamie Hunter (JamieHun) Nov-30-2000

Revision History:

@@END_DDKSPLIT
--*/

#include "devcon.h"

BOOL DumpDeviceWithInfo(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,LPCTSTR Info)
/*++

Routine Description:

    Write device instance & info to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    TCHAR devID[MAX_DEVICE_ID_LEN];
    LPTSTR desc;
    BOOL b = TRUE;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfo->DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        lstrcpy(devID,TEXT("?"));
        b = FALSE;
    }

    if(Info) {
        _tprintf(TEXT("%-60s: %s\n"),devID,Info);
    } else {
        _tprintf(TEXT("%s\n"),devID);
    }
    return b;
}

BOOL DumpDevice(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device instance & description to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR desc;
    BOOL b;

    desc = GetDeviceDescription(Devs,DevInfo);
    b = DumpDeviceWithInfo(Devs,DevInfo,desc);
    if(desc) {
        delete [] desc;
    }
    return b;
}

BOOL DumpDeviceDescr(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device description to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR desc;
    BOOL b;

    desc = GetDeviceDescription(Devs,DevInfo);
    if(!desc) {
        return FALSE;
    }
    Padding(1);
    FormatToStream(stdout,MSG_DUMP_DESCRIPTION,desc);
    delete [] desc;
    return TRUE;
}

BOOL DumpDeviceClass(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device class information to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR cls;
    LPTSTR guid;

    Padding(1);
    cls = GetDeviceStringProperty(Devs,DevInfo,SPDRP_CLASS);
    guid = GetDeviceStringProperty(Devs,DevInfo,SPDRP_CLASSGUID);
    if(!cls && !guid) {
        FormatToStream(stdout,
                        MSG_DUMP_NOSETUPCLASS
                        );
    } else {
        FormatToStream(stdout,
                        MSG_DUMP_SETUPCLASS,
                        guid ? guid : TEXT("{}"),
                        cls ? cls : TEXT("(?)")
                        );
    }

    if(cls) {
        delete [] cls;
    }
    if(guid) {
        delete [] guid;
    }

    return TRUE;
}

BOOL DumpDeviceStatus(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device status to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
    ULONG status = 0;
    ULONG problem = 0;
    BOOL hasInfo = FALSE;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_DevNode_Status_Ex(&status,&problem,DevInfo->DevInst,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        return FALSE;
    }
    //
    // handle off the status/problem codes
    //
    if((status & DN_HAS_PROBLEM) && problem == CM_PROB_DISABLED) {
        hasInfo = TRUE;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DISABLED);
        return TRUE;
    }
    if(status & DN_HAS_PROBLEM) {
        hasInfo = TRUE;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_PROBLEM,problem);
    }
    if(status & DN_PRIVATE_PROBLEM) {
        hasInfo = TRUE;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_PRIVATE_PROBLEM);
    }
    if(status & DN_STARTED) {
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_STARTED);
    } else if (!hasInfo) {
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_NOTSTARTED);
    }
    return TRUE;
}

BOOL DumpDeviceResourcesOfType(DEVINST DevInst,HMACHINE MachineHandle,LOG_CONF Config,RESOURCEID ReqResId)
{
    RES_DES prevResDes = (RES_DES)Config;
    RES_DES resDes = 0;
    RESOURCEID resId = ReqResId;
    ULONG dataSize;
    PBYTE resDesData;
    while(CM_Get_Next_Res_Des_Ex(&resDes,prevResDes,ReqResId,&resId,0,MachineHandle)==CR_SUCCESS) {
        if(prevResDes != Config) {
            CM_Free_Res_Des_Handle(prevResDes);
        }
        prevResDes = resDes;
        if(CM_Get_Res_Des_Data_Size_Ex(&dataSize,resDes,0,MachineHandle)!=CR_SUCCESS) {
            continue;
        }
        resDesData = new BYTE[dataSize];
        if(!resDesData) {
            continue;
        }
        if(CM_Get_Res_Des_Data_Ex(resDes,resDesData,dataSize,0,MachineHandle)!=CR_SUCCESS) {
            delete [] resDesData;
            continue;
        }
        switch(resId) {
            case ResType_Mem: {

                PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)resDesData;
                if(pMemData->MEM_Header.MD_Alloc_End-pMemData->MEM_Header.MD_Alloc_Base+1) {
                    Padding(2);
                    _tprintf(TEXT("MEM : %08I64x-%08I64x\n"),pMemData->MEM_Header.MD_Alloc_Base,pMemData->MEM_Header.MD_Alloc_End);
                }
                break;
            }

            case ResType_IO: {

                PIO_RESOURCE   pIoData = (PIO_RESOURCE)resDesData;
                if(pIoData->IO_Header.IOD_Alloc_End-pIoData->IO_Header.IOD_Alloc_Base+1) {
                    Padding(2);
                    _tprintf(TEXT("IO  : %04I64x-%04I64x\n"),pIoData->IO_Header.IOD_Alloc_Base,pIoData->IO_Header.IOD_Alloc_End);
                }
                break;
            }

            case ResType_DMA: {

                PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)resDesData;
                Padding(2);
                _tprintf(TEXT("DMA : %u\n"),pDmaData->DMA_Header.DD_Alloc_Chan);
                break;
            }

            case ResType_IRQ: {

                PIRQ_RESOURCE  pIrqData = (PIRQ_RESOURCE)resDesData;

                Padding(2);
                _tprintf(TEXT("IRQ : %u\n"),pIrqData->IRQ_Header.IRQD_Alloc_Num);
                break;
            }
        }
        delete [] resDesData;
    }
    if(prevResDes != Config) {
        CM_Free_Res_Des_Handle(prevResDes);
    }
    return TRUE;
}

BOOL DumpDeviceResources(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Dump Resources to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
    ULONG status = 0;
    ULONG problem = 0;
    LOG_CONF config = 0;
    BOOL haveConfig = FALSE;

    //
    // see what state the device is in
    //
    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_DevNode_Status_Ex(&status,&problem,DevInfo->DevInst,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        return FALSE;
    }

    //
    // see if the device is running and what resources it might be using
    //
    if(!(status & DN_HAS_PROBLEM)) {
        //
        // If this device is running, does this devinst have a ALLOC log config?
        //
        if (CM_Get_First_Log_Conf_Ex(&config,
                                     DevInfo->DevInst,
                                     ALLOC_LOG_CONF,
                                     devInfoListDetail.RemoteMachineHandle) == CR_SUCCESS) {
            haveConfig = TRUE;
        }
    }
    if(!haveConfig) {
        //
        // If no config so far, does it have a FORCED log config?
        // (note that technically these resources might be used by another device
        // but is useful info to show)
        //
        if (CM_Get_First_Log_Conf_Ex(&config,
                                     DevInfo->DevInst,
                                     FORCED_LOG_CONF,
                                     devInfoListDetail.RemoteMachineHandle) == CR_SUCCESS) {
            haveConfig = TRUE;
        }
    }

    if(!haveConfig) {
        //
        // if there's a hardware-disabled problem, boot-config isn't valid
        // otherwise use this if we don't have anything else
        //
        if(!(status & DN_HAS_PROBLEM) || (problem != CM_PROB_HARDWARE_DISABLED)) {
            //
            // Does it have a BOOT log config?
            //
            if (CM_Get_First_Log_Conf_Ex(&config,
                                         DevInfo->DevInst,
                                         BOOT_LOG_CONF,
                                         devInfoListDetail.RemoteMachineHandle) == CR_SUCCESS) {
                haveConfig = TRUE;
            }
        }
    }

    if(!haveConfig) {
        //
        // if we don't have any configuration, display an apropriate message
        //
        Padding(1);
        FormatToStream(stdout,(status & DN_STARTED) ? MSG_DUMP_NO_RESOURCES : MSG_DUMP_NO_RESERVED_RESOURCES );
        return TRUE;
    }
    Padding(1);
    FormatToStream(stdout,(status & DN_STARTED) ? MSG_DUMP_RESOURCES : MSG_DUMP_RESERVED_RESOURCES );

    //
    // dump resources
    //
    DumpDeviceResourcesOfType(DevInfo->DevInst,devInfoListDetail.RemoteMachineHandle,config,ResType_Mem);
    DumpDeviceResourcesOfType(DevInfo->DevInst,devInfoListDetail.RemoteMachineHandle,config,ResType_IO);
    DumpDeviceResourcesOfType(DevInfo->DevInst,devInfoListDetail.RemoteMachineHandle,config,ResType_DMA);
    DumpDeviceResourcesOfType(DevInfo->DevInst,devInfoListDetail.RemoteMachineHandle,config,ResType_IRQ);

    //
    // release handle
    //
    CM_Free_Log_Conf_Handle(config);

    return TRUE;
}


UINT DumpDeviceDriversCallback(PVOID Context,UINT Notification,UINT_PTR Param1,UINT_PTR Param2)
/*++

Routine Description:

    if Context provided, Simply count
    otherwise dump files indented 2

Arguments:

    Context      - DWORD Count
    Notification - SPFILENOTIFY_QUEUESCAN
    Param1       - scan

Return Value:

    none

--*/
{
    LPDWORD count = (LPDWORD)Context;
    LPTSTR file = (LPTSTR)Param1;
    if(count) {
        count[0]++;
    } else {
        Padding(2);
        _tprintf(TEXT("%s\n"),file);
    }

    return NO_ERROR;
}

BOOL FindCurrentDriver(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,PSP_DRVINFO_DATA DriverInfoData)
/*++

Routine Description:

    Find the driver that is associated with the current device
    We can do this either the quick way (available in WinXP)
    or the long way that works in Win2k.

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if we managed to determine and select current driver

--*/
{
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    WCHAR SectionName[LINE_LEN];
    WCHAR DrvDescription[LINE_LEN];
    WCHAR MfgName[LINE_LEN];
    WCHAR ProviderName[LINE_LEN];
    HKEY hKey = NULL;
    DWORD RegDataLength;
    DWORD RegDataType;
    DWORD c;
    BOOL match = FALSE;
    long regerr;

    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }

#ifdef DI_FLAGSEX_INSTALLEDDRIVER
    //
    // Set the flags that tell SetupDiBuildDriverInfoList to just put the
    // currently installed driver node in the list, and that it should allow
    // excluded drivers. This flag introduced in WinXP.
    //
    deviceInstallParams.FlagsEx |= (DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

    if(SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        //
        // we were able to specify this flag, so proceed the easy way
        // we should get a list of no more than 1 driver
        //
        if(!SetupDiBuildDriverInfoList(Devs, DevInfo, SPDIT_CLASSDRIVER)) {
            return FALSE;
        }
        if (!SetupDiEnumDriverInfo(Devs, DevInfo, SPDIT_CLASSDRIVER,
                                   0, DriverInfoData)) {
            return FALSE;
        }
        //
        // we've selected the current driver
        //
        return TRUE;
    }
    deviceInstallParams.FlagsEx &= ~(DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);
#endif
    //
    // The following method works in Win2k, but it's slow and painful.
    //
    // First, get driver key - if it doesn't exist, no driver
    //
    hKey = SetupDiOpenDevRegKey(Devs,
                                DevInfo,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_READ
                               );

    if(hKey == INVALID_HANDLE_VALUE) {
        //
        // no such value exists, so there can't be an associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // obtain path of INF - we'll do a search on this specific INF
    //
    RegDataLength = sizeof(deviceInstallParams.DriverPath); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_INFPATH,
                             NULL,
                             &RegDataType,
                             (PBYTE)deviceInstallParams.DriverPath,
                             &RegDataLength
                             );

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so no associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // obtain name of Provider to fill into DriverInfoData
    //
    RegDataLength = sizeof(ProviderName); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_PROVIDER_NAME,
                             NULL,
                             &RegDataType,
                             (PBYTE)ProviderName,
                             &RegDataLength
                             );

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // obtain name of section - for final verification
    //
    RegDataLength = sizeof(SectionName); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_INFSECTION,
                             NULL,
                             &RegDataType,
                             (PBYTE)SectionName,
                             &RegDataLength
                             );

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // driver description (need not be same as device description)
    // - for final verification
    //
    RegDataLength = sizeof(DrvDescription); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_DRVDESC,
                             NULL,
                             &RegDataType,
                             (PBYTE)DrvDescription,
                             &RegDataLength
                             );

    RegCloseKey(hKey);

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        return FALSE;
    }

    //
    // Manufacturer (via SPDRP_MFG, don't access registry directly!)
    //

    if(!SetupDiGetDeviceRegistryProperty(Devs,
                                        DevInfo,
                                        SPDRP_MFG,
                                        NULL,      // datatype is guaranteed to always be REG_SZ.
                                        (PBYTE)MfgName,
                                        sizeof(MfgName), // bytes!!!
                                        NULL)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        return FALSE;
    }

    //
    // now search for drivers listed in the INF
    //
    //
    deviceInstallParams.Flags |= DI_ENUMSINGLEINF;
    deviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

    if(!SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }
    if(!SetupDiBuildDriverInfoList(Devs, DevInfo, SPDIT_CLASSDRIVER)) {
        return FALSE;
    }

    //
    // find the entry in the INF that was used to install the driver for
    // this device
    //
    for(c=0;SetupDiEnumDriverInfo(Devs,DevInfo,SPDIT_CLASSDRIVER,c,DriverInfoData);c++) {
        if((_tcscmp(DriverInfoData->MfgName,MfgName)==0)
            &&(_tcscmp(DriverInfoData->ProviderName,ProviderName)==0)) {
            //
            // these two fields match, try more detailed info
            // to ensure we have the exact driver entry used
            //
            SP_DRVINFO_DETAIL_DATA detail;
            detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
            if(!SetupDiGetDriverInfoDetail(Devs,DevInfo,DriverInfoData,&detail,sizeof(detail),NULL)
                    && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
                continue;
            }
            if((_tcscmp(detail.SectionName,SectionName)==0) &&
                (_tcscmp(detail.DrvDescription,DrvDescription)==0)) {
                match = TRUE;
                break;
            }
        }
    }
    if(!match) {
        SetupDiDestroyDriverInfoList(Devs,DevInfo,SPDIT_CLASSDRIVER);
    }
    return match;
}

BOOL DumpDeviceDriverFiles(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Dump information about what files were installed for driver package
    <tab>Installed using OEM123.INF section [abc.NT]
    <tab><tab>file...

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    //
    // do this by 'searching' for the current driver
    // mimmicing a copy-only install to our own file queue
    // and then parsing that file queue
    //
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    SP_DRVINFO_DATA driverInfoData;
    SP_DRVINFO_DETAIL_DATA driverInfoDetail;
    HSPFILEQ queueHandle = INVALID_HANDLE_VALUE;
    DWORD count;
    DWORD scanResult;
    BOOL success = FALSE;

    ZeroMemory(&driverInfoData,sizeof(driverInfoData));
    driverInfoData.cbSize = sizeof(driverInfoData);

    if(!FindCurrentDriver(Devs,DevInfo,&driverInfoData)) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_DRIVER);
        return FALSE;
    }

    //
    // get useful driver information
    //
    driverInfoDetail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if(!SetupDiGetDriverInfoDetail(Devs,DevInfo,&driverInfoData,&driverInfoDetail,sizeof(SP_DRVINFO_DETAIL_DATA),NULL) &&
       GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        //
        // no information about driver or section
        //
        goto final;
    }
    if(!driverInfoDetail.InfFileName[0] || !driverInfoDetail.SectionName[0]) {
        goto final;
    }

    //
    // pretend to do the file-copy part of a driver install
    // to determine what files are used
    // the specified driver must be selected as the active driver
    //
    if(!SetupDiSetSelectedDriver(Devs, DevInfo, &driverInfoData)) {
        goto final;
    }

    //
    // create a file queue so we can look at this queue later
    //
    queueHandle = SetupOpenFileQueue();

    if ( queueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        goto final;
    }

    //
    // modify flags to indicate we're providing our own queue
    //
    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if ( !SetupDiGetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams) ) {
        goto final;
    }

    //
    // we want to add the files to the file queue, not install them!
    //
    deviceInstallParams.FileQueue = queueHandle;
    deviceInstallParams.Flags |= DI_NOVCP;

    if ( !SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams) ) {
        goto final;
    }

    //
    // now fill queue with files that are to be installed
    // this involves all class/co-installers
    //
    if ( !SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, Devs, DevInfo) ) {
        goto final;
    }

    //
    // we now have a list of delete/rename/copy files
    // iterate the copy queue twice - 1st time to get # of files
    // 2nd time to get files
    // (WinXP has API to get # of files, but we want this to work
    // on Win2k too)
    //

    count = 0;
    scanResult = 0;
    //
    // call once to count
    //
    SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACK,NULL,DumpDeviceDriversCallback,&count,&scanResult);
    Padding(1);
    FormatToStream(stdout, count ? MSG_DUMP_DRIVER_FILES : MSG_DUMP_NO_DRIVER_FILES, count, driverInfoDetail.InfFileName, driverInfoDetail.SectionName);
    //
    // call again to dump the files
    //
    SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACK,NULL,DumpDeviceDriversCallback,NULL,&scanResult);

    success = TRUE;

final:

    SetupDiDestroyDriverInfoList(Devs,DevInfo,SPDIT_CLASSDRIVER);

    if ( queueHandle != (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        SetupCloseFileQueue(queueHandle);
    }

    if(!success) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_DRIVER);
    }

    return success;

}

BOOL DumpArray(int pad,LPTSTR * Array)
/*++

Routine Description:

    Iterate array and dump entries to screen

Arguments:

    pad   - padding
    Array - array to dump

Return Value:

    none

--*/
{
    if(!Array || !Array[0]) {
        return FALSE;
    }
    while(Array[0]) {
        Padding(pad);
        _tprintf(TEXT("%s\n"),Array[0]);
        Array++;
    }
    return TRUE;
}

BOOL DumpDeviceHwIds(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device instance & description to stdout
    <tab>Hardware ID's
    <tab><tab>ID
    ...
    <tab>Compatible ID's
    <tab><tab>ID
    ...
    or
    <tab>No Hardware ID's for device

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    LPTSTR * hwIdArray = GetDevMultiSz(Devs,DevInfo,SPDRP_HARDWAREID);
    LPTSTR * compatIdArray = GetDevMultiSz(Devs,DevInfo,SPDRP_COMPATIBLEIDS);
    BOOL displayed = FALSE;

    if(hwIdArray && hwIdArray[0]) {
        displayed = TRUE;
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_HWIDS);
        DumpArray(2,hwIdArray);
    }
    if(compatIdArray && compatIdArray[0]) {
        displayed = TRUE;
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_COMPATIDS);
        DumpArray(2,compatIdArray);
    }
    if(!displayed) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_HWIDS);
    }

    DelMultiSz(hwIdArray);
    DelMultiSz(compatIdArray);

    return TRUE;
}

BOOL DumpDeviceDriverNodes(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device instance & description to stdout
    <tab>Installed using OEM123.INF section [abc.NT]
    <tab><tab>file...

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    BOOL success = FALSE;
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    SP_DRVINFO_DATA driverInfoData;
    SP_DRVINFO_DETAIL_DATA driverInfoDetail;
    SP_DRVINSTALL_PARAMS driverInstallParams;
    DWORD index;
    SYSTEMTIME SystemTime;
    ULARGE_INTEGER Version;
    TCHAR Buffer[MAX_PATH];

    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    ZeroMemory(&driverInfoData, sizeof(driverInfoData));

    driverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }

    //
    // Set the flags that tell SetupDiBuildDriverInfoList to allow excluded drivers.
    //
    deviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

    if(!SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }

    //
    // Now build a class driver list.
    //
    if(!SetupDiBuildDriverInfoList(Devs, DevInfo, SPDIT_COMPATDRIVER)) {
        goto final2;
    }

    //
    // Enumerate all of the drivernodes.
    //
    index = 0;
    while(SetupDiEnumDriverInfo(Devs, DevInfo, SPDIT_COMPATDRIVER,
                                index, &driverInfoData)) {

        success = TRUE;

        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_HEADER,index);

        //
        // get useful driver information
        //
        driverInfoDetail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if(SetupDiGetDriverInfoDetail(Devs,DevInfo,&driverInfoData,&driverInfoDetail,sizeof(SP_DRVINFO_DETAIL_DATA),NULL) ||
           GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_INF,driverInfoDetail.InfFileName);
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_SECTION,driverInfoDetail.SectionName);
        }

        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_DESCRIPTION,driverInfoData.Description);
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_MFGNAME,driverInfoData.MfgName);
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_PROVIDERNAME,driverInfoData.ProviderName);

        if (FileTimeToSystemTime(&driverInfoData.DriverDate, &SystemTime)) {
            if (GetDateFormat(LOCALE_USER_DEFAULT,
                              DATE_SHORTDATE,
                              &SystemTime,
                              NULL,
                              Buffer,
                              sizeof(Buffer)/sizeof(TCHAR)
                              ) != 0) {
                Padding(1);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_DRIVERDATE,Buffer);
            }
        }

        Version.QuadPart = driverInfoData.DriverVersion;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_DRIVERVERSION,
                       HIWORD(Version.HighPart),
                       LOWORD(Version.HighPart),
                       HIWORD(Version.LowPart),
                       LOWORD(Version.LowPart)
                       );

        driverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if(SetupDiGetDriverInstallParams(Devs,DevInfo,&driverInfoData,&driverInstallParams)) {
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_RANK,driverInstallParams.Rank);
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS,driverInstallParams.Flags);

            //
            // Interesting flags to dump
            //
            if (driverInstallParams.Flags & DNF_OLD_INET_DRIVER) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_OLD_INET_DRIVER);
            }
            if (driverInstallParams.Flags & DNF_BAD_DRIVER) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_BAD_DRIVER);
            }
#if defined(DNF_INF_IS_SIGNED)
            //
            // DNF_INF_IS_SIGNED is only available since WinXP
            //
            if (driverInstallParams.Flags & DNF_INF_IS_SIGNED) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_INF_IS_SIGNED);
            }
#endif
#if defined(DNF_OEM_F6_INF)
            //
            // DNF_OEM_F6_INF is only available since WinXP
            //
            if (driverInstallParams.Flags & DNF_OEM_F6_INF) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_OEM_F6_INF);
            }
#endif
#if defined(DNF_BASIC_DRIVER)
            //
            // DNF_BASIC_DRIVER is only available since WinXP
            //
            if (driverInstallParams.Flags & DNF_BASIC_DRIVER) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_BASIC_DRIVER);
            }
#endif
        }

        index++;
    }

    SetupDiDestroyDriverInfoList(Devs,DevInfo,SPDIT_COMPATDRIVER);

final2:

    if(!success) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_DRIVERNODES);
    }

    return success;

}

BOOL DumpDeviceStack(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write expected stack information to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR * filters;
    LPTSTR service;
    HKEY hClassKey = (HKEY)INVALID_HANDLE_VALUE;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    //
    // we need machine information
    //
    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) {
        return FALSE;
    }

    //
    // we need device setup class, we can use the GUID in DevInfo
    // note that this GUID is a snapshot, but works fine
    // if DevInfo isn't old
    //

    //
    // class upper/lower filters are in class registry
    //
    hClassKey = SetupDiOpenClassRegKeyEx(&DevInfo->ClassGuid,
                                         KEY_READ,
                                         DIOCR_INSTALLER,
                                         devInfoListDetail.RemoteMachineName[0] ? devInfoListDetail.RemoteMachineName : NULL,
                                         NULL);

    if(hClassKey != INVALID_HANDLE_VALUE) {
        //
        // dump upper class filters if available
        //
        filters = GetRegMultiSz(hClassKey,REGSTR_VAL_UPPERFILTERS);
        if(filters) {
            if(filters[0]) {
                Padding(1);
                FormatToStream(stdout,MSG_DUMP_DEVICESTACK_UPPERCLASSFILTERS);
                DumpArray(2,filters);
            }
            DelMultiSz(filters);
        }
    }
    filters = GetDevMultiSz(Devs,DevInfo,SPDRP_UPPERFILTERS);
    if(filters) {
        if(filters[0]) {
            //
            // dump upper device filters
            //
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DEVICESTACK_UPPERFILTERS);
            DumpArray(2,filters);
        }
        DelMultiSz(filters);
    }
    service = GetDeviceStringProperty(Devs,DevInfo,SPDRP_SERVICE);
    Padding(1);
    FormatToStream(stdout,MSG_DUMP_DEVICESTACK_SERVICE);
    if(service && service[0]) {
        //
        // dump service
        //
        Padding(2);
        _tprintf(TEXT("%s\n"),service);
    } else {
        //
        // dump the fact that there's no service
        //
        Padding(2);
        FormatToStream(stdout,MSG_DUMP_DEVICESTACK_NOSERVICE);
    }
    if(service) {
        delete [] service;
    }
    if(hClassKey != INVALID_HANDLE_VALUE) {
        filters = GetRegMultiSz(hClassKey,REGSTR_VAL_LOWERFILTERS);
        if(filters) {
            if(filters[0]) {
                //
                // lower class filters
                //
                Padding(1);
                FormatToStream(stdout,MSG_DUMP_DEVICESTACK_LOWERCLASSFILTERS);
                DumpArray(2,filters);
            }
            DelMultiSz(filters);
        }
        RegCloseKey(hClassKey);
    }
    filters = GetDevMultiSz(Devs,DevInfo,SPDRP_LOWERFILTERS);
    if(filters) {
        if(filters[0]) {
            //
            // lower device filters
            //
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DEVICESTACK_LOWERFILTERS);
            DumpArray(2,filters);
        }
        DelMultiSz(filters);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\devcon2.cpp ===
// DevCon2.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for DevCon2.idl by adding the following
//      files to the Outputs.
//          DevCon2_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f DevCon2ps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DevCon2.h"
#include "dlldatax.h"

#include "DevCon2_i.c"
#include "DeviceConsole.h"
#include "Devices.h"
#include "xStrings.h"
#include "SetupClasses.h"
#include "DeviceIcon.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CMyModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DeviceConsole, CDeviceConsole)
OBJECT_ENTRY(CLSID_Devices, CDevices)
OBJECT_ENTRY(CLSID_Strings, CStrings)
OBJECT_ENTRY(CLSID_SetupClasses, CSetupClasses)
OBJECT_ENTRY(CLSID_DeviceIcon, CDeviceIcon)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DEVCON2Lib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    //
    // DCOM support - App registration via IDR_DEVCON2
    //
    _Module.UpdateRegistryFromResource(IDR_DEVCON2, TRUE);
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    //
    // DCOM support - App cleanup via IDR_DEVCON2
    //
    _Module.UpdateRegistryFromResource(IDR_DEVCON2, FALSE);
    return _Module.UnregisterServer(TRUE);
}

//
// DCOM support, allow this DLL to also run as local server
// once the server is running, it needs to cleanup after a short period of time
//
const DWORD dwTimeOut = 5000; // time for server to be idle before shutting down

static void CALLBACK ModuleTimer(HWND /*hWnd*/,UINT /*uMsg*/,UINT_PTR /*idEvent*/,DWORD /*dwTime*/)
{
    _Module.CheckShutdown();
}

LONG CMyModule::Unlock()
{
    LONG l = CComModule::Unlock();
    //ATLTRACE("Unlock = %u\n",l);
    if (bServer && (l <= (punkFact ? 1 : 0)))
    {
        //
        // DCOM server
        // as soon as lock count reaches 1 (punkFact), timer is reset
        // if timer times out and lock count is still 1
        // then we can kill the server
        //
        SetTimer(NULL,0,dwTimeOut,ModuleTimer);
    }
    return l;
}

void CMyModule::KillServer()
{
    if(bServer) {
        //
        // make it a server no longer
        //
        CoRevokeClassObject(dwROC);
        bServer = FALSE;
    }
    if(punkFact) {
        punkFact->Release();
        punkFact = NULL;
    }
    if(m_nLockCnt != 0) {
        DebugBreak();
    }
}

void CMyModule::CheckShutdown()
{
    if(m_nLockCnt>(punkFact ? 1 : 0)) {
        //
        // module is still in use
        //
        return;
    }
    //
    // lock count stayed at zero for dwTimeOut ms
    //
    KillServer();
    PostMessage(NULL, WM_QUIT, 0, 0);
}

HRESULT CMyModule::InitServer(GUID & ClsId)
{
    HRESULT hr;

    hr = DllGetClassObject(ClsId, IID_IClassFactory, (LPVOID*)&punkFact);
    if(FAILED(hr)) {
        return hr;
    }
    hr = CoRegisterClassObject(ClsId, punkFact, CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE, &dwROC);
    if(FAILED(hr)) {
        punkFact->Release();
        punkFact = NULL;
        return hr;
    }
    bServer = true;

    return S_OK;
}

void WINAPI CreateLocalServerW(HWND /*hwnd*/, HINSTANCE /*hAppInstance*/, LPWSTR pszCmdLine, int /*nCmdShow*/)
{
    GUID ClsId;
    HRESULT hr;
    LPWSTR dup;
    LPWSTR p;
    size_t len;
    MSG msg;

    hr = CoInitialize(NULL);
    if(FAILED(hr)) {
        return;
    }

    //
    // pszCmdLine = the class GUID we want factory for
    //
    p = wcschr(pszCmdLine,'{');
    if(!p) {
        goto final;
    }
    pszCmdLine = p;
    p = wcschr(pszCmdLine,'}');
    if(!p) {
        goto final;
    }
    len = p-pszCmdLine+1;
    dup = new WCHAR[len+1];
    if(!dup) {
        goto final;
    }
    wcsncpy(dup,pszCmdLine,len+1);
    dup[len] = '\0';
    hr = CLSIDFromString(dup,&ClsId);
    delete [] dup;

    if(FAILED(hr)) {
        goto final;
    }
    hr = _Module.InitServer(ClsId);
    if(FAILED(hr)) {
        goto final;
    }

    //
    // now go into dispatch loop until we get a quit message
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    _Module.KillServer();

final:
    CoUninitialize();
}


#ifdef _M_IA64

//$WIN64: Don't know why _WndProcThunkProc isn't defined

extern "C" LRESULT CALLBACK _WndProcThunkProc(HWND, UINT, WPARAM, LPARAM )
{
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\device.cpp ===
// Device.cpp : Implementation of CDevice
#include "stdafx.h"
#include "DevCon2.h"
#include "Device.h"
#include "xStrings.h"
#include "Driver.h"
#include "Drivers.h"
#include "DrvSearchSet.h"
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////
// CDevice

CDevice::~CDevice()
{
    //
    // when this is destroyed, yank the entry out of HDEVINFO
    //
    if(DevInfoData.cbSize) {
        HDEVINFO hDevInfo = GetDevInfoSet();
        if(hDevInfo != INVALID_HANDLE_VALUE) {
            SetupDiDeleteDeviceInfo(hDevInfo,&DevInfoData);
        }
    }
}

HRESULT CDevice::Init(IDevInfoSet *pDevInfoSet, LPCWSTR pInstance,IDeviceConsole *pDevCon)
{
    //
    // init a new device (DeviceConsole/DevInfoSet are smart pointers)
    //
    DevInfoSet = pDevInfoSet;
    HDEVINFO hDevInfo = GetDevInfoSet();
    HRESULT hr;
    DWORD err;

    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }
    DeviceConsole = pDevCon;
    DevInfoData.cbSize = sizeof(DevInfoData);
    if(SetupDiOpenDeviceInfo(hDevInfo,pInstance,NULL,0,&DevInfoData)) {
        return S_OK;
    }
    err = GetLastError();
    hr = HRESULT_FROM_SETUPAPI(err);
    DevInfoData.cbSize = 0;
    return hr;
}

HRESULT CDevice::Init(IDevInfoSet *pDevInfoSet, PSP_DEVINFO_DATA pData,IDeviceConsole *pDevCon)
{
    //
    // init an existing device (DeviceConsole/DevInfoSet are smart pointers)
    //
    DevInfoSet = pDevInfoSet;
    DevInfoData = *pData;
    DeviceConsole = pDevCon;
    return S_OK;
}

HDEVINFO CDevice::GetDevInfoSet()
{
    ULONGLONG h;
    HRESULT hr;

    if(!DevInfoSet) {
        return (HDEVINFO)INVALID_HANDLE_VALUE;
    }
    hr = DevInfoSet->get_Handle(&h);
    if(FAILED(hr)) {
        return (HDEVINFO)INVALID_HANDLE_VALUE;
    }
    return (HDEVINFO)h;
}

STDMETHODIMP CDevice::get_InstanceId(BSTR *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_UNEXPECTED;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }
    //
    // get instance string given hDevInfo and DevInfoData
    //
    WCHAR devID[MAX_DEVICE_ID_LEN];
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfoData.DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        return E_UNEXPECTED;
    }
    *pVal = SysAllocString(devID);
    if(!*pVal) {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

BOOL CDevice::SameAs(CDevice *pOther)
{
    //
    // only works if pOther is in same set as us
    //
    if(pOther == this) {
        return TRUE;
    }
    if(!pOther) {
        return FALSE;
    }
    if(DevInfoData.cbSize != pOther->DevInfoData.cbSize) {
        return FALSE;
    }
    if(DevInfoData.DevInst != pOther->DevInfoData.DevInst) {
        return FALSE;
    }
    return TRUE;
}

STDMETHODIMP CDevice::Delete()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_REMOVEDEVICE_PARAMS rmdParams;

    ZeroMemory(&rmdParams,sizeof(rmdParams));
    rmdParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    rmdParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
    rmdParams.Scope = DI_REMOVEDEVICE_GLOBAL;
    rmdParams.HwProfile = 0;

    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&rmdParams.ClassInstallHeader,sizeof(rmdParams))
        || !SetupDiCallClassInstaller(DIF_REMOVE,hDevInfo,&DevInfoData)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    return CheckNoReboot();
}

STDMETHODIMP CDevice::Enable()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_PROPCHANGE_PARAMS pcp;
    VARIANT_BOOL NeedReboot;
    VARIANT_BOOL NowNeedReboot;
    HRESULT hr;


    //
    // remember current reboot status
    //
    hr = get_RebootRequired(&NeedReboot);
    if(FAILED(hr)) {
        return hr;
    }

    //
    // attempt to enable globally
    //
    ZeroMemory(&pcp,sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_ENABLE;
    pcp.Scope = DICS_FLAG_GLOBAL;
    pcp.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    hr = get_RebootRequired(&NowNeedReboot);
    if(FAILED(hr)) {
        return hr;
    }
    if(!(NeedReboot || NowNeedReboot)) {
        //
        // reboot not required, we must have enabled the device
        //
        return S_OK;
    }
    if(!NeedReboot) {
        //
        // reset reboot status back to how it was originally
        //
        put_RebootRequired(VARIANT_FALSE);
    }
    //
    // also do config specific enable
    //
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_ENABLE;
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    pcp.HwProfile = 0;
    if(SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp))
        && SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // succeeded to invoke config-specific
        //
        if(NeedReboot) {
            //
            // set back original status if reboot was required
            //
            put_RebootRequired(VARIANT_TRUE);
        }
        return CheckNoReboot();
    }
    //
    // if this failed, just imply reboot (our first result)
    //
    put_RebootRequired(VARIANT_TRUE);
    return CheckNoReboot();
}

STDMETHODIMP CDevice::Disable()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_PROPCHANGE_PARAMS pcp;

    //
    // attempt to disable globally
    //
    ZeroMemory(&pcp,sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_DISABLE;
    pcp.Scope = DICS_FLAG_GLOBAL;
    pcp.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    return CheckNoReboot();
}

STDMETHODIMP CDevice::Start()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_PROPCHANGE_PARAMS pcp;

    //
    // attempt to start (can only be for this config)
    //
    ZeroMemory(&pcp,sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_ENABLE;
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    pcp.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    return CheckNoReboot();
}

STDMETHODIMP CDevice::Stop()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_PROPCHANGE_PARAMS pcp;

    //
    // attempt to start (can only be for this config)
    //
    ZeroMemory(&pcp,sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_STOP;
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    pcp.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    return CheckNoReboot();
}

STDMETHODIMP CDevice::Restart()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_PROPCHANGE_PARAMS pcp;

    //
    // attempt to stop then start (restart) (can only be for this config)
    //
    ZeroMemory(&pcp,sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_PROPCHANGE;
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    pcp.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    return CheckNoReboot();
}

HRESULT CDevice::CheckNoReboot()
{
    VARIANT_BOOL NeedReboot;
    HRESULT hr = get_RebootRequired(&NeedReboot);
    if(FAILED(hr)) {
        return hr;
    }
    if(NeedReboot) {
        if(DeviceConsole) {
            //
            // set reboot required in device console too
            //
            DeviceConsole->put_RebootRequired(VARIANT_TRUE);
        }
        return S_FALSE;
    }
    return S_OK;
}

STDMETHODIMP CDevice::get_RebootRequired(VARIANT_BOOL *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_DEVINSTALL_PARAMS devParams;
    ZeroMemory(&devParams,sizeof(devParams));

    devParams.cbSize = sizeof(devParams);
    if(!SetupDiGetDeviceInstallParams(hDevInfo,&DevInfoData,&devParams)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    *pVal = (devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT)) ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CDevice::put_RebootRequired(VARIANT_BOOL newVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    BOOL changed = FALSE;
    SP_DEVINSTALL_PARAMS devParams;
    ZeroMemory(&devParams,sizeof(devParams));

    devParams.cbSize = sizeof(devParams);
    if(!SetupDiGetDeviceInstallParams(hDevInfo,&DevInfoData,&devParams)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    if(newVal) {
        if((devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT)) == 0) {
            devParams.Flags |= DI_NEEDREBOOT|DI_NEEDRESTART;
            changed = TRUE;
            if(DeviceConsole) {
                //
                // set reboot required in device console too
                //
                DeviceConsole->put_RebootRequired(VARIANT_TRUE);
            }
        }
    } else {
        if((devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT)) != 0) {
            devParams.Flags &= ~DI_NEEDREBOOT|DI_NEEDRESTART;
            changed = TRUE;
        }
    }
    if(changed) {
        if(!SetupDiSetDeviceInstallParams(hDevInfo,&DevInfoData,&devParams)) {
            DWORD Err = GetLastError();
            return HRESULT_FROM_SETUPAPI(Err);
        }
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_Description(BSTR *pVal)
{
    //
    // obtain a description for the device
    //
    HRESULT hr;
    CComVariant v;
    VARIANT final;
    VariantInit(&final);

    hr = GetDeviceProperty(SPDRP_FRIENDLYNAME,&v);
    if(SUCCEEDED(hr)) {
        hr = v.ChangeType(VT_BSTR);
        if(SUCCEEDED(hr)) {
            if(V_BSTR(&v)!=NULL && V_BSTR(&v)[0]) {
                v.Detach(&final);
                *pVal = V_BSTR(&final);
                return S_OK;
            }
        }
    }
    v.Clear();
    hr = GetDeviceProperty(SPDRP_DEVICEDESC,&v);
    if(SUCCEEDED(hr)) {
        hr = v.ChangeType(VT_BSTR);
        if(SUCCEEDED(hr)) {
            if(V_BSTR(&v)!=NULL && V_BSTR(&v)[0]) {
                v.Detach(&final);
                *pVal = V_BSTR(&final);
                return S_OK;
            }
        }
    }
    v.Clear();
    *pVal = SysAllocString(L"");
    if(!*pVal) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

STDMETHODIMP CDevice::get_HardwareIds(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_HARDWAREID,pVal);
}

STDMETHODIMP CDevice::put_HardwareIds(VARIANT newVal)
{
    return PutDevicePropertyMultiSz(SPDRP_HARDWAREID,&newVal);
}

STDMETHODIMP CDevice::get_CompatibleIds(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_COMPATIBLEIDS,pVal);
}

STDMETHODIMP CDevice::put_CompatibleIds(VARIANT newVal)
{
    return PutDevicePropertyMultiSz(SPDRP_COMPATIBLEIDS,&newVal);
}

STDMETHODIMP CDevice::get_ServiceName(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_SERVICE,pVal);
}

STDMETHODIMP CDevice::get_Class(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_CLASS,pVal);
}

STDMETHODIMP CDevice::get_Manufacturer(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_MFG,pVal);
}

STDMETHODIMP CDevice::get_FriendlyName(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_FRIENDLYNAME,pVal);
}

STDMETHODIMP CDevice::put_FriendlyName(VARIANT newVal)
{
    return PutDevicePropertyString(SPDRP_FRIENDLYNAME,&newVal);
}

STDMETHODIMP CDevice::get_LocationInformation(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_LOCATION_INFORMATION,pVal);
}

STDMETHODIMP CDevice::put_LocationInformation(VARIANT newVal)
{
    return PutDevicePropertyString(SPDRP_LOCATION_INFORMATION,&newVal);
}

STDMETHODIMP CDevice::get_UpperFilters(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_UPPERFILTERS,pVal);
}

STDMETHODIMP CDevice::put_UpperFilters(VARIANT newVal)
{
    return PutDevicePropertyMultiSz(SPDRP_UPPERFILTERS,&newVal);
}

STDMETHODIMP CDevice::get_LowerFilters(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_LOWERFILTERS,pVal);
}

STDMETHODIMP CDevice::put_LowerFilters(VARIANT newVal)
{
    return PutDevicePropertyMultiSz(SPDRP_LOWERFILTERS,&newVal);
}

STDMETHODIMP CDevice::get_EnumeratorName(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_ENUMERATOR_NAME,pVal);
}

STDMETHODIMP CDevice::get_Security(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_SECURITY_SDS,pVal);
}

STDMETHODIMP CDevice::put_Security(VARIANT newVal)
{
    return PutDevicePropertyString(SPDRP_SECURITY_SDS,&newVal);
}

STDMETHODIMP CDevice::get_DeviceTypeOverride(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_DEVTYPE,pVal);
}

STDMETHODIMP CDevice::put_DeviceTypeOverride(VARIANT newVal)
{
    return PutDevicePropertyDword(SPDRP_DEVTYPE,&newVal);
}

STDMETHODIMP CDevice::get_ForceExclusive(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_EXCLUSIVE,pVal);
}

STDMETHODIMP CDevice::put_ForceExclusive(VARIANT newVal)
{
    return PutDevicePropertyDword(SPDRP_EXCLUSIVE,&newVal);
}

STDMETHODIMP CDevice::get_CharacteristicsOverride(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_CHARACTERISTICS,pVal);
}

STDMETHODIMP CDevice::put_CharacteristicsOverride(VARIANT newVal)
{
    return PutDevicePropertyDword(SPDRP_CHARACTERISTICS,&newVal);
}

HRESULT CDevice::GetDeviceProperty(DWORD prop, VARIANT *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    //
    // first obtain raw registry data
    //
    LPBYTE buffer = NULL;
    DWORD size = 1024;
    DWORD bufsize;
    DWORD reqSize;
    DWORD dataType;
    HRESULT hr;

    for(;;) {
        if(buffer) {
            delete [] buffer;
        }
        bufsize = size + sizeof(WCHAR)*2;
        buffer = new BYTE[bufsize];
        if(!buffer) {
            return E_OUTOFMEMORY;
        }
        if(SetupDiGetDeviceRegistryProperty(hDevInfo,&DevInfoData,prop,&dataType,buffer,size,&reqSize)) {
            break;
        }
        DWORD Err = GetLastError();
        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            delete [] buffer;
            hr = HRESULT_FROM_SETUPAPI(Err);
            return hr;
        }
    }

    //
    // now determine how to parcel it to caller
    //
    switch(dataType) {
    case REG_DWORD: {
            //
            // package value as a long
            //
            if(size != sizeof(DWORD)) {
                hr = E_INVALIDARG;
            } else {
                VariantClear(pVal);
                V_VT(pVal) = VT_I4;
                V_I4(pVal) = (long)*((DWORD*)buffer);
                hr = S_OK;
            }
        }
        break;

    case REG_SZ: {
            //
            // package value as string
            //
            VariantClear(pVal);
            ZeroMemory(buffer+size,sizeof(WCHAR));
            BSTR pString = SysAllocString((LPWSTR)buffer);
            if(!pString) {
                hr = E_OUTOFMEMORY;
            } else {
                V_VT(pVal) = VT_BSTR;
                V_BSTR(pVal) = pString;
                hr = S_OK;
            }
        }
        break;

    case REG_MULTI_SZ: {
            //
            // package as string-list
            //
            VariantClear(pVal);
            ZeroMemory(buffer+size,sizeof(WCHAR)*2);
            CComObject<CStrings> *strings;
            hr = CComObject<CStrings>::CreateInstance(&strings);
            if(FAILED(hr)) {
                break;
            }
            CComPtr<IStrings> stringsPtr = strings;
            LPWSTR p;
            UINT len = 0;
            for(p = (LPWSTR)buffer;*p;p+=len+1) {
                len = wcslen(p);
                hr = strings->InternalAdd(p,len);
                if(FAILED(hr)) {
                    break;
                }
            }
            V_VT(pVal) = VT_DISPATCH;
            V_DISPATCH(pVal) = stringsPtr.Detach();
            hr = S_OK;
        }
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }
    delete [] buffer;
    return hr;

}

HRESULT CDevice::PutDevicePropertyString(DWORD prop, VARIANT *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    HRESULT hr;
    DWORD len = 0;
    PBYTE data = NULL;
    CComVariant v;
    if(!IsBlank(pVal)) {
        hr = v.ChangeType(VT_BSTR,pVal);
        if(FAILED(hr)) {
            return hr;
        }
        len = (SysStringLen(V_BSTR(&v))+1)*sizeof(WCHAR);
        data = (PBYTE)V_BSTR(&v);
    }

    if(SetupDiSetDeviceRegistryProperty(hDevInfo,
                                        &DevInfoData,
                                        prop,
                                        data,
                                        len)) {
        return S_OK;
    }
    DWORD Err = GetLastError();
    return HRESULT_FROM_SETUPAPI(Err);
}

HRESULT CDevice::PutDevicePropertyDword(DWORD prop, VARIANT *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    CComVariant v;
    HRESULT hr;
    DWORD len = 0;
    PBYTE data = NULL;
    if(!IsBlank(pVal)) {
        hr = v.ChangeType(VT_I4,pVal);
        if(FAILED(hr)) {
            return hr;
        }
        len = sizeof(V_I4(&v));
        data = (PBYTE)&V_I4(&v);
    }

    if(SetupDiSetDeviceRegistryProperty(hDevInfo,
                                        &DevInfoData,
                                        prop,
                                        data,
                                        len)) {
        return S_OK;
    }
    DWORD Err = GetLastError();
    return HRESULT_FROM_SETUPAPI(Err);

}

HRESULT CDevice::PutDevicePropertyMultiSz(DWORD prop, VARIANT *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    //
    // build a CStrings collection
    //
    HRESULT hr;
    CComObject<CStrings> *strings = NULL;
    CComPtr<IStrings> stringsPtr;
    DWORD len = 0;
    PBYTE data = NULL;
    LPWSTR multisz;
    if(!IsBlank(pVal)) {
        hr = CComObject<CStrings>::CreateInstance(&strings);
        if(FAILED(hr)) {
            return hr;
        }
        stringsPtr = strings; // handle ref-counting
        hr = strings->Add(*pVal);
        if(FAILED(hr)) {
            return hr;
        }
        //
        // now obtain multisz from the collection
        //
        hr = strings->GetMultiSz(&multisz,&len);
        if(FAILED(hr)) {
            return hr;
        }
        //
        // now write the multi-sz value to device registry
        //
        len *= sizeof(WCHAR);
        data = (PBYTE)multisz;
    }
    if(SetupDiSetDeviceRegistryProperty(hDevInfo,
                                        &DevInfoData,
                                        prop,
                                        (PBYTE)multisz,
                                        len)) {
        if(multisz) {
            delete [] multisz;
        }
        return S_OK;
    }
    DWORD Err = GetLastError();
    if(multisz) {
        delete [] multisz;
    }
    return HRESULT_FROM_SETUPAPI(Err);
}



HRESULT CDevice::GetRemoteMachine(HANDLE *hMachine)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    *hMachine = devInfoListDetail.RemoteMachineHandle;
    return S_OK;
}

STDMETHODIMP CDevice::get_IsRunning(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_STARTED) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_IsDisabled(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_HAS_PROBLEM) {
        if((problem == CM_PROB_DISABLED) || (problem == CM_PROB_HARDWARE_DISABLED)) {
            *pVal = VARIANT_TRUE;
            return S_OK;
        }
    }
    *pVal = VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CDevice::get_HasProblem(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & (DN_HAS_PROBLEM|DN_PRIVATE_PROBLEM)) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_ProblemCode(long *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_HAS_PROBLEM) {
        *pVal = (long)problem;
    } else {
        *pVal = 0;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_HasPrivateProblem(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_PRIVATE_PROBLEM) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_IsRootEnumerated(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_ROOT_ENUMERATED) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_IsDisableable(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_DISABLEABLE) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_IsRemovable(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_REMOVABLE) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

BOOL CDevice::SameAs(LPWSTR str)
{
    BSTR pThisStr;
    HRESULT hr = get_InstanceId(&pThisStr);
    if(FAILED(hr)) {
        return FALSE;
    }
    BOOL f = _wcsicmp(str,pThisStr)==0;
    SysFreeString(pThisStr);
    return f;
}

STDMETHODIMP CDevice::RegRead(BSTR key,VARIANT * pValue)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR val;
    LPWSTR subkey;
    LONG regerr;
    DWORD regType;
    DWORD regSize;
    LPBYTE pByte;

    if(!pValue) {
        return E_INVALIDARG;
    }
    VariantInit(pValue);

    HRESULT hr = SubKeyInfo(key,&hParentKey,&subkey,&val,FALSE);
    if(FAILED(hr)) {
        return hr;
    }
    //
    // now work out and marshell data
    //
    if(subkey) {
        regerr = RegOpenKeyEx(hParentKey,subkey,0,KEY_READ,&hKey);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }
    regSize = 0;
    regerr = RegQueryValueEx(hKey,val,NULL,&regType,NULL,&regSize);
    if(regerr != NO_ERROR) {
        RegCloseKey(hKey);
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    pByte = new BYTE[regSize+sizeof(WCHAR)*2];
    if(!pByte) {
        RegCloseKey(hKey);
        return E_OUTOFMEMORY;
    }
    regerr = RegQueryValueEx(hKey,val,NULL,&regType,pByte,&regSize);
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        delete [] pByte;
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    switch(regType) {
    case REG_DWORD:
        if(regSize != 4) {
            delete [] pByte;
            return DISP_E_TYPEMISMATCH;
        }

        V_VT(pValue) = VT_UI4;
        V_UI4(pValue) = *(DWORD*)pByte;
        break;

    case REG_BINARY:
        switch(regSize) {
        case 1:
            V_VT(pValue) = VT_UI1;
            V_UI1(pValue) = *((BYTE*)pByte);
            break;
        case 2:
            V_VT(pValue) = VT_UI2;
            V_UI2(pValue) = *((WORD*)pByte);
            break;
        case 4:
            V_VT(pValue) = VT_UI4;
            V_UI4(pValue) = *((DWORD*)pByte);
            break;
        default:
            delete [] pByte;
            return DISP_E_TYPEMISMATCH;
        }
        break;

    case REG_SZ:
        ZeroMemory(pByte+regSize,sizeof(WCHAR)*1);
        V_VT(pValue) = VT_BSTR;
        V_BSTR(pValue) = SysAllocString((LPWSTR)pByte);
        if(!V_BSTR(pValue)) {
            delete [] pByte;
            return E_OUTOFMEMORY;
        }
        break;

    case REG_MULTI_SZ: {
            ZeroMemory(pByte+regSize,sizeof(WCHAR)*2);
            CComObject<CStrings> *pStringTemp = NULL;
            hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
            if(FAILED(hr)) {
                delete [] pByte;
                return hr;
            }
            CComPtr<IStrings> stringTempPtr = pStringTemp; // handle ref-counting
            hr = pStringTemp->FromMultiSz((LPWSTR)pByte);
            if(FAILED(hr)) {
                delete [] pByte;
                return hr;
            }
            V_VT(pValue) = VT_DISPATCH;
            V_DISPATCH(pValue) = stringTempPtr.Detach();
        }
        break;


    case REG_EXPAND_SZ:
        ZeroMemory(pByte+regSize,sizeof(WCHAR)*1);
        regSize = ExpandEnvironmentStrings((LPWSTR)pByte,NULL,0);
        if(regSize == 0) {
            V_VT(pValue) = VT_BSTR;
            V_BSTR(pValue) = SysAllocString((LPWSTR)pByte);
        } else {
            LPWSTR pExp = new WCHAR[regSize+1];
            if(!pExp) {
                delete [] pByte;
                return E_OUTOFMEMORY;
            }
            regSize = ExpandEnvironmentStrings((LPWSTR)pByte,NULL,regSize);
            V_VT(pValue) = VT_BSTR;
            V_BSTR(pValue) = SysAllocString(pExp);
            delete [] pExp;
        }
        if(!V_BSTR(pValue)) {
            delete [] pByte;
            return E_OUTOFMEMORY;
        }
        break;

    default:
        delete [] pByte;
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    delete [] pByte;
    return S_OK;
}

STDMETHODIMP CDevice::RegWrite(BSTR key, VARIANT val, VARIANT strType)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR valname;
    LPWSTR subkey;
    LONG regerr;
    CComVariant strType_v;
    CComVariant val_v;
    LPCWSTR pType;
    HRESULT hr;
    DWORD dwType;
    BOOL DetermineType = FALSE;
    LPBYTE pData = NULL;
    LPWSTR pString = NULL;
    DWORD DataSize = 0;
    BYTE SimpleData[4];
    LPVARIANT pVal = &val;

    while(V_VT(pVal) == (VT_BYREF|VT_VARIANT)) {
        pVal = V_VARIANTREF(pVal);
    }

    //
    // validate strType
    //

    hr = GetOptionalString(&strType,strType_v,&pType);
    if(FAILED(hr)) {
        return hr;
    }

    if((pType == NULL) || !pType[0]) {
        //
        // determine type of variant
        //
        if(IsNumericVariant(pVal)) {
            dwType = REG_DWORD;
        } else if(IsMultiValueVariant(pVal)) {
            dwType = REG_MULTI_SZ;
        } else {
            dwType = REG_SZ;
        }
    } else if(_wcsicmp(pType,L"REG_DWORD")==0) {
        dwType = REG_DWORD;
    } else if(_wcsicmp(pType,L"REG_SZ")==0) {
        dwType = REG_SZ;
    } else if(_wcsicmp(pType,L"REG_EXPAND_SZ")==0) {
        dwType = REG_EXPAND_SZ;
    } else if(_wcsicmp(pType,L"REG_MULTI_SZ")==0) {
        dwType = REG_MULTI_SZ;
    } else if(_wcsicmp(pType,L"REG_BINARY")==0) {
        dwType = REG_BINARY;
    } else {
        return DISP_E_TYPEMISMATCH;
    }

    //
    // build up value data
    //
    switch(dwType) {
    case REG_BINARY:
        pData = SimpleData;
        switch V_VT(pVal) {
        case VT_I1:
        case VT_UI1:
            *(LPBYTE)pData = V_UI1(pVal);
            DataSize = 1;
            break;
        case VT_I1|VT_BYREF:
        case VT_UI1|VT_BYREF:
            *(LPBYTE)pData = *V_UI1REF(pVal);
            DataSize = 1;
            break;
        case VT_I2:
        case VT_UI2:
            *(LPWORD)pData = V_UI2(pVal);
            DataSize = 2;
            break;
        case VT_I2|VT_BYREF:
        case VT_UI2|VT_BYREF:
            *(LPWORD)pData = *V_UI2REF(pVal);
            DataSize = 2;
            break;
        case VT_I4:
        case VT_UI4:
            *(LPDWORD)pData = V_UI4(pVal);
            DataSize = 4;
            break;
        case VT_I4|VT_BYREF:
        case VT_UI4|VT_BYREF:
            *(LPDWORD)pData = *V_UI4REF(pVal);
            DataSize = 4;
            break;
        default:
            return DISP_E_TYPEMISMATCH;
        }
        break;

    case REG_DWORD:
        pData = SimpleData;
        hr = val_v.ChangeType(VT_UI4,pVal);
        if(FAILED(hr)) {
            return DISP_E_TYPEMISMATCH;
        }
        *(LPDWORD)pData = V_UI4(pVal);
        DataSize = 4;
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:
        hr = val_v.ChangeType(VT_BSTR,pVal);
        if(FAILED(hr)) {
            return DISP_E_TYPEMISMATCH;
        }

        DataSize = (SysStringLen(V_BSTR(&val_v))+1);
        pString = new WCHAR[DataSize];
        if(!pString) {
            return E_OUTOFMEMORY;
        }
        pData = (LPBYTE)pString;
        DataSize *= sizeof(WCHAR);
        memcpy(pData,V_BSTR(&val_v),DataSize);
        break;

    case REG_MULTI_SZ: {
            CComObject<CStrings> *pStringTemp = NULL;
            hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
            if(FAILED(hr)) {
                return hr;
            }
            CComPtr<IStrings> pStringTempPtr = pStringTemp; // for ref-counting
            hr = pStringTemp->InternalInsert(0,pVal);
            if(FAILED(hr)) {
                return hr;
            }
            hr = pStringTemp->GetMultiSz(&pString,&DataSize);
            if(FAILED(hr)) {
                return hr;
            }
            pData = (LPBYTE)pString;
            DataSize *= sizeof(WCHAR);
        }
        break;
    default:
        return DISP_E_TYPEMISMATCH;
    }

    hr = SubKeyInfo(key,&hParentKey,&subkey,&valname,TRUE);
    if(FAILED(hr)) {
        if(pString) {
            delete [] pString;
        }
        return hr;
    }
    if(subkey) {
        regerr = RegCreateKeyEx(hParentKey,subkey,0,NULL,0,KEY_WRITE,NULL,&hKey,NULL);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            if(pString) {
                delete [] pString;
            }
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }

    regerr = RegSetValueEx(hKey,valname,0,dwType,pData,DataSize);
    if(pString) {
        delete [] pString;
    }
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        return HRESULT_FROM_SETUPAPI(regerr);
    }

    return S_OK;
}

STDMETHODIMP CDevice::RegDelete(BSTR key)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR valname;
    LPWSTR subkey;
    LONG regerr;
    HRESULT hr = SubKeyInfo(key,&hParentKey,&subkey,&valname,TRUE);
    if(FAILED(hr)) {
        return hr;
    }
    if(subkey) {
        regerr = RegOpenKeyEx(hParentKey,subkey,0,KEY_WRITE,&hKey);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }
    regerr = RegDeleteValue(hKey,valname);
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    return S_OK;
}

HRESULT CDevice::SubKeyInfo(LPCWSTR subkey, HKEY *hKey, LPWSTR *pSubKey,LPCWSTR *pKeyVal,BOOL writeable)
{
    //
    // first 3 chars of subkey can be "SW\" or "HW\"
    //
    LPCWSTR partkey;
    DWORD Scope = DICS_FLAG_GLOBAL;
    DWORD HwProfile = 0;
    DWORD KeyType;
    HKEY hParentKey;
    LPWSTR keyname;
    LPCWSTR keyval;
    size_t len;

    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    if((subkey[0] == L'S' || subkey[0] == L's')
        &&(subkey[1] == L'W' || subkey[1] == L'w')
        &&(subkey[2] == L'\\')) {
        partkey = subkey+3;
        KeyType = DIREG_DRV;
    } else if((subkey[0] == L'H' || subkey[0] == L'h')
        &&(subkey[1] == L'W' || subkey[1] == L'w')
        &&(subkey[2] == L'\\')) {
        partkey = subkey+3;
        KeyType = DIREG_DEV;
    } else {
        return E_INVALIDARG;
    }
    hParentKey = SetupDiOpenDevRegKey(hDevInfo,
                                    &DevInfoData,
                                    Scope,
                                    HwProfile,
                                    KeyType,
                                    writeable ? KEY_WRITE: KEY_READ
                                    );
    if((hParentKey == NULL) || (hParentKey == INVALID_HANDLE_VALUE)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    //
    // determine value part of key
    //
    keyval = wcsrchr(partkey,L'\\');
    if(!keyval) {
        *hKey = hParentKey;
        *pKeyVal = partkey[0] ? partkey : NULL;
        *pSubKey = NULL;
        return S_OK;
    }
    len = keyval-partkey+1;
    keyname = new WCHAR[len];
    if(!keyname) {
        RegCloseKey(hParentKey);
        return E_OUTOFMEMORY;
    }
    wcsncpy(keyname,partkey,len);
    keyname[len-1] = 0;
    keyval++;
    if(!keyval[0]) {
        keyval = NULL;
    }
    *hKey = hParentKey;
    *pSubKey = keyname;
    *pKeyVal = keyval;
    return S_OK;
}

STDMETHODIMP CDevice::CurrentDriverPackage(LPDISPATCH *pDriver)
{
    *pDriver = NULL;
    //
    // create a search set for finding current driver
    //
    HRESULT hr;

    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }
    HANDLE remote;
    if(SUCCEEDED(GetRemoteMachine(&remote)) && remote) {

        //
        // remote driver search not implemented
        //
        return E_NOTIMPL;
    }

    CComObject<CDrvSearchSet> *pSet = NULL;

    hr = CComObject<CDrvSearchSet>::CreateInstance(&pSet);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<IDrvSearchSet> pSetPtr = pSet; // for ref-counting
    hr = pSet->Init(this,SPDIT_CLASSDRIVER);
    if(FAILED(hr)) {
        return hr;
    }

    //
    // use temporary device information
    //
    HDEVINFO SetDevInfo = pSet->GetDevInfoSet();
    PSP_DEVINFO_DATA SetDevInfoData = pSet->GetDevInfoData();

    //
    // WinXP has a nice feature for obtaining current driver
    //
    DWORD Err;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;

    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));
    ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if(!SetupDiGetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams)) {
        Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // Set the flags that tell SetupDiBuildDriverInfoList to just put the currently installed
    // driver node in the list, and that it should allow excluded drivers.
    //
    DeviceInstallParams.FlagsEx |= (DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

    if(SetupDiSetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams)
        && SetupDiBuildDriverInfoList(SetDevInfo, SetDevInfoData, SPDIT_CLASSDRIVER)) {
        if(!SetupDiEnumDriverInfo(SetDevInfo,SetDevInfoData,SPDIT_CLASSDRIVER,0,&DriverInfoData)) {
            //
            // flag recognized, but no driver
            //
            return S_OK;
        }
        //
        // DriverInfoData contains driver
        //
    } else {

        //
        // get information about a driver to do a full search
        //
        WCHAR SectionName[LINE_LEN];
        WCHAR DrvDescription[LINE_LEN];
        HKEY hKey = NULL;
        DWORD RegDataLength;
        DWORD RegDataType;
        long regerr;

        //
        // get driver key - if it doesn't exist, no driver
        //
        hKey = SetupDiOpenDevRegKey(SetDevInfo,
                                    SetDevInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_READ
                                   );

        if(hKey == INVALID_HANDLE_VALUE) {
            //
            // no such value exists, so we haven't an associated driver
            //
            RegCloseKey(hKey);
            return S_OK;
        }

        //
        // obtain path of INF
        //
        RegDataLength = sizeof(DeviceInstallParams.DriverPath); // want in bytes, not chars
        regerr = RegQueryValueEx(hKey,
                                 REGSTR_VAL_INFPATH,
                                 NULL,
                                 &RegDataType,
                                 (PBYTE)DeviceInstallParams.DriverPath,
                                 &RegDataLength
                                 );

        if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
            //
            // no such value exists, so we haven't an associated driver
            //
            RegCloseKey(hKey);
            return S_OK;
        }


        RegDataLength = sizeof(DriverInfoData.ProviderName);
        regerr = RegQueryValueEx(hKey,
                                 REGSTR_VAL_PROVIDER_NAME,
                                 NULL,
                                 &RegDataType,
                                 (PBYTE)DriverInfoData.ProviderName,
                                 &RegDataLength
                                 );

        if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
            //
            // no such value exists, so we don't have a valid associated driver
            //
            RegCloseKey(hKey);
            return S_OK;
        }

        RegDataLength = sizeof(SectionName);
        regerr = RegQueryValueEx(hKey,
                                 REGSTR_VAL_INFSECTION,
                                 NULL,
                                 &RegDataType,
                                 (PBYTE)SectionName,
                                 &RegDataLength
                                 );

        if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
            //
            // no such value exists, so we don't have a valid associated driver
            //
            RegCloseKey(hKey);
            return S_OK;
        }

        //
        // driver description is usually same as original device description
        // but sometimes obtained from strings section
        //
        RegDataLength = sizeof(DrvDescription);
        regerr = RegQueryValueEx(hKey,
                                 REGSTR_VAL_DRVDESC,
                                 NULL,
                                 &RegDataType,
                                 (PBYTE)DrvDescription,
                                 &RegDataLength
                                 );

        RegCloseKey(hKey);

        if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
            //
            // no such value exists, so we don't have a valid associated driver
            //
            return S_OK;
        }

        //
        // Manufacturer
        //

        if(!SetupDiGetDeviceRegistryProperty(SetDevInfo,
                                            SetDevInfoData,
                                            SPDRP_MFG,
                                            NULL,      // datatype is guaranteed to always be REG_SZ.
                                            (PBYTE)DriverInfoData.MfgName,
                                            sizeof(DriverInfoData.MfgName),
                                            NULL)) {
            //
            // no such value exists, so we don't have a valid associated driver
            //
            return S_OK;
        }

        //
        // Description
        //

        if(!SetupDiGetDeviceRegistryProperty(SetDevInfo,
                                            SetDevInfoData,
                                            SPDRP_DEVICEDESC,
                                            NULL,      // datatype is guaranteed to always be REG_SZ.
                                            (PBYTE)DriverInfoData.Description,
                                            sizeof(DriverInfoData.Description),
                                            NULL)) {
            //
            // no such value exists, so we don't have a valid associated driver
            //
            return S_OK;
        }


        //
        // now search for drivers listed in the INF
        //
        //
        DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;
        DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_INSTALLEDDRIVER;
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

        if(!SetupDiSetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams)) {
            Err = GetLastError();
            return HRESULT_FROM_SETUPAPI(Err);
        }
        if(!SetupDiBuildDriverInfoList(SetDevInfo, SetDevInfoData, SPDIT_CLASSDRIVER)) {
            return S_OK;
        }

        //
        // enumerate drivers to find a good match
        //
        SP_DRVINFO_DATA ThisDriverInfoData;
        ZeroMemory(&ThisDriverInfoData, sizeof(ThisDriverInfoData));
        ThisDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

        DWORD c;
        BOOL match = FALSE;
        for(c=0;SetupDiEnumDriverInfo(SetDevInfo,SetDevInfoData,SPDIT_CLASSDRIVER,c,&ThisDriverInfoData);c++) {
            if((_wcsicmp(DriverInfoData.MfgName,ThisDriverInfoData.MfgName)==0)
                &&(_wcsicmp(DriverInfoData.ProviderName,ThisDriverInfoData.ProviderName)==0)) {
                //
                // these two fields match, try more detailed info
                //
                SP_DRVINFO_DETAIL_DATA detail;
                detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                if(!SetupDiGetDriverInfoDetail(SetDevInfo,SetDevInfoData,&ThisDriverInfoData,&detail,sizeof(detail),NULL)) {
                    Err = GetLastError();
                    if((Err != NO_ERROR) && (Err != ERROR_INSUFFICIENT_BUFFER)) {
                        continue;
                    }
                }
                if((_wcsicmp(SectionName,detail.SectionName)==0) &&
                    (_wcsicmp(DrvDescription,detail.DrvDescription)==0)) {
                    DriverInfoData = ThisDriverInfoData;
                    match = TRUE;
                    break;
                }
            }
        }
        if(!match) {
            return S_OK;
        }
    }

    //
    // create the driver object
    //
    CComObject<CDriverPackage> *driver = NULL;
    hr = CComObject<CDriverPackage>::CreateInstance(&driver);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<IDriverPackage> driverPtr = driver; // for ref-counting
    hr = driver->Init(pSet,&DriverInfoData);
    if(FAILED(hr)) {
        return hr;
    }
    *pDriver = driverPtr.Detach();
    return S_OK;
}


STDMETHODIMP CDevice::FindDriverPackages(VARIANT ScriptPath, LPDISPATCH *pDriversOut)
{
    *pDriversOut = NULL;

    //
    // Treat variant as a multi-sz array if it exists
    //

    CComObject<CStrings> *pStrings = NULL;
    CComPtr<IStrings> pStringsPtr;
    CComObject<CDrvSearchSet> *pSet = NULL;
    CComPtr<IDrvSearchSet> pSetPtr;
    CComObject<CDriverPackages> *pDrivers = NULL;
    CComPtr<IDriverPackages> pDriversPtr;
    CComObject<CDriverPackage> *pDriver = NULL;
    CComPtr<IDriverPackage> pDriverPtr;
    HRESULT hr;

    if(!IsNoArg(&ScriptPath)) {
        hr = CComObject<CStrings>::CreateInstance(&pStrings);
        if(FAILED(hr)) {
            return hr;
        }
        pStringsPtr = pStrings;

        hr = pStrings->InternalInsert(0,&ScriptPath);
        if(FAILED(hr)) {
            return hr;
        }
    }

    //
    // create context for driver search
    //

    hr = CComObject<CDrvSearchSet>::CreateInstance(&pSet);
    if(FAILED(hr)) {
        return hr;
    }
    pSetPtr = pSet;
    hr = pSet->Init(this,SPDIT_COMPATDRIVER);
    if(FAILED(hr)) {
        return hr;
    }

    //
    // use temporary device information
    //
    HDEVINFO SetDevInfo = pSet->GetDevInfoSet();
    PSP_DEVINFO_DATA SetDevInfoData = pSet->GetDevInfoData();
    DWORD Err;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;
    DWORD c;

    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));
    ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if(!SetupDiGetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams)) {
        Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // Do a search in standard directories.
    //
    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

    BOOL done_wild = FALSE;
    BSTR str;

    for(c=0,str=NULL;(pStrings==NULL) || (pStrings->InternalEnum(c,&str));c++) {

        if(str && str[0] && ((str[0] != '*') || str[1])) {
            DWORD attr = GetFileAttributes(str);
            if(attr == (DWORD)(-1)) {
                continue;
            }
            DWORD sz = GetFullPathName(str,MAX_PATH,DeviceInstallParams.DriverPath,NULL);
            if(sz >= MAX_PATH) {
                DeviceInstallParams.DriverPath[0] = '\0';
                continue;
            }
            if(!(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                DeviceInstallParams.FlagsEx |= DI_ENUMSINGLEINF;
            }
        } else if(done_wild) {
            continue;
        } else {
            done_wild = TRUE;
        }

        if(!SetupDiSetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams)) {
            Err = GetLastError();
            hr = HRESULT_FROM_SETUPAPI(Err);
            goto final;
        }


        if(!SetupDiBuildDriverInfoList(SetDevInfo, SetDevInfoData, SPDIT_COMPATDRIVER)) {
            Err = GetLastError();
            hr = HRESULT_FROM_SETUPAPI(Err);
            goto final;
        }

        SetupDiGetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams);
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_APPENDDRIVERLIST;
        DeviceInstallParams.FlagsEx &= ~DI_ENUMSINGLEINF;
        DeviceInstallParams.DriverPath[0] = '\0';
    }

    //
    // now create the collection to hold search results
    //

    hr = CComObject<CDriverPackages>::CreateInstance(&pDrivers);
    if(FAILED(hr)) {
        pDrivers = NULL;
        goto final;
    }
    pDriversPtr = pDrivers;
    hr = pDrivers->Init(pSet);
    if(FAILED(hr)) {
        goto final;
    }

    for(c=0;SetupDiEnumDriverInfo(SetDevInfo,SetDevInfoData,SPDIT_COMPATDRIVER,c,&DriverInfoData);c++) {

        //
        // create the driver object
        //
        hr = CComObject<CDriverPackage>::CreateInstance(&pDriver);
        if(FAILED(hr)) {
            goto final;
        }
        pDriverPtr = pDriver;
        hr = pDriver->Init(pSet,&DriverInfoData);
        if(FAILED(hr)) {
            goto final;
        }
        hr = pDrivers->InternalAdd(pDriver);
        if(FAILED(hr)) {
            goto final;
        }
    }

final:

    if(FAILED(hr)) {
        return hr;
    }
    *pDriversOut = pDriversPtr.Detach();
    return S_OK;
}

STDMETHODIMP CDevice::HasInterface(BSTR Interface, VARIANT_BOOL *pFlag)
{
    //
    // create a search set for finding current driver
    //
    HRESULT hr;

    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    GUID guid;
    hr = CLSIDFromString(Interface,&guid);
    if(FAILED(hr)) {
        return hr;
    }
    SP_DEVICE_INTERFACE_DATA data;
    ZeroMemory(&data,sizeof(data));
    data.cbSize = sizeof(data);
    BOOL f = SetupDiEnumDeviceInterfaces(hDevInfo,&DevInfoData,&guid,0,&data);
    DWORD Err = GetLastError();

    *pFlag = f? VARIANT_TRUE: VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CDevice::get_Machine(BSTR *pVal)
{
    *pVal = NULL;

    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }

    if((devInfoListDetail.RemoteMachineHandle == NULL) || !devInfoListDetail.RemoteMachineName[0]) {
        *pVal = SysAllocString(L"");
        if(*pVal) {
            return S_FALSE;
        }
    } else {
        *pVal = SysAllocString(devInfoListDetail.RemoteMachineName);
        if(*pVal) {
            return S_OK;
        }
    }
    return E_OUTOFMEMORY;
}

STDMETHODIMP CDevice::get__ClassGuid(GUID *pVal)
{
    WCHAR ClassGuid[40];
    HRESULT hr;

    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }
    DWORD reqSize;
    if(!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                        &DevInfoData,
                                        SPDRP_CLASSGUID,
                                        NULL,
                                        (LPBYTE)ClassGuid,
                                        sizeof(ClassGuid),
                                        &reqSize)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    hr = CLSIDFromString(ClassGuid,pVal);
    if(FAILED(hr)) {
        return hr;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get__Machine(BSTR *pVal)
{
    return get_Machine(pVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\device.h ===
// Device.h : Declaration of the CDevice

#ifndef __DEVICE_H_
#define __DEVICE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDevice
class ATL_NO_VTABLE CDevice : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDevice, &IID_IDevice, &LIBID_DEVCON2Lib>,
	public IDeviceInternal,
	public ISetupClassInternal
{
public:
	CComPtr<IDevInfoSet> DevInfoSet;
	CComPtr<IDeviceConsole> DeviceConsole;
	SP_DEVINFO_DATA DevInfoData;

public:
	CDevice()
	{
		ZeroMemory(&DevInfoData,sizeof(DevInfoData));
	}
	~CDevice();
	HRESULT Init(IDevInfoSet *pDevInfoSet,LPCWSTR pInstance,IDeviceConsole *pDevCon);
	HRESULT Init(IDevInfoSet *pDevInfoSet, PSP_DEVINFO_DATA pData,IDeviceConsole *pDevCon);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDevice)
	COM_INTERFACE_ENTRY(IDevice)
	COM_INTERFACE_ENTRY(IDeviceInternal)
	COM_INTERFACE_ENTRY(ISetupClassInternal)  // because class can be determined from device
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDevice
public:
	STDMETHOD(get__Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get__ClassGuid)(/*[out, retval]*/ GUID *pVal);
	STDMETHOD(get_Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(HasInterface)(/*[in]*/ BSTR Interface,/*[out,retval]*/ VARIANT_BOOL *pFlag);
	STDMETHOD(FindDriverPackages)(/*[in]*/VARIANT ScriptPath,/*[out,retval]*/ LPDISPATCH *pDrivers);
	STDMETHOD(CurrentDriverPackage)(/*[out,retval]*/ LPDISPATCH *pDriver);
	STDMETHOD(RegDelete)(/*[in]*/ BSTR key);
	STDMETHOD(RegWrite)(/*[in]*/ BSTR key,/*[in]*/ VARIANT val,/*[in,optional]*/ VARIANT strType);
	STDMETHOD(RegRead)(/*[in]*/ BSTR key,VARIANT * pValue);
	STDMETHOD(get_IsRemovable)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsDisableable)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsRootEnumerated)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_HasPrivateProblem)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_ProblemCode)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_HasProblem)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsDisabled)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsRunning)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_CharacteristicsOverride)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_CharacteristicsOverride)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_ForceExclusive)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_ForceExclusive)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_DeviceTypeOverride)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_DeviceTypeOverride)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_Security)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_Security)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_EnumeratorName)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_LowerFilters)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_LowerFilters)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_UpperFilters)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_UpperFilters)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_LocationInformation)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_LocationInformation)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_FriendlyName)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_FriendlyName)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_Manufacturer)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_Class)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_ServiceName)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_CompatibleIds)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_CompatibleIds)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_HardwareIds)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_HardwareIds)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_RebootRequired)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_RebootRequired)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(Restart)();
	STDMETHOD(Stop)();
	STDMETHOD(Start)();
	STDMETHOD(Disable)();
	STDMETHOD(Enable)();
	STDMETHOD(Delete)();

	//
	// helpers
	//
	HRESULT TranslatePropVal(LPVARIANT var,DWORD * val);
	HRESULT CheckNoReboot();
	HDEVINFO GetDevInfoSet();
	HRESULT SubKeyInfo(LPCWSTR subkey, HKEY *hKey, LPWSTR *pSubKey,LPCWSTR *keyval,BOOL writeable);
	BOOL SameAs(CDevice *pOther);
	BOOL SameAs(LPWSTR str);
	STDMETHOD(get_InstanceId)(/*[out, retval]*/ BSTR *pVal);
	HRESULT GetRemoteMachine(HANDLE *hMachine);
	HRESULT PutDevicePropertyMultiSz(DWORD prop,VARIANT *pVal);
	HRESULT PutDevicePropertyDword(DWORD prop,VARIANT *pVal);
	HRESULT PutDevicePropertyString(DWORD prop,VARIANT *pVal);
	HRESULT GetDeviceProperty(DWORD prop,VARIANT *pVal);

};

#endif //__DEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\deviceconsole.cpp ===
// DeviceConsole.cpp : Implementation of CDeviceConsole
#include "stdafx.h"
#include "DevCon2.h"
#include "DeviceConsole.h"
#include "Devices.h"
#include "SetupClasses.h"
#include "xStrings.h"
#include "utils.h"

#include <dbt.h>

/////////////////////////////////////////////////////////////////////////////
// CDeviceConsole

//
// a window is used for events to ensure that we dispatch the events
// within the same apartment as the DeviceConsole object
//

LRESULT CDevConNotifyWindow::OnDeviceChange(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT ret = TRUE;
    bHandled = TRUE;
    switch(wParam) {
    case DBT_DEVNODES_CHANGED:
        //
        // post this so we don't block sender
        //
        PostMessage(UM_POSTGLOBALEVENT,wParam);
        return TRUE;
    default: ;
    }
    return ret;
}

LRESULT CDevConNotifyWindow::OnPostGlobalEvent(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT ret = TRUE;
    bHandled = TRUE;

    //
    // defer this global event to CDeviceConsole
    //
    if(m_pDevCon) {
        m_pDevCon->FireGlobalEvent(wParam);
    }

    return ret;
}

LRESULT CDevConNotifyWindow::OnPostEvents(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT ret = TRUE;
    bHandled = TRUE;

    //
    // handle all the pending events
    //

    return ret;
}

STDMETHODIMP CDeviceConsole::AllDevices(VARIANT flags, VARIANT machine, LPDISPATCH *pDevices)
{
    CComVariant m;
    DWORD diflags = 0;
    HRESULT hr;
    LPCWSTR pMachine;
    HDEVINFO hDevInfo;

    *pDevices = NULL;

    hr = TranslateDeviceFlags(&flags,&diflags);
    if(FAILED(hr)) {
        return hr;
    }
    diflags |= DIGCF_ALLCLASSES;
    hr = GetOptionalString(&machine,m,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }

    hDevInfo = SetupDiGetClassDevsEx(NULL,NULL,NULL,diflags,NULL,pMachine,NULL);
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        DWORD Err = GetLastError();
        return  HRESULT_FROM_SETUPAPI(Err);
    }
    return BuildDeviceList(hDevInfo,pDevices);
}

HRESULT CDeviceConsole::BuildDeviceList(HDEVINFO hDevInfo,LPDISPATCH *pDevices)
{
    *pDevices = NULL;

    HRESULT hr;
    CComObject<CDevices> *d;
    hr = CComObject<CDevices>::CreateInstance(&d);
    if(FAILED(hr)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return hr;
    }
    CComPtr<IDevices> dPtr = d;
    hr = d->Init(hDevInfo,this);
    if(FAILED(hr)) {
        return hr;
    }
    *pDevices = dPtr.Detach();
    return S_OK;
}

STDMETHODIMP CDeviceConsole::CreateEmptyDeviceList(VARIANT machine, LPDISPATCH *pDevices)
{
    CComVariant machine_v;
    LPCWSTR pMachine;
    HRESULT hr;
    HDEVINFO hDevInfo;
    DWORD Err;

    hr = GetOptionalString(&machine,machine_v,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }

    hDevInfo = SetupDiCreateDeviceInfoListEx(NULL,
                                              NULL,
                                              pMachine,
                                              NULL);
    if(hDevInfo != INVALID_HANDLE_VALUE) {
        return BuildDeviceList(hDevInfo,pDevices);
    }
    Err = GetLastError();
    return HRESULT_FROM_SETUPAPI(Err);
}

typedef BOOL (WINAPI *UpdateDriverForPlugAndPlayDevicesProtoW)(HWND hwndParent,
                                                         LPCWSTR HardwareId,
                                                         LPCWSTR FullInfPath,
                                                         DWORD InstallFlags,
                                                         PBOOL bRebootRequired OPTIONAL
                                                         );

#define UPDATEDRIVERFORPLUGANDPLAYDEVICESW "UpdateDriverForPlugAndPlayDevicesW"

STDMETHODIMP CDeviceConsole::UpdateDriver(BSTR infname, BSTR hwid, VARIANT op_flags)
{
    HMODULE newdevMod = NULL;
    UpdateDriverForPlugAndPlayDevicesProtoW UpdateFnW;
    BOOL reboot = FALSE;
    DWORD flags = 0;
    WCHAR InfPath[MAX_PATH];
    HRESULT hr;
    CComVariant flags_v;

    //
    // op_flags are optional
    //

    if(V_VT(&op_flags)!=VT_ERROR) {
        hr = flags_v.ChangeType(VT_BSTR,&op_flags);
        if(FAILED(hr)) {
            return hr;
        }
        flags = V_I4(&flags_v);
    } else if (V_ERROR(&op_flags) != DISP_E_PARAMNOTFOUND) {
        hr = V_ERROR(&op_flags);
        return hr;
    }

    //
    // Inf must be a full pathname
    //
    if(GetFullPathName(infname,MAX_PATH,InfPath,NULL) >= MAX_PATH) {
        //
        // inf pathname too long
        //
        return E_INVALIDARG;
    }

    //
    // make use of UpdateDriverForPlugAndPlayDevices
    //
    newdevMod = LoadLibrary(TEXT("newdev.dll"));
    if(!newdevMod) {
        goto final;
    }
    UpdateFnW = (UpdateDriverForPlugAndPlayDevicesProtoW)GetProcAddress(newdevMod,UPDATEDRIVERFORPLUGANDPLAYDEVICESW);
    if(!UpdateFnW)
    {
        goto final;
    }

    if(!UpdateFnW(NULL,hwid,InfPath,flags,&reboot)) {
        DWORD Err = GetLastError();
        hr = HRESULT_FROM_SETUPAPI(Err);
        goto final;
    }
    if(reboot) {
        RebootRequired = VARIANT_TRUE;
        hr = S_FALSE;
    } else {
        hr = S_OK;
    }


final:

    if(newdevMod) {
        FreeLibrary(newdevMod);
    }

    return hr;
}

STDMETHODIMP CDeviceConsole::CheckReboot()
{
    WCHAR RebootText[MAX_PATH];
    WCHAR RebootCaption[MAX_PATH];

    if(!RebootRequired) {
        return S_OK;
    }
    int str = LoadString(GetModuleHandle(NULL),IDS_REBOOTREQ,RebootText,MAX_PATH);
    if(!str) {
        return E_UNEXPECTED;
    }
    str = LoadString(GetModuleHandle(NULL),IDS_REBOOTCAP,RebootCaption,MAX_PATH);
    if(!str) {
        return E_UNEXPECTED;
    }

    MessageBeep(MB_ICONSTOP);
    int mb = MessageBox(NULL,RebootText,RebootCaption,MB_YESNO|MB_ICONSTOP);
    if(mb == IDOK) {
        return RebootReasonHardware();
    }
    return S_FALSE;
}

STDMETHODIMP CDeviceConsole::RebootReasonHardware()
{
    HANDLE Token;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    //
    // On WinNT, need to "turn on" reboot privilege
    // if any of this fails, try reboot anyway
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        goto final;
    }

    if(!LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&Luid)) {
        CloseHandle(Token);
        goto final;
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

final:

    //
    // attempt reboot - inform system that this is planned hardware install
    //
    return ExitWindowsEx(EWX_REBOOT, REASON_PLANNED_FLAG|REASON_HWINSTALL) ? S_OK : E_UNEXPECTED;
}

STDMETHODIMP CDeviceConsole::get_RebootRequired(VARIANT_BOOL *pVal)
{
    *pVal = RebootRequired ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CDeviceConsole::put_RebootRequired(VARIANT_BOOL newVal)
{
    RebootRequired = newVal ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CDeviceConsole::SetupClasses(VARIANT classList, VARIANT machine, LPDISPATCH *pDevices)
{
    *pDevices = NULL;
    CComVariant m;
    HRESULT hr;
    LPCWSTR pMachine;

    hr = GetOptionalString(&machine,m,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }
    CComObject<CSetupClasses> *d;
    hr = CComObject<CSetupClasses>::CreateInstance(&d);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<ISetupClasses> dPtr = d;
    hr = d->Init(pMachine,this);
    if(FAILED(hr)) {
        return hr;
    }
    if(IsBlankString(&classList)) {
        hr = d->AllClasses();
    } else {
        hr = d->Add(classList);
    }
    if(FAILED(hr)) {
        return hr;
    }
    *pDevices = dPtr.Detach();
    return S_OK;
}

STDMETHODIMP CDeviceConsole::CreateEmptySetupClassList(VARIANT machine, LPDISPATCH *pResult)
{
    *pResult = NULL;

    CComVariant m;
    HRESULT hr;
    LPCWSTR pMachine;

    hr = GetOptionalString(&machine,m,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }
    CComObject<CSetupClasses> *d;
    hr = CComObject<CSetupClasses>::CreateInstance(&d);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<ISetupClasses> dPtr = d;
    hr = d->Init(pMachine,this);
    if(FAILED(hr)) {
        return hr;
    }
    *pResult = dPtr.Detach();
    return S_OK;
}


STDMETHODIMP CDeviceConsole::DevicesBySetupClasses(VARIANT SetupClasses, VARIANT flags, VARIANT machine, LPDISPATCH *pDevices)
{
    *pDevices = NULL;

    CComObject<CSetupClasses> *pClasses = NULL;
    CComVariant m;
    HRESULT hr;
    LPCWSTR pMachine;

    //
    // shorthand for initializing class collection
    // to get devices
    //
    hr = GetOptionalString(&machine,m,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }
    hr = CComObject<CSetupClasses>::CreateInstance(&pClasses);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<ISetupClasses> pClassesPtr = pClasses;
    hr = pClasses->Init(pMachine,this);
    if(FAILED(hr)) {
        return hr;
    }
    hr = pClasses->Add(SetupClasses);
    if(FAILED(hr)) {
        return hr;
    }
    hr = pClasses->Devices(flags,pDevices);
    return hr;
}

STDMETHODIMP CDeviceConsole::DevicesByInterfaceClasses(VARIANT InterfaceClasses, VARIANT machine, LPDISPATCH *pDevicesOut)
{
    *pDevicesOut = NULL;

    //
    // similar to above, but for interface classes
    //
    CComObject<CStrings> *pStrings = NULL;
    CComObject<CDevices> *pDevices = NULL;
    CComVariant m;
    HRESULT hr;
    LPCWSTR pMachine;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    HDEVINFO hPrevDevInfo = NULL;
    DWORD Err;
    DWORD c;
    BSTR str;

    hr = GetOptionalString(&machine,m,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }

    hr = CComObject<CStrings>::CreateInstance(&pStrings);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<IStrings> pStringsPtr = pStrings;

    hr = pStrings->Add(InterfaceClasses);
    if(FAILED(hr)) {
        return hr;
    }

    for(c=0;pStrings->InternalEnum(c,&str);c++) {
        //
        // convert string to interface
        //
        GUID guid;
        hr = CLSIDFromString(str,&guid);
        if(FAILED(hr)) {
            return hr;
        }
        //
        // query present devices of interface
        //
        hDevInfo = SetupDiGetClassDevsEx(&guid,NULL,NULL,DIGCF_DEVICEINTERFACE|DIGCF_PRESENT,hPrevDevInfo,pMachine,NULL);
        if(hDevInfo == INVALID_HANDLE_VALUE) {
            Err = GetLastError();
            if(hPrevDevInfo) {
                SetupDiDestroyDeviceInfoList(hPrevDevInfo);
            }
            return HRESULT_FROM_SETUPAPI(Err);
        }
        hPrevDevInfo = hDevInfo;
    }
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_INVALIDARG;
    }
    //
    // now build resultant list
    //

    hr = CComObject<CDevices>::CreateInstance(&pDevices);
    if(FAILED(hr)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return hr;
    }
    CComPtr<IDevices> pDevicesPtr = pDevices;
    hr = pDevices->Init(hDevInfo,this);
    if(FAILED(hr)) {
        return hr;
    }
    *pDevicesOut = pDevicesPtr.Detach();
    return S_OK;
}

STDMETHODIMP CDeviceConsole::DevicesByInstanceIds(VARIANT InstanceIdList, VARIANT machine, LPDISPATCH *pDevices)
{
    //
    // shorthand for CreateEmptyDeviceList followed by Add
    //
    HRESULT hr;
    LPDISPATCH Devices = NULL;
    CComQIPtr<IDevices> pIf;
    hr = CreateEmptyDeviceList(machine,&Devices);
    if(FAILED(hr)) {
        return hr;
    }
    pIf = Devices;
    if(!pIf) {
        return E_UNEXPECTED;
    }
    hr = pIf->Add(InstanceIdList);
    if(FAILED(hr)) {
        Devices->Release();
        return hr;
    }
    *pDevices = Devices;
    return S_OK;
}

STDMETHODIMP CDeviceConsole::StringList(VARIANT from, LPDISPATCH *pDest)
{
    //
    // convinience only
    //
    *pDest = NULL;
    HRESULT hr;
    CComObject<CStrings> *pStrings = NULL;
    hr = CComObject<CStrings>::CreateInstance(&pStrings);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<IStrings> pStringsPtr = pStrings;

    if(!IsNoArg(&from)) {
        hr = pStrings->Add(from);
        if(FAILED(hr)) {
            return hr;
        }
    }
    *pDest = pStringsPtr.Detach();
    return S_OK;
}

STDMETHODIMP CDeviceConsole::AttachEvent(/*[in]*/ BSTR eventName,/*[in]*/ LPDISPATCH handler,/*[out, retval]*/ VARIANT_BOOL *pOk)
{
    *pOk = VARIANT_FALSE;
    if(!NotifyWindow()) {
        return E_OUTOFMEMORY;
    }
    return m_Events.AttachEvent(eventName,handler,pOk);
}

STDMETHODIMP CDeviceConsole::DetachEvent(/*[in]*/ BSTR eventName,/*[in]*/ LPDISPATCH handler,/*[out, retval]*/ VARIANT_BOOL *pOk)
{
    return m_Events.DetachEvent(eventName,handler,pOk);
}

CDevConNotifyWindow *CDeviceConsole::NotifyWindow()
{
    if(m_pNotifyWindow) {
        return m_pNotifyWindow;
    }
    m_pNotifyWindow = new CDevConNotifyWindow;
    if(!m_pNotifyWindow) {
        return NULL;
    }
    m_pNotifyWindow->m_pDevCon = this;
    RECT nil;
    nil.top = 0;
    nil.left = 0;
    nil.bottom = 8;
    nil.right = 8;
    if(!m_pNotifyWindow->Create(NULL,nil,NULL)) {
        delete m_pNotifyWindow;
        m_pNotifyWindow = NULL;
        return NULL;
    }
    return m_pNotifyWindow;
}

void CDeviceConsole::FireGlobalEvent(WPARAM wParam)
{
    switch(wParam) {
    case DBT_DEVNODES_CHANGED:
        m_Events.Invoke(L"OnDeviceNodesChanged",0,NULL);
        break;
    }
}


HRESULT CEventsDispEntry::AttachEvent(LPDISPATCH pDisp,VARIANT_BOOL *pStatus)
{
    try {
        *pStatus = VARIANT_FALSE;
        push_back(pDisp);
        *pStatus = VARIANT_TRUE;
    } catch(std::bad_alloc) {
        return E_OUTOFMEMORY;
    } catch(...) {
        return E_INVALIDARG;
    }
    return S_OK;
}

HRESULT CEventsDispEntry::DetachEvent(LPDISPATCH pDisp,VARIANT_BOOL *pStatus)
{
    try {
        *pStatus = VARIANT_FALSE;
        remove(pDisp);
        *pStatus = VARIANT_TRUE;
    } catch(std::bad_alloc) {
        return E_OUTOFMEMORY;
    } catch(...) {
        return E_INVALIDARG;
    }
    return S_OK;
}

HRESULT CEventsDispEntry::Invoke(UINT argc,VARIANT *argv)
{
    CEventsDispEntry::iterator i;
    for(i = begin();i != end();i++) {
        i->Invoke(argc,argv);
    }
    return S_OK;
}

CEventsDispEntry & CEventsMap::LookupNc(LPWSTR Name) throw(std::bad_alloc)
{
    HRESULT hr;
    size_t len = wcslen(Name)+1;
    wchar_t *pBuffer = new wchar_t[len+1];
    if(!pBuffer) {
        throw std::bad_alloc();
    }
    wcscpy(pBuffer,Name);
    _wcsupr(pBuffer);
    std::wstring ind = pBuffer;
    delete [] pBuffer;
    return (*this)[ind];
}

HRESULT CEventsMap::AttachEvent(LPWSTR Name,LPDISPATCH pDisp,VARIANT_BOOL *pStatus)
{
    HRESULT hr;
    try {
        *pStatus = VARIANT_FALSE;
        CEventsDispEntry &Ent = LookupNc(Name);
        hr = Ent.AttachEvent(pDisp,pStatus);
    } catch(std::bad_alloc) {
        return E_OUTOFMEMORY;
    } catch(...) {
        return E_INVALIDARG;
    }

    return hr;
}

HRESULT CEventsMap::DetachEvent(LPWSTR Name,LPDISPATCH pDisp,VARIANT_BOOL *pStatus)
{
    HRESULT hr;
    try {
        *pStatus = VARIANT_FALSE;
        CEventsDispEntry &Ent = LookupNc(Name);
        hr = Ent.DetachEvent(pDisp,pStatus);
    } catch(std::bad_alloc) {
        return E_OUTOFMEMORY;
    } catch(...) {
        return E_INVALIDARG;
    }

    return hr;
}

HRESULT CEventsMap::Invoke(LPWSTR Name,UINT argc,VARIANT *argv)
{
    HRESULT hr;
    try {
        CEventsDispEntry &Ent = LookupNc(Name);
        hr = Ent.Invoke(argc,argv);
    } catch(std::bad_alloc) {
        return E_OUTOFMEMORY;
    } catch(...) {
        return E_INVALIDARG;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\deviceicon.cpp ===
// DeviceIcon.cpp : Implementation of CDeviceIcon

#include "stdafx.h"
#include "DevCon2.h"
#include "DeviceIcon.h"
#include "Device.h"
#include "SetupClass.h"

/////////////////////////////////////////////////////////////////////////////
// CDeviceIcon

//
// SetupDiLoadClassIcon(guid,&hIcon,&miniicon)
// SetupDiDrawMiniIcon(....)
//

void CDeviceIcon::ResetIcon()
{
	if(m_hIcon) {
		DestroyIcon(m_hIcon);
		m_hIcon = NULL;
	}
	if(m_hSmallImage) {
		DeleteObject(m_hSmallImage);
		m_hSmallImage = NULL;
	}
	if(m_hSmallMask) {
		DeleteObject(m_hSmallMask);
		m_hSmallMask = NULL;
	}
}

HRESULT CDeviceIcon::OnDraw(ATL_DRAWINFO& di)
{
	if(!m_hIcon) {
		return S_OK;
	}
	RECT rect = *(RECT*)di.prcBounds;
	int asp_x;
	int asp_y;
	int asp;
	asp_x = rect.right-rect.left;
	asp_y = rect.bottom-rect.top;
	asp = min(asp_x,asp_y);
	if(asp>=32) {
		asp = 32;
	} else {
		asp = 16;
	}
	rect.left += (asp_x-asp)/2;
	rect.top += (asp_y-asp)/2;
	rect.right = rect.left+asp;
	rect.bottom = rect.top+asp;

	if(asp == 16) {
		//
		// draw mini-icon
		// this is complex because of the way SetupDiDrawMiniIcon works
		// and we want this to be like a real icon when placed on a web page
		//
		DrawMiniIcon(di.hdcDraw,rect,m_MiniIcon);
	} else {
		//
		// draw regular icon
		//
		DrawIcon(di.hdcDraw,rect.left,rect.top,m_hIcon);
	}

	return S_OK;
}


BOOL CDeviceIcon::DrawMiniIcon(HDC hDC, RECT &rect,INT icon)
{
    HBITMAP hbmOld;
    HDC     hdcMem;

	hdcMem = CreateCompatibleDC(hDC);
	if(!hdcMem) {
		return FALSE;
	}
	if(!(m_hSmallImage && m_hSmallMask)) {
		//
		// create bitmaps (once)
		//
		if(!m_hSmallImage) {
			m_hSmallImage = CreateCompatibleBitmap(hDC,rect.right-rect.left,rect.bottom-rect.top);
			if(!m_hSmallImage) {
				DeleteDC(hdcMem);
				return FALSE;
			}
		}
		if(!m_hSmallMask) {
			m_hSmallMask = CreateBitmap(rect.right-rect.left,rect.bottom-rect.top,1,1,NULL);
			if(!m_hSmallMask) {
				DeleteDC(hdcMem);
				return FALSE;
			}
		}
		//
		// obtain the bitmap data (once)
		//
		RECT memRect;
		memRect.left = memRect.top = 0;
		memRect.right = rect.right-rect.left;
		memRect.bottom = rect.bottom-rect.top;
		//
		// mask first
		//
		hbmOld = (HBITMAP)SelectObject(hdcMem,m_hSmallMask);
		SetupDiDrawMiniIcon(hdcMem,memRect,icon,DMI_USERECT|DMI_MASK);
		//
		// now source
		//
		SelectObject(hdcMem,m_hSmallImage);
		SetupDiDrawMiniIcon(hdcMem,memRect,icon,DMI_USERECT);
	} else {
		//
		// select source
		//
		hbmOld = (HBITMAP)SelectObject(hdcMem,m_hSmallImage);
	}	

	//
	// now blt image via mask
	//
	if(GetDeviceCaps(hDC,RASTERCAPS)&RC_BITBLT) {
		//
		// draw icon using mask
		//
		MaskBlt(hDC,
				rect.left,
				rect.top,
				rect.right-rect.left,
				rect.bottom-rect.top,
				hdcMem,
				0,
				0,
				m_hSmallMask,
				0,
				0,
				MAKEROP4(0xAA0029,SRCCOPY) // 0xAA0029 (from MSDN) = transparent
				);
	}
	SelectObject(hdcMem,hbmOld);
	DeleteDC(hdcMem);

	return TRUE;
}


STDMETHODIMP CDeviceIcon::ObtainIcon(LPDISPATCH pSource)
{
	HRESULT hr;
	CComQIPtr<IDeviceInternal> pDevice;
	CComQIPtr<ISetupClassInternal> pSetupClass;
	BSTR pMachine = NULL;
	GUID cls;
	HICON hIcon;
	INT miniIcon;

	if(!pSource) {
		ResetIcon();
		return S_OK;
	}
	pSetupClass = pSource;
	pDevice = pSource;
	
	if(pSetupClass) {
		//
		// obtain icon for specified device/class
		// based on devices class
		//
		hr = pSetupClass->get__Machine(&pMachine);
		if(FAILED(hr)) {
			pMachine = NULL;
		} else {
			hr = pSetupClass->get__ClassGuid(&cls);
		}
		if(FAILED(hr)) {
			cls = GUID_DEVCLASS_UNKNOWN;
		}

		//
		// obtain icon
		//
		if(!SetupDiLoadClassIcon(&cls,&hIcon,&miniIcon)) {
			cls = GUID_DEVCLASS_UNKNOWN;
			if(!SetupDiLoadClassIcon(&cls,&hIcon,&miniIcon)) {
				DWORD err = GetLastError();
				SysFreeString(pMachine);
				return HRESULT_FROM_SETUPAPI(err);
			}
		}
		ResetIcon();
		m_hIcon = hIcon;
		m_MiniIcon = miniIcon;
		FireViewChange();
		if(pMachine) {
			SysFreeString(pMachine);
		}
		return S_OK;


	} else {
		return E_INVALIDARG;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\devices.cpp ===
// Devices.cpp : Implementation of CDevices
#include "stdafx.h"
#include "DevCon2.h"
#include "Devices.h"
#include "Device.h"
#include "DevicesEnum.h"
#include "DevInfoSet.h"
#include "xStrings.h"
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////
// CDevices

CDevices::~CDevices()
{
	DWORD c;
	if(pDevices) {
		for(c=0;c<Count;c++) {
			pDevices[c]->Release();
		}
		delete [] pDevices;
	}
}


STDMETHODIMP CDevices::get_Count(long *pVal)
{
	*pVal = (long)Count;
	return S_OK;
}

STDMETHODIMP CDevices::Item(long Index, LPDISPATCH *ppVal)
{
	*ppVal = NULL;
	DWORD i = (DWORD)Index;
	if(i<1 || i > Count) {
		return E_INVALIDARG;
	}
	i--;
	pDevices[i]->AddRef();
	*ppVal = pDevices[i];

	return S_OK;
}

STDMETHODIMP CDevices::get__NewEnum(IUnknown **ppUnk)
{
	*ppUnk = NULL;
	HRESULT hr;
	CComObject<CDevicesEnum> *pEnum = NULL;
	hr = CComObject<CDevicesEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	pEnum->AddRef();
	if(!pEnum->CopyDevices(pDevices,Count)) {
		pEnum->Release();
		return E_OUTOFMEMORY;
	}

	*ppUnk = pEnum;

	return S_OK;
}


HRESULT CDevices::InternalAdd(LPCWSTR InstanceId)
{
	HRESULT hr;
	DWORD c;
	HDEVINFO hDevInfo = GetDevInfoSet();
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		return E_UNEXPECTED;
	}
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}
	//
	// create the SP_DEVINFO_DATA holder
	//
	CComObject<CDevice> *pDevice = NULL;
	hr = CComObject<CDevice>::CreateInstance(&pDevice);
	if(FAILED(hr)) {
		return hr;
	}
	CComPtr<IDevice> pDevicePtr = pDevice;
	hr = pDevice->Init(DevInfoSet,InstanceId,DeviceConsole);
	if(FAILED(hr)) {
		return hr;
	}
	//
	// see if we have a device already in our list
	// if we have, don't add another copy
	//
	for(c=0;c<Count;c++) {
		if(pDevices[c]->SameAs(pDevice)) {
			return S_OK;
		}
	}

	pDevicePtr.Detach();
	pDevices[Count++] = pDevice;

	return S_OK;
}

STDMETHODIMP CDevices::Add(VARIANT InstanceIds)
{
	CComObject<CStrings> *pStrings = NULL;
	HRESULT hr;
	BSTR str;
	DWORD c;

	hr = CComObject<CStrings>::CreateInstance(&pStrings);
	if(FAILED(hr)) {
		return hr;
	}
	CComPtr<IStrings> pStringsPtr = pStrings;

	hr = pStrings->Add(InstanceIds);
	if(FAILED(hr)) {
		return hr;
	}

	for(c=0;pStrings->InternalEnum(c,&str);c++) {
		//
		// convert string to interface
		//
		hr = InternalAdd(str);
		if(FAILED(hr)) {
			return hr;
		}
	}
	return S_OK;
}

STDMETHODIMP CDevices::Remove(VARIANT Index)
{
	//
	// remove from logical list
	// removal from HDEVINFO based on refcounting
	//
	DWORD i;
	HRESULT hr;
	hr = GetIndex(&Index,&i);
	if(FAILED(hr)) {
		return hr;
	}
	if(i >= Count) {
		return E_INVALIDARG;
	}
	pDevices[i]->Release();
	Count--;
	DWORD c;
	for(c=i;c<Count;c++) {
		pDevices[c] = pDevices[c+1];
	}

	return S_OK;
}

HRESULT CDevices::Init(HDEVINFO hDevInfo,IDeviceConsole *pDevCon)
{
	SP_DEVINFO_DATA DeviceInfoData;
	Reset();
	DWORD c;
	HRESULT hr;

	CComObject<CDevInfoSet> *d;
	hr = CComObject<CDevInfoSet>::CreateInstance(&d);
	if(FAILED(hr)) {
		SetupDiDestroyDeviceInfoList(hDevInfo);
		return hr;
	}
	DeviceConsole = pDevCon;
	DevInfoSet = d; // addref's
	d->Init(hDevInfo);

	ZeroMemory(&DeviceInfoData,sizeof(DeviceInfoData));
	DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	for(c=0;SetupDiEnumDeviceInfo(hDevInfo,c,&DeviceInfoData);c++) {
		if(!IncreaseArraySize(1)) {
			Reset();
			return E_OUTOFMEMORY;
		}
		CComObject<CDevice> *pDevice = NULL;
		hr = CComObject<CDevice>::CreateInstance(&pDevice);
		if(FAILED(hr)) {
			Reset();
			return hr;
		}
		pDevice->AddRef();
		pDevices[Count++] = pDevice;
		hr = pDevice->Init(DevInfoSet,&DeviceInfoData,DeviceConsole);
		if(FAILED(hr)) {
			Reset();
			return hr;
		}		
	}
	return Count ? S_OK : S_FALSE;
}

WINSETUPAPI BOOL WINAPI
  SetupDiEnumDeviceInfo(
    IN HDEVINFO  DeviceInfoSet,
    IN DWORD  MemberIndex,
    OUT PSP_DEVINFO_DATA  DeviceInfoData
    );

void CDevices::Reset()
{
	DWORD c;
	for(c=0;c<Count;c++) {
		pDevices[c]->Release();
	}
	Count = 0;
	DevInfoSet = NULL;
}

BOOL CDevices::IncreaseArraySize(DWORD add)
{
 	CDevice** pNewDevices;
 	DWORD Inc;
 	DWORD c;
 
 	if((ArraySize-Count)>=add) {
 		return TRUE;
 	}
 	Inc = ArraySize + add + 32;
 	pNewDevices = new CDevice*[Inc];
 	if(!pNewDevices) {
 		return FALSE;
 	}
 	for(c=0;c<Count;c++) {
 		pNewDevices[c] = pDevices[c];
 	}
 	delete [] pDevices;
 	pDevices = pNewDevices;
 	ArraySize = Inc;
 	return TRUE;
}

STDMETHODIMP CDevices::CreateRootDevice(VARIANT hwidParam, LPDISPATCH *pDispatch)
{
	*pDispatch = NULL;

	HRESULT hr;
	DWORD len;
	DWORD Err;
	LPWSTR hwidlist = NULL;
	CComObject<CDevice> *pDevice = NULL;
	HDEVINFO hDevInfo;
	SP_DEVINFO_DATA DeviceInfoData;
	WCHAR name[33];
	DWORD c,cc;
	LPCWSTR lastPart;
	LPCWSTR hwid;
	CComVariant hwid_v;
	LPCGUID pGuid = NULL;

	//
	// prepare list if we need to
	//
	hDevInfo = GetDevInfoSet();
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		return E_UNEXPECTED;
	}
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}

	hr = GetOptionalString(&hwidParam,hwid_v,&hwid);
	if(FAILED(hr)) {
		return hr;
	}

	//
	// see if this devices collection is associated with a setup class
	//
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) {
		DWORD Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

	if(memcmp(&devInfoListDetail.ClassGuid,&GUID_NULL,sizeof(devInfoListDetail.ClassGuid)) != 0) {
		//
		// collection is locked to a class, use that class to create device
		//
		pGuid = &devInfoListDetail.ClassGuid;
	} else {
		//
		// class is unknown
		//
		pGuid = &GUID_DEVCLASS_UNKNOWN;
	}

	if(hwid) {
		//
		// use hwid as basis of name
		// this really has no significant meaning, but helps for diagnostics
		// another option would be to use class name
		// be we don't know classname here
		//
		lastPart = wcsrchr(hwid,L'\\');
		if(!lastPart) {
			lastPart = hwid;
		}
		for(c=0,cc=0;c<16;c++) {
			//
			// ignore troublesome characters
			//
			while(lastPart[cc] &&
					((lastPart[cc] == L'/')
					|| (lastPart[cc] == L'\\')
					|| (lastPart[cc] == L'#')
					|| (lastPart[cc] >= 0x7f)
					|| (lastPart[cc] <= 0x20)
					)) {
				cc++;
			}
			if(!hwid[cc]) {
				break;
			}
			name[c] = hwid[cc];
		}
	} else {
		c = 0;
	}
	if(c) {
		name[c] = L'0';
	} else {
		wcscpy(name,L"NONAME");	
	}

	ZeroMemory(&DeviceInfoData,sizeof(DeviceInfoData));
	DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	if (!SetupDiCreateDeviceInfo(hDevInfo,
		name,
		pGuid,
		NULL,
		0,
		DICD_GENERATE_ID,
		&DeviceInfoData))
	{
		Err = GetLastError();
		hr = HRESULT_FROM_SETUPAPI(Err);
		return hr;
	}

	if(hwid && hwid[0]) {
		//
		// Add the HardwareID to the Device's HardwareID property.
		//
		len = wcslen(hwid);
		hwidlist = new WCHAR[len+2];
		if(!hwidlist) {
			hr = E_OUTOFMEMORY;
			goto final;
		}
		wcsncpy(hwidlist,hwid,len+1);
		hwidlist[len] = L'\0';
		hwidlist[len+1] = L'\0';
		
		if(!SetupDiSetDeviceRegistryProperty(hDevInfo,
 											&DeviceInfoData,
											SPDRP_HARDWAREID,
											(LPBYTE)hwidlist,
											(len+2)*sizeof(TCHAR)))
		{
			Err = GetLastError();
			hr = HRESULT_FROM_SETUPAPI(Err);
			goto final;
		}
	}

	//
	// Transform the registry element into an actual devnode
	// in the PnP HW tree.
	//
	if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
									hDevInfo,
									&DeviceInfoData))
	{
		Err = GetLastError();
		hr = HRESULT_FROM_SETUPAPI(Err);
		goto final;
	}

	//
	// create the SP_DEVINFO_DATA holder
	//
	hr = CComObject<CDevice>::CreateInstance(&pDevice);
	if(FAILED(hr)) {
		return hr;
	}
	pDevice->AddRef();
	hr = pDevice->Init(DevInfoSet,&DeviceInfoData,DeviceConsole);
	if(FAILED(hr)) {
		pDevice->Release();
		goto final;
	}
	//
	// Add to list
	//
	pDevices[Count++] = pDevice;
	//
	// Return it
	//
	pDevice->AddRef();
	*pDispatch = pDevice;

	hr = S_OK;

final:

	if(hwidlist) {
		delete [] hwidlist;
	}

	if(FAILED(hr)) {
		if(!SetupDiCallClassInstaller(DIF_REMOVE,hDevInfo,&DeviceInfoData)) {
			//
			// if we failed to delete including class/co installers
			// force it
			//
			SetupDiRemoveDevice(hDevInfo,&DeviceInfoData);
		}
	}

	return hr;
}

HDEVINFO CDevices::GetDevInfoSet()
{
	ULONGLONG h;
	HRESULT hr;

	if(!DevInfoSet) {
		return (HDEVINFO)INVALID_HANDLE_VALUE;
	}
	hr = DevInfoSet->get_Handle(&h);
	if(FAILED(hr)) {
		return (HDEVINFO)INVALID_HANDLE_VALUE;
	}
	return (HDEVINFO)h;
}

HRESULT CDevices::GetIndex(LPVARIANT Index,DWORD * pAt)
{
	CComVariant v;
	HRESULT hr;
	if(IsNumericVariant(Index)) {
		hr = v.ChangeType(VT_I4,Index);
		if(FAILED(hr)) {
			return DISP_E_TYPEMISMATCH;
		}
		if(V_I4(&v)<1) {
			return E_INVALIDARG;
		}
		*pAt = ((DWORD)V_I4(&v))-1;
		return S_OK;
	}
	//
	// user actually supplied instance id
	//
	hr = v.ChangeType(VT_BSTR,Index);
	if(FAILED(hr)) {
		return DISP_E_TYPEMISMATCH;
	}
	if(!Count) {
		//
		// cannot match anything
		//
		return E_INVALIDARG;
	}
	//
	// find an existing device that matches this
	//
	DWORD c;
	for(c=0;c<Count;c++) {
		if(pDevices[c]->SameAs(V_BSTR(&v))) {
			*pAt = c;
			return S_OK;
		}
	}
	//
	// none found
	//
	return E_INVALIDARG;
}

STDMETHODIMP CDevices::get_Machine(BSTR *pVal)
{
	HDEVINFO hDevInfo = GetDevInfoSet();
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		return E_UNEXPECTED;
	}

    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) {
		DWORD Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

	if((devInfoListDetail.RemoteMachineHandle == NULL) || !devInfoListDetail.RemoteMachineName[0]) {
		*pVal = SysAllocString(L"");
		if(*pVal) {
			return S_FALSE;
		}
	} else {
		*pVal = SysAllocString(devInfoListDetail.RemoteMachineName);
		if(*pVal) {
			return S_OK;
		}
	}
	*pVal = NULL;
	return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\devices.h ===
// Devices.h : Declaration of the CDevices

#ifndef __DEVICES_H_
#define __DEVICES_H_

#include "resource.h"       // main symbols

class CDevice;
/////////////////////////////////////////////////////////////////////////////
// CDevices
class ATL_NO_VTABLE CDevices : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDevices, &CLSID_Devices>,
	public IDispatchImpl<IDevices, &IID_IDevices, &LIBID_DEVCON2Lib>
{
public:
	CComPtr<IDevInfoSet> DevInfoSet;
	CComPtr<IDeviceConsole> DeviceConsole;
	CDevice **pDevices;
	ULONG  ArraySize;
	ULONG  Count;

public:
	CDevices()
	{
		pDevices = NULL;
		ArraySize = 0;
		Count = 0;
	}
	~CDevices();

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICES)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDevices)
	COM_INTERFACE_ENTRY(IDevices)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDevices
public:
	STDMETHOD(get_Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(CreateRootDevice)(/*[in]*/ VARIANT hwid,/*[out,retval]*/ LPDISPATCH *pDispatch);
	STDMETHOD(Remove)(/*[in]*/ VARIANT Index);
	STDMETHOD(Add)(/*[in]*/ VARIANT InstanceIds);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** ppUnk);
	STDMETHOD(Item)(/*[in]*/ long Index,/*[out, retval]*/ LPDISPATCH * ppVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

	//
	// helpers
	//
	HRESULT InternalAdd(LPCWSTR InstanceId);
	BOOL IncreaseArraySize(DWORD add);
	void Reset();
	HRESULT Init(HDEVINFO hDevInfo,IDeviceConsole *pDevCon);
	HRESULT GetIndex(LPVARIANT Index,DWORD * pAt);
	HDEVINFO GetDevInfoSet();
};

#endif //__DEVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\devicesenum.cpp ===
// DevicesEnum.cpp : Implementation of CDevCon2App and DLL registration.

#include "stdafx.h"
#include "DevCon2.h"
#include "Device.h"
#include "Devices.h"
#include "DevicesEnum.h"

/////////////////////////////////////////////////////////////////////////////
//
CDevicesEnum::~CDevicesEnum()
{
	DWORD c;
	if(pDevices) {
		for(c=0;c<Count;c++) {
			pDevices[c]->Release();
		}
		delete [] pDevices;
	}
}


HRESULT CDevicesEnum::Next(
                ULONG celt,
                VARIANT * rgVar,
                ULONG * pCeltFetched
            )
{
	ULONG fetched;
	CDevice *pDev;
	if(pCeltFetched) {
		*pCeltFetched = 0;
	}
	for(fetched = 0; fetched<celt && Position<Count ; fetched++,Position++) {
		VariantInit(&rgVar[fetched]);

		pDev = pDevices[Position];
		pDev->AddRef();
		V_VT(&rgVar[fetched]) = VT_DISPATCH;
		V_DISPATCH(&rgVar[fetched]) = pDev;
	}
	if(pCeltFetched) {
		*pCeltFetched = fetched;
	}
	return (fetched<celt) ? S_FALSE : S_OK;
}

HRESULT CDevicesEnum::Skip(
                ULONG celt
            )
{
	DWORD remaining = Count-Position;
	if(remaining<celt) {
		Position = Count;
		return S_FALSE;
	} else {
		Position += (DWORD)celt;
		return S_OK;
	}
}

HRESULT CDevicesEnum::Reset(
            )
{
	Position = 0;
	return S_OK;
}

HRESULT CDevicesEnum::Clone(
                IEnumVARIANT ** ppEnum
            )
{
	*ppEnum = NULL;
	HRESULT hr;
	CComObject<CDevicesEnum> *pEnum = NULL;
	hr = CComObject<CDevicesEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	if(!pEnum->CopyDevices(pDevices,Count)) {
		delete pEnum;
		return E_OUTOFMEMORY;
	}
	pEnum->Position = Position;

	pEnum->AddRef();
	*ppEnum = pEnum;

	return S_OK;
}


BOOL CDevicesEnum::CopyDevices(CDevice **pArray, DWORD NewCount)
{
	DWORD c;

	if(pDevices) {
		delete [] pDevices;
		pDevices = NULL;
	}
	Count = 0;
	Position = 0;
	pDevices = new CDevice*[NewCount];
	if(!pDevices) {
		return FALSE;
	}
	for(c=0;c<NewCount;c++) {
		pArray[c]->AddRef();
		pDevices[c] = pArray[c];
		if(!pDevices[c]) {
			Count = c;
			return FALSE;
		}
	}
	Count = NewCount;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\deviceicon.h ===
// DeviceIcon.h : Declaration of the CDeviceIcon

#ifndef __DEVICEICON_H_
#define __DEVICEICON_H_

#include "resource.h"       // main symbols
#include <atlctl.h>


/////////////////////////////////////////////////////////////////////////////
// CDeviceIcon
class ATL_NO_VTABLE CDeviceIcon : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDeviceIcon, &IID_IDeviceIcon, &LIBID_DEVCON2Lib>,
	public CComControl<CDeviceIcon>,
	public IPersistStreamInitImpl<CDeviceIcon>,
	public IOleControlImpl<CDeviceIcon>,
	public IOleObjectImpl<CDeviceIcon>,
	public IOleInPlaceActiveObjectImpl<CDeviceIcon>,
	public IViewObjectExImpl<CDeviceIcon>,
	public IOleInPlaceObjectWindowlessImpl<CDeviceIcon>,
	public IPersistStorageImpl<CDeviceIcon>,
	public ISpecifyPropertyPagesImpl<CDeviceIcon>,
	public IQuickActivateImpl<CDeviceIcon>,
	public IDataObjectImpl<CDeviceIcon>,
	public IProvideClassInfo2Impl<&CLSID_DeviceIcon, NULL, &LIBID_DEVCON2Lib>,
	public CComCoClass<CDeviceIcon, &CLSID_DeviceIcon>
{
protected:
	HICON m_hIcon;
    HBITMAP m_hSmallImage;
	HBITMAP m_hSmallMask;
	INT   m_MiniIcon;
public:
	CDeviceIcon()
	{
		m_hIcon = NULL;
		m_MiniIcon = 0;
		m_hSmallImage = NULL;
		m_hSmallMask = NULL;
	}
	~CDeviceIcon()
	{
		ResetIcon();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICEICON)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDeviceIcon)
	COM_INTERFACE_ENTRY(IDeviceIcon)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

	public:

BEGIN_PROP_MAP(CDeviceIcon)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CDeviceIcon)
	CHAIN_MSG_MAP(CComControl<CDeviceIcon>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	HRESULT OnDraw(ATL_DRAWINFO& di);


// IViewObjectEx
	DECLARE_VIEW_STATUS(0)

// IDeviceIcon
public:
	BOOL DrawMiniIcon(HDC hDC,RECT & rect,INT icon);
	STDMETHOD(ObtainIcon)(/*[in]*/ LPDISPATCH pSource);
	void ResetIcon();

};

#endif //__DEVICEICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\deviceconsole.h ===
// DeviceConsole.h : Declaration of the CDeviceConsole

#ifndef __DEVICECONSOLE_H_
#define __DEVICECONSOLE_H_

#include "resource.h"       // main symbols

#define UM_POSTEVENTS      (WM_USER+101)
#define UM_POSTGLOBALEVENT (WM_USER+102)

class CEventsDispEntry;
class CEventsMap;
class CDispHandlerEvent;
class CDispHandlerCallback;
class CDispInterfaceHandlers;
class CDeviceConsole;

class CEventsDispPtr
{
private:
    CComQIPtr<IDispatch> m_Dispatch;

public:
    //
    // I have to use const due to way STL works
    // however I need to cast away const for ref-counting
    // *sigh*
    //
    CEventsDispPtr(const IDispatch*p) {
        m_Dispatch = (IDispatch*)p;
    }
    CEventsDispPtr(const CEventsDispPtr & p) {
        m_Dispatch = (IDispatch*)p.m_Dispatch;
    }
    bool operator==(const CEventsDispPtr & p) const {
        return m_Dispatch == p.m_Dispatch;
    }
    HRESULT Invoke(UINT argc,VARIANT * argv) {
        if(!m_Dispatch) {
            return S_FALSE;
        }
        DISPPARAMS DispParams;
        UINT Err;
        HRESULT hr;
        DispParams.cArgs = argc;
        DispParams.cNamedArgs = 0;
        DispParams.rgdispidNamedArgs = NULL;
        DispParams.rgvarg = argv;

        hr = m_Dispatch->Invoke(0,IID_NULL,0,DISPATCH_METHOD,&DispParams,NULL,NULL,&Err);
        return hr;
    }

};


//
// attachEvent detachEvent operation
//
class CEventsDispEntry : public std::list<CEventsDispPtr>
{
public:
    HRESULT AttachEvent(LPDISPATCH pDisp,VARIANT_BOOL *pStatus);
    HRESULT DetachEvent(LPDISPATCH pDisp,VARIANT_BOOL *pStatus);
    HRESULT Invoke(UINT argc,VARIANT *argv);
};

class CEventsMap : public std::map<std::wstring,CEventsDispEntry>
{
public:
    HRESULT AttachEvent(LPWSTR Name,LPDISPATCH pDisp,VARIANT_BOOL *pStatus);
    HRESULT DetachEvent(LPWSTR Name,LPDISPATCH pDisp,VARIANT_BOOL *pStatus);
    HRESULT Invoke(LPWSTR Name,UINT argc,VARIANT *argv);
    CEventsDispEntry & LookupNc(LPWSTR Name) throw(std::bad_alloc);
};

//
// map of interface/handle and callbacks
//
class CDispInterfaceHandlers
{
public:
    CDispInterfaceHandlers *m_pPrev;
    CDispInterfaceHandlers *m_pNext;
    GUID m_InterfaceClass;
    HDEVNOTIFY m_hNotify;
    CDispHandlerCallback *m_pFirstCallback;
    CDispHandlerCallback *m_pLastCallback;

    CDispHandlerEvent *m_pFirstEvent;
    CDispHandlerEvent *m_pLastEvent;

public:
    CDispInterfaceHandlers() {
    }

    ~CDispInterfaceHandlers() {
    }

};

class CDispHandlerCallback
{
public:
    CDispHandlerCallback *m_pPrev;
    CDispHandlerCallback *m_pNext;

public:
    CDispHandlerCallback() {
    }

    ~CDispHandlerCallback() {
    }

    virtual void DeviceEvent(CDispHandlerEvent * pEvent) = 0;
};

class CDispHandlerEvent
{
public:
    CDispHandlerEvent *m_pNext;
    BSTR m_Device;
    WPARAM m_Event;

    CDispHandlerEvent() {
    }
    ~CDispHandlerEvent() {
    }
};

typedef CWinTraits<WS_POPUP,0> CPopupWinTraits;

class CDevConNotifyWindow :
    public CWindowImpl<CDevConNotifyWindow,CWindow,CPopupWinTraits>
{
public:
    CDeviceConsole *m_pDevCon;

public:
    CDevConNotifyWindow() {
        m_pDevCon = NULL;
    }

   BEGIN_MSG_MAP(CDevConNotifyWindow)
      MESSAGE_HANDLER(WM_DEVICECHANGE,    OnDeviceChange)
      MESSAGE_HANDLER(UM_POSTEVENTS,      OnPostEvents)
      MESSAGE_HANDLER(UM_POSTGLOBALEVENT, OnPostGlobalEvent)
   END_MSG_MAP()

   LRESULT OnDeviceChange(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
   LRESULT OnPostEvents(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
   LRESULT OnPostGlobalEvent(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

/////////////////////////////////////////////////////////////////////////////
// CDeviceConsole
class ATL_NO_VTABLE CDeviceConsole :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDeviceConsole, &CLSID_DeviceConsole>,
    public IDispatchImpl<IDeviceConsole, &IID_IDeviceConsole, &LIBID_DEVCON2Lib>
{
public:
    VARIANT_BOOL RebootRequired;
    CEventsMap m_Events;

    CDevConNotifyWindow *m_pNotifyWindow;

    CDispInterfaceHandlers *m_pFirstWatch;
    CDispInterfaceHandlers *m_pLastWatch;

    CDeviceConsole()
    {
        m_pNotifyWindow = NULL;
        m_pFirstWatch = NULL;
        m_pLastWatch = NULL;
        RebootRequired = VARIANT_FALSE;
    }
    ~CDeviceConsole()
    {
        if(m_pNotifyWindow) {
            m_pNotifyWindow->DestroyWindow();
            delete m_pNotifyWindow;
        }
    }

    CDevConNotifyWindow *NotifyWindow();

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICECONSOLE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDeviceConsole)
    COM_INTERFACE_ENTRY(IDeviceConsole)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDeviceConsole
public:
    void FireGlobalEvent(WPARAM wParam);
    STDMETHOD(AttachEvent)(/*[in]*/ BSTR eventName,/*[in]*/ LPDISPATCH handler,/*[out, retval]*/ VARIANT_BOOL *pOk);
    STDMETHOD(DetachEvent)(/*[in]*/ BSTR eventName,/*[in]*/ LPDISPATCH handler,/*[out, retval]*/ VARIANT_BOOL *pOk);
    STDMETHOD(StringList)(/*[in]*/ VARIANT from,/*[out,retval]*/ LPDISPATCH *pDest);
    STDMETHOD(DevicesByInstanceIds)(/*[in]*/ VARIANT InstanceIdList,/*[in,optional]*/ VARIANT machine,/*[out,retval]*/ LPDISPATCH *pDevList);
    STDMETHOD(DevicesByInterfaceClasses)(/*[in]*/ VARIANT InterfaceClasses,/*[in,optional]*/ VARIANT machine,/*[out,retval]*/ LPDISPATCH * pDevices);
    STDMETHOD(DevicesBySetupClasses)(/*[in]*/ VARIANT SetupClasses,/*[in,optional]*/ VARIANT flags,/*[in,optional]*/ VARIANT machine,/*[out,retval]*/ LPDISPATCH * pDevices);
    STDMETHOD(CreateEmptySetupClassList)(/*[in,optional]*/ VARIANT machine,/*[out,retval]*/ LPDISPATCH * pResult);
    STDMETHOD(SetupClasses)(/*[in,optional]*/ VARIANT match,/*[in,optional]*/ VARIANT machine,/*[retval,out]*/ LPDISPATCH *pDevices);
    STDMETHOD(get_RebootRequired)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_RebootRequired)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(RebootReasonHardware)();
    STDMETHOD(CheckReboot)();
    STDMETHOD(UpdateDriver)(/*[in]*/ BSTR infname,/*[in]*/ BSTR hwid,/*[in,optional]*/ VARIANT flags);
    STDMETHOD(CreateEmptyDeviceList)(/*[in,optional]*/ VARIANT machine,/*[retval,out]*/ LPDISPATCH *pDevices);
    STDMETHOD(AllDevices)(/*[in]*/ VARIANT flags,/*[in]*/ VARIANT machine,/*[retval,out]*/ LPDISPATCH *pDevices);

    //
    // helpers
    //
    HRESULT BuildDeviceList(HDEVINFO hDevInfo, LPDISPATCH *pDevices);
};

#endif //__DEVICECONSOLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\devicesenum.h ===
// DevicesEnum.h: Definition of the CDevicesEnum class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DEVICESENUM_H__F9048FCD_C525_4BDD_AB79_018DEE3B71E8__INCLUDED_)
#define AFX_DEVICESENUM_H__F9048FCD_C525_4BDD_AB79_018DEE3B71E8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDevicesEnum

class CDevice;

class ATL_NO_VTABLE CDevicesEnum : 
	public IDevicesEnum,
	public CComObjectRootEx<CComSingleThreadModel>
{
protected:
	CDevice** pDevices;
	DWORD Count;
	DWORD Position;

public:
	BOOL CopyDevices(CDevice **pArray,DWORD Count);

	CDevicesEnum() {
		pDevices = NULL;
		Count = 0;
		Position = 0;
	}
	~CDevicesEnum();

BEGIN_COM_MAP(CDevicesEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
	COM_INTERFACE_ENTRY(IDevicesEnum)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CDevicesEnum) 

// IDevicesEnum
public:
    STDMETHOD(Next)(
                /*[in]*/ ULONG celt,
                /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar,
                /*[out]*/ ULONG * pCeltFetched
            );
    STDMETHOD(Skip)(
                /*[in]*/ ULONG celt
            );

    STDMETHOD(Reset)(
            );

    STDMETHOD(Clone)(
                /*[out]*/ IEnumVARIANT ** ppEnum
            );
};

#endif // !defined(AFX_DEVICESENUM_H__F9048FCD_C525_4BDD_AB79_018DEE3B71E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\devinfoset.cpp ===
// DevInfoSet.cpp : Implementation of CDevCon2App and DLL registration.

#include "stdafx.h"
#include "DevCon2.h"
#include "DevInfoSet.h"

/////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP CDevInfoSet::get_Handle(ULONGLONG *pVal)
{
	HDEVINFO h = Handle();
	*pVal = (ULONGLONG)h;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\devinfoset.h ===
// DevInfoSet.h: Definition of the CDevInfoSet class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DEVINFOSET_H__7973729E_46E1_4B31_B15E_7B702679AC64__INCLUDED_)
#define AFX_DEVINFOSET_H__7973729E_46E1_4B31_B15E_7B702679AC64__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDevInfoSet

class ATL_NO_VTABLE CDevInfoSet : 
	public IDevInfoSet,
	public CComObjectRootEx<CComSingleThreadModel>
{
public:
	HDEVINFO hDevInfo;
public:
	CDevInfoSet() {
		//
		// use NULL to indicate uninitialized vs failed to initialize
		//
		hDevInfo = NULL;
	}
	~CDevInfoSet() {
		if(hDevInfo != INVALID_HANDLE_VALUE && hDevInfo != NULL) {
			SetupDiDestroyDeviceInfoList(hDevInfo);
		}
	}
	BOOL Init(HDEVINFO Handle) {
		hDevInfo = Handle;
		return TRUE;
	}
	HDEVINFO Handle() {
		//
		// initialize on demand
		//
		if(hDevInfo == NULL) {
			hDevInfo = SetupDiCreateDeviceInfoList(NULL,NULL);
		}
		return hDevInfo;
	}

DECLARE_NOT_AGGREGATABLE(CDevInfoSet) 

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDevInfoSet)
	COM_INTERFACE_ENTRY(IDevInfoSet)
END_COM_MAP()

// IDevInfoSet
public:
	STDMETHOD(get_Handle)(/*[out, retval]*/ ULONGLONG *pVal);
};

#endif // !defined(AFX_DEVINFOSET_H__7973729E_46E1_4B31_B15E_7B702679AC64__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "DevCon2_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__2465E4C1_F3FF_47A4_9F80_D934F4E50C48__INCLUDED_)
#define AFX_DLLDATAX_H__2465E4C1_F3FF_47A4_9F80_D934F4E50C48__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__2465E4C1_F3FF_47A4_9F80_D934F4E50C48__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\driver.cpp ===
// Driver.cpp : Implementation of CDriverPackage
#include "stdafx.h"
#include "DevCon2.h"
#include "Driver.h"
#include "Device.h"
#include "DrvSearchSet.h"
#include "xStrings.h"

/////////////////////////////////////////////////////////////////////////////
// CDriverPackage

CDriverPackage::~CDriverPackage()
{
	if(pDrvSearchSet) {
		pDrvSearchSet->Release();
	}
}

HRESULT CDriverPackage::Init(CDrvSearchSet *pSet,PSP_DRVINFO_DATA pDrvInfoData)
{
	if(pDrvSearchSet) {
		pDrvSearchSet->Release();
	}
	pDrvSearchSet = NULL;
	if(!pSet) {
		return E_UNEXPECTED;
	}
	pSet->AddRef();
	pDrvSearchSet = pSet;
	if(pDrvInfoData) {
		DrvInfoData = *pDrvInfoData;
	} else {
		DrvInfoData.cbSize = 0;
	}
	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Description(BSTR *pVal)
{
	*pVal = SysAllocString(DrvInfoData.Description);
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Manufacturer(BSTR *pVal)
{
	*pVal = SysAllocString(DrvInfoData.MfgName);
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Provider(BSTR *pVal)
{
	*pVal = SysAllocString(DrvInfoData.ProviderName);
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Date(DATE *pVal)
{
	//
	// work out ticks to translate to Dec 30 1899
	//
	SYSTEMTIME sysTime;
	FILETIME ref_zero;
	FILETIME ref_one;
	ULARGE_INTEGER i_zero;
	ULARGE_INTEGER i_one;
	ULARGE_INTEGER i_act;

	sysTime.wYear = 1899;
	sysTime.wMonth = 12;
	sysTime.wDayOfWeek = 0;
	sysTime.wDay = 30;
	sysTime.wHour = 0;
	sysTime.wMinute = 0;
	sysTime.wSecond = 0;
	sysTime.wMilliseconds = 0;

	if(!SystemTimeToFileTime(&sysTime,&ref_zero)) {
		return E_UNEXPECTED;
	}

	i_zero.LowPart = ref_zero.dwLowDateTime;
	i_zero.HighPart = ref_zero.dwHighDateTime;

	sysTime.wYear = 1899;
	sysTime.wMonth = 12;
	sysTime.wDay = 31;

	if(!SystemTimeToFileTime(&sysTime,&ref_one)) {
		return E_UNEXPECTED;
	}

	i_one.LowPart = ref_one.dwLowDateTime;
	i_one.HighPart = ref_one.dwHighDateTime;
	i_one.QuadPart -= i_zero.QuadPart;

	//
	// now the real FILETIME
	//

	i_act.LowPart = DrvInfoData.DriverDate.dwLowDateTime;
	i_act.HighPart = DrvInfoData.DriverDate.dwHighDateTime;
	double dbl = (double)(__int64)i_act.QuadPart;
	dbl -= (double)(__int64)i_zero.QuadPart;
	dbl /= (double)(__int64)i_one.QuadPart;

	*pVal = dbl;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Version(BSTR *pVal)
{
	WCHAR fmt[64];
	ULARGE_INTEGER i;
	i.QuadPart = DrvInfoData.DriverVersion;
	swprintf(fmt,L"%u.%u.%u.%u",
					HIWORD(i.HighPart),
					LOWORD(i.HighPart),
					HIWORD(i.LowPart),
					LOWORD(i.LowPart));
	*pVal = SysAllocString(fmt);

	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_ScriptName(BSTR *pVal)
{
	SP_DRVINFO_DETAIL_DATA detail;
	detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
	if(!SetupDiGetDriverInfoDetail(pDrvSearchSet->GetDevInfoSet(),
									 pDrvSearchSet->GetDevInfoData(),
									 &DrvInfoData,
									 &detail,
									 sizeof(detail),
									 NULL)) {
		DWORD Err = GetLastError();
		if(Err != ERROR_INSUFFICIENT_BUFFER) {
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}
	HINF hInf = SetupOpenInfFile(detail.InfFileName,
									NULL,
									INF_STYLE_WIN4|INF_STYLE_OLDNT,
									NULL);
	if(hInf == INVALID_HANDLE_VALUE) {
		DWORD Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
	WCHAR buf[LINE_LEN];
	if(!SetupDiGetActualSectionToInstall(hInf,detail.SectionName,buf,LINE_LEN,NULL,NULL)) {
		SetupCloseInfFile(hInf);
		return E_UNEXPECTED;
	}
	*pVal = SysAllocString(buf);

	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_ScriptFile(BSTR *pVal)
{
	SP_DRVINFO_DETAIL_DATA detail;
	detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
	if(!SetupDiGetDriverInfoDetail(pDrvSearchSet->GetDevInfoSet(),
									 pDrvSearchSet->GetDevInfoData(),
									 &DrvInfoData,
									 &detail,
									 sizeof(detail),
									 NULL)) {
		DWORD Err = GetLastError();
		if(Err != ERROR_INSUFFICIENT_BUFFER) {
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}

	*pVal = SysAllocString(detail.InfFileName);
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_HardwareIds(LPDISPATCH *pVal)
{
	PSP_DRVINFO_DETAIL_DATA pDetail;
	LPBYTE buffer = NULL;
	DWORD memsz = 8192;
	HRESULT hr;
	DWORD Err;

	for(;;) {
		buffer = new BYTE[memsz+sizeof(WCHAR)*2];
		if(!buffer) {
			return E_OUTOFMEMORY;
		}

		pDetail = (PSP_DRVINFO_DETAIL_DATA)buffer;
		ZeroMemory(pDetail,memsz+sizeof(WCHAR)*2);
		pDetail->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

		if(!SetupDiGetDriverInfoDetail(pDrvSearchSet->GetDevInfoSet(),
										 pDrvSearchSet->GetDevInfoData(),
										 &DrvInfoData,
										 pDetail,
										 memsz,
										 &memsz)) {
			Err = GetLastError();
			if(Err != ERROR_INSUFFICIENT_BUFFER) {
				delete [] buffer;
				return HRESULT_FROM_SETUPAPI(Err);
			}			
		} else {
			break;
		}
		delete [] buffer;
	}

	if(pDetail->CompatIDsLength) {
		pDetail->HardwareID[pDetail->CompatIDsOffset] = L'\0';
	}
	
	//
	// now build multisz of hardware ID's
	//
	CComObject<CStrings> *strings;
	hr = CComObject<CStrings>::CreateInstance(&strings);
	if(FAILED(hr)) {
		delete [] buffer;
		return hr;
	}
	strings->AddRef();
	hr = strings->FromMultiSz(pDetail->HardwareID);
	delete [] buffer;
	
	if(FAILED(hr)) {
		strings->Release();
		return hr;
	}
	*pVal = strings;
	return S_OK;
}

STDMETHODIMP CDriverPackage::get_CompatibleIds(LPDISPATCH *pVal)
{
	PSP_DRVINFO_DETAIL_DATA pDetail;
	LPBYTE buffer = NULL;
	DWORD memsz = 8192;
	HRESULT hr;
	DWORD Err;

	for(;;) {
		buffer = new BYTE[memsz+sizeof(WCHAR)*2];
		if(!buffer) {
			return E_OUTOFMEMORY;
		}

		pDetail = (PSP_DRVINFO_DETAIL_DATA)buffer;
		ZeroMemory(pDetail,memsz+sizeof(WCHAR)*2);
		pDetail->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

		if(!SetupDiGetDriverInfoDetail(pDrvSearchSet->GetDevInfoSet(),
										 pDrvSearchSet->GetDevInfoData(),
										 &DrvInfoData,
										 pDetail,
										 memsz,
										 &memsz)) {
			Err = GetLastError();
			if(Err != ERROR_INSUFFICIENT_BUFFER) {
				delete [] buffer;
				return HRESULT_FROM_SETUPAPI(Err);
			}			
		} else {
			break;
		}
		delete [] buffer;
	}

	//
	// now build multisz of hardware ID's
	//
	CComObject<CStrings> *strings;
	hr = CComObject<CStrings>::CreateInstance(&strings);
	if(FAILED(hr)) {
		delete [] buffer;
		return hr;
	}
	strings->AddRef();
	if(pDetail->CompatIDsLength) {
		hr = strings->FromMultiSz(pDetail->HardwareID+pDetail->CompatIDsOffset);
	} else {
		hr = S_OK;
	}
	
	delete [] buffer;
	
	if(FAILED(hr)) {
		strings->Release();
		return hr;
	}
	*pVal = strings;
	return S_OK;
}

STDMETHODIMP CDriverPackage::get_DriverDescription(BSTR *pVal)
{
	SP_DRVINFO_DETAIL_DATA detail;
	detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
	if(!SetupDiGetDriverInfoDetail(pDrvSearchSet->GetDevInfoSet(),
									 pDrvSearchSet->GetDevInfoData(),
									 &DrvInfoData,
									 &detail,
									 sizeof(detail),
									 NULL)) {
		DWORD Err = GetLastError();
		if(Err != ERROR_INSUFFICIENT_BUFFER) {
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}

	*pVal = SysAllocString(detail.DrvDescription);
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

UINT CDriverPackage::GetDriverListCallback(PVOID Context,UINT Notification,UINT_PTR Param1,UINT_PTR Param2)
{
	DriverListCallbackContext *pContext = (DriverListCallbackContext *)Context;
    LPTSTR file = (LPTSTR)Param1;

	pContext->hr = pContext->pList->InternalAdd(file,lstrlen(file));

    return FAILED(pContext->hr) ? ERROR_NO_MORE_ITEMS : NO_ERROR;
}

STDMETHODIMP CDriverPackage::DriverFiles(LPDISPATCH *pDriverFiles)
{
	//
	// if we were to install this driver, where would the files go?
	//
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    HSPFILEQ queueHandle = INVALID_HANDLE_VALUE;
    DWORD scanResult;
	DWORD Err;
	HRESULT hr;

	HDEVINFO hDevInfo = pDrvSearchSet->GetDevInfoSet();
	PSP_DEVINFO_DATA pDevInfoData = pDrvSearchSet->GetDevInfoData();

    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

	//
	// select this driver (expect this to last only as long as this call)
	//
    if(!SetupDiSetSelectedDriver(hDevInfo, pDevInfoData, &DrvInfoData)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // now 'instigate' an install, obtaining all files to be copied into
    // a file queue
    //
    queueHandle = SetupOpenFileQueue();

    if ( queueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // we want to add the files to the file queue, not install them!
    //
    deviceInstallParams.FileQueue = queueHandle;
    deviceInstallParams.Flags |= DI_NOVCP;

    if ( !SetupDiSetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

	//
	// do it
	//
    if ( !SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, hDevInfo, pDevInfoData) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // clear settings
    //
    deviceInstallParams.FileQueue = NULL;
    deviceInstallParams.Flags &= ~DI_NOVCP;
    SetupDiSetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams);

    //
    // we now have a list of delete/rename/copy files
    //
	DriverListCallbackContext context;
	CComObject<CStrings> *strings;
	hr = CComObject<CStrings>::CreateInstance(&strings);
	if(FAILED(hr)) {
		SetupCloseFileQueue(queueHandle);
		return hr;
	}
	strings->AddRef();

	context.pList = strings;
	context.hr = S_OK;

    if(!SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACK,NULL,GetDriverListCallback,&context,&scanResult)) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		strings->Release();
		if(FAILED(context.hr)) {
			return context.hr;
		} else {
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}
	SetupCloseFileQueue(queueHandle);
	*pDriverFiles = strings;
	return S_OK;
}

UINT CDriverPackage::GetManifestCallback(PVOID Context,UINT Notification,UINT_PTR Param1,UINT_PTR Param2)
{
	DriverListCallbackContext *pContext = (DriverListCallbackContext *)Context;
    FILEPATHS *pFileInfo = (FILEPATHS *)Param1;

	pContext->hr = pContext->pList->InternalAdd(pFileInfo->Source,lstrlen(pFileInfo->Source));

    return FAILED(pContext->hr) ? ERROR_NO_MORE_ITEMS : NO_ERROR;
}

STDMETHODIMP CDriverPackage::Manifest(LPDISPATCH *pManifest)
{
	//
	// source files
	//

    SP_DEVINSTALL_PARAMS deviceInstallParams;
    HSPFILEQ queueHandle = INVALID_HANDLE_VALUE;
    DWORD scanResult;
	DWORD Err;
	HRESULT hr;

	HDEVINFO hDevInfo = pDrvSearchSet->GetDevInfoSet();
	PSP_DEVINFO_DATA pDevInfoData = pDrvSearchSet->GetDevInfoData();

    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

	//
	// select this driver (expect this to last only as long as this call)
	//
    if(!SetupDiSetSelectedDriver(hDevInfo, pDevInfoData, &DrvInfoData)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // now 'instigate' an install, obtaining all files to be copied into
    // a file queue
    //
    queueHandle = SetupOpenFileQueue();

    if ( queueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // we want to add the files to the file queue, not install them!
    //
    deviceInstallParams.FileQueue = queueHandle;
    deviceInstallParams.Flags |= DI_NOVCP;

    if ( !SetupDiSetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

	//
	// do it
	//
    if ( !SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, hDevInfo, pDevInfoData) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // clear settings
    //
    deviceInstallParams.FileQueue = NULL;
    deviceInstallParams.Flags &= ~DI_NOVCP;
    SetupDiSetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams);

    //
    // we now have a list of delete/rename/copy files
    //
	DriverListCallbackContext context;
	CComObject<CStrings> *strings;
	hr = CComObject<CStrings>::CreateInstance(&strings);
	if(FAILED(hr)) {
		SetupCloseFileQueue(queueHandle);
		return hr;
	}
	strings->AddRef();

	context.pList = strings;
	context.hr = S_OK;

	//
	// WinXP has a perf option (no signing check) if these two flags are combined
	// if it doesn't work, fall back to Win2k method
	//
    if(!SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACKEX|SPQ_SCAN_FILE_PRESENCE,NULL,GetManifestCallback,&context,&scanResult) &&
		(FAILED(context.hr) || 
		!SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACKEX,NULL,GetManifestCallback,&context,&scanResult))) {

		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		strings->Release();
		if(FAILED(context.hr)) {
			return context.hr;
		} else {
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}
	SetupCloseFileQueue(queueHandle);
	*pManifest = strings;
	return S_OK;
}

BOOL CDriverPackage::IsSame(PSP_DRVINFO_DATA pInfo)
{
	if(pInfo->Reserved == DrvInfoData.Reserved) {
		return TRUE;
	}
	return FALSE;
}

STDMETHODIMP CDriverPackage::get_Reject(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_BAD_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::put_Reject(VARIANT_BOOL newVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}

	DWORD newflags = (params.Flags & ~DNF_BAD_DRIVER) | (newVal ? DNF_BAD_DRIVER : 0);

	if(params.Flags != newflags) {
		if(!SetupDiSetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
									      pDrvSearchSet->GetDevInfoData(),
									      &DrvInfoData,
										  &params)) {
			Err = GetLastError();
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_IsClassDriver(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_CLASS_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_IsCompatibleDriver(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_COMPATIBLE_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_DescriptionIsDuplicate(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_DUPDESC) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_ProviderIsDuplicate(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_DUPPROVIDER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_ExcludeFromList(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_EXCLUDEFROMLIST) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::put_ExcludeFromList(VARIANT_BOOL newVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}


	DWORD newflags = (params.Flags & ~DNF_EXCLUDEFROMLIST) | (newVal ? DNF_EXCLUDEFROMLIST : 0);

	if(params.Flags != newflags) {
		if(!SetupDiSetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
									      pDrvSearchSet->GetDevInfoData(),
									      &DrvInfoData,
										  &params)) {
			Err = GetLastError();
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_FromInternet(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_INET_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_NoDriver(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_NODRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_OldDriver(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_OLDDRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_OldInternetDriver(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_OLD_INET_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Rank(long *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}

	*pVal = params.Rank & 0xffff;
	*pVal = (params.Flags & DNF_COMPATIBLE_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::put_Rank(long newVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}


	DWORD newrank = newVal & 0xffff;

	if(params.Rank != newrank) {
		if(!SetupDiSetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
									      pDrvSearchSet->GetDevInfoData(),
									      &DrvInfoData,
										  &params)) {
			Err = GetLastError();
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\drivers.h ===
// Drivers.h : Declaration of the CDriverPackages

#ifndef __DRIVERS_H_
#define __DRIVERS_H_

#include "resource.h"       // main symbols

class CDriverPackage;
class CDrvSearchSet;
/////////////////////////////////////////////////////////////////////////////
// CDriverPackages
class ATL_NO_VTABLE CDriverPackages : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDriverPackages, &IID_IDriverPackages, &LIBID_DEVCON2Lib>
{
public:
	CDrvSearchSet *pDrvSearchSet;
	CDriverPackage **pDrivers;
	ULONG  Count;
	ULONG  ArraySize;

public:
	CDriverPackages()
	{
		pDrvSearchSet = NULL;
		pDrivers = NULL;
		Count = 0;
		ArraySize = 0;
	}
	~CDriverPackages();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDriverPackages)
	COM_INTERFACE_ENTRY(IDriverPackages)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDriverPackages
public:
	STDMETHOD(BestDriver)(LPDISPATCH *ppVal);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** ppUnk);
	STDMETHOD(Item)(/*[in]*/ long Index,/*[out, retval]*/ LPDISPATCH * ppVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

	//
	// helpers
	//
	HRESULT InternalAdd(CDriverPackage *pDriver);
	HRESULT Init(CDrvSearchSet *pSet);
	BOOL IncreaseArraySize(DWORD add);
};

#endif //__DRIVERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\driversenum.cpp ===
// DriversEnum.cpp : Implementation of CDevCon2App and DLL registration.

#include "stdafx.h"
#include "DevCon2.h"
#include "DriversEnum.h"
#include "Driver.h"

/////////////////////////////////////////////////////////////////////////////
//

CDriverPackagesEnum::~CDriverPackagesEnum()
{
	DWORD c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			pDrivers[c]->Release();
		}
		delete [] pDrivers;
	}
}


HRESULT CDriverPackagesEnum::Next(
                ULONG celt,
                VARIANT * rgVar,
                ULONG * pCeltFetched
            )
{
	ULONG fetched;
	CDriverPackage *pDrv;
	if(pCeltFetched) {
		*pCeltFetched = 0;
	}
	for(fetched = 0; fetched<celt && Position<Count ; fetched++,Position++) {
		VariantInit(&rgVar[fetched]);

		pDrv = pDrivers[Position];
		pDrv->AddRef();
		V_VT(&rgVar[fetched]) = VT_DISPATCH;
		V_DISPATCH(&rgVar[fetched]) = pDrv;
	}
	if(pCeltFetched) {
		*pCeltFetched = fetched;
	}
	return (fetched<celt) ? S_FALSE : S_OK;
}

HRESULT CDriverPackagesEnum::Skip(
                ULONG celt
            )
{
	DWORD remaining = Count-Position;
	if(remaining<celt) {
		Position = Count;
		return S_FALSE;
	} else {
		Position += (DWORD)celt;
		return S_OK;
	}
}

HRESULT CDriverPackagesEnum::Reset(
            )
{
	Position = 0;
	return S_OK;
}

HRESULT CDriverPackagesEnum::Clone(
                IEnumVARIANT ** ppEnum
            )
{
	*ppEnum = NULL;
	HRESULT hr;
	CComObject<CDriverPackagesEnum> *pEnum = NULL;
	hr = CComObject<CDriverPackagesEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	if(!pEnum->CopyDrivers(pDrivers,Count)) {
		delete pEnum;
		return E_OUTOFMEMORY;
	}
	pEnum->Position = Position;

	pEnum->AddRef();
	*ppEnum = pEnum;

	return S_OK;
}


BOOL CDriverPackagesEnum::CopyDrivers(CDriverPackage **pArray, DWORD NewCount)
{
	DWORD c;

	if(pDrivers) {
		delete [] pDrivers;
		pDrivers = NULL;
	}
	Count = 0;
	Position = 0;
	pDrivers = new CDriverPackage*[NewCount];
	if(!pDrivers) {
		return FALSE;
	}
	for(c=0;c<NewCount;c++) {
		pArray[c]->AddRef();
		pDrivers[c] = pArray[c];
		if(!pDrivers[c]) {
			Count = c;
			return FALSE;
		}
	}
	Count = NewCount;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\driversenum.h ===
// DriverPackagesEnum.h: Definition of the CDriverPackagesEnum class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DRIVERSENUM_H__840AC5A2_6A60_42B5_8CC7_FF67A2EA72B5__INCLUDED_)
#define AFX_DRIVERSENUM_H__840AC5A2_6A60_42B5_8CC7_FF67A2EA72B5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDriverPackagesEnum
class CDriverPackage;

class ATL_NO_VTABLE CDriverPackagesEnum : 
	public IDriverPackagesEnum,
	public CComObjectRootEx<CComSingleThreadModel>
{
protected:
	CDriverPackage** pDrivers;
	DWORD Count;
	DWORD Position;

public:
	BOOL CopyDrivers(CDriverPackage ** pArray,DWORD Count);

	CDriverPackagesEnum()
	{
		pDrivers = NULL;
		Count = 0;
		Position = 0;
	}

	~CDriverPackagesEnum();


BEGIN_COM_MAP(CDriverPackagesEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
	COM_INTERFACE_ENTRY(IDriverPackagesEnum)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CDriverPackagesEnum) 

// IDriverPackagesEnum
public:
    STDMETHOD(Next)(
                /*[in]*/ ULONG celt,
                /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar,
                /*[out]*/ ULONG * pCeltFetched
            );
    STDMETHOD(Skip)(
                /*[in]*/ ULONG celt
            );

    STDMETHOD(Reset)(
            );

    STDMETHOD(Clone)(
                /*[out]*/ IEnumVARIANT ** ppEnum
            );
};

#endif // !defined(AFX_DRIVERSENUM_H__840AC5A2_6A60_42B5_8CC7_FF67A2EA72B5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\driver.h ===
// Driver.h : Declaration of the CDriverPackage

#ifndef __DRIVER_H_
#define __DRIVER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDriverPackage
class CDevice;
class CDrvSearchSet;
class CStrings;

class ATL_NO_VTABLE CDriverPackage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDriverPackage, &IID_IDriverPackage, &LIBID_DEVCON2Lib>
{
private:
	struct DriverListCallbackContext {
		CStrings *pList;
		HRESULT   hr;
	};

	static UINT CALLBACK GetDriverListCallback(PVOID Context,UINT Notification,UINT_PTR Param1,UINT_PTR Param2);
	static UINT CALLBACK GetManifestCallback(PVOID Context,UINT Notification,UINT_PTR Param1,UINT_PTR Param2);

protected:
	CDrvSearchSet *pDrvSearchSet;
	SP_DRVINFO_DATA DrvInfoData;

public:
	CDriverPackage()
	{
		pDrvSearchSet = NULL;
		ZeroMemory(&DrvInfoData,sizeof(DrvInfoData));
	}
	~CDriverPackage();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDriverPackage)
	COM_INTERFACE_ENTRY(IDriverPackage)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDriverPackage
public:
	STDMETHOD(get_Rank)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Rank)(/*[in]*/ long newVal);
	STDMETHOD(get_OldInternetDriver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_OldDriver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_NoDriver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_FromInternet)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_ExcludeFromList)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ExcludeFromList)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ProviderIsDuplicate)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_DescriptionIsDuplicate)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsCompatibleDriver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsClassDriver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_Reject)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Reject)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(Manifest)(/*[out,retval]*/ LPDISPATCH * pManifest);
	STDMETHOD(DriverFiles)(/*[out,retval]*/ LPDISPATCH * pDriverFiles);
	STDMETHOD(get_DriverDescription)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_CompatibleIds)(/*[out, retval]*/ LPDISPATCH *pVal);
	STDMETHOD(get_HardwareIds)(/*[out, retval]*/ LPDISPATCH *pVal);
	STDMETHOD(get_ScriptFile)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_ScriptName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Version)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Date)(/*[out, retval]*/ DATE *pVal);
	STDMETHOD(get_Provider)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Manufacturer)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);

	//
	// helpers
	//
	BOOL IsSame(PSP_DRVINFO_DATA pInfo);
	HRESULT Init(CDrvSearchSet *pSet,PSP_DRVINFO_DATA pDrvInfoData);
};

#endif //__DRIVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\drvsearchset.cpp ===
// DrvSearchSet.cpp : Implementation of CDrvSearchSet
#include "stdafx.h"
#include "DevCon2.h"
#include "DrvSearchSet.h"
#include "Drivers.h"
#include "Driver.h"
#include "Device.h"
#include "DevInfoSet.h"
#include "DeviceConsole.h"

/////////////////////////////////////////////////////////////////////////////
// CDrvSearchSet

CDrvSearchSet::~CDrvSearchSet()
{
	if(pActualDevice) {
		pActualDevice->Release();
	}
	if(pTempDevice) {
		pTempDevice->Release();
	}
}

HRESULT CDrvSearchSet::Init(CDevice *device,DWORD searchType)
{
	if(pActualDevice) {
		pActualDevice->Release();
		pActualDevice = NULL;
	}
	if(pTempDevice) {
		pTempDevice->Release();
		pTempDevice = NULL;
	}
	//
	// determine machine name that device resides on
	//
	HDEVINFO hDevInfo = device->GetDevInfoSet();
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		return E_UNEXPECTED;
	}
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
	HRESULT hr;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) {
		DWORD Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

	//
	// create empty device info set for same machine as device
	//
	hDevInfo = SetupDiCreateDeviceInfoListEx(NULL,
											 NULL,
											 devInfoListDetail.RemoteMachineName[0]
											     ? devInfoListDetail.RemoteMachineName
											     : NULL,
											 NULL);
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		DWORD Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}

	CComObject<CDevInfoSet> *pDevInfoSet = NULL;
	hr = CComObject<CDevInfoSet>::CreateInstance(&pDevInfoSet);
	if(FAILED(hr)) {
		return hr;
	}
	CComPtr<IDevInfoSet> pDevInfoSetPtr = pDevInfoSet;
	hr = pDevInfoSet->Init(hDevInfo);
	if(FAILED(hr)) {
		return hr;
	}

	//
	// create a single entry device in new set
	//
	CComObject<CDevice> *pDevice = NULL;
	hr = CComObject<CDevice>::CreateInstance(&pDevice);
	if(FAILED(hr)) {
		return hr;
	}
	CComPtr<IDevice> pDevicePtr = pDevice;

	//
	// make a note of real device
	//
	device->AddRef();
	pActualDevice = device;
	//
	// and make a copy of it for temp device
	//
	BSTR Instance = NULL;
	hr = device->get_InstanceId(&Instance);
	if(FAILED(hr)) {
		return hr;
	}	
	hr = pDevice->Init(pDevInfoSet,Instance,device->DeviceConsole);
	SysFreeString(Instance);
	if(FAILED(hr)) {
		return hr;
	}
	pDevicePtr.Detach();
	pTempDevice = pDevice;
	SearchType = searchType;

	return S_OK;
}

HDEVINFO CDrvSearchSet::GetDevInfoSet()
{
	if(!pTempDevice) {
		return INVALID_HANDLE_VALUE;
	}
	return pTempDevice->GetDevInfoSet();
}

PSP_DEVINFO_DATA CDrvSearchSet::GetDevInfoData()
{
	if(!pTempDevice) {
		return NULL;
	}
	return &pTempDevice->DevInfoData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\drivers.cpp ===
// Drivers.cpp : Implementation of CDriverPackages
#include "stdafx.h"
#include "DevCon2.h"
#include "Driver.h"
#include "Drivers.h"
#include "DrvSearchSet.h"
#include "DriversEnum.h"
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////
// CDriverPackages

CDriverPackages::~CDriverPackages()
{
	DWORD c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			pDrivers[c]->Release();
		}
		delete [] pDrivers;
	}
	if(pDrvSearchSet) {
		pDrvSearchSet->Release();
		pDrvSearchSet = NULL;
	}
	
}


STDMETHODIMP CDriverPackages::get_Count(long *pVal)
{
	*pVal = (long)Count;
	return S_OK;
}

STDMETHODIMP CDriverPackages::Item(long Index, LPDISPATCH *ppVal)
{
	*ppVal = NULL;
	DWORD i = (DWORD)Index;
	if(i<1 || i > Count) {
		return E_INVALIDARG;
	}
	i--;
	pDrivers[i]->AddRef();
	*ppVal = pDrivers[i];

	return S_OK;
}

STDMETHODIMP CDriverPackages::get__NewEnum(IUnknown **ppUnk)
{
	*ppUnk = NULL;
	HRESULT hr;
	CComObject<CDriverPackagesEnum> *pEnum = NULL;
	hr = CComObject<CDriverPackagesEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	pEnum->AddRef();
	if(!pEnum->CopyDrivers(pDrivers,Count)) {
		pEnum->Release();
		return E_OUTOFMEMORY;
	}

	*ppUnk = pEnum;

	return S_OK;
}

BOOL CDriverPackages::IncreaseArraySize(DWORD add)
{
 	CDriverPackage** pNewDrivers;
 	DWORD Inc;
 	DWORD c;
 
 	if((ArraySize-Count)>=add) {
 		return TRUE;
 	}
 	Inc = ArraySize + add + 32;
 	pNewDrivers = new CDriverPackage*[Inc];
 	if(!pNewDrivers) {
 		return FALSE;
 	}
 	for(c=0;c<Count;c++) {
 		pNewDrivers[c] = pDrivers[c];
 	}
 	delete [] pDrivers;
 	pDrivers = pNewDrivers;
 	ArraySize = Inc;
 	return TRUE;
}



HRESULT CDriverPackages::Init(CDrvSearchSet *pSet)
{
	DWORD c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			pDrivers[c]->Release();
		}
		delete [] pDrivers;
	}
	pDrivers = NULL;
	Count = 0;
	if(pDrvSearchSet) {
		pDrvSearchSet->Release();
		pDrvSearchSet = NULL;
	}
	pSet->AddRef();
	pDrvSearchSet = pSet;
	return S_OK;
}

HRESULT CDriverPackages::InternalAdd(CDriverPackage *pDriver)
{
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}
	pDriver->AddRef();
	pDrivers[Count++] = pDriver;
	return S_OK;
}

STDMETHODIMP CDriverPackages::BestDriver(LPDISPATCH *ppVal)
{
	DWORD Err;
	HRESULT hr;

	//
	// attempt to search for best driver
	//
	if(!SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
									pDrvSearchSet->GetDevInfoSet(),
									pDrvSearchSet->GetDevInfoData()
									)) {
		Err = GetLastError();
		hr = HRESULT_FROM_SETUPAPI(Err);
		return hr;
	}
	SP_DRVINFO_DATA DriverInfoData;
	ZeroMemory(&DriverInfoData,sizeof(DriverInfoData));
	DriverInfoData.cbSize = sizeof(DriverInfoData);

	if(!SetupDiGetSelectedDriver(pDrvSearchSet->GetDevInfoSet(),
								 pDrvSearchSet->GetDevInfoData(),
								 &DriverInfoData)) {
		Err = GetLastError();
		hr = HRESULT_FROM_SETUPAPI(Err);
		return hr;
	}

	//
	// now get the driver object associated with this
	//
	DWORD c;
	for(c=0;c<Count;c++) {
		if(pDrivers[c]->IsSame(&DriverInfoData)) {
			pDrivers[c]->AddRef();
			*ppVal = pDrivers[c];
			return S_OK;
		}
	}
	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\drvsearchset.h ===
// DrvSearchSet.h : Declaration of the CDrvSearchSet

#ifndef __DRVSEARCHSET_H_
#define __DRVSEARCHSET_H_

#include "resource.h"       // main symbols

class CDevice;

/////////////////////////////////////////////////////////////////////////////
// CDrvSearchSet
class ATL_NO_VTABLE CDrvSearchSet : 
	public IDrvSearchSet,
	public CComObjectRootEx<CComSingleThreadModel>
{
public:
	CDevice *pActualDevice;
	CDevice *pTempDevice;
	DWORD   SearchType;

public:
	CDrvSearchSet()
	{
		pActualDevice = NULL;
		pTempDevice = NULL;
	}

	~CDrvSearchSet();

DECLARE_NOT_AGGREGATABLE(CDrvSearchSet)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDrvSearchSet)
	COM_INTERFACE_ENTRY(IDrvSearchSet)
END_COM_MAP()

// IDrvSearchSet
public:
	PSP_DEVINFO_DATA GetDevInfoData();
	HDEVINFO GetDevInfoSet();
	HRESULT Init(CDevice *device,DWORD searchType);
};

#endif //__DRVSEARCHSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DevCon2.rc
//
#define IDS_PROJNAME                    100
#define IDR_DEVICECONSOLE               101
#define IDR_DEVICES                     102
#define IDR_DRIVERS                     104
#define IDR_STRINGS                     106
#define IDS_DEVICESENUM_DESC            107
#define IDS_DRIVERSENUM_DESC            109
#define IDS_STRINGSENUM_DESC            111
#define IDS_DEVINFOSET_DESC             113
#define IDS_REBOOTREQ                   114
#define IDS_REBOOTCAP                   115
#define IDR_SETUPCLASSES                117
#define IDB_DEVICEICON                  120
#define IDR_DEVICEICON                  121
#define IDR_DEVCON2                     202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           122
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\setupclass.cpp ===
// SetupClass.cpp : Implementation of CSetupClass
#include "stdafx.h"
#include "DevCon2.h"
#include "SetupClass.h"
#include "devices.h"
#include "utils.h"
#include "xStrings.h"

/////////////////////////////////////////////////////////////////////////////
// CSetupClass

CSetupClass::~CSetupClass()
{
    if(pMachine) {
        SysFreeString(pMachine);
    }
}

HRESULT CSetupClass::Init(GUID *pGuid,LPWSTR Machine, IDeviceConsole *pDevCon)
{
    ClassGuid = *pGuid;
    if(pMachine) {
        SysFreeString(pMachine);
    }
    if(Machine) {
        pMachine = SysAllocString(Machine);
        if(!pMachine) {
            return E_OUTOFMEMORY;
        }
    } else {
        pMachine = NULL;
    }
    DeviceConsole = pDevCon;
    return S_OK;
}

BOOL CSetupClass::IsDuplicate(GUID *pCheck)
{
    //
    // only valid if pMachine/DeviceConsole known to be same
    //
    return memcmp(&ClassGuid,pCheck,sizeof(GUID)) ? FALSE : TRUE;
}

STDMETHODIMP CSetupClass::get_Name(BSTR *pVal)
{
    HRESULT hr;
    DWORD Err;
    LPWSTR Buffer;
    DWORD BuffSize=128;
    DWORD ReqSize;
    for(;;) {
        Buffer = new WCHAR[BuffSize];
        if(!Buffer) {
            return E_OUTOFMEMORY;
        }
        if(SetupDiClassNameFromGuidEx(&ClassGuid,Buffer,BuffSize,&ReqSize,pMachine,NULL)) {
            *pVal = SysAllocString(Buffer);
            delete [] Buffer;
            if(!*pVal) {
                return E_OUTOFMEMORY;
            }
            return S_OK;
        }
        Err = GetLastError();
        delete [] Buffer;
        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            hr = HRESULT_FROM_SETUPAPI(Err);
            return hr;
        }
        BuffSize = ReqSize+2;
    }
    return S_OK;
}

STDMETHODIMP CSetupClass::get_Description(BSTR *pVal)
{
    HRESULT hr;
    DWORD Err;
    LPWSTR Buffer;
    DWORD BuffSize=128;
    DWORD ReqSize;
    for(;;) {
        Buffer = new WCHAR[BuffSize];
        if(!Buffer) {
            return E_OUTOFMEMORY;
        }
        if(SetupDiGetClassDescriptionEx(&ClassGuid,Buffer,BuffSize,&ReqSize,pMachine,NULL)) {
            *pVal = SysAllocString(Buffer);
            delete [] Buffer;
            if(!*pVal) {
                return E_OUTOFMEMORY;
            }
            return S_OK;
        }
        Err = GetLastError();
        delete [] Buffer;
        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            hr = HRESULT_FROM_SETUPAPI(Err);
            return hr;
        }
        BuffSize = ReqSize+2;
    }
    return S_OK;
}

STDMETHODIMP CSetupClass::Devices(VARIANT flags,LPDISPATCH * pDevices)
{
    DWORD diflags = 0;
    HRESULT hr;
    HDEVINFO hDevInfo;
    DWORD Err;

    hr = TranslateDeviceFlags(&flags,&diflags);
    if(FAILED(hr)) {
        return hr;
    }
    hDevInfo = SetupDiGetClassDevsEx(&ClassGuid,NULL,NULL,diflags,NULL,pMachine,NULL);
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }

    CComObject<CDevices> *d;
    hr = CComObject<CDevices>::CreateInstance(&d);
    if(FAILED(hr)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return hr;
    }
    d->AddRef();
    hr = d->Init(hDevInfo,DeviceConsole);
    if(FAILED(hr)) {
        d->Release();
        return hr;
    }
    *pDevices = d;
    return S_OK;
}

STDMETHODIMP CSetupClass::CreateEmptyDeviceList(LPDISPATCH *pDevices)
{
    HRESULT hr;
    HDEVINFO hDevInfo;
    DWORD Err;

    hDevInfo = SetupDiCreateDeviceInfoListEx(&ClassGuid,
                                              NULL,
                                              pMachine,
                                              NULL);
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }

    CComObject<CDevices> *d;
    hr = CComObject<CDevices>::CreateInstance(&d);
    if(FAILED(hr)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return hr;
    }
    d->AddRef();
    hr = d->Init(hDevInfo,DeviceConsole);
    if(FAILED(hr)) {
        d->Release();
        return hr;
    }
    *pDevices = d;
    return S_OK;
}

STDMETHODIMP CSetupClass::get_Guid(BSTR *pVal)
{
    LPOLESTR pStr;
    HRESULT hr = StringFromCLSID(ClassGuid,&pStr);
    if(FAILED(hr)) {
        return hr;
    }
    *pVal = SysAllocString(pStr);
    CoTaskMemFree(pStr);
    if(!*pVal) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

GUID* CSetupClass::Guid()
{
    return &ClassGuid;
}

STDMETHODIMP CSetupClass::get_Machine(BSTR *pVal)
{
    if((pMachine == NULL) || !pMachine[0]) {
        *pVal = SysAllocString(L"");
        if(*pVal) {
            return S_FALSE;
        }
    } else {
        *pVal = SysAllocString(pMachine);
        if(*pVal) {
            return S_OK;
        }
    }
    *pVal = NULL;
    return E_OUTOFMEMORY;
}

STDMETHODIMP CSetupClass::get__ClassGuid(GUID *pVal)
{
    *pVal = ClassGuid;

    return S_OK;
}

STDMETHODIMP CSetupClass::get__Machine(BSTR *pVal)
{
    return get_Machine(pVal);

    return S_OK;
}

HRESULT CSetupClass::GetClassProperty(DWORD prop, VARIANT *pVal)
{
#if 0
    //
    // first obtain raw registry data
    //
    LPBYTE buffer = NULL;
    DWORD size = 1024;
    DWORD bufsize;
    DWORD reqSize;
    DWORD dataType;
    HRESULT hr;

    for(;;) {
        if(buffer) {
            delete [] buffer;
        }
        bufsize = size + sizeof(WCHAR)*2;
        buffer = new BYTE[bufsize];
        if(!buffer) {
            return E_OUTOFMEMORY;
        }
        if(SetupDiGetClassRegistryProperty(&ClassGuid,prop,&dataType,buffer,size,&reqSize,pMachine,NULL)) {
            break;
        }
        DWORD Err = GetLastError();
        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            delete [] buffer;
            hr = HRESULT_FROM_SETUPAPI(Err);
            return hr;
        }
    }

    //
    // now determine how to parcel it to caller
    //
    switch(dataType) {
    case REG_DWORD: {
            //
            // package value as a long
            //
            if(size != sizeof(DWORD)) {
                hr = E_INVALIDARG;
            } else {
                VariantClear(pVal);
                V_VT(pVal) = VT_I4;
                V_I4(pVal) = (long)*((DWORD*)buffer);
                hr = S_OK;
            }
        }
        break;

    case REG_SZ: {
            //
            // package value as string
            //
            VariantClear(pVal);
            ZeroMemory(buffer+size,sizeof(WCHAR));
            BSTR pString = SysAllocString((LPWSTR)buffer);
            if(!pString) {
                hr = E_OUTOFMEMORY;
            } else {
                V_VT(pVal) = VT_BSTR;
                V_BSTR(pVal) = pString;
                hr = S_OK;
            }
        }
        break;

    case REG_MULTI_SZ: {
            //
            // package as string-list
            //
            VariantClear(pVal);
            ZeroMemory(buffer+size,sizeof(WCHAR)*2);
            CComObject<CStrings> *strings;
            hr = CComObject<CStrings>::CreateInstance(&strings);
            if(FAILED(hr)) {
                break;
            }
            strings->AddRef();
            LPWSTR p;
            UINT len = 0;
            for(p = (LPWSTR)buffer;*p;p+=len+1) {
                len = wcslen(p);
                hr = strings->InternalAdd(p,len);
                if(FAILED(hr)) {
                    strings->Release();
                    break;
                }
            }
            V_VT(pVal) = VT_DISPATCH;
            V_DISPATCH(pVal) = strings;
            hr = S_OK;
        }
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }
    delete [] buffer;
    return hr;

#endif

    return E_NOTIMPL;
}

HRESULT CSetupClass::PutClassPropertyString(DWORD prop, VARIANT *pVal)
{
#if 0
    HRESULT hr;
    DWORD len = 0;
    PBYTE data = NULL;
    CComVariant v;
    if(!IsBlank(pVal)) {
        hr = v.ChangeType(VT_BSTR,pVal);
        if(FAILED(hr)) {
            return hr;
        }
        len = (SysStringLen(V_BSTR(&v))+1)*sizeof(WCHAR);
        data = (PBYTE)V_BSTR(&v);
    }

    if(SetupDiSetClassRegistryProperty(&ClassGuid,
                                        prop,
                                        data,
                                        len,
                                        pMachine,
                                        NULL)) {
        return S_OK;
    }
    DWORD Err = GetLastError();
    return HRESULT_FROM_SETUPAPI(Err);

#endif

    return E_NOTIMPL;
}

HRESULT CSetupClass::PutClassPropertyDword(DWORD prop, VARIANT *pVal)
{
#if 0
    CComVariant v;
    HRESULT hr;
    DWORD len = 0;
    PBYTE data = NULL;
    if(!IsBlank(pVal)) {
        hr = v.ChangeType(VT_I4,pVal);
        if(FAILED(hr)) {
            return hr;
        }
        len = sizeof(V_I4(&v));
        data = (PBYTE)&V_I4(&v);
    }

    if(SetupDiSetClassRegistryProperty(&ClassGuid,
                                        prop,
                                        data,
                                        len,
                                        pMachine,
                                        NULL)) {
        return S_OK;
    }
    DWORD Err = GetLastError();
    return HRESULT_FROM_SETUPAPI(Err);

#endif

    return E_NOTIMPL;

}

HRESULT CSetupClass::PutClassPropertyMultiSz(DWORD prop, VARIANT *pVal)
{
#if 0
    //
    // build a CStrings collection
    //
    HRESULT hr;
    CComObject<CStrings> *strings = NULL;
    DWORD len = 0;
    PBYTE data = NULL;
    LPWSTR multisz;
    if(!IsBlank(pVal)) {
        hr = CComObject<CStrings>::CreateInstance(&strings);
        if(FAILED(hr)) {
            return hr;
        }
        strings->AddRef();
        hr = strings->Add(*pVal);
        if(FAILED(hr)) {
            strings->Release();
            return hr;
        }
        //
        // now obtain multisz from the collection
        //
        hr = strings->GetMultiSz(&multisz,&len);
        strings->Release(); // done with temporary collection
        if(FAILED(hr)) {
            return hr;
        }
        //
        // now write the multi-sz value to device registry
        //
        len *= sizeof(WCHAR);
        data = (PBYTE)multisz;
    }
    CONFIGRET cr = CM_Get_Class_Registry_Property(
    if(SetupDiSetClassRegistryProperty(&ClassGuid,
                                        prop,
                                        (PBYTE)multisz,
                                        len,
                                        pMachine,
                                        NULL)) {
        if(multisz) {
            delete [] multisz;
        }
        return S_OK;
    }
    DWORD Err = GetLastError();
    if(multisz) {
        delete [] multisz;
    }
    return HRESULT_FROM_SETUPAPI(Err);

#endif

    return E_NOTIMPL;
}


STDMETHODIMP CSetupClass::get_Security(VARIANT *pVal)
{
    return GetClassProperty(SPDRP_SECURITY_SDS,pVal);
}

STDMETHODIMP CSetupClass::put_Security(VARIANT newVal)
{
    return PutClassPropertyString(SPDRP_SECURITY_SDS,&newVal);
}

STDMETHODIMP CSetupClass::get_DeviceTypeOverride(VARIANT *pVal)
{
    return GetClassProperty(SPDRP_DEVTYPE,pVal);
}

STDMETHODIMP CSetupClass::put_DeviceTypeOverride(VARIANT newVal)
{
    return PutClassPropertyDword(SPDRP_DEVTYPE,&newVal);
}

STDMETHODIMP CSetupClass::get_ForceExclusive(VARIANT *pVal)
{
    return GetClassProperty(SPDRP_EXCLUSIVE,pVal);
}

STDMETHODIMP CSetupClass::put_ForceExclusive(VARIANT newVal)
{
    return PutClassPropertyDword(SPDRP_EXCLUSIVE,&newVal);
}

STDMETHODIMP CSetupClass::get_CharacteristicsOverride(VARIANT *pVal)
{
    return GetClassProperty(SPDRP_CHARACTERISTICS,pVal);
}

STDMETHODIMP CSetupClass::put_CharacteristicsOverride(VARIANT newVal)
{
    return PutClassPropertyDword(SPDRP_CHARACTERISTICS,&newVal);
}



HRESULT CSetupClass::SubKeyInfo(LPCWSTR subkey, HKEY *hKey, LPWSTR *pSubKey,LPCWSTR *pKeyVal,BOOL writeable)
{
    DWORD Scope = DICS_FLAG_GLOBAL;
    DWORD HwProfile = 0;
    HKEY hParentKey;
    LPWSTR keyname;
    LPCWSTR keyval;
    size_t len;

    hParentKey = SetupDiOpenClassRegKeyEx(&ClassGuid,
                                    writeable ? KEY_WRITE: KEY_READ,
                                    DIOCR_INSTALLER,
                                    pMachine,
                                    NULL
                                    );
    if((hParentKey == NULL) || (hParentKey == INVALID_HANDLE_VALUE)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    //
    // determine value part of key
    //
    keyval = wcsrchr(subkey,L'\\');
    if(!keyval) {
        *hKey = hParentKey;
        *pKeyVal = subkey[0] ? subkey : NULL;
        *pSubKey = NULL;
        return S_OK;
    }
    len = keyval-subkey+1;
    keyname = new WCHAR[len];
    if(!keyname) {
        RegCloseKey(hParentKey);
        return E_OUTOFMEMORY;
    }
    wcsncpy(keyname,subkey,len);
    keyname[len-1] = 0;
    keyval++;
    if(!keyval[0]) {
        keyval = NULL;
    }
    *hKey = hParentKey;
    *pSubKey = keyname;
    *pKeyVal = keyval;
    return S_OK;
}

STDMETHODIMP CSetupClass::RegRead(BSTR key,VARIANT * pValue)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR val;
    LPWSTR subkey;
    LONG regerr;
    DWORD regType;
    DWORD regSize;
    LPBYTE pByte;

    if(!pValue) {
        return E_INVALIDARG;
    }
    VariantInit(pValue);

    HRESULT hr = SubKeyInfo(key,&hParentKey,&subkey,&val,FALSE);
    if(FAILED(hr)) {
        return hr;
    }
    //
    // now work out and marshell data
    //
    if(subkey) {
        regerr = RegOpenKeyEx(hParentKey,subkey,0,KEY_READ,&hKey);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }
    regSize = 0;
    regerr = RegQueryValueEx(hKey,val,NULL,&regType,NULL,&regSize);
    if(regerr != NO_ERROR) {
        RegCloseKey(hKey);
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    pByte = new BYTE[regSize+sizeof(WCHAR)*2];
    if(!pByte) {
        RegCloseKey(hKey);
        return E_OUTOFMEMORY;
    }
    regerr = RegQueryValueEx(hKey,val,NULL,&regType,pByte,&regSize);
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        delete [] pByte;
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    switch(regType) {
    case REG_DWORD:
        if(regSize != 4) {
            delete [] pByte;
            return DISP_E_TYPEMISMATCH;
        }

        V_VT(pValue) = VT_UI4;
        V_UI4(pValue) = *(DWORD*)pByte;
        break;

    case REG_BINARY:
        switch(regSize) {
        case 1:
            V_VT(pValue) = VT_UI1;
            V_UI1(pValue) = *((BYTE*)pByte);
            break;
        case 2:
            V_VT(pValue) = VT_UI2;
            V_UI2(pValue) = *((WORD*)pByte);
            break;
        case 4:
            V_VT(pValue) = VT_UI4;
            V_UI4(pValue) = *((DWORD*)pByte);
            break;
        default:
            delete [] pByte;
            return DISP_E_TYPEMISMATCH;
        }
        break;

    case REG_SZ:
        ZeroMemory(pByte+regSize,sizeof(WCHAR)*1);
        V_VT(pValue) = VT_BSTR;
        V_BSTR(pValue) = SysAllocString((LPWSTR)pByte);
        if(!V_BSTR(pValue)) {
            delete [] pByte;
            return E_OUTOFMEMORY;
        }
        break;

    case REG_MULTI_SZ: {
            ZeroMemory(pByte+regSize,sizeof(WCHAR)*2);
            CComObject<CStrings> *pStringTemp = NULL;
            hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
            if(FAILED(hr)) {
                delete [] pByte;
                return hr;
            }
            pStringTemp->AddRef();
            hr = pStringTemp->FromMultiSz((LPWSTR)pByte);
            if(FAILED(hr)) {
                pStringTemp->Release();
                delete [] pByte;
                return hr;
            }
            V_VT(pValue) = VT_DISPATCH;
            V_DISPATCH(pValue) = pStringTemp;
        }
        break;


    case REG_EXPAND_SZ:
        ZeroMemory(pByte+regSize,sizeof(WCHAR)*1);
        regSize = ExpandEnvironmentStrings((LPWSTR)pByte,NULL,0);
        if(regSize == 0) {
            V_VT(pValue) = VT_BSTR;
            V_BSTR(pValue) = SysAllocString((LPWSTR)pByte);
        } else {
            LPWSTR pExp = new WCHAR[regSize+1];
            if(!pExp) {
                delete [] pByte;
                return E_OUTOFMEMORY;
            }
            regSize = ExpandEnvironmentStrings((LPWSTR)pByte,NULL,regSize);
            V_VT(pValue) = VT_BSTR;
            V_BSTR(pValue) = SysAllocString(pExp);
            delete [] pExp;
        }
        if(!V_BSTR(pValue)) {
            delete [] pByte;
            return E_OUTOFMEMORY;
        }
        break;

    default:
        delete [] pByte;
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    delete [] pByte;
    return S_OK;
}

STDMETHODIMP CSetupClass::RegWrite(BSTR key, VARIANT val, VARIANT strType)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR valname;
    LPWSTR subkey;
    LONG regerr;
    CComVariant strType_v;
    CComVariant val_v;
    LPCWSTR pType;
    HRESULT hr;
    DWORD dwType;
    BOOL DetermineType = FALSE;
    LPBYTE pData = NULL;
    LPWSTR pString = NULL;
    DWORD DataSize = 0;
    BYTE SimpleData[4];
    LPVARIANT pVal = &val;

    while(V_VT(pVal) == (VT_BYREF|VT_VARIANT)) {
        pVal = V_VARIANTREF(pVal);
    }

    //
    // validate strType
    //

    hr = GetOptionalString(&strType,strType_v,&pType);
    if(FAILED(hr)) {
        return hr;
    }

    if((pType == NULL) || !pType[0]) {
        //
        // determine type of variant
        //
        if(IsNumericVariant(pVal)) {
            dwType = REG_DWORD;
        } else if(IsMultiValueVariant(pVal)) {
            dwType = REG_MULTI_SZ;
        } else {
            dwType = REG_SZ;
        }
    } else if(_wcsicmp(pType,L"REG_DWORD")==0) {
        dwType = REG_DWORD;
    } else if(_wcsicmp(pType,L"REG_SZ")==0) {
        dwType = REG_SZ;
    } else if(_wcsicmp(pType,L"REG_EXPAND_SZ")==0) {
        dwType = REG_EXPAND_SZ;
    } else if(_wcsicmp(pType,L"REG_MULTI_SZ")==0) {
        dwType = REG_MULTI_SZ;
    } else if(_wcsicmp(pType,L"REG_BINARY")==0) {
        dwType = REG_BINARY;
    } else {
        return DISP_E_TYPEMISMATCH;
    }

    //
    // build up value data
    //
    switch(dwType) {
    case REG_BINARY:
        pData = SimpleData;
        switch V_VT(pVal) {
        case VT_I1:
        case VT_UI1:
            *(LPBYTE)pData = V_UI1(pVal);
            DataSize = 1;
            break;
        case VT_I1|VT_BYREF:
        case VT_UI1|VT_BYREF:
            *(LPBYTE)pData = *V_UI1REF(pVal);
            DataSize = 1;
            break;
        case VT_I2:
        case VT_UI2:
            *(LPWORD)pData = V_UI2(pVal);
            DataSize = 2;
            break;
        case VT_I2|VT_BYREF:
        case VT_UI2|VT_BYREF:
            *(LPWORD)pData = *V_UI2REF(pVal);
            DataSize = 2;
            break;
        case VT_I4:
        case VT_UI4:
            *(LPDWORD)pData = V_UI4(pVal);
            DataSize = 4;
            break;
        case VT_I4|VT_BYREF:
        case VT_UI4|VT_BYREF:
            *(LPDWORD)pData = *V_UI4REF(pVal);
            DataSize = 4;
            break;
        default:
            return DISP_E_TYPEMISMATCH;
        }
        break;

    case REG_DWORD:
        pData = SimpleData;
        hr = val_v.ChangeType(VT_UI4,pVal);
        if(FAILED(hr)) {
            return DISP_E_TYPEMISMATCH;
        }
        *(LPDWORD)pData = V_UI4(pVal);
        DataSize = 4;
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:
        hr = val_v.ChangeType(VT_BSTR,pVal);
        if(FAILED(hr)) {
            return DISP_E_TYPEMISMATCH;
        }

        DataSize = (SysStringLen(V_BSTR(&val_v))+1);
        pString = new WCHAR[DataSize];
        if(!pString) {
            return E_OUTOFMEMORY;
        }
        pData = (LPBYTE)pString;
        DataSize *= sizeof(WCHAR);
        memcpy(pData,V_BSTR(&val_v),DataSize);
        break;

    case REG_MULTI_SZ: {
            CComObject<CStrings> *pStringTemp = NULL;
            hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
            if(FAILED(hr)) {
                return hr;
            }
            pStringTemp->AddRef();
            hr = pStringTemp->InternalInsert(0,pVal);
            if(FAILED(hr)) {
                pStringTemp->Release();
                return hr;
            }
            hr = pStringTemp->GetMultiSz(&pString,&DataSize);
            pStringTemp->Release();
            if(FAILED(hr)) {
                return hr;
            }
            pData = (LPBYTE)pString;
            DataSize *= sizeof(WCHAR);
        }
        break;
    default:
        return DISP_E_TYPEMISMATCH;
    }

    hr = SubKeyInfo(key,&hParentKey,&subkey,&valname,TRUE);
    if(FAILED(hr)) {
        if(pString) {
            delete [] pString;
        }
        return hr;
    }
    if(subkey) {
        regerr = RegCreateKeyEx(hParentKey,subkey,0,NULL,0,KEY_WRITE,NULL,&hKey,NULL);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            if(pString) {
                delete [] pString;
            }
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }

    regerr = RegSetValueEx(hKey,valname,0,dwType,pData,DataSize);
    if(pString) {
        delete [] pString;
    }
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        return HRESULT_FROM_SETUPAPI(regerr);
    }

    return S_OK;
}

STDMETHODIMP CSetupClass::RegDelete(BSTR key)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR valname;
    LPWSTR subkey;
    LONG regerr;
    HRESULT hr = SubKeyInfo(key,&hParentKey,&subkey,&valname,TRUE);
    if(FAILED(hr)) {
        return hr;
    }
    if(subkey) {
        regerr = RegOpenKeyEx(hParentKey,subkey,0,KEY_WRITE,&hKey);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }
    regerr = RegDeleteValue(hKey,valname);
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\setupclassenum.h ===
// SetupClassEnum.h : Declaration of the CSetupClassEnum

#ifndef __SETUPCLASSENUM_H_
#define __SETUPCLASSENUM_H_

#include "resource.h"       // main symbols

class CSetupClass;
/////////////////////////////////////////////////////////////////////////////
// CSetupClassEnum
class ATL_NO_VTABLE CSetupClassEnum : 
	public ISetupClassEnum,
	public CComObjectRootEx<CComSingleThreadModel>
{
protected:
	CSetupClass** pSetupClasses;
	DWORD Count;
	DWORD Position;

public:
	BOOL CopySetupClasses(CSetupClass ** pArray,DWORD Count);

	CSetupClassEnum()
	{
		Position = 0;
		pSetupClasses = NULL;
		Count = 0;
	}
	~CSetupClassEnum();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSetupClassEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
	COM_INTERFACE_ENTRY(ISetupClassEnum)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CSetupClassEnum) 

// ISetupClassEnum
public:
    STDMETHOD(Next)(
                /*[in]*/ ULONG celt,
                /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar,
                /*[out]*/ ULONG * pCeltFetched
            );
    STDMETHOD(Skip)(
                /*[in]*/ ULONG celt
            );

    STDMETHOD(Reset)(
            );

    STDMETHOD(Clone)(
                /*[out]*/ IEnumVARIANT ** ppEnum
            );
};

#endif //__SETUPCLASSENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\setupclassenum.cpp ===
// SetupClassEnum.cpp : Implementation of CSetupClassEnum
#include "stdafx.h"
#include "DevCon2.h"
#include "SetupClass.h"
#include "SetupClasses.h"
#include "SetupClassEnum.h"

/////////////////////////////////////////////////////////////////////////////
// CSetupClassEnum

CSetupClassEnum::~CSetupClassEnum()
{
	DWORD c;
	if(pSetupClasses) {
		for(c=0;c<Count;c++) {
			pSetupClasses[c]->Release();
		}
		delete [] pSetupClasses;
	}
}


HRESULT CSetupClassEnum::Next(
                ULONG celt,
                VARIANT * rgVar,
                ULONG * pCeltFetched
            )
{
	ULONG fetched;
	CSetupClass *pCls;
	if(pCeltFetched) {
		*pCeltFetched = 0;
	}
	for(fetched = 0; fetched<celt && Position<Count ; fetched++,Position++) {
		VariantInit(&rgVar[fetched]);

		pCls = pSetupClasses[Position];
		pCls->AddRef();
		V_VT(&rgVar[fetched]) = VT_DISPATCH;
		V_DISPATCH(&rgVar[fetched]) = pCls;
	}
	if(pCeltFetched) {
		*pCeltFetched = fetched;
	}
	return (fetched<celt) ? S_FALSE : S_OK;
}

HRESULT CSetupClassEnum::Skip(
                ULONG celt
            )
{
	DWORD remaining = Count-Position;
	if(remaining<celt) {
		Position = Count;
		return S_FALSE;
	} else {
		Position += (DWORD)celt;
		return S_OK;
	}
}

HRESULT CSetupClassEnum::Reset(
            )
{
	Position = 0;
	return S_OK;
}

HRESULT CSetupClassEnum::Clone(
                IEnumVARIANT ** ppEnum
            )
{
	*ppEnum = NULL;
	HRESULT hr;
	CComObject<CSetupClassEnum> *pEnum = NULL;
	hr = CComObject<CSetupClassEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	if(!pEnum->CopySetupClasses(pSetupClasses,Count)) {
		delete pEnum;
		return E_OUTOFMEMORY;
	}
	pEnum->Position = Position;

	pEnum->AddRef();
	*ppEnum = pEnum;

	return S_OK;
}


BOOL CSetupClassEnum::CopySetupClasses(CSetupClass **pArray, DWORD NewCount)
{
	DWORD c;

	if(pSetupClasses) {
		delete [] pSetupClasses;
		pSetupClasses = NULL;
	}
	Count = 0;
	Position = 0;
	pSetupClasses = new CSetupClass*[NewCount];
	if(!pSetupClasses) {
		return FALSE;
	}
	for(c=0;c<NewCount;c++) {
		pArray[c]->AddRef();
		pSetupClasses[c] = pArray[c];
		if(!pSetupClasses[c]) {
			Count = c;
			return FALSE;
		}
	}
	Count = NewCount;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\setupclasses.h ===
// SetupClasses.h : Declaration of the CSetupClasses

#ifndef __SETUPCLASSES_H_
#define __SETUPCLASSES_H_

#include "resource.h"       // main symbols

class CSetupClass;
/////////////////////////////////////////////////////////////////////////////
// CSetupClasses
class ATL_NO_VTABLE CSetupClasses : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSetupClasses, &CLSID_SetupClasses>,
	public IDispatchImpl<ISetupClasses, &IID_ISetupClasses, &LIBID_DEVCON2Lib>
{
protected:
	CComPtr<IDeviceConsole> DeviceConsole;
	BSTR pMachine;
	CSetupClass** pSetupClasses;
	DWORD Count;
	DWORD ArraySize;

public:
	CSetupClasses()
	{
		pMachine = NULL;
		pSetupClasses = NULL;
		Count = 0;
		ArraySize = 0;
	}

	~CSetupClasses();

DECLARE_REGISTRY_RESOURCEID(IDR_SETUPCLASSES)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSetupClasses)
	COM_INTERFACE_ENTRY(ISetupClasses)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISetupClasses
public:
	STDMETHOD(get_Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(Devices)(/*[in,optional]*/ VARIANT flags,/*[out,retval]*/ LPDISPATCH * pDevices);
	STDMETHOD(Remove)(/*[in]*/ VARIANT v);
	STDMETHOD(Add)(/*[in]*/ VARIANT ClassNames);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** ppUnk);
	STDMETHOD(Item)(/*[in]*/ long Index,/*[out, retval]*/ LPDISPATCH * ppVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

	//
	// helpers
	//
	BOOL IncreaseArraySize(DWORD strings);
	HRESULT AddGuid(GUID *pGuid);
	HRESULT AppendClass(LPCWSTR Filter);
	HRESULT Init(LPCWSTR Machine, IDeviceConsole * pDevCon);
	BOOL FindDuplicate(GUID *pGuid);
	HRESULT GetIndex(LPVARIANT Index,DWORD *pAt);
	HRESULT AllClasses();
};

#endif //__SETUPCLASSES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\setupclass.h ===
// SetupClass.h : Declaration of the CSetupClass

#ifndef __SETUPCLASS_H_
#define __SETUPCLASS_H_

#include "resource.h"       // main symbols

class CDeviceConsole;
/////////////////////////////////////////////////////////////////////////////
// CSetupClass
class ATL_NO_VTABLE CSetupClass : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ISetupClass, &IID_ISetupClass, &LIBID_DEVCON2Lib>,
	public ISetupClassInternal
{
protected:
	CComPtr<IDeviceConsole> DeviceConsole;
	BSTR pMachine;
	GUID ClassGuid;

public:
	CSetupClass()
	{
		pMachine = NULL;
		ZeroMemory(&ClassGuid,sizeof(ClassGuid));
	}
	~CSetupClass();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSetupClass)
	COM_INTERFACE_ENTRY(ISetupClass)
	COM_INTERFACE_ENTRY(ISetupClassInternal)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISetupClass
public:
	STDMETHOD(RegDelete)(/*[in]*/ BSTR key);
	STDMETHOD(RegWrite)(/*[in]*/ BSTR key,/*[in]*/ VARIANT val,/*[in,optional]*/ VARIANT strType);
	STDMETHOD(RegRead)(/*[in]*/ BSTR key,VARIANT * pValue);
	STDMETHOD(get_CharacteristicsOverride)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_CharacteristicsOverride)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_ForceExclusive)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_ForceExclusive)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_DeviceTypeOverride)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_DeviceTypeOverride)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_Security)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_Security)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Guid)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(CreateEmptyDeviceList)(/*[retval,out]*/ LPDISPATCH *pDevices);
	STDMETHOD(Devices)(/*[in,optional]*/ VARIANT flags,/*[out]*/ LPDISPATCH * pDevices);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);

// internal
public:
	STDMETHOD(get__Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get__ClassGuid)(/*[out, retval]*/ GUID *pVal);


	//
	// helpers
	//
	GUID* Guid();
	BOOL IsDuplicate(GUID *pCheck);
	HRESULT SubKeyInfo(LPCWSTR subkey, HKEY *hKey, LPWSTR *pSubKey,LPCWSTR *keyval,BOOL writeable);
	HRESULT Init(GUID *pGuid,LPWSTR Machine, IDeviceConsole *pDevCon);
	HRESULT GetClassProperty(DWORD prop, VARIANT *pVal);
	HRESULT PutClassPropertyString(DWORD prop, VARIANT *pVal);
	HRESULT PutClassPropertyDword(DWORD prop, VARIANT *pVal);
	HRESULT PutClassPropertyMultiSz(DWORD prop, VARIANT *pVal);
};

#endif //__SETUPCLASS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\setupclasses.cpp ===
// SetupClasses.cpp : Implementation of CSetupClasses
#include "stdafx.h"
#include "DevCon2.h"
#include "SetupClass.h"
#include "SetupClassEnum.h"
#include "SetupClasses.h"
#include "DeviceConsole.h"
#include "Devices.h"
#include "xStrings.h"
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////
// CSetupClasses

CSetupClasses::~CSetupClasses()
{
	DWORD c;
	if(pSetupClasses) {
		for(c=0;c<Count;c++) {
			pSetupClasses[c]->Release();
		}
		delete [] pSetupClasses;
	}
	if(pMachine) {
		SysFreeString(pMachine);
	}
}


STDMETHODIMP CSetupClasses::get_Count(long *pVal)
{
	*pVal = (long)Count;
	return S_OK;
}

STDMETHODIMP CSetupClasses::Item(long Index, LPDISPATCH *ppVal)
{
	*ppVal = NULL;
	DWORD i = (DWORD)Index;
	if(i<1 || i > Count) {
		return E_INVALIDARG;
	}
	i--;
	pSetupClasses[i]->AddRef();
	*ppVal = pSetupClasses[i];

	return S_OK;
}

STDMETHODIMP CSetupClasses::get__NewEnum(IUnknown **ppUnk)
{
	*ppUnk = NULL;
	HRESULT hr;
	CComObject<CSetupClassEnum> *pEnum = NULL;
	hr = CComObject<CSetupClassEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	pEnum->AddRef();
	if(!pEnum->CopySetupClasses(pSetupClasses,Count)) {
		pEnum->Release();
		return E_OUTOFMEMORY;
	}

	*ppUnk = pEnum;

	return S_OK;
}


BOOL CSetupClasses::IncreaseArraySize(DWORD add)
{
 	CSetupClass** pNewSetupClasses;
 	DWORD Inc;
 	DWORD c;
 
 	if((ArraySize-Count)>=add) {
 		return TRUE;
 	}
 	Inc = ArraySize + add + 32;
 	pNewSetupClasses = new CSetupClass*[Inc];
 	if(!pNewSetupClasses) {
 		return FALSE;
 	}
 	for(c=0;c<Count;c++) {
 		pNewSetupClasses[c] = pSetupClasses[c];
 	}
 	delete [] pSetupClasses;
 	pSetupClasses = pNewSetupClasses;
 	ArraySize = Inc;
 	return TRUE;
}



HRESULT CSetupClasses::Init(LPCWSTR Machine, IDeviceConsole *pDevCon)
{
	if(pMachine) {
		SysFreeString(pMachine);
	}
	if(Machine) {
		pMachine = SysAllocString(Machine);
		if(!pMachine) {
			return E_OUTOFMEMORY;
		}
	} else {
		pMachine = NULL;
	}
	DeviceConsole = pDevCon;
	return S_OK;
}

HRESULT CSetupClasses::AppendClass(LPCWSTR Filter)
{
	DWORD nClasses;
	DWORD nClasses2;
	DWORD c;
	DWORD Err;
	HRESULT hr;

	if(Filter[0]==L'{') {
		//
		// possibly GUID
		//
		GUID guid;
		hr = CLSIDFromString((LPWSTR)Filter,&guid);
		if(SUCCEEDED(hr)) {
			//
			// class is in GUID format
			//
			if(FindDuplicate(&guid)) {
				return S_OK;
			}
			return AddGuid(&guid);
		}
	}
	//
	// class is probably in text format
	// obtain list of class id's that match class name
	// append all class devices for each class guid
	//
	if(SetupDiClassGuidsFromNameEx(Filter,NULL,0,&nClasses,pMachine,NULL) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
		if(!nClasses) {
			//
			// no classes
			//
			return S_FALSE;
		}
		GUID *pList = new GUID[nClasses];
		if(!pList) {
			return E_OUTOFMEMORY;
		}
		if(SetupDiClassGuidsFromNameEx(Filter,pList,nClasses,&nClasses2,pMachine,NULL) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
			//
			// count may have changed since last call
			//
			if(nClasses>nClasses2) {
				nClasses = nClasses2;
			}
			if(!nClasses) {
				//
				// no classes
				//
				delete [] pList;
				return S_FALSE;
			}
			for(c=0;c<nClasses;c++) {
				if(FindDuplicate(&pList[c])) {
					continue;
				}
				hr = AddGuid(&pList[c]);
				if(FAILED(hr)) {
					delete [] pList;
					return hr;
				}
			}
			delete [] pList;
			return hr;
		}
	}
	Err = GetLastError();
	return HRESULT_FROM_SETUPAPI(Err);
}


HRESULT CSetupClasses::AddGuid(GUID *pGuid)
{
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}
	CComObject<CSetupClass> *d;	
	HRESULT hr;
	hr = CComObject<CSetupClass>::CreateInstance(&d);
	if(FAILED(hr)) {
		return hr;
	}
	d->AddRef();
	hr = d->Init(pGuid,pMachine,DeviceConsole);
	if(FAILED(hr)) {
		d->Release();
		return hr;
	}
	pSetupClasses[Count++] = d;
	return S_OK;
}

STDMETHODIMP CSetupClasses::Add(VARIANT ClassNames)
{
	//
	// can pass in a collection
	//
	CComObject<CStrings> *pStrings = NULL;
	HRESULT hr;
	DWORD c;
	BSTR str;

	hr = CComObject<CStrings>::CreateInstance(&pStrings);
	if(FAILED(hr)) {
		return hr;
	}

	pStrings->AddRef();
	hr = pStrings->InternalInsert(0,&ClassNames);
	if(FAILED(hr)) {
		pStrings->Release();
		return hr;
	}

	for(c=0;pStrings->InternalEnum(c,&str);c++) {
		hr = AppendClass(str);
		if(FAILED(hr)) {
			pStrings->Release();
			return hr;
		}
	}
	pStrings->Release();
	return c ? S_OK : S_FALSE;
}

BOOL CSetupClasses::FindDuplicate(GUID *pGuid)
{
	DWORD c;
	for(c=0;c<Count;c++) {
		if(pSetupClasses[c]->IsDuplicate(pGuid)) {
			return TRUE;
		}
	}
	return FALSE;
}


STDMETHODIMP CSetupClasses::Remove(VARIANT v)
{
	// TODO: Add your implementation code here

	return S_OK;
}

HRESULT CSetupClasses::GetIndex(LPVARIANT Index, DWORD *pAt)
{
	CComVariant v;
	HRESULT hr;
	if(IsNumericVariant(Index)) {
		hr = v.ChangeType(VT_I4,Index);
		if(FAILED(hr)) {
			return DISP_E_TYPEMISMATCH;
		}
		if(V_I4(&v)<1) {
			return E_INVALIDARG;
		}
		*pAt = ((DWORD)V_I4(&v))-1;
		return S_OK;
	}
	//
	// user actually supplied guid?
	//
	hr = v.ChangeType(VT_BSTR,Index);
	if(FAILED(hr)) {
		return DISP_E_TYPEMISMATCH;
	}
	if(!Count) {
		//
		// cannot match anything
		//
		return E_INVALIDARG;
	}
	BSTR pMatch = V_BSTR(&v);
	if(pMatch[0]!=L'{') {
		return E_INVALIDARG;
	}
	//
	// obtain GUID
	//
	GUID guid;
	hr = CLSIDFromString((LPWSTR)pMatch,&guid);
	if(FAILED(hr)) {
		return hr;
	}
	DWORD c;
	for(c=0;c<Count;c++) {
		if(pSetupClasses[c]->IsDuplicate(&guid)) {
			*pAt = c;
			return S_OK;
		}
	}
	//
	// still none found
	//
	return E_INVALIDARG;
}

STDMETHODIMP CSetupClasses::Devices(VARIANT flags, LPDISPATCH *pDevices)
{
	//
	// combine devices for all classes
	//
	DWORD diflags = 0;
	HRESULT hr;
	HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
	HDEVINFO hPrevDevInfo = NULL;
	DWORD Err;
	DWORD c;

	hr = TranslateDeviceFlags(&flags,&diflags);
	if(FAILED(hr)) {
		return hr;
	}
	for(c=0;c<Count;c++) {
		hDevInfo = SetupDiGetClassDevsEx(pSetupClasses[c]->Guid(),NULL,NULL,diflags,hPrevDevInfo,pMachine,NULL);
		if(hDevInfo == INVALID_HANDLE_VALUE) {
			Err = GetLastError();
			if(hPrevDevInfo) {
				SetupDiDestroyDeviceInfoList(hPrevDevInfo);
			}
			return HRESULT_FROM_SETUPAPI(Err);
		}
		hPrevDevInfo = hDevInfo;
	}
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		return E_INVALIDARG;
	}

	CComObject<CDevices> *d;	
	hr = CComObject<CDevices>::CreateInstance(&d);
	if(FAILED(hr)) {
		SetupDiDestroyDeviceInfoList(hDevInfo);
		return hr;
	}
	d->AddRef();
	hr = d->Init(hDevInfo,DeviceConsole);
	if(FAILED(hr)) {
		d->Release();
		return hr;
	}
	*pDevices = d;
	return S_OK;
}

HRESULT CSetupClasses::AllClasses()
{
	DWORD nClasses;
	DWORD nClasses2;
	DWORD c;
	DWORD Err;
	HRESULT hr;

	//
	// start with empty list
	//
	if(pSetupClasses) {
		for(c=0;c<Count;c++) {
			pSetupClasses[c]->Release();
		}
		delete [] pSetupClasses;
	}
	//
	// all classes
	//
	if(SetupDiBuildClassInfoListEx(0,NULL,0,&nClasses,pMachine,NULL) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
		if(!nClasses) {
			//
			// no classes
			//
			return S_FALSE;
		}
		GUID *pList = new GUID[nClasses];
		if(!pList) {
			return E_OUTOFMEMORY;
		}
		if(SetupDiBuildClassInfoListEx(0,pList,nClasses,&nClasses2,pMachine,NULL) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
			//
			// count may have changed since last call
			//
			if(nClasses>nClasses2) {
				nClasses = nClasses2;
			}
			if(!nClasses) {
				//
				// no classes
				//
				delete [] pList;
				return S_FALSE;
			}
			for(c=0;c<nClasses;c++) {
				hr = AddGuid(&pList[c]);
				if(FAILED(hr)) {
					delete [] pList;
					return hr;
				}
			}
			delete [] pList;
			return hr;
		}
	}
	Err = GetLastError();
	return HRESULT_FROM_SETUPAPI(Err);
}

STDMETHODIMP CSetupClasses::get_Machine(BSTR *pVal)
{
	if((pMachine == NULL) || !pMachine[0]) {
		*pVal = SysAllocString(L"");
		if(*pVal) {
			return S_FALSE;
		}
	} else {
		*pVal = SysAllocString(pMachine);
		if(*pVal) {
			return S_OK;
		}
	}
	*pVal = NULL;
	return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2B158C89_9DAA_42AD_BAF7_44D5FA3A7C53__INCLUDED_)
#define AFX_STDAFX_H__2B158C89_9DAA_42AD_BAF7_44D5FA3A7C53__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//
// DCOM support (note, this must occur after atlbase.h but before anything else)
//
class CMyModule : public CComModule
{
public:
    CMyModule() {
        bServer = FALSE;
        punkFact = NULL;
        dwROC = 0;
    }
    LONG Unlock();
    void CheckShutdown();
    void KillServer();
    HRESULT InitServer(GUID & ClsId);
    bool bServer;
    IUnknown* punkFact;
    DWORD dwROC;
};
extern CMyModule _Module;

#include <atlcom.h>
#include <setupapi.h>
#include <devguid.h>
#include <cfgmgr32.h>
#include <regstr.h>
#include <atlctl.h>
#include <string>
#include <map>
#include <list>
#include <iterator>
#include <iostream>
#include <stdexcept>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2B158C89_9DAA_42AD_BAF7_44D5FA3A7C53__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\stringsenum.cpp ===
// StringsEnum.cpp : Implementation of CDevCon2App and DLL registration.

#include "stdafx.h"
#include "DevCon2.h"
#include "StringsEnum.h"

/////////////////////////////////////////////////////////////////////////////
//

CStringsEnum::~CStringsEnum()
{
	DWORD c;
	if(pMultiStrings) {
		for(c=0;c<Count;c++) {
			SysFreeString(pMultiStrings[c]);
		}
		delete [] pMultiStrings;
	}
}


HRESULT CStringsEnum::Next(
                ULONG celt,
                VARIANT * rgVar,
                ULONG * pCeltFetched
            )
{
	ULONG fetched;
	ULONG i;
	BSTR b;
	if(pCeltFetched) {
		*pCeltFetched = 0;
	}
	for(fetched = 0; fetched<celt && Position<Count ; fetched++,Position++) {
		VariantInit(&rgVar[fetched]);

		b = SysAllocStringLen(pMultiStrings[Position],SysStringLen(pMultiStrings[Position]));
		if(!b) {
			for(i=0;i<fetched;i++) {
				VariantClear(&rgVar[i]);
			}
			return E_OUTOFMEMORY;
		}
		V_VT(&rgVar[fetched]) = VT_BSTR;
		V_BSTR(&rgVar[fetched]) = b;
	}
	if(pCeltFetched) {
		*pCeltFetched = fetched;
	}
	return (fetched<celt) ? S_FALSE : S_OK;
}

HRESULT CStringsEnum::Skip(
                ULONG celt
            )
{
	DWORD remaining = Count-Position;
	if(remaining<celt) {
		Position = Count;
		return S_FALSE;
	} else {
		Position += (DWORD)celt;
		return S_OK;
	}
}

HRESULT CStringsEnum::Reset(
            )
{
	Position = 0;
	return S_OK;
}

HRESULT CStringsEnum::Clone(
                IEnumVARIANT ** ppEnum
            )
{
	*ppEnum = NULL;
	HRESULT hr;
	CComObject<CStringsEnum> *pEnum = NULL;
	hr = CComObject<CStringsEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	if(!pEnum->CopyStrings(pMultiStrings,Count)) {
		delete pEnum;
		return E_OUTOFMEMORY;
	}
	pEnum->Position = Position;

	pEnum->AddRef();
	*ppEnum = pEnum;

	return S_OK;
}

BOOL CStringsEnum::CopyStrings(BSTR *pArray, DWORD NewCount)
{
	DWORD c;

	if(pMultiStrings) {
		delete [] pMultiStrings;
		pMultiStrings = NULL;
	}
	Count = 0;
	Position = 0;
	pMultiStrings = new BSTR[NewCount];
	if(!pMultiStrings) {
		return FALSE;
	}
	for(c=0;c<NewCount;c++) {
		pMultiStrings[c] = SysAllocStringLen(pArray[c],SysStringLen(pArray[c]));
		if(!pMultiStrings[c]) {
			Count = c;
			return FALSE;
		}
	}
	Count = NewCount;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\strings.cpp ===
// Strings.cpp : Implementation of CStrings
#include "stdafx.h"
#include "DevCon2.h"
#include "xStrings.h"
#include "StringsEnum.h"
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////
// CStrings

CStrings::~CStrings()
{
	DWORD c;
	if(pMultiStrings) {
		for(c=0;c<Count;c++) {
			SysFreeString(pMultiStrings[c]);
		}
		delete [] pMultiStrings;
	}
}

STDMETHODIMP CStrings::get_Count(long *pVal)
{
	*pVal = (long)Count;
	return S_OK;
}

STDMETHODIMP CStrings::Item(VARIANT Index, VARIANT *pVal)
{
	HRESULT hr;
	DWORD i;
	BSTR ValueCopy = NULL;
	if(!IsNoArg(&Index)) {
		//
		// get single value
		//
		hr = GetIndex(&Index,&i);
		if(FAILED(hr)) {
			return hr;
		}
		ValueCopy = SysAllocStringLen(pMultiStrings[i],SysStringLen(pMultiStrings[i]));
		if(!ValueCopy) {
			return E_OUTOFMEMORY;
		}
		VariantInit(pVal);
		V_VT(pVal) = VT_BSTR;
		V_BSTR(pVal) = ValueCopy;
		return S_OK;
	}
	//
	// return collection as an array of strings
	//
#if 1
	SAFEARRAY *pArray;
	SAFEARRAYBOUND bounds[1];
	LONG ind[1];
	bounds[0].lLbound = 1;
	bounds[0].cElements = Count;
	VARIANT v;
	pArray = SafeArrayCreate(VT_VARIANT,1,bounds);
	if(!pArray) {
		return E_OUTOFMEMORY;
	}
	DWORD c;
	VariantInit(&v);
	for(c=0;c<Count;c++) {
		ind[0] = (LONG)(c+1);
		V_VT(&v) = VT_BSTR;
		V_BSTR(&v) = pMultiStrings[c];

		hr = SafeArrayPutElement(pArray,ind,&v);
		if(FAILED(hr)) {
			SafeArrayDestroy(pArray);
			return hr;
		}
	}
	VariantInit(pVal);
	V_VT(pVal) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(pVal) = pArray;
#else
	SAFEARRAY *pArray;
	SAFEARRAYBOUND bounds[1];
	LONG ind[1];
	bounds[0].lLbound = 1;
	bounds[0].cElements = Count;
	pArray = SafeArrayCreate(VT_BSTR,1,bounds);
	if(!pArray) {
		return E_OUTOFMEMORY;
	}
	DWORD c;
	for(c=0;c<Count;c++) {
		ind[0] = (LONG)(c+1);
		hr = SafeArrayPutElement(pArray,ind,pMultiStrings[c]);
		if(FAILED(hr)) {
			SafeArrayDestroy(pArray);
			return hr;
		}
	}
	VariantInit(pVal);
	V_VT(pVal) = VT_ARRAY | VT_BSTR;
	V_ARRAY(pVal) = pArray;
#endif

	
	return S_OK;
}

STDMETHODIMP CStrings::get__NewEnum(IUnknown **ppUnk)
{
	*ppUnk = NULL;
	HRESULT hr;
	CComObject<CStringsEnum> *pEnum = NULL;
	hr = CComObject<CStringsEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	pEnum->AddRef();
	if(!pEnum->CopyStrings(pMultiStrings,Count)) {
		pEnum->Release();
		return E_OUTOFMEMORY;
	}

	*ppUnk = pEnum;

	return S_OK;
}


HRESULT CStrings::InternalAdd(LPCWSTR Value, UINT len)
{
	if(len == (UINT)(-1)) {
		len = wcslen(Value);
	}
	BSTR ValueCopy = NULL;
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}
	ValueCopy = SysAllocStringLen(Value,len);
	if(!ValueCopy) {
		return E_OUTOFMEMORY;
	}
	pMultiStrings[Count++] = ValueCopy;

	return S_OK;
}

STDMETHODIMP CStrings::Add(VARIANT Value)
{
	return InternalInsert(Count,&Value);
}

BOOL CStrings::IncreaseArraySize(DWORD strings)
{
	BSTR* pNewStrings;
	DWORD Inc;
	DWORD c;

	if((ArraySize-Count)>=strings) {
		return TRUE;
	}
	Inc = ArraySize + strings + 32;
	pNewStrings = new BSTR[Inc];
	if(!pNewStrings) {
		return FALSE;
	}
	for(c=0;c<Count;c++) {
		pNewStrings[c] = pMultiStrings[c];
	}
	delete [] pMultiStrings;
	pMultiStrings = pNewStrings;
	ArraySize = Inc;
	return TRUE;
}

STDMETHODIMP CStrings::Insert(VARIANT Index, VARIANT Value)
{
	HRESULT hr;
	DWORD i;
	hr = GetIndex(&Index,&i);
	if(FAILED(hr)) {
		return hr;
	}
	//
	// allow i==Count
	//
	if(i>Count) {
		return E_INVALIDARG;
	}
	return InternalInsert(i,&Value);
}

STDMETHODIMP CStrings::Remove(VARIANT Index)
{
	HRESULT hr;
	DWORD i;
	hr = GetIndex(&Index,&i);
	if(FAILED(hr)) {
		return hr;
	}
	if(i>=Count) {
		return E_INVALIDARG;
	}

	DWORD c;

	SysFreeString(pMultiStrings[i]);
	Count--;
	for(c=i;c<Count;c++) {
		pMultiStrings[c] = pMultiStrings[c+1];
	}

	return S_OK;
}

HRESULT CStrings::InternalInsert(DWORD Index, LPVARIANT pVal)
{
	CComVariant v;
	HRESULT hr;
	SAFEARRAY *pArray;
	VARTYPE vt;
	CComPtr<IEnumVARIANT> pEnum;

	if(IsArrayVariant(pVal,&pArray,&vt)) {
		return InternalInsertArray(Index,vt,pArray);
	}
	if(IsCollectionVariant(pVal,&pEnum)) {
		return InternalInsertCollection(Index,pEnum);
	}
	//
	// now see if we can treat it as a string
	//
	hr = v.ChangeType(VT_BSTR,pVal);
	if(SUCCEEDED(hr)) {
		return InternalInsertString(Index,V_BSTR(&v));
	}
	return hr;
}

HRESULT CStrings::InternalInsertArray(DWORD Index, VARTYPE vt, SAFEARRAY *pArray)
{
	HRESULT hr;
	UINT dims = SafeArrayGetDim(pArray);
	if(!dims) {
		return S_FALSE;
	}
	long *pDims = new long[dims];
	if(!pDims) {
		return E_OUTOFMEMORY;
	}

	//
	// write values into a temporary collection
	//
	CComObject<CStrings> *pStringTemp = NULL;
	hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
	if(FAILED(hr)) {
		delete [] pDims;
		return hr;
	}
	pStringTemp->AddRef();

	hr = InternalInsertArrayDim(pStringTemp,vt,pArray,pDims,0,dims);
	delete [] pDims;
	if(FAILED(hr)) {
		pStringTemp->Release();
		return hr;
	}
	//
	// now quickly insert pStringTemp strings into this collection
	//
	DWORD Added = pStringTemp->Count;
	if(!IncreaseArraySize(Added)) {
		pStringTemp->Release();
		return E_OUTOFMEMORY;
	}
	DWORD c;
	for(c=Count;c>Index;c--) {
		pMultiStrings[c-1+Added] = pMultiStrings[c-1];
	}
	for(c=0;c<Added;c++) {
		pMultiStrings[Index+c] = pStringTemp->pMultiStrings[c];
	}
	Count += Added;
	//
	// throw strings in temp collection away without free'ing them
	//
	pStringTemp->Count = 0;
	pStringTemp->Release();

	return S_OK;
}

HRESULT CStrings::InternalInsertArrayDim(CComObject<CStrings> *pStringTemp, VARTYPE vt, SAFEARRAY *pArray,long *pDims,UINT dim,UINT dims)
{
	long lower;
	long upper;
	long aIndex;
	HRESULT hr;
	UINT nextdim = dim+1;

	hr = SafeArrayGetLBound(pArray,nextdim,&lower);
	if(FAILED(hr)) {
		return hr;
	}
	hr = SafeArrayGetUBound(pArray,nextdim,&upper);
	if(FAILED(hr)) {
		return hr;
	}
	if(nextdim<dims) {
		for(aIndex=lower;aIndex<=upper;aIndex++) {
			pDims[dim] = aIndex;
			hr = InternalInsertArrayDim(pStringTemp,vt,pArray,pDims,nextdim,dims);
			if(FAILED(hr)) {
				return hr;
			}
		}
		return S_OK;
	}
	if(upper-lower<0) {
		return S_OK;
	}
	//
	// write values for this vector
	//
	UINT elemsize = SafeArrayGetElemsize(pArray);
	PBYTE buffer = new BYTE[elemsize];
	if(!buffer) {
		return E_OUTOFMEMORY;
	}
	for(aIndex=lower;aIndex<=upper;aIndex++) {
		pDims[dim] = aIndex;
		hr = SafeArrayGetElement(pArray,pDims,buffer);
		if(FAILED(hr)) {
			delete [] buffer;
			return hr;
		}
		VARIANT v;
		if(elemsize < sizeof(VARIANT)) {
			VariantInit(&v);
			V_VT(&v) = vt & ~(VT_ARRAY|VT_VECTOR|VT_BYREF);
			memcpy(&V_BYREF(&v),buffer,elemsize);
		} else {
			memcpy(&v,buffer,sizeof(v));
		}
		if(V_VT(&v)!=VT_EMPTY) {
			//
			// only add non-empty items
			//
			hr = pStringTemp->Add(v);
		}
		VariantClear(&v);
		if(FAILED(hr)) {
			delete [] buffer;
			return hr;
		}
	}
	return S_OK;
}

HRESULT CStrings::InternalInsertCollection(DWORD Index, IEnumVARIANT *pEnum)
{
	pEnum->Reset();
	CComVariant ent;
	//
	// get first item - this allows us to do little work if
	// source collection is empty
	//
	HRESULT hr = pEnum->Next(1,&ent,NULL);
	if(FAILED(hr)) {
		return hr;
	}
	if(hr != S_OK) {
		//
		// empty
		//
		return S_FALSE;
	}
	//
	// create a temporary collection for working
	//
	CComObject<CStrings> *pStringTemp = NULL;
	hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
	if(FAILED(hr)) {
		return hr;
	}
	pStringTemp->AddRef();
	do {
		//
		// this will recursively process an element of this collection
		//
		hr = pStringTemp->Add(ent);
		if(FAILED(hr)) {
			break;
		}
		//
		// next
		//
		ent.Clear();
		hr = pEnum->Next(1,&ent,NULL);
	} while(hr == S_OK);
	if(FAILED(hr)) {
		pStringTemp->Release();
		return hr;
	}
	//
	// now quickly insert pStringTemp strings into this collection
	//
	DWORD Added = pStringTemp->Count;
	if(!IncreaseArraySize(Added)) {
		pStringTemp->Release();
		return E_OUTOFMEMORY;
	}
	DWORD c;
	for(c=Count;c>Index;c--) {
		pMultiStrings[c-1+Added] = pMultiStrings[c-1];
	}
	for(c=0;c<Added;c++) {
		pMultiStrings[Index+c] = pStringTemp->pMultiStrings[c];
	}
	Count += Added;
	//
	// throw strings in temp collection away without free'ing them
	//
	pStringTemp->Count = 0;
	pStringTemp->Release();

	return S_OK;
}

HRESULT CStrings::InternalInsertString(DWORD Index, BSTR pString)
{
	DWORD c;
	BSTR ValueCopy = NULL;

	if(Index>Count) {
		return E_INVALIDARG;
	}
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}
	ValueCopy = SysAllocStringLen(pString,SysStringLen(pString));
	if(!ValueCopy) {
		return E_OUTOFMEMORY;
	}
	for(c=Count;c>Index;c--) {
		pMultiStrings[c] = pMultiStrings[c-1];
	}	
	pMultiStrings[Index] = ValueCopy;
	Count++;

	return S_OK;
}

HRESULT CStrings::GetMultiSz(LPWSTR *pResult, DWORD *pSize)
{
	//
	// get a multi-sz buffer from this list of strings
	//
	DWORD c;
	DWORD buflen = 1;
	DWORD actlen = 0;
	LPWSTR buffer = NULL;
	for(c=0;c<Count;c++) {
		//
		// estimate buffer size
		//
		DWORD ellen = SysStringLen(pMultiStrings[c]);
		if(ellen) {
			buflen += ellen+1;
		}
	}
	buffer = new WCHAR[buflen];
	if(!buffer) {
		return E_OUTOFMEMORY;
	}
	for(c=0;c<Count;c++) {
		//
		// first NULL of string might be inside string
		// in such a case, terminate string there
		//
		DWORD ellen = wcslen(pMultiStrings[c]);
		if(ellen == 0) {
			continue;
		}
		memcpy(buffer+actlen,pMultiStrings[c],ellen*sizeof(WCHAR));
		actlen += ellen;
		buffer[actlen++] = 0;
	}
	buffer[actlen++] = 0;
	*pResult = buffer;
	*pSize = actlen;
	return S_OK;
}

HRESULT CStrings::FromMultiSz(LPCWSTR pMultiSz)
{
	//
	// append to list from multi-sz
	// usually used with a temporary/new CStrings
	//
	DWORD len = 0;
	HRESULT hr;
	for(;*pMultiSz;pMultiSz+=len+1) {
		len = wcslen(pMultiSz);
		hr = InternalAdd(pMultiSz,len);
		if(FAILED(hr)) {
			return hr;
		}
	}
	return S_OK;
}

HRESULT CStrings::GetIndex(VARIANT *Index, DWORD *pAt)
{
	CComVariant v;
	HRESULT hr;
	if(IsNumericVariant(Index)) {
		hr = v.ChangeType(VT_I4,Index);
		if(FAILED(hr)) {
			return DISP_E_TYPEMISMATCH;
		}
		if(V_I4(&v)<1) {
			return E_INVALIDARG;
		}
		*pAt = ((DWORD)V_I4(&v))-1;
		return S_OK;
	}
	//
	// user actually supplied instance id
	//
	hr = v.ChangeType(VT_BSTR,Index);
	if(FAILED(hr)) {
		return DISP_E_TYPEMISMATCH;
	}
	if(!Count) {
		//
		// cannot match anything
		//
		return E_INVALIDARG;
	}
	//
	// find an existing device that matches this
	//
	DWORD c;
	for(c=0;c<Count;c++) {
		if(wcscmp(pMultiStrings[c],V_BSTR(&v))==0) {
			*pAt = c;
			return S_OK;
		}
	}
	//
	// none found, run through again ignoring case
	//
	if(!IsCaseSensative) {
		for(c=0;c<Count;c++) {
			if(_wcsicmp(pMultiStrings[c],V_BSTR(&v))==0) {
				*pAt = c;
				return S_OK;
			}
		}
	}

	//
	// still none found
	//
	return E_INVALIDARG;
}

BOOL CStrings::InternalEnum(DWORD index,BSTR *pNext)
{
	//
	// note that pNext returned is not a unique string
	//
	if(index>=Count) {
		return FALSE;
	}
	*pNext = pMultiStrings[index];
	return TRUE;
}

STDMETHODIMP CStrings::Find(BSTR name, long *pFound)
{
	//
	// find an existing device that matches this
	//
	DWORD c;
	for(c=0;c<Count;c++) {
		if(wcscmp(pMultiStrings[c],name)==0) {
			*pFound = (long)(c+1);
			return S_OK;
		}
	}
	//
	// none found, run through again ignoring case
	//
	if(!IsCaseSensative) {
		for(c=0;c<Count;c++) {
			if(_wcsicmp(pMultiStrings[c],name)==0) {
				*pFound = (long)(c+1);
				return S_OK;
			}
		}
	}

	*pFound = 0;
	return S_FALSE;
}

STDMETHODIMP CStrings::get_CaseSensative(VARIANT_BOOL *pVal)
{
	*pVal = IsCaseSensative ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CStrings::put_CaseSensative(VARIANT_BOOL newVal)
{
	IsCaseSensative = newVal ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\utils.h ===
//
// utils.h
//

inline BOOL IsNumericVariant(VARIANT * pVar)
{
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    if((V_VT(pVar) & ~(VT_TYPEMASK|VT_BYREF)) != 0) {
        return FALSE;
    }
    switch(V_VT(pVar) & VT_TYPEMASK) {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        case VT_INT:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        case VT_UINT:
        case VT_R4:
        case VT_R8:
            return TRUE;
    }
    return FALSE;
}

inline BOOL IsArrayVariant(VARIANT * pVar,SAFEARRAY **pArray,VARTYPE *pType)
{
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    if(!V_ISARRAY(pVar)) {
        return FALSE;
    }
    if(pArray) {
        if(V_ISBYREF(pVar)) {
            *pArray = *V_ARRAYREF(pVar);
        } else {
            *pArray = V_ARRAY(pVar);
        }
    }
    if(pType) {
        *pType = V_VT(pVar) & VT_TYPEMASK;
    }
    return TRUE;
}

inline BOOL IsCollectionVariant(VARIANT * pVar,IEnumVARIANT ** pCollection)
{
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    CComVariant v;
    HRESULT hr = v.ChangeType(VT_DISPATCH,pVar);
    if(FAILED(hr)) {
        return FALSE;
    }
    //
    // look for an enumerator
    //
    DISPPARAMS params;
    LPDISPATCH pDisp = V_DISPATCH(&v);
    if(!pDisp) {
        return FALSE;
    }
    CComVariant result;
    params.cArgs = 0;
    params.cNamedArgs = 0;
    hr = pDisp->Invoke(DISPID_NEWENUM,
                        IID_NULL,
                        0,
                        DISPATCH_PROPERTYGET,
                        &params,
                        &result,
                        NULL,
                        NULL);

    if(FAILED(hr)) {
        return FALSE;
    }
    hr = result.ChangeType(VT_UNKNOWN);
    if(FAILED(hr)) {
        return FALSE;
    }
    IEnumVARIANT *pEnum;
    hr = V_UNKNOWN(&result)->QueryInterface(IID_IEnumVARIANT,(LPVOID*)&pEnum);
    if(FAILED(hr)) {
        return FALSE;
    }
    if(pCollection) {
        *pCollection = pEnum;
    } else {
        pEnum->Release();
    }
    return TRUE;
}

inline BOOL IsMultiValueVariant(VARIANT * pVar)
{
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    if(IsArrayVariant(pVar,NULL,NULL)) {
        return TRUE;
    }
    if(IsCollectionVariant(pVar,NULL)) {
        return TRUE;
    }
    return FALSE;
}

inline BOOL IsNoArg(LPVARIANT pVar)
{
    //
    // explicit "no parameter"
    //
    if((V_VT(pVar) == VT_ERROR) && (V_ERROR(pVar) == (DISP_E_PARAMNOTFOUND))) {
        return TRUE;
    }
    return FALSE;
}

inline BOOL IsBlank(LPVARIANT pVar)
{
    //
    // flexable "no parameter" allow 'null' 'nothing'
    //
    if(IsNoArg(pVar)) {
        return TRUE;
    }
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    if(V_ISBYREF(pVar) && !V_BYREF(pVar)) {
        return TRUE;
    }
    if((V_VT(pVar) == VT_EMPTY) || (V_VT(pVar) == VT_NULL)) {
        return TRUE;
    }
    if(((V_VT(pVar) == VT_UNKNOWN) || (V_VT(pVar) == VT_DISPATCH))  && !V_UNKNOWN(pVar)) {
        return TRUE;
    }
    if(((V_VT(pVar) == (VT_BYREF|VT_UNKNOWN)) || (V_VT(pVar) == (VT_BYREF|VT_DISPATCH)))
        && !(V_UNKNOWNREF(pVar) && *V_UNKNOWNREF(pVar))) {
        return TRUE;
    }
    //
    // consider everything else as a parameter
    //
    return FALSE;
}

inline BOOL IsBlankString(LPVARIANT pVar)
{
    //
    // even more flexable, allow "" too
    //
    if(IsBlank(pVar)) {
        return TRUE;
    }
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    if(V_VT(pVar) == VT_BSTR) {
        return SysStringLen(V_BSTR(pVar)) ? FALSE : TRUE;
    }
    if(V_VT(pVar) == (VT_BYREF|VT_BSTR)) {
        return (V_BSTRREF(pVar) && SysStringLen(*V_BSTRREF(pVar))) ? FALSE : TRUE;
    }
    return FALSE;
}

#define DEVFLAGS_HIDDEN        0x00000001
#define DEVFLAGS_SINGLEPROFILE 0x00000002
#define DEVFLAGS_ALL            0x00000003

inline HRESULT TranslateDeviceFlags(LPVARIANT flags,DWORD * di_flags)
{
    long fl_final = 0;
    CComVariant v;
    HRESULT hr;

    if(flags) {
        if(IsNoArg(flags)) {
            fl_final = 0;
        } else if(IsNumericVariant(flags)) {
            hr = v.ChangeType(VT_I4,flags);
            if(FAILED(hr)) {
                return hr;
            }
            fl_final = V_I4(&v);
        } else {
            return E_INVALIDARG;
        }
    }

    *di_flags = 0;
    if(fl_final & ~(DEVFLAGS_ALL)) {
        return E_INVALIDARG;
    }
    if(!(fl_final & DEVFLAGS_HIDDEN)) {
        *di_flags |= DIGCF_PRESENT;
    }
    if(fl_final & DEVFLAGS_SINGLEPROFILE) {
        *di_flags |= DIGCF_PROFILE;
    }

    return S_OK;
}

inline HRESULT GetOptionalString(LPVARIANT param,CComVariant &store,LPCWSTR *pString)
{
    HRESULT hr;

    *pString = NULL;
    if(param) {
        if(IsBlank(param)) {
            return S_OK;
        }
        hr = store.ChangeType(VT_BSTR,param);
        if(FAILED(hr)) {
            return hr;
        }
        *pString = V_BSTR(&store);
        return S_OK;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\stringsenum.h ===
// StringsEnum.h: Definition of the CStringsEnum class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRINGSENUM_H__2DABC6B9_80D8_4E73_B4A9_7031AB8DF930__INCLUDED_)
#define AFX_STRINGSENUM_H__2DABC6B9_80D8_4E73_B4A9_7031AB8DF930__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CStringsEnum
#include "xStrings.h"

class ATL_NO_VTABLE CStringsEnum : 
	public IStringsEnum,
	public CComObjectRootEx<CComSingleThreadModel>
{
protected:
	BSTR* pMultiStrings;
	DWORD Count;
	DWORD Position;

public:
	CStringsEnum() {
		Position = 0;
		pMultiStrings = NULL;
		Count = 0;
	}
	~CStringsEnum();

BEGIN_COM_MAP(CStringsEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
	COM_INTERFACE_ENTRY(IStringsEnum)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CStringsEnum) 

// IStringsEnum
public:
	BOOL CopyStrings(BSTR *pArray,DWORD Count);
    STDMETHOD(Next)(
                /*[in]*/ ULONG celt,
                /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar,
                /*[out]*/ ULONG * pCeltFetched
            );
    STDMETHOD(Skip)(
                /*[in]*/ ULONG celt
            );

    STDMETHOD(Reset)(
            );

    STDMETHOD(Clone)(
                /*[out]*/ IEnumVARIANT ** ppEnum
            );
};

#endif // !defined(AFX_STRINGSENUM_H__2DABC6B9_80D8_4E73_B4A9_7031AB8DF930__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\dock\dock.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    locate.c

Abstract:

    This module contains the code
    for finding, adding, removing, and identifying hid devices.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include <basetyps.h>
#include <stdlib.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <stdio.h>
#include <winioctl.h>
#include "dock.h"

#define USAGE "Usage: dock [-e] [-v] [-f]\n" \
              "\t -e eject dock\n"  \
              "\t -v verbose\n" \
              "\t -f force\n"

VOID
DockStartEject (
    BOOLEAN Verbose,
    BOOLEAN Force
    );


__cdecl
main (
  ULONG argc,
  CHAR *argv[]
  )
/*++
++*/
{
    BOOLEAN eject = FALSE;
    BOOLEAN verbose = FALSE;
    BOOLEAN force = FALSE;
    BOOLEAN error = FALSE;
    ULONG i;
    char * parameter = NULL;

    //
    // parameter parsing follows:
    //
    try {
        if (argc < 2) {
            leave;
        }

        for (i = 1; i < argc; i++) {
            parameter = argv[i];

            if ('-' == *(parameter ++)) {
                switch (*parameter) {
                case 'e':
                    eject = TRUE;
                    break;

                case 'v':
                    verbose = TRUE;
                    break;

                case 'f':
                    force = TRUE;
                    break;

                default:
                    error = TRUE;
                    leave;
                }
            } else {
                error = TRUE;
                leave;
            }
        }


    } finally {
        if (error || ((!eject) && (!verbose))) {
            printf (USAGE);
            exit (1);
        }
        if (verbose) {
            printf ("Verbose Mode Requested \n");
        }
        if (eject) {
            printf ("Eject Requested \n");
            DockStartEject (verbose, force);
        }
    }

    printf("Done\n");

    return 0;
}


VOID
DockStartEject (
    BOOLEAN Verbose,
    BOOLEAN Force
    )
/*++

--*/
{
    CONFIGRET   status;
    BOOL        present;

    if (Verbose) {
        printf("Checking if Dock Present\n");
    }

    status = CM_Is_Dock_Station_Present (&present);

    if (Verbose) {
        printf("ret 0x%x, Present %s\n",
               status,
               (present ? "TRUE" : "FALSE"));
    }

    if (Force || present) {
        if (Verbose) {
            printf("Calling eject\n");
        }

        status = CM_Request_Eject_PC ();

        if (Verbose) {
            printf("ret 0x%x\n", status);
        }

    } else {
        printf("Skipping eject call\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\expackdll\compinst.c ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    msoobci.c

Abstract:

    Exception Pack installer helper DLL
    Can be used as a co-installer, or called via setup app, or RunDll32 stub

    This DLL is for internal distribution of exception packs to update
    OS components.

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#include "msoobcip.h"

typedef struct _CALLBACKDATA {
    PVOID pDefContext; // context for default queue callback
    LPCTSTR Media;     // where old root was
    LPCTSTR Store;     // where new root is
    BOOL    PreCopy;   // if using PreCopy section
} CALLBACKDATA;

HRESULT
HandleReboot(
    IN DWORD   Flags
    )
/*++

Routine Description:

    Prompt for and execute reboot

Arguments:

    Flags - how reboot should be handled

Return Value:

    INST_S_REBOOT
    INST_S_REBOOTING

--*/

{
    if(Flags & COMP_FLAGS_NOPROMPTREBOOT) {
        //
        // TODO
        // if set, reboot unconditionally
        //
        HANDLE Token;
        BOOL b;
        TOKEN_PRIVILEGES NewPrivileges;
        LUID Luid;

        //
        // we need to "turn on" reboot privilege
        // if any of this fails, try reboot anyway
        //
        if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
            goto try_reboot;
        }

        if(!LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&Luid)) {
            CloseHandle(Token);
            goto try_reboot;
        }

        NewPrivileges.PrivilegeCount = 1;
        NewPrivileges.Privileges[0].Luid = Luid;
        NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        AdjustTokenPrivileges(
                Token,
                FALSE,
                &NewPrivileges,
                0,
                NULL,
                NULL
                );

        CloseHandle(Token);

    try_reboot:

        //
        // attempt reboot - inform system that this is planned hardware install
        //
        if(ExitWindowsEx(EWX_REBOOT,
                            SHTDN_REASON_FLAG_PLANNED
                                |SHTDN_REASON_MAJOR_SOFTWARE
                                |SHTDN_REASON_MINOR_INSTALLATION)) {
            return INST_S_REBOOTING;
        }

    } else if(Flags & COMP_FLAGS_PROMPTREBOOT) {
        //
        // TODO
        // if set, prompt for reboot
        //
        if(IsInteractiveWindowStation()) {
            if(SetupPromptReboot(NULL,NULL,FALSE) & SPFILEQ_REBOOT_IN_PROGRESS) {
                return INST_S_REBOOTING;
            }
        }
    }
    return INST_S_REBOOT;
}

HRESULT
WINAPI
InstallInfSectionW(
    IN LPCTSTR InfPath,
    IN LPCWSTR SectionName, OPTIONAL
    IN DWORD   Flags
    )
/*++

Routine Description:

    Does an install along lines of InstallHinfSection

Arguments:

    InfPath - full path to INF file
    SectionName - name of section including any decoration

Return Value:

    status as hresult

--*/
{
    TCHAR SectionNameBuffer[LINE_LEN];
    TCHAR ServiceSection[LINE_LEN+32];
    HINF  hInf = INVALID_HANDLE_VALUE;
    HSPFILEQ hFileQueue = INVALID_HANDLE_VALUE;
    PVOID QueueContext = NULL;
    DWORD Status = NO_ERROR;
    BOOL reboot = FALSE;
    BOOL needUninstallInf = FALSE;
    INT res;
    INFCONTEXT InfLine;
    DWORD InstFlags;

    //
    // Some decisions are version based
    //

    //
    // Load the inf file
    //
    hInf = SetupOpenInfFile(InfPath, NULL, INF_STYLE_WIN4, NULL);
    if(hInf == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        goto final;
    }

    if(!SectionName) {
        //
        // determine section name
        //
        if(!SetupDiGetActualSectionToInstall(hInf,
                                             KEY_DEFAULTINSTALL,
                                             SectionNameBuffer,
                                             ARRAY_SIZE(SectionNameBuffer),
                                             NULL,
                                             NULL)) {
            Status = GetLastError();
            goto final;
        }
        SectionName = SectionNameBuffer;
    }

    //
    // Check to see if the install section has a "Reboot" line.
    // or otherwise reboot forced
    //
    if((Flags & COMP_FLAGS_NEEDSREBOOT)
       || (SetupFindFirstLine(hInf, SectionName, KEY_REBOOT, &InfLine))) {
        reboot = TRUE;
    }

    //
    // See if UI allowed
    //
    if(((Flags & COMP_FLAGS_NOUI)==0) && !IsInteractiveWindowStation()) {
        Flags |= COMP_FLAGS_NOUI;
    }

    //
    // Load any layout file
    //
    SetupOpenAppendInfFile(NULL, hInf, NULL);

    //
    // Create a setup file queue and initialize the default queue callback.
    //
    hFileQueue = SetupOpenFileQueue();
    if(hFileQueue == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        goto final;
    }
    QueueContext = SetupInitDefaultQueueCallbackEx(
                       NULL,
                       ((Flags & COMP_FLAGS_NOUI) ? INVALID_HANDLE_VALUE : NULL),
                       0,
                       0,
                       0
                      );

    if(!QueueContext) {
        Status = GetLastError();
        goto final;
    }

    if(!SetupInstallFilesFromInfSection(hInf,
                                        NULL,
                                        hFileQueue,
                                        SectionName,
                                        NULL,
                                        0              // SP_COPY_xxxx
                                        )) {
        Status = GetLastError();
        goto final;
    }
    //
    // Commit file queue.
    //
    if(!SetupCommitFileQueue(NULL, hFileQueue, SetupDefaultQueueCallback, QueueContext)) {
        Status = GetLastError();
        goto final;
    }

    //
    // Note, if the INF contains a (non-NULL) ClassGUID, then it will have
    // been installed into %windir%\Inf during the above queue committal.
    // We make no effort to subsequently uninstall it (and its associated
    // PNF and CAT) if something fails below.
    //
    needUninstallInf = TRUE;

    InstFlags = SPINST_ALL;
    if(g_VerInfo.dwMajorVersion < 5) {
        InstFlags = 0x1f;
    }

    if(!SetupInstallFromInfSection(NULL,
                                    hInf,
                                    SectionName,
                                    InstFlags &~ SPINST_FILES,
                                    NULL,           // HKEY_xxxx
                                    NULL,           // no copying...
                                    0,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL
                                    )) {
        Status = GetLastError();
        goto final;
    }
    lstrcpyn(ServiceSection,SectionName,LINE_LEN);
    lstrcat(ServiceSection,KEY_DOTSERVICES);
    //
    // If services section exists, install it
    //
    if(SetupFindFirstLine(hInf, ServiceSection, NULL, &InfLine)) {
        if(!SetupInstallServicesFromInfSection(hInf,ServiceSection,0)) {
            Status = GetLastError();
            goto final;
        }
        if(GetLastError() == ERROR_SUCCESS_REBOOT_REQUIRED) {
            reboot = TRUE;
        }
    }
    res = SetupPromptReboot(hFileQueue, NULL, TRUE);
    if((res!=-1) && (res & SPFILEQ_REBOOT_RECOMMENDED)) {
        reboot = TRUE;
    }

  final:

    if(QueueContext) {
        SetupTermDefaultQueueCallback(QueueContext);
    }
    if(hFileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(hFileQueue);
    }
    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
    if(Status == NO_ERROR) {
        //
        // are we meant to prompt for reboot?
        //
        if(reboot) {
            return HandleReboot(Flags);
        } else {
            return S_OK;
        }
    }
    if(needUninstallInf) {
        //
        // call SetupUninstallOEMInf ?
        //
    }
    return HRESULT_FROM_SETUPAPI(Status);
}

HRESULT
WINAPI
InstallInfSectionA(
    IN LPCSTR  InfPath,
    IN LPCSTR  SectionName, OPTIONAL
    IN DWORD   Flags
    )
{
    TCHAR OutPath[MAX_PATH];
    TCHAR OutSection[LINE_LEN]; // as per friendly name
    INT sz;
    if(InfPath) {
        sz = MultiByteToWideChar(CP_ACP,0,InfPath,-1,OutPath,ARRAY_SIZE(OutPath));
        if(!sz) {
            return E_INVALIDARG;
        }
    }
    if(SectionName) {
        sz = MultiByteToWideChar(CP_ACP,0,SectionName,-1,OutSection,ARRAY_SIZE(OutSection));
        if(!sz) {
            return E_INVALIDARG;
        }
    }
    return InstallInfSection(InfPath ? OutPath : NULL,
                                SectionName ? OutSection : NULL,
                                Flags);
}


HRESULT
AttemptStoreCopy(
    IN CALLBACKDATA *pCallbackData,
    IN LPCTSTR Root,   OPTIONAL
    IN LPCTSTR Source,
    IN LPCTSTR Target  OPTIONAL
    )
/*++

Routine Description:

    Copy from source to target, redirected to the expack store

Arguments:

    pCallbackData - as passed to PreCopyQueueCallback
    Root - root to source directory
    Source - source, relative to Root
    Target - target name

Return Value:

    status as hresult

--*/
{
    TCHAR FullSource[MAX_PATH];
    TCHAR FullTarget[MAX_PATH];
    LPTSTR SubDir;
    LPTSTR BaseName;
    LPTSTR DestName;
    LPCTSTR p;
    DWORD dwStatus;
    HRESULT hrStatus;

    if(Root) {
        lstrcpyn(FullSource,Root,MAX_PATH);
        hrStatus = ConcatPath(FullSource,MAX_PATH,Source);
        if(!SUCCEEDED(hrStatus)) {
            return hrStatus;
        }
    } else {
        lstrcpyn(FullSource,Source,MAX_PATH);
    }
    //
    // we want to determine the source sub-directory
    //
    SubDir = FullSource;
    p = pCallbackData->Media;
    while(*p && (*p == *SubDir)) {
        p = CharNext(p);
        SubDir = CharNext(SubDir);
    }
    if(*p || ((*SubDir != TEXT('\\')) && (*SubDir != TEXT('/')))) {
        //
        // not a sub-directory of media
        //
        DebugPrint(TEXT("Not copying \"%s\" (not subdirectory of \"%s\")"),FullSource,pCallbackData->Media);
        return E_FAIL;
    }
    lstrcpyn(FullTarget,pCallbackData->Store,MAX_PATH);
    hrStatus = ConcatPath(FullTarget,MAX_PATH,SubDir);
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    if(Target) {
        //
        // change final name of this
        //
        BaseName = GetBaseName(Target);
        DestName = GetBaseName(FullTarget);
        if(((DestName-FullTarget)+lstrlen(BaseName))>=MAX_PATH) {
            return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        lstrcpy(DestName,BaseName);
    }
    if(GetFileAttributes(FullTarget)!=INVALID_FILE_ATTRIBUTES) {
        //
        // allow file to be replaced
        //
        SetFileAttributes(FullTarget,FILE_ATTRIBUTE_NORMAL);
    }
    MakeSureParentPathExists(FullTarget);
    if(CopyFile(FullSource,FullTarget,FALSE)) {
        return S_OK;
    }
    dwStatus = GetLastError();
    return HRESULT_FROM_WIN32(dwStatus);
}

UINT
CALLBACK
PreCopyQueueCallback(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
/*++

Routine Description:

    Intent is to copy files from existing media to final media
    Copy all files

Arguments:

    FileName - name of file to scan

Return Value:

    status as hresult

--*/
{
    CALLBACKDATA * pCallbackData = (CALLBACKDATA *)Context;

    switch(Notification) {
        case SPFILENOTIFY_NEEDMEDIA:
            {
                UINT res;
                SOURCE_MEDIA *pMedia = (SOURCE_MEDIA *)Param1;
                SOURCE_MEDIA MediaCopy = *pMedia;
                LPCTSTR Path = NULL;
                //
                // get the media in place - let default callback do this
                // however we can't deal with media location being changed
                // so don't allow it
                //
                MediaCopy.Flags |= SP_COPY_NOSKIP|SP_COPY_NOBROWSE;
                res= SetupDefaultQueueCallback(pCallbackData->pDefContext,
                                                 Notification,
                                                 (UINT_PTR)&MediaCopy,
                                                 Param2);
                if(res==FILEOP_DOIT) {
                    //
                    // typical case
                    // SourcePath unchanged
                    //
                    Path = pMedia->SourcePath;
                } else if(res == FILEOP_NEWPATH) {
                    //
                    // alternative case
                    // we said above we don't want this
                    //
                    SetLastError(ERROR_CANCELLED);
                    return FILEOP_ABORT;
                } else if(res == FILEOP_SKIP) {
                    //
                    // skip
                    // we said above we don't want this
                    //
                    SetLastError(ERROR_CANCELLED);
                    return FILEOP_ABORT;
                } else {
                    //
                    // existing failure case
                    //
                    return res;
                }
                //
                // if the tag exists at source media, copy it
                // if the sourcefile exists at source media, copy it now
                // (it might reference a cab file)
                //
                AttemptStoreCopy(pCallbackData,Path,pMedia->Tagfile,NULL);
                AttemptStoreCopy(pCallbackData,Path,pMedia->SourceFile,NULL);
            }
            return FILEOP_DOIT;

        case SPFILENOTIFY_STARTCOPY:
            {
                UINT res;
                FILEPATHS *pPaths = (FILEPATHS*)Param1;
                if(pCallbackData->PreCopy) {
                    //
                    // we want the target name (PRECOPY case)
                    //
                    AttemptStoreCopy(pCallbackData,NULL,pPaths->Source,pPaths->Target);
                } else {
                    //
                    // we want the source name
                    //
                    AttemptStoreCopy(pCallbackData,NULL,pPaths->Source,NULL);
                }
            }
            return FILEOP_SKIP;

        case SPFILENOTIFY_STARTDELETE:
            return FILEOP_SKIP;

        case SPFILENOTIFY_STARTRENAME:
            return FILEOP_SKIP;


        default:
            return SetupDefaultQueueCallback(pCallbackData->pDefContext,
                                             Notification,
                                             Param1,
                                             Param2);
    }
}

HRESULT
InstallExceptionPackFromInf(
    IN LPCTSTR InfPath,
    IN LPCTSTR Media,
    IN LPCTSTR Store,
    IN DWORD   Flags
    )
/*++

Routine Description:

    Assume INF installed into INF directory
    all decisions made
    media/store known

Arguments:

    InfPath - name of Inf in Media location
    Media   - InfPath less InfName
    Store   - expack store
    Flags   - various flags

Return Value:

    status as hresult

--*/
{
    TCHAR SectionName[LINE_LEN];
    TCHAR PrecopySectionName[LINE_LEN];
    HINF hInf;
    HSPFILEQ hFileQueue = INVALID_HANDLE_VALUE;
    PVOID QueueContext = NULL;
    CALLBACKDATA CallbackData;
    DWORD Status;

    //
    // exception packs must be moved to a component-specific store
    // run through a file-install to see what files we have to copy
    // and use that list to determine source media
    //
    hInf = SetupOpenInfFile(InfPath, NULL, INF_STYLE_WIN4, NULL);
    if(hInf == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        goto final;
    }
    if(!SetupDiGetActualSectionToInstall(hInf,
                                         KEY_DEFAULTINSTALL,
                                         SectionName,
                                         ARRAY_SIZE(SectionName),
                                         NULL,
                                         NULL)) {
        Status = GetLastError();
        goto final;
    }
    SetupOpenAppendInfFile(NULL,hInf,NULL);
    hFileQueue = SetupOpenFileQueue();
    if(hFileQueue == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        goto final;
    }

    if((lstrlen(SectionName)+10)>LINE_LEN) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    lstrcpy(PrecopySectionName,SectionName);
    lstrcat(PrecopySectionName,KEY_DOTPRECOPY);


    QueueContext = SetupInitDefaultQueueCallbackEx(
                       NULL,
                       ((Flags & COMP_FLAGS_NOUI) ? INVALID_HANDLE_VALUE : NULL),
                       0,
                       0,
                       0
                      );

    if(!QueueContext) {
        Status = GetLastError();
        goto final;
    }
    ZeroMemory(&CallbackData,sizeof(CallbackData));
    CallbackData.pDefContext = QueueContext;
    CallbackData.Store = Store;
    CallbackData.Media = Media;


    if(SetupGetLineCount(hInf,PrecopySectionName)>0) {
        //
        // do the pre-copy install via this section instead
        //
        CallbackData.PreCopy = TRUE;
        if(!SetupInstallFilesFromInfSection(hInf,
                                            NULL,
                                            hFileQueue,
                                            PrecopySectionName,
                                            NULL,
                                            0              // SP_COPY_xxxx
                                            )) {
            Status = GetLastError();
            goto final;
        }
    } else {
        CallbackData.PreCopy = FALSE;
        if(!SetupInstallFilesFromInfSection(hInf,
                                            NULL,
                                            hFileQueue,
                                            SectionName,
                                            NULL,
                                            0              // SP_COPY_xxxx
                                            )) {
            Status = GetLastError();
            goto final;
        }
    }


    //
    // Commit file queue, this will get the files to the store
    //
    if(!SetupCommitFileQueue(NULL, hFileQueue, PreCopyQueueCallback, &CallbackData)) {
        Status = GetLastError();
        goto final;
    }
    if(hFileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(hFileQueue);
        hFileQueue = INVALID_HANDLE_VALUE;
    }
    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
        hInf = INVALID_HANDLE_VALUE;
    }
    //
    // now install files from here to final destination
    // this should be relatively quick so don't bother with UI
    //
    if(!(Flags & COMP_FLAGS_NOINSTALL)) {
        return InstallInfSection(InfPath,
                                 SectionName,
                                 COMP_FLAGS_NOUI);
    }
    return S_OK;

    //
    // TODO - move files to component directory
    //
final:
    if(QueueContext) {
        SetupTermDefaultQueueCallback(QueueContext);
    }
    if(hFileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(hFileQueue);
    }
    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
    return HRESULT_FROM_SETUPAPI(Status);
}

DWORD
DownlevelQueryInfOriginalFileInformation(
    IN  HINF                   hInf,
    PSP_INF_INFORMATION        InfInformation,
    PSP_ORIGINAL_FILE_INFO     OriginalFileInfo
    )
/*++

Routine Description:

    Emulates SetupQueryInfOriginalFileInformation
    we need to look in hINF to determine catalog name
    only partial implementation enough to support x86
    (will degrade on other architectures)

Arguments:

    hInf                        - handle to open INF file
    InfInformation              - information obtained about original INF
    pInfOriginalFileInformation - fill with inf/catalog names

Return Value:

    status as DWORD (not HRESULT)

--*/
{
    //
    // in downlevel case, filename is name of file we opened
    // catalog is referenced in the INF
    //
    // get basename of the INF
    // (actually returns full name, but we'll deal with it right)
    //
    INFCONTEXT InfLine;
    SYSTEM_INFO SysInfo;
    TCHAR KeyName[LINE_LEN];

    if(!SetupQueryInfFileInformation(InfInformation,
                                        0,
                                        OriginalFileInfo->OriginalInfName,
                                        ARRAY_SIZE(OriginalFileInfo->OriginalInfName),
                                        NULL)) {
        return GetLastError();
    }
    //
    // now determine name of catalog
    //
    GetSystemInfo(&SysInfo);
    if(SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
        //
        // look for .NTx86
        // only makes sence for x86
        // which is the only architecture we'll migrate Win9x/NT4 to Win2k+
        //
        lstrcpy(KeyName,INFSTR_KEY_CATALOGFILE);
        lstrcat(KeyName,TEXT(".NTx86"));
        if(SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,KeyName,&InfLine)) {
            if(SetupGetStringField(&InfLine,
                                    1,
                                    OriginalFileInfo->OriginalCatalogName,
                                    ARRAY_SIZE(OriginalFileInfo->OriginalCatalogName),
                                    NULL)) {
                return NO_ERROR;
            }
        }
    }
    //
    // look for .NT (even on 9x, as the exception pack will be re-parsed
    // on NT)
    //
    lstrcpy(KeyName,INFSTR_KEY_CATALOGFILE);
    lstrcat(KeyName,TEXT(".NT"));
    if(SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,KeyName,&InfLine)) {
        if(SetupGetStringField(&InfLine,
                                1,
                                OriginalFileInfo->OriginalCatalogName,
                                ARRAY_SIZE(OriginalFileInfo->OriginalCatalogName),
                                NULL)) {
            return NO_ERROR;
        }
    }
    //
    // finally look for undecorated
    //
    if(SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,INFSTR_KEY_CATALOGFILE,&InfLine)) {
        if(SetupGetStringField(&InfLine,
                                1,
                                OriginalFileInfo->OriginalCatalogName,
                                ARRAY_SIZE(OriginalFileInfo->OriginalCatalogName),
                                NULL)) {
            return NO_ERROR;
        }
    }
    //
    // no catalog
    //
    OriginalFileInfo->OriginalCatalogName[0] = TEXT('\0');
    return NO_ERROR;
}

HRESULT
GetInfOriginalFileInformation(
    IN  HINF                   hInf,
    OUT PSP_ORIGINAL_FILE_INFO pInfOriginalFileInformation
    )
/*++

Routine Description:

    Given a handle to an INF, determine names of inf and catalog files

Arguments:

    hInf                        - handle to open INF file
    pInfOriginalFileInformation - inf/catalog names

Return Value:

    status as hresult

--*/
{
    PSP_INF_INFORMATION pInfInformation = NULL;
    DWORD InfInformationSize;
    DWORD Status;

    InfInformationSize = 8192;
    pInfInformation = (PSP_INF_INFORMATION)malloc(InfInformationSize);
    if (pInfInformation == NULL) {
        return E_OUTOFMEMORY;
    }
    if(!SetupGetInfInformation(hInf,INFINFO_INF_SPEC_IS_HINF,pInfInformation,InfInformationSize,&InfInformationSize)) {
        PVOID TempBuf;
        Status = GetLastError();
        if(Status != ERROR_INSUFFICIENT_BUFFER) {
            free(pInfInformation);
            return HRESULT_FROM_SETUPAPI(Status);
        }
        TempBuf = realloc(pInfInformation,InfInformationSize);
        if(!TempBuf) {
            free(pInfInformation);
            return E_OUTOFMEMORY;
        }
    }
    if(!SetupGetInfInformation(hInf,INFINFO_INF_SPEC_IS_HINF,pInfInformation,InfInformationSize,&InfInformationSize)) {
        Status = GetLastError();
        free(pInfInformation);
        return HRESULT_FROM_SETUPAPI(Status);
    }
    pInfOriginalFileInformation->cbSize = sizeof(SP_ORIGINAL_FILE_INFO);
    if((g_VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_VerInfo.dwMajorVersion >= 5)) {
        //
        // Win2k+ - have SetupAPI tell us the information (we're querying oem*.inf)
        //
        if (!QueryInfOriginalFileInformation(pInfInformation,0,NULL,pInfOriginalFileInformation)) {
            Status = GetLastError();
            free(pInfInformation);
            return HRESULT_FROM_SETUPAPI(Status);
        }
    } else {
        //
        // <Win2k - querying source INF, get information from there
        //
        Status = DownlevelQueryInfOriginalFileInformation(hInf,pInfInformation,pInfOriginalFileInformation);
        if(Status != NO_ERROR) {
            free(pInfInformation);
            return HRESULT_FROM_SETUPAPI(Status);
        }
    }
    free(pInfInformation);
    return S_OK;
}

HRESULT
DeleteDirectoryRecursive(
    IN LPCTSTR Path
    )
/*++

Routine Description:

    delete specified directory recursively

Arguments:

    Path - path of the directory to delete

Return Value:

    as HRESULT
    S_FALSE if directory doesn't exist
    S_OK    if directory deleted
    other error if, eg, files in use

--*/
{
    TCHAR Wildcard[MAX_PATH];
    TCHAR Target[MAX_PATH];
    HRESULT hrStatus;
    DWORD Status;
    HRESULT hrFirstError = S_FALSE;
    HANDLE hFind;
    WIN32_FIND_DATA FindData;

    //
    // enumerate the directory
    //
    lstrcpyn(Wildcard,Path,MAX_PATH);
    hrStatus = ConcatPath(Wildcard,MAX_PATH,TEXT("\\*.*"));
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    hFind = FindFirstFile(Wildcard,&FindData);
    if(hFind != INVALID_HANDLE_VALUE) {
        hrFirstError = S_OK;
        do {
            if(lstrcmp(FindData.cFileName,TEXT(".")) == 0) {
                continue;
            }
            if(lstrcmp(FindData.cFileName,TEXT("..")) == 0) {
                continue;
            }
            lstrcpyn(Target,Path,MAX_PATH);
            hrStatus = ConcatPath(Target,MAX_PATH,FindData.cFileName);
            if(SUCCEEDED(hrStatus)) {
                if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    hrStatus = DeleteDirectoryRecursive(Target);
                    if(SUCCEEDED(hrFirstError) && !SUCCEEDED(hrStatus)) {
                        hrFirstError = hrStatus;
                    }
                } else {
                    SetFileAttributes(Target,FILE_ATTRIBUTE_NORMAL);
                    if(!DeleteFile(Target)) {
                        Status = GetLastError();
                        if(SUCCEEDED(hrFirstError)) {
                            hrFirstError = HRESULT_FROM_WIN32(Status);
                        }
                    }
                }
            } else if(SUCCEEDED(hrFirstError)) {
                hrFirstError = hrStatus;
            }
        } while (FindNextFile(hFind,&FindData));
        FindClose(hFind);
    }
    //
    // now delete this directory
    //

    SetFileAttributes(Path,FILE_ATTRIBUTE_NORMAL);
    if(RemoveDirectory(Path) || !SUCCEEDED(hrFirstError)) {
        return hrFirstError;
    }
    Status = GetLastError();
    if((Status == ERROR_PATH_NOT_FOUND) || (Status == ERROR_FILE_NOT_FOUND)) {
        return hrFirstError;
    }
    return HRESULT_FROM_WIN32(Status);
}

HRESULT
RevertStore(
    IN LPCTSTR BackupDir,
    IN LPCTSTR TargetDir
    )
/*++

Routine Description:

    moves contents from backup back to original location
    overwriting files/directories if needed

Arguments:

    BackupDir - directory restoring from
    TargetDir - directory restoring to

Return Value:

    as HRESULT
    S_OK    if backup created
    other error if, eg, files in use

--*/
{
    TCHAR Wildcard[MAX_PATH];
    TCHAR Source[MAX_PATH];
    TCHAR Target[MAX_PATH];
    HRESULT hrStatus;
    HRESULT hrFirstError = S_FALSE;
    DWORD Status;
    DWORD dwRes;
    HANDLE hFind;
    WIN32_FIND_DATA FindData;

    lstrcpyn(Wildcard,BackupDir,MAX_PATH);
    hrStatus = ConcatPath(Wildcard,MAX_PATH,TEXT("\\*.*"));
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    hFind = FindFirstFile(Wildcard,&FindData);
    if(hFind != INVALID_HANDLE_VALUE) {
        hrFirstError = S_OK;
        do {
            if(lstrcmp(FindData.cFileName,TEXT(".")) == 0) {
                continue;
            }
            if(lstrcmp(FindData.cFileName,TEXT("..")) == 0) {
                continue;
            }
            lstrcpyn(Source,BackupDir,MAX_PATH);
            hrStatus = ConcatPath(Source,MAX_PATH,FindData.cFileName);
            if(!SUCCEEDED(hrStatus)) {
                if(SUCCEEDED(hrFirstError)) {
                    hrFirstError = hrStatus;
                }
                continue;
            }
            lstrcpyn(Target,TargetDir,MAX_PATH);
            hrStatus = ConcatPath(Target,MAX_PATH,FindData.cFileName);
            if(!SUCCEEDED(hrStatus)) {
                if(SUCCEEDED(hrFirstError)) {
                    hrFirstError = hrStatus;
                }
                continue;
            }
            //
            // does target exist?
            //
            dwRes = GetFileAttributes(Target);
            if(dwRes != INVALID_FILE_ATTRIBUTES) {
                if(dwRes & FILE_ATTRIBUTE_DIRECTORY) {
                    //
                    // revert store recursively
                    //
                    hrStatus = RevertStore(Source,Target);
                    if(!SUCCEEDED(hrStatus)) {
                        if(SUCCEEDED(hrFirstError)) {
                            hrFirstError = hrStatus;
                        }
                        continue;
                    }
                } else {
                    SetFileAttributes(Target,FILE_ATTRIBUTE_NORMAL);
                    if(!DeleteFile(Target)) {
                        Status = GetLastError();
                    }
                }
            }
            if(!MoveFile(Source,Target)) {
                Status = GetLastError();
                hrStatus = HRESULT_FROM_WIN32(Status);
                if(SUCCEEDED(hrFirstError)) {
                    hrFirstError = hrStatus;
                }
            }
        } while (FindNextFile(hFind,&FindData));
        FindClose(hFind);
    }
    //
    // now attempt to remove the backup directory
    //
    if(RemoveDirectory(BackupDir) || !SUCCEEDED(hrFirstError)) {
        return hrFirstError;
    }
    Status = GetLastError();
    if((Status == ERROR_PATH_NOT_FOUND) || (Status == ERROR_FILE_NOT_FOUND)) {
        return hrFirstError;
    }
    return HRESULT_FROM_WIN32(Status);
}

HRESULT
BackupStore(
    IN LPCTSTR Path,
    OUT LPTSTR BackupDir,
    OUT DWORD BackupDirLen
    )
/*++

Routine Description:

    moves contents to new backup, ideally to \\$BACKUP$
    returns name of backup

Arguments:

    Path         - path of the store
    BackupDir    - filled with directory containing backup
    BackupDirLen - containing length of BackupDir

Return Value:

    as HRESULT
    S_OK    if backup created
    other error if, eg, files in use

--*/
{
    TCHAR Wildcard[MAX_PATH];
    TCHAR Source[MAX_PATH];
    TCHAR Target[MAX_PATH];
    HRESULT hrStatus;
    DWORD Status;
    HANDLE hFind;
    WIN32_FIND_DATA FindData;
    int i;
    int len;

    lstrcpyn(BackupDir,Path,BackupDirLen);
    hrStatus = ConcatPath(BackupDir,BackupDirLen,TEXT("\\$BACKUP$"));
    if(!SUCCEEDED(hrStatus)) {
        //
        // obviously path is too big, no point ignoring
        // as we'd fail elsewhere
        //
        return hrStatus;
    }
    len = lstrlen(BackupDir);
    if((BackupDirLen-len)<5) {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // first, if there's a backup, try and delete it
    //
    hrStatus = DeleteDirectoryRecursive(BackupDir);
    if(SUCCEEDED(hrStatus)) {
        hrStatus = MakeSurePathExists(BackupDir);
    }
    if((hrStatus == HRESULT_FROM_WIN32(ERROR_WRITE_PROTECT)) ||
       (hrStatus == HRESULT_FROM_WIN32(ERROR_INVALID_ACCESS))) {
        //
        // no point even trying again
        //
        return hrStatus;
    }
    for(i = 0;!SUCCEEDED(hrStatus) && i<1000;i++) {
        _sntprintf(BackupDir+len,5,TEXT(".%03u"),i);
        hrStatus = DeleteDirectoryRecursive(BackupDir);
        if(SUCCEEDED(hrStatus)) {
            hrStatus = MakeSurePathExists(BackupDir);
        }
    }
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    //
    // now we have a backup directory, move all the files there
    //
    lstrcpyn(Wildcard,Path,MAX_PATH);
    hrStatus = ConcatPath(Wildcard,MAX_PATH,TEXT("\\*.*"));
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    hrStatus = S_FALSE;
    hFind = FindFirstFile(Wildcard,&FindData);
    if(hFind != INVALID_HANDLE_VALUE) {
        do {
            if(lstrcmp(FindData.cFileName,TEXT(".")) == 0) {
                continue;
            }
            if(lstrcmp(FindData.cFileName,TEXT("..")) == 0) {
                continue;
            }
            if(_tcsnicmp(FindData.cFileName,TEXT("$BACKUP$"),8) == 0) {
                //
                // a/the backup directory
                //
                continue;
            }
            lstrcpyn(Source,Path,MAX_PATH);
            hrStatus = ConcatPath(Source,MAX_PATH,FindData.cFileName);
            if(!SUCCEEDED(hrStatus)) {
                break;
            }
            lstrcpyn(Target,BackupDir,MAX_PATH);
            hrStatus = ConcatPath(Target,MAX_PATH,FindData.cFileName);
            if(!SUCCEEDED(hrStatus)) {
                break;
            }
            if(!MoveFile(Source,Target)) {
                Status = GetLastError();
                hrStatus = HRESULT_FROM_WIN32(Status);
            }
            if(!SUCCEEDED(hrStatus)) {
                break;
            }
            hrStatus = S_OK;
        } while (FindNextFile(hFind,&FindData));
        FindClose(hFind);
    }
    if(!SUCCEEDED(hrStatus)) {
        RevertStore(BackupDir,Path);
    }
    return hrStatus;
}

HRESULT
WINAPI
InstallComponentW(
    IN LPCTSTR InfPath,
    IN DWORD   Flags,
    IN const GUID * CompGuid, OPTIONAL
    IN INT VerMajor,           OPTIONAL
    IN INT VerMinor,           OPTIONAL
    IN INT VerBuild,           OPTIONAL
    IN INT VerQFE,             OPTIONAL
    IN LPCTSTR Name           OPTIONAL
    )
/*++

Routine Description:

    exported for call by setup routine
    install a component with a given version assumed
    show progress while pulling files from original location

Arguments:

    InfPath - path to INF file
    Flags   - flags
                COMP_FLAGS_NOINSTALL      - place in store, don't install
                COMP_FLAGS_NOUI           - don't show any UI
                COMP_FLAGS_NOPROMPTREBOOT - reboot if needed (no prompt)
                COMP_FLAGS_PROMPTREBOOT   - prompt for reboot if needed
                COMP_FLAGS_NEEDSREBOOT    - assume reboot needed

    CompGuid - if NULL, use GUID specified in INF (ComponentId)
               else verify against GUID specified in INF
    VerMajor/VerMinor/VerBuild/VerQFE
             - if -1, use version specified in INF (ComponentVersion)
               else use this version and verify against version if specified in INF
    Name
            - if NULL, use name specified in INF (ComponentName)
              else use this component name.

Return Value:

    status as hresult

--*/
{
    HINF hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT InfLine;
    TCHAR Buffer[MAX_PATH*3];
    TCHAR FriendlyName[DESC_SIZE];
    TCHAR NewStore[MAX_PATH];
    TCHAR OldStore[MAX_PATH];
    TCHAR MediaRoot[MAX_PATH];
    TCHAR GuidString[64];
    LPTSTR BaseName;
    LPTSTR SubDir;
    DWORD Status = NO_ERROR; // set Status or hrStatus
    DWORD DwRes;
    UINT  UiRes;
    HRESULT hrStatus = S_OK;
    GUID InfGuid;
    INT InfVerMajor,InfVerMinor,InfVerBuild,InfVerQFE;
    BOOL PrevReg = FALSE;
    BOOL NeedProxy = FALSE;
    BOOL CanRevert = FALSE;
    BOOL BackedUp = FALSE;
    SETUP_OS_COMPONENT_DATA OsComponentData;
    SETUP_OS_EXCEPTION_DATA OsExceptionData;
    SETUP_OS_COMPONENT_DATA NewOsComponentData;
    SETUP_OS_EXCEPTION_DATA NewOsExceptionData;
    SP_ORIGINAL_FILE_INFO InfOriginalFileInformation;

    //
    // validate args
    //
    if((InfPath == NULL)
       || (VerMajor<-1)
       || (VerMajor>65535)
       || (VerMinor<-1)
       || (VerMinor>65535)
       || (VerBuild<-1)
       || (VerBuild>65535)
       || (VerQFE<-1)
       || (VerQFE>65535)
       || (lstrlen(InfPath)>=MAX_PATH)
       || (Name && (lstrlen(Name)>=ARRAY_SIZE(FriendlyName)))) {
        return E_INVALIDARG;
    }
    //
    // open the INF, we're going to do some information finding
    //
    hInf = SetupOpenInfFile(InfPath,NULL,INF_STYLE_WIN4,NULL);
    if(hInf == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        goto final;
    }
    //
    // get various information about this exception pack
    // We want to know about the exception pack
    // check classguid is correct
    // get componentid
    // get version if exists, and validate against any passed in
    // get description if exists (overwritten by that passed in)
    //

    //
    // CLASSGUID={F5776D81-AE53-4935-8E84-B0B283D8BCEF}
    //
    if(!SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,INFSTR_KEY_CLASSGUID,&InfLine)) {
        Status = GetLastError();
        goto final;
    }
    if(!SetupGetStringField(&InfLine,1,Buffer,MAX_PATH,NULL)) {
        Status = GetLastError();
        goto final;
    }
    if(_tcsicmp(Buffer,TEXT("{F5776D81-AE53-4935-8E84-B0B283D8BCEF}"))!=0) {
        hrStatus = SPAPI_E_CLASS_MISMATCH;
        goto final;
    }
    //
    // determine what component the INF says
    // ComponentId must exist for exception packs
    //
    if(!SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,KEY_COMPONENTID,&InfLine)) {
        Status = GetLastError();
        goto final;
    }
    if(!SetupGetStringField(&InfLine,1,Buffer,MAX_PATH,NULL)) {
        Status = GetLastError();
        goto final;
    }
    hrStatus = GuidFromString(Buffer,&InfGuid);
    if(SUCCEEDED(hrStatus)) {
        hrStatus = S_OK;
    } else {
        goto final;
    }
    if(CompGuid && !IsEqualGUID(CompGuid,&InfGuid)) {
        //
        // mismatched
        //
        hrStatus = E_INVALIDARG;
        goto final;
    }
    //
    // determine version - optional, just for msoobci
    // but if not specified in INF in DriverVer = <date>,<version>
    // must be passed in
    //
    if(SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,INFSTR_DRIVERVERSION_SECTION,&InfLine)) {
        if(!SetupGetStringField(&InfLine,2,Buffer,MAX_PATH,NULL)) {
            Status = GetLastError();
            goto final;
        }
        hrStatus = VersionFromString(Buffer,&InfVerMajor,&InfVerMinor,&InfVerBuild,&InfVerQFE);
        if(hrStatus == S_FALSE) {
            hrStatus = E_INVALIDARG;
            goto final;
        }
        if(SUCCEEDED(hrStatus)) {
            hrStatus = S_OK;
        } else {
            goto final;
        }
        if(VerMajor>=0) {
            if(VerMajor != InfVerMajor) {
                hrStatus = E_INVALIDARG;
                goto final;
            }
            if(VerMinor>=0) {
                if(VerMinor != InfVerMinor) {
                    hrStatus = E_INVALIDARG;
                    goto final;
                }
                if(VerBuild>=0) {
                    if(VerBuild != InfVerBuild) {
                        hrStatus = E_INVALIDARG;
                        goto final;
                    }
                    if(VerQFE>=0) {
                        if(VerQFE != InfVerQFE) {
                            hrStatus = E_INVALIDARG;
                            goto final;
                        }
                    }
                } else if(VerQFE != -1) {
                    //
                    // VerQFE must be -1
                    //
                    hrStatus = E_INVALIDARG;
                    goto final;
                }
            } else if((VerBuild != -1) || (VerQFE != -1)) {
                //
                // VerBuild & VerQFE must be -1
                //
                hrStatus = E_INVALIDARG;
                goto final;
            }
        } else if((VerMinor != -1) || (VerBuild != -1) || (VerQFE != -1)) {
            //
            // VerMinor, VerBuild & VerQFE must be -1
            //
            hrStatus = E_INVALIDARG;
            goto final;
        }
    } else {
        //
        // must be specified
        //
        if((VerMajor<0) || (VerMinor<0) || (VerBuild<0) || (VerQFE<0)) {
            hrStatus = E_INVALIDARG;
            goto final;
        }
        InfVerMajor = VerMajor;
        InfVerMinor = VerMinor;
        InfVerBuild = VerBuild;
        InfVerQFE = VerQFE;
    }
    //
    // determine friendly name
    // use Class= entry in INF (must always be specified)
    // if Name not defined, use class name instead
    //
    if(!SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,INFSTR_KEY_CLASS,&InfLine)) {
        Status = GetLastError();
        goto final;
    }
    if(!Name) {
        if(!SetupGetStringField(&InfLine,1,FriendlyName,ARRAY_SIZE(FriendlyName),NULL)) {
            Status = GetLastError();
            goto final;
        }
        Name = FriendlyName;
    }

    //
    // we might not need to update this package after all
    //
    ZeroMemory(&OsComponentData,sizeof(OsComponentData));
    OsComponentData.SizeOfStruct = sizeof(OsComponentData);
    ZeroMemory(&OsExceptionData,sizeof(OsExceptionData));
    OsExceptionData.SizeOfStruct = sizeof(OsExceptionData);
    if(QueryRegisteredOsComponent(&InfGuid,&OsComponentData,&OsExceptionData)) {
        //
        // already registered? see if we supercede
        //
        if(((Flags & COMP_FLAGS_FORCE)==0) && (CompareCompVersion(InfVerMajor,InfVerMinor,InfVerBuild,InfVerQFE,&OsComponentData)<=0)) {
            VerbosePrint(TEXT("Not installing %s, %u.%u.%u.%u <= %u.%u.%u.%u"),
                                InfPath,
                                InfVerMajor,InfVerMinor,InfVerBuild,InfVerQFE,
                                OsComponentData.VersionMajor,
                                OsComponentData.VersionMinor,
                                OsComponentData.BuildNumber,
                                OsComponentData.QFENumber);
            hrStatus = S_FALSE;
            goto final;
        }
        PrevReg = TRUE;
    }

    //
    // determine MediaRoot and INF basename
    //
    DwRes= GetFullPathName(InfPath,MAX_PATH,MediaRoot,&BaseName);
    if(DwRes == 0) {
        Status = GetLastError();
        goto final;
    } else if(DwRes >= MAX_PATH) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    if((BaseName == NULL) || (BaseName == InfPath) || !BaseName[0]) {
        hrStatus = E_INVALIDARG;
        goto final;
    }
    if(BaseName[-1] != TEXT('\\')) {
        hrStatus = E_INVALIDARG;
        goto final;
    }
    //
    // split off MediaRoot and BaseName
    //
    BaseName[-1] = TEXT('\0');
    //
    // get Windows directory
    //
    UiRes = GetRealWindowsDirectory(Buffer,MAX_PATH);
    if(UiRes == 0) {
        Status = GetLastError();
        goto final;
    } else if(UiRes >= MAX_PATH) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    if(!SUCCEEDED(ConcatPath(Buffer,MAX_PATH,TEXT("\\")))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    SubDir = Buffer+lstrlen(Buffer);
    //
    // c:\windows\
    // ^-buffer   ^-subdir
    // we'll do a number of operations using the subdir part of this buffer
    //
    // if PrevReg is TRUE, we most likely have access to previous package
    // so that we can install prev package to revert back to it
    // we expect this package to be in the windows directory as per spec
    // if it's not, then the old package might not still be around
    //
    if(PrevReg && _tcsncmp(OsExceptionData.ExceptionInfName,Buffer,SubDir-Buffer)==0) {
        //
        // it's a sub-directory of %windir%
        // now check for presence of INF and CAT files
        //
        DwRes = GetFileAttributes(OsExceptionData.ExceptionInfName);
        if(DwRes != INVALID_FILE_ATTRIBUTES) {
            DwRes = GetFileAttributes(OsExceptionData.CatalogFileName);
            if(DwRes != INVALID_FILE_ATTRIBUTES) {
                //
                // both present, looks good
                //
                CanRevert = TRUE;
            }
        }
    }

    //
    // determine final path/name of INF and catalog
    // We must place it directly in %windir%\<comp>
    // (WFP relies on this!!!!)
    // we'll backup what's there so that we can restore it later if needed
    //
    hrStatus = StringFromGuid(&InfGuid,GuidString,ARRAY_SIZE(GuidString));
    if(!SUCCEEDED(hrStatus)) {
        goto final;
    }
    hrStatus = S_OK;
    _sntprintf(SubDir,MAX_PATH,TEXT("%s\\%s"),
                                TEXT("RegisteredPackages"),
                                GuidString
                                );
    if((lstrlen(Buffer)+16)>MAX_PATH) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    lstrcpy(NewStore,Buffer);

    if(CanRevert) {
        hrStatus = BackupStore(NewStore,OldStore,ARRAY_SIZE(OldStore));
        if(!SUCCEEDED(hrStatus)) {
            //
            // if we failed backup, that means there's something bad
            // such as files in the store in use
            // probability is that we'll fail later
            // so fail gracefully now instead of badly later
            //
            goto final;
        }
        hrStatus = S_OK;
    }

    //
    // see if %windir%\INF\<BaseName> is there?
    //
    lstrcpy(SubDir,TEXT("INF\\"));
    if(!SUCCEEDED(ConcatPath(Buffer,MAX_PATH,BaseName))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    DwRes = GetFileAttributes(Buffer);
    if(DwRes != INVALID_FILE_ATTRIBUTES) {
        //
        // replacing an existing INF
        // to work around a cache bug, we'll kick the actuall install
        // off in another process
        //
        NeedProxy = TRUE;
    }

    hrStatus = MakeSurePathExists(NewStore);
    if(!SUCCEEDED(hrStatus)) {
        goto final;
    }

    //
    // install INF into %windir%\INF directory noting location the files
    // should be
    //
    if((g_VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_VerInfo.dwMajorVersion >= 5)) {
        //
        // only do this on Win2k+
        // this will have SetupAPI tell us the original name and the catalog
        // name
        //
        if(CopyOEMInf(InfPath,NewStore,SPOST_PATH,0,NULL,0,NULL,NULL)) {
            //
            // Switch to the INF that's in %windir%\INF directory
            //
            SetupCloseInfFile(hInf);
            hInf = SetupOpenInfFile(Buffer,NULL,INF_STYLE_WIN4,NULL);
            if(hInf == INVALID_HANDLE_VALUE) {
                Status = GetLastError();
                goto final;
            }
        } else {
            Status = GetLastError();
            goto final;
        }
    }
    //
    // now find out what the catalog name would be
    //
    hrStatus = GetInfOriginalFileInformation(hInf,&InfOriginalFileInformation);
    if(!SUCCEEDED(hrStatus)) {
        goto final;
    }
    if((InfOriginalFileInformation.OriginalInfName[0]==TEXT('\0'))
       ||(InfOriginalFileInformation.OriginalCatalogName[0]==TEXT('\0'))) {
        //
        // shouldn't happen
        //
        hrStatus = E_FAIL;
        goto final;
    }

    ZeroMemory(&NewOsExceptionData,sizeof(NewOsExceptionData));
    NewOsExceptionData.SizeOfStruct = sizeof(NewOsExceptionData);
    //
    // INF name
    //
    BaseName = GetBaseName(InfOriginalFileInformation.OriginalInfName);
    lstrcpyn(NewOsExceptionData.ExceptionInfName,NewStore,ARRAY_SIZE(NewOsExceptionData.ExceptionInfName));
    if(!SUCCEEDED(ConcatPath(NewOsExceptionData.ExceptionInfName,ARRAY_SIZE(NewOsExceptionData.ExceptionInfName),BaseName))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    lstrcpy(Buffer,MediaRoot);
    if(!SUCCEEDED(ConcatPath(Buffer,MAX_PATH,BaseName))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    if(!CopyFile(Buffer,NewOsExceptionData.ExceptionInfName,FALSE)) {
        Status = GetLastError();
        goto final;
    }
    //
    // CAT name
    //
    BaseName = GetBaseName(InfOriginalFileInformation.OriginalCatalogName);
    lstrcpyn(NewOsExceptionData.CatalogFileName,NewStore,ARRAY_SIZE(NewOsExceptionData.CatalogFileName));
    if(!SUCCEEDED(ConcatPath(NewOsExceptionData.CatalogFileName,ARRAY_SIZE(NewOsExceptionData.CatalogFileName),BaseName))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    lstrcpy(Buffer,MediaRoot);
    if(!SUCCEEDED(ConcatPath(Buffer,MAX_PATH,BaseName))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    if(!CopyFile(Buffer,NewOsExceptionData.CatalogFileName,FALSE)) {
        Status = GetLastError();
        goto final;
    }

    //
    // WFP may query exception pack as a source to restore files that are replaced
    // change registration so if WFP does get in loop, it goes to the right place
    //
    if(PrevReg) {
        UnRegisterOsComponent(&InfGuid);
    }
    ZeroMemory(&NewOsComponentData,sizeof(NewOsComponentData));
    NewOsComponentData.SizeOfStruct = sizeof(NewOsComponentData);
    NewOsComponentData.ComponentGuid = InfGuid;
    lstrcpyn(NewOsComponentData.FriendlyName,Name,ARRAY_SIZE(NewOsComponentData.FriendlyName));
    NewOsComponentData.VersionMajor = (WORD)InfVerMajor;
    NewOsComponentData.VersionMinor = (WORD)InfVerMinor;
    NewOsComponentData.BuildNumber  = (WORD)InfVerBuild;
    NewOsComponentData.QFENumber    = (WORD)InfVerQFE;
    if(!RegisterOsComponent(&NewOsComponentData,&NewOsExceptionData)) {
        Status = GetLastError();
        goto final;
    }
    if(((Flags & COMP_FLAGS_NOUI)==0) && !IsInteractiveWindowStation()) {
        Flags |= COMP_FLAGS_NOUI;
    }

    if(NeedProxy) {
        //
        // A bug in Win2k/XP means that we have problems if replacing an existing
        // exception-pack component
        //
        hrStatus = ProxyInstallExceptionPackFromInf(InfPath,MediaRoot,NewStore,Flags);
    } else {
        hrStatus = InstallExceptionPackFromInf(InfPath,MediaRoot,NewStore,Flags);
    }
    if(!SUCCEEDED(hrStatus)) {
        //
        // not sure best thing to do here, but
        // the component that we had above is definately invalid
        //
        UnRegisterOsComponent(&InfGuid);
        if(PrevReg) {
            RegisterOsComponent(&OsComponentData,&OsExceptionData);
        }
        if(BackedUp) {
            //
            // we got part through and failed. Re-install the old component
            // to revert whatever we did
            //
            RevertStore(OldStore,NewStore);
            BackedUp = FALSE;
            InstallInfSection(OsExceptionData.ExceptionInfName,NULL,COMP_FLAGS_NOUI);
        }
        goto final;
    } else {
        //
        // don't need backup any more
        //
        if(BackedUp) {
            DeleteDirectoryRecursive(OldStore);
            BackedUp = FALSE;
        }
    }
    //
    // succeeded
    //
    Status = NO_ERROR;
    if(hrStatus == INST_S_REBOOT) {
        hrStatus = HandleReboot(Flags);
    } else {
        hrStatus = S_OK;
    }


  final:
    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
    if((hrStatus == S_OK) && Status != NO_ERROR) {
        hrStatus = HRESULT_FROM_SETUPAPI(Status);
    }
    if(BackedUp) {
        //
        // we need to revert the backup
        //
        RevertStore(OldStore,NewStore);
    }
    return hrStatus;
}

HRESULT
WINAPI
InstallComponentA(
    IN LPCSTR InfPath,
    IN DWORD   Flags,
    IN const GUID * CompGuid, OPTIONAL
    IN INT VerMajor,           OPTIONAL
    IN INT VerMinor,           OPTIONAL
    IN INT VerBuild,           OPTIONAL
    IN INT VerQFE,             OPTIONAL
    IN LPCSTR Name            OPTIONAL
    )
{
    TCHAR OutPath[MAX_PATH];
    TCHAR OutDesc[DESC_SIZE]; // as per friendly name
    INT sz;
    if(InfPath) {
        sz = MultiByteToWideChar(CP_ACP,0,InfPath,-1,OutPath,ARRAY_SIZE(OutPath));
        if(!sz) {
            return E_INVALIDARG;
        }
    }
    if(Name) {
        sz = MultiByteToWideChar(CP_ACP,0,Name,-1,OutDesc,ARRAY_SIZE(OutDesc));
        if(!sz) {
            return E_INVALIDARG;
        }
    }
    return InstallComponent(InfPath ? OutPath : NULL,
                            Flags,
                            CompGuid,
                            VerMajor,
                            VerMinor,
                            VerBuild,
                            VerQFE,
                            Name ? OutDesc : NULL);
}

VOID
WINAPI
DoInstallW(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCTSTR    CommandLine,
    IN INT       ShowCommand
    )
/*++

Routine Description:

    exported for call by rundll32

Arguments:

    Window       - parent window (not used)
    ModuleHandle - not used
    CommandLine  - see below
    ShowCommand  - not used

    CommandLine -
        "InfPath;Flags;GUID;High.Low.Build.QFE;Name" (; - CMD_SEP)

Return Value:

    none

--*/
{
    TCHAR InfPath[MAX_PATH];
    TCHAR Desc[DESC_SIZE];
    TCHAR Hold[64];
    INT VerMajor = -1;
    INT VerMinor = -1;
    INT VerBuild = -1;
    INT VerQFE = -1;
    GUID Guid;
    DWORD Flags = 0;
    LPGUID pGuid = NULL;
    LPTSTR pDesc = NULL;
    LPCTSTR pCmd = CommandLine;
    LPCTSTR pEnd;
    HRESULT hResult = S_OK;

    //
    // break CommandLine up into relevent parts
    // First InfPath
    //
    pEnd = _tcschr(pCmd,CMD_SEP);
    if(!pEnd) {
        pEnd = pCmd+lstrlen(pCmd);
    }
    if((pEnd == pCmd) || ((pEnd-pCmd)>=MAX_PATH)) {
        hResult = E_INVALIDARG;
        goto final;
    }
    CopyMemory(InfPath,pCmd,(pEnd-pCmd)*sizeof(TCHAR));
    InfPath[pEnd-pCmd] = TEXT('\0');
    if(*pEnd == CMD_SEP) {
        pCmd = pEnd+1;
        if((*pCmd == CMD_SEP) || (*pCmd == TEXT('\0'))) {
            //
            // skip
            //
            pEnd = pCmd;
        } else {
            //
            // Flags
            //
            Flags = (DWORD)_tcstoul(pCmd,&(LPTSTR)pEnd,0);
            if((*pEnd != CMD_SEP) && (*pEnd != TEXT('\0'))) {
                hResult = E_INVALIDARG;
                goto final;
            }
        }
    }
    if(*pEnd == CMD_SEP) {
        pCmd = pEnd+1;
        if((*pCmd == CMD_SEP) || (*pCmd == TEXT('\0'))) {
            //
            // skip
            //
            pEnd = pCmd;
        } else {
            //
            // Guid
            //
            pEnd = _tcschr(pCmd,CMD_SEP);
            if(!pEnd) {
                pEnd = pCmd+lstrlen(pCmd);
            }
            if((pEnd-pCmd)>=ARRAY_SIZE(Hold)) {
                hResult = E_INVALIDARG;
                goto final;
            }
            CopyMemory(Hold,pCmd,(pEnd-pCmd)*sizeof(TCHAR));
            Hold[pEnd-pCmd] = TEXT('\0');
            hResult = GuidFromString(Hold,&Guid);
            if(!SUCCEEDED(hResult)) {
                goto final;
            }
            pGuid = &Guid;
        }
    }
    if(*pEnd == CMD_SEP) {
        pCmd = pEnd+1;
        if((*pCmd == CMD_SEP) || (*pCmd == TEXT('\0'))) {
            //
            // skip
            //
            pEnd = pCmd;
        } else {
            //
            // Version
            //
            pEnd = _tcschr(pCmd,CMD_SEP);
            if(!pEnd) {
                pEnd = pCmd+lstrlen(pCmd);
            }
            if((pEnd-pCmd)>=ARRAY_SIZE(Hold)) {
                hResult = E_INVALIDARG;
                goto final;
            }
            CopyMemory(Hold,pCmd,(pEnd-pCmd)*sizeof(TCHAR));
            Hold[pEnd-pCmd] = TEXT('\0');
            hResult = VersionFromString(Hold,&VerMajor,&VerMinor,&VerBuild,&VerQFE);
            if(!SUCCEEDED(hResult)) {
                goto final;
            }
            if(hResult == S_FALSE) {
                VerMajor = VerMinor = VerBuild = VerQFE = -1;
            }
        }
    }
    if(*pEnd == CMD_SEP) {
        pCmd = pEnd+1;
        pEnd = pCmd+lstrlen(pCmd);
        if(pEnd != pCmd) {
            if((pEnd-pCmd) >= ARRAY_SIZE(Desc)) {
                hResult = E_INVALIDARG;
                goto final;
            }
            CopyMemory(Desc,pCmd,(pEnd-pCmd)*sizeof(TCHAR));
            Desc[pEnd-pCmd] = TEXT('\0');
            pDesc = Desc;
        }
    }
    hResult = InstallComponent(InfPath,Flags,pGuid,VerMajor,VerMinor,VerBuild,VerQFE,pDesc);

  final:
    if(SUCCEEDED(hResult)) {
        //
        // deal with specific success scenarios
        //
    } else {
        //
        // an error occurred
        //
        DebugPrint(TEXT("DoInstall failed with error: 0x%08x"),hResult);
    }
}


VOID
WINAPI
DoInstallA(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR     CommandLine,
    IN INT       ShowCommand
    )
{
    TCHAR OutLine[MAX_PATH*2];
    INT sz;
    sz = MultiByteToWideChar(CP_ACP,0,CommandLine,-1,OutLine,ARRAY_SIZE(OutLine));
    if(!sz) {
        DebugPrint(TEXT("DoInstallA was passed too big a command line"));
        return;
    }
    DoInstall(Window,ModuleHandle,OutLine,ShowCommand);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\devcon2\xstrings.h ===
// Strings.h : Declaration of the CStrings

#ifndef __STRINGS_H_
#define __STRINGS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CStrings
class ATL_NO_VTABLE CStrings : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CStrings, &CLSID_Strings>,
	public IDispatchImpl<IStrings, &IID_IStrings, &LIBID_DEVCON2Lib>
{
protected:
	BSTR  *pMultiStrings;
	ULONG  ArraySize;
	ULONG  Count;
	VARIANT_BOOL   IsCaseSensative;

public:
	CStrings()
	{
		pMultiStrings = NULL;
		ArraySize = 0;
		Count = 0;
		IsCaseSensative = VARIANT_FALSE;
	}

	virtual ~CStrings();

DECLARE_REGISTRY_RESOURCEID(IDR_STRINGS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStrings)
	COM_INTERFACE_ENTRY(IStrings)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IStrings
public:
	STDMETHOD(get_CaseSensative)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_CaseSensative)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(Find)(/*[in]*/ BSTR name,/*[out,retval]*/ long *pFound);
	STDMETHOD(Remove)(/*[in]*/ VARIANT Index);
	STDMETHOD(Insert)(/*[in]*/ VARIANT Index,/*[in]*/ VARIANT Value);
	STDMETHOD(Add)(/*[in]*/ VARIANT Value);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** ppUnk);
	STDMETHOD(Item)(/*[in]*/ VARIANT Index,/*[out, retval]*/ VARIANT * pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

	//
	// helpers
	//
	BOOL InternalEnum(DWORD index,BSTR *pNext);
	HRESULT GetIndex(VARIANT *pIndex,DWORD *pAt);
	HRESULT FromMultiSz(LPCWSTR pMultiSz);
	HRESULT GetMultiSz(LPWSTR *pResult,DWORD *pSize);
	HRESULT InternalInsertString(DWORD Index,BSTR pString);
	HRESULT InternalInsertCollection(DWORD Index,IEnumVARIANT * pEnum);
	HRESULT InternalInsertArray(DWORD Index, VARTYPE vt,SAFEARRAY * pArray);
	HRESULT InternalInsertArrayDim(CComObject<CStrings> *pStringTemp, VARTYPE vt, SAFEARRAY *pArray,long *pDims,UINT dim,UINT dims);
	HRESULT InternalInsert(DWORD Index,LPVARIANT Value);
	HRESULT InternalAdd(LPCWSTR Value,UINT len);
	BOOL IncreaseArraySize(DWORD strings);
};

#endif //__STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\dock\dock.h ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    DOCK.H

Abstract:

    This module contains the common private declarations for the undock tester


Author:

    Kenneth Ray

Environment:

    User Mode Only

Notes:


Revision History:

    Created June 98

--*/

#ifndef DOCK_H
#define DOCK_H


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))


//
// Prototypes
//




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\expackdll\msoobci.c ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    msoobci.c

Abstract:

    Exception Pack installer helper DLL
    Can be used as a co-installer, or called via setup app, or RunDll32 stub

    This DLL is for internal distribution of exception packs to update
    OS components.

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#include "msoobcip.h"

//
// globals
//
HANDLE          g_DllHandle;
OSVERSIONINFOEX g_VerInfo;


VOID
DebugPrint(
    IN PCTSTR format,
    IN ...                         OPTIONAL
    )
/*++

Routine Description:

    Send a formatted string to the debugger.

Arguments:

    format - standard printf format string.

Return Value:

    NONE.

--*/
{
    TCHAR buf[1200];    // wvsprintf maxes at 1024.
    va_list arglist;

    va_start(arglist, format);
    lstrcpy(buf,TEXT("MSOOBCI: "));
    wvsprintf(buf+lstrlen(buf), format, arglist);
    lstrcat(buf,TEXT("\n"));
    OutputDebugString(buf);
}

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            //
            // global initialization
            // - make a note of DllHandle
            // - make a note of OS version
            //
            g_DllHandle = DllHandle;
            ZeroMemory(&g_VerInfo,sizeof(g_VerInfo));
            g_VerInfo.dwOSVersionInfoSize = sizeof(g_VerInfo);
            if(!GetVersionEx((LPOSVERSIONINFO)&g_VerInfo)) {
                g_VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
                if(!GetVersionEx((LPOSVERSIONINFO)&g_VerInfo)) {
                    return FALSE;
                }
            }
            break;
    }

    return TRUE;
}

HRESULT
GuidFromString(
    IN  LPCTSTR GuidString,
    OUT GUID   *GuidBinary
    )
/*++

Routine Description:

    Convert a GUID from String form to Binary form

Arguments:

    GuidString - string form
    GuidBinary - filled with binary form

Return Value:

    S_OK or E_INVALIDARG

--*/
{
    HRESULT res;
    TCHAR String[64];
    lstrcpyn(String,GuidString,ARRAY_SIZE(String));
    res = IIDFromString(String,GuidBinary);
    return res;
}

HRESULT
StringFromGuid(
    IN  GUID   *GuidBinary,
    OUT LPTSTR GuidString,
    IN  DWORD  BufferSize
    )
/*++

Routine Description:

    Convert a GUID from Binary form to String form

Arguments:

    GuidBinary - binary form
    GuidString - filled with string form
    BufferSize - length of GuidString buffer

Return Value:

    S_OK or E_INVALIDARG

--*/
{
    int res;
    res = StringFromGUID2(GuidBinary,GuidString,(int)BufferSize);
    if(res == 0) {
        return E_INVALIDARG;
    }
    return S_OK;
}


HRESULT
VersionFromString(
    IN  LPCTSTR VerString,
    OUT INT * VerMajor,
    OUT INT * VerMinor,
    OUT INT * VerBuild,
    OUT INT * VerQFE
    )
/*++

Routine Description:

    Convert a high.low string to VerHigh and VerLow

Arguments:

    VerString - string form
    VerMajor/VerMinor/VerBuild/VerQFE - components of version

Return Value:

    S_OK or E_INVALIDARG

--*/
{
    HRESULT res;
    LPTSTR VerPtr;
    long val;

    *VerMajor = *VerMinor = *VerBuild = *VerQFE = 0;
    //
    // skip leading white space
    //
    while((VerString[0] == TEXT(' ')) ||
          (VerString[0] == TEXT('\t'))) {
        VerString++;
    }
    if(VerString[0] == TEXT('\0')) {
        //
        // wildcard
        //
        return S_FALSE;
    }
    //
    // get version major part (decimal)
    //
    if(!((VerString[0]>= TEXT('0')) &&
         (VerString[0]<= TEXT('9')))) {
        return E_INVALIDARG;
    }
    val = _tcstol(VerString,&VerPtr,10);
    if((VerPtr == VerString) ||
       ((VerPtr-VerString)>5) ||
       (val>65535) ||
       (val<0)) {
        return E_INVALIDARG;
    }
    *VerMajor = (WORD)val;

    //
    // followed by .decimal
    // (version minor part)
    //
    if((VerPtr[0] != TEXT('.')) ||
       !((VerPtr[1]>= TEXT('0')) &&
         (VerPtr[1]<= TEXT('9')))) {
        return E_INVALIDARG;
    }
    VerString = VerPtr+1;
    val = _tcstol(VerString,&VerPtr,10);
    if((VerPtr == VerString) ||
       ((VerPtr-VerString)>5) ||
       (val>65535) ||
       (val<0)) {
        return E_INVALIDARG;
    }
    *VerMinor = (WORD)val;

    //
    // followed by .decimal
    // (version build, optional)
    //
    if(VerPtr[0] == TEXT('.')) {
        if(!((VerPtr[1]>= TEXT('0')) &&
             (VerPtr[1]<= TEXT('9')))) {
            return E_INVALIDARG;
        }
        VerString = VerPtr+1;
        val = _tcstol(VerString,&VerPtr,10);
        if((VerPtr == VerString) ||
           ((VerPtr-VerString)>5) ||
           (val>65535) ||
           (val<0)) {
            return E_INVALIDARG;
        }
        *VerBuild = (WORD)val;
    }

    //
    // followed by .decimal
    // (version qfe, optional)
    //
    if(VerPtr[0] == TEXT('.')) {
        if(!((VerPtr[1]>= TEXT('0')) &&
             (VerPtr[1]<= TEXT('9')))) {
            return E_INVALIDARG;
        }
        VerString = VerPtr+1;
        val = _tcstol(VerString,&VerPtr,10);
        if((VerPtr == VerString) ||
           ((VerPtr-VerString)>5) ||
           (val>65535) ||
           (val<0)) {
            return E_INVALIDARG;
        }
        *VerQFE = (WORD)val;

    }

    //
    // trailing white space
    //
    VerString = VerPtr;
    while((VerString[0] == TEXT(' ')) ||
          (VerString[0] == TEXT('\t'))) {
        VerString++;
    }
    //
    // not well formed?
    //
    if(VerString[0] != TEXT('\0')) {
        return E_INVALIDARG;
    }
    return S_OK;
}

int
CompareCompVersion(
    IN INT VerMajor,
    IN INT VerMinor,
    IN INT VerBuild,
    IN INT VerQFE,
    IN PSETUP_OS_COMPONENT_DATA SetupOsComponentData
    )
/*++

Routine Description:

    Compare a version against component information

Arguments:

    VerMajor/VerMinor/VerBuild/VerQFE - version to check against
        (can have wildcards)

    SetupOsComponentData - component version

Return Value:

    -1, version not as good as component
    0, version equiv to component
    1, version better than component
--*/
{
    return CompareVersion(VerMajor,
                            VerMinor,
                            VerBuild,
                            VerQFE,
                            SetupOsComponentData->VersionMajor,
                            SetupOsComponentData->VersionMinor,
                            SetupOsComponentData->BuildNumber,
                            SetupOsComponentData->QFENumber
                            );
}

int
CompareVersion(
    IN INT VerMajor,
    IN INT VerMinor,
    IN INT VerBuild,
    IN INT VerQFE,
    IN INT OtherMajor,
    IN INT OtherMinor,
    IN INT OtherBuild,
    IN INT OtherQFE
    )
/*++

Routine Description:

    Compare a version against component information

Arguments:

    VerMajor/VerMinor/VerBuild/VerQFE - version to check
        (can have wildcards)

    OtherMajor/OtherMinor/OtherBuid/OtherQFE - version to check against

Return Value:

    -1, version not as good as component
    0, version equiv to component
    1, version better than component
--*/
{
    if((VerMajor==-1)||(OtherMajor==-1)) {
        return 0;
    }
    if(VerMajor<OtherMajor) {
        return -1;
    }
    if(VerMajor>OtherMajor) {
        return 1;
    }
    if((VerMinor==-1)||(OtherMinor==-1)) {
        return 0;
    }
    if(VerMinor<OtherMinor) {
        return -1;
    }
    if(VerMinor>OtherMinor) {
        return 1;
    }
    if((VerBuild==-1)||(OtherBuild==-1)) {
        return 0;
    }
    if(VerBuild<OtherBuild) {
        return -1;
    }
    if(VerBuild>OtherBuild) {
        return 1;
    }
    if((VerQFE==-1)||(OtherQFE==-1)) {
        return 0;
    }
    if(VerQFE<OtherQFE) {
        return -1;
    }
    if(VerQFE>OtherQFE) {
        return 1;
    }
    return 0;
}

HRESULT
MakeSurePathExists(
    IN LPTSTR Path
    )
/*++

Routine Description:

    Make sure named directory exists

Arguments:

    Path - path to directory to create, must be a writable buffer

Return Value:

    status as hresult
    S_OK    - path created
    S_FALSE - path already exists

--*/
{
    DWORD dwResult;
    DWORD Status;
    HRESULT hrStatus;

    dwResult = GetFileAttributes(Path);
    if((dwResult != (DWORD)(-1)) && ((dwResult & FILE_ATTRIBUTE_DIRECTORY)!=0)) {
        //
        // directory exists
        //
        return S_FALSE;
    }
    hrStatus = MakeSureParentPathExists(Path);
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    if(!CreateDirectory(Path,NULL)) {
        Status = GetLastError();
        return HRESULT_FROM_WIN32(Status);
    }
    return S_OK;
}

HRESULT
MakeSureParentPathExists(
    IN LPTSTR Path
    )
/*++

Routine Description:

    Make sure parent of named directory/file exists

Arguments:

    Path - path to directory to create, must be a writable buffer

Return Value:

    status as hresult
    S_OK    - path created
    S_FALSE - path already exists

--*/
{
    HRESULT hrStatus;
    LPTSTR Split;
    LPTSTR Base;
    TCHAR Save;

    //
    // make sure we don't try to create the root
    //
    if((_istalpha(Path[0]) && (Path[1]==TEXT(':')))
       && ((Path[2] == TEXT('\\'))  || (Path[2] == TEXT('/')))
       && (Path[3] != TEXT('\0'))) {
        Base = Path+3;
    } else {
        //
        // at this time, this code expects X:\... format
        //
        return E_FAIL;
    }
    Split = GetSplit(Base);
    if(Split == Base) {
        //
        // strange, should have succeeded
        //
        return E_FAIL;
    }
    Save = *Split;
    *Split = TEXT('\0');
    hrStatus = MakeSurePathExists(Path);
    *Split = Save;
    return hrStatus;
}

LPTSTR GetBaseName(
    IN LPCTSTR FileName
    )
/*++

Routine Description:

    Given a full path, return basename portion

Arguments:

    FileName - full or partial path

Return Value:

    status as hresult

--*/
{
    LPTSTR BaseName = (LPTSTR)FileName;

    for(; *FileName; FileName = CharNext(FileName)) {
        switch (*FileName) {
            case TEXT(':'):
            case TEXT('/'):
            case TEXT('\\'):
                BaseName = (LPTSTR)CharNext(FileName);
                break;
        }
    }
    return BaseName;
}

LPTSTR GetSplit(
    IN LPCTSTR FileName
    )
/*++

Routine Description:

    Split path at last '/' or '\\' (similar to GetBaseName)

Arguments:

    FileName - full or partial path

Return Value:

    status as hresult

--*/
{
    LPTSTR SplitPos = (LPTSTR)FileName;

    for(SplitPos; *FileName; FileName = CharNext(FileName)) {
        switch (*FileName) {
            case TEXT('/'):
            case TEXT('\\'):
                SplitPos = (LPTSTR)FileName;
                break;
        }
    }
    return SplitPos;
}

BOOL
WINAPI
IsInteractiveWindowStation(
    )
/*++

Routine Description:

    Determine if we are running on an interactive station vs non-interactive
    // station (i.e., service)

Arguments:

    none

Return Value:

    True if interactive

--*/
{
    HWINSTA winsta;
    USEROBJECTFLAGS flags;
    BOOL interactive = TRUE; // true unless we determine otherwise
    DWORD lenNeeded;

    winsta = GetProcessWindowStation();
    if(!winsta) {
        return interactive;
    }
    if(GetUserObjectInformation(winsta,UOI_FLAGS,&flags,sizeof(flags),&lenNeeded)) {
        interactive = (flags.dwFlags & WSF_VISIBLE) ? TRUE : FALSE;
    }
    //
    // don't call CLoseWindowStation
    //
    return interactive;
}

BOOL
WINAPI
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process has admin privs

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

    Though we could use CheckTokenMembership
    this function has to work on NT4

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrator privs.

    FALSE - Caller does not have Administrator privs.

--*/

{
    BOOL fAdmin = FALSE;
    HANDLE  hToken = NULL;
    DWORD dwStatus;
    DWORD dwACLSize;
    DWORD cbps = sizeof(PRIVILEGE_SET);
    PACL pACL = NULL;
    PSID psidAdmin = NULL;
    PSECURITY_DESCRIPTOR psdAdmin = NULL;
    PRIVILEGE_SET ps;
    GENERIC_MAPPING gm;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    BOOL Impersonated = FALSE;

    //
    // Prepare some memory
    //
    ZeroMemory(&ps, sizeof(ps));
    ZeroMemory(&gm, sizeof(gm));

    //
    // Get the Administrators SID
    //
    if (AllocateAndInitializeSid(&sia, 2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0, 0, 0, 0, 0, 0, &psidAdmin) ) {
        //
        // Get the Asministrators Security Descriptor (SD)
        //
        psdAdmin = malloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
        if (psdAdmin) {
            if(InitializeSecurityDescriptor(psdAdmin,SECURITY_DESCRIPTOR_REVISION)) {
                //
                // Compute size needed for the ACL then allocate the
                // memory for it
                //
                dwACLSize = sizeof(ACCESS_ALLOWED_ACE) + 8 +
                            GetLengthSid(psidAdmin) - sizeof(DWORD);
                pACL = (PACL)malloc(dwACLSize);
                if(pACL) {
                    //
                    // Initialize the new ACL
                    //
                    if(InitializeAcl(pACL, dwACLSize, ACL_REVISION2)) {
                        //
                        // Add the access-allowed ACE to the DACL
                        //
                        if(AddAccessAllowedAce(pACL,ACL_REVISION2,
                                             (ACCESS_READ | ACCESS_WRITE),psidAdmin)) {
                            //
                            // Set our DACL to the Administrator's SD
                            //
                            if (SetSecurityDescriptorDacl(psdAdmin, TRUE, pACL, FALSE)) {
                                //
                                // AccessCheck is downright picky about what is in the SD,
                                // so set the group and owner
                                //
                                SetSecurityDescriptorGroup(psdAdmin,psidAdmin,FALSE);
                                SetSecurityDescriptorOwner(psdAdmin,psidAdmin,FALSE);

                                //
                                // Initialize GenericMapping structure even though we
                                // won't be using generic rights
                                //
                                gm.GenericRead = ACCESS_READ;
                                gm.GenericWrite = ACCESS_WRITE;
                                gm.GenericExecute = 0;
                                gm.GenericAll = ACCESS_READ | ACCESS_WRITE;

                                //
                                // AccessCheck requires an impersonation token, so lets
                                // indulge it
                                //
                                Impersonated = ImpersonateSelf(SecurityImpersonation);

                                if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {

                                    if (!AccessCheck(psdAdmin, hToken, ACCESS_READ, &gm,
                                                    &ps,&cbps,&dwStatus,&fAdmin)) {

                                        fAdmin = FALSE;
                                    }
                                    CloseHandle(hToken);
                                }
                            }
                        }
                    }
                    free(pACL);
                }
            }
            free(psdAdmin);
        }
        FreeSid(psidAdmin);
    }
    if(Impersonated) {
        RevertToSelf();
    }

    return(fAdmin);
}

HRESULT
ConcatPath(
    IN LPTSTR Path,
    IN DWORD  Len,
    IN LPCTSTR NewPart
    )
/*++

Routine Description:

    Concat NewPart onto Path

Arguments:

    Path - existing path
    Len  - length of buffer
    NewPart - part to append

Return Value:

    status as hresult

--*/
{
    LPTSTR end = Path+lstrlen(Path);
    TCHAR c;
    BOOL add_slash = FALSE;
    BOOL pre_slash = FALSE;
    c = *CharPrev(Path,end);
    if((c!= TEXT('\\')) && (c!= TEXT('/'))) {
        add_slash = TRUE;
    }
    if(NewPart) {
        c = NewPart[0];
        if((c== TEXT('\\')) || (c== TEXT('/'))) {
            if(add_slash) {
                add_slash = FALSE;
            } else {
                NewPart = CharNext(NewPart);
            }
        }
    }
    if((DWORD)((end-Path)+lstrlen(NewPart)+(add_slash?1:0)) >= Len) {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    if(add_slash) {
        end[0] = TEXT('\\');
        end++;
    }
    if(NewPart) {
        lstrcpy(end,NewPart);
    } else {
        end[0] = TEXT('\0');
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\expackdll\devinst.c ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    msoobci.c

Abstract:

    Exception Pack installer helper DLL
    Can be used as a co-installer, or called via setup app, or RunDll32 stub

    This DLL is for internal distribution of exception packs to update
    OS components.

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#include "msoobcip.h"


typedef struct _INST_POSTPROCESSING_INFO {
    DWORD Flags;
} INST_POSTPROCESSING_INFO;

DWORD
CALLBACK
DriverInstallComponents (
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
/*++

Routine Description:

    co-installer callback
    catch the moment of call to DIF_INSTALLDEVICE
    Consider installing exception packs at this point
    If we succeed, we may need to restart device install

Arguments:

    InstallFunction - DIF_INSTALLDEVICE
    DeviceInfoSet/DeviceInfoData - describes device


Return Value:

    status, normally NO_ERROR

--*/
{
    DWORD Status = NO_ERROR;

    if((g_VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_VerInfo.dwMajorVersion >= 5)) {
        //
        // we should only be executing co-installers on Win2k+
        // but this is an added sanity check
        //
        switch (InstallFunction)
        {
        case DIF_INSTALLDEVICE:
            VerbosePrint(TEXT("handling DIF_INSTALLDEVICE"));
            if(Context->PostProcessing) {
                Status = DoDriverInstallComponentsPostProcessing(DeviceInfoSet,DeviceInfoData,Context);
            } else {
                Status = DoDriverInstallComponents(DeviceInfoSet,DeviceInfoData,Context);
            }
            VerbosePrint(TEXT("finished DIF_INSTALLDEVICE with status=0x%08x"),Status);
            break;

        default:
            break;
        }
    }
    return Status;
}


DWORD
DoDriverInstallComponents (
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
/*++

Routine Description:

    co-installer callback
    enumerate all the components sections

Arguments:

    DeviceInfoSet/DeviceInfoData - describes device
    Context - callback context


Return Value:

    status, normally NO_ERROR

--*/
{
    SP_DRVINFO_DATA        DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF                   InfFile = INVALID_HANDLE_VALUE;
    DWORD                  AndFlags = (DWORD)(-1);
    DWORD                  OrFlags  = (DWORD)0;
    INFCONTEXT             CompLine;
    TCHAR                  InstallSectionName[LINE_LEN];
    TCHAR                  CompSectionName[LINE_LEN];
    DWORD                  FieldIndex;
    DWORD                  FieldCount;
    DWORD                  Status;
    DWORD                  FinalStatus = NO_ERROR;
    INST_POSTPROCESSING_INFO PostProcess;

    ZeroMemory(&PostProcess,sizeof(PostProcess));

    //
    // determine selected driver
    // and INF
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver( DeviceInfoSet,
                                   DeviceInfoData,
                                   &DriverInfoData)) {
        Status = GetLastError();
        DebugPrint(TEXT("Fail: SetupDiGetSelectedDriver, Error: 0x%08x"),Status);
        goto clean;
    }

    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &DriverInfoData,
                                    &DriverInfoDetailData,
                                    sizeof(SP_DRVINFO_DETAIL_DATA),
                                    NULL)) {
        Status = GetLastError();
        if (Status == ERROR_INSUFFICIENT_BUFFER) {
            //
            // We don't need the extended information.  Ignore.
            //
        } else {
            DebugPrint(TEXT("Fail: SetupDiGetDriverInfoDetail, 0xError: %08x"),Status);
            goto clean;
        }
    }
    InfFile = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                               NULL,
                               INF_STYLE_WIN4,
                               NULL);
    if (InfFile == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        DebugPrint(TEXT("Fail: SetupOpenInfFile"));
        goto clean;
    }

    if(!SetupDiGetActualSectionToInstall(InfFile,
                                         DriverInfoDetailData.SectionName,
                                         InstallSectionName,
                                         LINE_LEN,
                                         NULL,
                                         NULL)) {

        Status = GetLastError();
        DebugPrint(TEXT("Fail: SetupDiGetActualSectionToInstall, Error: 0x%08x"),Status);
        goto clean;
    }

    //
    // look for one or more Components= entries in INF section
    //
    if (SetupFindFirstLine(InfFile,
                           InstallSectionName,
                           KEY_COMPONENTS,
                           &CompLine)) {
        VerbosePrint(TEXT("Components keyword found in %s"),DriverInfoDetailData.InfFileName);
        do {
            //
            // Components = section,section,...
            // first section @ index 1.
            //
            FieldCount = SetupGetFieldCount(&CompLine);
            for(FieldIndex = 1;FieldIndex<=FieldCount;FieldIndex++) {
                if(SetupGetStringField(&CompLine,
                                       FieldIndex,
                                       CompSectionName,
                                       LINE_LEN,
                                       NULL)) {
                    //
                    // we have a listed section
                    //
                    Status = DoDriverComponentsSection(InfFile,
                                                       CompSectionName,
                                                       &AndFlags,
                                                       &OrFlags);
                    if(Status != NO_ERROR) {
                        FinalStatus = Status;
                        goto clean;
                    }
                } else {
                    Status = GetLastError();
                    DebugPrint(TEXT("Fail: SetupGetStringField, Error: 0x%08x"),Status);
                    //
                    // non-fatal
                    //
                }
            }
        } while (SetupFindNextMatchLine(&CompLine,
                                        KEY_COMPONENTS,
                                        &CompLine));

        //
        // handle AndFlags/OrFlags here
        //
        if(OrFlags & (FLAGS_REBOOT|FLAGS_REINSTALL)) {
            //
            // reboot is required
            //
            HMACHINE hMachine = NULL;
            SP_DEVINFO_LIST_DETAIL_DATA DevInfoListDetail;
            SP_DEVINSTALL_PARAMS DeviceInstallParams;
            DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);

            if(SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                              DeviceInfoData,
                                              &DeviceInstallParams)) {
                //
                // set reboot flags
                //
                DeviceInstallParams.Flags |= DI_NEEDRESTART|DI_NEEDREBOOT;
                SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                                DeviceInfoData,
                                                &DeviceInstallParams);

            }
            DevInfoListDetail.cbSize = sizeof(DevInfoListDetail);
            if(GetDeviceInfoListDetail(DeviceInfoSet,&DevInfoListDetail)) {
                hMachine = DevInfoListDetail.RemoteMachineHandle;
            }
            Set_DevNode_Problem_Ex(DeviceInfoData->DevInst,
                                      CM_PROB_NEED_RESTART,
                                      CM_SET_DEVINST_PROBLEM_OVERRIDE,
                                      hMachine);
        }
        if(OrFlags & FLAGS_REINSTALL) {
            //
            // we'll need to mark the device as needing reinstall when we go through post-processing
            //
            FinalStatus = ERROR_DI_POSTPROCESSING_REQUIRED;
            PostProcess.Flags |= POSTFLAGS_REINSTALL;
        }
    }

clean:

    if (InfFile != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(InfFile);
    }

    if(FinalStatus == ERROR_DI_POSTPROCESSING_REQUIRED) {
        //
        // data to use during post-processing
        //
        INST_POSTPROCESSING_INFO *pPostProcess = malloc(sizeof(INST_POSTPROCESSING_INFO));
        if(!pPostProcess) {
            return ERROR_OUTOFMEMORY;
        }
        *pPostProcess = PostProcess;
        Context->PrivateData = pPostProcess;
    }

    return FinalStatus;
}

DWORD
DoDriverInstallComponentsPostProcessing (
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
/*++

Routine Description:

    co-installer callback
    enumerate all the components sections

Arguments:

    DeviceInfoSet/DeviceInfoData - describes device
    Context - callback context


Return Value:

    status, normally NO_ERROR

--*/
{
    INST_POSTPROCESSING_INFO PostProcess;
    SP_DEVINFO_LIST_DETAIL_DATA DevInfoListDetail;
    HMACHINE hMachine = NULL;

    if(!Context->PrivateData) {
        return Context->InstallResult;
    }
    PostProcess = *(INST_POSTPROCESSING_INFO*)(Context->PrivateData);
    free(Context->PrivateData);
    Context->PrivateData = NULL;

    DevInfoListDetail.cbSize = sizeof(DevInfoListDetail);
    if(GetDeviceInfoListDetail(DeviceInfoSet,&DevInfoListDetail)) {
        hMachine = DevInfoListDetail.RemoteMachineHandle;
    }

    if(PostProcess.Flags & POSTFLAGS_REINSTALL) {

        Set_DevNode_Problem_Ex(DeviceInfoData->DevInst,
                                  CM_PROB_REINSTALL,
                                  CM_SET_DEVINST_PROBLEM_OVERRIDE,
                                  hMachine);
    }

    return Context->InstallResult;
}

DWORD
DoDriverComponentsSection(
    IN     HINF    InfFile,
    IN     LPCTSTR CompSectionName,
    IN OUT DWORD  *AndFlags,
    IN OUT DWORD  *OrFlags
    )
/*++

Routine Description:

    enumerate all the component entries in component section
    component entry consists of
    filename,flags,identity,version
    filename is absolute directory, eg, %1%\foo.inf
    flags - bit 16 set indicating Exception Pack
            bit 0 set indicating device install needs restarting
    identity - component GUID
    version  - component version

Arguments:

    InfFile - handle to INF file
    CompSectionName - handle to components section
    AndFlags/OrFlags - accumulated flags

Return Value:

    status, normally NO_ERROR

--*/
{
    INFCONTEXT             EntryLine;
    TCHAR                  Path[MAX_PATH];
    DWORD                  Flags;
    INT                    FieldVal;
    DWORD                  SubFlags;
    DWORD                  Status;

    if (!SetupFindFirstLine(InfFile,
                            CompSectionName,
                            NULL,
                           &EntryLine)) {
        //
        // section was empty
        //
        VerbosePrint(TEXT("Section [%s] is empty"),CompSectionName);
        return NO_ERROR;
    }
    VerbosePrint(TEXT("Processing components section [%s]"),CompSectionName);
    do {
        if(!SetupGetStringField(&EntryLine,COMPFIELD_NAME,Path,MAX_PATH,NULL)) {
            Status = GetLastError();
            DebugPrint(TEXT("- Fail: SetupGetStringField(1), Error: 0x%08x"),Status);
            return NO_ERROR;
        }
        VerbosePrint(TEXT("Processing component %s"),Path);
        if(SetupGetIntField(&EntryLine,COMPFIELD_FLAGS,&FieldVal)) {
            Flags = (DWORD)FieldVal;
        } else {
            Status = GetLastError();
            DebugPrint(TEXT("- Fail: SetupGetIntField(2), Error: 0x%08x"),Status);
            return NO_ERROR;
        }
        SubFlags = Flags & ~ FLAGS_METHOD;
        switch(Flags & FLAGS_METHOD) {
            case FLAGS_EXPACK:
                Status = DoDriverExPack(&EntryLine,Path,&SubFlags);
                break;
            case FLAGS_QFE:
                Status = DoDriverQfe(&EntryLine,Path,&SubFlags);
                break;
            default:
                DebugPrint(TEXT("- Fail: Invalid component type"));
                Status = ERROR_INVALID_DATA;
                break;
        }
        if(Status != NO_ERROR) {
            return Status;
        }
        if(SubFlags & FLAGS_INSTALLED) {
            *AndFlags &= SubFlags;
            *OrFlags |= SubFlags;
        }
    } while (SetupFindNextLine(&EntryLine,&EntryLine));

    return NO_ERROR;
}

DWORD
DoDriverExPack(
    IN     INFCONTEXT  *EntryLine,
    IN     LPCTSTR      PathName,
    IN OUT DWORD       *Flags
    )
/*++

Routine Description:

    queries and potentially installs exception-pack component

Arguments:

    EntryLine - context for remaining information
    PathName  - name of exception pack INF (param 1)
    SubFlags  - flags passed in (param 2) sans type of install

    component entry consists of
    filename,flags,identity,version
    filename is absolute directory, eg, %1%\foo.inf
    identity - component GUID
    version  - component version

Return Value:

    status, normally NO_ERROR
    if return value >= 0x80000000 then it's a HRESULT error

--*/
{
    TCHAR   CompIdentity[64]; // expecting a GUID
    TCHAR   CompVersion[64];  // major.minor
    TCHAR   CompDesc[DESC_SIZE];     // description
    GUID    ComponentGuid;
    INT     VerMajor = -1;
    INT     VerMinor = -1;
    INT     VerBuild = -1;
    INT     VerQFE = -1;
    DWORD   Status;
    DWORD   dwLen;
    HRESULT hrStatus;
    SETUP_OS_COMPONENT_DATA OsComponentData;
    SETUP_OS_EXCEPTION_DATA OsExceptionData;
    UINT uiRes;
    TCHAR SrcPath[MAX_PATH];
    TCHAR NewSrcPath[MAX_PATH];
    TCHAR CompOsVerRange[128];
    LPTSTR ToVerPart;
    LPTSTR SrcName;
    BOOL PreInst = FALSE;

    VerbosePrint(TEXT("- %s is an exception pack"),PathName);
    //
    // now read in identity and version
    // we can then check to see if an apropriate version installed
    //

    if(!SetupGetStringField(EntryLine,COMPFIELD_COMP,CompIdentity,ARRAY_SIZE(CompIdentity),NULL)) {
        Status = GetLastError();
        DebugPrint(TEXT("- Fail: SetupGetStringField(3), Error: 0x%08x"),Status);
        return Status;
    }
    if(!SetupGetStringField(EntryLine,COMPFIELD_VER,CompVersion,ARRAY_SIZE(CompVersion),NULL)) {
        Status = GetLastError();
        DebugPrint(TEXT("- Fail: SetupGetStringField(4), Error: 0x%08x"),Status);
        return Status;
    }
    if(!SetupGetStringField(EntryLine,COMPFIELD_DESC,CompDesc,ARRAY_SIZE(CompDesc),NULL)) {
        CompDesc[0] = TEXT('\0');
    }
    if(SetupGetStringField(EntryLine,COMPFIELD_OSVER,CompOsVerRange,ARRAY_SIZE(CompOsVerRange),NULL)) {
        //
        // need to verify OS version range, do that now
        //
        int maj_f,min_f,build_f,qfe_f;
        int maj_t,min_t,build_t,qfe_t;

        ToVerPart = _tcschr(CompOsVerRange,TEXT('-'));
        if(ToVerPart) {
            *ToVerPart = TEXT('\0');
            ToVerPart++;
        }
        hrStatus = VersionFromString(CompOsVerRange,&maj_f,&min_f,&build_f,&qfe_f);
        if(!SUCCEEDED(hrStatus)) {
            return (DWORD)hrStatus;
        }
        if((hrStatus == S_FALSE) || (qfe_f != 0)) {
            return ERROR_INVALID_PARAMETER;
        }
        if(ToVerPart) {
            hrStatus = VersionFromString(ToVerPart,&maj_t,&min_t,&build_t,&qfe_t);
            if(!SUCCEEDED(hrStatus)) {
                return (DWORD)hrStatus;
            }
            if((hrStatus == S_FALSE) || (qfe_t != 0)) {
                return ERROR_INVALID_PARAMETER;
            }
            if(CompareVersion(maj_f,
                                min_f,
                                build_f>0 ? build_f : -1,
                                0,
                                g_VerInfo.dwMajorVersion,
                                g_VerInfo.dwMinorVersion,
                                g_VerInfo.dwBuildNumber,
                                0) > 0) {
                VerbosePrint(TEXT("- Skipped (OS < %u.%u.%u)"),
                                maj_f,min_f,build_f);
                return NO_ERROR;
            } else if(CompareVersion(maj_t,
                                min_t,
                                build_t>0 ? build_t : -1,
                                0,
                                g_VerInfo.dwMajorVersion,
                                g_VerInfo.dwMinorVersion,
                                g_VerInfo.dwBuildNumber,
                                0) < 0) {
                VerbosePrint(TEXT("- Skipped (OS > %u.%u.%u)"),
                                maj_t,min_t,build_t);
                return NO_ERROR;
            }
        } else {
            if(CompareVersion(maj_f,
                                min_f,
                                build_f,
                                0,
                                g_VerInfo.dwMajorVersion,
                                g_VerInfo.dwMajorVersion,
                                g_VerInfo.dwMajorVersion,
                                0) != 0) {
                VerbosePrint(TEXT("- Skipped (OS != %u.%u.%u)"),
                                maj_f,min_f,build_f);
                return NO_ERROR;
            }
        }
    }
    //
    // fold CompIdentity into a GUID
    //
    hrStatus = GuidFromString(CompIdentity,&ComponentGuid);
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }
    //
    // and version
    //
    hrStatus = VersionFromString(CompVersion,&VerMajor,&VerMinor,&VerBuild,&VerQFE);
    if(hrStatus == S_FALSE) {
        return ERROR_INVALID_PARAMETER;
    }
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }
    //
    // now do a component check
    //
    ZeroMemory(&OsComponentData,sizeof(OsComponentData));
    OsComponentData.SizeOfStruct = sizeof(OsComponentData);
    ZeroMemory(&OsExceptionData,sizeof(OsExceptionData));
    OsExceptionData.SizeOfStruct = sizeof(OsExceptionData);
    if(QueryRegisteredOsComponent(&ComponentGuid,&OsComponentData,&OsExceptionData)) {
        //
        // maybe already registered?
        //
        if(CompareCompVersion(VerMajor,VerMinor,VerBuild,VerQFE,&OsComponentData)<=0) {
            VerbosePrint(TEXT("- Skipped, %u.%u.%u.%u <= %u.%u.%u.%u"),
                                VerMajor,VerMinor,VerBuild,VerQFE,
                                OsComponentData.VersionMajor,
                                OsComponentData.VersionMinor,
                                OsComponentData.BuildNumber,
                                OsComponentData.QFENumber);
            return NO_ERROR;
        }
    }
    VerbosePrint(TEXT("- Install, %u.%u.%u.%u > %u.%u.%u.%u"),
                                VerMajor,VerMinor,VerBuild,VerQFE,
                                OsComponentData.VersionMajor,
                                OsComponentData.VersionMinor,
                                OsComponentData.BuildNumber,
                                OsComponentData.QFENumber);
    //
    // we need to make sure component INF media is in
    // prompt for media if interactive and INF cannot be found
    //
    dwLen = GetFullPathName(PathName,MAX_PATH,SrcPath,&SrcName);
    if(dwLen >= MAX_PATH) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    if(SrcName == SrcPath) {
        //
        // shouldn't happen
        //
        return ERROR_INVALID_DATA;
    }
    *CharPrev(SrcPath,SrcName) = TEXT('\0');
    uiRes = SetupPromptForDisk(
                    NULL, // parent
                    NULL, // title
                    CompDesc[0] ? CompDesc : NULL, // disk name
                    SrcPath, // path to source
                    SrcName, // name of file
                    NULL,    // tag file
                    IDF_CHECKFIRST|IDF_NOCOMPRESSED|IDF_NOSKIP,
                    NewSrcPath,
                    ARRAY_SIZE(NewSrcPath),
                    NULL);

    switch(uiRes) {
        case DPROMPT_SUCCESS:
            break;
        case DPROMPT_CANCEL:
        case DPROMPT_SKIPFILE:
            return ERROR_FILE_NOT_FOUND;
        case DPROMPT_BUFFERTOOSMALL:
            return ERROR_INSUFFICIENT_BUFFER;
        case DPROMPT_OUTOFMEMORY:
            return ERROR_OUTOFMEMORY;
        default:
            //
            // shouldn't happen
            //
            return ERROR_INVALID_DATA;
    }

    hrStatus = ConcatPath(NewSrcPath,MAX_PATH,SrcName);
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }
    hrStatus = InstallComponent(NewSrcPath,
                                COMP_FLAGS_NOUI,
                                &ComponentGuid,
                                VerMajor,
                                VerMinor,
                                VerBuild,
                                VerQFE,
                                CompDesc[0] ? CompDesc : NULL);
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }
    //
    // if install was not skipped, we get S_OK, else S_FALSE
    //
    if(hrStatus == S_OK) {
        *Flags |= FLAGS_INSTALLED;
    } else if(hrStatus == INST_S_REBOOT) {
        *Flags |= FLAGS_INSTALLED|FLAGS_REBOOT;
    }
    return NO_ERROR;
}

DWORD
CheckQfe(
    IN     INT          SpNum,
    IN     LPCTSTR      QfeNum
    )
/*++

Routine Description:

    This is pretty dirty, it knows where the QFE #'s will go
    in registry for Win2k/WinXP so checks there
    this saves us running the QFE unless we need to
    (assumption is that target OS version already checked)

Arguments:

    SpNum - service pack # that fix should be in
    QfeNum - QfeNum of fix

Return Value:

    ERROR_INVALID_PARAMETER if version not supported
    NO_ERROR if QFE installed
    other status if QFE might not be installed

--*/
{
    HKEY hKey;
    TCHAR KeyPath[MAX_PATH*2];
    LONG res;
    //
    // what about the SP level?
    //
    if(g_VerInfo.wServicePackMajor >= SpNum) {
        VerbosePrint(TEXT("- Skipped (SP >= %u)"),SpNum);
        return NO_ERROR;
    }
    if((g_VerInfo.dwMajorVersion == 5) && (g_VerInfo.dwMinorVersion == 0)) {
        //
        // check for QFE presence on Windows 2000
        //
        _sntprintf(KeyPath,ARRAY_SIZE(KeyPath),
                            TEXT("Software\\Microsoft\\Updates\\Windows 2000\\SP%u\\%s"),
                            SpNum,
                            QfeNum);
        res = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            KeyPath,
                            0,
                            KEY_READ,
                            &hKey);
        if(res == NO_ERROR) {
            RegCloseKey(hKey);
        }
        return (DWORD)res;
    } else if((g_VerInfo.dwMajorVersion == 5) && (g_VerInfo.dwMinorVersion == 1)) {
            //
            // check for QFE presence on Windows XP
            //
            _sntprintf(KeyPath,ARRAY_SIZE(KeyPath),
                                TEXT("Software\\Microsoft\\Updates\\Windows XP\\SP%u\\%s"),
                                SpNum,
                                QfeNum);
            res = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                KeyPath,
                                0,
                                KEY_READ,
                                &hKey);
            if(res == NO_ERROR) {
                RegCloseKey(hKey);
            }
            return (DWORD)res;
    } else {
        return ERROR_INVALID_PARAMETER;
    }
}

DWORD
DoDriverQfe(
    IN     INFCONTEXT  *EntryLine,
    IN     LPCTSTR      PathName,
    IN OUT DWORD       *Flags
    )
/*++

Routine Description:

    queries and potentially installs QFE

Arguments:

    EntryLine - context for remaining information
    PathName  - name of exception pack INF (param 1)
    SubFlags  - flags passed in (param 2) sans type of install

    component entry consists of
    <path\name>,<flags>,<osver>,<os-sp>,<qfenum>
    filename is absolute directory, eg, %1%\foo.exe
    <flags> indicates what to do if qfe installed
    <osver> indicates os version QFE is for, eg, 5.0
    <os-sp> indicates service pack QFE is in, eg, 1
    <qfenum> indicates the qfe number as found in registry

Return Value:

    status, normally NO_ERROR
    if return value >= 0x80000000 then it's a HRESULT error

--*/
{
    TCHAR   QfeOs[64]; // expecting major.minor
    TCHAR   QfeNum[64];  // some descriptive name
    INT     QfeSp;
    INT     VerMaj,VerMin,VerBuild,VerQfe;
    TCHAR Buffer[MAX_PATH];
    TCHAR CmdLine[MAX_PATH*3];
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    DWORD ExitCode;
    DWORD Status;
    HRESULT hrStatus;
    UINT uiRes;
    DWORD dwLen;
    TCHAR SrcPath[MAX_PATH];
    TCHAR NewSrcPath[MAX_PATH];
    LPTSTR SrcName;

    VerbosePrint(TEXT("- %s is a QFE"),PathName);

    if(!SetupGetStringField(EntryLine,COMPFIELD_QFEOS,QfeOs,ARRAY_SIZE(QfeOs),NULL)) {
        Status = GetLastError();
        DebugPrint(TEXT("- Fail: SetupGetStringField(3), Error: 0x%08x"),Status);
        return Status;
    }
    if(!SetupGetIntField(EntryLine,COMPFIELD_QFESP,&QfeSp)) {
        Status = GetLastError();
        DebugPrint(TEXT("- Fail: SetupGetIntField(4), Error: 0x%08x"),Status);
        return Status;
    }
    if(!SetupGetStringField(EntryLine,COMPFIELD_QFENUM,QfeNum,ARRAY_SIZE(QfeNum),NULL)) {
        Status = GetLastError();
        DebugPrint(TEXT("- Fail: SetupGetStringField(5), Error: 0x%08x"),Status);
        return Status;
    }
    //
    // see if QFE is targeted at this version?
    //
    hrStatus = VersionFromString(QfeOs,&VerMaj,&VerMin,&VerBuild,&VerQfe);
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }
    if((hrStatus == S_FALSE) || (VerBuild != 0) || (VerQfe != 0)) {
        return ERROR_INVALID_PARAMETER;
    }
    if(CompareVersion(VerMaj,
                        VerMin,
                        0,
                        0,
                        g_VerInfo.dwMajorVersion,
                        g_VerInfo.dwMinorVersion,
                        0,
                        0) != 0) {
        VerbosePrint(TEXT("- Skipped (OS != %u.%u)"),VerMaj,VerMin);
        return NO_ERROR;
    }
    //
    // see if the Qfe needs to be installed on this OS
    //
    Status = CheckQfe(QfeSp,QfeNum);
    if(Status == ERROR_INVALID_PARAMETER) {
        //
        // invalid parameter because in invalid version was
        // specified
        //
        DebugPrint(TEXT("- Cannot install QFE's for %u.%u"),
                            g_VerInfo.dwMajorVersion,
                            g_VerInfo.dwMinorVersion);
        return Status;
    }
    //
    // ok, has the QFE already been installed?
    //
    if(Status == NO_ERROR) {
        return NO_ERROR;
    }

    //
    // we need to make sure component INF media is in
    // prompt for media if interactive and INF cannot be found
    //
    dwLen = GetFullPathName(PathName,MAX_PATH,SrcPath,&SrcName);
    if(dwLen >= MAX_PATH) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    if(SrcName == SrcPath) {
        //
        // shouldn't happen
        //
        return ERROR_INVALID_DATA;
    }
    *CharPrev(SrcPath,SrcName) = TEXT('\0');
    uiRes = SetupPromptForDisk(
                    NULL, // parent
                    NULL, // title
                    QfeNum, // disk name
                    SrcPath, // path to source
                    SrcName, // name of file
                    NULL,    // tag file
                    IDF_CHECKFIRST|IDF_NOCOMPRESSED|IDF_NOSKIP,
                    NewSrcPath,
                    ARRAY_SIZE(NewSrcPath),
                    NULL);

    switch(uiRes) {
        case DPROMPT_SUCCESS:
            break;
        case DPROMPT_CANCEL:
        case DPROMPT_SKIPFILE:
            return ERROR_FILE_NOT_FOUND;
        case DPROMPT_BUFFERTOOSMALL:
            return ERROR_INSUFFICIENT_BUFFER;
        case DPROMPT_OUTOFMEMORY:
            return ERROR_OUTOFMEMORY;
        default:
            //
            // shouldn't happen
            //
            return ERROR_INVALID_DATA;
    }

    hrStatus = ConcatPath(NewSrcPath,MAX_PATH,SrcName);
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }

    // now build up command line
    //
    lstrcpy(CmdLine,NewSrcPath);
    lstrcat(CmdLine,TEXT(" -n -o -z -q"));

    ZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    ZeroMemory(&ProcessInfo,sizeof(ProcessInfo));

    //
    // kick off rundll32 process to install QFE
    //
    if(!CreateProcess(NewSrcPath,
                      CmdLine,
                      NULL,
                      NULL,
                      FALSE, // don't inherit handles
                      CREATE_NO_WINDOW,    // creation flags
                      NULL, // environment
                      NULL, // directory
                      &StartupInfo,
                      &ProcessInfo
                      )) {
        return GetLastError();
    }
    if(WaitForSingleObject(ProcessInfo.hProcess,INFINITE) == WAIT_OBJECT_0) {
        //
        // process terminated 'fine', retrieve status from shared data
        //
        if(GetExitCodeProcess(ProcessInfo.hProcess,&ExitCode)) {
            Status = (DWORD)ExitCode;
        } else {
            Status = GetLastError();
        }
    } else {
        //
        // failure
        //
        Status = ERROR_INVALID_PARAMETER;
    }
    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);

    if(Status != NO_ERROR) {
        return Status;
    }
    if(CheckQfe(QfeSp,QfeNum)!=NO_ERROR) {
        //
        // sanity check failed
        //
        return E_UNEXPECTED;
    }

    //
    // if install was not skipped, we get S_OK, else S_FALSE
    //
#if 0
    if(hrStatus == S_OK) {
        *Flags |= FLAGS_INSTALLED;
    } else if(hrStatus == INST_S_REBOOT) {
    }
#endif
    *Flags |= FLAGS_INSTALLED|FLAGS_REBOOT;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\expackdll\msoobcip.h ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    msoobcip.h

Abstract:

    Exception Pack installer helper DLL
    Can be used as a co-installer, or called via setup app, or RunDll32 stub

    This DLL is for internal distribution of exception packs to update
    OS components.

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#define _SETUPAPI_VER 0x0500
#include <windows.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <infstr.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <malloc.h>
#include <objbase.h>
#include <lm.h>
#include <excppkg.h>
#include <msoobci.h>


//
// Keywords
//
#define KEY_REBOOT                  TEXT("Reboot")
#define KEY_DOTSERVICES             TEXT(".Services")
#define KEY_DOTPRECOPY              TEXT(".Precopy")
#define KEY_COMPONENTID             TEXT("ComponentID")
#define KEY_DEFAULTINSTALL          TEXT("DefaultInstall")
#define KEY_COMPONENTS              TEXT("Components")

#define CMD_SEP         TEXT(';')    // character used for DoInstall
#define DESC_SIZE       (64)         // size of exception pack description

//
// common
//
#define COMPFIELD_NAME  (1)
#define COMPFIELD_FLAGS (2)
//
// expack
//
// <path\name>,<flags>,<comp>,<ver>,<desc>,<osver>-<osver>
//
#define COMPFIELD_COMP  (3)
#define COMPFIELD_VER   (4)
#define COMPFIELD_DESC  (5)
#define COMPFIELD_OSVER (6)
//
// qfe
//
// <path\name>,<flags>,<osver>,<os-sp>,<qfenum>
//
#define COMPFIELD_QFEOS  (3)
#define COMPFIELD_QFESP  (4)
#define COMPFIELD_QFENUM (5)


#define FLAGS_METHOD    0xffff0000
#define FLAGS_EXPACK    0x00010000   // method = exception pack
#define FLAGS_QFE       0x00020000   // method = QFE
#define FLAGS_REINSTALL 0x00000001   // indicates need to reinstall
#define FLAGS_REBOOT    0x00000002   // set if reboot required
#define FLAGS_INSTALLED 0x80000000   // (not user) set if a component installed


#define POSTFLAGS_REINSTALL 0x00000001 // postprocessing - set problem to reinstall

#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))

extern HANDLE g_DllHandle;
extern OSVERSIONINFOEX g_VerInfo;

VOID
DebugPrint(
    PCTSTR format,
    ...                                 OPTIONAL
    );

#if DBG
//
// real DebugPrint
//
#define VerbosePrint DebugPrint

#else
//
// don't want VerbosePrint
// below define has intentional side effect(s)
// VerbosePrint(TEXT("text"),foo) -> 1?0:(TEXT("text"),foo) -> 0 -> nothing
//
#define VerbosePrint /* (...) */    1?0: /* (...) */

#endif // DBG


DWORD
DoDriverInstallComponents (
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    );

DWORD
DoDriverInstallComponentsPostProcessing (
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    );

DWORD
DoDriverComponentsSection(
    IN     HINF    InfFile,
    IN     LPCTSTR CompSectionName,
    IN OUT DWORD  *AndFlags,
    IN OUT DWORD  *OrFlags
    );

DWORD
DoDriverExPack(
    IN     INFCONTEXT  *EntryLine,
    IN     LPCTSTR      PathName,
    IN OUT DWORD       *Flags
    );

DWORD
DoDriverQfe(
    IN     INFCONTEXT  *EntryLine,
    IN     LPCTSTR      PathName,
    IN OUT DWORD       *Flags
    );

HRESULT
StringFromGuid(
    IN  GUID   *GuidBinary,
    OUT LPTSTR GuidString,
    IN  DWORD  BufferSize
    );

HRESULT
GuidFromString(
    IN  LPCTSTR GuidString,
    OUT GUID   *GuidBinary
    );

HRESULT
VersionFromString(
    IN  LPCTSTR VerString,
    OUT INT * VerMajor,
    OUT INT * VerMinor,
    OUT INT * VerBuild,
    OUT INT * VerQFE
    );

int
CompareVersion(
    IN INT VerMajor,
    IN INT VerMinor,
    IN INT VerBuild,
    IN INT VerQFE,
    IN INT OtherMajor,
    IN INT OtherMinor,
    IN INT OtherBuild,
    IN INT OtherQFE
    );

int
CompareCompVersion(
    IN INT VerMajor,
    IN INT VerMinor,
    IN INT VerBuild,
    IN INT VerQFE,
    IN PSETUP_OS_COMPONENT_DATA SetupOsComponentData
    );

BOOL
WINAPI
QueryRegisteredOsComponent(
    IN  LPGUID ComponentGuid,
    OUT PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    OUT PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData
    );

BOOL
WINAPI
RegisterOsComponent (
    IN const PSETUP_OS_COMPONENT_DATA ComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    );

BOOL
WINAPI
UnRegisterOsComponent (
    IN const LPGUID ComponentGuid
    );


UINT
GetRealWindowsDirectory(
    LPTSTR lpBuffer,  // buffer to receive directory name
    UINT uSize        // size of name buffer
    );

BOOL QueryInfOriginalFileInformation(
  PSP_INF_INFORMATION InfInformation,
  UINT InfIndex,
  PSP_ALTPLATFORM_INFO AlternatePlatformInfo,
  PSP_ORIGINAL_FILE_INFO OriginalFileInfo
);

BOOL CopyOEMInf(
  PCTSTR SourceInfFileName,
  PCTSTR OEMSourceMediaLocation,
  DWORD OEMSourceMediaType,
  DWORD CopyStyle,
  PTSTR DestinationInfFileName,
  DWORD DestinationInfFileNameSize,
  PDWORD RequiredSize,
  PTSTR *DestinationInfFileNameComponent
);


HRESULT
MakeSureParentPathExists(
    IN LPTSTR Path
    );

HRESULT
MakeSurePathExists(
    IN LPTSTR Path
    );

LPTSTR GetSplit(
    IN LPCTSTR FileName
    );

LPTSTR GetBaseName(
    IN LPCTSTR FileName
    );

HRESULT
ConcatPath(
    IN LPTSTR Path,
    IN DWORD  Len,
    IN LPCTSTR NewPart
    );

HRESULT
InstallExceptionPackFromInf(
    IN LPCTSTR InfPath,
    IN LPCTSTR Media,
    IN LPCTSTR Store,
    IN DWORD   Flags
    );

HRESULT
ProxyInstallExceptionPackFromInf(
    IN LPCTSTR InfPath,
    IN LPCTSTR Media,
    IN LPCTSTR Store,
    IN DWORD   Flags
    );

CONFIGRET
Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    );

BOOL
GetDeviceInfoListDetail(
    IN HDEVINFO  DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA  DeviceInfoSetDetailData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\expackdll\msoobci.h ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    msoobci.h

Abstract:

    Exception Pack installer helper DLL

    Public API header

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/

#ifndef __MSOOBCI_H__
#define __MSOOBCI_H__

//
// DriverInstallComponents is a standard co-installer entrypoint
// return status is WinError form, as expected by SetupAPI
//

DWORD
CALLBACK
DriverInstallComponents (
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    );

//
// InstallComponent is a generic entry point
// return status is HRESULT form, providing success codes
//
// CompGuid - if NULL, use GUID specified in INF (ComponentId)
//            else verify against GUID specified in INF
// VerMajor/VerMinor/VerBuild/VerQFE
//          - if -1, use version specified in INF (ComponentVersion)
//            else use this version and verify against version if specified in INF
// Name
//          - if NULL, use name specified in INF (ComponentName)
//            else use this component name.
//

#define INST_S_REBOOT    ((HRESULT)(0x20000100)) // 'success' code that indicates reboot required
#define INST_S_REBOOTING ((HRESULT)(0x20000101)) // indicates reboot in progress

#define COMP_FLAGS_NOINSTALL      0x00000001    // place in store, don't install
#define COMP_FLAGS_NOUI           0x00000002    // don't show any UI
#define COMP_FLAGS_NOPROMPTREBOOT 0x00000004    // reboot if needed (no prompt)
#define COMP_FLAGS_PROMPTREBOOT   0x00000008    // prompt for reboot if needed
#define COMP_FLAGS_NEEDSREBOOT    0x00000010    // assume reboot needed
#define COMP_FLAGS_FORCE          0x00000020    // don't do version check

HRESULT
WINAPI
InstallComponentA(
    IN LPCSTR InfPath,
    IN DWORD   Flags,
    IN const GUID * CompGuid,  OPTIONAL
    IN INT VerMajor,           OPTIONAL
    IN INT VerMinor,           OPTIONAL
    IN INT VerBuild,           OPTIONAL
    IN INT VerQFE,             OPTIONAL
    IN LPCSTR Name             OPTIONAL
    );

HRESULT
WINAPI
InstallComponentW(
    IN LPCWSTR InfPath,
    IN DWORD   Flags,
    IN const GUID * CompGuid,  OPTIONAL
    IN INT VerMajor,           OPTIONAL
    IN INT VerMinor,           OPTIONAL
    IN INT VerBuild,           OPTIONAL
    IN INT VerQFE,             OPTIONAL
    IN LPCWSTR Name            OPTIONAL
    );

#ifdef UNICODE
#define InstallComponent InstallComponentW
#else
#define InstallComponent InstallComponentA
#endif


//
// DoInstall is a RunDll32 entrypoint.
// CommandLine = "InfPath;Flags;GUID;Version;Name"
// where version has format High.Low.Build.QFE
//
// calls InstallComponent, but drops return status
//

VOID
WINAPI
DoInstallA(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR     CommandLine,
    IN INT       ShowCommand
    );

VOID
WINAPI
DoInstallW(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR    CommandLine,
    IN INT       ShowCommand
    );

#ifdef UNICODE
#define DoInstall DoInstallW
#else
#define DoInstall DoInstallA
#endif

//
// lower-level install API's
// install from specified section of specified INF
// if SectionName not specified, install from (potentially decorated)
// "DefaultInstall"
//

HRESULT
WINAPI
InstallInfSectionA(
    IN LPCSTR  InfPath,
    IN LPCSTR  SectionName, OPTIONAL
    IN DWORD   Flags
    );

HRESULT
WINAPI
InstallInfSectionW(
    IN LPCWSTR InfPath,
    IN LPCWSTR SectionName, OPTIONAL
    IN DWORD   Flags
    );

#ifdef UNICODE
#define InstallInfSection InstallInfSectionW
#else
#define InstallInfSection InstallInfSectionA
#endif

//
// check to see if current user has admin rights
// Caller is NOT expected to be impersonating anyone and IS
// expected to be able to open their own process and process
// token.
//
BOOL
WINAPI
IsUserAdmin(
    VOID
    );

//
// see if process is running in an interactive window station
// (ie, can show dialogs and get input off user)
//
BOOL
WINAPI
IsInteractiveWindowStation(
    VOID
    );




#endif // __MSOOBCI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\expackdll\stubs.c ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    stubs.c

Abstract:

    Stubs for various API's

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#include "msoobcip.h"

#define MODULE_SYSSETUP TEXT("syssetup.dll")
#define MODULE_KERNEL32 TEXT("kernel32.dll")
#define MODULE_SETUPAPI TEXT("setupapi.dll")
#define NAME_SetupQueryRegisteredOsComponent  "SetupQueryRegisteredOsComponent"
#define NAME_GetSystemWindowsDirectory        "GetSystemWindowsDirectoryW"
#define NAME_SetupRegisterOsComponent         "SetupRegisterOsComponent"
#define NAME_SetupUnRegisterOsComponent       "SetupUnRegisterOsComponent"
#define NAME_SetupCopyOEMInf                  "SetupCopyOEMInfW"
#define NAME_SetupQueryInfOriginalFileInformation "SetupQueryInfOriginalFileInformationW"
#define NAME_SetupDiGetDeviceInfoListDetail   "SetupDiGetDeviceInfoListDetailW"
#define NAME_CM_Set_DevNode_Problem_Ex        "CM_Set_DevNode_Problem_Ex"

typedef BOOL (WINAPI *API_SetupQueryRegisteredOsComponent)(LPGUID,PSETUP_OS_COMPONENT_DATA,PSETUP_OS_EXCEPTION_DATA);
typedef BOOL (WINAPI *API_SetupRegisterOsComponent)(PSETUP_OS_COMPONENT_DATA,PSETUP_OS_EXCEPTION_DATA);
typedef BOOL (WINAPI *API_SetupUnRegisterOsComponent)(LPGUID);
typedef BOOL (WINAPI *API_GetSystemWindowsDirectory)(LPTSTR,UINT);
typedef BOOL (WINAPI *API_SetupQueryInfOriginalFileInformation)(PSP_INF_INFORMATION,UINT,PSP_ALTPLATFORM_INFO,PSP_ORIGINAL_FILE_INFO);
typedef BOOL (WINAPI *API_SetupCopyOEMInf)(PCTSTR,PCTSTR,DWORD,DWORD,PTSTR,DWORD,PDWORD,PTSTR*);
typedef BOOL (WINAPI *API_SetupDiGetDeviceInfoListDetail)(HDEVINFO,PSP_DEVINFO_LIST_DETAIL_DATA);
typedef CONFIGRET (WINAPI *API_CM_Set_DevNode_Problem_Ex)(DEVINST,ULONG,ULONG,HMACHINE);



FARPROC
GetModProc(
    IN OUT HMODULE * phModule,
    IN LPCTSTR ModuleName,
    IN LPCSTR ApiName
    )
/*++

Routine Description:

    Demand-load specific API
    combines LoadLibrary with GetProcAddress

Arguments:

    phModule - if points to NULL, replaced by handle to module ModuleName
    ModuleName - valid if phModule points to NULL
    ApiName - name of API to load

Return Value:

    procedure, or NULL

--*/
{
    HMODULE hMod = *phModule;
    if(!hMod) {
        HMODULE hModPrev;
        //
        // need to load
        //
        hMod = LoadLibrary(ModuleName);
        if(hMod == NULL) {
            //
            // error linking to module
            //
            return NULL;
        }
        hModPrev = InterlockedCompareExchangePointer(phModule,hMod,NULL);
        if(hModPrev) {
            //
            // someone else set phModule
            //
            FreeLibrary(hMod);
            hMod = hModPrev;
        }
    }
    return GetProcAddress(hMod,ApiName);
}

FARPROC
GetSysSetupProc(
    IN LPCSTR ApiName
    )
/*++

Routine Description:

    Demand-load specific API from syssetup.dll
    1st time side-effect is that we'll load and keep syssetup.dll in memory
    ok to not deref syssetup.dll when dll exists.

Arguments:

    ApiName - name of API to load

Return Value:

    procedure, or NULL

--*/
{
    static HMODULE hSysSetupDll = NULL;
    return GetModProc(&hSysSetupDll,MODULE_SYSSETUP,ApiName);
}

FARPROC
GetSetupApiProc(
    IN LPCSTR ApiName
    )
/*++

Routine Description:

    Demand-load specific API from setupapi.dll
    1st time side-effect is that we'll ref and keep setupapi.dll in memory
    ok to not deref syssetup.dll when dll exists.

Arguments:

    ApiName - name of API to load

Return Value:

    procedure, or NULL

--*/
{
    static HMODULE hSetupApiDll = NULL;
    return GetModProc(&hSetupApiDll,MODULE_SETUPAPI,ApiName);
}

FARPROC
GetKernelProc(
    IN LPCSTR ApiName
    )
/*++

Routine Description:

    Demand-load specific API from kernel32.dll
    1st time side-effect is that we'll load and keep kernel32.dll in memory
    (it's in memory anyway)
    ok to not deref kernel32.dll when dll exists.

Arguments:

    ApiName - name of API to load

Return Value:

    procedure, or NULL

--*/
{
    static HMODULE hKernel32Dll = NULL;
    return GetModProc(&hKernel32Dll,MODULE_KERNEL32,ApiName);
}

BOOL
WINAPI
QueryRegisteredOsComponent(
    IN  LPGUID ComponentGuid,
    OUT PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    OUT PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData
    )
/*++

Routine Description:

    Demand-load and use SetupQueryRegisteredOsComponent from syssetup.dll, or
    use static version if not available

Arguments:

    as SetupQueryRegisteredOsComponent

Return Value:

    as SetupQueryRegisteredOsComponent

--*/
{
    static API_SetupQueryRegisteredOsComponent Func_SetupQueryRegisteredOsComponent = NULL;
    if(!Func_SetupQueryRegisteredOsComponent) {
        Func_SetupQueryRegisteredOsComponent = (API_SetupQueryRegisteredOsComponent)GetSysSetupProc(NAME_SetupQueryRegisteredOsComponent);
        if(!Func_SetupQueryRegisteredOsComponent) {
            Func_SetupQueryRegisteredOsComponent = SetupQueryRegisteredOsComponent; // static
        }
    }
    return Func_SetupQueryRegisteredOsComponent(ComponentGuid,SetupOsComponentData,SetupOsExceptionData);
}

BOOL
WINAPI
RegisterOsComponent (
    IN const PSETUP_OS_COMPONENT_DATA ComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    )
/*++

Routine Description:

    Demand-load and use SetupRegisterOsComponent from syssetup.dll, or
    use static version if not available

Arguments:

    as SetupRegisterOsComponent

Return Value:

    as SetupRegisterOsComponent

--*/
{
    static API_SetupRegisterOsComponent Func_SetupRegisterOsComponent = NULL;
    if(!Func_SetupRegisterOsComponent) {
        Func_SetupRegisterOsComponent = (API_SetupRegisterOsComponent)GetSysSetupProc(NAME_SetupRegisterOsComponent);
        if(!Func_SetupRegisterOsComponent) {
            Func_SetupRegisterOsComponent = SetupRegisterOsComponent; // static
        }
    }
    return Func_SetupRegisterOsComponent(ComponentData,ExceptionData);
}


BOOL
WINAPI
UnRegisterOsComponent (
    IN const LPGUID ComponentGuid
    )
/*++

Routine Description:

    Demand-load and use SetupUnRegisterOsComponent from syssetup.dll, or
    use static version if not available

Arguments:

    as SetupUnRegisterOsComponent

Return Value:

    as SetupUnRegisterOsComponent

--*/
{
    static API_SetupUnRegisterOsComponent Func_SetupUnRegisterOsComponent = NULL;
    if(!Func_SetupUnRegisterOsComponent) {
        Func_SetupUnRegisterOsComponent = (API_SetupUnRegisterOsComponent)GetSysSetupProc(NAME_SetupUnRegisterOsComponent);
        if(!Func_SetupUnRegisterOsComponent) {
            Func_SetupUnRegisterOsComponent = SetupUnRegisterOsComponent; // static
        }
    }
    return Func_SetupUnRegisterOsComponent(ComponentGuid);
}

UINT
GetRealWindowsDirectory(
    LPTSTR lpBuffer,  // buffer to receive directory name
    UINT uSize        // size of name buffer
    )
/*++

Routine Description:

    Use GetSystemWindowsDirectory if it exists
    otherwise use GetWindowsDirectory

Arguments:

    as GetSystemWindowsDirectory

Return Value:

    as GetSystemWindowsDirectory

--*/
{
    static API_GetSystemWindowsDirectory Func_GetSystemWindowsDirectory = NULL;

    if(!Func_GetSystemWindowsDirectory) {
        Func_GetSystemWindowsDirectory = (API_GetSystemWindowsDirectory)GetKernelProc(NAME_GetSystemWindowsDirectory);
        if(!Func_GetSystemWindowsDirectory) {
            Func_GetSystemWindowsDirectory = GetWindowsDirectory; // static
        }
    }
    return Func_GetSystemWindowsDirectory(lpBuffer,uSize);
}

BOOL Downlevel_SetupQueryInfOriginalFileInformation(
  PSP_INF_INFORMATION InfInformation,
  UINT InfIndex,
  PSP_ALTPLATFORM_INFO AlternatePlatformInfo,
  PSP_ORIGINAL_FILE_INFO OriginalFileInfo
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

BOOL QueryInfOriginalFileInformation(
  PSP_INF_INFORMATION InfInformation,
  UINT InfIndex,
  PSP_ALTPLATFORM_INFO AlternatePlatformInfo,
  PSP_ORIGINAL_FILE_INFO OriginalFileInfo
)
{
    static API_SetupQueryInfOriginalFileInformation Func_SetupQueryInfOriginalFileInformation = NULL;

    if(!Func_SetupQueryInfOriginalFileInformation) {
        Func_SetupQueryInfOriginalFileInformation = (API_SetupQueryInfOriginalFileInformation)GetSetupApiProc(NAME_SetupQueryInfOriginalFileInformation);
        if(!Func_SetupQueryInfOriginalFileInformation) {
            Func_SetupQueryInfOriginalFileInformation = Downlevel_SetupQueryInfOriginalFileInformation;
        }
    }
    return Func_SetupQueryInfOriginalFileInformation(InfInformation,InfIndex,AlternatePlatformInfo,OriginalFileInfo);
}

BOOL
WINAPI
Downlevel_SetupCopyOEMInf(
  PCTSTR SourceInfFileName,
  PCTSTR OEMSourceMediaLocation,
  DWORD OEMSourceMediaType,
  DWORD CopyStyle,
  PTSTR DestinationInfFileName,
  DWORD DestinationInfFileNameSize,
  PDWORD RequiredSize,
  PTSTR *DestinationInfFileNameComponent
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

BOOL CopyOEMInf(
  PCTSTR SourceInfFileName,
  PCTSTR OEMSourceMediaLocation,
  DWORD OEMSourceMediaType,
  DWORD CopyStyle,
  PTSTR DestinationInfFileName,
  DWORD DestinationInfFileNameSize,
  PDWORD RequiredSize,
  PTSTR *DestinationInfFileNameComponent
)
{
    static API_SetupCopyOEMInf Func_SetupCopyOEMInf = NULL;

    if(!Func_SetupCopyOEMInf) {
        Func_SetupCopyOEMInf = (API_SetupCopyOEMInf)GetSetupApiProc(NAME_SetupCopyOEMInf);
        if(!Func_SetupCopyOEMInf) {
            Func_SetupCopyOEMInf = Downlevel_SetupCopyOEMInf; // static
        }
    }
    return Func_SetupCopyOEMInf(SourceInfFileName,
                                OEMSourceMediaLocation,
                                OEMSourceMediaType,
                                CopyStyle,
                                DestinationInfFileName,
                                DestinationInfFileNameSize,
                                RequiredSize,
                                DestinationInfFileNameComponent
                                );
}

BOOL
WINAPI
Downlevel_SetupDiGetDeviceInfoListDetail(
    IN HDEVINFO  DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA  DeviceInfoSetDetailData
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

BOOL
GetDeviceInfoListDetail(
    IN HDEVINFO  DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA  DeviceInfoSetDetailData
    )
{
    static API_SetupDiGetDeviceInfoListDetail Func_SetupDiGetDeviceInfoListDetail = NULL;

    if(!Func_SetupDiGetDeviceInfoListDetail) {
        Func_SetupDiGetDeviceInfoListDetail = (API_SetupDiGetDeviceInfoListDetail)GetSetupApiProc(NAME_SetupDiGetDeviceInfoListDetail);
        if(!Func_SetupDiGetDeviceInfoListDetail) {
            Func_SetupDiGetDeviceInfoListDetail = Downlevel_SetupDiGetDeviceInfoListDetail; // static
        }
    }
    return Func_SetupDiGetDeviceInfoListDetail(DeviceInfoSet,DeviceInfoSetDetailData);

}

CONFIGRET
WINAPI
Downlevel_CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )
{
    return CR_SUCCESS;
}

CONFIGRET
Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )
{
    static API_CM_Set_DevNode_Problem_Ex Func_CM_Set_DevNode_Problem_Ex = NULL;

    if(!Func_CM_Set_DevNode_Problem_Ex) {
        Func_CM_Set_DevNode_Problem_Ex = (API_CM_Set_DevNode_Problem_Ex)GetSetupApiProc(NAME_CM_Set_DevNode_Problem_Ex);
        if(!Func_CM_Set_DevNode_Problem_Ex) {
            Func_CM_Set_DevNode_Problem_Ex = Downlevel_CM_Set_DevNode_Problem_Ex; // static
        }
    }
    return Func_CM_Set_DevNode_Problem_Ex(dnDevInst,ulProblem,ulFlags,hMachine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\blob.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        blob.h

Abstract:

    Conceptual blob of data (smart pointer variation)
    this allows passing of a large object around
    like a pointer but with cleanup if stack is unwound (eg, due to an exception)
    and can also be passed into the STL constructs

    blob<basetype> creates a container object. One container object
    can create the blob.


    ASSUMPTIONS:
      blob<x> val1,val2;

      thread1 & thread2 calling "val1.create()" is *not* thread safe
      thread1 & thread2 calling "val1=val2" is *not* thread safe
      thread1 calling "val1=val2" where val2 owned by thread 2 *is* thread safe
       as long as no other threads are trying to assign a value to val1.

      ie assignment of an instance of blob<x> is *not* thread safe, however
      the referenced 'pointer' of blob<x> *is* thread safe

      This requires interlocked ref-counting on the shared data

History:

    Created July 2001 - JamieHun

--*/

#ifndef _INFSCAN_BLOB_H_
#define _INFSCAN_BLOB_H_

template <class _Ty> class blob {
private:
    typedef blob<_Ty> _Myt;
    typedef _Ty value_type;

    class _Item {
        //
        // the allocated structure
        //
    public:
        LONG _Reference;
        value_type _Object;
        _Item() {
            _Reference = 1;
        }
        void _AddRef() {
            if(this) {
                //
                // needs to be thread-safe as two different threads
                // can access the same _Item
                // to inc/dec
                //
                InterlockedIncrement(&_Reference);
            }
        }
        void _Release() {
            if(this) {
                //
                // needs to be thread-safe as two different threads
                // can access the same _Item
                // to inc/dec
                //
                // obviously if one is dec'ing to zero, nobody else
                // has a reference to it
                //
                if(InterlockedDecrement(&_Reference) == 0) {
                    delete this;
                }
            }
        }
    };
    //
    // pointer to this special structure
    //
    _Item *_pItem;

public:
    _Myt & create(void) {
        _pItem->_Release();
        _pItem = NULL;
        _pItem = new _Item; // might throw
        return *this;
    }
    blob(bool f = false) {
        _pItem = NULL;
        if(f) {
            create();
        }
    }
    //
    // const implies constness of data
    // AddRef doesn't effect true constness of data
    // it's a behind the scenes thing
    //
    blob(const _Myt & other) {
        const_cast<_Item*>(other._pItem)->_AddRef();
        _pItem = other._pItem;
    }
    _Myt & operator=(const _Myt & other) {
        if(_pItem != other._pItem) {
            const_cast<_Item*>(other._pItem)->_AddRef();
            _pItem->_Release();
            _pItem = other._pItem;
        }
        return *this;
    }
    bool operator==(const _Myt & other) const {
        return _pItem == other._pItem;
    }
    bool operator!=(const _Myt & other) const {
        return _pItem == other._pItem;
    }
    operator bool() const {
        return _pItem ? true : false;
    }
    bool operator!() const {
        return _pItem ? false : true;
    }
    operator value_type*() const {
        if(_pItem) {
            return &_pItem->_Object;
        } else {
            return NULL;
        }
    }
    operator value_type&() const {
        if(_pItem) {
            return _pItem->_Object;
        } else {
            throw bad_pointer();
        }
    }
    value_type& operator*() const {
        if(_pItem) {
            return _pItem->_Object;
        } else {
            throw bad_pointer();
        }
    }
    value_type* operator->() const {
        if(_pItem) {
            return &_pItem->_Object;
        } else {
            return NULL;
        }
    }
};

#endif // !_INFSCAN_BLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\common.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        common.h

Abstract:

    Common types/macros/constants

History:

    Created July 2001 - JamieHun

--*/

#ifndef _INFSCAN_COMMON_H_
#define _INFSCAN_COMMON_H_

#define ASIZE(x) (sizeof(x)/sizeof((x)[0]))
typedef vector<TCHAR> tcharbuffer;
typedef map<SafeString,SafeString> StringToString;
typedef map<int,int>         IntToInt;
typedef map<SafeString,int>     StringToInt;
typedef map<int,SafeString>     IntToString;
typedef list<SafeString>        StringList;
typedef set<SafeString>         StringSet;
typedef map<SafeString,StringSet> StringToStringset;

#define PLATFORM_MASK_WIN            (0x00000001)
#define PLATFORM_MASK_NTX86          (0x00000002)
#define PLATFORM_MASK_NTIA64         (0x00000004)
#define PLATFORM_MASK_NTAMD64        (0x00000008)
#define PLATFORM_MASK_NT             (0x0000000E)
#define PLATFORM_MASK_ALL_ARCHITECTS (0x0000ffff)
#define PLATFORM_MASK_ALL_MAJOR_VER  (0x00010000)
#define PLATFORM_MASK_ALL_MINOR_VER  (0x00020000)
#define PLATFORM_MASK_ALL_TYPE       (0x00040000)
#define PLATFORM_MASK_ALL_SUITE      (0x00080000)
#define PLATFORM_MASK_ALL            (0x00ffffff)
#define PLATFORM_MASK_IGNORE         (0x80000000) // indicates never do
#define PLATFORM_MASK_MODIFIEDFILES  (0x40000000) // for HasDependentFileChanged

#define GUID_STRING_LEN (39)

//
// basic critical section
//
class CriticalSection {
private:
    CRITICAL_SECTION critsect;

public:
    CriticalSection()
    {
        InitializeCriticalSection(&critsect);
    }
    ~CriticalSection()
    {
        DeleteCriticalSection(&critsect);
    }
    void Enter()
    {
        EnterCriticalSection(&critsect);
    }
    void Leave()
    {
        LeaveCriticalSection(&critsect);
    }
};

//
// use this inside a function to manage enter/leaving a critical section
//
class ProtectedSection {
private:
    CriticalSection & CS;
    int count;
public:
    ProtectedSection(CriticalSection & sect,BOOL enter=TRUE) : CS(sect)
    {
        count = 0;
        if(enter) {
            Enter();
        }
    }
    ~ProtectedSection()
    {
        if(count) {
            CS.Leave();
        }
    }
    void Enter()
    {
        count++;
        if(count == 1) {
            CS.Enter();
        }
    }
    void Leave()
    {
        if(count>0) {
            count--;
            if(count == 0) {
                CS.Leave();
            }
        }
    }
};

//
// for string/product lookup tables
//
struct StringProdPair {
    PCTSTR String;
    DWORD  ProductMask;
};

//
// SourceDisksFiles tables
//
struct SourceDisksFilesEntry {
    BOOL    Used;                // indicates someone referenced it at least once
    DWORD   Platform;
    int     DiskId; // field 1
    SafeString SubDir; // field 2
    //
    // the following are specific to layout.inf
    //
    int     TargetDirectory;     // field 8
    int     UpgradeDisposition;  // field 9
    int     TextModeDisposition; // field 10
    SafeString TargetName;          // field 11
};

typedef list<SourceDisksFilesEntry>  SourceDisksFilesList;
typedef map<SafeString,SourceDisksFilesList> StringToSourceDisksFilesList;

//
// DestinationDirs tables
//
struct TargetDirectoryEntry {
    bool    Used;                // indicates someone referenced it at least once
    int     DirId;               // DIRID
    SafeString SubDir;              // sub-directory
};

typedef map<SafeString,TargetDirectoryEntry> CopySectionToTargetDirectoryEntry;

//
// exception classes
//
class bad_pointer : public exception {
public:
    bad_pointer(const char *_S = "bad pointer") : exception(_S) {}
};

//
// globals.cpp and common.inl
//
VOID Usage(VOID);
void FormatToStream(FILE * stream,DWORD fmt,DWORD flags,...);
PTSTR CopyString(PCTSTR arg, int extra = 0);
#ifdef UNICODE
PTSTR CopyString(PCSTR arg, int extra = 0);
#endif
SafeString PathConcat(const SafeString & path,const SafeString & tail);
int GetFullPathName(const SafeString & given,SafeString & target);
bool MyGetStringField(PINFCONTEXT Context,DWORD FieldIndex,SafeString & result,bool downcase = true);
bool MyIsAlpha(CHAR c);
bool MyIsAlpha(WCHAR c);
LPSTR MyCharNext(LPCSTR lpsz);
LPWSTR MyCharNext(LPCWSTR lpsz);
SafeString QuoteIt(const SafeString & val);
int GeneratePnf(const SafeString & pnf);
void Write(HANDLE hFile,const SafeStringW & str);
void Write(HANDLE hFile,const SafeStringA & str);
//
// forward references
//
class InfScan;
class GlobalScan;
class InstallScan;
class ParseInfContext;

#endif //!_INFSCAN_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\expackdll\proxyinst.c ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    proxyinst.c

Abstract:

    Exception Pack installer helper DLL
    Can be used as a co-installer, or called via setup app, or RunDll32 stub

    This DLL is for internal distribution of exception packs to update
    OS components.

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#include "msoobcip.h"

typedef struct _PROXY_DATA {
    TCHAR InfPath[MAX_PATH];
    TCHAR Media[MAX_PATH];
    TCHAR Store[MAX_PATH];
    DWORD Flags;
    HRESULT hrStatus;
} PROXY_DATA, * PPROXY_DATA;


HRESULT
ProxyInstallExceptionPackFromInf(
    IN LPCTSTR InfPath,
    IN LPCTSTR Media,
    IN LPCTSTR Store,
    IN DWORD   Flags
    )
/*++

Routine Description:

    Kicks off another process, and calls RemoteInstallExceptionPackFromInf in
    remote process.
    (Bug workaround)
    Otherwise as InstallExceptionPackFromInf

Arguments:

    InfPath - name of Inf in Media location
    Media   - InfPath less InfName
    Store   - expack store
    Flags   - various flags

Return Value:

    status as hresult

--*/
{
    HANDLE hMapping = NULL;
    DWORD Status;
    HRESULT hrStatus;
    PPROXY_DATA pData = NULL;
    TCHAR ExecName[MAX_PATH];
    TCHAR Buffer[MAX_PATH];
    TCHAR CmdLine[MAX_PATH*3];
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    SECURITY_ATTRIBUTES Security;
    UINT uiRes;
    //
    // create a mapped region of shared data
    //

    ZeroMemory(&Security,sizeof(Security));
    Security.nLength = sizeof(Security);
    Security.lpSecurityDescriptor = NULL; // default
    Security.bInheritHandle = TRUE;

    hMapping = CreateFileMapping(INVALID_HANDLE_VALUE,
                                 &Security,
                                 PAGE_READWRITE|SEC_COMMIT,
                                 0,
                                 sizeof(PROXY_DATA),
                                 NULL);
    if(hMapping == NULL) {
        Status = GetLastError();
        return HRESULT_FROM_WIN32(Status);
    }

    pData = MapViewOfFile(
                        hMapping,
                        FILE_MAP_ALL_ACCESS,
                        0,
                        0,
                        sizeof(PROXY_DATA)
                        );

    if(!pData) {
        Status = GetLastError();
        hrStatus = HRESULT_FROM_WIN32(Status);
        goto final;
    }
    ZeroMemory(pData,sizeof(PROXY_DATA));
    lstrcpyn(pData->InfPath,InfPath,MAX_PATH);
    lstrcpyn(pData->Media,Media,MAX_PATH);
    lstrcpyn(pData->Store,Store,MAX_PATH);
    pData->Flags = Flags;
    pData->hrStatus = E_UNEXPECTED;

    //
    // invoke the remote function
    //
    uiRes = GetSystemDirectory(ExecName,MAX_PATH);
    if(uiRes>=MAX_PATH) {
        hrStatus = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto final;
    }
    ConcatPath(ExecName,MAX_PATH,TEXT("rundll32.exe"));

    uiRes = GetModuleFileName(g_DllHandle,CmdLine,MAX_PATH);
    if(uiRes>=MAX_PATH) {
        hrStatus = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto final;
    }
    //
    // convert this to short name to ensure no spaces in path
    // (hacky)
    //
    uiRes = GetShortPathName(CmdLine,Buffer,MAX_PATH);
    if(uiRes>=MAX_PATH) {
        hrStatus = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto final;
    }
    //
    // now build up command line
    //
    lstrcpy(CmdLine,ExecName);
    lstrcat(CmdLine,TEXT(" "));
    lstrcat(CmdLine,Buffer);
    _stprintf(Buffer,TEXT(",ProxyRemoteInstall 0x%08x"),(ULONG_PTR)hMapping);
    lstrcat(CmdLine,Buffer);

    ZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    ZeroMemory(&ProcessInfo,sizeof(ProcessInfo));

    //
    // kick off rundll32 process to run our ProxyRemoteInstall entrypoint
    //
    if(!CreateProcess(ExecName,
                      CmdLine,
                      NULL,
                      NULL,
                      TRUE, // inherit handles
                      CREATE_NO_WINDOW,    // creation flags
                      NULL, // environment
                      NULL, // directory
                      &StartupInfo,
                      &ProcessInfo
                      )) {
        Status = GetLastError();
        hrStatus = HRESULT_FROM_WIN32(Status);
        goto final;
    }
    if(WaitForSingleObject(ProcessInfo.hProcess,INFINITE) == WAIT_OBJECT_0) {
        //
        // process terminated 'fine', retrieve status from shared data
        //
        hrStatus = pData->hrStatus;
    } else {
        //
        // failure
        //
        hrStatus = E_UNEXPECTED;
    }
    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);

final:
    if(pData) {
        UnmapViewOfFile(pData);
    }
    if(hMapping) {
        CloseHandle(hMapping);
    }
    return hrStatus;
}


VOID
ProxyRemoteInstallHandle(
    IN HANDLE    hShared
    )
/*++

Routine Description:

    Given a handle to a memory mapped file
    marshell all the parameters to invoke InstallExceptionPackFromInf
    and marshell result back

Arguments:

    hShared - handle to memory mapped file

Return Value:

    none, status returned via shared memory region

--*/
{
    PPROXY_DATA pData = NULL;

    try {

        //
        // Map the whole region
        //
        pData = MapViewOfFile(
                            hShared,
                            FILE_MAP_ALL_ACCESS,
                            0,
                            0,
                            sizeof(PROXY_DATA)
                            );

        if(pData) {
            pData->hrStatus = InstallExceptionPackFromInf(pData->InfPath,pData->Media,pData->Store,pData->Flags);
            UnmapViewOfFile(pData);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(pData) {
            UnmapViewOfFile(pData);
        }
    }
}


VOID
WINAPI
ProxyRemoteInstallW(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR    CommandLine,
    IN INT       ShowCommand
    )
/*++

Routine Description:

    Remote side of the proxy install process

Arguments:

    Window       - ignored
    ModuleHandle - ignored
    CommandLine  - "0xXXXX" - shared handle
    ShowCommand  - ignored

Return Value:

    none, status returned via shared memory region

--*/
{
    ULONG_PTR val = wcstol(CommandLine,NULL,0);
    ProxyRemoteInstallHandle((HANDLE)val);
}


VOID
WINAPI
ProxyRemoteInstallA(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR     CommandLine,
    IN INT       ShowCommand
    )
/*++

Routine Description:

    Remote side of the proxy install process

Arguments:

    Window       - ignored
    ModuleHandle - ignored
    CommandLine  - "0xXXXX" - shared handle
    ShowCommand  - ignored

Return Value:

    none, status returned via shared memory region

--*/
{
    ULONG_PTR val = strtol(CommandLine,NULL,0);
    ProxyRemoteInstallHandle((HANDLE)val);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\common.inl ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        common.inl

Abstract:

    Global functions (inlines) and global function templates

History:

    Created July 2001 - JamieHun

--*/

template<class T>
SafeString ConvertString(const T* arg)
/*++

Routine Description:

    Convert string pointer to SafeString
    (unnatural char type)

Arguments:
    arg - string to convert

Return Value:
    SafeString(arg)

--*/
{
    PCTSTR targ = CopyString(arg);
    SafeString final;
    if(targ) {
        final = targ;
        delete [] targ;
    }
    return final;
}

template<>
inline SafeString ConvertString<TCHAR>(const TCHAR * arg)
/*++

Routine Description:

    Convert string pointer to SafeString
    (natural char type override)

Arguments:
    arg - string to convert

Return Value:
    SafeString(arg)

--*/
{
    return arg;
}

//
// template/polymorphic stuff
//

inline
bool MyIsAlpha(CHAR c)
/*++

Routine Description:

    typed version of isalpha (ANSI)
    used by GetFileNamePart

Arguments:
    ANSI char

Return Value:
    true if it's alpha

--*/
{
    return isalpha(c) != 0;
}

inline
bool MyIsAlpha(WCHAR c)
/*++

Routine Description:

    typed version of isalpha (Unicode)
    used by GetFileNamePart

Arguments:
    Unicode char

Return Value:
    true if it's alpha

--*/
{
    return iswalpha(c) != 0;
}

inline
LPSTR MyCharNext(LPCSTR lpsz)
/*++

Routine Description:

    typed version of CharNext (Ansi)
    used by GetFileNamePart

Arguments:
    Ansi string pointer

Return Value:
    Ansi string pointer pointing to next char if prev char non-null

--*/
{
    return CharNextA(lpsz);
}

inline
LPWSTR MyCharNext(LPCWSTR lpsz)
/*++

Routine Description:

    typed version of CharNext (Unicode)
    used by GetFileNamePart

Arguments:
    Unicode string pointer

Return Value:
    Unicode string pointer pointing to next char if prev char non-null

--*/
{
    return CharNextW(lpsz);
}

template<class T>
T * GetFileNamePart(const T * path)
/*++

Routine Description:

    Template:
    PCWSTR/PCSTR/PCTSTR version
    Find basename.ext part of a full path
    written as template to work in both ansi and unicode form

Arguments:
    path - zero-terminated pathname

Return Value:
    pointer to the filename part

--*/
{
    const T * mark = path;
    const T * name = path;
    if(MyIsAlpha(*mark) && *MyCharNext(mark) == ':') {
        mark = MyCharNext(MyCharNext(mark));
        name = mark;
    }
    while(*mark) {
        if((*mark == '/') || (*mark == '\\')) {
            name = MyCharNext(mark);
        }
        mark = MyCharNext(mark);
    }

    return (T*)name;
}

template<class T>
SafeString_<T> GetFileNamePart(const SafeString_<T> & path)
/*++

Routine Description:

    Template:
    SafeStringX version of GetFileNamePart
    See GetFileNamePart above

Arguments:
    path - pathname

Return Value:
    filename part

--*/
{
    return GetFileNamePart(path.c_str());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\filters.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        filters.h

Abstract:

    Filter INF creation/parsing

History:

    Created July 2001 - JamieHun

--*/

#ifndef _INFSCAN_FILTERS_H_
#define _INFSCAN_FILTERS_H_

#define SECTION_FILEFILTERS    TEXT("FileFilters")
#define SECTION_ERRORFILTERS   TEXT("ErrorFilters")
#define SECTION_GUIDFILTERS    TEXT("GuidFilters")
#define SECTION_INSTALLS       TEXT("OtherInstallSections")

#define NULL_GUID               TEXT("{00000000-0000-0000-0000-000000000000}")
#define INVALID_GUID            TEXT("{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}")

#define WRITE_INF_HEADER       TEXT("[Version]\r\n") \
                               TEXT("Signature=\"$Windows NT$\"\r\n") \
                               TEXT("ClassGUID=") NULL_GUID TEXT("\r\n") \
                               TEXT("\r\n")

#define WRITE_DEVICES_TO_UPGRADE TEXT("[DevicesToUpgrade]\r\n")


#define FILEFILTERS_KEY_FILENAME      (0)
#define FILEFILTERS_FIELD_ACTION      (1)
#define FILEFILTERS_FIELD_SECTION     (2)
#define FILEFILTERS_FIELD_GUID        (3)

#define ERRORFILTERS_KEY_ERROR        (0)
#define ERRORFILTERS_FIELD_ACTION     (1)
#define ERRORFILTERS_FIELD_PARAM1     (2)

#define GUIDFILTERS_KEY_GUID          (0)
#define GUIDFILTERS_FIELD_ACTION      (1)
#define GUIDFILTERS_FIELD_SECTION     (2)

#define ACTION_DEFAULT     (0x00000000)
#define ACTION_IGNOREINF   (0x00000001)
#define ACTION_IGNOREMATCH (0x00000002)
#define ACTION_FAILINF     (0x00000004)
#define ACTION_EARLYLOAD   (0x00010000) // TODO, load this INF before others
#define ACTION_CHECKGUID   (0x00020000) // need to at least check GUID
#define ACTION_FAILEDMATCH (0x10000000)
#define ACTION_NOMATCH     (0x20000000)


#define REPORT_HASH_MOD      (2147483647)   // 2^31-1 (prime)
#define REPORT_HASH_CMULT    (0x00000003)
#define REPORT_HASH_SMULT    (0x00000007)

//
// STL uses compares for it's maps
// we can reduce the time order
// by maintaining a hash
// we compare hash first, and only if we have a match
// do we compare strings
//
// downside is we lose sorting
//
// we must follow rules that
// if (A>B) and !(A<B) then A==B
// and
// if (A>B) and (B>C) then A>C
//
// neat thing here is that we can make the HASH value as big as we want
// the bigger, the better
//

class GlobalScan;

class ReportEntry {
public:
    int FilterAction;
    StringList args;
    unsigned long hash;

public:
    ReportEntry();
    ReportEntry(const StringList & strings);
    ReportEntry(const ReportEntry & other);
    void Initialize(const StringList & strings);
    void Initialize(const ReportEntry & other);
    unsigned long GetHash() const;
    unsigned long CreateHash();
    int compare(const ReportEntry & other) const;
    bool operator<(const ReportEntry & other) const;
    void Report(int tag,const SafeString & file) const;
    void AppendFilterInformation(HANDLE filter,int tag);
};

class ReportEntryBlob : public blob<ReportEntry> {
public:
    bool operator<(const ReportEntryBlob & other) const;
};

class ReportEntrySet : public set<ReportEntryBlob> {
public:
    int FilterAction;

public:
    ReportEntrySet();
};
//
// and map this based on error tag
//
class ReportEntryMap : public map<int,ReportEntrySet> {
public:
    int FindReport(int tag,const ReportEntry & src,bool add = false);
    void LoadFromInfSection(HINF hInf,const SafeString & section);
};

//
// Per-inf filter management
//
class FileDisposition {
public:
    bool Filtered;              // true if obtained from Filter
    int FilterAction;           // what action to take for file
    SafeString FilterErrorSection; // where to look for processing errors
    SafeString FileGuid;           // what expected Guid is
    FileDisposition();
    FileDisposition(const FileDisposition & other);
    FileDisposition & operator = (const FileDisposition & other);
};

typedef map<SafeString,FileDisposition> FileDispositionMap;

#endif //!_INFSCAN_FILTERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\filters.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

For Internal use only!

Module Name:

    INFSCAN
        filters.cpp

Abstract:

    Filter processing implementation

History:

    Created July 2001 - JamieHun

--*/

#include "precomp.h"
#pragma hdrstop

int ReportEntryMap::FindReport(int tag,const ReportEntry & src,bool add)
/*++

Routine Description:

    Find a src entry for a given tag in ReportEntryMap
    If none exist but 'add' true, add the entry

Arguments:
    tag         - error tag (msg id)
    src         - ReportEntry to find/add
    add         - if true, add the entry

Return Value:
    effective filter action for report entry
    (retrieved from src if not found and add==true
        retrieved from matching entry if found
        if entry not found, or'd with ACTION_NOMATCH)

--*/
{
    iterator byTag = find(tag);
    if(byTag == end()) {
        //
        // this is the first time we've come across this numeric
        //
        if(!add) {
            return ACTION_NOMATCH;
        }
        ReportEntrySet s;
        if(!(src.FilterAction & (ACTION_FAILEDMATCH | ACTION_IGNOREMATCH))) {
            //
            // global flag
            //
            s.FilterAction = src.FilterAction;
            insert(ReportEntryMap::value_type(tag,s));
            return src.FilterAction | ACTION_NOMATCH;
        }
        ReportEntryBlob n;
        n.create();
        n->Initialize(src);
        s.insert(n); // add blob to set
        insert(ReportEntryMap::value_type(tag,s));
        return src.FilterAction | ACTION_NOMATCH;
    }
    ReportEntrySet &s = byTag->second;
    if(!(src.FilterAction & (ACTION_FAILEDMATCH | ACTION_IGNOREMATCH))) {
        return s.FilterAction;
    }
    if(s.FilterAction & ACTION_IGNOREINF) {
        return s.FilterAction;
    }
    ReportEntryBlob n;
    n.create();
    n->Initialize(src);
    ReportEntrySet::iterator byMatch = s.find(n);
    if(byMatch == s.end()) {
        //
        // this is the first time we've come across this report entry
        //
        if(!add) {
            return ACTION_NOMATCH;
        }
        s.insert(n); // add blob to set
        insert(ReportEntryMap::value_type(tag,s));
        return src.FilterAction | ACTION_NOMATCH;
    }
    n = *byMatch;
    if(n->FilterAction & ACTION_IGNOREMATCH) {
        //
        // we have a filter entry to ignore
        // can't overwrite
        //
        return n->FilterAction;
    }
    //
    // possibly have a global override to not ignore
    // or already marked as failed match
    //
    // only thing we can overwrite is ACTION_FAILEDMATCH
    //
    if(src.FilterAction & ACTION_FAILEDMATCH) {
        n->FilterAction |= ACTION_FAILEDMATCH;
    }
    return n->FilterAction;
}

void ReportEntryMap::LoadFromInfSection(HINF hInf,const SafeString & section)
/*++

Routine Description:

    pre-load tag table from INF filter

Arguments:
    hINF        - INF to load filter from
    section     - Section specifying filter

Return Value:
    NONE

--*/
{
    INFCONTEXT context;
    if(section.length() == 0) {
        return;
    }
    if(hInf == INVALID_HANDLE_VALUE) {
        return;
    }
    if(!SetupFindFirstLine(hInf,section.c_str(),NULL,&context)) {
        return;
    }
    do {
        SafeString field;
        int tag;
        ReportEntry ent;
        int f;
        //
        // retrieve tag and map to same range as messages
        //
        if(!SetupGetIntField(&context,0,&tag)) {
            continue;
        }
        tag = (tag%1000)+MSG_NULL;
        //
        // retrieve action
        //
        if(!SetupGetIntField(&context,1,&ent.FilterAction)) {
            ent.FilterAction = 0;
        }
        //
        // pull the filter strings case sensative
        // as we match case sensatively
        //
        for(f = 2;MyGetStringField(&context,f,field,false);f++) {
            ent.args.push_back(field);
        }
        ent.CreateHash();
        //
        // add this to our table
        //
        FindReport(tag,ent,true);

    } while (SetupFindNextLine(&context,&context));
}

void ReportEntry::Report(int tag,const SafeString & file) const
/*++

Routine Description:

    Generate a user-readable report

Arguments:
    tag         - MSG string to use
    file        - INF file that caused error

Return Value:
    NONE

--*/
{
    if(!(FilterAction&ACTION_FAILEDMATCH)) {
        //
        // filtered out error
        // not interesting
        //
    }
    TCHAR key[16];
    _stprintf(key,TEXT("#%03u "),(tag%1000));
    _fputts(key,stdout);
    _fputts(file.c_str(),stdout);
    _fputts(TEXT(" "),stdout);

    vector<DWORD_PTR> xargs;
    StringList::iterator c;
    for(c=args.begin();c!=args.end();c++) {
        xargs.push_back(reinterpret_cast<DWORD_PTR>(c->c_str()));
    }
    FormatToStream(stdout,tag,FORMAT_MESSAGE_ARGUMENT_ARRAY,static_cast<DWORD_PTR*>(&xargs.front()));
}

void ReportEntry::AppendFilterInformation(HANDLE filter,int tag)
/*++

Routine Description:

    Create an INF-line syntax for error

Arguments:
    filter      - handle to filter file to append to
    tag         - MSG ID

Return Value:
    NONE

--*/
{
    basic_ostringstream<TCHAR> line;

    line << dec << setfill(TEXT('0')) << setw(3) << (tag % 1000) << setfill(TEXT(' ')) << TEXT(" = ");
    line << TEXT("0x") << hex << ACTION_IGNOREMATCH;

    StringList::iterator c;
    for(c=args.begin();c!=args.end();c++) {
        line << TEXT(",") << QuoteIt(*c);
    }

    line << TEXT("\r\n");
    Write(filter,line.str());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\globalscan.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

For Internal use only!

Module Name:

    INFSCAN
        globalscan.cpp

Abstract:

    Global scanner class
    entry points GlobalScan::ParseArgs
    and          GlobalScan::Scan
    are called from main()

History:

    Created July 2001 - JamieHun

--*/

#include "precomp.h"
#pragma hdrstop

GlobalScan::GlobalScan()
/*++

Routine Description:

    Initialize class variables

--*/
{
    InfFilter = INVALID_HANDLE_VALUE;
    ThreadCount = 0;
    GeneratePnfs = false;
    GeneratePnfsOnly = false;
    Pedantic   = false;
    Trace      = false;
    IgnoreErrors = false;
    TargetsToo = false;
    DetermineCopySections = false;
    LimitedSourceDisksFiles = false;
    BuildChangedDevices = BUILD_CHANGED_DEVICES_DISABLED;
    SourceFileList = INVALID_HANDLE_VALUE;
    NewFilter = INVALID_HANDLE_VALUE;
    DeviceFilterList = INVALID_HANDLE_VALUE;
    NextJob = Jobs.end();
    SpecifiedNames = false;
}

GlobalScan::~GlobalScan()
/*++

Routine Description:

    Release any allocated data/files

--*/
{
    if(InfFilter != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(InfFilter);
    }
    if(SourceFileList != INVALID_HANDLE_VALUE) {
        CloseHandle(SourceFileList);
    }
    if(NewFilter != INVALID_HANDLE_VALUE) {
        CloseHandle(NewFilter);
    }
    if(DeviceFilterList != INVALID_HANDLE_VALUE) {
        CloseHandle(DeviceFilterList);
    }
}


int
GlobalScan::ParseVersion(LPCSTR ver)
/*++

Routine Description:

    Parse a version string into constituent parts

Arguments:
    ver         - version string as passed into argv[]

Return Value:
    0 on success

--*/
{
    //
    // <plat>.<maj>.<min>.<typ>.<suite>
    //
    PTSTR cpy = CopyString(ver);
    int res = Version.Parse(cpy);
    delete [] cpy;
    if(res == 4) {
        Usage();
        return 2;
    }
    return res;
}

int
GlobalScan::ParseArgs(int argc,char *argv[])
/*++

Routine Description:

    Parse command line parameters

Arguments:
    argc/argv as passed into main

Return Value:
    0 on success

--*/
{

    int i;
    int res;
    SafeString arg;

    for(i = 1; i < argc; i++) {

        if((argv[i][0] != TEXT('/')) && (argv[i][0] != TEXT('-'))) {
            break;
        }

        if(!argv[i][1] || (argv[i][2] && !isdigit(argv[i][2]))) {
            Usage();
            return 2;
        }

        switch(*(argv[i]+1)) {

            case 'B' :
            case 'b' :
                //
                // Take supplied textfile as list of "unchanged" build files
                // report a list of devices that use (copy) files that are not
                // part of this unchanged list
                //
                // SP build special
                // use in conjunction with /E
                //
                BuildChangedDevices = (DWORD)strtoul(argv[i]+2,NULL,0);
                if(!BuildChangedDevices) {
                    BuildChangedDevices = BUILD_CHANGED_DEVICES_DEFAULT;
                }
                BuildChangedDevices |= BUILD_CHANGED_DEVICES_ENABLED;
                i++;
                if(i == argc) {
                    Usage();
                    return 2;
                } else {
                    StringList list;
                    res = LoadListFromFile(SafeStringA(argv[i]),list);
                    if(res != 0) {
                        return res;
                    }
                    StringList::iterator li;
                    for(li = list.begin(); li != list.end(); li++) {
                        BuildUnchangedFiles.insert(*li);
                    }
                }
                break;

            case 'C' :
            case 'c' :
                //
                // Create Filter INF specified in the next argument
                //
                i++;

                if(i == argc) {
                    Usage();
                    return 2;
                }
                if(NewFilter == INVALID_HANDLE_VALUE) {
                    NewFilter = CreateFileA(argv[i],
                                                GENERIC_WRITE,
                                                0,
                                                NULL,
                                                CREATE_ALWAYS,
                                                FILE_ATTRIBUTE_NORMAL,
                                                NULL);
                    if(NewFilter == INVALID_HANDLE_VALUE) {
                        fprintf(stderr,"#*** Cannot open file \"%s\" for writing\n",argv[i]);
                        return 3;
                    }
                    Write(NewFilter,WRITE_INF_HEADER);
                }
                break;

            case 'D' :
            case 'd' :
                //
                // Determine other copy sections
                //
                DetermineCopySections = true;
                break;

            case 'E' :
            case 'e' :
                //
                // Create a list of device = inf
                //
                i++;

                if(i == argc) {
                    Usage();
                    return 2;
                }
                if(DeviceFilterList == INVALID_HANDLE_VALUE) {
                    DeviceFilterList = CreateFileA(argv[i],
                                                GENERIC_WRITE,
                                                0,
                                                NULL,
                                                CREATE_ALWAYS,
                                                FILE_ATTRIBUTE_NORMAL,
                                                NULL);
                    if(DeviceFilterList == INVALID_HANDLE_VALUE) {
                        fprintf(stderr,"#*** Cannot open file \"%s\" for writing\n",argv[i]);
                        return 3;
                    }
                }
                break;

            case 'F' :
            case 'f' :
                //
                // Filter the list based on the INF in the next argument
                //
                i++;

                if(i == argc) {
                    Usage();
                    return 2;
                }
                FilterPath = ConvertString(argv[i]);
                break;

            case 'G':
            case 'g':
                //
                // generate PNF's (see also Z)
                //
                GeneratePnfs = true;
                break;

            case 'H' :
            case 'h' :
            case '?' :
                //
                // Display usage help
                //
                Usage();
                return 1;

            case 'I' :
            case 'i' :
                //
                // ignore
                //
                IgnoreErrors = true;
                break;

            case 'N' :
            case 'n' :
                //
                // named file
                //
                i++;

                if(i == argc) {
                    Usage();
                    return 2;
                }
                SpecifiedNames = true;
                _strlwr(argv[i]);
                arg = ConvertString(argv[i]);
                if(ExcludeInfs.find(arg) == ExcludeInfs.end()) {
                    NamedInfList.push_back(arg);
                    //
                    // make sure it appears only once
                    //
                    ExcludeInfs.insert(arg);
                }
                break;

            case 'O' :
            case 'o' :
                //
                // override path (if an INF is in this (relative) location,
                // it's used instead
                // multiple overrides can be given
                // "/O ." is always assumed to be last unless explicitly given
                //
                i++;

                if(i == argc) {
                    Usage();
                    return 2;
                }
                arg = ConvertString(argv[i]);
                Overrides.push_back(arg);
                break;

            case 'P' :
            case 'p' :
                //
                // pedantic mode - INF's must match expectations in filter
                //
                Pedantic = true;
                break;

            case 'Q' :
            case 'q' :
                //
                // output source+target files (used in conjunction with /S
                //
                i++;

                if(i == argc) {
                    Usage();
                    return 2;
                }
                if(SourceFileList == INVALID_HANDLE_VALUE) {
                    TargetsToo = true;
                    SourceFileList = CreateFileA(argv[i],
                                                GENERIC_WRITE,
                                                0,
                                                NULL,
                                                CREATE_ALWAYS,
                                                FILE_ATTRIBUTE_NORMAL,
                                                NULL);
                    if(SourceFileList == INVALID_HANDLE_VALUE) {
                        fprintf(stderr,"#*** Cannot open file \"%s\" for writing\n",argv[i]);
                        return 3;
                    }
                }
                break;


            case 'R' :
            case 'r' :
                //
                // trace
                //
                Trace = true;
                break;

            case 'S' :
            case 's' :
                //
                // output source file
                //
                i++;

                if(i == argc) {
                    Usage();
                    return 2;
                }
                if(SourceFileList == INVALID_HANDLE_VALUE) {
                    SourceFileList = CreateFileA(argv[i],
                                                GENERIC_WRITE,
                                                0,
                                                NULL,
                                                CREATE_ALWAYS,
                                                FILE_ATTRIBUTE_NORMAL,
                                                NULL);
                    if(SourceFileList == INVALID_HANDLE_VALUE) {
                        fprintf(stderr,"#*** Cannot open file \"%s\" for writing\n",argv[i]);
                        return 3;
                    }
                }
                break;


            case 'T':
            case 't':
                //
                // specify number of threads
                //
                i++;

                if(i == argc) {
                    Usage();
                    return 2;
                }
                ThreadCount = atoi(argv[i]);
                break;

            case 'V' :
            case 'v' :
                //
                // version
                //
                i++;

                if(i == argc) {
                    Usage();
                    return 2;
                }
                res = ParseVersion(argv[i]);
                if(res != 0) {
                    return res;
                }
                break;

            case 'W' :
            case 'w' :
                //
                // include, alternative to 'N'
                //
                i++;
                if(i == argc) {
                    Usage();
                    return 2;
                } else {
                    SpecifiedNames = true;

                    StringList list;
                    res = LoadListFromFile(SafeStringA(argv[i]),list);
                    if(res != 0) {
                        return res;
                    }
                    StringList::iterator li;
                    for(li = list.begin(); li != list.end(); li++) {
                        if(ExcludeInfs.find(*li) == ExcludeInfs.end()) {
                            NamedInfList.push_back(*li);
                            //
                            // insert only once
                            // stop a 2nd/subsequent insert
                            //
                            ExcludeInfs.insert(*li);
                        }
                    }
                }
                break;

            case 'X' :
            case 'x' :
                //
                // exclude, mask out future files added to list
                //
                i++;
                if(i == argc) {
                    Usage();
                    return 2;
                } else {
                    StringList list;
                    res = LoadListFromFile(SafeStringA(argv[i]),list);
                    if(res != 0) {
                        return res;
                    }
                    StringList::iterator li;
                    for(li = list.begin(); li != list.end(); li++) {
                        ExcludeInfs.insert(*li);
                    }
                }
                break;


            case 'Y':
            case 'y':
                LimitedSourceDisksFiles = true;
                break;

            case 'Z':
            case 'z':
                //
                // generate PNF's only
                //
                GeneratePnfs = true;
                GeneratePnfsOnly = true;
                break;

            default:
                //
                // Display usage help
                //
                Usage();
                return 2;
        }
    }

    if(i < argc) {
        SourcePath = ConvertString(argv[i]);
        i++;
    }
    if(i != argc) {
        Usage();
        return 2;
    }

    return 0;
}

int
GlobalScan::Scan()
/*++

Routine Description:

    Do the actual scanning

Arguments:
    none

Return Value:
    0 on success

--*/
{
    int res;
    StringList ParseInfList;
    StringList LayoutInfList;

    if(Trace) {
        _ftprintf(stderr,TEXT("#### Obtaining list of INF files\n"));
    }
    Overrides.push_back(TEXT("."));
    if (!SpecifiedNames) {
        //
        // enumerate all the INF's if none were explicitly mentioned
        //
        StringList::iterator dir;
        for (dir = Overrides.begin(); dir != Overrides.end(); dir++) {
            //
            // for each directory
            //
            WIN32_FIND_DATA findData;
            HANDLE findHandle;

            ZeroMemory(&findData,sizeof(findData));
            SafeString mask;
            res = ExpandFullPath(*dir,TEXT("*.INF"),mask);
            if(res != 0) {
                return res;
            }
            if(Trace) {
                _ftprintf(stderr,TEXT("####    Scanning %s\n"),mask.c_str());
            }
            findHandle = FindFirstFile(mask.c_str(),&findData);

            if(findHandle == INVALID_HANDLE_VALUE) {
                continue;
            }

            do {
                if(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    continue;
                }
                if(findData.nFileSizeHigh != 0) {
                    continue;
                }
                if(findData.nFileSizeLow == 0) {
                    continue;
                }
                _tcslwr(findData.cFileName);
                SafeString name = findData.cFileName; // saves lots of automatics
                if(ExcludeInfs.find(name) != ExcludeInfs.end()) {
                    //
                    // not allowed to process an INF with this name
                    // (previously obtained or specifically excluded)
                    //
                    continue;
                }
                //
                // make a note of the filename so we effectively override it
                //
                ExcludeInfs.insert(name);
                //
                // make the final name
                //
                SafeString fullname;
                res = ExpandFullPath(*dir,name,fullname);
                if(res != 0) {
                    return res;
                }
                if(name.compare(TEXT("layout.inf")) == 0) {
                    //
                    // looks like a (the) layout file
                    // these are parsed ahead of other INF's
                    //
                    LayoutInfList.push_back(fullname);
                } else {
                    ParseInfList.push_back(fullname);
                }

            } while (FindNextFile(findHandle,&findData));
            FindClose(findHandle);
        }
    } else {
        //
        // INF's were manually specified, find where they are located
        //
        StringList::iterator name;
        StringList::iterator dir;
        for(name = NamedInfList.begin(); name != NamedInfList.end(); name++) {
            SafeString fullname;
            res = ExpandFullPathWithOverride(*name,fullname);
            if(res != 0) {
                return res;
            }
            if(_tcsicmp(GetFileNamePart(name->c_str()),TEXT("layout.inf"))==0) {
                //
                // looks lie a layout file
                // parse ahead of other INF's
                //
                LayoutInfList.push_back(fullname);
            } else {
                ParseInfList.push_back(fullname);
            }
        }
    }

    if(ParseInfList.empty() && LayoutInfList.empty()) {
        _ftprintf(stderr,TEXT("#*** No files\n"));
        return 1;
    }

    if(FilterPath.length() && !GeneratePnfsOnly) {
        GetFullPathName(FilterPath,FilterPath);
        InfFilter = SetupOpenInfFile(FilterPath.c_str(),NULL,INF_STYLE_WIN4,NULL);
        if(InfFilter == INVALID_HANDLE_VALUE) {
            _ftprintf(stderr,TEXT("#*** Cannot open filter\n"));
            return 3;
        }
        if(Trace) {
            _ftprintf(stderr,TEXT("#### Loading filter %s\n"),FilterPath.c_str());
        }
        LoadFileDispositions();
        LoadOtherCopySections();
    }
    if((NewFilter == INVALID_HANDLE_VALUE) && !DetermineCopySections) {
        FileDisposition & disp = GetGuidDisposition(NULL_GUID);
        if(!disp.Filtered) {
            //
            // default disposition for NULL guid's
            //
            disp.FilterAction = ACTION_IGNOREINF;
        }
    }

    StringList::iterator i;

    if(GeneratePnfsOnly) {
        //
        // do nothing special with layout files because all we'll be doing
        // is generating PNF's
        // so merge them into ParseInfList
        //
        for(i = LayoutInfList.begin(); i != LayoutInfList.end() ; i++) {
            ParseInfList.push_back(*i);
        }

    } else {
        if(Trace) {
            _ftprintf(stderr,TEXT("#### Scanning Layout.Inf file(s) sequentially\n"));
        }
        for(i = LayoutInfList.begin(); i != LayoutInfList.end() ; i++) {
            SafeString &full_inf = *i;

            if(GeneratePnfs) {
                GeneratePnf(full_inf);
            }
            //
            // this stuff has to be done sequentially
            //

            GetFileDisposition(full_inf).FilterAction |= ACTION_EARLYLOAD; // override

            InfScan *pInfScan = new InfScan(this,full_inf); // may throw bad_alloc
            SerialJobs.push_back(pInfScan);
            pInfScan->ThisIsLayoutInf = true;
            res = pInfScan->Run();
            if(res == 0) {
                //
                // parse [SourceDisksFiles*]
                //
                pInfScan->PrimaryInf->Locked = true;
                LayoutInfs.push_back(pInfScan->PrimaryInf);
                if(pInfScan->PrimaryInf->LooksLikeLayoutInf) {
                    //
                    // parse [WinntDirectories]
                    // (only makes sense if layout.inf extended syntax detected)
                    //
                    res = pInfScan->PrimaryInf->LoadWinntDirectories(GlobalDirectories);
                }
                if(NewFilter != INVALID_HANDLE_VALUE) {
                    //
                    // ensure we indicate this INF should always be processed
                    // at some point we can handle this flag specially
                    //
                    GetFileDisposition(full_inf).FilterAction |= ACTION_EARLYLOAD;
                }
            }
            pInfScan->PartialCleanup();
            if(res != 0) {
                return res;
            }
        }
    }

    if(GeneratePnfs) {
        //
        // process Pnf's either now
        // or add them to Job list
        //
        if(Trace) {
            if(ThreadCount) {
                _ftprintf(stderr,TEXT("#### Adding Pnf generation Jobs\n"));
            } else {
                _ftprintf(stderr,TEXT("#### Generating Pnf's sequentially\n"));
            }
        }

        for(i = ParseInfList.begin(); i != ParseInfList.end() ; i++) {
            SafeString &full_inf = *i;

            if(ThreadCount) {
                //
                // add to job list
                //
                PnfGen *pJob = new PnfGen(full_inf); // may throw bad_alloc
                Jobs.push_back(pJob);
            } else {
                //
                // do now
                //
                GeneratePnf(full_inf);
            }
        }
        //
        // limit threads to # of INF's
        //
        if(Jobs.size() < ThreadCount) {
            ThreadCount = Jobs.size();
        }
    }
    if(!GeneratePnfsOnly) {
        //
        // process Inf's either now or queue for job processing
        //
        if(Trace) {
            if(ThreadCount) {
                _ftprintf(stderr,TEXT("#### Adding Inf scanning Jobs\n"));
            } else {
                _ftprintf(stderr,TEXT("#### Scanning Inf's sequentially\n"));
            }
        }

        for(i = ParseInfList.begin(); i != ParseInfList.end() ; i++) {
            SafeString &full_inf = *i;

            InfScan *pJob = new InfScan(this,full_inf); // may throw bad_alloc
            if(ThreadCount) {
                //
                // add to job list
                //
                Jobs.push_back(pJob);
            } else {
                //
                // do now
                //
                SerialJobs.push_back(pJob);

                res = pJob->Run();
                pJob->PartialCleanup();
                if(res != 0) {
                    return res;
                }
            }
        }
    }

    if(ThreadCount) {
        //
        // use worker threads
        //
        // see if #jobs > #threads
        //
        if(Jobs.size() < ThreadCount) {
            ThreadCount = Jobs.size();
        }
        if(Trace) {
            _ftprintf(stderr,TEXT("#### Spinning %u threads\n"),ThreadCount);
        }
        //
        // generate the thread objects
        //
        res = GenerateThreads();
        if(res != 0) {
            return res;
        }
        //
        // start the threads
        // they will start picking up the jobs
        //
        if(Trace) {
            _ftprintf(stderr,TEXT("#### Starting threads\n"));
        }
        res = StartThreads();
        if(res != 0) {
            return res;
        }
        //
        // wait for all threads to finish
        //
        if(Trace) {
            _ftprintf(stderr,TEXT("#### Waiting for Jobs to finish\n"));
        }
        res = FinishThreads();
        if(res != 0) {
            return res;
        }
    }
    //
    // merge any results
    //
    if(Trace) {
        _ftprintf(stderr,TEXT("#### Merge results\n"));
    }
    res = FinishJobs();
    if(res != 0) {
        return res;
    }

    if(GeneratePnfsOnly) {
        return 0;
    }

    //
    // post operations
    //

    if(res == 0) {
        res = BuildNewInfFilter();
    }
    if(res == 0) {
        res = BuildDeviceInfMap();
    }
    if(res == 0) {
        res = BuildFinalSourceList();
    }
    if(Trace) {
        _ftprintf(stderr,TEXT("#### Finish\n"));
    }

    return res;

}

int
GlobalScan::GenerateThreads()
/*++

Routine Description:

    Create required number of Job threads
    Threads are initially stopped

Arguments:
    none

Return Value:
    0 on success

--*/
{
    int c;
    for(c=0; c< ThreadCount;c++) {
        JobThreads.push_back(JobThread(this));
    }
    return 0;
}

int
GlobalScan::StartThreads()
/*++

Routine Description:

    Kick off the job threads to start processing the jobs

Arguments:
    none

Return Value:
    0 on success

--*/
{
    //
    // this is the first job in the list
    //
    NextJob = Jobs.begin();

    //
    // now kick off the threads to start looking for
    // and processing jobs
    //
    JobThreadList::iterator i;
    for(i = JobThreads.begin(); i != JobThreads.end(); i++) {
        if(!i->Begin()) {
            _ftprintf(stderr,TEXT("#*** Could not start thread\n"));
            return 3;
        }
    }
    return 0;
}

int
GlobalScan::FinishThreads()
/*++

Routine Description:

    Wait for all job threads to finish

Arguments:
    none

Return Value:
    0 on success

--*/
{
    JobThreadList::iterator i;
    for(i = JobThreads.begin(); i != JobThreads.end(); i++) {
        int res = (int)(i->Wait());
        if(res != 0) {
            return res;
        }
    }
    return 0;
}

int
GlobalScan::FinishJobs()
/*++

Routine Description:

    Do finish processing on each job sequentially
    this includes any serialized jobs

Arguments:
    none

Return Value:
    0 on success

--*/
{
    JobList::iterator i;
    //
    // two passes
    // first PreResults to do any final prep's
    //
    for(i = SerialJobs.begin(); i != SerialJobs.end(); i++) {
        int res = i->PreResults();
        if(res != 0) {
            return res;
        }
    }
    for(i = Jobs.begin(); i != Jobs.end(); i++) {
        int res = i->PreResults();
        if(res != 0) {
            return res;
        }
    }
    //
    // now actual Results phase
    //
    for(i = SerialJobs.begin(); i != SerialJobs.end(); i++) {
        int res = i->Results();
        if(res != 0) {
            return res;
        }
    }
    for(i = Jobs.begin(); i != Jobs.end(); i++) {
        int res = i->Results();
        if(res != 0) {
            return res;
        }
    }
    return 0;
}

int
GlobalScan::ExpandFullPath(const SafeString & subdir,const SafeString & name,SafeString & target)
/*++

Routine Description:

    Expand full path taking into account specified SourcePath

Arguments:
    subdir - subdirectory of SourcePath if not ""
    name   - filename (may be wildcard and may include a subdirectory)
    target - generated full path name

Return Value:
    0

--*/
{
    SafeString given = PathConcat(SourcePath,PathConcat(subdir,name));
    GetFullPathName(given,target);
    return 0;
}

int
GlobalScan::ExpandFullPathWithOverride(const SafeString & name,SafeString & target)
/*++

Routine Description:

    Expand full path taking into account Overrides
    look for each SourcePath\<override>\name
    and take first found converting it into full path

Arguments:
    name   - filename (may include a subdirectory)
    target - generated full path name

Return Value:
    0

--*/
{
    StringList::iterator dir;
    int res;
    for(dir = Overrides.begin(); dir != Overrides.end(); dir++) {
        res = ExpandFullPath(*dir,name,target);
        if(res != 0) {
            return res;
        }
        DWORD attr = GetFileAttributes(target.c_str());
        if((attr == (DWORD)(-1)) || (attr & FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // the named file doesn't exist in this particular
            // override directory
            //
            continue;
        }
        //
        // we found an override match
        //
        return 0;
    }
    //
    // since the last overrides entry is ".", just return
    // last generated name
    //
    return 0;
}

int GlobalScan::SaveForCrossInfInstallCheck(const SafeString & desc,const SafeString & src)
/*++

Routine Description:

    Not thread safe, called during PreResults

    Save description->src mapping
    for later call to CheckCrossInfInstallCheck
    (we can't do the check here else we'd randomly pick one inf over another
    to report the conflict and we want to fail both inf's)

Arguments:
    desc   - lower-case device description
    src    - full name of INF currently being checked

Return Value:
    0

--*/
{
    StringToStringset::iterator i;
    i = GlobalInfDescriptions.find(desc);
    if(i == GlobalInfDescriptions.end()) {
        //
        // description doesn't exist
        // create a new entry desc->src
        //
        StringSet s;
        s.insert(src);
        GlobalInfDescriptions.insert(StringToStringset::value_type(desc,s));
    } else {
        //
        // description exists
        // add this src (if it doesn't already exist)
        //
        i->second.insert(src);
    }
    return 0;
}

int GlobalScan::SaveForCrossInfDeviceCheck(const SafeString & hwid,const SafeString & src)
/*++

Routine Description:

    Not thread safe, called during PreResults

    Save hwid->src mapping
    for later call to CheckCrossInfInstallCheck
    (we can't do the check here else we'd randomly pick one inf over another
    to report the conflict and we want to fail both inf's)

Arguments:
    hwid   - lower-case hardware ID
    src    - full name of INF currently being checked

Return Value:
    0

--*/
{
    StringToStringset::iterator i;
    i = GlobalInfHardwareIds.find(hwid);
    if(i == GlobalInfHardwareIds.end()) {
        //
        // hwid doesn't exist
        // create a new entry desc->src
        //
        StringSet s;
        s.insert(src);
        GlobalInfHardwareIds.insert(StringToStringset::value_type(hwid,s));
    } else {
        //
        // hwid exists
        // add this src (if it doesn't already exist)
        //
        i->second.insert(src);
    }
    return 0;
}

int
GlobalScan::CheckCrossInfInstallConflict(const SafeString & desc,const SafeString & src, bool & f,SafeString & others)
/*++

Routine Description:

    Not thread safe, called during PreResults

    given a "description"
    return f=true if found in some INF other than 'src'
    return f=false if not found (INF added)

Arguments:
    desc   - lower-case device description
    src    - full name of INF currently being checked
    f      - return true if exists in another inf
    others - descriptive list of conflicting INF's

Return Value:
    0

--*/
{
    f = false;

    StringToStringset::iterator i;
    i = GlobalInfDescriptions.find(desc);
    if(i == GlobalInfDescriptions.end()) {
        //
        // shouldn't happen, but do right thing
        //
        return 0;
    }
    StringSet & s = i->second;
    StringSet::iterator ii;

    //
    // report any conflicts other than self
    //
    for(ii = s.begin(); ii != s.end(); ii++) {
        SafeString & str = *ii;
        if(str == src) {
            continue;
        }
        if(f) {
            others += TEXT(" & ") + str;
        } else {
            f = true;
            others = str;
        }
    }
    return 0;
}

int
GlobalScan::CheckCrossInfDeviceConflict(const SafeString & hwid,const SafeString & src, bool & f,SafeString & others)
/*++

Routine Description:

    Not thread safe, called during PreResults

    given a "hardwareId"
    return f=true if found in some INF other than 'src'
    return f=false if not found (INF added)

Arguments:
    hwid   - lower-case hardware ID
    src    - full name of INF currently being checked
    f      - return true if exists in another inf
    others - descriptive list of conflicting INF's

Return Value:
    0

--*/
{
    f = false;

    StringToStringset::iterator i;
    i = GlobalInfHardwareIds.find(hwid);
    if(i == GlobalInfHardwareIds.end()) {
        //
        // shouldn't happen, but do right thing
        //
        return 0;
    }
    StringSet & s = i->second;
    StringSet::iterator ii;

    //
    // report any conflicts other than self
    //
    for(ii = s.begin(); ii != s.end(); ii++) {
        SafeString & str = *ii;
        if(str == src) {
            continue;
        }
        if(f) {
            others += TEXT(" & ") + str;
        } else {
            f = true;
            others = str;
        }
    }
    return 0;
}

int GlobalScan::AddSourceFiles(StringList & sources)
/*++

Routine Description:

    Add the list 'sources' to the known set of source files

Arguments:
    sources - list of source files to add

Return Value:
    0

--*/
{
    if(SourceFileList != INVALID_HANDLE_VALUE) {
        StringList::iterator i;
        for(i = sources.begin(); i != sources.end(); i++) {
            GlobalFileSet.insert(*i);
        }
    }
    return 0;
}

JobEntry * GlobalScan::GetNextJob()
/*++

Routine Description:

    Get next job safely

Arguments:
    none

Return Value:
    next job or NULL

--*/
{
    ProtectedSection ThisSectionIsA(BottleNeck);

    if(NextJob == Jobs.end()) {
        return NULL;
    }
    JobEntry * Job = &*NextJob;
    NextJob++;
    return Job;
}

int GlobalScan::LoadFileDispositions()
/*++

Routine Description:

    Load global error dispositions from filter
    Load file/guid top-level dispositions
        (actual error tables for these are loaded on demand)

Arguments:
    none

Return Value:
    0 on success

--*/
{
    //
    // load filter tables
    //
    int res;
    INFCONTEXT filterContext;

    if(InfFilter == INVALID_HANDLE_VALUE) {
        return 0;
    }
    //
    // load top-level filter table
    //
    if(SetupFindFirstLine(InfFilter,SECTION_FILEFILTERS,NULL,&filterContext)) {
        do {
            SafeString filename;
            FileDisposition disp;
            if(!MyGetStringField(&filterContext,FILEFILTERS_KEY_FILENAME,filename)) {
                continue;
            }
            if(FileDispositions.find(filename) != FileDispositions.end()) {
                continue;
            }
            if(!SetupGetIntField(&filterContext,FILEFILTERS_FIELD_ACTION,&disp.FilterAction)) {
                disp.FilterAction = ACTION_DEFAULT;
            }
            MyGetStringField(&filterContext,FILEFILTERS_FIELD_SECTION,disp.FilterErrorSection);
            MyGetStringField(&filterContext,FILEFILTERS_FIELD_GUID,disp.FileGuid);
            disp.Filtered = true;
            FileDispositions.insert(FileDispositionMap::value_type(filename,disp));

        } while (SetupFindNextLine(&filterContext,&filterContext));
    }
    if(SetupFindFirstLine(InfFilter,SECTION_GUIDFILTERS,NULL,&filterContext)) {
        do {
            SafeString guid;
            FileDisposition disp;
            if(!MyGetStringField(&filterContext,GUIDFILTERS_KEY_GUID,guid)) {
                continue;
            }
            if(GuidDispositions.find(guid) != GuidDispositions.end()) {
                continue;
            }
            if(!SetupGetIntField(&filterContext,GUIDFILTERS_FIELD_ACTION,&disp.FilterAction)) {
                disp.FilterAction = ACTION_DEFAULT;
            }
            MyGetStringField(&filterContext,GUIDFILTERS_FIELD_SECTION,disp.FilterErrorSection);
            disp.Filtered = true;
            GuidDispositions.insert(FileDispositionMap::value_type(guid,disp));

        } while (SetupFindNextLine(&filterContext,&filterContext));
    }

    //
    // preload global error table
    //
    GlobalErrorFilters.LoadFromInfSection(InfFilter,SECTION_ERRORFILTERS);
    return 0;
}

int GlobalScan::LoadOtherCopySections()
/*++

Routine Description:

    Load copy filters
    Load file/guid top-level dispositions
        (actual error tables for these are loaded on demand)

Arguments:
    none

Return Value:
    0 on success

--*/
{
    //
    // load filter tables
    //
    int res;
    INFCONTEXT filterContext;

    if(InfFilter == INVALID_HANDLE_VALUE) {
        return 0;
    }
    //
    // load top-level filter table
    //
    if(SetupFindFirstLine(InfFilter,SECTION_INSTALLS,NULL,&filterContext)) {
        //
        // file = install[,install....]
        //
        do {
            SafeString filename;
            SafeString section;
            int c;
            if(!MyGetStringField(&filterContext,0,filename)) {
                continue;
            }
            StringSet & sects = GlobalOtherInstallSections[filename];
            for(c=1; MyGetStringField(&filterContext,c,section);c++) {
                sects.insert(section);
            }
        } while(SetupFindNextLine(&filterContext,&filterContext));
    }

    return 0;

}

int GlobalScan::GetCopySections(const SafeString & filename,StringSet & target)
/*++

Routine Description:

    Return cached list of copy sections from filter

Arguments:
    filename (without path)
    target - merged with list of install sections

Return Value:
    0 = success

--*/
{
    StringToStringset::iterator i;
    i = GlobalOtherInstallSections.find(filename);
    if(i == GlobalOtherInstallSections.end()) {
        return 0;
    }
    StringSet & sects = i->second;
    StringSet::iterator ii;
    for(ii = sects.begin(); ii != sects.end(); ii++) {
        target.insert(*ii);
    }
    return 0;
}

int GlobalScan::SetCopySections(const SafeString & filename,const StringSet & sections)
/*++

Routine Description:

    Not thread safe
    upgrade global table with extra copy sections

Arguments:
    filename (without path)
    sections - list of install sections to merge in

Return Value:
    0 = success

--*/
{
    StringSet::iterator i;
    StringSet & sects = GlobalOtherInstallSections[filename];
    for(i = sections.begin(); i != sections.end(); i++) {
        sects.insert(*i);
    }
    return 0;
}

FileDisposition & GlobalScan::GetFileDisposition(const SafeString & pathname)
/*++

Routine Description:

    Return a file disposition entry for specified file
    Note that the returned structure may be modified
    However the table itself is shared

Arguments:
    full path or filename

Return Value:
    modifiable entry

--*/
{
    //
    // assume filename is lower-case
    // we need to get just the actual name
    //
    SafeString filename = GetFileNamePart(pathname);
    FileDispositionMap::iterator i;

    ProtectedSection ThisSectionIsA(BottleNeck);

    i = FileDispositions.find(filename);
    if(i == FileDispositions.end()) {
        //
        // create and return
        //
        return FileDispositions[filename];
    }
    return i->second;
}

FileDisposition & GlobalScan::GetGuidDisposition(const SafeString & guid)
/*++

Routine Description:

    Return a guid disposition entry for specified guid
    Note that the returned structure may be modified
    However the table itself is shared

Arguments:
    full guid {...}

Return Value:
    modifiable entry

--*/
{
    FileDispositionMap::iterator i;
    //
    // assume guid-string is lower-case
    //
    ProtectedSection ThisSectionIsA(BottleNeck);

    i = GuidDispositions.find(guid);
    if(i == GuidDispositions.end()) {
        //
        // create and return
        //
        return GuidDispositions[guid];
    }
    return i->second;
}

int GlobalScan::BuildFinalSourceList()
/*++

Routine Description:

    If requested, build a complete list of source files

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    if(SourceFileList == INVALID_HANDLE_VALUE) {
        return 0;
    }
    if(Trace) {
        _ftprintf(stderr,TEXT("#### Build source list\n"));
    }
    StringSet::iterator i;
    for(i = GlobalFileSet.begin(); i != GlobalFileSet.end(); i++) {
        Write(SourceFileList,*i);
        Write(SourceFileList,"\r\n");
    }
    return 0;
}

int GlobalScan::BuildNewInfFilter()
/*++

Routine Description:

    If requested, complete a filter INF

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    if(NewFilter == INVALID_HANDLE_VALUE) {
        return 0;
    }
    if(Trace) {
        _ftprintf(stderr,TEXT("#### Build filter\n"));
    }
    FileDispositionMap::iterator i;
    //
    // File Dispositions table
    //
    Write(NewFilter,TEXT("\r\n[") SECTION_FILEFILTERS TEXT("]\r\n"));
    for(i = FileDispositions.begin(); i != FileDispositions.end(); i++) {
        if(i->second.Filtered) {
            basic_ostringstream<TCHAR> line;
            line << QuoteIt(i->first) << TEXT(" = ");
            line << TEXT("0x") << setfill(TEXT('0')) << setw(8) << hex << i->second.FilterAction << setfill(TEXT(' ')) << TEXT(",");
            line << QuoteIt(i->second.FilterErrorSection) << TEXT(",");
            line << QuoteIt(i->second.FileGuid);
            line << TEXT("\r\n");
            Write(NewFilter,line.str());
        }
    }
    //
    // Guid Dispositions
    //
    Write(NewFilter,TEXT("\r\n[") SECTION_GUIDFILTERS TEXT("]\r\n"));
    for(i = GuidDispositions.begin(); i != GuidDispositions.end(); i++) {
        if(i->second.Filtered) {
            basic_ostringstream<TCHAR> line;
            line << QuoteIt(i->first) << TEXT(" = ");
            line << TEXT("0x") << setfill(TEXT('0')) << setw(8)  << hex << i->second.FilterAction << setfill(TEXT(' ')) << TEXT("\r\n");
            Write(NewFilter,line.str());
        }
    }
    //
    // other copy sections
    //
    if(GlobalOtherInstallSections.size()) {
        Write(NewFilter,TEXT("\r\n[") SECTION_INSTALLS TEXT("]\r\n"));
        StringToStringset::iterator s;
        for(s = GlobalOtherInstallSections.begin(); s != GlobalOtherInstallSections.end(); s++) {
            StringSet & sects = s->second;
            StringSet::iterator ss;
            for(ss = sects.begin(); ss != sects.end(); ss++) {
                basic_ostringstream<TCHAR> line;
                line << QuoteIt(s->first) << TEXT(" = ");
                line << QuoteIt(*ss) << TEXT("\r\n");
                Write(NewFilter,line.str());
            }
        }
    }


    return 0;
}


bool GlobalScan::IsFileChanged(const SafeString & file) const
{
    SafeString fnp = GetFileNamePart(file);
    //
    // appears to have changed
    //
    return BuildUnchangedFiles.find(fnp) == BuildUnchangedFiles.end();
}

int GlobalScan::BuildDeviceInfMap()
/*++

Routine Description:

    Create a list of "hardwareId" = "file"
    to DeviceFilterList

Return Value:
    0

--*/
{
    if(DeviceFilterList == INVALID_HANDLE_VALUE) {
        return 0;
    }
    StringToStringset::iterator i;
    for(i = GlobalInfHardwareIds.begin(); i != GlobalInfHardwareIds.end(); i++) {
        const SafeString &hwid = i->first;
        StringSet &s = i->second;
        Write(DeviceFilterList,QuoteIt(hwid));

        bool f = false;
        StringSet::iterator ii;

        //
        // report all INF's hwid appears in
        //
        for(ii = s.begin(); ii != s.end(); ii++) {
            SafeString & str = *ii;

            if(f) {
                Write(DeviceFilterList,",");
            } else {
                Write(DeviceFilterList," = ");
                f = true;
            }
            Write(DeviceFilterList,QuoteIt(*ii));
        }

        Write(DeviceFilterList,"\r\n");

    }
    return 0;

}


int GlobalScan::LoadListFromFile(const SafeStringA & file,StringList & list)
/*++

Routine Description:

    Load a list of strings from a text file (ANSI filename)

    file - name of file to load
    list - returned list of strings

Return Value:
    0

--*/
{
    HANDLE hFile = CreateFileA(file.c_str(),
                                    GENERIC_READ,
                                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
    if(hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr,"#*** Cannot open file \"%s\" for reading\n",file.c_str());
        return 3;
    }
    int res = LoadListFromFile(hFile,list);
    CloseHandle(hFile);
    if(res!=0) {
        fprintf(stderr,"#*** Failure reading file \"%s\"\n",file.c_str());
    }
    return res;
}

int GlobalScan::LoadListFromFile(const SafeStringW & file,StringList & list)
/*++

Routine Description:

    Load a list of strings from a text file (Unicode filename)

    file - name of file to load
    list - returned list of strings

Return Value:
    0

--*/
{
    HANDLE hFile = CreateFileW(file.c_str(),
                                    GENERIC_READ,
                                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
    if(hFile == INVALID_HANDLE_VALUE) {
        fprintf(stderr,"#*** Cannot open file \"%S\" for reading\n",file.c_str());
        return 3;
    }
    int res = LoadListFromFile(hFile,list);
    CloseHandle(hFile);
    if(res!=0) {
        fprintf(stderr,"#*** Failure reading file \"%S\"\n",file.c_str());
    }
    return res;
}

int GlobalScan::LoadListFromFile(HANDLE hFile,StringList & list)
/*++

Routine Description:

    Load a list of strings from a text file (handle)

    file - name of file to load
    list - returned list of strings

Return Value:
    0

--*/
{
    DWORD sz = GetFileSize(hFile,NULL);
    if(sz == INVALID_FILE_SIZE) {
        return 3;
    }
    if(sz==0) {
        //
        // nothing to read
        //
        return 0;
    }
    LPSTR buffer = new CHAR[sz+1];
    DWORD actsz;
    if(!ReadFile(hFile,buffer,sz,&actsz,NULL)) {
        delete [] buffer;
        return 3;
    }
    buffer[actsz] = 0;
    while(actsz>0 && buffer[actsz-1] == ('Z'-'@'))
    {
        actsz--;
        buffer[actsz] = 0;
    }
    LPSTR linestart = buffer;

    while(*linestart) {
        LPSTR lineend = strchr(linestart,'\n');
        if(lineend==NULL) {
            lineend += strlen(linestart);
        } else if(lineend == linestart) {
            linestart = lineend+1;
            continue;
        } else {
            if(lineend[-1] == '\r') {
                lineend[-1] = '\0';
            }
            if(*lineend) {
                *lineend = '\0';
                lineend++;
            }
        }
        _strlwr(linestart);
        list.push_back(ConvertString(linestart));
        linestart = lineend;
    }
    delete [] buffer;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\globals.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

For Internal use only!

Module Name:

    INFSCAN
        globals.cpp

Abstract:

    Global functions (ie, not part of any class)

History:

    Created July 2001 - JamieHun

--*/

#include "precomp.h"
#pragma hdrstop
#include <initguid.h>
#include <new.h>

int
__cdecl
my_new_handler(size_t)
{
  throw std::bad_alloc();
  return 0;
}

int
__cdecl
main(int   argc,char *argv[])
/*++

Routine Description:

    Main point of entry
    Defer to GlobalScan::ParseArgs and GlobalScan::Scan

Arguments:

    argc                - # of arguments passed on command line
    argv                - arguments passed on command line

Return Value:

    0 on success
    1 no files
    2 bad usage
    3 fatal error (out of memory)

    stdout -- scan errors
    stderr -- trace/fatal errors

--*/
{
    int res;
    _PNH _old_new_handler = _set_new_handler(my_new_handler);
    int _old_new_mode = _set_new_mode(1);

    try {
        GlobalScan scanner;

        res = scanner.ParseArgs(argc,argv);
        if(res != 0) {
            return res;
        }
        res = scanner.Scan();

    } catch(bad_alloc &) {
        res = 3;
    }
    if(res == 3) {
        fprintf(stderr,"Out of memory!\n");
    }
    _set_new_mode(_old_new_mode);
    _set_new_handler(_old_new_handler);
    return res;

}


void FormatToStream(FILE * stream,DWORD fmt,DWORD flags,...)
/*++

Routine Description:

    Format text to stream using a particular msg-id fmt
    Used for displaying localizable messages

Arguments:

    stream              - file stream to output to, stdout or stderr
    fmt                 - message id
    ...                 - parameters %1...

Return Value:

    none

--*/
{
    va_list arglist;
    LPTSTR locbuffer = NULL;
    DWORD count;

    va_start(arglist, flags);
    count = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ALLOCATE_BUFFER|flags,
                          NULL,
                          fmt,
                          0,              // LANGID
                          (LPTSTR) &locbuffer,
                          0,              // minimum size of buffer
                          (flags & FORMAT_MESSAGE_ARGUMENT_ARRAY)
                            ? reinterpret_cast<va_list*>(va_arg(arglist,DWORD_PTR*))
                            : &arglist);

    if(locbuffer) {
        if(count) {
            int c;
            int back = 0;
            while(((c = *CharPrev(locbuffer,locbuffer+count)) == TEXT('\r')) ||
                  (c == TEXT('\n'))) {
                count--;
                back++;
            }
            if(back) {
                locbuffer[count++] = TEXT('\n');
                locbuffer[count] = TEXT('\0');
            }
            _fputts(locbuffer,stream);
        }
        LocalFree(locbuffer);
    }
}

PTSTR CopyString(PCTSTR arg, int extra)
/*++

Routine Description:

    Copy a string into a newly allocated buffer

Arguments:

    arg                 - string to copy
    extra               - extra characters to allow for

Return Value:

    TCHAR[] buffer, delete with "delete []"

--*/
{
    int max = _tcslen(arg)+1;
    PTSTR chr = new TCHAR[max+extra]; // may throw bad_alloc
    memcpy(chr,arg,max*sizeof(TCHAR));
    return chr;
}

#ifdef UNICODE
PTSTR CopyString(PCSTR arg, int extra)
/*++

Routine Description:

    Copy a string into a newly allocated buffer
    Converting from ANSI to UNICODE

Arguments:

    arg                 - string to copy
    extra               - extra characters to allow for

Return Value:

    TCHAR[] buffer, delete with "delete []"

--*/
{

    int max = strlen(arg)+1;
    PTSTR chr = new TCHAR[max+extra]; // may throw bad_alloc
    if(!MultiByteToWideChar(CP_ACP,0,arg,max,chr,max)) {
        delete [] chr;
        return NULL;
    }
    return chr;
}
#else
PTSTR CopyString(PCWSTR arg, int extra)
/*++

Routine Description:

    Copy a string into a newly allocated buffer
    Converting from UNICODE to ANSI

Arguments:

    arg                 - string to copy
    extra               - extra characters to allow for

Return Value:

    TCHAR[] buffer, delete with "delete []"

--*/
{
    #error CopyString(PCWSTR arg,int extra)
}
#endif

int GetFullPathName(const SafeString & given,SafeString & target)
/*++

Routine Description:

    Obtain full pathname

Arguments:

    given               - path to convert
    target              - full pathname on success, same as given on error

Return Value:

    0 on success, !=0 on failure

--*/
{
    DWORD len = GetFullPathName(given.c_str(),0,NULL,NULL);
    if(len == 0) {
        if(&target != &given) {
            target = given;
        }
        return -1;
    }
    PTSTR chr = new TCHAR[len];
    if(!chr) {
        if(&target != &given) {
            target = given;
        }
        return -1;
    }
    DWORD alen = GetFullPathName(given.c_str(),len,chr,NULL);
    if((alen == 0) || (alen>len)) {
        if(&target != &given) {
            target = given;
        }
        delete [] chr;
        return -1;
    }
    target = chr;
    delete [] chr;
    return 0;
}

SafeString PathConcat(const SafeString & path,const SafeString & tail)
/*++

Routine Description:

    Combine path and tail, returning newly combined string
    inserts/removes path seperator if needed

Arguments:

    path                - first part
    tail                - last part

Return Value:

    appended path

--*/
{
    if(!path.length()) {
        return tail;
    }
    if(!tail.length()) {
        return path;
    }
    PCTSTR path_p = path.c_str();
    int path_l = path.length();
    int c = *CharPrev(path_p,path_p+path_l);
    bool addslash = false;
    bool takeslash = false;
    if((c != TEXT('\\')) && (c != TEXT('/'))) {
        addslash = true;
    }
    c = tail[0];
    if((c == TEXT('\\')) || (c == TEXT('/'))) {
        if(addslash) {
            return path+tail;
        } else {
            return path+tail.substr(1);
        }
    } else {
        if(addslash) {
            return path+SafeString(TEXT("\\"))+tail;
        } else {
            return path+tail;
        }
    }
}

VOID
Usage(VOID)
/*++

Routine Description:

    Help information

Arguments:

Return Value:

--*/
{
    _tprintf(TEXT("Usage:  INFSCAN [/B <textfile>] [/C <output>] [/D] [/E <output>] [/F <filter>] [/G] [/I] {/N <infname>} {/O <dir>} [/P] [Q <output>] [/R] [/S <output>] [/T <count>] [/V <version>] [/W <textfile>] [/X <textfile>] [/Y] [/Z] [SourcePath]\n\n"));
    _tprintf(TEXT("Options:\n\n"));
    _tprintf(TEXT("/B <textfile> (build special) Filter /E based on a list of \"unchanged\" files\n"));
    _tprintf(TEXT("              variation /B1 - based on copied files only\n"));
    _tprintf(TEXT("              variation /B2 - based on INF files only\n"));
    _tprintf(TEXT("/C <output>   Create INF filter/report based on errors\n"));
    _tprintf(TEXT("/D            Determine non-driver installation sections\n"));
    _tprintf(TEXT("/E <output>   Create a DeviceToInf filter INF\n"));
    _tprintf(TEXT("/F <filter>   Filter based on INF: FilterInfPath\n"));
    _tprintf(TEXT("/G            Generate Pnfs first (see also /Z)\n"));
    _tprintf(TEXT("/I            Ignore errors (for when generating file list)\n"));
    _tprintf(TEXT("/N <infname>  Specify single INF name (/N may be used multiple times)\n"));
    _tprintf(TEXT("/O <dir>      Specify an override directory (/O may be used multiple times and parsed in order)\n"));
    _tprintf(TEXT("/P            Pedantic mode (show potential problems too)\n"));
    _tprintf(TEXT("/Q <output>   Source+Target copied files list (filtered by layout.inf) see also /S\n"));
    _tprintf(TEXT("/R            Trace (list all INF's)\n"));
    _tprintf(TEXT("/S <output>   Source copied files list (filtered by layout.inf) see also /Q\n"));
    _tprintf(TEXT("/T <count>    Specify number of threads to use\n"));
    _tprintf(TEXT("/V <version>  Version (eg NTx86.5.1)\n"));
    _tprintf(TEXT("/W <textfile> List of files to include (alternative to /N)\n"));
    _tprintf(TEXT("/X <textfile> List of files to exclude (same format as /W) overrides later includes\n"));
    _tprintf(TEXT("/Y            Don't check per-inf [SourceDisksFiles*]\n"));
    _tprintf(TEXT("/Z            Generate Pnfs and quit (see also /G)\n"));
    _tprintf(TEXT("/? or /H Display brief usage message\n"));
}



bool MyGetStringField(PINFCONTEXT Context,DWORD FieldIndex,SafeString & result,bool downcase)
/*++

Routine Description:

    Get a string field from an INF
    downcase it if flag indicates it needs to be (typical case)

Arguments:
    Context     - from SetupFindFirstLine/SetupFindNextLine etc
    FieldIndex  - 0 for key, 1-n for parameter
    result      - string obtained
    downcase    - true (typical) to return result as lower-case

Return Value:
    TRUE if success (result modified), FALSE otherwise (result left untouched)

--*/
{
    TCHAR Buf[MAX_INF_STRING_LENGTH];
    if(SetupGetStringField(Context,FieldIndex,Buf,MAX_INF_STRING_LENGTH,NULL)) {
        if(downcase) {
            _tcslwr(Buf);
        }
        result = Buf;
        return true;
    } else {
        //
        // leave result as is, allowing default capability
        //
        return false;
    }
}

SafeString QuoteIt(const SafeString & val)
/*++

Routine Description:

    Quote a string in such a way that it will be correctly parsed by SetupAPI

Arguments:
    val - unquoted string

Return Value:
    quoted string

--*/
{
    if(val.empty()) {
        //
        // don't quote empty string
        //
        return val;
    }
    basic_ostringstream<TCHAR> result;
    result << TEXT("\"");
    LPCTSTR p = val.c_str();
    LPCTSTR q;
    while((q = wcsstr(p,TEXT("%\""))) != NULL) {
        TCHAR c = *q;
        q++; // include the special char
        result << SafeString(p,q-p) << c; // write what we have so far, double up the special char
        p = q;
    }
    result << p << TEXT("\"");
    return result.str();
}

int GeneratePnf(const SafeString & pnf)
/*++

Routine Description:

    Generate a single PNF

Arguments:
    none

Return Value:
    0 on success

--*/
{
    HINF hInf;

    hInf = SetupOpenInfFile(pnf.c_str(),
                            NULL,
                            INF_STYLE_WIN4 | INF_STYLE_CACHE_ENABLE,
                            NULL
                           );

    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    return 0;
}


void Write(HANDLE hFile,const SafeStringW & str)
/*++

Routine Description:

    Write a string to specified file, converting UNICODE to ANSI

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    int len = WideCharToMultiByte(CP_ACP,0,str.c_str(),str.length(),NULL,0,NULL,NULL);
    if(!len) {
        return;
    }
    LPSTR buf = new CHAR[len];
    if(!buf) {
        return;
    }
    int nlen = WideCharToMultiByte(CP_ACP,0,str.c_str(),str.length(),buf,len,NULL,NULL);
    if(!nlen) {
        delete [] buf;
        return;
    }
    DWORD written;
    BOOL f = WriteFile(hFile,buf,len,&written,NULL);
    delete [] buf;
}

void Write(HANDLE hFile,const SafeStringA & str)
/*++

Routine Description:

    Write a string to specified file as-is

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    DWORD written;
    BOOL f = WriteFile(hFile,str.c_str(),str.length(),&written,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\infscan.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

For Internal use only!

Module Name:

    INFSCAN
        infscan.cpp

Abstract:

    Individual INF scanner class
    entry point InfScan::Run
    is invoked to parse an INF specified by InfScan::FullInfName

    WARNING! WARNING!
    SetupAPI implementation specific information is used
    to do the parsing

History:

    Created July 2001 - JamieHun

--*/

#include "precomp.h"
#pragma hdrstop

int PnfGen::Run()
/*++

Routine Description:

    Job entry point: invoke GeneratePnf for context INF

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    return GeneratePnf(InfName);
}

InfScan::InfScan(GlobalScan *globalScan,const SafeString & infName)
/*++

Routine Description:

    Initialization

--*/
{
    pGlobalScan = globalScan;
    FullInfName = infName;
    HasErrors = false;
    ThisIsLayoutInf = false;
    HasDependentFileChanged = false;
    ScanDevices = false;
}

InfScan::~InfScan()
/*++

Routine Description:

    Cleanup any dynamic data/handles

--*/
{
}

int
InfScan::Run()
/*++

Routine Description:

    Job entry point: Parse a given Inf

Arguments:
    NONE

Return Value:
    0 on success

--*/
{

    int res;

    //
    // see if this INF can be ignored
    //
    FileNameOnly = GetFileNamePart(FullInfName);
    FileDisposition & disp = pGlobalScan->GetFileDisposition(FileNameOnly);
    if((disp.FilterAction == ACTION_IGNOREINF) && (pGlobalScan->NewFilter == INVALID_HANDLE_VALUE)) {
        //
        // return here if the only flag set is ACTION_IGNOREINF
        // if any other flags are set, we must at least load the inf
        //
        return 0;
    }
    FilterAction = disp.FilterAction;
    FilterSection = disp.FilterErrorSection;
    FilterGuid = disp.FileGuid;

    if(pGlobalScan->BuildChangedDevices
       || (pGlobalScan->DeviceFilterList != INVALID_HANDLE_VALUE)
       || !pGlobalScan->IgnoreErrors) {
        //
        // maintain this flag so that we only scan devices if we need to
        //
        ScanDevices = true;
    }

    if((pGlobalScan->BuildChangedDevices & BUILD_CHANGED_DEVICES_INFCHANGED) &&
           pGlobalScan->IsFileChanged(FullInfName)) {
        HasDependentFileChanged = true;
    }
    PrimaryInf = Include(FullInfName,false);

    if(PrimaryInf->InfHandle == INVALID_HANDLE_VALUE) {
        FilterAction |= ACTION_IGNOREINF; // used when generating filters
        if(Pedantic() && !HasErrors) {
            Fail(MSG_INF_STYLE_WIN4);
        }
        return 0;
    }

    //
    // obviously there must be [Version] information
    // now see what kind of INF this is
    //

    res = CheckClassGuid();
    if(res != 0) {
        return res;
    }
    if(FilterAction & ACTION_IGNOREINF) {
        return 0;
    }

    //
    // if we haven't been filtered out, go on as if this is a driver INF
    //

    if(pGlobalScan->DetermineCopySections) {
        res = GetCopySections();
        if(res != 0) {
            return res;
        }
    }

    res = CheckDriverInf();
    if(res != 0) {
        return res;
    }

    res = ProcessCopySections();
    if(res != 0) {
        return res;
    }

    return res;
}

void
InfScan::Fail(int err,const StringList & errors)
/*++

Routine Description:

    Handle an error while processing this INF

Arguments:
    err = MSGID of error
    errors = list of string parameters

Return Value:
    NONE

--*/
{
    if(pGlobalScan->IgnoreErrors) {
        //
        // not interested in errors, bail now
        //
        return;
    }
    //
    // prep the entry we want to add
    //
    ReportEntry ent(errors);
    ent.FilterAction = ACTION_FAILEDMATCH;
    if(!HasErrors) {
        //
        // on first error determine what errors we'll allow or not
        // (saves us processing filters for Good INF's)
        //
        if((pGlobalScan->InfFilter != INVALID_HANDLE_VALUE) &&
           (pGlobalScan->NewFilter == INVALID_HANDLE_VALUE)) {
            //
            // per-file filters has precedence over per-guid filters
            //
            LocalErrorFilters.LoadFromInfSection(pGlobalScan->InfFilter,FilterSection);
            LocalErrorFilters.LoadFromInfSection(pGlobalScan->InfFilter,GuidFilterSection);
        }
        HasErrors = true;
    }
    //
    // If the global action doesn't tell us to ignore, we want to add
    //
    int action = LocalErrorFilters.FindReport(err,ent);
    if(action & ACTION_NOMATCH) {
        action = pGlobalScan->GlobalErrorFilters.FindReport(err,ent);
    }
    if (action & (ACTION_IGNOREINF|ACTION_IGNOREMATCH)) {
        //
        // whichever filter we used, indicated to ignore
        //
        return;
    }
    //
    // add to our error table
    //
    action = LocalErrors.FindReport(err,ent,true);
}

int
InfScan::CheckClassGuid()
/*++

Routine Description:

    Check to see if INF's ClassGUID is valid

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    INFCONTEXT targetContext;
    SafeString guid;
    if(!SetupFindFirstLine(PrimaryInf->InfHandle,TEXT("Version"),TEXT("ClassGUID"),&targetContext)) {
        if(SetupFindFirstLine(PrimaryInf->InfHandle,TEXT("Version"),TEXT("Class"),&targetContext)) {
            //
            // if Class is specified, ClassGUID needs to be too
            //
            Fail(MSG_NO_CLASS_GUID);
            guid = INVALID_GUID;
        } else {
            //
            // this is a file way to specify no guid
            //
            guid = NULL_GUID;
        }
    } else {
        if(!MyGetStringField(&targetContext,1,guid)) {
            Fail(MSG_INVALID_CLASS_GUID);
            guid = INVALID_GUID;
        }
        if(guid.length() != 38) {
            Fail(MSG_INVALID_CLASS_GUID);
            guid = INVALID_GUID;
        }
        if(FilterGuid.length() != 0) {
            if(FilterGuid != guid) {
                Fail(MSG_INCORRECT_CLASS_GUID,FilterGuid);
                FilterGuid = guid;
            }
        } else {
            if((guid[0] != TEXT('{')) ||
               (guid[37] != TEXT('}'))) {
                Fail(MSG_INVALID_CLASS_GUID);
                guid = INVALID_GUID;
            }
        }
    }
    if(FilterGuid.empty()) {
        FilterGuid = guid;
    }
    //
    // see if any global handling to be done with this GUID
    //
    FileDisposition & disp = pGlobalScan->GetGuidDisposition(guid);
    FilterAction |= disp.FilterAction;
    GuidFilterSection = disp.FilterErrorSection;
    return 0;
}

int
InfScan::CheckSameInfInstallConflict(const SafeString & desc, const SafeString & sect, bool & f)
/*++

Routine Description:

    Check to see if description appears twice in one INF for a different section

Arguments:
    desc - description (lower-case)
    sect - section being checked (lower-case)
    f    - returned true/false indicating duplicate

Return Value:
    0

--*/
{
    StringToString::iterator i;
    i = LocalInfDescriptions.find(desc);
    if(i != LocalInfDescriptions.end()) {
        //
        // already exists
        //
        if(i->second.compare(sect)==0) {
            //
            // but same section
            //
            f = false;
        } else {
            //
            // different section
            //
            f = true;
            Fail(MSG_LOCAL_DUPLICATE_DESC,sect,i->second,desc);
        }
        return 0;
    }
    //
    // first time
    //
    LocalInfDescriptions[desc] = sect;
    f = false;
    return 0;
}

int
InfScan::CheckSameInfDeviceConflict(const SafeString & hwid, const SafeString & sect, bool & f)
/*++

Routine Description:

    Check to see if hwid appears twice in one INF for a different section
    (Ok for now)

Arguments:
    hwid - hardware ID (lower-case)
    sect - section being checked (lower-case)
    f    - returned true/false indicating duplicate

Return Value:
    0

--*/
{
    StringToString::iterator i;
    i = LocalInfHardwareIds.find(hwid);
    if(i != LocalInfHardwareIds.end()) {
        //
        // already exists
        //
        if(i->second.compare(sect)==0) {
            //
            // but same section
            //
            f = false;
        } else {
            //
            // different section
            //
            f = true;
            //Fail(MSG_LOCAL_DUPLICATE_DESC,sect,i->second,desc);
        }
        return 0;
    }
    //
    // first time
    //
    LocalInfHardwareIds[hwid] = sect;
    f = false;
    return 0;
}

int
InfScan::PrepareCrossInfDeviceCheck()
/*++

Routine Description:

    Invoke pGlobalScan::SaveForCrossInfInstallCheck
    to prime table for later checks by CheckCrossInfInstallConflict

Arguments:
    NONE

Return Value:
    0

--*/
{
    StringToString::iterator i;
    for(i = LocalInfHardwareIds.begin(); i != LocalInfHardwareIds.end(); i++) {
        if(pGlobalScan->BuildChangedDevices && !HasDependentFileChanged) {
            //
            // filter (only do this if !HasDependentFileChanged
            // otherwise we'll get wrong results. We optimize
            // writing stuff back)
            //
            if(ModifiedHardwareIds.find(i->first) == ModifiedHardwareIds.end()) {
                continue;
            }
        }

        pGlobalScan->SaveForCrossInfDeviceCheck(i->first,FileNameOnly);
    }
    return 0;
}

int
InfScan::PrepareCrossInfInstallCheck()
/*++

Routine Description:

    Invoke pGlobalScan::SaveForCrossInfInstallCheck
    to prime table for later checks by CheckCrossInfInstallConflict

Arguments:
    NONE

Return Value:
    0

--*/
{
    StringToString::iterator i;
    for(i = LocalInfDescriptions.begin(); i != LocalInfDescriptions.end(); i++) {
        pGlobalScan->SaveForCrossInfInstallCheck(i->first,FileNameOnly);
    }
    return 0;
}

int
InfScan::CheckCrossInfDeviceConflicts()
/*++

Routine Description:

    Invoke pGlobalScan::CheckCrossInfDeviceConflict
    for each device in this INF to see if device is used in another INF
    this is done during Results phase

Arguments:
    desc - description (lower-case)
    f    - returned true/false indicating duplicate

Return Value:
    0

--*/
{
    StringToString::iterator i;
    for(i = LocalInfHardwareIds.begin(); i != LocalInfHardwareIds.end(); i++) {
        bool f;
        const SafeString & hwid = i->first;
        SafeString & sect = i->second;
        SafeString other;
        int res;
        res = pGlobalScan->CheckCrossInfDeviceConflict(hwid,FileNameOnly,f,other);
        if(res==0 && f) {
            Fail(MSG_GLOBAL_DUPLICATE_HWID,sect,other,hwid);
        }
    }
    return 0;
}

int
InfScan::CheckCrossInfInstallConflicts()
/*++

Routine Description:

    Invoke pGlobalScan::CheckCrossInfInstallConflict
    for each description in this INF to see if description is used in another INF
    this is done during Results phase

Arguments:
    desc - description (lower-case)
    f    - returned true/false indicating duplicate

Return Value:
    0

--*/
{
    StringToString::iterator i;
    for(i = LocalInfDescriptions.begin(); i != LocalInfDescriptions.end(); i++) {
        bool f;
        const SafeString & desc = i->first;
        SafeString & sect = i->second;
        SafeString other;
        int res;
        res = pGlobalScan->CheckCrossInfInstallConflict(desc,FileNameOnly,f,other);
        if(res==0 && f) {
            Fail(MSG_GLOBAL_DUPLICATE_DESC,sect,other,desc);
        }
    }
    return 0;
}

int
InfScan::CheckModelsSection(const SafeString & section,const StringList & shadowDecorations,DWORD platformMask,bool CopyElimination)
/*++

Routine Description:

    Process a given models section
    WARNING! may need to change if SetupAPI install behavior changes
    MAINTAINANCE: This function expects [Models] to follow
    <desc> = <sect>[,id....]
    MAINTAINANCE: Must keep all possible decorations up to date
    MAINTAINANCE: Must keep all shadow install sections up to date

Arguments:
    section      - name of models section
    shadowDecorations - decorations to append (passed into CheckInstallSections)
    PlatformMask - limit of platforms being processed
    sections     - returned list of decorated sections to be processed
    CopyElimination - true if processing to eliminate from potential non-driver sections

Return Value:
    0 on success

--*/
{
    int res;
    bool f;
    INFCONTEXT context;
    SafeString desc;
    SafeString installsect;
    HINF inf = PrimaryInf->InfHandle;

    if(!SetupFindFirstLine(inf,section.c_str(),NULL,&context)) {
        if(SetupGetLineCount(inf, section.c_str()) == -1) {
            if(!CopyElimination) {
                Fail(MSG_NO_LISTED_MODEL,section);
            }
        }
        return 0;
    }

    //
    // enumerate through each <desc> = <install>[,hwid...]
    //
    do {
        if(CopyElimination) {
            //
            // CopyElimination pass
            //
            if(!MyGetStringField(&context,1,installsect) || installsect.empty()) {
                continue;
            }
            //
            // check for all possible install sections
            //
            InstallSectionBlobList sections;
            res = CheckInstallSections(installsect,platformMask,shadowDecorations,sections,true,CopyElimination);
        } else {
            //
            // Driver processing pass
            //
            if(!MyGetStringField(&context,0,desc) || desc.empty()) {
                Fail(MSG_EXPECTED_DESCRIPTION,section);
                continue;
            }
            if(!MyGetStringField(&context,1,installsect) || installsect.empty()) {
                Fail(MSG_EXPECTED_INSTALL_SECTION,section,desc);
                continue;
            }
            if(!pGlobalScan->IgnoreErrors) {
                //
                // only check for conflicts if we're going
                // to report errors
                //
                res = CheckSameInfInstallConflict(desc,installsect,f);
                if(res != 0) {
                    return res;
                }
            }

            InstallSectionBlobList sections;
            //
            // check for all possible install sections
            //
            res = CheckInstallSections(installsect,platformMask,shadowDecorations,sections,true,CopyElimination);

            if(ScanDevices) {
                StringSet hwids;
                //
                // extract all hardware ID's handled
                //
                int hwidIter = 2;
                SafeString hwid;

                //
                // inf-centric hardware ID's
                // and fill in hwid for hardware ID's specific to this install line
                //
                while(MyGetStringField(&context,hwidIter++,hwid)) {
                    if(hwid.length()) {
                        hwids.insert(hwid);
                        res = CheckSameInfDeviceConflict(hwid,installsect,f);
                        if(res != 0) {
                            return res;
                        }
                    }
                }

                //
                // install-section centric hardware ID's
                //
                InstallSectionBlobList::iterator isli;
                for(isli = sections.begin(); isli != sections.end(); isli++) {
                    (*isli)->AddHWIDs(hwids);
                }
            }
        }

    } while (SetupFindNextLine(&context,&context));


    return 0;

}

InstallSectionBlob InfScan::GetInstallSection(const SafeString & section)
/*++

Routine Description:

    Obtain an install section (might already exist)

Arguments:

    section - name of install section

Return Value:

    InstallSection object related to the named install section

--*/
{
    //
    // see if we have one cached away
    //
    StringToInstallSectionBlob::iterator srch;

    srch = UsedInstallSections.find(section);
    if(srch != UsedInstallSections.end()) {
        return srch->second;
    }
    //
    // nope, so add one
    //
    InstallSectionBlob sect;
    sect.create();
    sect->pGlobalScan = pGlobalScan;
    sect->pInfScan = this;
    sect->Section = section;

    UsedInstallSections[section] = sect;
    return sect;
}

int
InfScan::CheckInstallSections(
            const SafeString & namedSection,
            DWORD platformMask,
            const StringList & shadowDecorations,
            InstallSectionBlobList & sections,
            bool required,
            bool CopyElimination)
/*++

Routine Description:

    Given a section name
    determine list of decorated sections to parse

Arguments:
    namedSection - 'undecorated' section
    shadowDecorations - sub-decorations appended to platform decorated section get complete list of install sections
    sections     - list of sections determined (CopyElimination = false)
    warn - true if section is required
    CopyElimination - true if processing to eliminate sections

Return Value:
    0 on success

--*/
{
    static StringProdPair decorations[] = {
        //
        // listed from most specific to most generic
        // all lower-case
        //
        { TEXT(".ntx86"),   PLATFORM_MASK_NTX86          },
        { TEXT(".ntia64"),  PLATFORM_MASK_NTIA64         },
        { TEXT(".ntamd64"), PLATFORM_MASK_NTAMD64        },
        { TEXT(".nt"),      PLATFORM_MASK_NT             },
        { TEXT(""),         PLATFORM_MASK_ALL_ARCHITECTS },
        { NULL, 0 }
    };

    int i;
    StringList::iterator ii;
    SafeString sectFull;
    SafeString sectFullDec;

    if(CopyElimination) {
        //
        // copy elimination pass
        //
        for(i=0;decorations[i].String;i++) {
            sectFull = namedSection + decorations[i].String;
            PotentialInstallSections.erase(sectFull);
            for(ii = shadowDecorations.begin(); ii != shadowDecorations.end(); ii++) {
                sectFullDec = sectFull+*ii;
                PotentialInstallSections.erase(sectFullDec);
            }
        }
        return 0;
    }

    bool f = false;
    DWORD platforms = platformMask & (PLATFORM_MASK_NT|PLATFORM_MASK_WIN);
    HINF inf = PrimaryInf->InfHandle;

    for(i=0;decorations[i].String;i++) {
        DWORD plat = platforms & decorations[i].ProductMask;
        if(plat) {
            sectFull = namedSection + decorations[i].String;
            //
            // see if this section exists
            //
            if(SetupGetLineCount(inf, sectFull.c_str()) == -1) {
                //
                // nope, look for another one
                //
                continue;
            }

            f = true;
            //
            // return list of all sections potentially used
            // over all platforms of interest
            //
            InstallSectionBlob sectInfo = GetInstallSection(sectFull);
            sectInfo->PlatformMask |= plat;
            sections.push_back(sectInfo);
            //
            // these sections are processed in parallel with primary section
            //
            for(ii = shadowDecorations.begin(); ii != shadowDecorations.end(); ii++) {
                sectFullDec = sectFull+*ii;
                PotentialInstallSections.erase(sectFullDec);
                sectInfo = GetInstallSection(sectFullDec);
                sectInfo->PlatformMask |= plat;
                sections.push_back(sectInfo);
            }
            platforms &= ~plat;
        }
    }

    if(!f) {
        //
        // no install section found at all
        //
        if(required) {
            Fail(MSG_NO_ACTUAL_INSTALL_SECTION,namedSection);
        }
    } else if(Pedantic()) {
        if(platforms) {
            //
            // an install section found but not all platforms covered
            //
            Fail(MSG_NO_GENERIC_INSTALL_SECTION,namedSection);
        }
    }
    return 0;
}

int
InfScan::GetCopySections()
/*++

Routine Description:

    Get initial list of sections (place into set for modification)
    don't do anything that takes time yet

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    StringList sections;
    INFCONTEXT context;

    pGlobalScan->SetupAPI.GetInfSections(PrimaryInf->InfHandle,sections);
    StringList::iterator i;
    for(i = sections.begin(); i != sections.end(); i++) {
        PotentialInstallSections.insert(*i);
    }
    if(sections.empty()) {
        return 0;
    }

    //
    // get rid of some special cases
    //
    PotentialInstallSections.erase(TEXT("sourcedisksfiles"));
    PotentialInstallSections.erase(TEXT("sourcedisksnames"));
    PotentialInstallSections.erase(TEXT("version"));
    PotentialInstallSections.erase(TEXT("strings"));
    PotentialInstallSections.erase(TEXT("classinstall"));
    PotentialInstallSections.erase(TEXT("manufacturer"));
    //
    // special pass of driver files
    //
    int res = CheckDriverInf(true);
    if(res != 0) {
        return res;
    }

    //
    // now enumerate what we have left
    //
    StringSet::iterator ii;
    for(ii = PotentialInstallSections.begin(); ii != PotentialInstallSections.end() ; ii++) {
        const SafeString & str = *ii;
        if(str.empty()) {
            continue;
        }
        if(str[0] == TEXT('s')) {
            if((_tcsncmp(str.c_str(),TEXT("sourcedisksfiles."),17)==0) ||
                (_tcsncmp(str.c_str(),TEXT("sourcedisksnames."),17)==0) ||
                (_tcsncmp(str.c_str(),TEXT("strings."),8)==0)) {
                continue;
            }
        }
        //
        // for this section to be valid, it must have at least one
        // CopyFiles = directive
        //
        if(!SetupFindFirstLine(PrimaryInf->InfHandle,str.c_str(),TEXT("copyfiles"),&context)) {
            continue;
        }
        //
        // ok, consider this
        //
        OtherInstallSections.insert(str);
    }

    return 0;
}

int
InfScan::ProcessCopySections()
/*++

Routine Description:

    Process final list of copy sections

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    int res = pGlobalScan->GetCopySections(FileNameOnly,OtherInstallSections);
    if(res != 0) {
        return res;
    }
    if(OtherInstallSections.empty()) {
        return 0;
    }
    //
    // make sure we haven't set IGNOREINF anywhere in our pass
    //
    FilterAction &= ~ ACTION_IGNOREINF;

    //
    // for each install section...
    //
    StringSet::iterator i;
    DWORD platforms = pGlobalScan->Version.PlatformMask & (PLATFORM_MASK_NT|PLATFORM_MASK_WIN);
    for(i = OtherInstallSections.begin(); i != OtherInstallSections.end(); i++) {
        InstallScan s;
        s.pGlobalScan = pGlobalScan;
        s.pInfScan = this;
        s.PlatformMask = platforms;
        s.Section = *i;
        s.NotDeviceInstall = true;
        res =s.ScanInstallSection();
        if(res != 0) {
            return res;
        }
    }

    return 0;
}

int
InfScan::CheckClassInstall(bool CopyElimination)
/*++

Routine Description:

    Process one of the [classinstall32.*] sections
    WARNING! may need to change if SetupAPI install behavior changes

Arguments:
    sections - returned list of classinstall32 section variations
    CopyElimination - true if just doing copy elimination

Return Value:
    0 on success

--*/
{
    StringList shadows; // currently none
    InstallSectionBlobList sections;
    return CheckInstallSections(TEXT("classinstall32"),
                                pGlobalScan->Version.PlatformMask,
                                shadows,
                                sections,
                                false,
                                CopyElimination);
}

int
InfScan::CheckDriverInf(bool CopyElimination)
/*++

Routine Description:

    Process the [manufacturer] section
    WARNING! may need to change if SetupAPI install behavior changes
    MAINTAINANCE: This function expects [Manufacturer] to follow
    <desc> = <sect>[,dec....]
    MAINTAINANCE: Modify NodeVerInfo class if decr syntax changes

Arguments:
    CopyElimination - true if just doing copy elimination

Return Value:
    0 on success

--*/
{
    INFCONTEXT context;
    int res;
    SafeString ModelSection;
    SafeString DecSection;
    SafeString ActualSection;
    StringList shadows;
    int dec;
    HINF inf = PrimaryInf->InfHandle;
    bool hasModels;

    res = CheckClassInstall(CopyElimination);
    if(res > 0) {
        return res;
    }
    if(SetupFindFirstLine(inf,TEXT("manufacturer"),NULL,&context)) {
        hasModels = true;
    } else {
        hasModels = false;
        if(Pedantic()) {
            Fail(MSG_NO_MANUFACTURER);
        }
        FilterAction |= ACTION_IGNOREINF;
        if(UsedInstallSections.empty()) {
            //
            // no classinstall32 sections either, can return
            //
            return 0;
        }
    }
    if(hasModels) {
        //
        // for a given DDInstall, also need to process these decorations
        //
        shadows.push_back(TEXT(".coinstallers"));
        shadows.push_back(TEXT(".interfaces"));
        //
        // obtain list of all installation sections to parse
        //
        do {
            //
            // Model section entry
            // expect <desc> = <section> [, dec [, dec ... ]]
            //
            if(!MyGetStringField(&context,1,ModelSection) || !ModelSection.length()) {
                Fail(MSG_EXPECTED_MODEL_SECTION);
                continue;
            }
            if(CopyElimination) {
                PotentialInstallSections.erase(ModelSection);
            }

            //
            // process all the model decorations
            //
            NodeVerInfoList nodes;
            NodeVerInfoList::iterator i;
            NodeVerInfo node;
            //
            // first entry is the default node (no decoration)
            //
            nodes.push_back(node);

            //
            // determine interesting decorations
            //
            for(dec = 2;MyGetStringField(&context,dec,DecSection);dec++) {
                 if(DecSection.length()) {
                     if(DecSection[0]==TEXT('.')) {
                         //
                         // cannot start with '.'
                         //
                         res = 4;
                     } else {
                         res = node.Parse(DecSection);
                     }
                     if(res == 4) {
                         Fail(MSG_MODEL_DECORATION_BAD,ModelSection,DecSection);
                         continue;
                     }
                 }
                 if(CopyElimination) {
                     //
                     // processing for copy sections
                     // can't do at same time as driver install processing
                     //
                     nodes.push_back(node);

                 } else if(node.IsCompatibleWith(pGlobalScan->Version)) {
                     //
                     // this is something to be considered
                     // see if this is better than anything
                     // we have so far based on the version
                     // criterias we're checking against
                     //
                     for(i = nodes.begin(); i != nodes.end(); i++) {
                        int test = node.IsBetter(*i,pGlobalScan->Version);
                        switch(test) {
                            case 1:
                                //
                                // *i is better
                                //
                                node.Rejected = true;
                                break;

                            case 0:
                                //
                                // node & *i are equally valid
                                //
                                break;

                            case -1:
                                //
                                // node & *i are the same
                                //
                                node.Rejected = true;
                                break;

                            case -2:
                                //
                                // node is better
                                //
                                (*i).Rejected = true;
                                break;

                        }
                     }
                     nodes.push_back(node);
                 }
            }

            //
            // now look at each decorated models section in turn
            // (that we've decided are interesting)
            // adding any install sections to 'sections'
            // for later processing
            //
            for(i = nodes.begin(); i != nodes.end(); i++) {
                if((*i).Rejected) {
                    continue;
                }
                ActualSection = ModelSection;
                if((*i).Decoration.length()) {
                    ActualSection+=(TEXT("."));
                    ActualSection+=((*i).Decoration);
                    if(CopyElimination) {
                        PotentialInstallSections.erase(ActualSection);
                    }
                }
                DWORD platforms = (*i).PlatformMask & pGlobalScan->Version.PlatformMask &
                                        PLATFORM_MASK_ALL_ARCHITECTS;
                res = CheckModelsSection(ModelSection,shadows,platforms,CopyElimination);
                if(res != 0) {
                    return res;
                }
            }

        } while (SetupFindNextLine(&context,&context));
    }

    if(CopyElimination || UsedInstallSections.empty()) {
        //
        // no sections to process
        //
        return 0;
    }

    //
    // now parse all the device install sections
    //
    StringToInstallSectionBlob::iterator s;
    for(s = UsedInstallSections.begin() ; s != UsedInstallSections.end(); s++) {
        res = s->second->ScanInstallSection();
        if(res != 0) {
            return res;
        }
        if(s->second->HasDependentFileChanged) {
            //
            // merge hardware ID's back
            // (optimization for now to do this only when needed)
            //
            s->second->GetHWIDs(ModifiedHardwareIds);
        }
    }

    return 0;
}

ParseInfContextBlob & InfScan::Include(const SafeString & val,bool expandPath)
/*++

Routine Description:

    Called to add an INF to our list of INF's required to process the
    primary INF in question.
    If 'expandPath' is false, this is the primary INF and we don't
    need to determine the path of the INF
    If 'expandPath' is true, this is an included INF.

Arguments:
    val        - name of INF
    expandPath - true if we need to determine location of INF

Return Value:
    Modifiable ParseInfContextBlob entry

--*/
{
    SafeString infpath;
    SafeString infname;
    ParseInfContextMap::iterator i;
    int res = 0;

    if(expandPath) {
        //
        // we are being supplied (supposedly) only the name
        //
        infname = val;
    } else {
        //
        // we are being supplied full pathname
        //
        infpath = val;
        infname = GetFileNamePart(infpath.c_str());
    }

    i = Infs.find(infname);
    if(i != Infs.end()) {
        //
        // already have it
        //
        return i->second;
    }

    if(expandPath) {
        //
        // we need to obtain full pathname
        //
        res = pGlobalScan->ExpandFullPathWithOverride(val,infpath);
    }

    ParseInfContextBlob & ThisInf = Infs[infname];
    ThisInf.create();
    ThisInf->InfName = infname;
    ThisInf->pGlobalScan = pGlobalScan;
    ThisInf->pInfScan = this;
    if(res == 0) {
        ThisInf->InfHandle = SetupOpenInfFile(infpath.c_str(),NULL,INF_STYLE_WIN4,NULL);
    }
    if(ThisInf->InfHandle == INVALID_HANDLE_VALUE) {
        DWORD Err = GetLastError();
        if(Err != ERROR_WRONG_INF_STYLE) {
            Fail(MSG_OPENAPPENDINF,infname,infpath);
        }
        return ThisInf;
    }
    //
    // load the source disks files and destination dirs that's in this INF
    //
    if(ThisIsLayoutInf || !pGlobalScan->LimitedSourceDisksFiles) {
        ThisInf->LoadSourceDisksFiles();
    }
    ThisInf->LoadDestinationDirs();
    return ThisInf;
}

int
InfScan::PartialCleanup()
/*++

Routine Description:

    Clean up as much as we can
    leaving only the info we need to complete the results phase
    Whatever we do, don't leave INF handles open
    700+ INF handles eats up virtual memory

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    //
    // 'LocalInfDescriptions' required for cross-checking
    // 'LocalErrorFilters' required for cross-checking
    // 'LocalErrors' required for output
    // 'Infs' required for filter generation (but not handle)
    //

    PotentialInstallSections.clear();
    UsedInstallSections.clear();

    if(pGlobalScan->NewFilter == INVALID_HANDLE_VALUE) {
        //
        // for results generation only, we don't need Inf information
        //
        Infs.clear();
    }

    //
    // If we still have Infs table, make sure all INF's are closed
    //
    ParseInfContextMap::iterator i;
    for(i = Infs.begin(); i != Infs.end(); i++) {
        i->second->PartialCleanup();
    }

    return 0;
}

int
InfScan::PreResults()
/*++

Routine Description:

    Perform pre-results phase. Prime any global tables that will
    be scanned by other InfScan functions during Results phase

    In particular, do the cross-inf checking

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    if(!pGlobalScan->IgnoreErrors) {
        PrepareCrossInfInstallCheck();
        PrepareCrossInfDeviceCheck();
    } else {
        if(pGlobalScan->DeviceFilterList != INVALID_HANDLE_VALUE) {
            PrepareCrossInfDeviceCheck();
        }
    }
    return 0;
}

int
InfScan::Results()
/*++

Routine Description:

    Perform results phase. This function is called sequentially
    so we can do thread-unsafe operations such as merging results

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    int res;

    //
    // finish checking for cross-inf conflicts
    //
    if(!pGlobalScan->IgnoreErrors) {
        CheckCrossInfInstallConflicts();
        CheckCrossInfDeviceConflicts();
    }

    if(pGlobalScan->DetermineCopySections) {
        pGlobalScan->SetCopySections(FileNameOnly,OtherInstallSections);
    }

    res = pGlobalScan->AddSourceFiles(SourceFiles);
    if(res != 0) {
        return res;
    }

    if(pGlobalScan->NewFilter == INVALID_HANDLE_VALUE) {
        //
        // display errors
        //
        ReportEntryMap::iterator byTag;
        for(byTag = LocalErrors.begin(); byTag != LocalErrors.end(); byTag++) {
            //
            // this is our class/tag of error
            //
            int tag = byTag->first;
            ReportEntrySet &s = byTag->second;
            ReportEntrySet::iterator byText;
            for(byText = s.begin(); byText != s.end(); byText++) {
                //
                // this is our actual error
                //
                (*byText)->Report(tag,FullInfName);
            }
        }
    } else {
        res = GenerateFilterInformation();
        if(res != 0) {
            return res;
        }
    }

    return 0;
}


int InfScan::GenerateFilterInformation()
/*++

Routine Description:

    Generate entries into the new filter file
    called as part of results processing

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    //
    // generate all the filter information required
    //
    FileDisposition & filedisp = pGlobalScan->GetFileDisposition(FileNameOnly);
    filedisp.Filtered = true;
    filedisp.FilterAction = FilterAction;
    filedisp.FileGuid = FilterGuid;

    if(FilterGuid.length()) {
        filedisp.FilterAction |= ACTION_CHECKGUID;
        FileDisposition & guiddisp = pGlobalScan->GetGuidDisposition(FilterGuid);
        guiddisp.Filtered = true;
        guiddisp.FilterAction = ACTION_DEFAULT;
    }

    //
    // process through all errors and create local error filter
    // if there is any errors, designate a section name for the errors
    //
    if(HasErrors) {
        filedisp.FilterErrorSection = GetFileNamePart(FullInfName) + TEXT(".Errors");
        Write(pGlobalScan->NewFilter,"\r\n[");
        Write(pGlobalScan->NewFilter,filedisp.FilterErrorSection);
        Write(pGlobalScan->NewFilter,"]\r\n");

        ReportEntryMap::iterator byTag;
        for(byTag = LocalErrors.begin(); byTag != LocalErrors.end(); byTag++) {
            //
            // this is our class/tag of error
            //
            int tag = byTag->first;
            ReportEntrySet &s = byTag->second;
            ReportEntrySet::iterator byText;
            for(byText = s.begin(); byText != s.end(); byText++) {
                //
                // this is our actual error
                //
                (*byText)->AppendFilterInformation(pGlobalScan->NewFilter,tag);
            }
        }
    }

    //
    // process through all DestinationDirs
    // and create a list of unprocessed sections
    // for a 2nd pass CopyFiles
    //

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\globalscan.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        globalscan.h

Abstract:

    Main class definitions

History:

    Created July 2001 - JamieHun

--*/

#ifndef _INFSCAN_GLOBALSCAN_H_
#define _INFSCAN_GLOBALSCAN_H_


#define BUILD_CHANGED_DEVICES_DISABLED      (0x00000000)
#define BUILD_CHANGED_DEVICES_DEPCHANGED    (0x00000001)
#define BUILD_CHANGED_DEVICES_INFCHANGED    (0x00000002)
#define BUILD_CHANGED_DEVICES_ENABLED       (0x80000000)
#define BUILD_CHANGED_DEVICES_DEFAULT       (0x00000003)

class GlobalScan {

private:
    //
    // data that's not thread-safe
    //
    int             ThreadCount;
    StringSet       GlobalFileSet;
    StringSet       ExcludeInfs;
    JobThreadList   JobThreads;
    JobList         Jobs;
    JobList         SerialJobs;
    JobList::iterator NextJob;

protected:
    CriticalSection BottleNeck;

public:
    //
    // once multi-threading starts, don't modify this stuff
    // but always ok to read
    //
    bool                GeneratePnfs;
    bool                GeneratePnfsOnly;
    bool                Pedantic;
    bool                Trace;
    bool                IgnoreErrors;
    bool                TargetsToo;
    bool                DetermineCopySections;
    bool                LimitedSourceDisksFiles;
    DWORD               BuildChangedDevices;
    SafeString          SourcePath;
    SafeString          FilterPath;
    HINF                InfFilter;
    HANDLE              SourceFileList;
    HANDLE              NewFilter;
    HANDLE              DeviceFilterList;
    StringList          Overrides;
    StringList          NamedInfList;
    bool                SpecifiedNames;
    StringToStringset   GlobalInfDescriptions;
    StringToStringset   GlobalInfHardwareIds;
    StringToStringset   GlobalOtherInstallSections;
    BasicVerInfo        Version;
    ParseInfContextList LayoutInfs;
    IntToString         GlobalDirectories;
    ReportEntryMap      GlobalErrorFilters;
    FileDispositionMap  FileDispositions;
    FileDispositionMap  GuidDispositions;
    SetupPrivate        SetupAPI;
    StringSet           BuildUnchangedFiles;

public:
    //
    // constructor/destructor/main entry points
    //
    GlobalScan();
    ~GlobalScan();
    int ParseArgs(int argc,char *argv[]);
    int Scan();

private:
    //
    // private functions
    // don't call these within threads
    //
    int ParseVersion(LPCSTR ver);
    int GenerateThreads();
    int StartThreads();
    int FinishThreads();
    int FinishJobs();
    int BuildFinalSourceList();
    int BuildNewInfFilter();
    int BuildDeviceInfMap();
    int LoadFileDispositions();
    int LoadOtherCopySections();
    int LoadListFromFile(const SafeStringA & file,StringList & list);
    int LoadListFromFile(const SafeStringW & file,StringList & list);
    int LoadListFromFile(HANDLE hFile,StringList & list);

public:
    //
    // don't call these within threads
    //
    int AddSourceFiles(StringList & sources);
    int SaveForCrossInfInstallCheck(const SafeString & desc,const SafeString & src);
    int SaveForCrossInfDeviceCheck(const SafeString & hwid,const SafeString & src);
    int CheckCrossInfInstallConflict(const SafeString & desc,const SafeString & src, bool & f,SafeString & other);
    int CheckCrossInfDeviceConflict(const SafeString & hardwareId,const SafeString & src, bool & f,SafeString & others);
    int SetCopySections(const SafeString & filename,const StringSet & sections);

public:
    int ExpandFullPath(const SafeString & subdir,const SafeString & name,SafeString & target);
    int ExpandFullPathWithOverride(const SafeString & name,SafeString & target);
    FileDisposition & GetGuidDisposition(const SafeString & guid);
    FileDisposition & GetFileDisposition(const SafeString & filename);
    int GetCopySections(const SafeString & filename,StringSet & target);
    bool IsFileChanged(const SafeString & file) const;
    JobEntry * GetNextJob();

};

#endif //!_INFSCAN_GLOBALSCAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\infscan.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        infscan.h

Abstract:

    PNF generation and INF Parser class definations

History:

    Created July 2001 - JamieHun

--*/

#ifndef _INFSCAN_INFSCAN_H_
#define _INFSCAN_INFSCAN_H_

class InstallScan;
typedef blob<InstallScan> InstallSectionBlob;
typedef list<InstallSectionBlob> InstallSectionBlobList;
typedef map<SafeString,InstallSectionBlob> StringToInstallSectionBlob;


class PnfGen: public JobItem {
protected:
    SafeString InfName;

protected:
    virtual int Run();

public:
    PnfGen(const SafeString & name);
};

class InfScan: public JobItem {

public:
    bool ThisIsLayoutInf;
    GlobalScan *pGlobalScan;
    StringToString LocalInfDescriptions;
    StringToString LocalInfHardwareIds;
    ParseInfContextMap Infs;
    ParseInfContextBlob PrimaryInf;
    SafeString   FullInfName;
    SafeString   FileNameOnly;
    int     FilterAction;
    SafeString   FilterSection;
    SafeString   GuidFilterSection;
    SafeString   FilterGuid;
    StringList SourceFiles;
    StringSet  DriverSourceCheck;
    StringSet  OtherInstallSections;
    StringSet  PotentialInstallSections;
    StringSet  ModifiedHardwareIds;
    bool HasErrors;
    ReportEntryMap LocalErrorFilters;
    ReportEntryMap LocalErrors;
    StringToInstallSectionBlob UsedInstallSections;
    bool ScanDevices;
    bool HasDependentFileChanged;

public:
    //
    // job callbacks
    //
    virtual int Run();
    virtual int PartialCleanup();
    virtual int PreResults();
    virtual int Results();

protected:
    //
    // internal
    //
    int GenerateFilterInformation();
    int CheckSameInfInstallConflict(const SafeString & desc, const SafeString & sect, bool & f);
    int CheckSameInfDeviceConflict(const SafeString & hwid, const SafeString & sect, bool & f);
    int CheckClassGuid();
    int GetCopySections();
    int CheckCopySections();
    int ProcessCopySections();
    int CheckDriverInf(bool CopyElimination = false);
    int CheckClassInstall(bool CopyElimination);
    int CheckInstallSections(const SafeString & namedSection,DWORD platformMask,const StringList & shadowDecorations,InstallSectionBlobList & sections, bool required,bool CopyElimination);
    int CheckModelsSection(const SafeString & section,const StringList & shadowDecorations,DWORD PlatformMask,bool CopyElimination);
    int CheckCrossInfInstallConflicts();
    int CheckCrossInfDeviceConflicts();
    int PrepareCrossInfInstallCheck();
    int PrepareCrossInfDeviceCheck();
    InstallSectionBlob GetInstallSection(const SafeString & section);

public:
    ParseInfContextBlob & Include(const SafeString & val, bool expandPath = true);
    void Fail(int err,const StringList & errors);
    //
    // alternative Fail's
    //
    void Fail(int err);
    void Fail(int err,const SafeString & one);
    void Fail(int err,const SafeString & one,const SafeString & two);
    void Fail(int err,const SafeString & one,const SafeString & two,const SafeString & three);
    BOOL Pedantic();

public:
    InfScan(GlobalScan *globalScan,const SafeString & infName);
    virtual ~InfScan();
};



#endif //!_INFSCAN_INFSCAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\filters.inl ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        filters.inl

Abstract:

    Filter INF creation/parsing (inlines)

History:

    Created July 2001 - JamieHun

--*/

inline
ReportEntry::ReportEntry()
/*++

Routine Description:

    Initialize ReportEntry instance

--*/
{
    FilterAction = ACTION_DEFAULT;
    hash = 0;
}

inline
ReportEntry::ReportEntry(const StringList & strings) :
                    args(strings)
/*++

Routine Description:

    Initialize ReportEntry instance

Arguments:
    strings - list of error parameters

--*/
{
    //
    // see constructor initializers
    //
    FilterAction = ACTION_DEFAULT;
    CreateHash();
}

inline
ReportEntry::ReportEntry(const ReportEntry & other) :
                    args(other.args),
                    hash(other.hash),
                    FilterAction(other.FilterAction)
/*++

Routine Description:

    Copy-Initialize ReportEntry instance

Arguments:
    other - another ReportEntry to initialize from

--*/
{
    //
    // see constructor initializers
    //
}

inline
void ReportEntry::Initialize(const StringList & strings)
/*++

Routine Description:

    Initialize ReportEntry instance from a list of error strings

Arguments:
    strings - list of error parameters

Return Value:
    NONE

--*/
{
    args = strings;
    CreateHash();
}

inline
void ReportEntry::Initialize(const ReportEntry & other)
/*++

Routine Description:

    Initialize this ReportEntry instance from another ReportEntry instance

Arguments:
    other - another ReportEntry instance

Return Value:
    NONE

--*/
{
    args = other.args;
    hash = other.hash;
    FilterAction = other.FilterAction;
}

inline
unsigned long ReportEntry::GetHash() const
/*++

Routine Description:

    Retrieve hash (a protected value)
    As this routine is const, we can't determine hash
    as a side-effect

Arguments:
    NONE

Return Value:
    current hash value (if initialized)

--*/
{
    return hash;
}

inline
unsigned long ReportEntry::CreateHash()
/*++

Routine Description:

    Determine and retrieve hash
    Hash is always re-determined

Arguments:
    NONE

Return Value:
    new hash value

--*/
{
    StringList::iterator i;
    LPCTSTR ptr;
    hash = 0;
    for(i = args.begin(); i != args.end(); i++) {
        //
        // each new string weighting
        //
        int mult = REPORT_HASH_SMULT;
        for(ptr = i->c_str(); *ptr; ptr++) {
            hash = ((hash * mult) + (*ptr)) % REPORT_HASH_MOD;
            //
            // change to individual character weighting
            //
            mult = REPORT_HASH_CMULT;
        }
    }
    return hash;
}

inline
int ReportEntry::compare(const ReportEntry & other) const
/*++

Routine Description:

    Compare this report entry with another
    a<b implies b>a
    a<b and b<c implies a<c
    Other than predictability, a returned value !=0
    does not imply any real collation order, it's here
    to speed up the binary-tree
    a returned value==0 (a==b) does however imply that
    they are exactly the same.

Arguments:
    A ReportEntry instance to compare against

Return Value:
    -1 implies this<other wrt binary tree sorting
    0  implies this==other
    1  implies this>other wrt binary tree sorting

--*/
{
    //
    // compare the hash's first
    //
    if(hash<other.hash) {
        return -1;
    }
    if(hash>other.hash) {
        return 1;
    }
    //
    // if hashes compare we need to do detailed string compare, perf hit time
    //
    StringList::iterator i,j;
    int comp;
    for(i = args.begin(), j = other.args.begin(); i != args.end(); i++, j++) {
        if(j == other.args.end()) {
            //
            // other ran out of args before this
            // so consider this > other
            //
            return 1;
        }
        SafeString &s = *i;
        SafeString &t = *j;

        comp = s.compare(t);
        //
        // if we have a non-equal compare
        // we can bail now
        //
        if(comp  < 0) {
            return -1;
        }
        if(comp > 0) {
            return 1;
        }
        //
        // if they are equal, continue comparing
        //
    }
    if(j == other.args.end()) {
        //
        // two items compare exactly
        //
        return 0;
    } else {
        //
        // two string matched for all of this's args
        // but other has more args
        // so consider this < other
        //
        return -1;
    }
}

inline
bool ReportEntry::operator<(const ReportEntry & other) const
/*++

Routine Description:

    Redress compare as '<' operator

Arguments:
    A ReportEntry instance to compare against

Return Value:
    true if conceptually this<other
    false otherwise

--*/
{
    return compare(other) < 0 ? true : false;
}

inline
bool ReportEntryBlob::operator<(const ReportEntryBlob & other) const
/*++

Routine Description:

    comparing the blob version is same as comparing the members

Arguments:
    A ReportEntry instance to compare against

Return Value:
    true if conceptually this<other
    false otherwise

--*/
{
    return (*this)->compare(other) < 0 ? true : false;
}

inline
ReportEntrySet::ReportEntrySet()
/*++

Routine Description:

    Initialize ReportEntrySet instance

--*/
{
    FilterAction = ACTION_DEFAULT;
}

inline
FileDisposition::FileDisposition()
/*++

Routine Description:

    Initialize FileDisposition instance

--*/
{
    Filtered = false;
    FilterAction = ACTION_DEFAULT;
}

inline
FileDisposition::FileDisposition(const FileDisposition & other) :
                    Filtered(other.Filtered),
                    FilterAction(other.FilterAction),
                    FileGuid(other.FileGuid),
                    FilterErrorSection(other.FilterErrorSection)
/*++

Routine Description:

    Copy-Initialize FileDisposition instance from another instance

Arguments:
    A ReportEntry instance to initialize with

--*/
{
    //
    // see constructor initializers
    //
}

inline
FileDisposition & FileDisposition::operator = (const FileDisposition & other)
/*++

Routine Description:

    Assignment definition

Arguments:
    A ReportEntry instance to copy from

Return Value:
    *this

--*/
{
    Filtered = other.Filtered;
    FilterAction = other.FilterAction;
    FileGuid = other.FileGuid;
    FilterErrorSection = other.FilterErrorSection;

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\infscan.inl ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        infscan.inl

Abstract:

    PNF generation and INF Parser functions (inlines)

History:

    Created July 2001 - JamieHun

--*/

inline PnfGen::PnfGen(const SafeString & name)
{
    InfName = name;
}

inline void InfScan::Fail(int err)
{
    StringList errors;
    Fail(err,errors);
}
inline void InfScan::Fail(int err,const SafeString & one)
{
    StringList errors;
    errors.push_back(one);
    Fail(err,errors);
}
inline void InfScan::Fail(int err,const SafeString & one,const SafeString & two)
{
    StringList errors;
    errors.push_back(one);
    errors.push_back(two);
    Fail(err,errors);
}
inline void InfScan::Fail(int err,const SafeString & one,const SafeString & two,const SafeString & three)
{
    StringList errors;
    errors.push_back(one);
    errors.push_back(two);
    errors.push_back(three);
    Fail(err,errors);
}

inline BOOL InfScan::Pedantic()
{
    return pGlobalScan->Pedantic;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\installscan.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

For Internal use only!

Module Name:

    INFSCAN
        installscan.cpp

Abstract:

    Individual install section scanner class
    main entry point InfScan::ScanInstallSection

    WARNING! WARNING!
    All of this implementation relies on intimate knowledge of
    SetupAPI's SETUPAPI!SetupInstallFromInfSection
    It is re-implemented here for speed due to having to process
    700+ INF's in a single go at the cost of having to maintain
    this.

    DO NOT (I repeat) DO NOT re-implement the code here without
    consultation with SetupAPI owner.

History:

    Created July 2001 - JamieHun

--*/

#include "precomp.h"
#pragma hdrstop

InstallScan::InstallScan()
/*++

Routine Description:

    Initialization

--*/
{
    pGlobalScan = NULL;
    pInfScan = NULL;
    PlatformMask = 0;
    pTargetDirectory = NULL;
    NotDeviceInstall = false;
    HasDependentFileChanged = false;
}

InstallScan::~InstallScan()
/*++

Routine Description:

    Cleanup allocated data/handles

--*/
{
}

void InstallScan::AddHWIDs(const StringSet & hwids)
/*++

Routine Description:

    Add to list of HWIDs effected by this section

--*/
{
    StringSet::iterator i;
    for(i = hwids.begin(); i != hwids.end(); i++) {
        HWIDs.insert(*i);
    }
}

void InstallScan::GetHWIDs(StringSet & hwids)
/*++

Routine Description:

    Retrieve list of HWIDs effected by this section

--*/
{
    StringSet::iterator i;
    for(i = HWIDs.begin(); i != HWIDs.end(); i++) {
        hwids.insert(*i);
    }
}

int
InstallScan::ScanInstallSection()
/*++

Routine Description:

    Main entry point for processing an install section

    WARNING! tightly coupled with SetupAPI implementation that could change
    MAINTAINANCE: keep this in step with supported Needs/nesting syntax
    MAINTAINANCE: keep in step with install processing

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    int res;

    //
    // prime initial list of search INF's
    //
    Layouts();

    int count = 1; // no more than 1
    res = RecurseKeyword(Section,TEXT("Include"),IncludeCallback,count);
    if(res != 0) {
        return res;
    }
    if(count<0) {
        Fail(MSG_MULTIPLE_INCLUDE,Section);
    } else if(Pedantic() && (count<1)) {
        Fail(MSG_INCLUDE,Section);
    }

    count = 1; // no more than 1
    res = RecurseKeyword(Section,TEXT("Needs"),NeedsCallback,count);
    if(res != 0) {
        return res;
    }
    if(count<0) {
        Fail(MSG_MULTIPLE_NEEDS,Section);
    } else if(Pedantic() && (count<1)) {
        Fail(MSG_NEEDS,Section);
    }

    return CheckInstallSubSection(Section);
}


int
InstallScan::RecurseKeyword(const SafeString & sect,const SafeString & keyword,RecurseKeywordCallback callback,int & count)
/*++

Routine Description:

    Section parsing workhorse
    WARNING! Uses knowledge about how SetupAPI searches INF lists, could change
    MAINTAINANCE: Keep search algorithm in step with SetupAPI
    see aslo QuerySourceFile, GetLineCount and DoesSectionExist

    given keyword = val[,val...]
    each value is converted to lower-case and callback is called with information
    about what inf/section the value is in.

Arguments:
    sect        - name of section to search
    keyword     - name of keyword
    callback    - callback function for each hit
    count       - must be initialized to max # of callbacks to invoke
                - returns -1 if there are more entries than wanted

Return Value:
    0 on success

--*/
{
    INFCONTEXT context;
    int res;
    int i;
    SafeString value;

    //
    // we didn't call SetupOpenAppendInf for any INF's, so instead
    // enumerate all "included inf's" using our view of the world
    // this allows us to reset our view for each install section
    // to validate include/needs processing
    //
    ParseInfContextList::iterator AnInf;
    for(AnInf = InfSearchList.begin(); AnInf != InfSearchList.end(); AnInf++) {
        ParseInfContextBlob & TheInf = *AnInf;
        if(TheInf->InfHandle == INVALID_HANDLE_VALUE) {
            //
            // a fail-loaded inf
            //
            continue;
        }
        if(!SetupFindFirstLine(TheInf->InfHandle,sect.c_str(),keyword.c_str(),&context)) {
            //
            // can't find (keyword in) section in this inf
            //
            continue;
        }

        do {
            if(count>=0) {
                count--;
                if(count<0) {
                    return 0;
                }
            }
            for(i=1;MyGetStringField(&context,i,value);i++) {
                res = (this->*callback)(TheInf,sect,keyword,value);
                if(res != 0) {
                    return res;
                }
            }

        } while (SetupFindNextMatchLine(&context,keyword.c_str(),&context));
    }

    return 0;
}

int
InstallScan::IncludeCallback(ParseInfContextBlob & TheInf,const SafeString & sect,const SafeString & keyword,const SafeString & val)
/*++

Routine Description:

    Callback for "INCLUDE" processing
    Add INF to the search-list

    MAINTAINANCE: keep this in step with supported Include/nesting syntax

Arguments:
    TheInf      - INF that the include was found in
    sect        - section that the include was found in
    keyword     - "INCLUDE"
    val         - name of INF to include

Return Value:
    0 on success

--*/
{
    if(!val.length()) {
        return 0;
    }

    //
    // simply 'append' the INF
    //
    return Include(val);
}

int
InstallScan::NeedsCallback(ParseInfContextBlob & TheInf,const SafeString & sect,const SafeString & keyword,const SafeString & val)
/*++

Routine Description:

    Callback for "NEEDS" processing
    process the specified needed section

    MAINTAINANCE: keep this in step with supported Needs/nesting syntax

Arguments:
    TheInf      - INF that the needs was found in
    sect        - section that the needs was found in
    keyword     - "NEEDS"
    val         - name of section to process

Return Value:
    0 on success

--*/
{
    if(!val.length()) {
        return 0;
    }

    INFCONTEXT context;
    //
    // concerning if section doesn't exist
    //
    if(!DoesSectionExist(val)) {
        Fail(MSG_NEEDS_NOSECT,sect,val);
        return 0;
    }

    //
    // catch recursive includes/needs
    // set want-count to zero so we don't actually recurse
    // (we need to use RecurseKeyword to ensure correct searching)
    //
    int res;
    int count = 0; // no more than zero (query)
    res = RecurseKeyword(val,TEXT("Include"),IncludeCallback,count);
    if(res != 0) {
        return res;
    }
    if(count<0) {
        Fail(MSG_RECURSIVE_INCLUDE,sect,val);
    }

    count = 0; // no more than zero (query)
    res = RecurseKeyword(val,TEXT("Needs"),NeedsCallback,count);
    if(res != 0) {
        return res;
    }
    if(count<0) {
        Fail(MSG_RECURSIVE_NEEDS,sect,val);
    }

    return CheckInstallSubSection(val);
}


int InstallScan::CheckInstallSubSection(const SafeString & section)
/*++

Routine Description:

    Effectively SetupInstallInfSection
    Processed for primary and each needed section

    WARNING! tightly coupled with SetupAPI implementation that could change
    MAINTAINANCE: keep in step with install processing

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    int res;

    res = CheckCopyFiles(section);
    if(res != 0) {
        return res;
    }
    return 0;
}

int InstallScan::CheckCopyFiles(const SafeString & section)
/*++

Routine Description:

    Process CopyFiles entries in install section

    WARNING! tightly coupled with SetupAPI implementation that could change
    MAINTAINANCE: keep in step with CopyFiles processing

Arguments:
    section     - section to check for CopyFiles= entries

Return Value:
    0 on success

--*/
{
    //
    // enumerate all CopyFiles entries in this section
    //
    int count = -1; // there can be any # of CopyFiles keywords in a section
    return RecurseKeyword(section,TEXT("CopyFiles"),CopyFilesCallback,count);
}

int
InstallScan::CopyFilesCallback(ParseInfContextBlob & TheInf,const SafeString & section,const SafeString & keyword,const SafeString & val)
/*++

Routine Description:

    Process CopyFiles entries in install section (callback)

    WARNING! tightly coupled with SetupAPI implementation that could change
    MAINTAINANCE: keep in step with CopyFiles processing
    MAINTAINANCE: keep in step with CopyFiles section syntax
    MAINTAINANCE: keep in step with DestinationDirs section syntax

Arguments:
    TheInf      - INF that the needs was found in
    sect        - section that the needs was found in
    keyword     - "CopyFiles"
    val         - section or @file

Return Value:
    0 on success

--*/
{
    if(!val.length()) {
        return 0;
    }
    //
    // a single copy-files section entry
    //
    INFCONTEXT context;
    int res;
    bool FoundAny = false;

    if(val[0] == TEXT('@')) {
        //
        // immediate copy, use default target as specified in context inf
        //
        SafeString source = val.substr(1);
        return CheckSingleCopyFile(TheInf,TheInf->GetDefaultTargetDirectory(),source,source,section);
    }
    //
    // interpret as a section, we need to enumerate through all the INF's
    // that have this particular copy section
    //
    ParseInfContextList::iterator AnInf;
    for(AnInf = InfSearchList.begin(); AnInf != InfSearchList.end(); AnInf++) {
        ParseInfContextBlob & TheCopyInf = *AnInf;
        if(TheCopyInf->InfHandle == INVALID_HANDLE_VALUE) {
            //
            // a fail-loaded inf
            //
            continue;
        }
        DWORD flgs = TheCopyInf->DoingCopySection(val,PlatformMask);
        if(flgs!=0) {
            //
            // we have already done this copy section in this INF
            //
            if(flgs != (DWORD)(-1)) {
                FoundAny = true;
                if(flgs & PLATFORM_MASK_MODIFIEDFILES) {
                    //
                    // hint that one of the files in this copy section
                    // was determined to be modified
                    //
                    HasDependentFileChanged = true;
                }
            }
            continue;
        }
        //
        // section contains multiple copy-files
        //
        if(!SetupFindFirstLine(TheCopyInf->InfHandle,val.c_str(),NULL,&context)) {
            if(SetupGetLineCount(TheCopyInf->InfHandle, val.c_str()) != 0) {
                //
                // make a note that this inf doesn't have this copy section
                //
                TheCopyInf->NoCopySection(val);
            } else {
                FoundAny = true;
            }
            continue;
        }

        //
        // we've found copy section inside TheCopyInf that we haven't
        // previously processed for this platform
        //
        FoundAny = true;

        //
        // determine target directory for this copy section
        // this must be in same inf as copy section
        //
        TargetDirectoryEntry *pTargDir = TheCopyInf->GetTargetDirectory(val);

        SafeString target;
        SafeString source;
        //
        // enumerate through each <desc> = <install>
        //
        do {
            //
            // each line consists of <target>[,<src>]
            //
            if(!MyGetStringField(&context,1,target) || !target.length()) {
                continue;
            }
            if(!MyGetStringField(&context,2,source) || !source.length()) {
                source = target;
            }
            //
            // source/target always in lower-case to aid comparisons
            //
            res = CheckSingleCopyFile(TheCopyInf,pTargDir,target,source,val);
            if(res != 0) {
                return res;
            }

        } while(SetupFindNextLine(&context,&context));

    }
    if(!FoundAny) {
        Fail(MSG_MISSING_COPY_SECTION,val,section);
    }

    return 0;
}

int InstallScan::CheckSingleCopyFile(ParseInfContextBlob & TheInf,TargetDirectoryEntry *pTargDir,const SafeString & target,const SafeString & source,const SafeString & section)
/*++

Routine Description:

    Process a single CopyFile entry (either immediate or not)

    WARNING! tightly coupled with SetupAPI implementation that could change
    MAINTAINANCE: keep in step with CopyFiles processing
    MAINTAINANCE: keep in step with CopyFiles section syntax

Arguments:
    TheInf      -  Inf that the copy section is in
    pTargDir    -  relevent target directory entry for this copy
    target      -  name of target file
    source      -  name of source file
    section     -  name of copyfiles section, or of install section

Return Value:
    0 on success

--*/
{
    if(!target.length()) {
        return 0;
    }
    if(!source.length()) {
        return 0;
    }
    //
    // this is a single copy target/source entry
    //
    // need to lookup file in SourceDisksFiles
    // for matching platform
    //
    // for each file, need to
    // (1) queue source name
    // (2) textmode & guimode validate target
    //
    SourceDisksFilesList sources;
    int res = QuerySourceFile(TheInf,section,source,sources);
    if(res != 0) {
        return res;
    }
    if(!sources.size()) {
        return 0;
    }

    SafeString destdir;
    if(pGlobalScan->TargetsToo) {
        int IsDriverFile = NotDeviceInstall ? 0 : 1;
        if(IsDriverFile) {
            //
            // make a special note that we determined at least once that this is a driver file
            // wrt this primary INF
            // (this saves us reporting that file is and is not a driver file for a given inf)
            //
            pInfScan->DriverSourceCheck.insert(source);
        } else if(pInfScan->DriverSourceCheck.find(source) != pInfScan->DriverSourceCheck.end()) {
            IsDriverFile = 1; // we found this to be a driver fill during driver pass
        }
        //
        // we want a more detailed output for further analysis
        // or import into database
        //
        basic_ostringstream<TCHAR> line;
        //
        // source name
        //
        line << QuoteIt(source);
        //
        // target location
        //
        if(pTargDir) {
            line << TEXT(",") << pTargDir->DirId
                 << TEXT(",") << QuoteIt(pTargDir->SubDir);
        } else {
            line << TEXT(",,");
        }
        //
        // final name and if this appears to be a driver file or not
        //
        line << TEXT(",") << QuoteIt(target)
             << TEXT(",") << (NotDeviceInstall ? TEXT("0") : TEXT("1"));
        //
        // report primary INF
        //
        line << TEXT(",") << QuoteIt(GetFileNamePart(pInfScan->PrimaryInf->InfName));
        if(!IsDriverFile) {
            //
            // if this doesn't appear to be a driver file, report install section
            //
            line << TEXT(",") << QuoteIt(Section);
        }
        pInfScan->SourceFiles.push_back(line.str());
    } else {
        //
        // just source will do
        //
        pInfScan->SourceFiles.push_back(source);
    }
    if((pGlobalScan->BuildChangedDevices & BUILD_CHANGED_DEVICES_DEPCHANGED)
       && !pInfScan->HasDependentFileChanged
       && pGlobalScan->IsFileChanged(source)) {
        HasDependentFileChanged = true;
        //
        // since we only do a copy section once, we need to make the copy section
        // 'dirty' so next time we reference section out of here
        //
        TheInf->DoingCopySection(section,PLATFORM_MASK_MODIFIEDFILES);
    }
    if(pGlobalScan->IgnoreErrors) {
        //
        // if not interested in checking errors
        // we're done
        //
        return 0;
    }

    SourceDisksFilesList::iterator i;
    for(i = sources.begin(); i != sources.end(); i++) {
        i->Used = true;
        if((i->UpgradeDisposition != 3) || (i->TextModeDisposition != 3)) {
            //
            // need to do a consistency check
            //
            if(!pTargDir) {
                //
                // error already reported (?)
                //
                continue;
            }
            if(pTargDir->DirId != 10) {
                //
                // DirId should be 10 or normalized off 10
                //
                Fail(MSG_TEXTMODE_TARGET_MISMATCH,section,source);
                continue;
            }
            if(!i->TargetDirectory) {
                //
                // error already reported
                //
                continue;
            }
            IntToString::iterator gd = pGlobalScan->GlobalDirectories.find(i->TargetDirectory);
            if(gd == pGlobalScan->GlobalDirectories.end()) {
                //
                // no textmode subdir for specified dir
                //
                Fail(MSG_TEXTMODE_TARGET_UNKNOWN,section,source);
                continue;
            }
            SafeString gm_target = PathConcat(pTargDir->SubDir,target);
            SafeString tm_target = PathConcat(gd->second,i->TargetName.length() ? i->TargetName : source);
            if(gm_target.compare(tm_target)!=0) {
                Fail(MSG_TEXTMODE_TARGET_MISMATCH,section,source);
                continue;
            }
            //
            // get here, user-mode and text-mode match
            //
        }
    }

    return 0;
}

int InstallScan::Include(const SafeString & name)
/*++

Routine Description:

    Process a single Include entry

    WARNING! tightly coupled with SetupAPI implementation that could change
    MAINTAINANCE: keep in step with INCLUDE processing

Arguments:
    name        -  argument passed into INCLUDE

Return Value:
    0 on success

--*/
{
    //
    // nested include
    //
    if(Included.find(name) == Included.end()) {
        //
        // first time this install section has come across this file
        //
        Included.insert(name); // so we don't try to re-load
        ParseInfContextBlob & ThisInf = pInfScan->Include(name,true);
        InfSearchList.push_back(ThisInf);
    }
    return 0;
}

int InstallScan::Layouts()
/*++

Routine Description:

    Prime search list with primary inf and list of layout files

    WARNING! tightly coupled with SetupAPI implementation that could change
    MAINTAINANCE: keep in step with LAYOUT processing
    DISCREPENCY: layout files list currently limited to layout.inf

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    //
    // start the search list with the default inf
    //
    Included.insert(pInfScan->PrimaryInf->InfName);
    InfSearchList.push_back(pInfScan->PrimaryInf);
    //
    // start the search list with layout inf's
    //
    // we can do this with pGlobalScan as the data is readable but not modified
    // there is an interlocked dependency on multi-processors
    //
    ParseInfContextList::iterator i;
    for(i = pGlobalScan->LayoutInfs.begin(); i != pGlobalScan->LayoutInfs.end(); i++) {
        Included.insert((*i)->InfName); // so we don't try to re-load
        InfSearchList.push_back(*i); // interlocked dependency
    }
    return 0;
}

int InstallScan::QuerySourceFile(ParseInfContextBlob & TheInf,const SafeString & section,const SafeString & source,SourceDisksFilesList & Target)
/*++

Routine Description:

    Determine list of possible source entries for given source file
    This can be zero (bad layout)
    1 (typical)
    >1 (multiple targets)

Arguments:
    TheInf - INF of the copy section, or install section
    section - name of the copy section or install section (for error reporting only)
    source - name of source file
    Target - returned list of source media information

Return Value:
    0 on success

--*/
{
    int res =0;
    Target.clear();
    //
    // return list of entries matching source file
    //

    DWORD platforms = pGlobalScan->Version.PlatformMask & PlatformMask & (PLATFORM_MASK_NT|PLATFORM_MASK_WIN);

    //
    // attempt to search within context of specified inf
    //
    res = TheInf->QuerySourceFile(platforms,section,source,Target);
    if(res != 0) {
        if(res<0) {
            //
            // non-fatal
            //
            res = 0;
        }
        return res;
    }
    if(Target.empty()) {
        //
        // now attempt to search within context of any inf's
        //
        ParseInfContextList::iterator AnInf;
        for(AnInf = InfSearchList.begin(); AnInf != InfSearchList.end(); AnInf++) {
            ParseInfContextBlob & TheLayoutInf = *AnInf;
            if(TheLayoutInf->InfHandle == INVALID_HANDLE_VALUE) {
                //
                // a fail-loaded inf
                //
                continue;
            }
            res = TheLayoutInf->QuerySourceFile(platforms,section,source,Target);
            if(res != 0) {
                if(res<0) {
                    //
                    // non-fatal
                    //
                    res = 0;
                }
                return res;
            }
            if(!Target.empty()) {
                //
                // found a hit
                //
                break;
            }
        }
    }
    if(Target.empty()) {
        //
        // not found
        //
        Fail(MSG_SOURCE_NOT_LISTED,section,source);
        return 0;
    }

    return 0;
}

LONG InstallScan::GetLineCount(const SafeString & section)
/*++

Routine Description:

    Simulates SetupGetLineCount
    WARNING! Uses knowledge about how SetupAPI searches INF lists, could change
    MAINTAINANCE: Keep search algorithm in step with SetupAPI
    reference RecurseKeyword

Arguments:
    section        - name of section to count

Return Value:
    # of lines or -1 if no sections found

--*/
{
    INFCONTEXT context;
    int res;
    int i;
    SafeString value;
    LONG count = -1;

    ParseInfContextList::iterator AnInf;
    for(AnInf = InfSearchList.begin(); AnInf != InfSearchList.end(); AnInf++) {
        ParseInfContextBlob & TheInf = *AnInf;
        if(TheInf->InfHandle == INVALID_HANDLE_VALUE) {
            //
            // a fail-loaded inf
            //
            continue;
        }

        LONG actcount = SetupGetLineCount(TheInf->InfHandle,section.c_str());
        if(actcount >= 0) {
            if(count<=0) {
                count = actcount;
            } else {
                count += actcount;
            }
        }
    }

    return 0;

}

bool InstallScan::DoesSectionExist(const SafeString & section)
/*++

Routine Description:

    Optimally simulates "SetupGetLineCount()>=0"

    WARNING! Uses knowledge about how SetupAPI searches INF lists, could change
    MAINTAINANCE: Keep search algorithm in step with SetupAPI
    reference SetupGetLineCount and RecurseKeyword

Arguments:
    section        - name of section to count

Return Value:
    true if named section exists

--*/
{
    //
    // optimized version of (GetLineCount(section)>=0)
    //
    INFCONTEXT context;
    int res;
    int i;
    SafeString value;

    ParseInfContextList::iterator AnInf;
    for(AnInf = InfSearchList.begin(); AnInf != InfSearchList.end(); AnInf++) {
        ParseInfContextBlob & TheInf = *AnInf;
        if(TheInf->InfHandle == INVALID_HANDLE_VALUE) {
            //
            // a fail-loaded inf
            //
            continue;
        }

        LONG actcount = SetupGetLineCount(TheInf->InfHandle,section.c_str());
        if(actcount >= 0) {
            return true;
        }
    }

    return false;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\parseinfctx.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        parseinfctx.h

Abstract:

    Context about a particular loaded INF

History:

    Created July 2001 - JamieHun

--*/

#ifndef _INFSCAN_PARSEINFCTX_H_
#define _INFSCAN_PARSEINFCTX_H_

class ParseInfContext {
public:
    GlobalScan *pGlobalScan;
    InfScan *pInfScan;
    SafeString InfName;
    HINF InfHandle;
    bool LooksLikeLayoutInf;
    bool Locked;
    bool HasDependentFileChanged;
    CopySectionToTargetDirectoryEntry DestinationDirectories;
    StringToSourceDisksFilesList SourceDisksFiles;
    CopySectionToTargetDirectoryEntry::iterator DefaultTargetDirectory;
    StringToInt CompletedCopySections;

public:
    ParseInfContext();
    ~ParseInfContext();
    TargetDirectoryEntry * GetDefaultTargetDirectory();
    TargetDirectoryEntry * GetTargetDirectory(const SafeString & section);
    void PartialCleanup();
    int Init(const SafeString & name);
    int LoadSourceDisksFiles();
    int LoadSourceDisksFilesSection(DWORD platform,const SafeString & section);
    int LoadDestinationDirs();
    int LoadWinntDirectories(IntToString & Target);
    int QuerySourceFile(DWORD platforms,const SafeString & section,const SafeString & source,SourceDisksFilesList & Target);
    DWORD DoingCopySection(const SafeString & section,DWORD platforms);
    void NoCopySection(const SafeString & section);
};

typedef blob<ParseInfContext> ParseInfContextBlob;
typedef map<SafeString,ParseInfContextBlob> ParseInfContextMap;
typedef list<ParseInfContextBlob> ParseInfContextList;


#endif //!_INFSCAN_PARSEINFCTX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\precomp.cpp ===
#include "precomp.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\installscan.inl ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        installscan.inl

Abstract:

    Install section scanning functions (inline)

History:

    Created July 2001 - JamieHun

--*/

//
// redirected
//
inline void InstallScan::Fail(int err,const StringList & errors)
{
    if(pInfScan) {
        pInfScan->Fail(err,errors);
    }
}

inline void InstallScan::Fail(int err)
{
    StringList errors;
    Fail(err,errors);
}

inline void InstallScan::Fail(int err,const SafeString & one)
{
    StringList errors;
    errors.push_back(one);
    Fail(err,errors);
}

inline void InstallScan::Fail(int err,const SafeString & one,const SafeString & two)
{
    StringList errors;
    errors.push_back(one);
    errors.push_back(two);
    Fail(err,errors);
}

inline void InstallScan::Fail(int err,const SafeString & one,const SafeString & two,const SafeString & three)
{
    StringList errors;
    errors.push_back(one);
    errors.push_back(two);
    errors.push_back(three);
    Fail(err,errors);
}

inline BOOL InstallScan::Pedantic()
{
     return pGlobalScan->Pedantic;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\parseinfctx.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

For Internal use only!

Module Name:

    INFSCAN
        parseinfctx.cpp

Abstract:

    Information about an individual INF (either primary INF
    being parsed by InfScan or a secondary included INF)

    WARNING! WARNING!
    All of this implementation relies on intimate knowledge of
    SetupAPI/TextMode Setup/GuiMode Setup parsing of INF files.

    It is re-implemented here for speed due to having to process
    700+ INF's in a single go at the cost of having to maintain
    this.

    DO NOT (I repeat) DO NOT re-implement the code here without
    consultation with SetupAPI owner.

History:

    Created July 2001 - JamieHun

--*/

#include "precomp.h"
#pragma hdrstop

int ParseInfContext::LoadSourceDisksFiles()
/*++

Routine Description:

    Determine all source media information (as of right now, we don't need
    target disk information)
    Build a per-file list of possible media/platform information
    MAINTAINANCE: Keep in step with SourceDisksFiles syntax and decorations

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    static StringProdPair decorations[] = {
        //
        // listed from most specific to most generic
        //
        { TEXT("SourceDisksFiles.x86"),    PLATFORM_MASK_NTX86          },
        { TEXT("SourceDisksFiles.ia64"),   PLATFORM_MASK_NTIA64         },
        { TEXT("SourceDisksFiles.amd64"),  PLATFORM_MASK_NTAMD64        },
        { TEXT("SourceDisksFiles"),        PLATFORM_MASK_ALL_ARCHITECTS },
        { NULL, 0 }
    };

    INFCONTEXT context;
    int i;
    DWORD platforms = pGlobalScan->Version.PlatformMask & (PLATFORM_MASK_NT|PLATFORM_MASK_WIN);
    int res;


    for(i=0;decorations[i].String;i++) {
        DWORD plat = platforms & decorations[i].ProductMask;
        if(plat) {
            res = LoadSourceDisksFilesSection(plat,decorations[i].String);
            if(res != 0) {
                return res;
            }
        }
    }

    return 0;
}

int ParseInfContext::LoadSourceDisksFilesSection(DWORD platform,const SafeString & section)
/*++

Routine Description:

    Helper function for LoadSourceDisksFiles
    loading information for a specific (decorated) section

Arguments:
    platform - specific platform or platforms that section is valid for
    section  - section to load

Return Value:
    0 on success

--*/
{
    //
    // see if specified section exists
    // load section into TargetList of same name
    //
    INFCONTEXT context;

    if(!SetupFindFirstLine(InfHandle,section.c_str(),NULL,&context)) {
        return 0;
    }
    do {
        SafeString filename;
        SafeString name;
        if(!MyGetStringField(&context,0,filename) || filename.empty()) {
            pInfScan->Fail(MSG_BAD_FILENAME_ENTRY,section);
            continue;
        }
        SourceDisksFilesEntry entry;
        entry.Used = FALSE;
        entry.Platform = platform;
        if(!SetupGetIntField(&context,1,&entry.DiskId)) {
            pInfScan->Fail(MSG_BAD_FILENAME_DISK,section,filename);
            continue;
        }
        if(MyGetStringField(&context,2,name) && name.length()) {
            entry.SubDir = name;
        }
        if(!SetupGetIntField(&context,8,&entry.TargetDirectory)) {
            entry.TargetDirectory = 0;
        }
        if(!SetupGetIntField(&context,9,&entry.UpgradeDisposition)) {
            entry.UpgradeDisposition = 3;
        } else if((entry.UpgradeDisposition == 0) && MyGetStringField(&context,9,name) && name.empty()) {
            //
            // actually empty field
            //
            entry.UpgradeDisposition = 3;
        }
        if(!SetupGetIntField(&context,10,&entry.TextModeDisposition)) {
            entry.TextModeDisposition = 3;
        } else if((entry.TextModeDisposition == 0) && MyGetStringField(&context,10,name) && name.empty()) {
            //
            // actually empty field
            //
            entry.TextModeDisposition = 3;
        }
        if(MyGetStringField(&context,11,name) && name.length()) {
            entry.TargetName = name;
        }
        if((entry.UpgradeDisposition != 3) || (entry.TextModeDisposition != 3)) {
            if(entry.TargetDirectory) {
                LooksLikeLayoutInf = TRUE;
            } else {
                pInfScan->Fail(MSG_TEXTMODE_DISPOSITION_MISSING_DIR,section,filename);
            }
        }
        //
        // is this a completely new entry for this file?
        //
        StringToSourceDisksFilesList::iterator sdfl = SourceDisksFiles.find(filename);
        if(sdfl == SourceDisksFiles.end()) {
            //
            // never come across this name before (typical case)
            //
            SourceDisksFilesList blankList;
            sdfl = SourceDisksFiles.insert(sdfl,StringToSourceDisksFilesList::value_type(filename,blankList));
            SourceDisksFilesList & list = sdfl->second;
            list.push_back(entry);
        } else {
            //
            // there's already an entry for this filename
            // see if this is an alternate location/info
            //
            SourceDisksFilesList & list = sdfl->second;
            SourceDisksFilesList::iterator i;
            BOOL conflict = FALSE;
            BOOL duplicate = FALSE;
            for(i = list.begin(); i != list.end(); i++) {
                //
                // existing entries
                //
                SourceDisksFilesEntry & e = *i;
                //
                // test numerics first then strings
                //
                if(entry.DiskId == e.DiskId &&
                        entry.TargetDirectory == e.TargetDirectory &&
                        entry.TextModeDisposition == e.TextModeDisposition &&
                        entry.UpgradeDisposition == e.UpgradeDisposition &&
                        entry.SubDir == e.SubDir &&
                        entry.TargetName == e.TargetName) {
                    //
                    // already listed
                    //
                    duplicate = TRUE;
                    break;
                }
                //
                // the existing entry might be more specific than what we have
                // eg, specific ia64, generic everything else
                // so remove the flags from existing entry from mask
                //
                entry.Platform &= ~ e.Platform;
                if(pInfScan->Pedantic()) {
                    conflict = TRUE;
                }
            }
            if (duplicate) {
                //
                // duplicate/compatible entry listed
                //
                i->Platform |= entry.Platform;
            } else {
                //
                // no duplicate or compatible
                //
                if (conflict) {
                    //
                    // different source listings for different platforms
                    // might be an error
                    //
                    pInfScan->Fail(MSG_SOURCE_CONFLICT,section,filename);
                }
                list.push_back(entry);
            }
        }

    } while (SetupFindNextLine(&context,&context));
    return 0;
}

int ParseInfContext::QuerySourceFile(DWORD platforms,const SafeString & section,const SafeString & source,SourceDisksFilesList & Target)
/*++

Routine Description:

    See also InstallScan::QuerySourceFile
    Determine list of possible source entries for given source file
    This can be zero (bad layout)
    1 (typical)
    >1 (multiple targets)
    WARNING! This shadows SetupAPI implementation always subject to change
    MAINTAINANCE: keep in step with SetupAPI

Arguments:
    platforms - bitmap list of platforms we're interested in
    section - name of the copy section or install section (for error reporting only)
    source - name of source file
    Target - returned list of source media information

Return Value:
    0 on success

--*/
{
    //
    // return list of entries matching source file
    //

    StringToSourceDisksFilesList::iterator sdfl = SourceDisksFiles.find(source);

    if(sdfl == SourceDisksFiles.end()) {
        //
        // not found
        // don't fail here, caller will try a few more alternatives
        //
        return 0;
    }

    SourceDisksFilesList & list = sdfl->second;
    SourceDisksFilesList::iterator i;

    for(i = list.begin(); i != list.end(); i++) {
        //
        // existing entries
        //
        SourceDisksFilesEntry & e = *i;
        if ((e.Platform & platforms) == 0) {
            continue;
        }
        Target.push_back(e);
    }

    if(!Target.size()) {
        pInfScan->Fail(MSG_SOURCE_NOT_LISTED_PLATFORM,section,source);
        //
        // indicate we errored out
        //
        return -1;
    }

    return 0;
}

int ParseInfContext::LoadWinntDirectories(IntToString & Target)
/*++

Routine Description:

    Load the Layout.INF specific [WinntDirectories]
    to aid in textmode vs setupapi consistency
    WARNING! This relies heavily on current textmode implementation subject to change
    MAINTAINANCE: Keep in step with textmode

Arguments:
    Target  - initialized with <id> to <subdirectory> mapping

Return Value:
    0 on success

--*/
{
    if(pGlobalScan->IgnoreErrors && !pGlobalScan->TargetsToo) {
        //
        // don't bother if we're not interested in errors
        // (unless we want target information)
        //
        return 0;
    }
    INFCONTEXT context;

    if(!SetupFindFirstLine(InfHandle,TEXT("WinntDirectories"),NULL,&context)) {
        return 0;
    }
    do {
        int index;
        TCHAR path[MAX_PATH];
        if(SetupGetIntField(&context,0,&index) && index) {
            if(!SetupGetStringField(&context,1,path,MAX_PATH,NULL) || !path[0]) {
                continue;
            }
            _tcslwr(path);
            IntToString::iterator i = Target.find(index);
            if(i == Target.end()) {
                Target[index] = path;
            } else {
                if(i->second.compare(path)!=0) {
                    //
                    // mismatch
                    //
                    pInfScan->Fail(MSG_WINNT_DIRECTORY_CONFLICT,i->second,path);
                }
            }
        }
    } while (SetupFindNextLine(&context,&context));
    return 0;
}

int ParseInfContext::LoadDestinationDirs()
/*++

Routine Description:

    Load the [DestinationDirs]
    Also uses pGlobalScan->GlobalDirectories to remap certain ID's
    WARNING! This relies heavily on current SetupAPI and textmode implementations subject to change
    MAINTAINANCE: Keep in step with textmode vs SetupAPI directory ID's

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    if(pGlobalScan->IgnoreErrors && !pGlobalScan->TargetsToo) {
        //
        // don't bother if we're not interested in errors
        // (unless we want target information)
        //
        return 0;
    }
    INFCONTEXT context;

    if(!SetupFindFirstLine(InfHandle,TEXT("DestinationDirs"),NULL,&context)) {
        return 0;
    }

    //
    //
    // MAINTAINANCE:
    // this table needs to correlate to LAYOUT.INX
    //
    // process [DestinationDirs] if there is one
    // <section> = dirid,subdir
    //
    // normalize following dirid's:
    // 10,subdir - as is
    // 11,subdir - 10,system32\subdir
    // 12,subdir - 10,system32\drivers\subdir
    // 17,subdir - 10,inf\subdir
    // 18,subdir -

    TCHAR section[LINE_LEN];
    int dirid = 0;
    TCHAR subdir[MAX_PATH];
    int global_equiv[] = {
        0,0,0,0,0,0,0,0,0,0,0, // 0-10
        2,          // 11 - system32
        4,          // 12 - system32/drivers
        0,0,0,0,    // 13-16
        20,         // 17 - inf
        21,         // 18 - help
        0,          // 19
        22,         // 20 - fonts
        0
    };

    do {
        int index;
        TCHAR path[MAX_PATH];
        if(!SetupGetStringField(&context,0,section,LINE_LEN,NULL) || !section[0]) {
            continue;
        }
        _tcslwr(section);
        if(!SetupGetIntField(&context,1,&dirid) || dirid == 0) {
            pInfScan->Fail(MSG_DIRID_NOT_SPECIFIED,section);
            dirid = 0;
        }
        if(!SetupGetStringField(&context,2,subdir,MAX_PATH,NULL)) {
            subdir[0] = TEXT('\0');
        }
        _tcslwr(subdir);
        TargetDirectoryEntry entry;
        entry.Used = false;
        entry.DirId = dirid;
        entry.SubDir = subdir;
        //
        // certain dirid have a global equiv, remap
        //
        if(dirid>0 && dirid < ASIZE(global_equiv)) {
            int equiv = global_equiv[dirid];
            if(equiv) {
                IntToString::iterator i = pGlobalScan->GlobalDirectories.find(equiv);
                if(i != pGlobalScan->GlobalDirectories.end()) {
                    //
                    // we have a mapping relative to dirID 10.
                    //
                    entry.DirId = 10;
                    entry.SubDir = PathConcat(i->second,subdir);
                }
            }
        }
        //
        // make a note
        //
        DestinationDirectories[section] = entry;

    } while (SetupFindNextLine(&context,&context));

    //
    // now determine default
    //
    CopySectionToTargetDirectoryEntry::iterator tde = DestinationDirectories.find(TEXT("defaultdestdir"));
    if(tde != DestinationDirectories.end()) {
        DefaultTargetDirectory = tde;
    }

    return 0;
}

void ParseInfContext::PartialCleanup()
/*++

Routine Description:

    Cleanup information not required by results phase
    In particular, INF handle must ALWAYS be closed

Arguments:
    NONE

Return Value:
    NONE

--*/
{
    if(InfHandle != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(InfHandle);
        InfHandle = INVALID_HANDLE_VALUE;
    }
    SourceDisksFiles.clear();
    CompletedCopySections.clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\precomp.h ===
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <setupapi.h>
#include <msg.h>
#include <process.h>

#include <new>      // causes the 'new' operator to throw bad_alloc
#include <list>
#include <map>
#include <set>
#include <utility>
#include <vector>
#include <sstream>
#include <iomanip>

using namespace std ;

#include "safestring.h"

#include "common.h"
#include "blob.h"
#include "filters.h"
#include "worker.h"
#include "verinfo.h"
#include "parseinfctx.h"
#include "sppriv.h"
#include "globalscan.h"
#include "installscan.h"
#include "infscan.h"

//
// inline code
//
#include "common.inl"
#include "filters.inl"
#include "infscan.inl"
#include "installscan.inl"
#include "parseinfctx.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\installscan.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        installscan.h

Abstract:

    Install section scanning class

History:

    Created July 2001 - JamieHun

--*/

#ifndef _INFSCAN_INSTALLSCAN_H_
#define _INFSCAN_INSTALLSCAN_H_

typedef int (InstallScan::*RecurseKeywordCallback)(ParseInfContextBlob & TheInf,const SafeString & sect,const SafeString & keyword,const SafeString & val);

class InstallScan {

public:
    GlobalScan *pGlobalScan;
    InfScan *pInfScan;
    DWORD PlatformMask;
    SafeString Section;
    ParseInfContextList InfSearchList;
    StringSet Included;
    StringSet HWIDs;
    TargetDirectoryEntry *pTargetDirectory;

public:
    bool NotDeviceInstall;
    bool HasDependentFileChanged;

    InstallScan();
    ~InstallScan();

public:
    int ScanInstallSection();
    void AddHWIDs(const StringSet & hwids);
    void GetHWIDs(StringSet & hwids);

protected:
    int Layouts();
    int Include(const SafeString & name);
    int RecurseKeyword(const SafeString & sect,const SafeString & keyword,RecurseKeywordCallback callback, int & count);
    int IncludeCallback(ParseInfContextBlob & TheInf,const SafeString & sect,const SafeString & keyword,const SafeString & value);
    int NeedsCallback(ParseInfContextBlob & TheInf,const SafeString & sect,const SafeString & keyword,const SafeString & value);
    int CopyFilesCallback(ParseInfContextBlob & TheInf,const SafeString & sect,const SafeString & keyword,const SafeString & value);
    int CheckSingleCopyFile(ParseInfContextBlob & TheInf,TargetDirectoryEntry *pTargDir,const SafeString & sect,const SafeString & keyword,const SafeString & section);
    int CheckInstallSubSection(const SafeString & sect);
    int CheckCopyFiles(const SafeString & section);
    int QuerySourceFile(ParseInfContextBlob & TheInf,const SafeString & section,const SafeString & source,SourceDisksFilesList & Target);
    LONG GetLineCount(const SafeString & section);
    bool DoesSectionExist(const SafeString & section);

public:
    //
    // redirected
    //
    void Fail(int err,const StringList & errors);
    void Fail(int err);
    void Fail(int err,const SafeString & one);
    void Fail(int err,const SafeString & one,const SafeString & two);
    void Fail(int err,const SafeString & one,const SafeString & two,const SafeString & three);
    BOOL Pedantic();

};


#endif //!_INFSCAN_INSTALLSCAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\parseinfctx.inl ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        parseinfctx.inl

Abstract:

    ParseInfContext inline functions

History:

    Created July 2001 - JamieHun

--*/

inline ParseInfContext::ParseInfContext()
{
    Locked = false;
    pGlobalScan = NULL;
    pInfScan = NULL;
    InfHandle = INVALID_HANDLE_VALUE;
    LooksLikeLayoutInf = false;
    HasDependentFileChanged = false;
    DefaultTargetDirectory = DestinationDirectories.end();
}

inline ParseInfContext::~ParseInfContext()
{
    if(InfHandle != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(InfHandle);
    }
}

inline TargetDirectoryEntry * ParseInfContext::GetDefaultTargetDirectory()
{
    if(DefaultTargetDirectory != DestinationDirectories.end()) {
        DefaultTargetDirectory->second.Used = true;
        return &(DefaultTargetDirectory->second);
    }
    return NULL;
}

inline TargetDirectoryEntry * ParseInfContext::GetTargetDirectory(const SafeString & section)
{
    CopySectionToTargetDirectoryEntry::iterator i;
    i = DestinationDirectories.find(section);
    if(i != DestinationDirectories.end()) {
        i->second.Used = true;
        return &(i->second);
    }
    return GetDefaultTargetDirectory();
}

inline DWORD ParseInfContext::DoingCopySection(const SafeString & section,DWORD platforms)
{
    StringToInt::iterator i = CompletedCopySections.find(section);
    if(i == CompletedCopySections.end()) {
        //
        // never done this section before
        //
        CompletedCopySections[section] = platforms;
        return 0;
    }
    if(i->second & PLATFORM_MASK_IGNORE) {
        //
        // attempted this section before, but there isn't one
        //
        return (DWORD)-1;
    }
    if(platforms & ~i->second) {
        //
        // never done these specific platforms before
        //
        i->second |= platforms;
        return 0;
    }
    return i->second;
}

inline void ParseInfContext::NoCopySection(const SafeString & section)
{
    //
    // effectively do a no-section platform to get the bit there
    //
    DoingCopySection(section,PLATFORM_MASK_IGNORE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\safestring.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        safestring.h

Abstract:

    Define SafeString<> template
    SafeString is our alternative to basic_string
    as basic_string is not thread-safe
    a basic_string can be obtained from SafeString and vice-versa

History:

    Created July 2001 - JamieHun

--*/

#ifndef _INFSCAN_SAFESTRING_H_
#define _INFSCAN_SAFESTRING_H_

#include <string>

template<class _E,
    class _Tr = std::char_traits<_E> >
    class SafeString_ {

    typedef SafeString_<_E, _Tr> _Myt;
    _E* pData;
    size_t nLen;

    //
    // safe ref-counting
    //
    long & RefCount(_E* p) {
        return reinterpret_cast<long*>(p)[-1];
    }
    void IncRef(_E* p) {
        if(p) {
            InterlockedIncrement(&RefCount(p));
        }
    }
    void DecRef(_E* p) {
        if(p && (InterlockedDecrement(&RefCount(p))==0)) {
            //
            // if this is the final release, delete
            //
            FreeString(p);
        }
    }
    _E* AllocString(size_t len) {
        //
        // allocate enough data for the refcount, the data
        // and terminating NULL
        // return pointer to data part
        //
        LPBYTE data = new BYTE[((len+1)*sizeof(_E)+sizeof(long))];
        return reinterpret_cast<_E*>(data+sizeof(long));
    }
    void FreeString(_E* p) {
        if(p) {
            //
            // translate to actual allocated data and delete
            //
            delete [] (reinterpret_cast<BYTE*>(p)-sizeof(long));
        }
    }

    void Erase() {
        //
        // release data (final release deletes)
        //
        DecRef(pData);
        pData = NULL;
        nLen = 0;
    }
    void Init(const _E* p,size_t len) {
        //
        // create a new string given pointer to string and length
        //
        if(!len) {
            Erase();
        } else {
            pData = AllocString(len);
            RefCount(pData)=1;
            _Tr::copy(pData,p,len);
            nLen = len;
            pData[nLen] = 0;
        }
    }
    void Init(const _E* p) {
        //
        // in this case, length is not known and p may be NULL
        //
        if(!p) {
            Erase();
        } else {
            Init(p,_Tr::length(p));
        }
    }
    void Copy(const _E *p) {
        //
        // copy, in the case where length is not known
        //
        if(p && p[0]) {
            _E *old = pData;
            Init(p);
            DecRef(old);
        } else {
            Erase();
        }
    }
    void Copy(const _E *p,size_t len) {
        //
        // copy in the case where length is known
        //
        if(len) {
            _E *old = pData;
            Init(p,len);
            DecRef(old);
        } else {
            Erase();
        }
    }
    void Copy(const _Myt & other) {
        //
        // don't need to do byte copy, just add a ref to original string
        //
        if(other.nLen) {
            _E *old = pData;
            IncRef(other.pData);
            pData = other.pData;
            nLen = other.nLen;
            DecRef(old);
        } else {
            Erase();
        }
    }
    void Copy(const std::basic_string<_E,_Tr> & other) {
        //
        // copying from basic string, need to make copy of actual data
        // in this case
        //
        if(other.length()) {
            _E *old = pData;
            Init(other.c_str(),other.length());
            DecRef(old);
        } else {
            Erase();
        }
    }

    void Concat(const _E *first,size_t flen,const _E *second,size_t slen) {
        //
        // concat second to end of first, both lengths known
        //
        if(flen && slen) {
            _E *old = pData;
            pData = AllocString(flen+slen);
            RefCount(pData)=1;
            _Tr::copy(pData,first,flen);
            _Tr::copy(pData+flen,second,slen);
            nLen=flen+slen;
            pData[nLen] = 0;
            DecRef(old);
        } else if(flen) {
            Init(first,flen);
        } else if(slen) {
            Init(second,slen);
        } else {
            Erase();
        }
    }
    void Concat(const _E *first,size_t flen,const _E *second) {
        //
        // concat second to end of first.
        // second length not known and pointer may be null
        //
        if(second) {
            Concat(first,flen,second,_Tr::length(second));
        } else {
            Init(first,flen);
        }
    }

public:
    SafeString_() {
        //
        // Initializer, create empty string
        //
        pData = NULL;
        nLen = 0;
    }
    SafeString_(const _E *p) {
        //
        // Initializer, given LPCxSTR
        //
        pData = NULL;
        Copy(p);
    }
    SafeString_(const _E *p,size_t len) {
        //
        // Initializer, given LPCxSTR and length
        //
        pData = NULL;
        Copy(p,len);
    }
    SafeString_(const _Myt & other) {
        //
        // Initializer, refcount other string
        //
        pData = NULL;
        Copy(other);
    }
    SafeString_(const std::basic_string<_E,_Tr> & other) {
        //
        // Initializer, copy from basic_string
        //
        pData = NULL;
        Copy(other);
    }
    ~SafeString_() {
        //
        // destructor, delete(deref) string
        //
        Erase();
    }
    _Myt & operator =(const _E *p) {
        //
        // assignment
        //
        Copy(p);
        return *this;
    }
    _Myt & operator =(const _Myt & other) {
        //
        // assignment
        //
        Copy(other);
        return *this;
    }
    _Myt & operator =(const std::basic_string<_E,_Tr> & other) {
        //
        // assignment
        //
        Copy(other);
        return *this;
    }

    _Myt & operator +=(const _E *p) {
        //
        // append. If p is NULL, do nothing
        //
        if(p) {
            if(nLen) {
                Concat(pData,nLen,p);
            } else {
                Copy(p);
            }
        }

        return *this;
    }
    _Myt & operator +=(const _Myt & other) {
        //
        // append
        //
        if(other.nLen) {
            if(nLen) {
                Concat(pData,nLen,other.c_str(),other.nLen);
            } else {
                Copy(other);
            }
        }
        return *this;
    }
    _Myt & operator +=(const std::basic_string<_E,_Tr> & other) {
        //
        // append
        //
        if(other.length()) {
            if(nLen) {
                Concat(pData,nLen,other.c_str(),other.length());
            } else {
                Copy(other);
            }
        }
        return *this;
    }

    _Myt operator +(const _E *p) const {
        //
        // concat into new, or copy (left native)
        //
        if(p) {
            if(nLen) {
                _Myt n;
                n.Concat(pData,nLen,p);
                return n;
            } else {
                return _Myt(p);
            }
        } else {
            return *this;
        }
    }
    _Myt operator +(const _Myt & other) const {
        //
        // concat into new, or copy (left native)
        //
        if(other.nLen) {
            if(nLen) {
                _Myt n;
                n.Concat(pData,nLen,other.c_str(),other.nLen);
                return n;
            } else {
                return other;
            }
        } else {
            return *this;
        }
    }
    _Myt operator +(const std::basic_string<_E,_Tr> & other) const {
        //
        // concat into new, or copy (left native)
        //
        if(other.length()) {
            if(nLen) {
                _Myt n;
                n.Concat(pData,nLen,other.c_str(),other.length());
                return n;
            } else {
                return _Myt(other);
            }
        } else {
            return *this;
        }
    }

    friend _Myt operator +(const _E *first,const _Myt & second) {
        //
        // concat where left is not native but right is
        //
        if(first) {
            _Myt n;
            n.Concat(first,_Tr::length(first),second.c_str(),second.length());
            return n;
        } else {
            return second;
        }
    }

    friend _Myt operator +(const std::basic_string<_E,_Tr> & first,const _Myt & second) {
        //
        // concat where left is not native but right is
        //
        if(first.length()) {
            _Myt n;
            n.Concat(first.c_str(),first.length(),second.c_str(),second.length());
            return n;
        } else {
            return second;
        }
    }

    int compare(const _Myt & other) const {
        //
        // compare this string with another string
        // (force other string into SafeString if needed)
        //
        int sz = min(nLen,other.nLen);
        if(sz) {
            int cmp = _Tr::compare(pData,other.pData,sz);
            if(cmp != 0) {
                return cmp;
            }
        }
        if(nLen<other.nLen) {
            return -1;
        } else if(nLen>other.nLen) {
            return 1;
        } else {
            return 0;
        }
    }
    bool operator < (const _Myt & other) const {
        //
        // specific compare
        //
        return compare(other)<0;
    }
    bool operator > (const _Myt & other) const {
        //
        // specific compare
        //
        return compare(other)>0;
    }
    bool operator == (const _Myt & other) const {
        //
        // specific compare
        //
        return compare(other)==0;
    }
    operator const _E* () const {
        //
        // natively convert to LPCxSTR if needed
        // (temporary string)
        //
        return pData;
    }
    const _E & operator[](unsigned int pos) const {
        //
        // index into string (unsigned)
        //
        return pData[pos];
    }
    const _E & operator[](int pos) const {
        //
        // index into string (signed)
        //
        return pData[pos];
    }
    bool empty(void) const {
        //
        // return true if empty
        //
        return nLen==0;
    }
    const _E* c_str(void) const {
        //
        // explicit conversion to LPCxSTR
        // (temporary string)
        //
        return pData;
    }
    size_t length(void) const {
        //
        // length of string
        //
        return nLen;
    }
    _Myt substr(size_t base,size_t len = (size_t)(-1)) const {
        //
        // part of string
        // unless it returns the full string, creates new string
        //
        if(base>=nLen) {
            base = 0;
            len = 0;
        } else {
            len = min(len,nLen-base);
        }
        if(len == 0) {
            //
            // returns empty string
            //
            return SafeString();
        } else if(len == nLen) {
            //
            // returns full string
            //
            return *this;
        } else {
            //
            // returns literal copy of part of string
            //
            return SafeString(pData+base,len);
        }
    }
};

//
// ostream/istream helpers
//

template<class _E, class _Tr> inline
basic_ostream<_E, _Tr>& __cdecl operator<<(
        basic_ostream<_E, _Tr>& Output,
        const SafeString_<_E, _Tr>& Str)
{
    size_t i;
    size_t len = Str.length();
    const _E* data = Str.c_str();

    for (i = 0; i < len; i++,data++) {
        if (_Tr::eq_int_type(_Tr::eof(),Output.rdbuf()->sputc(*data))) {
            break;
        }
    }
    return Output;
}

//
// 3 variations of SafeString
//

typedef SafeString_<TCHAR> SafeString;
typedef SafeString_<CHAR>  SafeStringA;
typedef SafeString_<WCHAR> SafeStringW;

#endif //!_INFSCAN_SAFESTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\sppriv.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

For Internal use only!

Module Name:

    INFSCAN
        infscan.cpp

Abstract:

    Access to private SetupAPI functions

History:

    Created July 2001 - JamieHun

--*/

#include "precomp.h"
#pragma hdrstop

SetupPrivate::SetupPrivate()
{
    Fn_pSetupGetInfSections = NULL;
    Fn_SetupEnumInfSections = NULL;
    hSetupAPI = LoadLibrary(TEXT("setupapi.dll"));
    if(hSetupAPI) {
        Fn_SetupEnumInfSections = (Type_SetupEnumInfSections)GetProcAddress(hSetupAPI,"SetupEnumInfSectionsW");
        Fn_pSetupGetInfSections = (Type_pSetupGetInfSections)GetProcAddress(hSetupAPI,"pSetupGetInfSections");
        if(!Fn_pSetupGetInfSections) {
            Fn_pSetupGetInfSections = (Type_pSetupGetInfSections)GetProcAddress(hSetupAPI,"SetupGetInfSections");
        }
    }
}

SetupPrivate::~SetupPrivate()
{
    if(hSetupAPI) {
        FreeLibrary(hSetupAPI);
    }
}

bool SetupPrivate::GetInfSections(HINF hInf,StringList & sections)
{
    if(Fn_SetupEnumInfSections) {
        return GetInfSectionsNewWay(hInf,sections);
    }
    if(Fn_pSetupGetInfSections) {
        return GetInfSectionsOldWay(hInf,sections);
    }
    return false;
}

bool SetupPrivate::GetInfSectionsOldWay(HINF hInf,StringList & sections)
{
    UINT Size;
    UINT SizeNeeded;
    if(Fn_pSetupGetInfSections(hInf,NULL,0,&SizeNeeded) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        SizeNeeded+=2;
        PWSTR text = new WCHAR[SizeNeeded];
        if(!text) {
            return false;
        }
        if(!Fn_pSetupGetInfSections(hInf,text,SizeNeeded,NULL)) {
            delete [] text;
            return false;
        }
        PWSTR str = text;
        sections.clear();
        while(*str) {
            _wcslwr(str);
            sections.push_back(ConvertString(str));
            str+=wcslen(str)+1;
        }
        delete [] text;
        return true;
    }
    return false;
}


bool SetupPrivate::GetInfSectionsNewWay(HINF hInf,StringList & sections)
{
    WCHAR buf[256];
    int inc;
    for(inc = 0; Fn_SetupEnumInfSections(hInf,inc,buf,ASIZE(buf),NULL); inc++) {
        _wcslwr(buf);
        sections.push_back(ConvertString(buf));
    }
    return inc ? true : false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\verinfo.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        verinfo.h

Abstract:

    Driver node Version management

History:

    Created July 2001 - JamieHun

--*/

#ifndef _INFSCAN_VERINFO_H_
#define _INFSCAN_VERINFO_H_

class BasicVerInfo {
public:
    DWORD   PlatformMask;
    DWORD   VersionHigh;
    DWORD   VersionLow;
    DWORD   ProductType;
    DWORD   ProductSuite;

public:
    int IsBetter(BasicVerInfo & other,BasicVerInfo & filter);
    virtual bool IsCompatibleWith(BasicVerInfo & other);
    BasicVerInfo();
    int Parse(PTSTR verString);

};

class NodeVerInfo : public BasicVerInfo {
public:
    SafeString Decoration;
    bool    Rejected;

public:
    NodeVerInfo();
    int IsBetter(NodeVerInfo & other,BasicVerInfo & filter);
    int Parse(PTSTR verString);
    int Parse(const SafeString & str);
};

typedef list<NodeVerInfo> NodeVerInfoList;

#endif //!_INFSCAN_VERINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\sppriv.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

For Internal use only!

Module Name:

    INFSCAN
        sppriv.h

Abstract:

    Access to private SetupAPI functions

History:

    Created July 2001 - JamieHun

--*/

#ifndef _INFSCAN_SPPRIV_H_
#define _INFSCAN_SPPRIV_H_

class SetupPrivate {

private:
    typedef BOOL (WINAPI *Type_pSetupGetInfSections)(HINF InfHandle,PWSTR Buffer,UINT Size,UINT *SizeNeeded);
    typedef BOOL (WINAPI *Type_SetupEnumInfSections)(HINF InfHandle,UINT Index,PWSTR Buffer,UINT Size,UINT *SizeNeeded);
    Type_pSetupGetInfSections Fn_pSetupGetInfSections;
    Type_SetupEnumInfSections Fn_SetupEnumInfSections;

private:
    bool GetInfSectionsOldWay(HINF hInf,StringList & sections);
    bool GetInfSectionsNewWay(HINF hInf,StringList & sections);

protected:
    HMODULE hSetupAPI;

public:
    SetupPrivate();
    ~SetupPrivate();
    bool GetInfSections(HINF hInf,StringList & sections);

};

#endif //!_INFSCAN_SPPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\verinfo.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

For Internal use only!

Module Name:

    INFSCAN
        verinfo.cpp

Abstract:

    Platform version matching

    WARNING! WARNING!
    All of this implementation relies on intimate knowledge of
    SetupAPI parsing of INF files. Particularly processing
    of [Manufacturer] seciton.

    It is re-implemented here for speed due to having to process
    700+ INF's in a single go at the cost of having to maintain
    this.

    DO NOT (I repeat) DO NOT re-implement the code here without
    consultation with SetupAPI owner.

History:

    Created July 2001 - JamieHun

--*/

#include "precomp.h"
#pragma hdrstop

BasicVerInfo::BasicVerInfo()
/*++

Routine Description:

    Initialize BasicVerInfo data

Arguments:
    NONE

Return Value:
    NONE

--*/
{
    PlatformMask = PLATFORM_MASK_ALL;
    VersionHigh = 0;
    VersionLow = 0;
    ProductType = 0;
    ProductSuite = 0;
}

int BasicVerInfo::Parse(PTSTR verString)
/*++

Routine Description:

    Parse a (modifiable) verString
    determining range of platforms supported
    version supported
    product type supported
    range of product suites supported
    and a bitmap of what was specified

    syntax currently:

      <plat>.<maj>.<min>.<typ>.<suite>

    WARNING! This can be extended by SetupAPI
    MAINTAINANCE: format must correlate with SetupAPI manufacturer/models version syntax
    MAINTAINANCE: add all supported platforms

Arguments:
    Version string, eg "ntx86.5.1"

Return Value:
    0 if success

--*/
{
    PlatformMask = 0;

    int i;
    PTSTR nn = verString;

    for (i = 0;i<5;i++) {
        PCTSTR n = nn;
        while((*nn) && (*nn != TEXT('.'))) {
            nn++;
        }
        TCHAR c = *nn;
        *nn = TEXT('\0');
        switch(i) {
            case 0: // platform
                if(!n[0]) {
                    PlatformMask |= PLATFORM_MASK_ALL_ARCHITECTS;
                    break;
                }
                if(_tcsicmp(n,TEXT("win"))==0) {
                    PlatformMask = (PlatformMask & ~PLATFORM_MASK_ALL_ARCHITECTS) | PLATFORM_MASK_WIN;
                    break;
                }
                if(_tcsicmp(n,TEXT("NTx86"))==0) {
                    PlatformMask = (PlatformMask & ~PLATFORM_MASK_ALL_ARCHITECTS) | PLATFORM_MASK_NTX86;
                    break;
                }
                if(_tcsicmp(n,TEXT("NTia64"))==0) {
                    PlatformMask = (PlatformMask & ~PLATFORM_MASK_ALL_ARCHITECTS) | PLATFORM_MASK_NTIA64;
                    break;
                }
                if(_tcsicmp(n,TEXT("NTamd64"))==0) {
                    PlatformMask = (PlatformMask & ~PLATFORM_MASK_ALL_ARCHITECTS) | PLATFORM_MASK_NTAMD64;
                    break;
                }
                if(_tcsicmp(n,TEXT("NT"))==0) {
                    PlatformMask = (PlatformMask & ~PLATFORM_MASK_ALL_ARCHITECTS) | PLATFORM_MASK_NT;
                    break;
                }
                return 4;

            case 1: // major
                if(!n[0]) {
                    PlatformMask |= PLATFORM_MASK_ALL_MAJOR_VER;
                    break;
                }
                PlatformMask &= ~PLATFORM_MASK_ALL_MAJOR_VER;
                VersionHigh = _tcstoul(n,NULL,0);
                break;

            case 2: // minor
                if(!n[0]) {
                    PlatformMask |= PLATFORM_MASK_ALL_MINOR_VER;
                    break;
                }
                PlatformMask &= ~PLATFORM_MASK_ALL_MINOR_VER;
                VersionLow = _tcstoul(n,NULL,0);
                break;

            case 3: // type
                if(!n[0]) {
                    PlatformMask |= PLATFORM_MASK_ALL_TYPE;
                    break;
                }
                PlatformMask &= ~PLATFORM_MASK_ALL_TYPE;
                ProductType = _tcstoul(n,NULL,0);
                break;

            case 4: // suite
                if(!n[0]) {
                    PlatformMask |= PLATFORM_MASK_ALL_SUITE;
                    break;
                }
                PlatformMask &= ~PLATFORM_MASK_ALL_SUITE;
                ProductSuite = _tcstoul(n,NULL,0);
                break;

        }
        if(c) {
            *nn = c;
            nn++;
        }
    }
    return 0;

}

bool BasicVerInfo::IsCompatibleWith(BasicVerInfo & other)
/*++

Routine Description:

    Determine if given version is compatible with other (actual) version
    To put into context,
        this: version of a model decoration
        other: information about target OS

    note that A.IsCompatibleWith(B)
    does not imply B.IsCompatibleWith(A)


Arguments:
    BasicVerInfo to compare against (usually GlobalScan::Version)

Return Value:
    true if they are (loosely) compatible
    false if mutually exclusive

    ie.  NTx86 is compatible with NTx86.5.1
    NTx86 is mutually exclusive with NTia64

--*/
{
    //
    // first match the platform architecture
    //
    if(!((other.PlatformMask & PlatformMask) & PLATFORM_MASK_ALL_ARCHITECTS)) {
        //
        // mutually exclusive platform
        //
        return FALSE;
    }
    //
    // Version
    //
    if(!((other.PlatformMask | PlatformMask) & PLATFORM_MASK_ALL_MAJOR_VER)) {
        //
        // explicit major version required
        //
        if(other.VersionHigh < VersionHigh) {
            //
            // this entry is not compatible with target
            //
            return FALSE;
        }
        if(other.VersionHigh == VersionHigh) {
            //
            // need to check VersionLow
            //
            if(!((other.PlatformMask | PlatformMask) & PLATFORM_MASK_ALL_MINOR_VER)) {
                //
                // explicit minor version required
                //
                if(other.VersionLow < VersionLow) {
                    //
                    // this entry is not compatible with target
                    //
                    return FALSE;
                }
            }
        }
    }
    //
    // Product Type - must be explicit or wild-carded
    //
    if(!((other.PlatformMask | PlatformMask) & PLATFORM_MASK_ALL_TYPE)) {
        if(other.ProductType != ProductType) {
            //
            // this entry is not compatible with target
            //
            return FALSE;
        }
    }
    //
    // Product Suite - must be mask or wild-carded
    //
    if(!((other.PlatformMask | PlatformMask) & PLATFORM_MASK_ALL_SUITE)) {
        if(!(other.ProductSuite & ProductSuite)) {
            //
            // this entry is not compatible with target
            //
            return FALSE;
        }
    }
    return TRUE;
}

int BasicVerInfo::IsBetter(BasicVerInfo & other,BasicVerInfo & filter)
/*++

Routine Description:

    More complex check between this & other

    filter is target OS version (GlobalScan::Version)

Arguments:
    BasicVerInfo to compare against (usually another model version)

Return Value:
    if 'other' is definately better than primary, return 1
    if 'other' and this likely are both just as good/bad (but not same), return 0
    if 'other' is exactly the same as primary, return -1
    if 'other' is definately worse than primary, return -2


--*/
{
    //
    //
    // for a field:
    //
    // if field is filtered as not testable, then both primary and other are
    //   either 'same' or 'likely'
    //
    int testres;
    int suggest;

    //
    // check platform
    //
    if((PlatformMask ^ other.PlatformMask) & PLATFORM_MASK_ALL_ARCHITECTS) {
        //
        // the two platform matches are different
        // result will be 1/0/-2
        //
        DWORD o_plat = other.PlatformMask & filter.PlatformMask & PLATFORM_MASK_ALL_ARCHITECTS;
        DWORD t_plat = PlatformMask & filter.PlatformMask & PLATFORM_MASK_ALL_ARCHITECTS;

        if(o_plat == t_plat) {
            //
            // both are in the same realm
            //
            // a more generic one is allowable if a more specific one
            // could get rejected for other reasons
            // so mark this as a suggestion at this moment
            //
            if((o_plat ^ other.PlatformMask) & PLATFORM_MASK_ALL_ARCHITECTS) {
                //
                // 'other' is less specific
                //
                testres = -2;
            } else {
                //
                // 'other' is more specific
                //
                testres = 1;
            }
        } else {
            //
            // consider both
            //
            return 0;
        }
    } else {
        //
        // they are exactly the same
        //
        testres = -1;
    }

    if(PlatformMask & PLATFORM_MASK_ALL_MAJOR_VER) {
        //
        // we have generic version
        //
        if(other.PlatformMask & PLATFORM_MASK_ALL_MAJOR_VER) {
            //
            // other also has generic version
            //
            suggest = -1;
        } else {
            //
            // 'other' has specific version, so it wins
            //
            suggest = 1;
        }
    } else {
        //
        // we have specific version
        //
        if(other.PlatformMask & PLATFORM_MASK_ALL_MAJOR_VER) {
            //
            // 'other' has generic version, so we win
            //
            suggest = -2;
        } else {
            //
            // both have specific major version
            //
            if(other.VersionHigh > VersionHigh) {
                //
                // 'other' has higher version, it wins
                //
                suggest = 1;
            } else if(VersionHigh > other.VersionHigh) {
                //
                // we have higher version, we win
                //
                suggest = -2;
            } else {
                //
                // version-high matches, need to check version low
                //
                if(PlatformMask & PLATFORM_MASK_ALL_MINOR_VER) {
                    //
                    // we have generic version
                    //
                    if(other.PlatformMask & PLATFORM_MASK_ALL_MINOR_VER) {
                        //
                        // other also has generic version, draw
                        //
                        suggest = -1;
                    } else {
                        //
                        // 'other' has specific version, so it wins
                        //
                        suggest = 1;
                    }
                } else {
                    //
                    // we have specific version
                    //
                    if(other.PlatformMask & PLATFORM_MASK_ALL_MINOR_VER) {
                        //
                        // 'other' has generic version, so we win
                        //
                        suggest = -2;
                    } else {
                        //
                        // both have specific minor version, higher version wins
                        //
                        if(other.VersionLow > VersionLow) {
                            suggest = 1;
                        } else if(VersionLow > other.VersionLow) {
                            suggest = -2;
                        } else {
                            //
                            // draw
                            //
                            suggest = -1;
                        }
                    }
                }
            }
        }
    }
    if(suggest != -1) {
        //
        // if we suggested anything other than a draw
        //
        if(filter.PlatformMask & PLATFORM_MASK_ALL_MINOR_VER) {
            //
            // consider as two possible outcomes
            //
            return 0;

        } else if (testres == -1) {
            //
            // the two are no longer identical
            //
            testres = suggest;
        }
    }

    if((PlatformMask ^other.PlatformMask) & PLATFORM_MASK_ALL_TYPE) {
        //
        // product types are different (one generic, one specific)
        //
        if(filter.PlatformMask & PLATFORM_MASK_ALL_TYPE) {
            //
            // consider both outcomes
            //
            return 0;

        } else if (testres == -1) {
            //
            // we're keying off type
            //
            if(PlatformMask & PLATFORM_MASK_ALL_TYPE) {
                //
                // 'other' has specific suite
                //
                testres = 1;
            } else {
                //
                // we have specific suite
                //
                testres = -2;
            }
        }
    } else if(! (PlatformMask & other.PlatformMask & PLATFORM_MASK_ALL_TYPE)) {
        //
        // both specified type
        //
        if (ProductType != other.ProductType) {
            //
            // if types are different, consider both
            //
            return 0;
        }
    }

    if((PlatformMask ^other.PlatformMask) & PLATFORM_MASK_ALL_SUITE) {
        //
        // product suites are different (one generic, one 'specific')
        //
        if(filter.PlatformMask & PLATFORM_MASK_ALL_SUITE) {
            //
            // consider both outcomes
            //
            return 0;

        } else if (testres == -1) {
            //
            // we're keying off suite
            //
            if(PlatformMask & PLATFORM_MASK_ALL_SUITE) {
                //
                // 'other' has specific suite
                //
                testres = 1;
            } else {
                //
                // we have specific suite
                //
                testres = -2;
            }
        }
    } else if(! (PlatformMask & other.PlatformMask & PLATFORM_MASK_ALL_SUITE)) {
        //
        // both specified suite
        //
        if (ProductSuite != other.ProductSuite) {
            return 0;
        }
    }
    return testres;
}

//
//
// NodeVerInfo - adaptation of BasicVerInfo
//               where a decoration string needs to be kept
//               for selecting what decorations to consider
//

NodeVerInfo::NodeVerInfo()
/*++

Routine Description:

    Initialize NodeVerInfo data

Arguments:
    NONE

Return Value:
    NONE

--*/
{
    Rejected = false;
}


int NodeVerInfo::Parse(PTSTR verString)
/*++

Routine Description:

    Parse a (modifiable) verString
    and also save a copy as Decoration

Arguments:
    Version string, eg "ntx86.5.1"

Return Value:
    0 if success

--*/
{
    //
    // copy it before it's modified
    //
    Decoration = verString;
    return BasicVerInfo::Parse(verString);
}

int NodeVerInfo::Parse(const SafeString & str)
/*++

Routine Description:

    Parse an unmodifiable verString

Arguments:
    Version string, eg "ntx86.5.1"

Return Value:
    0 if success

--*/
{
    PTSTR buf;
    buf = new TCHAR[str.length()+1];
    lstrcpy(buf,str.c_str());
    int res = Parse(buf);
    delete [] buf;
    return res;
}

int NodeVerInfo::IsBetter(NodeVerInfo & other,BasicVerInfo & filter)
/*++

Routine Description:

    Specific variation of 'IsBetter'

Arguments:
    Same as BasicVersion::IsBetter

Return Value:
    Same as BasicVersion::IsBetter

--*/
{
    int testres = BasicVerInfo::IsBetter(other,filter);
    if(testres == -1) {
        //
        // we considered both equally ranked
        // compare the strings. If the strings are
        // different, consider both
        //
        if(Decoration.length() != other.Decoration.length()) {
            return 0;
        }
        if(_tcsicmp(Decoration.c_str(),other.Decoration.c_str())!=0) {
            return 0;
        }
    }
    return testres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\worker.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        worker.h

Abstract:

    Thread/Job management

History:

    Created July 2001 - JamieHun

--*/


#ifndef _INFSCAN_WORKER_H_
#define _INFSCAN_WORKER_H_

class WorkerThread {
private:
    HANDLE ThreadHandle;
    unsigned ThreadId;
    static unsigned __stdcall WrapWorker(void * This);

protected:
    //
    // override for worker function
    //
    virtual unsigned Worker();

public:
    WorkerThread();
    virtual ~WorkerThread();
    virtual bool Begin();
    virtual unsigned Wait();
};

class GlobalScan;

class JobThread : public WorkerThread {
protected:
    virtual unsigned Worker();
public:
    GlobalScan * pGlobalScan;

    JobThread()
    {
        pGlobalScan = NULL;
    }
    JobThread(GlobalScan * globalScan) {
        pGlobalScan = globalScan;
    }
};

typedef list<JobThread> JobThreadList;

//
// JobItem is what classes can override as a task
//
class JobItem {
    friend class JobEntry;
protected:
    LONG RefCount;
    void AddRef() {
        InterlockedIncrement(&RefCount);
    }
    void Release() {
        if(InterlockedDecrement(&RefCount) == 0) {
            delete this;
        }
    }

public:
    virtual int Run();
    virtual int PartialCleanup();
    virtual int Results();
    virtual int PreResults();
public:
    JobItem() {
        RefCount = 0;
    }
    virtual ~JobItem();
};

//
// JobEntry is a container for a JobItem
// note that a JobItem is ref-counted
//
class JobEntry {
private:
    JobItem *pItem;
public:
    void ChangeItem(JobItem *item) {
        if(item) {
            item->AddRef();
        }
        if(pItem) {
            pItem->Release();
        }
        pItem = item;
    }
    JobEntry(JobItem *item = NULL) {
        if(item) {
            item->AddRef();
        }
        pItem = item;
    }
    JobEntry(const JobEntry & from) {
        if(from.pItem) {
            const_cast<JobEntry*>(&from)->pItem->AddRef();
        }
        pItem = from.pItem;
    }
    ~JobEntry() {
        if(pItem) {
            pItem->Release();
        }
    }
    int Run() {
        if(pItem) {
            return pItem->Run();
        } else {
            return -1;
        }
    }
    int PartialCleanup() {
        if(pItem) {
            return pItem->PartialCleanup();
        } else {
            return -1;
        }
    }
    int PreResults() {
        if(pItem) {
            return pItem->PreResults();
        } else {
            return -1;
        }
    }
    int Results() {
        if(pItem) {
            return pItem->Results();
        } else {
            return -1;
        }
    }
};

typedef list<JobEntry> JobList;

#endif //!_INFSCAN_WORKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\infscan\worker.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    INFSCAN
        worker.cpp

Abstract:

    WorkerThread and JobItem implementations

    Classes to simplify working with threads

History:

    Created July 2001 - JamieHun

--*/
#include "precomp.h"
#pragma hdrstop

//
// Worker thread basics
//
WorkerThread::WorkerThread()
/*++

Routine Description:

    Initialize WorkerThread

--*/
{
    ThreadHandle = NULL;
    ThreadId = 0;
}

WorkerThread::~WorkerThread()
/*++

Routine Description:

    Cleanup WorkerThread
    release allocated resources

--*/
{
    if(ThreadHandle) {
        Wait();
    }
}

bool WorkerThread::Begin()
/*++

Routine Description:

    Kick off thread

Arguments:
    NONE

Return Value:
    true if successful

--*/
{
    if(ThreadHandle) {
        return false;
    }
    ThreadHandle = reinterpret_cast<HANDLE>(_beginthreadex(NULL,0,WrapWorker,this,CREATE_SUSPENDED,&ThreadId));
    if(!ThreadHandle) {
        return false;
    }
    //
    // this side of the thread object done, child can continue
    //
    ResumeThread(ThreadHandle);
    return true;
}

unsigned WorkerThread::Wait()
/*++

Routine Description:

    Wait until thread terminates

Arguments:
    NONE

Return Value:
    exit code

--*/
{
    if(!ThreadHandle) {
        return (unsigned)(-1);
    }
    WaitForSingleObject(ThreadHandle,INFINITE);
    DWORD ExitCode;
    if(!GetExitCodeThread(ThreadHandle,&ExitCode)) {
        CloseHandle(ThreadHandle);
        return (unsigned)(-1);
    }
    CloseHandle(ThreadHandle);
    ThreadHandle = NULL;
    return static_cast<unsigned>(ExitCode);
}

unsigned WorkerThread::Worker()
/*++

Routine Description:

    overridable thread operation

Arguments:
    NONE

Return Value:
    exit code

--*/
{
    return 0;
}

unsigned WorkerThread::WrapWorker(void * This)
/*++

Routine Description:

   _beginthreadex expects static function, invoke real worker

Arguments:
    pointer to class instance

Return Value:
    exit code

--*/
{
    //
    // static function, invoke protected member function
    //
    WorkerThread * TypedThis = reinterpret_cast<WorkerThread*>(This);
    if(TypedThis == NULL) {
        return 0;
    }
    return TypedThis->Worker();
}

JobItem::~JobItem()
/*++

Routine Description:

    Job variation cleanup

--*/
{
    //
    // nothing
    //
}

int JobItem::Run()
/*++

Routine Description:

    Job item dummy Run

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    //
    // nothing
    //
    return 0;
}

int JobItem::PartialCleanup()
/*++

Routine Description:

    Job item dummy PartialCleanup

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    //
    // nothing
    //
    return 0;
}

int JobItem::Results()
/*++

Routine Description:

    Job item dummy Results

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    //
    // nothing
    //
    return 0;
}

int JobItem::PreResults()
/*++

Routine Description:

    Job item dummy PreResults

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    //
    // nothing
    //
    return 0;
}

unsigned JobThread::Worker()
/*++

Routine Description:

    Job thread. Pull job from GlobalScan::GetNextJob
    execute it
    do partial cleanup
    rinse repeat

Arguments:
    NONE

Return Value:
    0 on success

--*/
{
    //
    // simple task
    //
    JobEntry   * pJob;

    if(!pGlobalScan) {
        return 0;
    }
    for(;;) {
        pJob = pGlobalScan->GetNextJob();
        if(!pJob) {
            return 0;
        }
        int res = pJob->Run();
        pJob->PartialCleanup();
        if(res != 0) {
            return res;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\config.c ===
/*++

Copyright (c) 2000 Microsoft Corporation All Rights Reserved

Module Name:

    config.c

Abstract:

    This module controls access to the simulated configuration space
    of the SHPC.

    Config access is controlled in the following manner in this simulator:
    We assume that this simulator will be loaded on a bridge enumerated by
    the SoftPCI simulator.  SoftPCI keeps an internal representation of the
    config space of the devices it controls.  The function of this simulator,
    then, is to manage the SHPC register set and perform commands associated
    with writing the SHPC config space.  However, the representation of config
    space is kept internal to SoftPCI.

Environment:

    Kernel Mode

Revision History:

    Davis Walker (dwalker) Sept 8 2000

--*/

#include "hpsp.h"


NTSTATUS
HpsInitConfigSpace(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine initializes the config space of this device, and
    is designed to simulate a ControllerReset event.

Arguments:

    DeviceExtension - the device extension for the current devobj

    ReadFromRegistry - This indicates whether or not to read the HWINIT
        parameters from the registry.

Return value:

    NT Status code

--*/
{
    NTSTATUS                status;
    UCHAR                   offset;

    //
    // If we haven't gotten a PCI interface yet, something's broken.
    //
    ASSERT(DeviceExtension->InterfaceWrapper.PciContext != NULL);
    if (DeviceExtension->InterfaceWrapper.PciContext == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Find out where Softpci put the SHPC capability and save it away.
    //
    status = HpsGetCapabilityOffset(DeviceExtension,
                                    SHPC_CAPABILITY_ID,
                                    &offset
                                    );
    if (!NT_SUCCESS(status)) {
        return status;
    }
    DeviceExtension->ConfigOffset = offset;
    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-Config Space initialized at offset %d\n",
               offset
               );
    //
    // Also make sure Softpci gave us a HWINIT capability.  We only support
    // this method of initialization for now, so it's a fatal error if not.
    //
    status = HpsGetCapabilityOffset(DeviceExtension,
                                    HPS_HWINIT_CAPABILITY_ID,
                                    &offset
                                    );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Read the Capability Header from PCI config space.  Softpci should have faked this
    // up for us. Then initialize the rest of the SHPC config space
    //
    DeviceExtension->InterfaceWrapper.PciGetBusData(DeviceExtension->InterfaceWrapper.PciContext,
                                                    PCI_WHICHSPACE_CONFIG,
                                                    &DeviceExtension->ConfigSpace.Header,
                                                    DeviceExtension->ConfigOffset,
                                                    sizeof(PCI_CAPABILITIES_HEADER)
                                                    );

    DeviceExtension->ConfigSpace.DwordSelect = 0x00;
    DeviceExtension->ConfigSpace.Pending.AsUCHAR = 0x0;
    DeviceExtension->ConfigSpace.Data = 0x0;
    //
    // We'd like to keep Softpci in the loop as far as config space access goes, so write
    // this out to the bus.
    //
    DeviceExtension->InterfaceWrapper.PciSetBusData(DeviceExtension->InterfaceWrapper.PciContext,
                                                    PCI_WHICHSPACE_CONFIG,
                                                    &DeviceExtension->ConfigSpace,
                                                    DeviceExtension->ConfigOffset,
                                                    sizeof(SHPC_CONFIG_SPACE)
                                                    );

    //
    // Finally, initialize the register set.
    //
    status = HpsInitRegisters(DeviceExtension);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return STATUS_SUCCESS;

}

ULONG
HpsHandleDirectReadConfig(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine is provided in the BUS_INTERFACE_STANDARD to allow upper
    drivers direct access to config space without using a ReadConfig IRP.
    Since SoftPCI maintains the whole config space for the bridge, simply
    pass the request down.  This function is kept as a stub in case more
    work needs to be done later on reads.

Arguments:

    Context - context provided in the interface, in this case a
              PHPS_INTERFACE_WRAPPER.

    DataType - type of config space access

    Buffer - a buffer to read into

    Offset - offset into config space to read

    Length - length of read

Return Value:

    The number of bytes read from config space

--*/

{

    PHPS_DEVICE_EXTENSION   deviceExtension = (PHPS_DEVICE_EXTENSION) Context;
    PHPS_INTERFACE_WRAPPER  wrapper         = &deviceExtension->InterfaceWrapper;

    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-Config Read at offset 0x%x for length 0x%x\n",
               Offset,
               Length
               );
    return wrapper->PciGetBusData(wrapper->PciContext,
                                  DataType,
                                  Buffer,
                                  Offset,
                                  Length
                                  );

}

ULONG
HpsHandleDirectWriteConfig(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine is provided in the BUS_INTERFACE_STANDARD to allow upper
    drivers direct access to config space without using a WriteConfig IRP.
    It needs check to see if this is our config space access.  If so, handle
    it, if not, restore the PCI interface state and pass it down.

Arguments:

    Context - context provided in the interface, in this case a
              PHPS_INTERFACE_WRAPPER.

    DataType - type of config space access

    Buffer - a buffer to write from

    Offset - offset into config space to write to

    Length - length of read

Return Value:

    The number of bytes read from config space

--*/
{

    PHPS_DEVICE_EXTENSION   deviceExtension = (PHPS_DEVICE_EXTENSION) Context;
    PHPS_INTERFACE_WRAPPER  wrapper         = &deviceExtension->InterfaceWrapper;
    ULONG pciLength;

    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-Config Write at offset 0x%x for length 0x%x\n",
               Offset,
               Length
               );

    if ((DataType == PCI_WHICHSPACE_CONFIG) &&
        IS_SUBSET(Offset,
                  Length,
                  deviceExtension->ConfigOffset,
                  sizeof(SHPC_CONFIG_SPACE)
                  )) {

        HpsWriteConfig(deviceExtension,
                       Buffer,
                       Offset,
                       Length
                       );

        RtlCopyMemory(Buffer,
                      (PUCHAR)&deviceExtension->ConfigSpace + Offset,
                      Length
                      );

        //
        // Even though we've internally handled the write, pass it down to PCI so that
        // SoftPCI stays in the loop.  Since the write may have caused other fields
        // of config to be written, send the whole config to softpci.
        //
        pciLength = wrapper->PciSetBusData(wrapper->PciContext,
                                      DataType,
                                      &deviceExtension->ConfigSpace,
                                      deviceExtension->ConfigOffset,
                                      sizeof(SHPC_CONFIG_SPACE)
                                      );

        if (pciLength != sizeof(SHPC_CONFIG_SPACE)) {

            return 0;

        } else {
            return Length;
        }

    } else {

        return wrapper->PciSetBusData(wrapper->PciContext,
                                      DataType,
                                      Buffer,
                                      Offset,
                                      Length
                                      );
    }

}

VOID
HpsResync(
    IN PHPS_DEVICE_EXTENSION DeviceExtension
    )
{
    PSHPC_CONFIG_SPACE configSpace = &DeviceExtension->ConfigSpace;
    PSHPC_REGISTER_SET registerSet = &DeviceExtension->RegisterSet;

    if (DeviceExtension->UseConfig) {

        configSpace->Pending.Field.ControllerIntPending = (*(PULONG)&registerSet->WorkingRegisters.IntLocator) ? 1:0;
        configSpace->Pending.Field.ControllerSERRPending = (*(PULONG)&registerSet->WorkingRegisters.SERRLocator) ? 1:0;
    
        if (configSpace->DwordSelect < SHPC_NUM_REGISTERS) {
    
            DbgPrintEx(DPFLTR_HPS_ID,
                       DPFLTR_INFO_LEVEL,
                       "HPS-Getting Register %d\n",
                       configSpace->DwordSelect
                       );
    
            configSpace->Data = registerSet->AsULONGs[configSpace->DwordSelect];
            DbgPrintEx(DPFLTR_HPS_ID,
                       DPFLTR_INFO_LEVEL,
                       "HPS-Value: 0x%x\n",
                       configSpace->Data
                       );
    
        } else {
    
            //
            // Illegal register write
            //
            configSpace->Data = 0x12345678;
    
        }
    
        DeviceExtension->InterfaceWrapper.PciSetBusData(DeviceExtension->InterfaceWrapper.PciContext,
                                                        PCI_WHICHSPACE_CONFIG,
                                                        configSpace,
                                                        DeviceExtension->ConfigOffset,
                                                        sizeof(SHPC_CONFIG_SPACE)
                                                        );
    } else {

        RtlCopyMemory((PUCHAR)DeviceExtension->HBRB + DeviceExtension->HBRBRegisterSetOffset,
                  &DeviceExtension->RegisterSet,
                  sizeof(SHPC_REGISTER_SET)
                  );
    }
    
}

VOID
HpsWriteConfig(
    IN PHPS_DEVICE_EXTENSION    DeviceExtension,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    )

/*++

Routine Description:

    This routine performs a write to the config space of the SHPC.

Arguments:

    DeviceExtension - this device's device extension

    Buffer - a buffer to write the data from

    Offset - the offset in bytes into config space

    Length - the length in bytes into config space to be written

Return Value:

    The number of bytes written

--*/

{

    ULONG                   internalOffset;
    ULONG                   regOffset, regLength;
    ULONG                   registerNum;
    ULONG                   i;
    UCHAR                   busNumberBuffer;
    ULONG                   bytesRead;
    SHPC_CONFIG_SPACE       configWriteMask;
    NTSTATUS                status;
    KIRQL                   irql;

    internalOffset = Offset - (DeviceExtension->ConfigOffset);

    HpsLockRegisterSet(DeviceExtension,
                       &irql
                       );
    //
    // This check should have already been done when we verified that this was an access
    // to the SHPC
    //
    ASSERT((internalOffset + Length)<= sizeof(SHPC_CONFIG_SPACE));

    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-Internal Config Write at offset 0x%x for length 0x%x\n",
               internalOffset,
               Length
               );


    //
    // now overwrite the current config space, taking into account which bits were
    // written and the access mask for the config space
    //
    HpsWriteWithMask((PUCHAR)&DeviceExtension->ConfigSpace + internalOffset,
                     ConfigWriteMask + internalOffset,
                     (PUCHAR)Buffer,
                     Length
                     );

    if (IS_SUBSET(internalOffset,
                  Length,
                  FIELD_OFFSET(SHPC_CONFIG_SPACE,Data),
                  sizeof(DeviceExtension->ConfigSpace.Data)
                  )) {

        //
        // We've written the data register.  Update the register set.
        //
        registerNum = DeviceExtension->ConfigSpace.DwordSelect;
        ASSERT(registerNum < SHPC_NUM_REGISTERS);

        DbgPrintEx(DPFLTR_HPS_ID,
                   DPFLTR_INFO_LEVEL,
                   "HPS-Writing Register %d\n",
                   registerNum
                   );
        if (registerNum < SHPC_NUM_REGISTERS) {

            //
            // Perform the register specific write
            //
            regOffset = (internalOffset > FIELD_OFFSET(SHPC_CONFIG_SPACE,Data))
                        ? (internalOffset - FIELD_OFFSET(SHPC_CONFIG_SPACE,Data))
                        : 0;
            regLength = (internalOffset+Length)-(regOffset+FIELD_OFFSET(SHPC_CONFIG_SPACE,Data));
            RegisterWriteCommands[registerNum](DeviceExtension,
                                               registerNum,
                                               &DeviceExtension->ConfigSpace.Data,
                                               HPS_ULONG_WRITE_MASK(regOffset,regLength)
                                               );
        }
    }

    //
    // Make sure the config space representation reflects what just happened to
    // the register set.
    //
    HpsResync(DeviceExtension);

    HpsUnlockRegisterSet(DeviceExtension,
                         irql
                         );
    return;

}

NTSTATUS
HpsGetCapabilityOffset(
    IN  PHPS_DEVICE_EXTENSION   Extension,
    IN  UCHAR                   CapabilityID,
    OUT PUCHAR                  Offset
    )
/*++

Routine Description:

    This routine searches through the config space of this device for a
    PCI capability on the list that matches the specified CapabilityID.

Arguments:

    Extension - The device extension for the device.  This allows us access
        to config space.

    CapabilityID - The capability identifier to search for.

    Offset - a pointer to a UCHAR which will contain the offset into config
        space of the matching capability.

Return Value:

    STATUS_SUCCESS if the capability is found.
    STATUS_UNSUCCESSFUL otherwise.

    --*/
{
    PHPS_INTERFACE_WRAPPER  interfaceWrapper = &Extension->InterfaceWrapper;
    UCHAR                   statusReg, currentPtr;
    PCI_CAPABILITIES_HEADER capHeader;

    ASSERT(interfaceWrapper->PciContext != NULL);

    //
    // read the status register to see if we have a capabilities pointer
    //
    interfaceWrapper->PciGetBusData(interfaceWrapper->PciContext,
                                    PCI_WHICHSPACE_CONFIG,
                                    &statusReg,
                                    FIELD_OFFSET(PCI_COMMON_CONFIG,Status),
                                    sizeof(UCHAR));

    //
    // Capability exists bit is in the PCI status register
    //
    if (statusReg & PCI_STATUS_CAPABILITIES_LIST) {

        //
        // we have a capabilities pointer.  go get the capabilities
        //
        interfaceWrapper->PciGetBusData(interfaceWrapper->PciContext,
                                        PCI_WHICHSPACE_CONFIG,
                                        &currentPtr,
                                        FIELD_OFFSET(PCI_COMMON_CONFIG,u.type0.CapabilitiesPtr),
                                        sizeof(UCHAR));

        //
        // now walk through the list looking for given capability ID
        // Loop until the next capability ptr is 0.
        //

        while (currentPtr != 0) {

            //
            // This gets us a capability pointer.
            //
            interfaceWrapper->PciGetBusData(interfaceWrapper->PciContext,
                                            PCI_WHICHSPACE_CONFIG,
                                            &capHeader,
                                            currentPtr,
                                            sizeof(PCI_CAPABILITIES_HEADER));

            if (capHeader.CapabilityID == CapabilityID) {

                *Offset = currentPtr;
                return STATUS_SUCCESS;

            } else {

                currentPtr = capHeader.Next;
            }
        }
    }
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
HpsWriteWithMask(
    OUT PVOID        Destination,
    IN  PVOID        BitMask,
    IN  PVOID        Source,
    IN  ULONG        Length
    )
/*++

Routine Description:

    This routine overwrites the Destination parameter with Source for
    Length bytes, but only the bits that are specified in the BitMask
    Destination, Source and BitMask are all aligned.

Arguments:

    Destination - The destination of the write

    BitMask - A bitmask that indicates which bits of source to overwrite
              into Destination

    Source - Pointer to a buffer that will overwrite Destination

    Length - the number of bytes to write into Destination

Return Value

    NT status code

--*/
{

    PUCHAR bitMask = (PUCHAR) BitMask;
    PUCHAR source = (PUCHAR) Source;
    PUCHAR destination = (PUCHAR) Destination;
    ULONG i;
    UCHAR temp;


    for (i=0; i < Length; i++){
        temp = source[i] & bitMask[i];
        destination[i] &= ~bitMask[i];
        destination[i] |= temp;
    }

    return STATUS_SUCCESS;

}

VOID
HpsGetBridgeInfo(
    IN  PHPS_DEVICE_EXTENSION   Extension,
    OUT PHPTEST_BRIDGE_INFO     BridgeInfo
    )
/*++

Routine Description:

    This routine fills in a HPTEST_BRIDGE_INFO structure with the
    bus/dev/func of this device.

Arguments:

    Extension - the device extension associated with this device.

    BridgeInfo - a pointer to the HPTEST_BRIDGE_INFO structure to be
        filled in.

Return Value:

    VOID

--*/
{

    UCHAR busNumber;
    UCHAR devSel;

    Extension->InterfaceWrapper.PciGetBusData(Extension->InterfaceWrapper.PciContext,
                                              PCI_WHICHSPACE_CONFIG,
                                              &busNumber,
                                              FIELD_OFFSET(PCI_COMMON_CONFIG,u.type1.PrimaryBus),
                                              sizeof(UCHAR)
                                              );
    BridgeInfo->PrimaryBus = busNumber;

    Extension->InterfaceWrapper.PciGetBusData(Extension->InterfaceWrapper.PciContext,
                                              PCI_WHICHSPACE_CONFIG,
                                              &busNumber,
                                              FIELD_OFFSET(PCI_COMMON_CONFIG,u.type1.SecondaryBus),
                                              sizeof(UCHAR)
                                              );
    BridgeInfo->SecondaryBus = busNumber;

    //
    // TODO: do this for real.
    //
    BridgeInfo->DeviceSelect = 2;
    BridgeInfo->FunctionNumber = 0;

    return;
}

VOID
HpsLockRegisterSet(
    IN PHPS_DEVICE_EXTENSION Extension,
    OUT PKIRQL OldIrql
    )
{
    KeRaiseIrql(HIGH_LEVEL,
                OldIrql
                );
    KeAcquireSpinLockAtDpcLevel(&Extension->RegisterLock);
}

VOID
HpsUnlockRegisterSet(
    IN PHPS_DEVICE_EXTENSION Extension,
    IN KIRQL NewIrql
    )
{
    KeReleaseSpinLockFromDpcLevel(&Extension->RegisterLock);

    KeLowerIrql(NewIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\dispatch.c ===
/*++

Copyright (c) 2000  Microsoft Corporation All Rights Reserved

Module Name:

    dispatch.c

Abstract:

    This module handles the entry points to the driver and contains
    utilities used privately by these functions.

Environment:

    Kernel mode

Revision History:

    Davis Walker (dwalker) Sept 6 2000

--*/

#include "hpsp.h"

//
// Driver entry points
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

VOID
HpsUnload (
    IN PDRIVER_OBJECT   DriverObject
    );

NTSTATUS
HpsAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );

//
// IRP_MJ handlers
//

NTSTATUS
HpsDispatchPnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
HpsDispatchPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
HpsDispatchWmi (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
HpsCreateCloseDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
HpsDeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
HpsDispatchNop(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

UNICODE_STRING HpsRegistryPath;

//
// Dispatch table
//

#define IRP_MN_PNP_MAXIMUM_FUNCTION IRP_MN_QUERY_LEGACY_BUS_INFORMATION
#define IRP_MN_PO_MAXIMUM_FUNCTION  IRP_MN_QUERY_POWER

typedef
NTSTATUS
(*PHPS_DISPATCH)(
    IN PIRP Irp,
    IN PVOID Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

PHPS_DISPATCH HpsPnpLowerDispatchTable[] = {

    HpsStartLower,                  // IRP_MN_START_DEVICE
    HpsPassIrp,                     // IRP_MN_QUERY_REMOVE_DEVICE
    HpsRemoveLower,                 // IRP_MN_REMOVE_DEVICE
    HpsPassIrp,                     // IRP_MN_CANCEL_REMOVE_DEVICE
    HpsPassIrp,                     // IRP_MN_STOP_DEVICE
    HpsPassIrp,                     // IRP_MN_QUERY_STOP_DEVICE
    HpsPassIrp,                     // IRP_MN_CANCEL_STOP_DEVICE
    HpsPassIrp,                     // IRP_MN_QUERY_DEVICE_RELATIONS
    HpsQueryInterfaceLower,         // IRP_MN_QUERY_INTERFACE
    HpsPassIrp,                     // IRP_MN_QUERY_CAPABILITIES
    HpsPassIrp,                     // IRP_MN_QUERY_RESOURCES
    HpsPassIrp,                     // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    HpsPassIrp,                     // IRP_MN_QUERY_DEVICE_TEXT
    HpsPassIrp,                     // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    HpsPassIrp,                     // Unused
    HpsPassIrp,                     // IRP_MN_READ_CONFIG
    HpsWriteConfigLower,            // IRP_MN_WRITE_CONFIG
    HpsPassIrp,                     // IRP_MN_EJECT
    HpsPassIrp,                     // IRP_MN_SET_LOCK
    HpsPassIrp,                     // IRP_MN_QUERY_ID
    HpsPassIrp,                     // IRP_MN_QUERY_PNP_DEVICE_STATE
    HpsPassIrp,                     // IRP_MN_QUERY_BUS_INFORMATION
    HpsPassIrp,                     // IRP_MN_DEVICE_USAGE_NOTIFICATION
    HpsPassIrp,                     // IRP_MN_SURPRISE_REMOVAL
    HpsPassIrp                      // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
};

PHPS_DISPATCH HpsPnpUpperDispatchTable[] = {

    HpsPassIrp,                     // IRP_MN_START_DEVICE
    HpsPassIrp,                     // IRP_MN_QUERY_REMOVE_DEVICE
    HpsRemoveCommon,                // IRP_MN_REMOVE_DEVICE
    HpsPassIrp,                     // IRP_MN_CANCEL_REMOVE_DEVICE
    HpsPassIrp,                     // IRP_MN_STOP_DEVICE
    HpsPassIrp,                     // IRP_MN_QUERY_STOP_DEVICE
    HpsPassIrp,                     // IRP_MN_CANCEL_STOP_DEVICE
    HpsPassIrp,                     // IRP_MN_QUERY_DEVICE_RELATIONS
    HpsPassIrp,                     // IRP_MN_QUERY_INTERFACE
    HpsPassIrp,                     // IRP_MN_QUERY_CAPABILITIES
    HpsPassIrp,                     // IRP_MN_QUERY_RESOURCES
    HpsPassIrp,                     // IRP_MN_QUERY_RESOURCE_REQUIREMENTS
    HpsPassIrp,                     // IRP_MN_QUERY_DEVICE_TEXT
    HpsPassIrp,                     // IRP_MN_FILTER_RESOURCE_REQUIREMENTS
    HpsPassIrp,                     // Unused
    HpsPassIrp,                     // IRP_MN_READ_CONFIG
    HpsPassIrp,                     // IRP_MN_WRITE_CONFIG
    HpsPassIrp,                     // IRP_MN_EJECT
    HpsPassIrp,                     // IRP_MN_SET_LOCK
    HpsPassIrp,                     // IRP_MN_QUERY_ID
    HpsPassIrp,                     // IRP_MN_QUERY_PNP_DEVICE_STATE
    HpsPassIrp,                     // IRP_MN_QUERY_BUS_INFORMATION
    HpsPassIrp,                     // IRP_MN_DEVICE_USAGE_NOTIFICATION
    HpsPassIrp,                     // IRP_MN_SURPRISE_REMOVAL
    HpsPassIrp                      // IRP_MN_QUERY_LEGACY_BUS_INFORMATION
};

//
// WMI entry points
// 625 this order is important, must match up to indices in hpwmi.h  have appropriate comment.
//
WMIGUIDREGINFO HpsWmiGuidList[] =
{
    {
        &GUID_HPS_CONTROLLER_EVENT,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID      // Flag as an event
    },

    {
        &GUID_HPS_EVENT_CONTEXT,
        1,
        0
    },

    {
        &GUID_HPS_INIT_DATA,
        1,
        0
    },

    {
        &GUID_HPS_SLOT_METHOD,           // Guid
        1,                               // # of instances in each device
        0                                // Flags
    }
};

#define HpsWmiGuidCount (sizeof(HpsWmiGuidList)/sizeof(WMIGUIDREGINFO))

WMILIB_CONTEXT HpsWmiContext = {

    HpsWmiGuidCount,
    HpsWmiGuidList,         // GUID List
    HpsWmiRegInfo,          // QueryWmiRegInfo
    HpsWmiQueryDataBlock,   // QueryWmiDataBlock
    HpsWmiSetDataBlock,     // SetWmiDataBlock
    NULL,                   // SetWmiDataItem
    HpsWmiExecuteMethod,    // ExecuteWmiMethod
    HpsWmiFunctionControl   // WmiFunctionControl
};

LIST_ENTRY HpsDeviceExtensions;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, HpsUnload)
#pragma alloc_text (PAGE, HpsAddDevice)
#pragma alloc_text (PAGE, HpsDispatchPnp)
#pragma alloc_text (PAGE, HpsDispatchWmi)
#pragma alloc_text (PAGE, HpsCreateCloseDevice)
#pragma alloc_text (PAGE, HpsDeferProcessing)
#pragma alloc_text (PAGE, HpsSendPnpIrp)
#pragma alloc_text (PAGE, HpsPassIrp)
#pragma alloc_text (PAGE, HpsRemoveCommon)
// NOT PAGED, HpsCompletionRoutine
// NOT PAGED, HpsDeviceControl
// NOT PAGED, HpsDispatchPower
// NOT PAGED, HpsDispatchNop

#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )

/*++

Routine Description:

    Driver entry point.  This routine sets up entry points for
    all future accesses

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to a driver-specific registry key

Return Value:

    STATUS_SUCCESS

--*/
{
    ULONG index;
    PDRIVER_DISPATCH *dispatch;

    HpsRegistryPath.Buffer = ExAllocatePool(NonPagedPool,
                                            RegistryPath->MaximumLength
                                            );
    if (!HpsRegistryPath.Buffer) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyUnicodeString(&HpsRegistryPath,
                         RegistryPath
                         );

    InitializeListHead(&HpsDeviceExtensions);

    //
    // Create Dispatch Points
    //

    DriverObject->MajorFunction[IRP_MJ_PNP] = HpsDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = HpsDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = HpsDispatchWmi;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = HpsCreateCloseDevice;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = HpsCreateCloseDevice;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = HpsDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = HpsDispatchNop;
    DriverObject->DriverExtension->AddDevice = HpsAddDevice;
    DriverObject->DriverUnload = HpsUnload;

    return STATUS_SUCCESS;

}

VOID
HpsUnload (
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Routine to free all resources allocated to the driver

Arguments:

    DriverObject - pointer to the driver object originally passed
                   to the DriverEntry routine

Return Value:

    VOID

--*/
{

    PAGED_CODE();

    //
    // Device Object should be NULL by now
    //

    ASSERT(DriverObject->DeviceObject == NULL);

    if (HpsRegistryPath.Buffer) {
        ExFreePool(HpsRegistryPath.Buffer);
    }

    return;

}

NTSTATUS
HpsAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

Routine Description:

    Create an FDO for ourselves and attach it to the stack.
    This has to deal with the fact that our driver could either
    be loaded as an upper or lower filter.  It creates a different
    device extension and has different initialization for these
    two cases.

    The upper filter exists solely so that the fdo of the device stack
    doesn't fail requests before we get a chance to trap them.  Virtually
    all of the work of the driver happens in the lower filter.

Arguments:

    Driver Object - pointer to our driver object

    PhysicalDeviceObject - pointer to the PDO we are asked to attach to

Return Value:

    NT Status code.
    STATUS_SUCCESS if successful

--*/
{

    BOOLEAN                     initialized=FALSE;
    NTSTATUS                    status;
    PDEVICE_OBJECT              deviceObject = NULL;
    PDEVICE_OBJECT              lowerFilter = NULL;
    PHPS_DEVICE_EXTENSION       deviceExtension;
    PHPS_COMMON_EXTENSION       commonExtension;

    PAGED_CODE();

    //
    // Query our location on the stack.  If upperFilter comes back
    // NULL, we're the lower filter.
    //
    status = HpsGetLowerFilter(PhysicalDeviceObject,
                               &lowerFilter
                               );

    //
    // Create the FDO, differently for upper and lower filter
    //

    if (NT_SUCCESS(status) &&
        (lowerFilter != NULL)) {

        //
        // We're an upper filter.  Create a devobj with a limited extension,
        // essentially just large enough to identify itself as the upper
        // filter and to save its place on the stack
        //

        status = IoCreateDevice(DriverObject,
                                sizeof(HPS_COMMON_EXTENSION),
                                NULL,                       // FDOs are not named
                                FILE_DEVICE_BUS_EXTENDER,   // since this is a bus driver filter
                                FILE_DEVICE_SECURE_OPEN,    // to apply security descriptor to opens
                                FALSE,
                                &deviceObject
                                );

        if (!NT_SUCCESS(status)) {

            goto cleanup;
        }

        //
        // Initialize device extension
        //
        commonExtension = deviceObject->DeviceExtension;
        commonExtension->ExtensionTag = HpsUpperDeviceTag;
        commonExtension->Self = deviceObject;
        commonExtension->LowerDO = IoAttachDeviceToDeviceStack (
                                                    deviceObject,
                                                    PhysicalDeviceObject
                                                    );
        if (commonExtension->LowerDO == NULL) {
    
            status = STATUS_UNSUCCESSFUL;
            goto cleanup;
        }

    } else {

        //
        // We're the lower filter
        //

        status = IoCreateDevice(DriverObject,
                                sizeof(HPS_DEVICE_EXTENSION),
                                NULL,                       // FDOs are not named
                                FILE_DEVICE_BUS_EXTENDER,   // since this is a bus driver filter
                                FILE_DEVICE_SECURE_OPEN,    // to apply security descriptor to opens
                                FALSE,
                                &deviceObject
                                );

        if (!NT_SUCCESS(status)) {

            goto cleanup;
        }

        //
        // Initialize device extension
        //

        deviceExtension = deviceObject->DeviceExtension;
        deviceExtension->ExtensionTag = HpsLowerDeviceTag;
        deviceExtension->PhysicalDO = PhysicalDeviceObject;
        deviceExtension->Self = deviceObject;
        deviceExtension->LowerDO = IoAttachDeviceToDeviceStack (
                                                    deviceObject,
                                                    PhysicalDeviceObject
                                                    );
        if (deviceExtension->LowerDO == NULL) {
    
            status = STATUS_UNSUCCESSFUL;
            goto cleanup;
        }
        status = HpsGetBusInterface(deviceExtension);
        if (NT_SUCCESS(status)) {
            
            deviceExtension->UseConfig = TRUE;
            status = HpsInitConfigSpace(deviceExtension);
            if (NT_SUCCESS(status)) {
    
                initialized=TRUE;
                
            }
        }

        if (initialized == FALSE) {
            
            deviceExtension->UseConfig = FALSE;   
            status = HpsInitHBRB(deviceExtension);
            if (!NT_SUCCESS(status)) {
                
                goto cleanup;
            }
            
        }       

        if (deviceExtension->HwInitData.NumSlots != 0) {
            deviceExtension->SoftDevices = ExAllocatePool(PagedPool,
                                                          deviceExtension->HwInitData.NumSlots * sizeof(PSOFTPCI_DEVICE)
                                                          );
            if (!deviceExtension->SoftDevices) {

                goto cleanup;
            }
            RtlZeroMemory(deviceExtension->SoftDevices, deviceExtension->HwInitData.NumSlots * sizeof(PSOFTPCI_DEVICE));
        }

        //
        // Register device interface
        //
        deviceExtension->SymbolicName = ExAllocatePoolWithTag(PagedPool,
                                                              sizeof(UNICODE_STRING),
                                                              HpsStringPool
                                                              );
        if (!deviceExtension->SymbolicName) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
        RtlInitUnicodeString(deviceExtension->SymbolicName,
                             NULL
                             );
        status = IoRegisterDeviceInterface(deviceExtension->PhysicalDO,
                                           &GUID_HPS_DEVICE_CLASS,
                                           NULL,
                                           deviceExtension->SymbolicName
                                           );
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        deviceExtension->EventsEnabled = FALSE;
        deviceExtension->WmiEventContext = NULL;
        deviceExtension->WmiEventContextSize = 0;
        status = IoWMIRegistrationControl(deviceObject,
                                          WMIREG_ACTION_REGISTER
                                          );
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        KeInitializeDpc(&deviceExtension->EventDpc,
                        HpsEventDpc,
                        deviceExtension
                        );

        KeInitializeSpinLock(&deviceExtension->IntSpinLock);
        KeInitializeSpinLock(&deviceExtension->RegisterLock);

    }

    //
    // Initialize device object flags
    //
    commonExtension = (PHPS_COMMON_EXTENSION)deviceObject->DeviceExtension;
    deviceObject->Flags |= commonExtension->LowerDO->Flags &
                                (DO_POWER_PAGABLE | DO_POWER_INRUSH |
                                 DO_BUFFERED_IO | DO_DIRECT_IO
                                 );


    //
    // Everything worked successfully
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;

cleanup:

    if (deviceObject != NULL) {
        //
        // Make sure we're not still attached
        //
        commonExtension = (PHPS_COMMON_EXTENSION)deviceObject->DeviceExtension;
        ASSERT(commonExtension->LowerDO == NULL);
        if (commonExtension->ExtensionTag = HpsLowerDeviceTag) {
            deviceExtension = (PHPS_DEVICE_EXTENSION)commonExtension;
            IoWMIRegistrationControl(deviceObject,
                                     WMIREG_ACTION_DEREGISTER
                                     );
            if (deviceExtension->SoftDevices) {
                ExFreePool(deviceExtension->SoftDevices);
            }
            if (deviceExtension->SymbolicName) {
                ExFreePool(deviceExtension->SymbolicName);
            }
        }

        IoDeleteDevice(deviceObject);
    }

    return status;

}

//
// IRP_MJ handler routines
//

NTSTATUS
HpsDispatchPnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The PnP dispatch routine.  For most IRP_MN codes, we
    simply pass the IRP on.  The others are dealt with in
    this function.

    The upper filter trivially passes all IRP_MN codes except
    for remove.  The lower filter has a bit more work to do.

Arguments:

    DeviceObject - pointer to the device object that represents us

    Irp - pointer to the IRP to be serviced

Return Value:

    NT status code

--*/
{

    NTSTATUS                status;
    PHPS_DEVICE_EXTENSION   deviceExtension;
    PHPS_COMMON_EXTENSION   commonExtension;
    PIO_STACK_LOCATION      irpStack;

    PAGED_CODE();

    //
    // Both upper and lower devexts start with an extension tag
    // for identification
    //
    commonExtension = (PHPS_COMMON_EXTENSION)DeviceObject->DeviceExtension;

    ASSERT((commonExtension->ExtensionTag == HpsUpperDeviceTag) ||
           (commonExtension->ExtensionTag == HpsLowerDeviceTag));

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    if (irpStack->MinorFunction <= IRP_MN_PNP_MAXIMUM_FUNCTION) {

        //
        // Since many of our dispatch functions do strange things like completing
        // IRPs that usually shouldn't be completed and deferring processing, we
        // let each one deal with passing the IRP along instead of doing it centrally
        //
        if (commonExtension->ExtensionTag == HpsUpperDeviceTag) {

            status = HpsPnpUpperDispatchTable[irpStack->MinorFunction](Irp,
                                                                       commonExtension,
                                                                       irpStack
                                                                       );
        } else {

            //
            // We're the lower filter
            //
            deviceExtension = (PHPS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

            status = HpsPnpLowerDispatchTable[irpStack->MinorFunction](Irp,
                                                                       deviceExtension,
                                                                       irpStack
                                                                       );
        }

    } else {

        status = HpsPassIrp(Irp,
                            commonExtension,
                            irpStack
                            );
    }

    return status;
}



NTSTATUS
HpsDispatchPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The dispatch routine for IRP_MJ_POWER Irps.  We don't care about
    power at all, so these simply pass the IRP down to the next lower
    driver.

Arguments:

    DeviceObject - pointer to our device object

    Irp - pointer to the current Irp

Return Value:

    NT Status Code, as returned from processing by next lower driver

--*/
{
    PHPS_COMMON_EXTENSION extension = (PHPS_COMMON_EXTENSION) DeviceObject->DeviceExtension;

    //
    // NOT PAGED
    //

    ASSERT(extension->ExtensionTag == HpsUpperDeviceTag ||
           extension->ExtensionTag == HpsLowerDeviceTag);

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(extension->LowerDO,
                        Irp
                        );

}

NTSTATUS
HpsDispatchWmi (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The WMI dispatch routine.

    The upper filter trivially passes all IRP_MN codes.
    The lower filter dispatches the request to the appropriate
    routine in the dispatch table.

Arguments:

    DeviceObject - pointer to the device object that represents us

    Irp - pointer to the IRP to be serviced

Return Value:

    NT status code

--*/
{

    PHPS_COMMON_EXTENSION   commonExtension;
    PIO_STACK_LOCATION      irpStack;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Both upper and lower devexts start with an extension tag
    // for identification
    //
    commonExtension = (PHPS_COMMON_EXTENSION)DeviceObject->DeviceExtension;

    ASSERT((commonExtension->ExtensionTag == HpsUpperDeviceTag) ||
           (commonExtension->ExtensionTag == HpsLowerDeviceTag));

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    if (commonExtension->ExtensionTag == HpsUpperDeviceTag) {

        status = HpsPassIrp(Irp,
                            commonExtension,
                            irpStack
                            );
    } else {

        //
        // Call WmiSystemControl to crack the IRP and call the appropriate
        // callbacks.
        //
        status = WmiSystemControl(&HpsWmiContext,
                                  commonExtension->Self,
                                  Irp,
                                  &disposition
                                  );
        switch (disposition) {
            case IrpProcessed:
                //
                // The IRP has been fully processed and is out of our hands
                //
                break;

            case IrpNotCompleted:
                //
                // We need to complete the IRP
                //
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;

            case IrpForward:
            case IrpNotWmi:
            default:
                //
                // We need to pass the IRP down.
                //
                status = HpsPassIrp(Irp,
                                    commonExtension,
                                    irpStack
                                    );
                break;

        }
    }

    return status;
}

NTSTATUS
HpsCreateCloseDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The handler routine for IRP_MJ_CREATE requests.  In order
    to communicate with the user mode portion of the simulator,
    this routine must succeed these requests.  In this case, however,
    there is no other work to do.

Arguments:

    DeviceObject - Pointer to the device object for this stack location

    Irp - Pointer to the current IRP

Return Value:

    STATUS_SUCCESS
--*/
{
    PAGED_CODE();
    UNREFERENCED_PARAMETER(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
HpsDeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The handler routine for IRP_MJ_DEVICE_CONTROL IRPs. This routine
    handles the communication with the user mode portion of the
    simulator

Arguments:

    Device Object - Pointer to the device object for this stack location

    Irp - Pointer to the current IRP

Return Value:

    NT status code
--*/
{

    NTSTATUS                        status;
    PIO_STACK_LOCATION              irpStack;
    PHPS_DEVICE_EXTENSION           deviceExtension;
    PHPS_COMMON_EXTENSION           commonExtension;

    //
    // NOT PAGED
    //

    commonExtension = (PHPS_COMMON_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT((commonExtension->ExtensionTag == HpsUpperDeviceTag) ||
           (commonExtension->ExtensionTag == HpsLowerDeviceTag));

    if (commonExtension->ExtensionTag == HpsUpperDeviceTag) {

        //
        // For an upper filter, we don't want to handle these.
        // Just pass them down.
        //
        status = STATUS_NOT_SUPPORTED;

    } else {

        irpStack = IoGetCurrentIrpStackLocation(Irp);
        deviceExtension = (PHPS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

        status = HpsDeviceControlLower(Irp,
                                       deviceExtension,
                                       irpStack
                                       );
    }

    //
    // Unless the status is STATUS_NOT_SUPPORTED or STATUS_PENDING,
    // we always complete this request because we only support
    // private IOCTLs that will fail if they are passed down.
    //
    if (status == STATUS_NOT_SUPPORTED) {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(commonExtension->LowerDO,
                            Irp
                            );
    } else if (status == STATUS_PENDING) {
        return status;

    } else {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,
                          IO_NO_INCREMENT
                          );
        return status;
    }

}

NTSTATUS
HpsDispatchNop(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PHPS_COMMON_EXTENSION commonExtension = (PHPS_COMMON_EXTENSION) DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(commonExtension->LowerDO,
                        Irp
                        );
}

NTSTATUS
HpsRemoveCommon(
    IN PIRP Irp,
    IN PHPS_COMMON_EXTENSION Common,
    IN PIO_STACK_LOCATION IrpStack
    )
/*++
Routine Description:

    This function performs the default remove handling for the driver.

Arguments:

    Irp - The IRP that caused this request

    Common - Device Extension for this device

    IrpStack - The current IRP stack location

Return Value:

    NT Status code
--*/
{
    NTSTATUS status;

    PAGED_CODE();

    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-IRP Remove\n"
               );
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation(Irp);
    status = IoCallDriver(Common->LowerDO,
                          Irp
                          );

    IoDetachDevice(Common->LowerDO);
    IoDeleteDevice(Common->Self);

    return status;
}

NTSTATUS
HpsPassIrp(
    IN PIRP Irp,
    IN PHPS_COMMON_EXTENSION Common,
    IN PIO_STACK_LOCATION IrpStack
    )
/*++

Function Description:

    This routine is the default handler for PNP Irps.  It simply passes
    the request down to the next location in the stack

Arguments:

    Irp - The IRP that caused this request

    Common - The Device Extension for this device

    IrpStack - The current IRP stack location

Return Value:

    NT Status code
--*/
{
    PAGED_CODE();

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(Common->LowerDO,
                        Irp
                        );
}

NTSTATUS
HpsDeferProcessing (
    IN PHPS_COMMON_EXTENSION Common,
    IN PIRP                  Irp
    )
/*++

Routine Description:

    This routine defers processing of an IRP until after a completion routine
    has fired.  In this case, the completion routine simply fires the event
    that is initialized in this routine.  By the time this routine returns, we
    can be guaranteed that all lower drivers have finished processing the IRP.

Arguments:

    DeviceExtension - pointer to the current device extension

    Irp - pointer to the current IRP

Return Value:

    NT status code

--*/

{

    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE
                      );

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           HpsCompletionRoutine,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );
    status = IoCallDriver(Common->LowerDO,
                          Irp
                          );

    if (status == STATUS_PENDING) {

        // we're still waiting on a lower driver to complete, so wait for
        // the completion routine event to fire

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
    }

    // by now, the completion routine must have executed

    return Irp->IoStatus.Status;

}

NTSTATUS
HpsCompletionRoutine (
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp,
    IN PVOID           Context
    )

/*++

Routine Description:

    A simple completion routine for a PNP Irp. It simply fires an event
    and returns STATUS_MORE_PROCESSING_REQUIRED, thereby returning control
    to the function that set the completion routine in the first place.
    This is done rather than performing the postprocessing tasks directly
    in the completion routine because completion routines can be called at
    Dispatch IRQL, meaning, among other things, no access to paged pool.

Arguments:

    DeviceObject - pointer to our device object

    Irp - pointer to the current Irp

    Context - the context for this completion routine; in this case an
              event to be fired.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    //
    // NOT PAGED
    //
    UNREFERENCED_PARAMETER(DeviceObject);

    KeSetEvent((PKEVENT) Context,
               IO_NO_INCREMENT,
               FALSE
               );

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
HpsSendPnpIrp(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIO_STACK_LOCATION  IrpStack,
    OUT PULONG_PTR          Information OPTIONAL
    )
/*++

Routine Description:

    This builds and send a pnp irp to a device.

Arguments:

    DeviceObject - The a device in the device stack the irp is to be sent to -
        the top of the device stack is always found and the irp sent there first.

    IrpStack - The initial stack location to use - contains the IRP minor code
        and any parameters

    Information - If provided contains the final value of the irps information
        field.

Return Value:

    The final status of the completed irp or an error if the irp couldn't be sent

--*/
{

    NTSTATUS            status;
    PIRP                irp = NULL;
    PIO_STACK_LOCATION  newSp;
    PDEVICE_OBJECT      targetDevice = NULL;
    KEVENT              event;

    PAGED_CODE();

    ASSERT(IrpStack->MajorFunction == IRP_MJ_PNP);

    //
    // Find out where we are sending the irp
    //
    targetDevice = IoGetAttachedDeviceReference(DeviceObject);

    //
    // Get an IRP
    //
    irp = IoAllocateIrp(targetDevice->StackSize,FALSE);
    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    //
    // Initialize the IRP
    //
    ASSERT(IrpStack->MajorFunction == IRP_MJ_PNP);
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Initialize the top stack location with the parameters passed in.
    //
    newSp = IoGetNextIrpStackLocation(irp);
    RtlCopyMemory(newSp, IrpStack, sizeof(IO_STACK_LOCATION));

    //
    // Call the driver and wait for completion
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoSetCompletionRoutine(irp,
                           HpsCompletionRoutine,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );
    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = irp->IoStatus.Status;
    }

    //
    // Return the information
    //
    if (ARGUMENT_PRESENT(Information)) {

        if (!NT_ERROR(status)) {

            *Information = irp->IoStatus.Information;

        } else {

            //
            // If it's an error, PnP will ignore the information value. If the
            // driver expected PnP to free some memory, it is going to be
            // sorely mistaken.
            //
            ASSERT(irp->IoStatus.Information == 0);
            *Information = 0;
        }
    }

cleanup:

    if (irp) {
        IoFreeIrp(irp);
    }

    ObDereferenceObject(targetDevice);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\hpsfunc.h ===
#ifndef _HPFUNC_H
#define _HPFUNC_H

//
// Shared function declarations
//

//
// dispatch.c
//

// all other dispatch.c function declarations are in dispatch.c
// since functions are private to that file

NTSTATUS
HpsPassIrp(
    IN PIRP Irp,
    IN PHPS_COMMON_EXTENSION Common,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
HpsSendPnpIrp(
    IN  PDEVICE_OBJECT       DeviceObject,
    IN  PIO_STACK_LOCATION   Location,
    OUT PULONG_PTR           Information OPTIONAL
    );

NTSTATUS
HpsDeferProcessing(
    IN PHPS_COMMON_EXTENSION    DeviceExtension,
    IN PIRP                     Irp
    );

NTSTATUS
HpsRemoveCommon(
    IN PIRP Irp,
    IN PHPS_COMMON_EXTENSION Common,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
HpsCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );


//
// lower.c
//
NTSTATUS
HpsStartLower(
    IN PIRP Irp,
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
HpsRemoveLower(
    IN PIRP Irp,
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
HpsStopLower(
    IN PIRP Irp,
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
HpsQueryInterfaceLower(
    IN PIRP Irp,
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
HpsWriteConfigLower(
    IN PIRP Irp,
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    );

NTSTATUS
HpsDeviceControlLower(
    PIRP Irp,
    PHPS_DEVICE_EXTENSION Common,
    PIO_STACK_LOCATION IrpStack
    );

//
// intrface.c
//

NTSTATUS
HpsGetBusInterface(
    PHPS_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
HpsTrapBusInterface (
    IN     PHPS_DEVICE_EXTENSION  DeviceExtension,
    IN OUT PIO_STACK_LOCATION     IrpStack
    );

NTSTATUS
HpsGetLowerFilter (
    IN  PDEVICE_OBJECT   DeviceObject,
    OUT PDEVICE_OBJECT   *LowerDeviceObject
    );

VOID
HpsGenericInterfaceReference (
    PVOID Context
    );

VOID
HpsGenericInterfaceDereference (
    PVOID Context
    );

VOID
HpsBusInterfaceReference (
    PVOID Context
    );

VOID
HpsBusInterfaceDereference (
    PVOID Context
    );

//
// interrupt.c
//
VOID
HpsInterruptExecution(
    IN PHPS_DEVICE_EXTENSION Extension
    );

NTSTATUS
HpsConnectInterrupt(
    IN PVOID  Context,
    IN PKSERVICE_ROUTINE  ServiceRoutine,
    IN PVOID  ServiceContext
    );

VOID
HpsDisconnectInterrupt(
    IN PVOID Context
    );

BOOLEAN
HpsSynchronizeExecution(
    IN PVOID Context,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

//
// config.c
//

NTSTATUS
HpsInitConfigSpace(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    );

ULONG
HpsHandleDirectReadConfig(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HpsHandleDirectWriteConfig(
    IN PVOID Context,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
HpsResync(
    IN PHPS_DEVICE_EXTENSION DeviceExtension
    );

VOID
HpsWriteConfig(
    IN PHPS_DEVICE_EXTENSION    DeviceExtension,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

NTSTATUS
HpsGetCapabilityOffset(
    PHPS_DEVICE_EXTENSION   Extension,
    UCHAR                   CapabilityID,
    PUCHAR                  Offset
    );

NTSTATUS
HpsWriteWithMask(
    OUT PVOID       Destination,
    IN  PVOID       BitMask,
    IN  PVOID       Source,
    IN  ULONG       Length
    );

VOID
HpsMaskConfig(
    OUT PUCHAR      Destination,
    IN  PUCHAR      Source,
    IN  ULONG       InternalOffset,
    IN  ULONG       Length
    );

VOID
HpsGetBridgeInfo(
    PHPS_DEVICE_EXTENSION Extension,
    PHPTEST_BRIDGE_INFO BridgeInfo
    );

VOID
HpsLockRegisterSet(
    IN PHPS_DEVICE_EXTENSION Extension,
    OUT PKIRQL OldIrql
    );

VOID
HpsUnlockRegisterSet(
    IN PHPS_DEVICE_EXTENSION Extension,
    IN KIRQL NewIrql
    );

//
// memory.c
//
NTSTATUS
HpsInitHBRB(
    IN PHPS_DEVICE_EXTENSION Extension
    );

NTSTATUS
HpsGetHBRBHwInit(
    IN PHPS_DEVICE_EXTENSION Extension
    );

NTSTATUS
HpsSendIoctl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

VOID
HpsMemoryInterfaceReference(
    IN PVOID Context
    );

VOID
HpsMemoryInterfaceDereference(
    IN PVOID Context
    );

VOID
HpsReadRegister(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

VOID
HpsWriteRegister(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

PHPS_DEVICE_EXTENSION
HpsFindExtensionForHbrb(
    IN PUCHAR Register,
    IN ULONG Length
    );

//
// register.c
//

NTSTATUS
HpsInitRegisters(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    );

VOID
HpsHandleSlotEvent (
    IN OUT PHPS_DEVICE_EXTENSION    DeviceExtension,
    IN     PHPS_SLOT_EVENT          SlotEvent
    );

VOID
HpsPerformControllerCommand (
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    );

VOID
HpsEventDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
HpsSendEventToWmi(
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PHPS_CONTROLLER_EVENT Event
    );

VOID
HpsCommandCompleted(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    );

//
// wmi.c
//
NTSTATUS
HpsWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
HpsWmiQueryDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
HpsWmiSetDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
HpsWmiExecuteMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );

NTSTATUS
HpsWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\hpsp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation All Rights Reserved

Module Name:

    hpsp.h

Abstract:

    This header file contains the private structure and function
    declarations for the hotplugsim driver

Environment:

    Kernel Mode

Revision History:

    Davis Walker (dwalker) Sept 8 2000

--*/

#ifndef HPSP_H
#define HPSP_H

//#include <ntos.h>
//#include <ntrtl.h>
#include <ntddk.h>
//#include <pci.h>
#include "shpc.h"
#include "interface.h"
#include "hpsim.h"
#include "hptest.h"
#include "simguid.h"
#include "wdmguid.h"
#include "wmilib.h"
#include "wmistr.h"
#include "acpiioct.h"
#include "spci.h"
#include "hpwmi.h"
#include "hpsstruct.h"
#include "hpsfunc.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\interrupt.c ===
/*++

Copyright (c) 2000  Microsoft Corporation All Rights Reserved

Module Name:

    interrupt.c

Abstract:

    This module contains the functions for handling simulated interrupts
    to the hotplug controller.

Environment:

    Kernel mode

Revision History:

    Davis Walker (dwalker) Sept 6 2000

--*/

#include "hpsp.h"

BOOLEAN HpsInterruptPending = FALSE;

VOID
HpsInterruptExecution(
    IN PHPS_DEVICE_EXTENSION Extension
    )
{
    KIRQL oldIrql;

    HpsInterruptPending = TRUE;

    oldIrql = KeGetCurrentIrql();
    if (oldIrql >= PROFILE_LEVEL-1) {
        //
        // These interrupts are currently masked.  This will
        // only happen because we are in HpsSynchronizeExecution.
        // So set a flag indicating that there is a pending interrupt
        // so that SynchronizeExecution will execute the ISR.
        //

        return;

    } else {

        HpsInterruptPending = FALSE;

        KeRaiseIrql(PROFILE_LEVEL-1,
                    &oldIrql
                    );

        KeAcquireSpinLockAtDpcLevel(&Extension->IntSpinLock);

        Extension->IntServiceRoutine((PKINTERRUPT)Extension,
                                     Extension->IntServiceContext
                                     );

        KeReleaseSpinLockFromDpcLevel(&Extension->IntSpinLock);

        KeLowerIrql(oldIrql);
    }

}

//
// Interrupt Interface Functions
//


NTSTATUS
HpsConnectInterrupt(
    IN PVOID  Context,
    IN PKSERVICE_ROUTINE  ServiceRoutine,
    IN PVOID  ServiceContext
    )
/*++

Routine Description:

    This routine is the hps version of IoConnectInterrupt.  It has the same
    semantics and is called in the same situations.  This is called by the
    SHPC driver to register an ISR with the simulator so that the SHPC driver
    can receive simulated interrupts.

Arguments:

    ServiceRoutine - A pointer to the ISR

    ServiceContext - The context with which this routine is called.  In this
        case, it is a device extension.

    The rest of the arguments are ignored.

Return Value:

    STATUS_SUCCESS

--*/
{
    PHPS_DEVICE_EXTENSION deviceExtension;

    deviceExtension = (PHPS_DEVICE_EXTENSION) Context;
    deviceExtension->IntServiceRoutine = ServiceRoutine;
    deviceExtension->IntServiceContext = ServiceContext;

    return STATUS_SUCCESS;
}

VOID
HpsDisconnectInterrupt(
    IN PVOID Context
    )
{
    PHPS_DEVICE_EXTENSION deviceExtension = (PHPS_DEVICE_EXTENSION)Context;

    deviceExtension->IntServiceRoutine = NULL;
    deviceExtension->IntServiceContext = NULL;
}

BOOLEAN
HpsSynchronizeExecution(
    IN PVOID Context,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    )
{
    PHPS_DEVICE_EXTENSION Extension = (PHPS_DEVICE_EXTENSION)Context;
    KIRQL oldIrql;

    KeRaiseIrql(PROFILE_LEVEL-1,
                &oldIrql
                );

    KeAcquireSpinLockAtDpcLevel(&Extension->IntSpinLock);

    SynchronizeRoutine(SynchronizeContext);

    //
    // If there's a pending interrupt, it gets serviced at this
    // IRQL as well, so call it.
    //
    if (HpsInterruptPending) {
        HpsInterruptPending = FALSE;
        Extension->IntServiceRoutine((PKINTERRUPT)Extension,
                                     Extension->IntServiceContext
                                     );
    }

    KeReleaseSpinLockFromDpcLevel(&Extension->IntSpinLock);

    KeLowerIrql(oldIrql);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\hpsstruct.h ===
#ifndef _HPSSTRUCT_H
#define _HPSSTRUCT_H

#define HPS_WMI_LEVEL (0x10|DPFLTR_MASK)

extern UNICODE_STRING HpsRegistryPath;
extern LIST_ENTRY HpsDeviceExtensions;

typedef struct _HPS_EVENT_WORKITEM {
    PIO_WORKITEM WorkItem;
    PHPS_CONTROLLER_EVENT Event;

} HPS_EVENT_WORKITEM, *PHPS_EVENT_WORKITEM;

typedef struct _HPS_INTERFACE_WRAPPER {

    PVOID                   PciContext;
    PINTERFACE_REFERENCE    PciInterfaceReference;
    PINTERFACE_DEREFERENCE  PciInterfaceDereference;
    PGET_SET_DEVICE_DATA    PciSetBusData;
    PGET_SET_DEVICE_DATA    PciGetBusData;

} HPS_INTERFACE_WRAPPER, *PHPS_INTERFACE_WRAPPER;

//
// Device Object defines and structures
//

typedef enum _HPS_DEVICE_TAG {
    HpsUpperDeviceTag = 'UspH',
    HpsLowerDeviceTag = 'LspH'

} HPS_DEVICE_TAG;

typedef struct _HPS_DEVICE_EXTENSION {

    //
    // These three variables are the same as HPS_COMMON_EXTENSION,
    // so rearranging them requires rearranging the
    // HPS_COMMON_EXTENSION declaration as well
    //
    HPS_DEVICE_TAG          ExtensionTag;
    PDEVICE_OBJECT          LowerDO;
    PDEVICE_OBJECT          Self;

    //
    // List entry to link all hps device extensions together.
    //
    LIST_ENTRY              ListEntry;
    
    PDEVICE_OBJECT          PhysicalDO;
    PUNICODE_STRING         SymbolicName;
    PVOID                   WmiEventContext;
    ULONG                   WmiEventContextSize;
    KDPC                    EventDpc;
    HPS_CONTROLLER_EVENT    CurrentEvent;
    PSOFTPCI_DEVICE         *SoftDevices;

    BOOLEAN                 EventsEnabled;
    UCHAR                   ConfigOffset;

    PKSERVICE_ROUTINE       IntServiceRoutine;
    PVOID                   IntServiceContext;
    KSPIN_LOCK              IntSpinLock;

    BOOLEAN                 UseConfig;
    HPS_INTERFACE_WRAPPER   InterfaceWrapper;
    PUCHAR                  HBRBOffset;
    ULONG                   HBRBLength;
    ULONG                   HBRBRegisterSetOffset;
    PVOID                   HBRB;
    
    HPS_HWINIT_DESCRIPTOR   HwInitData;
    SHPC_CONFIG_SPACE       ConfigSpace;
    SHPC_REGISTER_SET       RegisterSet;
    KSPIN_LOCK              RegisterLock;

    LONG                   MemoryInterfaceCount;

} HPS_DEVICE_EXTENSION, *PHPS_DEVICE_EXTENSION;

typedef struct _HPS_COMMON_EXTENSION {

    HPS_DEVICE_TAG  ExtensionTag;
    PDEVICE_OBJECT  LowerDO;
    PDEVICE_OBJECT  Self;

} HPS_COMMON_EXTENSION, *PHPS_COMMON_EXTENSION;

//
// Interface structures and defines
//
typedef struct _HPS_PING_INTERFACE {


    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    PDEVICE_OBJECT SenderDevice;


} HPS_PING_INTERFACE, *PHPS_PING_INTERFACE;

DEFINE_GUID(GUID_HPS_PING_INTERFACE,0x0c76ca29, 0x4f2a, 0x4870,
            0xa4, 0xdd, 0xc1, 0xa7, 0x56, 0x1a, 0xf7, 0xc7);


#define HPS_EQUAL_GUID(x,y)       \
    (RtlEqualMemory((PVOID)(x), (PVOID)(y), sizeof(GUID)))


//
// Register Writing Variables
//
extern UCHAR ConfigWriteMask[];
extern ULONG RegisterReadOnlyMask[];
extern ULONG RegisterWriteClearMask[];


typedef
VOID
(*PHPS_WRITE_REGISTER)(
    PHPS_DEVICE_EXTENSION   DeviceExtension,
    ULONG                   RegisterNum,
    PULONG                  Source,
    ULONG                   BitMask
    );

extern PHPS_WRITE_REGISTER RegisterWriteCommands[];

#define IS_SUBSET(_inner,_ilength,_outer,_olength)      \
    ((_outer <= _inner) && ((_outer+_olength) >= (_inner+_ilength)))

//
// Returns a ULONG that is a bit mask of the bits in the ULONG written
// where all bits from _offset for _length were written.
//
#define HPS_ULONG_WRITE_MASK(_offset,_length)   \
    (((1 << (_length*8)) - 1) << (_offset * 8))

#define FOR_ALL_IN_LIST(Type, Head, Current)                            \
    for((Current) = CONTAINING_RECORD((Head)->Flink, Type, ListEntry);  \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = CONTAINING_RECORD((Current)->ListEntry.Flink,        \
                                     Type,                              \
                                     ListEntry)                         \
       )

//
// Pool Tags
//

typedef enum _HPS_POOL_TAG {
    HpsInterfacePool = 'IspH',
    HpsTempPool = 'TspH',
    HpsStringPool = 'SspH'

} HPS_POOL_TAG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\shpcmasks.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    shpcmasks.c

Abstract:

    This module contains global data indicating the type of each of the
    bits in the SHPC register set.

Author:

    Davis Walker (dwalker) 2 Feb 2001

Revision History:

--*/

#include "hpsp.h"

UCHAR ConfigWriteMask[] = {
    0x00,
    0x00,    // Capability Header
    0xFF,    // DwordSelect
    0x00,    // Pending
    0xFF,
    0xFF,
    0xFF,
    0xFF       // Data
};

//
// Any bit set to 1 in this mask is RWC, so writing 1 to it will cause
// it to be cleared.  All writes to these bits (other than those
// explicitly designed to clear these bits) must be 0.  The register
// specific masks are defined in shpc.h.
//
ULONG RegisterWriteClearMask[] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    ControllerMaskRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC,
    SlotRWC
};

//
// Any bit set to 1 in this mask is read only.  This is a combination of
// registers that are spec-defined to be read only and those that are
// reserved, since we are emulating a nice controller that ignores writes
// to reserved registers.
// TODO be a mean controller.
//
ULONG RegisterReadOnlyMask[] = {
    BaseOffsetRO,
    SlotsAvailDWord1RO | SlotsAvailDWord1RsvdP,
    SlotsAvailDWord2RO | SlotsAvailDWord2RsvdP,
    SlotConfigRO | SlotConfigRsvdP,
    BusConfigRO | BusConfigRsvdP,
    CommandStatusRO | CommandStatusRsvdP,
    IntLocatorRO,
    SERRLocatorRO,
    ControllerMaskRsvdP | ControllerMaskRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ,
    SlotRO | SlotRsvdP | SlotRsvdZ
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\inc\hptest.h ===
#ifndef _HPTEST_H
#define _HPTEST_H

typedef struct _HPTEST_WRITE_CONFIG {

    ULONG Offset;
    ULONG Length;
    SHPC_CONFIG_SPACE Buffer;

} HPTEST_WRITE_CONFIG, *PHPTEST_WRITE_CONFIG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\wmi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation All Rights Reserved

Module Name:

    wmi.c

Abstract:

    This module controls access to the simulated configuration space
    of the SHPC.

    Config access is controlled in the following manner in this simulator:
    We assume that this simulator will be loaded on a bridge enumerated by
    the SoftPCI simulator.  SoftPCI keeps an internal representation of the
    config space of the devices it controls.  The function of this simulator,
    then, is to manage the SHPC register set and perform commands associated
    with writing the SHPC config space.  However, the representation of config
    space is kept internal to SoftPCI.

Environment:

    Kernel Mode

Revision History:

    Davis Walker (dwalker) Sept 8 2000

--*/

  // 625 comments on how this crap works.
#include "hpsp.h"

NTSTATUS
HpsWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
{
    PHPS_DEVICE_EXTENSION deviceExtension = (PHPS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    *RegistryPath = &HpsRegistryPath;
                                            // 625 need to set unused parameters to null?
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *Pdo = deviceExtension->PhysicalDO;

    return STATUS_SUCCESS;
}

NTSTATUS
HpsWmiQueryDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
{
    NTSTATUS status;
    ULONG sizeNeeded = 0;
    PHPS_DEVICE_EXTENSION extension = (PHPS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    PHPS_HWINIT_DESCRIPTOR hwInit;

    ASSERT(InstanceIndex == 0);
    ASSERT(InstanceCount == 1);

    if ((InstanceIndex !=0) ||
        (InstanceCount != 1)) {

        status = STATUS_WMI_INSTANCE_NOT_FOUND;
    } else {
        switch (GuidIndex) {
            case HPS_SLOT_METHOD_GUID_INDEX:
                //
                // Method classes do not have any data within them, but must
                // repond successfully to queries so that WMI method operation
                // work successfully.
                //
                sizeNeeded = sizeof(USHORT);
                if (BufferAvail < sizeof(USHORT)) {


                    status = STATUS_BUFFER_TOO_SMALL;
                } else {

                    *InstanceLengthArray = sizeof(USHORT);
                    status = STATUS_SUCCESS;
                }
                break;
            case HPS_EVENT_CONTEXT_GUID_INDEX:          // 625 comment sync or lack thereof for data blocks

                sizeNeeded = extension->WmiEventContextSize;

                if (BufferAvail < extension->WmiEventContextSize) {

                    status = STATUS_BUFFER_TOO_SMALL;
                } else {
                    *InstanceLengthArray = extension->WmiEventContextSize;
                    RtlCopyMemory(Buffer, extension->WmiEventContext, extension->WmiEventContextSize);
                    status = STATUS_SUCCESS;
                }
                break;
            case HPS_INIT_DATA_GUID_INDEX:

                sizeNeeded = sizeof(HPS_HWINIT_DESCRIPTOR);

                if (BufferAvail < sizeof(HPS_HWINIT_DESCRIPTOR)) {

                    status = STATUS_BUFFER_TOO_SMALL;
                } else {

                    *InstanceLengthArray = sizeof(HPS_HWINIT_DESCRIPTOR);
                    RtlCopyMemory(Buffer, &extension->HwInitData, sizeof(HPS_HWINIT_DESCRIPTOR));
                    status = STATUS_SUCCESS;
                }
                break;
            default:
                status = STATUS_WMI_GUID_NOT_FOUND;
                break;
        }
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              sizeNeeded,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
HpsWmiSetDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
{
    NTSTATUS status;
    PHPS_DEVICE_EXTENSION extension = (PHPS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    ASSERT(InstanceIndex == 0);

    if (InstanceIndex !=0) {

        status = STATUS_WMI_INSTANCE_NOT_FOUND;

    } else if (GuidIndex == HPS_EVENT_CONTEXT_GUID_INDEX)  {

        if (BufferSize == 0) {                         // 625 sync comment from above
            extension->WmiEventContextSize = 0;
            if (extension->WmiEventContext) {
                ExFreePool(extension->WmiEventContext);
                extension->WmiEventContext = NULL;
            }
            goto cleanup;
        }
        if (BufferSize > extension->WmiEventContextSize) {
            //
            // We need to allocate a bigger buffer.
            //
            if (extension->WmiEventContext) {
                ExFreePool(extension->WmiEventContext);
            }
            extension->WmiEventContext = ExAllocatePool(NonPagedPool,
                                                        BufferSize
                                                        );
            if (!extension->WmiEventContext) {
                extension->WmiEventContextSize = 0;
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto cleanup;
            }
        }

        //
        // Copy the context
        //
        extension->WmiEventContextSize = BufferSize;
        RtlCopyMemory(extension->WmiEventContext, Buffer, extension->WmiEventContextSize);

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_WMI_GUID_NOT_FOUND;
    }

cleanup:
    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              0,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
HpsWmiExecuteMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    )
{
    PHPS_DEVICE_EXTENSION extension = (PHPS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    NTSTATUS status;
    ULONG sizeNeeded = 0;
    PSOFTPCI_DEVICE softDevice;
    ULONG slotNum;
    PHPS_SLOT_EVENT event;

    if (GuidIndex == HPS_SLOT_METHOD_GUID_INDEX) {

        switch (MethodId) {
            case SlotMethod:
                if (InBufferSize < sizeof(HPS_SLOT_EVENT)) {

                    status = STATUS_BUFFER_TOO_SMALL;

                } else {
                    event = (PHPS_SLOT_EVENT)Buffer;
                    DbgPrintEx(DPFLTR_HPS_ID,
                       HPS_WMI_LEVEL,
                       "HPS-Handle Slot Event at slot %d Type=%d\n",
                               event->SlotNum,
                               event->EventType
                       );
                    HpsHandleSlotEvent(extension,
                                       (PHPS_SLOT_EVENT)Buffer
                                       );
                    status = STATUS_SUCCESS;
                }
                sizeNeeded = sizeof(HPS_SLOT_EVENT);
                break;

            case AddDeviceMethod:
                if (InBufferSize < sizeof(SOFTPCI_DEVICE)) {

                    status = STATUS_BUFFER_TOO_SMALL;

                } else {

                    softDevice = (PSOFTPCI_DEVICE)Buffer;
                    //
                    // SlotNum is the 0 indexed slot number of the slot a device is
                    // being added to.
                    //
                    slotNum = softDevice->Slot.Device - extension->HwInitData.FirstDeviceID;

                    if (slotNum < extension->HwInitData.NumSlots) {

                        if (extension->SoftDevices[slotNum]) {
                            ExFreePool(extension->SoftDevices[slotNum]);
                        }

                        extension->SoftDevices[slotNum] = ExAllocatePool(PagedPool, sizeof(SOFTPCI_DEVICE));
                        if (!extension->SoftDevices[slotNum]) {
                            status = STATUS_INSUFFICIENT_RESOURCES;

                        } else {
                            RtlCopyMemory(extension->SoftDevices[slotNum],softDevice,sizeof(SOFTPCI_DEVICE));
                            //
                            // Finally mark the device as present in the register set.
                            //
                            extension->RegisterSet.WorkingRegisters.SlotRegisters[slotNum].SlotStatus.PrsntState = SHPC_PRSNT_7_5_WATTS;
                            status = STATUS_SUCCESS;
                        }

                    } else {
                        ASSERT(FALSE);
                        status = STATUS_INVALID_PARAMETER;
                    }

                    DbgPrintEx(DPFLTR_HPS_ID,
                       HPS_WMI_LEVEL,
                       "HPS-Add Device at Slot %d - Status=0x%x\n",
                               slotNum,
                               status
                       );
                }
                sizeNeeded = sizeof(SOFTPCI_DEVICE);
                break;

            case RemoveDeviceMethod:
                if (InBufferSize < sizeof(UCHAR)) {

                    status = STATUS_BUFFER_TOO_SMALL;

                } else {

                    //
                    // SlotNum is the 0 indexed slot number of the slot a device is
                    // being added to.
                    //
                    slotNum = *(PUCHAR)Buffer;

                    if (slotNum < extension->HwInitData.NumSlots) {

                        if (extension->SoftDevices[slotNum]) {
                            ExFreePool(extension->SoftDevices[slotNum]);
                            extension->SoftDevices[slotNum] = NULL;
                        }
                        extension->RegisterSet.WorkingRegisters.SlotRegisters[slotNum].SlotStatus.PrsntState = SHPC_PRSNT_EMPTY;
                        status = STATUS_SUCCESS;

                    } else {
                        ASSERT(FALSE);
                        status = STATUS_INVALID_PARAMETER;
                    }

                    DbgPrintEx(DPFLTR_HPS_ID,
                       HPS_WMI_LEVEL,
                       "HPS-Remove Device at Slot %d=0x%x Status=0x%x\n",
                               slotNum,
                               extension->SoftDevices[slotNum],
                               status
                       );
                }
                sizeNeeded = sizeof(UCHAR);
                break;

            case GetDeviceMethod:
                if ((InBufferSize < sizeof(UCHAR)) ||
                    (OutBufferSize < sizeof(SOFTPCI_DEVICE))) {

                    status = STATUS_BUFFER_TOO_SMALL;

                } else {

                    //
                    // SlotNum is the 0 indexed slot number of the slot a device is
                    // being added to.
                    //
                    slotNum = *(PUCHAR)Buffer;

                    if (slotNum < extension->HwInitData.NumSlots) {

                        if (extension->SoftDevices[slotNum]) {
                            RtlCopyMemory(Buffer,
                                          extension->SoftDevices[slotNum],
                                          sizeof(SOFTPCI_DEVICE)
                                          );
                            status = STATUS_SUCCESS;
                        } else {
                            status = STATUS_NO_SUCH_DEVICE;
                        }
                    } else {
                        ASSERT(FALSE);
                        status = STATUS_INVALID_PARAMETER;
                    }
                    DbgPrintEx(DPFLTR_HPS_ID,
                       HPS_WMI_LEVEL,
                       "HPS-Get Device at Slot %d=0x%x Status=0x%x\n",
                               slotNum,
                               extension->SoftDevices[slotNum],
                               status
                       );
                }
                sizeNeeded = sizeof(SOFTPCI_DEVICE);
                break;

            case GetSlotStatusMethod:
                if ((InBufferSize < sizeof(UCHAR)) ||
                    (OutBufferSize < sizeof(SHPC_SLOT_STATUS_REGISTER))){

                    status = STATUS_BUFFER_TOO_SMALL;

                } else {

                    //
                    // SlotNum is the 0 indexed slot number of the slot a device is
                    // being added to.
                    //
                    slotNum = *(PUCHAR)Buffer;
                    if (slotNum < extension->HwInitData.NumSlots) {

                        RtlCopyMemory(Buffer,
                                      &extension->RegisterSet.WorkingRegisters.SlotRegisters[slotNum].SlotStatus,
                                      sizeof(SHPC_SLOT_STATUS_REGISTER)
                                      );
                        status = STATUS_SUCCESS;

                    } else {
                        ASSERT(FALSE);
                        status = STATUS_INVALID_PARAMETER;
                    }
                }
                sizeNeeded = sizeof(SHPC_SLOT_STATUS_REGISTER);
                break;

            case CommandCompleteMethod:
                DbgPrintEx(DPFLTR_HPS_ID,
                       HPS_WMI_LEVEL,
                       "HPS-Command Completed\n"
                       );
                HpsCommandCompleted(extension);
                status = STATUS_SUCCESS;
                break;

            default:
                status = STATUS_WMI_ITEMID_NOT_FOUND;
                DbgPrintEx(DPFLTR_HPS_ID,
                           HPS_WMI_LEVEL,
                           "HPS-Method ID not found: %d\n",
                           MethodId
                           );
                break;
        }

    } else {
        DbgPrintEx(DPFLTR_HPS_ID,
                           HPS_WMI_LEVEL,
                           "HPS-Guid ID not found: %d\n",
                           GuidIndex
                           );
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              sizeNeeded,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
HpsWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
{
    PHPS_DEVICE_EXTENSION deviceExtension = (PHPS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    if (Function == WmiEventControl) {

        deviceExtension->EventsEnabled = Enable;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              STATUS_SUCCESS,
                              0,
                              IO_NO_INCREMENT
                              );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\memory.c ===
/*++

Copyright (c) 2000 Microsoft Corporation All Rights Reserved

Module Name:

    memory.c

Abstract:

    This module controls access to the simulated memory space of the SHPC.

    

Environment:

    Kernel Mode

Revision History:

    Davis Walker (dwalker) Sept 8 2000

--*/

#include "hpsp.h"

NTSTATUS
HpsInitHBRB(
    IN PHPS_DEVICE_EXTENSION Extension
    )
{

    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER input;
    PACPI_EVAL_OUTPUT_BUFFER output = NULL;
    ULONG count;
    PACPI_METHOD_ARGUMENT argument;
    ULONG outputSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER) + sizeof(ACPI_METHOD_ARGUMENT) * HBRB_PACKAGE_COUNT;
    PHYSICAL_ADDRESS HBRB;
    PHBRB_HEADER HBRBHeader;
    PHBRB_CAPABILITIES_HEADER HBRBCapHeader;

    PAGED_CODE();

    output = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, outputSize);

    if (!output) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    RtlZeroMemory(&input, sizeof(ACPI_EVAL_INPUT_BUFFER));
    RtlZeroMemory(output, outputSize);

    //
    // Send a IOCTL to ACPI to request it to run the HBRB method on this device
    // if the method it is present
    //

    input.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    input.MethodNameAsUlong = (ULONG)'BRBH';

    //
    // HpsSendIoctl deals with sending this from the top of the stack.
    //

    status = HpsSendIoctl(Extension->Self,
                         IOCTL_ACPI_EVAL_METHOD,
                         &input,
                         sizeof(ACPI_EVAL_INPUT_BUFFER),
                         output,
                         outputSize
                         );

    if (!NT_SUCCESS(status)) {
        goto cleanup;

    }

    //
    // Check they are all integers and in the right bounds
    //
    ASSERT(output->Count <= HBRB_PACKAGE_COUNT);
    if (output->Argument[0].Type != ACPI_METHOD_ARGUMENT_INTEGER) {
        status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }
    HBRB.LowPart = output->Argument[0].Argument;

    if (output->Count > 1) {
        if (output->Argument[1].Type != ACPI_METHOD_ARGUMENT_INTEGER) {
            status = STATUS_UNSUCCESSFUL;
            goto cleanup;
        }
        HBRB.HighPart = output->Argument[1].Argument;
    }
    Extension->HBRBOffset = (PUCHAR)HBRB.QuadPart;
    Extension->HBRBLength = sizeof(HBRB_HEADER) + sizeof(HBRB_CAPABILITIES_HEADER) + sizeof(SHPC_REGISTER_SET);
    Extension->HBRBRegisterSetOffset = sizeof(HBRB_HEADER) + sizeof(HBRB_CAPABILITIES_HEADER);

    Extension->HBRB = ExAllocatePool(NonPagedPool,sizeof(HBRB_HEADER) + 
                                                  sizeof(HBRB_CAPABILITIES_HEADER) + 
                                                  sizeof(SHPC_REGISTER_SET)
                                                  );
    if (!Extension->HBRB) {
        
        goto cleanup;
    }

    HBRBHeader = (PHBRB_HEADER)Extension->HBRB;
    HBRBHeader->BusNumber = 0;
    HBRBHeader->VendorID = 0x9999;
    HBRBHeader->DeviceID = 0x0123;
    HBRBHeader->SubSystemID = 0x1234;
    HBRBHeader->SubVendorID = 0x9999;
    HBRBHeader->ProgIF = 1;
    HBRBHeader->RevisionID = 1;
    HBRBHeader->HBRBVersion = 1;
    HBRBHeader->CapabilitiesPtr = sizeof(HBRB_HEADER);
    HBRBHeader->Size = sizeof(HBRB_HEADER) + sizeof(HBRB_CAPABILITIES_HEADER) + sizeof(SHPC_REGISTER_SET);

    HBRBCapHeader = (PHBRB_CAPABILITIES_HEADER)((PUCHAR)HBRBHeader + sizeof(HBRB_HEADER));
    HBRBCapHeader->CapabilityID = 0xC;
    HBRBCapHeader->Next = 0x0;

    status = HpsInitRegisters(Extension);
    if (!NT_SUCCESS(status)) {
        
        goto cleanup;
    }

    RtlCopyMemory((PUCHAR)HBRBCapHeader + sizeof(HBRB_CAPABILITIES_HEADER),
                  &Extension->RegisterSet,
                  sizeof(SHPC_REGISTER_SET)
                  );

cleanup:

    if (output) {
        ExFreePool(output);
    }
    return status;

}

NTSTATUS
HpsGetHBRBHwInit(
    IN PHPS_DEVICE_EXTENSION DeviceExtension
    )
{
    NTSTATUS status;
    ACPI_EVAL_INPUT_BUFFER input;
    PACPI_EVAL_OUTPUT_BUFFER output = NULL;
    ULONG count;
    PACPI_METHOD_ARGUMENT argument;
    ULONG outputSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER) + sizeof(ACPI_METHOD_ARGUMENT) + sizeof(HPS_HWINIT_DESCRIPTOR);
    PHYSICAL_ADDRESS HBRB;
    PHBRB_HEADER HBRBHeader;
    PHBRB_CAPABILITIES_HEADER HBRBCapHeader;

    PAGED_CODE();

    output = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, outputSize);

    if (!output) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    RtlZeroMemory(&input, sizeof(ACPI_EVAL_INPUT_BUFFER));
    RtlZeroMemory(output, outputSize);

    //
    // Send a IOCTL to ACPI to request it to run the HBRB method on this device
    // if the method it is present
    //

    input.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    input.MethodNameAsUlong = (ULONG)'IHBH';

    //
    // HpsSendIoctl deals with sending this from the top of the stack.
    //

    status = HpsSendIoctl(DeviceExtension->Self,
                         IOCTL_ACPI_EVAL_METHOD,
                         &input,
                         sizeof(ACPI_EVAL_INPUT_BUFFER),
                         output,
                         outputSize
                         );

    if (!NT_SUCCESS(status)) {
        goto cleanup;

    }

    //
    // Check they are all integers and in the right bounds
    //
    ASSERT(output->Count == 1);
    if ((output->Argument[0].Type != ACPI_METHOD_ARGUMENT_BUFFER) ||
        (output->Argument[0].DataLength != sizeof(HPS_HWINIT_DESCRIPTOR))) {
        status = STATUS_UNSUCCESSFUL;
        goto cleanup;
    }
    RtlCopyMemory(&DeviceExtension->HwInitData,
                  output->Argument[0].Data,
                  output->Argument[0].DataLength
                  );

cleanup:

    if (output) {
        ExFreePool(output);
    }
    return status;
}


NTSTATUS
HpsSendIoctl(
    IN PDEVICE_OBJECT Device,
    IN ULONG IoctlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )
/*++

Description:

    Builds and send an IOCTL to a device and return the results

Arguments:

    Device - a device on the device stack to receive the IOCTL - the
             irp is always sent to the top of the stack

    IoctlCode - the IOCTL to run

    InputBuffer - arguments to the IOCTL

    InputBufferLength - length in bytes of the InputBuffer

    OutputBuffer - data returned by the IOCTL

    OnputBufferLength - the size in bytes of the OutputBuffer

Return Value:

    Status

--*/
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    PDEVICE_OBJECT targetDevice = NULL;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Get the top of the stack to send the IRP to
    //

    targetDevice = IoGetAttachedDeviceReference(Device);

    if (!targetDevice) {
        status = STATUS_INVALID_PARAMETER;
    goto exit;
    }

    //
    // Get Io to build the IRP for us
    //

    irp = IoBuildDeviceIoControlRequest(IoctlCode,
                                        targetDevice,
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        FALSE, // InternalDeviceIoControl
                                        &event,
                                        &ioStatus
                                        );


    if (!irp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Send the IRP and wait for it to complete
    //

    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

exit:

    if (targetDevice) {
        ObDereferenceObject(targetDevice);
    }

    return status;

}

VOID
HpsMemoryInterfaceReference(
    IN PVOID Context
    )
{
    PHPS_DEVICE_EXTENSION Extension = (PHPS_DEVICE_EXTENSION)Context;

    if (InterlockedExchangeAdd(&Extension->MemoryInterfaceCount,1) == 0) {

        //
        // This is the first increment.  Put this device extension on the
        // list of device extensions.
        //
        InsertHeadList(&HpsDeviceExtensions,&Extension->ListEntry);
    }
}

VOID
HpsMemoryInterfaceDereference(
    IN PVOID Context
    )
{
    PHPS_DEVICE_EXTENSION Extension = (PHPS_DEVICE_EXTENSION)Context;
    LONG decrementedValue;

    decrementedValue = InterlockedDecrement(&Extension->MemoryInterfaceCount);

    ASSERT(decrementedValue >= 0);

    if (decrementedValue == 0) {

        //
        // This is the final decrement.  Remove the device extension from the list        
        //
        RemoveEntryList(&Extension->ListEntry);
    }
}

VOID
HpsReadRegister(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG Length
    )
{
    PHPS_DEVICE_EXTENSION extension;
    ULONG offset;

    extension = HpsFindExtensionForHbrb(Register,Length);

    offset = (ULONG)(Register - extension->HBRBOffset);

    if ((offset < extension->HBRBLength) &&
        ((offset+Length) <= extension->HBRBLength)) {
        
        RtlCopyMemory(Buffer,(PUCHAR)extension->HBRB + offset,Length);        
        
    }

}
VOID
HpsWriteRegister(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG Length
    )
{
    PHPS_DEVICE_EXTENSION extension;
    ULONG hbrbOffset, shpcOffset, shpcLength, bufferOffset;
    ULONG registerNum, registerOffset, registerLength, registerData;
    KIRQL irql;

    extension = HpsFindExtensionForHbrb(Register,Length);

    HpsLockRegisterSet(extension,
                       &irql
                       );

    hbrbOffset = (ULONG)(Register - extension->HBRBOffset);

    if ((hbrbOffset < extension->HBRBLength) &&
        ((hbrbOffset+Length) <= extension->HBRBLength)) {
        
        RtlCopyMemory((PUCHAR)extension->HBRB + hbrbOffset,Buffer,Length);        
        
    }

    if ((hbrbOffset >= extension->HBRBRegisterSetOffset) &&
        ((hbrbOffset + Length) < (extension->HBRBRegisterSetOffset + sizeof(SHPC_REGISTER_SET)))) {
           
        //
        // The write is to the SHPC register set.
        //
        shpcOffset = hbrbOffset - extension->HBRBRegisterSetOffset;
        shpcLength = Length;

        bufferOffset = 0;
        while (bufferOffset < Length) {
            registerNum = shpcOffset / sizeof(ULONG);
            registerOffset = shpcOffset - (registerNum * sizeof(ULONG));
            registerLength = min(shpcLength,sizeof(ULONG)-registerOffset);
            registerData = *(PULONG)((PUCHAR)Buffer + bufferOffset);
            registerData <<= (registerOffset*8);
            
            RegisterWriteCommands[registerNum](extension,
                                               registerNum,
                                               &registerData,
                                               HPS_ULONG_WRITE_MASK(registerOffset,registerLength)
                                               );

            bufferOffset += registerLength;
            shpcOffset += registerLength;
            shpcLength -= registerLength;
        }
    }

    RtlCopyMemory((PUCHAR)extension->HBRB + extension->HBRBRegisterSetOffset,
                  &extension->RegisterSet,
                  sizeof(SHPC_REGISTER_SET)
                  );

    HpsUnlockRegisterSet(extension,
                         irql
                         );

}

PHPS_DEVICE_EXTENSION
HpsFindExtensionForHbrb(
    IN PUCHAR Register,
    IN ULONG Length
    )
{
    PHPS_DEVICE_EXTENSION currentExtension;

    FOR_ALL_IN_LIST(HPS_DEVICE_EXTENSION,&HpsDeviceExtensions,currentExtension) {
        
        if (IS_SUBSET(Register,Length,currentExtension->HBRBOffset,currentExtension->HBRBLength)) {

            return currentExtension;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\intrface.c ===
/*++

Copyright (c) 2000 Microsoft Corporation All Rights Reserved

Module Name:

    intrface.c

Abstract:

    This module deals with the interface handling in the hotplug PCI
    simulator.

Environment:

    Kernel Mode

Revision History:

    Davis Walker (dwalker) Sept 8 2000

--*/

#include "hpsp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, HpsGetBusInterface)
#pragma alloc_text (PAGE, HpsTrapBusInterface)
#pragma alloc_text (PAGE, HpsGetLowerFilter)
#endif

NTSTATUS
HpsGetBusInterface(
    PHPS_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine queries the underlying PCI driver for an interface
    to access config space.  It then stores the interface in
    the device extension.

Arguments:

    DeviceExtension - the device extension for the device

Return Value:

    STATUS_SUCCESS if the interface was stored successfully.
    NT status code indicating the error condition otherwise.

--*/
{
    NTSTATUS status;
    BUS_INTERFACE_STANDARD busInterface;
    IO_STACK_LOCATION location;

    PAGED_CODE();

    DbgPrintEx(DPFLTR_HPS_ID,
           DPFLTR_INFO_LEVEL,
           "HPS-Getting Interface From PCI\n"
           );

    RtlZeroMemory(&location, sizeof(IO_STACK_LOCATION));
    location.MajorFunction = IRP_MJ_PNP;
    location.MinorFunction = IRP_MN_QUERY_INTERFACE;
    location.Parameters.QueryInterface.InterfaceType = &GUID_BUS_INTERFACE_STANDARD;
    location.Parameters.QueryInterface.Size = sizeof(BUS_INTERFACE_STANDARD);
    location.Parameters.QueryInterface.Version = 1;
    location.Parameters.QueryInterface.Interface = (PINTERFACE)&busInterface;

    status = HpsSendPnpIrp(DeviceExtension->PhysicalDO,
                          &location,
                          NULL);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    return HpsTrapBusInterface(DeviceExtension,
                               &location
                               );

}

NTSTATUS
HpsTrapBusInterface (
    IN PHPS_DEVICE_EXTENSION    DeviceExtension,
    IN OUT PIO_STACK_LOCATION   IrpStack
    )

/*++

Routine Description:

    This routine modifies a bus interface provided by PCI to access HPS functions
    instead, thus allowing this driver to simulate PCI config space access.  It will
    save the PCI functions, so that the functions it provides in the interface become
    wrappers around the PCI functions.

Arguments:

    DeviceExtension - the extension for the current device object

    IrpStack - current IRP stack location

Return Value:

    NT status code

    TODO: This is broken, because we use it even when we're not munging an interface
    requested by someone else - that is, when we ask PCI for the interface ourselves.

--*/

{
    NTSTATUS    status;
    ULONG       readBuffer;
    ULONG       capableOf64Bits;
    UCHAR       currentDword;
    UCHAR       currentSize;
    UCHAR       currentType;
    UCHAR       i;
    ULONGLONG   usageMask;
    ULONGLONG   tempMask;


    PHPS_INTERFACE_WRAPPER interfaceWrapper = &(DeviceExtension->InterfaceWrapper);
    PBUS_INTERFACE_STANDARD standard = (PBUS_INTERFACE_STANDARD)
                                       IrpStack->Parameters.QueryInterface.Interface;

    PAGED_CODE();

    ASSERT(standard != NULL);

    //
    // If the PciContext is NULL, that means we haven't trapped the interface before.
    // If we have, then we don't need to save it again.
    //
    if (interfaceWrapper->PciContext == NULL) {

        //
        // save away PCI interface state
        //

        interfaceWrapper->PciContext = standard->Context;
        interfaceWrapper->PciInterfaceReference = standard->InterfaceReference;
        interfaceWrapper->PciInterfaceDereference = standard->InterfaceDereference;
        interfaceWrapper->PciSetBusData = standard->SetBusData;
        interfaceWrapper->PciGetBusData = standard->GetBusData;

    }

    //
    // put in our interface
    //

    standard->Context =                 DeviceExtension;
    standard->InterfaceReference =      HpsBusInterfaceReference;
    standard->InterfaceDereference =    HpsBusInterfaceDereference;
    standard->Version =                 1;  // We only support version 1
    standard->SetBusData =              HpsHandleDirectWriteConfig;
    standard->GetBusData =              HpsHandleDirectReadConfig;

    return STATUS_SUCCESS;

}

NTSTATUS
HpsGetLowerFilter (
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PDEVICE_OBJECT  *LowerDeviceObject
    )
/*++

Routine Description:

    This routine sends a query interface IRP to the stack
    that the DeviceObject resides on to see if anyone responds. When
    called from AddDevice, this effectively tells the caller if
    DeviceObject is the first Hps driver loaded on the stack.

Parameters:

    DeviceObject - A pointer to the devobj whose device stack
                   we send the interface to

    LowerDeviceObject -  A pointer to the PDEVICE_OBJECT of the devobj
                         that responds to the interface, or NULL if the
                         interface returns without a response

Return Value:

    NT status code

--*/
{

    HPS_PING_INTERFACE    locInterface;
    IO_STACK_LOCATION     irpStack;
    NTSTATUS              status;

    PAGED_CODE();

    locInterface.SenderDevice = DeviceObject;
    locInterface.Context = NULL;

    irpStack.MajorFunction = IRP_MJ_PNP;
    irpStack.MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack.Parameters.QueryInterface.InterfaceType = &GUID_HPS_PING_INTERFACE;
    irpStack.Parameters.QueryInterface.Size = sizeof(HPS_PING_INTERFACE);
    irpStack.Parameters.QueryInterface.Version = 1;
    irpStack.Parameters.QueryInterface.Interface = (PINTERFACE)&locInterface;

    status = HpsSendPnpIrp(DeviceObject,
                           &irpStack,
                           NULL
                           );

    if (NT_SUCCESS(status)) {
        //
        // Someone provided the interface.
        //
        ASSERT(LowerDeviceObject != NULL);
        *LowerDeviceObject = locInterface.Context;
        locInterface.InterfaceDereference(locInterface.Context);
    }

    return status;

}

//
// Interface ref/deref routines
//

VOID
HpsBusInterfaceReference (
    PVOID Context
    )
/*++

Routine Description:

    This is the reference routine to our wrapper to the BUS_INTERFACE_STANDARD
    interface.  It must reference PCI's interface.  Since we don't keep a refcount,
    this is all it must do.

Arguments:

    Context - We pass the deviceExtension as the context for the interface, so
              this PVOID is casted to a devext.

Return Value:

    VOID

--*/
{
    PHPS_DEVICE_EXTENSION   deviceExtension = (PHPS_DEVICE_EXTENSION) Context;
    PHPS_INTERFACE_WRAPPER  interfaceWrapper = &deviceExtension->InterfaceWrapper;

    interfaceWrapper->PciInterfaceReference(interfaceWrapper->PciContext);
}

VOID
HpsBusInterfaceDereference (
    PVOID Context
    )
/*++

Routine Description:

    This is the dereference routine to our wrapper to the BUS_INTERFACE_STANDARD
    interface.  It must dereference both our interface and PCI's, since PCI is
    operating as usual without knowing we're here.

Arguments:

    Context - We pass the deviceExtension as the context for the interface, so
              this PVOID is casted to a devext.

Return Value:

    VOID

--*/
{
    PHPS_DEVICE_EXTENSION   deviceExtension = (PHPS_DEVICE_EXTENSION) Context;
    PHPS_INTERFACE_WRAPPER  interfaceWrapper = &deviceExtension->InterfaceWrapper;

    interfaceWrapper->PciInterfaceDereference(interfaceWrapper->PciContext);

}

VOID
HpsGenericInterfaceReference (
    PVOID Context
    )
{
}

VOID
HpsGenericInterfaceDereference (
    PVOID Context
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\inc\hpsim.h ===
/*++

Copyright (c) 2000 Microsoft Corporation All Rights Reserved

Module Name:

    hpsim.h

Abstract:

    This header file contains the structure and function declarations
    for the hotplugsim driver that must be accessible outside of hps.sys,
    either by the hotplug driver or by the user mode slot simulator

Environment:

    Kernel Mode

Revision History:

    Davis Walker (dwalker) Sept 8 2000

--*/

#ifndef _HPSIM_H
#define _HPSIM_H

//
// The following two structures are used for communication between
// the controller and slots that originates at the slot.
//
typedef enum _HPS_SLOT_EVENT_TYPE {

    IsolatedPowerFault,
    AttentionButton,
    MRLOpen,
    MRLClose

} HPS_SLOT_EVENT_TYPE;


typedef struct _HPS_SLOT_EVENT {

    UCHAR SlotNum;

    HPS_SLOT_EVENT_TYPE EventType;

} HPS_SLOT_EVENT, *PHPS_SLOT_EVENT;

//
// The following two structures are used for communication between
// the controller and slots that originates at the controller.
//
typedef union _HPS_SLOT_OPERATION_COMMAND {

    struct {
        UCHAR SlotState:2;
        UCHAR PowerIndicator:2;
        UCHAR AttentionIndicator:2;
        UCHAR CommandCode:2;

    } SlotOperation;

    UCHAR AsUchar;

} HPS_SLOT_OPERATION_COMMAND;

//
// SlotNums - a bitmask indicating which slots this event applies to
// SERRAsserted - the controller has detected an SERR condition.  Instead
//      of bugchecking the machine, we just inform usermode
// ControllerReset - A controller reset has been issued.
// Command - The slot operation command to execute.
//
typedef struct _HPS_CONTROLLER_EVENT {

    ULONG SlotNums;
    UCHAR SERRAsserted;

    HPS_SLOT_OPERATION_COMMAND Command;

} HPS_CONTROLLER_EVENT, *PHPS_CONTROLLER_EVENT;

//
// User-mode initialization interface
//

typedef struct _HPS_HWINIT_DESCRIPTOR {

    ULONG BarSelect;

    ULONG NumSlots33Conv:5;
    ULONG NumSlots66PciX:5;
    ULONG NumSlots100PciX:5;
    ULONG NumSlots133PciX:5;
    ULONG NumSlots66Conv:5;
    ULONG NumSlots:5;
    ULONG:2;

    UCHAR FirstDeviceID:5;
    UCHAR UpDown:1;
    UCHAR AttentionButtonImplemented:1;
    UCHAR MRLSensorsImplemented:1;
    UCHAR FirstSlotLabelNumber;
    UCHAR ProgIF;

} HPS_HWINIT_DESCRIPTOR, *PHPS_HWINIT_DESCRIPTOR;

#define HPS_HWINIT_CAPABILITY_ID 0xD

typedef struct _HPTEST_BRIDGE_INFO {

    UCHAR PrimaryBus;
    UCHAR DeviceSelect;
    UCHAR FunctionNumber;

    UCHAR SecondaryBus;

} HPTEST_BRIDGE_INFO, *PHPTEST_BRIDGE_INFO;

typedef struct _HPTEST_BRIDGE_DESCRIPTOR {

    HANDLE Handle;
    HPTEST_BRIDGE_INFO BridgeInfo;

} HPTEST_BRIDGE_DESCRIPTOR, *PHPTEST_BRIDGE_DESCRIPTOR;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\lower.c ===
/*++

Copyright (c) 2000 Microsoft Corporation All Rights Reserved

Module Name:

    lower.c

Abstract:

    This module contains the lower filter specific IRP handlers.

    The functions in this module all have the same prototypes and so
    are documented here:

    NTSTATUS
    HpsXxxLower(
        IN PIRP Irp,
        IN PHPS_DEVICE_EXTENSION Extension,
        IN PIO_STACK_LOCATION IrpStack
        )

    Arguments:

        Irp - a pointer to the IRP currently being handled
        Extension - a pointer to the device extension of this device. In
            some functions this is of type PHPS_COMMON_EXTENSION if this
            reduced extension is all that is required.
        IrpStack - the current IRP stack location

    Return Value:

        an NT status code

Environment:

    Kernel Mode

Revision History:

    Davis Walker (dwalker) Oct 1 2000

--*/

#include "hpsp.h"

NTSTATUS
HpsStartLower(
    IN PIRP Irp,
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;

    status = HpsDeferProcessing((PHPS_COMMON_EXTENSION)Extension,
                                Irp
                                );
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    status = IoSetDeviceInterfaceState(Extension->SymbolicName,
                                       TRUE // enable
                                       );

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;

}

NTSTATUS
HpsRemoveLower(
    IN PIRP Irp,
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    ULONG i;

    IoSetDeviceInterfaceState(Extension->SymbolicName,
                              FALSE
                              );
    IoWMIRegistrationControl(Extension->Self,
                             WMIREG_ACTION_DEREGISTER
                             );

    if (Extension->SoftDevices) {
        for (i=0; i<Extension->HwInitData.NumSlots;i++) {
            if (Extension->SoftDevices[i]) {
                ExFreePool(Extension->SoftDevices[i]);
            }
        }
        ExFreePool(Extension->SoftDevices);
    }

    if (Extension->SymbolicName) {
        ExFreePool(Extension->SymbolicName);
    }

    if (Extension->WmiEventContext) {

        ExFreePool(Extension->WmiEventContext);
    }

    return HpsRemoveCommon(Irp,
                           (PHPS_COMMON_EXTENSION)Extension,
                           IrpStack
                           );

}

NTSTATUS
HpsStopLower(
    IN PIRP Irp,
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    IoSetDeviceInterfaceState(Extension->SymbolicName,
                              FALSE
                              );

    return HpsPassIrp(Irp,
                      (PHPS_COMMON_EXTENSION)Extension,
                      IrpStack
                      );
}

NTSTATUS
HpsQueryInterfaceLower(
    IN PIRP Irp,
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    )
{

    NTSTATUS status = STATUS_NOT_SUPPORTED;
    PHPS_REGISTER_INTERRUPT_INTERFACE interruptInterface;
    PHPS_MEMORY_INTERFACE memInterface;
    PHPS_PING_INTERFACE pingInterface;

    if (HPS_EQUAL_GUID(IrpStack->Parameters.QueryInterface.InterfaceType,
                       &GUID_BUS_INTERFACE_STANDARD
                       )) {

        if (Extension->UseConfig) {
            //
            // Someone is requesting a bus interface standard.  We need to capture
            // this request and fill it in with our own.
            //
            DbgPrintEx(DPFLTR_HPS_ID,
                       DPFLTR_INFO_LEVEL,
                       "HPS-IRP QueryInterface for Bus Interface\n"
                       );
            if (IrpStack->Parameters.QueryInterface.Size <
                sizeof(BUS_INTERFACE_STANDARD)) {
    
                status = STATUS_NOT_SUPPORTED;
    
            } else {
                //
                // This is a query for access to config space, which we need to trap
                // after PCI has filled it in.
                //
                status = HpsDeferProcessing((PHPS_COMMON_EXTENSION)Extension,
                                            Irp
                                            );
    
                if (NT_SUCCESS(status)) {
    
                    // PDO filled in the interface, so we can trap and modify it.
    
                    status = HpsTrapBusInterface(Extension,
                                                 IrpStack
                                                 );
    
                    //
                    // the status of the trap operation is the status of the IRP.
                    // complete the IRP with whatever status that happens to be.
                    //
                    Irp->IoStatus.Status = status;
                }
    
                //
                // Complete the deferred IRP
                //
                IoCompleteRequest(Irp,IO_NO_INCREMENT);
                return status;
            }    
        }
        
    } else if (HPS_EQUAL_GUID(IrpStack->Parameters.QueryInterface.InterfaceType,
                              &GUID_HPS_MEMORY_INTERFACE
                              )) {
        if (IrpStack->Parameters.QueryInterface.Size <
            sizeof(HPS_MEMORY_INTERFACE)) {
            
            status = STATUS_NOT_SUPPORTED;

        } else {
            memInterface = (PHPS_MEMORY_INTERFACE)
                            IrpStack->Parameters.QueryInterface.Interface;
            
            memInterface->Context = Extension;
            memInterface->InterfaceReference = HpsMemoryInterfaceReference;
            memInterface->InterfaceDereference = HpsMemoryInterfaceDereference;
            memInterface->ReadRegister = HpsReadRegister;
            memInterface->WriteRegister = HpsWriteRegister;

            memInterface->InterfaceReference(memInterface->Context);
            
            status = STATUS_SUCCESS;
        }
        
    } else if (HPS_EQUAL_GUID(IrpStack->Parameters.QueryInterface.InterfaceType,
                              &GUID_HPS_PING_INTERFACE
                              )) {

        DbgPrintEx(DPFLTR_HPS_ID,
                   DPFLTR_INFO_LEVEL,
                   "HPS-IRP QueryInterface for Ping Interface\n"
                   );
        if (IrpStack->Parameters.QueryInterface.Size <
            sizeof(HPS_PING_INTERFACE)) {

            status = STATUS_NOT_SUPPORTED;

        } else {
            //
            // The upper filter is querying to see if there is another
            // instance of the driver below it.  Inform it that there is.
            //
            pingInterface = (PHPS_PING_INTERFACE)
                            IrpStack->Parameters.QueryInterface.Interface;
            if (pingInterface->SenderDevice != Extension->Self) {
                pingInterface->Context = Extension->Self;
                pingInterface->InterfaceReference = HpsGenericInterfaceReference;
                pingInterface->InterfaceDereference = HpsGenericInterfaceDereference;
            }

            pingInterface->InterfaceReference(pingInterface->Context);

            status = STATUS_SUCCESS;
        }

    } else if (HPS_EQUAL_GUID(IrpStack->Parameters.QueryInterface.InterfaceType,
                              &GUID_REGISTER_INTERRUPT_INTERFACE
                              )) {

        DbgPrintEx(DPFLTR_HPS_ID,
                   DPFLTR_INFO_LEVEL,
                   "HPS-IRP QueryInterface for Interrupt Interface\n"
                   );
        if (IrpStack->Parameters.QueryInterface.Size <
            sizeof(HPS_REGISTER_INTERRUPT_INTERFACE)) {

            status = STATUS_NOT_SUPPORTED;

        } else {
            //
            // The hotplug driver is querying for an interface that allows it
            // to register a fake interrupt.  Provide the interface.
            //
            interruptInterface = (PHPS_REGISTER_INTERRUPT_INTERFACE)
                                 IrpStack->Parameters.QueryInterface.Interface;
            interruptInterface->InterfaceReference = HpsGenericInterfaceReference;
            interruptInterface->InterfaceDereference = HpsGenericInterfaceDereference;
            interruptInterface->ConnectISR = HpsConnectInterrupt;
            interruptInterface->DisconnectISR = HpsDisconnectInterrupt;
            interruptInterface->SyncExecutionRoutine = HpsSynchronizeExecution;
            interruptInterface->Context = Extension;

            status = STATUS_SUCCESS;
        }

    }

    if (NT_SUCCESS(status)) {

        Irp->IoStatus.Status = status;
    }

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(Extension->LowerDO,
                        Irp
                        );
}

NTSTATUS
HpsWriteConfigLower(
    IN PIRP Irp,
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PIO_STACK_LOCATION IrpStack
    )
{
    if (Extension->UseConfig) {
        DbgPrintEx(DPFLTR_HPS_ID,
                   DPFLTR_INFO_LEVEL,
                   "HPS-IRP Write Config at offset %d for length %d\n",
                   IrpStack->Parameters.ReadWriteConfig.Offset,
                   IrpStack->Parameters.ReadWriteConfig.Length
                   );
        if (IS_SUBSET(IrpStack->Parameters.ReadWriteConfig.Offset,
                      IrpStack->Parameters.ReadWriteConfig.Length,
                      Extension->ConfigOffset,
                      sizeof(SHPC_CONFIG_SPACE)
                      )) {
    
            //
            // Handle the IRP internally.  The request lines up with the config space
            // offset of the SHPC capability.
            //
            HpsWriteConfig (Extension,
                            IrpStack->Parameters.ReadWriteConfig.Buffer,
                            IrpStack->Parameters.ReadWriteConfig.Offset,
                            IrpStack->Parameters.ReadWriteConfig.Length
                            );
    
            //
            // Since the write may have altered the register set, we have to recopy the
            // result into the buffer before passing the IRP to Soft PCI
            //
            RtlCopyMemory(IrpStack->Parameters.ReadWriteConfig.Buffer,
                          (PUCHAR)&Extension->ConfigSpace + IrpStack->Parameters.ReadWriteConfig.Offset,
                          IrpStack->Parameters.ReadWriteConfig.Length
                          );
        }    
    }
    

    //
    // We've handled the IRP internally, but we want to keep SoftPCI in the loop,
    // so pass it down.
    //
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver (Extension->LowerDO,
                         Irp
                         );
}

NTSTATUS
HpsDeviceControlLower(
    PIRP Irp,
    PHPS_DEVICE_EXTENSION Extension,
    PIO_STACK_LOCATION IrpStack
    )
{
    NTSTATUS status;
    PHPTEST_WRITE_CONFIG writeDescriptor;
    PHPTEST_BRIDGE_INFO bridgeInfo;

    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_HPS_READ_REGISTERS:
            //
            // Usermode wants a copy of the register set.  This is a test
            // IOCTL
            //

            DbgPrintEx(DPFLTR_HPS_ID,
                       DPFLTR_INFO_LEVEL,
                       "HPS-Device Control IOCTL_HPS_READ_REGISTERS\n"
                       );
            if (!Irp->AssociatedIrp.SystemBuffer ||
                (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                 sizeof(SHPC_WORKING_REGISTERS))) {

                //
                // We didn't get the buffer we expected.  Fail.
                //
                return STATUS_INVALID_PARAMETER;
            }

            RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer,
                          &Extension->RegisterSet,
                          sizeof(SHPC_WORKING_REGISTERS)
                          );
            Irp->IoStatus.Information = sizeof(SHPC_WORKING_REGISTERS);
            status = STATUS_SUCCESS;
            break;

        case IOCTL_HPS_READ_CAPABILITY:
            //
            // Usermode wants a copy of the SHPC capability structure.  This
            // is a test IOCTL
            //

            DbgPrintEx(DPFLTR_HPS_ID,
                       DPFLTR_INFO_LEVEL,
                       "HPS-Device Control IOCTL_HPS_READ_CAPABILITY\n"
                       );
            if (!Irp->AssociatedIrp.SystemBuffer ||
                (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                 sizeof(SHPC_CONFIG_SPACE))) {

                //
                // We didn't get the buffer we expected.  Fail.
                //
                return STATUS_INVALID_PARAMETER;
            }

            HpsHandleDirectReadConfig(Extension,
                                      PCI_WHICHSPACE_CONFIG,
                                      Irp->AssociatedIrp.SystemBuffer,
                                      Extension->ConfigOffset,
                                      sizeof(SHPC_CONFIG_SPACE)
                                      );
            Irp->IoStatus.Information = sizeof(SHPC_CONFIG_SPACE);
            status = STATUS_SUCCESS;
            break;

        case IOCTL_HPS_WRITE_CAPABILITY:
            //
            // Usermode is overwriting the SHPC capability structure.  This
            // is a test IOCTL.
            //

            DbgPrintEx(DPFLTR_HPS_ID,
                       DPFLTR_INFO_LEVEL,
                       "HPS-Device Control IOCTL_HPS_WRITE_CAPABILITY\n"
                       );
            if (!Irp->AssociatedIrp.SystemBuffer ||
                (IrpStack->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(HPTEST_WRITE_CONFIG))) {

                //
                // We didn't get the buffer we expected.  Fail.
                //
                return STATUS_INVALID_PARAMETER;
            }

            writeDescriptor = (PHPTEST_WRITE_CONFIG)Irp->AssociatedIrp.SystemBuffer;
            HpsHandleDirectWriteConfig(Extension,
                                       PCI_WHICHSPACE_CONFIG,
                                       (PUCHAR)&writeDescriptor->Buffer + writeDescriptor->Offset,
                                       Extension->ConfigOffset+writeDescriptor->Offset,
                                       writeDescriptor->Length
                                       );
            status = STATUS_SUCCESS;
            break;

        case IOCTL_HPS_BRIDGE_INFO:
            //
            // Usermode is requesting the bus/dev/func for this device for
            // identification purposes.  This is a test IOCTL.
            //

            DbgPrintEx(DPFLTR_HPS_ID,
                       DPFLTR_INFO_LEVEL,
                       "HPS-Device Control IOCTL_HPS_BRIDGE_INFO\n"
                       );
            if (!Irp->AssociatedIrp.SystemBuffer ||
                (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                 sizeof(HPTEST_BRIDGE_INFO))) {

                //
                // We didn't get the buffer we expected.  Fail.
                //
                return STATUS_INVALID_PARAMETER;
            }

            bridgeInfo = (PHPTEST_BRIDGE_INFO)Irp->AssociatedIrp.SystemBuffer;
            HpsGetBridgeInfo(Extension,
                             bridgeInfo
                             );
            Irp->IoStatus.Information = sizeof(HPTEST_BRIDGE_INFO);
            status = STATUS_SUCCESS;
            break;

        default:

            status = STATUS_NOT_SUPPORTED;

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\hotplug\sys\register.c ===
/*++

Copyright (c) 2000 Microsoft Corporation All Rights Reserved

Module Name:

    register.c

Abstract:

    This module controls access to the register set
    of the SHPC.

Environment:

    Kernel Mode

Revision History:

    Davis Walker (dwalker) Sept 8 2000

--*/

#include "hpsp.h"

//
// Private function declarations
//

VOID
RegisterWriteCommon(
    IN OUT PHPS_DEVICE_EXTENSION    DeviceExtension,
    IN     ULONG                    RegisterNum,
    IN     PULONG                   Buffer,
    IN     ULONG                    BitMask
    );

VOID
RegisterWriteCommandReg(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension,
    IN     ULONG                 RegisterNum,
    IN     PULONG                Buffer,
    IN     ULONG                 BitMask
    );

VOID
RegisterWriteIntMask(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension,
    IN     ULONG                 RegisterNum,
    IN     PULONG                Buffer,
    IN     ULONG                 BitMask
    );

VOID
RegisterWriteSlotRegister(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension,
    IN     ULONG                 RegisterNum,
    IN     PULONG                Buffer,
    IN     ULONG                 BitMask
    );

BOOLEAN
HpsCardCapableOfBusSpeed(
    IN ULONG                BusSpeed,
    IN SHPC_SLOT_REGISTER   SlotRegister
    );

BOOLEAN
HpsSlotLegalForSpeedMode(
    IN PHPS_DEVICE_EXTENSION    DeviceExtension,
    IN ULONG                    BusSpeed,
    IN ULONG                    TargetSlot
    );

NTSTATUS
HpsSendControllerEvent(
    IN PHPS_DEVICE_EXTENSION DeviceExtension,
    IN PHPS_CONTROLLER_EVENT ControllerEvent
    );

VOID
HpEventWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID
HpsPerformInterruptRipple(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    );

VOID
HpsSerrConditionDetected(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    );

//
// Register writing structure
//


PHPS_WRITE_REGISTER RegisterWriteCommands[] = {
    RegisterWriteCommon,        // Bar Description reg
    RegisterWriteCommon,        // Slots Available 1
    RegisterWriteCommon,        // Slots Available 2
    RegisterWriteCommon,        // SlotsControlled reg
    RegisterWriteCommon,        // SecondaryBus reg
    RegisterWriteCommandReg,    // Command reg needs to execute command
    RegisterWriteCommon,        // InterruptLocator reg
    RegisterWriteCommon,        // SERR locator reg
    RegisterWriteIntMask,       // InterruptEnable reg needs to clear pending bits
    RegisterWriteSlotRegister,  //
    RegisterWriteSlotRegister,  // Slot registers need to do things like send
    RegisterWriteSlotRegister,  // commands to the user-mode slot controller
    RegisterWriteSlotRegister,  // on write.
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister,
    RegisterWriteSlotRegister
};

NTSTATUS
HpsInitRegisters(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    )
/*++

Function Description:

    This routine initializes the register set to its default
    state

Arguments:

    DeviceExtension - Pointer to the device extension containing the
                      register set to be initialized.

Return Value:

    VOID
--*/
{

    ULONG                       i;
    PSHPC_WORKING_REGISTERS     registerSet;
    NTSTATUS                    status;
    UCHAR                       offset;
    PHPS_HWINIT_DESCRIPTOR       hwInit;

    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-HPS Register Init\n"
               );

    registerSet = &DeviceExtension->RegisterSet.WorkingRegisters;
    RtlZeroMemory(registerSet,
                  sizeof(SHPC_REGISTER_SET)
                  );
    //
    // Now we just have to initialize fields with non-zero default values
    //

    //
    // This is a revision 1 SHPC
    //
    registerSet->BusConfig.ProgIF = 0x1;

    if (DeviceExtension->UseConfig) {
        status = HpsGetCapabilityOffset(DeviceExtension,
                                        HPS_HWINIT_CAPABILITY_ID,
                                        &offset);
    
        if (!NT_SUCCESS(status)) {
    
            return status;
        }
    
        DeviceExtension->InterfaceWrapper.PciGetBusData(DeviceExtension->InterfaceWrapper.PciContext,
                                                        PCI_WHICHSPACE_CONFIG,
                                                        &DeviceExtension->HwInitData,
                                                        offset + sizeof(PCI_CAPABILITIES_HEADER),
                                                        sizeof(HPS_HWINIT_DESCRIPTOR)
                                                        );    
    
    } else {
        
        status = HpsGetHBRBHwInit(DeviceExtension);
    }
    

    hwInit = &DeviceExtension->HwInitData;

    registerSet->BaseOffset = hwInit->BarSelect;
    registerSet->SlotsAvailable.NumSlots33Conv = hwInit->NumSlots33Conv;
    registerSet->SlotsAvailable.NumSlots66Conv = hwInit->NumSlots66Conv;
    registerSet->SlotsAvailable.NumSlots66PciX = hwInit->NumSlots66PciX;
    registerSet->SlotsAvailable.NumSlots100PciX = hwInit->NumSlots100PciX;
    registerSet->SlotsAvailable.NumSlots133PciX = hwInit->NumSlots133PciX;
    registerSet->SlotConfig.NumSlots = hwInit->NumSlots;

    registerSet->SlotConfig.UpDown = hwInit->UpDown;
    registerSet->SlotConfig.MRLSensorsImplemented =
        hwInit->MRLSensorsImplemented;
    registerSet->SlotConfig.AttentionButtonImplemented =
        hwInit->AttentionButtonImplemented;

    registerSet->SlotConfig.FirstDeviceID = hwInit->FirstDeviceID;
    registerSet->SlotConfig.PhysicalSlotNumber =
        hwInit->FirstSlotLabelNumber;

    registerSet->BusConfig.ProgIF = hwInit->ProgIF;

    //
    // slot specific registers
    // initialize everything to be off
    //
    for (i = 0; i < SHPC_MAX_SLOT_REGISTERS; i++) {

        registerSet->SlotRegisters[i].SlotStatus.SlotState = SHPC_SLOT_OFF;
        registerSet->SlotRegisters[i].SlotStatus.PowerIndicatorState = SHPC_INDICATOR_OFF;
        registerSet->SlotRegisters[i].SlotStatus.AttentionIndicatorState = SHPC_INDICATOR_OFF;
    }

    //
    // Make sure these changes are reflected in the config space and HBRB representations.
    //
    HpsResync(DeviceExtension);
    
    return STATUS_SUCCESS;
}

//
// functions to execute on register writes
//

VOID
RegisterWriteCommon(
    IN OUT PHPS_DEVICE_EXTENSION    DeviceExtension,
    IN     ULONG                    RegisterNum,
    IN     PULONG                   Buffer,
    IN     ULONG                    BitMask
    )
/*++

Function Description:

    This routine performs a register write.

Arguments:

    DeviceExtension - the devext containing the register set to be written

    RegisterNum - the register number to write

    Buffer - a buffer containing the value to write into

    BitMask - a mask indicating the bits of the register that were written

Return Value:

    VOID
--*/
{

    PULONG destinationReg;
    ULONG data;
    ULONG registerWriteMask;
    ULONG registerClearMask;

    if (RegisterNum >= SHPC_NUM_REGISTERS) {
        return;
    }

    registerWriteMask = ~RegisterReadOnlyMask[RegisterNum] & BitMask;
    registerClearMask = RegisterWriteClearMask[RegisterNum] & BitMask;

    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-Register Write Common for register %d\n",
               RegisterNum
               );

    destinationReg = &(DeviceExtension->RegisterSet.AsULONGs[RegisterNum]);
    data = *Buffer;

    //
    // clear the bits that are RWC if the corresponding bit is set in the Buffer
    //
    data &= ~(registerClearMask & data);

    //
    // now overwrite the existing register taking into account read only bits
    //
    HpsWriteWithMask(destinationReg,
                     &registerWriteMask,
                     &data,
                     sizeof(ULONG)
                     );
}

VOID
RegisterWriteCommandReg(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension,
    IN     ULONG                 RegisterNum,
    IN     PULONG                Buffer,
    IN     ULONG                 BitMask
    )

/*++
Function Description:

    This function performs a write to the command register.  Since this
    register write has side effects, we cannot simply call RegisterWriteCommon

Arguments:

    DeviceExtension - the devext containing the register set to be written

    RegisterNum - the register number to write

    Buffer - a buffer containing the value to write into

    BitMask - a mask indicating the bits of the register that were written

Return Value:

    VOID
--*/

{

    BOOLEAN written;

    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-Register Write Command Register\n"
               );

    ASSERT(RegisterNum == FIELD_OFFSET(SHPC_WORKING_REGISTERS,
                                       Command
                                       ) / sizeof(ULONG));

    RegisterWriteCommon(DeviceExtension,
                        RegisterNum,
                        Buffer,
                        BitMask
                        );

    if (BitMask & 0xFF) {

        HpsPerformControllerCommand(DeviceExtension);
    }


    //
    // Command is not guaranteed to be finished at this point, so we do not
    // clear the busy bit.  This is done either in PerformControllerCommand or PendCommand
    //

}

VOID
RegisterWriteIntMask(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension,
    IN     ULONG                 RegisterNum,
    IN     PULONG                Buffer,
    IN     ULONG                 BitMask
    )
/*++
Function Description:

    This function performs a write to the INT enable register.  Since this
    register write has side effects, we cannot simply call RegisterWriteCommon
    DeviceExtension - the devext containing the register set to be written

Arguments:

    DeviceExtension - the devext containing the register set to be written

    RegisterNum - the register number to write

    Buffer - a buffer containing the value to write into

    BitMask - a mask indicating the bits of the register that were written

Return Value:

    VOID
--*/
{
    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-Register Write Interrupt Mask\n"
               );
    ASSERT(RegisterNum == FIELD_OFFSET(SHPC_WORKING_REGISTERS,
                                       SERRInt
                                       ) / sizeof(ULONG));
    RegisterWriteCommon(DeviceExtension,
                        RegisterNum,
                        Buffer,
                        BitMask
                        );

    HpsPerformInterruptRipple(DeviceExtension);

}

VOID
RegisterWriteSlotRegister(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension,
    IN     ULONG                 RegisterNum,
    IN     PULONG                Buffer,
    IN     ULONG                 BitMask
    )
/*++
Function Description:

    This function performs a write to a slot register.  Since this
    register write has side effects, we cannot simply call RegisterWriteCommon
    DeviceExtension - the devext containing the register set to be written

Arguments:

    DeviceExtension - the devext containing the register set to be written

    RegisterNum - the register number to write

    Buffer - a buffer containing the value to write into

    BitMask - a mask indicating the bits of the register that were written

Return Value:

    VOID
--*/
{

    ULONG slotNum = RegisterNum - SHPC_FIRST_SLOT_REG;

    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-Register Write Slot Register\n"
               );
    ASSERT(RegisterNum >= FIELD_OFFSET(SHPC_WORKING_REGISTERS,
                                       SlotRegisters
                                       ) / sizeof(ULONG));

    RegisterWriteCommon(DeviceExtension,
                        RegisterNum,
                        Buffer,
                        BitMask
                        );
    HpsPerformInterruptRipple(DeviceExtension);
}

//
// Command execution functions
//

VOID
HpsHandleSlotEvent (
    IN OUT PHPS_DEVICE_EXTENSION    DeviceExtension,
    IN     PHPS_SLOT_EVENT          SlotEvent
    )
/*++

Function Description:

    This routine performs an event that originated at the slots
    (attention button pressed, etc)

Arguments:

    DeviceExtension - the devext representing the SHPC

    SlotEvent - a structure defining the slot event that needs to be processed

Return Value:

    VOID
--*/
{
    UCHAR               slotNum = SlotEvent->SlotNum;
    UCHAR               intEnable;
    UCHAR               serrEnable;
    PSHPC_SLOT_REGISTER slotRegister;
    PIO_STACK_LOCATION  irpStack;
    HPS_CONTROLLER_EVENT event;

    ASSERT(slotNum < DeviceExtension->RegisterSet.WorkingRegisters.SlotConfig.NumSlots);

    if (slotNum >= DeviceExtension->RegisterSet.WorkingRegisters.SlotConfig.NumSlots) {

        return;
    }

    //
    // slot numbers are assumed to be 0 indexed from softpci's perspective, but 1 indexed
    // from the controller's perspective, so we add 1 before printing out the number of
    // the slot we're playing with.
    //
    slotRegister = &(DeviceExtension->RegisterSet.WorkingRegisters.SlotRegisters[slotNum]);

    DbgPrintEx(DPFLTR_HPS_ID,
               DPFLTR_INFO_LEVEL,
               "HPS-Performing Slot Command on slot %d\n",
               slotNum+1
               );

    //
    // set slot specific pending and status fields;
    //
    switch (SlotEvent->EventType) {
        case IsolatedPowerFault:
            slotRegister->SlotEventLatch |= SHPC_SLOT_EVENT_ISO_FAULT;
            slotRegister->SlotStatus.PowerFaultDetected = 1;
            break;
        case AttentionButton:
            slotRegister->SlotEventLatch |= SHPC_SLOT_EVENT_ATTEN_BUTTON;
            break;
        case MRLClose:
            slotRegister->SlotEventLatch |= SHPC_SLOT_EVENT_MRL_SENSOR;
            slotRegister->SlotStatus.MRLSensorState = SHPC_MRL_CLOSED;
            break;
        case MRLOpen:
            slotRegister->SlotEventLatch |= SHPC_SLOT_EVENT_MRL_SENSOR;
            slotRegister->SlotStatus.MRLSensorState = SHPC_MRL_OPEN;

            //
            // Opening the MRL implicitly disables the slot.  Set the register
            // and tell softpci about it.
            //
            //
            slotRegister->SlotStatus.SlotState = SHPC_SLOT_OFF;

            event.SlotNums = 1<<slotNum;
            event.SERRAsserted = 0;
            event.Command.SlotOperation.CommandCode = SHPC_SLOT_OPERATION_CODE;
            event.Command.SlotOperation.SlotState = SHPC_SLOT_OFF;
            event.Command.SlotOperation.PowerIndicator = SHPC_INDICATOR_NOP;
            event.Command.SlotOperation.AttentionIndicator = SHPC_INDICATOR_NOP;
            HpsSendEventToWmi(DeviceExtension,
                              &event
                              );
            break;
    }

    //
    // These latch events could cause an interrupt.  Perform the appropriate
    // ripple magic.
    //
    HpsPerformInterruptRipple(DeviceExtension);

}

VOID
HpsPerformControllerCommand (
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    )
/*++

Function Description:

    This routine performs a command that originated at the controller

Arguments:

    DeviceExtension - the devext representing the SHPC

Return Value:

    VOID
--*/
{

    SHPC_CONTROLLER_COMMAND command;
    PSHPC_WORKING_REGISTERS workingRegisters;
    PSHPC_SLOT_REGISTER     slotRegister;

    NTSTATUS                status;
    HPS_CONTROLLER_EVENT    controllerEvent;
    USHORT                  currentPowerState;
    UCHAR                   targetSlot;
    BOOLEAN                 commandLegal = TRUE;
    UCHAR                   errorCode = 0;
    UCHAR                   currentSlot;
    UCHAR                   currentMaxSpeed;
    ULONG                   i;

    //
    // If the controller is already busy, we can't execute another command.
    //
    if (DeviceExtension->RegisterSet.WorkingRegisters.Command.Status.ControllerBusy) {
        return;
    }
    DeviceExtension->RegisterSet.WorkingRegisters.Command.Status.ControllerBusy = 1;

    workingRegisters = &DeviceExtension->RegisterSet.WorkingRegisters;

    command  = workingRegisters->Command.Command;
    targetSlot = workingRegisters->Command.Target.TargetForCommand;
    RtlZeroMemory(&controllerEvent,
                  sizeof(HPS_CONTROLLER_EVENT)
                  );

    ASSERT(targetSlot <= SHPC_MAX_SLOT_REGISTERS);
    if (targetSlot > SHPC_MAX_SLOT_REGISTERS) {
        workingRegisters->Command.Status.InvalidCommand = 1;
        HpsCommandCompleted(DeviceExtension);
        return;
    }

    slotRegister = &workingRegisters->SlotRegisters[targetSlot-1];

    if (IS_COMMAND_SLOT_OPERATION(command)) {
        //
        // The command is to change the state of a slot.
        //

        DbgPrintEx(DPFLTR_HPS_ID,
                   DPFLTR_INFO_LEVEL,
                   "HPS-Controller to Slot Command\n"
                   );

        //
        // perform legality checking
        //
        currentPowerState = workingRegisters->SlotRegisters[targetSlot-1].SlotStatus.SlotState;
        switch (command.SlotOperation.SlotState) {
            case SHPC_SLOT_POWERED:

                if (currentPowerState == SHPC_SLOT_ENABLED) {

                    //
                    // can't go from enabled to powered
                    //
                    commandLegal = FALSE;
                    workingRegisters->Command.Status.InvalidCommand = 1;
                }
                if (slotRegister->SlotStatus.MRLSensorState == SHPC_MRL_OPEN) {

                    //
                    // MRL Open.  Command fails.
                    //
                    commandLegal = FALSE;
                    workingRegisters->Command.Status.MRLOpen = 1;
                }
                break;

            case SHPC_SLOT_ENABLED:

                if (slotRegister->SlotStatus.MRLSensorState == SHPC_MRL_OPEN) {

                    //
                    // MRL Open.  Command fails.
                    //
                    commandLegal = FALSE;
                    workingRegisters->Command.Status.MRLOpen = 1;
                }
                if (!HpsCardCapableOfBusSpeed(workingRegisters->BusConfig.CurrentBusMode,
                                              *slotRegister
                                              )) {

                    //
                    // The card in this slot can't run at the current bus speed.  Command fails.
                    //
                    commandLegal = FALSE;
                    workingRegisters->Command.Status.InvalidSpeedMode = 1;
                }
                if (!HpsSlotLegalForSpeedMode(DeviceExtension,
                                              workingRegisters->BusConfig.CurrentBusMode,
                                              targetSlot
                                              )) {
                    //
                    // This slot is above the maximum supported for this bus speed.  Command fails.
                    //
                    commandLegal = FALSE;
                    workingRegisters->Command.Status.InvalidCommand = 1;
                }
                break;

            default:
                commandLegal = TRUE;
                break;

        }

        if (commandLegal) {

            if (command.SlotOperation.SlotState != SHPC_SLOT_NOP) {
                slotRegister->SlotStatus.SlotState =
                    command.SlotOperation.SlotState;
            }
            if (command.SlotOperation.AttentionIndicator != SHPC_INDICATOR_NOP) {
                slotRegister->SlotStatus.AttentionIndicatorState =
                    command.SlotOperation.AttentionIndicator;
            }
            if (command.SlotOperation.PowerIndicator != SHPC_INDICATOR_NOP) {
                slotRegister->SlotStatus.PowerIndicatorState =
                    command.SlotOperation.PowerIndicator;
            }

            controllerEvent.SlotNums = 1 << (targetSlot-1);
            controllerEvent.Command.AsUchar  = command.AsUchar;
            controllerEvent.SERRAsserted = 0;
            status = HpsSendControllerEvent(DeviceExtension,
                                            &controllerEvent
                                            );
            if (!NT_SUCCESS(status)) {
                commandLegal = FALSE;
            }

        }


    } else if (IS_COMMAND_SET_BUS_SEGMENT(command)) {
        //
        // The command is to change the bus speed/mode
        //

        //
        // perform legality checking
        //
        if (!HpsSlotLegalForSpeedMode(DeviceExtension,
                                      command.BusSegmentOperation.BusSpeed,
                                      1
                                      )) {
            //
            // If Slot 1 is illegal for the requested speed/mode, the speed is unsupported
            //
            commandLegal = FALSE;
            workingRegisters->Command.Status.InvalidSpeedMode = 1;

        }
        for (i=1; i<=workingRegisters->SlotConfig.NumSlots; i++) {

            if ((workingRegisters->SlotRegisters[i-1].SlotStatus.SlotState == SHPC_SLOT_ENABLED) &&
                !HpsSlotLegalForSpeedMode(DeviceExtension,
                                          command.BusSegmentOperation.BusSpeed,
                                          i
                                          )) {
                //
                // If more slots are enabled than are supported at this bus speed,
                // the command must fail.
                //
                commandLegal = FALSE;
                workingRegisters->Command.Status.InvalidCommand = 1;
            }
            if ((workingRegisters->SlotRegisters[i-1].SlotStatus.SlotState == SHPC_SLOT_ENABLED) &&
                !HpsCardCapableOfBusSpeed(command.BusSegmentOperation.BusSpeed,
                                          workingRegisters->SlotRegisters[i-1]
                                          )) {
                //
                // If there is an enabled card that does not support the requested
                // bus speed, the command must fail.
                //
                commandLegal = FALSE;
                workingRegisters->Command.Status.InvalidSpeedMode = 1;
            }
        }

        if (commandLegal){

            workingRegisters->BusConfig.CurrentBusMode =
                command.BusSegmentOperation.BusSpeed;

            HpsCommandCompleted(DeviceExtension);
        }


    } else if (IS_COMMAND_POWER_ALL_SLOTS(command)) {
        //
        // The command is to power up all the slots
        //

        //
        // perform legality checking
        //
        for (i=0; i<workingRegisters->SlotConfig.NumSlots; i++) {

            if (workingRegisters->SlotRegisters[i].SlotStatus.SlotState == SHPC_SLOT_ENABLED) {

                //
                // A slot can't go from enabled to powered.
                //
                commandLegal = FALSE;
                workingRegisters->Command.Status.InvalidCommand = 1;
                break;
            }
        }

        if (commandLegal) {

            for (i=0; i<workingRegisters->SlotConfig.NumSlots; i++) {
                if (workingRegisters->SlotRegisters[i].SlotStatus.MRLSensorState == SHPC_MRL_CLOSED) {
                    controllerEvent.SlotNums |= 1<<i;
                }
            }
            controllerEvent.Command.SlotOperation.PowerIndicator = SHPC_INDICATOR_ON;
            controllerEvent.Command.SlotOperation.SlotState = SHPC_SLOT_POWERED;
            controllerEvent.SERRAsserted = 0;
            status = HpsSendControllerEvent(DeviceExtension,
                                            &controllerEvent
                                            );
            if (!NT_SUCCESS(status)) {
                commandLegal = FALSE;
            }
        }

    } else if (IS_COMMAND_ENABLE_ALL_SLOTS(command)) {
        //
        // The command is to enable all the slots
        //

        //
        // Perform legality checking
        //
        for (i=0; i<workingRegisters->SlotConfig.NumSlots; i++){

            if ((workingRegisters->SlotRegisters[i].SlotStatus.MRLSensorState == SHPC_MRL_CLOSED) &&
                !HpsCardCapableOfBusSpeed(workingRegisters->BusConfig.CurrentBusMode,
                                          workingRegisters->SlotRegisters[i]
                                          )) {

                //
                // If a card in a slot with a closed MRL can't run at the current bus speed,
                // the command must fail.
                //
                commandLegal = FALSE;
                workingRegisters->Command.Status.InvalidSpeedMode = 1;
            }
            if (workingRegisters->SlotRegisters[i].SlotStatus.SlotState == SHPC_SLOT_ENABLED) {

                //
                // If any slots are already enabled, the command must fail.
                //
                commandLegal = FALSE;
                workingRegisters->Command.Status.InvalidCommand = 1;
            }
        }

        if (commandLegal) {

            for (i=0; i<workingRegisters->SlotConfig.NumSlots; i++) {
                if (workingRegisters->SlotRegisters[i].SlotStatus.MRLSensorState == SHPC_MRL_CLOSED) {
                    controllerEvent.SlotNums |= 1<<i;
                }
            }
            controllerEvent.Command.SlotOperation.PowerIndicator = SHPC_INDICATOR_ON;
            controllerEvent.Command.SlotOperation.SlotState = SHPC_SLOT_ENABLED;
            controllerEvent.SERRAsserted = 0;
            status = HpsSendControllerEvent(DeviceExtension,
                                            &controllerEvent
                                            );
            if (!NT_SUCCESS(status)) {
                commandLegal = FALSE;
            }

        }
    }

    if (!commandLegal) {

        HpsCommandCompleted(DeviceExtension);
    }

    return;
}

BOOLEAN
HpsCardCapableOfBusSpeed(
    IN ULONG                BusSpeed,
    IN SHPC_SLOT_REGISTER   SlotRegister
    )
/*++

Routine Description:

    This routine determines whether the slot indicated can run at the
    bus speed indicated.

Arguments:

    BusSpeed - The bus speed to check.  The possible values for this
        are spelled out in the SHPC_SPEED_XXX variables.

    SlotRegister - The slot specific register representing the slot
        to be tested.

Return Value:

    TRUE if the card in the specified slot can run at the specified
        bus speed.
    FALSE otherwise.
--*/
{
    ULONG maximumSpeed;

    switch (SlotRegister.SlotStatus.PCIXCapability) {
        case SHPC_PCIX_NO_CAP:
            //
            // If the card is not capable of PCIX, its maximum speed is
            // indicated by its 66 Mhz capability
            //
            maximumSpeed = SlotRegister.SlotStatus.SpeedCapability;
            break;
        case SHPC_PCIX_66_CAP:
            maximumSpeed = SHPC_SPEED_66_PCIX;
            break;
        case SHPC_PCIX_133_CAP:
            maximumSpeed = SHPC_SPEED_133_PCIX;
            break;
    }

    if (BusSpeed > maximumSpeed) {
        return FALSE;
    } else return TRUE;

}

BOOLEAN
HpsSlotLegalForSpeedMode(
    IN PHPS_DEVICE_EXTENSION    DeviceExtension,
    IN ULONG                    BusSpeed,
    IN ULONG                    TargetSlot
    )
/*++

Routine Description:

    This routine determines whether the slot indicated is legal for
    the bus speed indicated.  This takes into account the Slots Available
    registers in the register set.

Arguments:

    DeviceExtension - The device extension.  This contains a pointer to
        the register set.

    BusSpeed - The bus speed to check.  The possible values for this
        are spelled out in the SHPC_SPEED_XXX variables.

    TargetSlot - The slot to test.

Return Value:

    TRUE if the specified slot is legal for the specified bus speed.
    FALSE otherwise.
--*/
{
    ULONG maxSupportedSlot;

    switch (BusSpeed) {
        case SHPC_SPEED_33_CONV:
            maxSupportedSlot =
                DeviceExtension->RegisterSet.WorkingRegisters.SlotsAvailable.NumSlots33Conv;
            break;
        case SHPC_SPEED_66_CONV:
            maxSupportedSlot =
                DeviceExtension->RegisterSet.WorkingRegisters.SlotsAvailable.NumSlots66Conv;
            break;
        case SHPC_SPEED_66_PCIX:
            maxSupportedSlot =
                DeviceExtension->RegisterSet.WorkingRegisters.SlotsAvailable.NumSlots66PciX;
            break;
        case SHPC_SPEED_100_PCIX:
            maxSupportedSlot =
                DeviceExtension->RegisterSet.WorkingRegisters.SlotsAvailable.NumSlots100PciX;
            break;
        case SHPC_SPEED_133_PCIX:
            maxSupportedSlot =
                DeviceExtension->RegisterSet.WorkingRegisters.SlotsAvailable.NumSlots133PciX;
            break;
        default:
            maxSupportedSlot = 0;
            break;
    }

    if (TargetSlot > maxSupportedSlot) {
        return FALSE;

    } else {
        return TRUE;
    }
}

NTSTATUS
HpsSendControllerEvent(
    IN PHPS_DEVICE_EXTENSION DeviceExtension,
    IN PHPS_CONTROLLER_EVENT ControllerEvent
    )
/*++

Routine Description:

    This routine sends an event that originated at the controller level
    to the usermode application representing the slots.  It relies on
    usermode sending an IRP for the driver to pend so that it can later
    complete the IRP to notify usermode about a controller event.         // 625 comment is out of date

Arguments:

    DeviceExtension - The device extension for this device.

    ControllerEvent - A pointer to the structure representing the event to be sent.

Return Value:

    An NT status code indicating the success of the operation.

--*/
{
    NTSTATUS status;

    // 625 make sure this can't be reentrant, because it's screwed if it is.
    if (!DeviceExtension->EventsEnabled) {
        //
        // We can't do anything if WMI events aren't enabled
        //
        return STATUS_UNSUCCESSFUL;
    }

    RtlCopyMemory(&DeviceExtension->CurrentEvent,ControllerEvent,sizeof(HPS_CONTROLLER_EVENT));

    //
    // Make sure the config space and the HBRB are synced up before sending this
    // request
    //
    HpsResync(DeviceExtension);
    
    KeInsertQueueDpc(&DeviceExtension->EventDpc,
                     &DeviceExtension->CurrentEvent,
                     NULL
                     );

    return STATUS_SUCCESS;
}

VOID
HpsEventDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PHPS_DEVICE_EXTENSION extension = (PHPS_DEVICE_EXTENSION)DeferredContext;
    PHPS_EVENT_WORKITEM workContext;

    workContext = ExAllocatePool(NonPagedPool,
                                 sizeof(HPS_EVENT_WORKITEM)
                                 );
    if (!workContext) {
        return;
    }
    workContext->WorkItem = IoAllocateWorkItem(extension->Self);
    if (!workContext->WorkItem) {
        ExFreePool(workContext);
        return;
    }
    workContext->Event = (PHPS_CONTROLLER_EVENT)SystemArgument1;

    IoQueueWorkItem(workContext->WorkItem,
                    HpEventWorkerRoutine,
                    CriticalWorkQueue,
                    workContext
                    );
}

VOID
HpEventWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PHPS_DEVICE_EXTENSION extension = (PHPS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    PHPS_EVENT_WORKITEM workContext = (PHPS_EVENT_WORKITEM)Context;
    PHPS_CONTROLLER_EVENT event;

    event = workContext->Event;

    IoFreeWorkItem(workContext->WorkItem);
    ExFreePool(workContext);

    HpsSendEventToWmi(extension,
                      event
                      );
}

VOID
HpsSendEventToWmi(
    IN PHPS_DEVICE_EXTENSION Extension,
    IN PHPS_CONTROLLER_EVENT Event
    )
{
    PWNODE_HEADER Wnode;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    ULONG sizeNeeded;
    PUCHAR WnodeDataPtr;

    PAGED_CODE();
    //
    // Create a new WNODE for the event
    //
    sizeNeeded = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                              sizeof(HPS_CONTROLLER_EVENT) +
                              Extension->WmiEventContextSize;

    Wnode = ExAllocatePool(NonPagedPool,
                           sizeNeeded
                           );
    if (!Wnode) {

        return;
    }

    Wnode->ProviderId = IoWMIDeviceObjectToProviderId(Extension->Self);
    Wnode->Flags = WNODE_FLAG_EVENT_ITEM | WNODE_FLAG_SINGLE_INSTANCE | WNODE_FLAG_PDO_INSTANCE_NAMES;
    Wnode->BufferSize = sizeNeeded;
    Wnode->Guid = GUID_HPS_CONTROLLER_EVENT;

    WnodeSI = (PWNODE_SINGLE_INSTANCE)Wnode;
    WnodeSI->DataBlockOffset = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData);
    WnodeSI->InstanceIndex = 0;
    WnodeSI->SizeDataBlock = sizeof(HPS_CONTROLLER_EVENT) + Extension->WmiEventContextSize;

    WnodeDataPtr = (PUCHAR)Wnode + WnodeSI->DataBlockOffset;
    RtlCopyMemory(WnodeDataPtr, Extension->WmiEventContext, Extension->WmiEventContextSize);

    WnodeDataPtr += Extension->WmiEventContextSize;
    RtlCopyMemory(WnodeDataPtr, Event, sizeof(HPS_CONTROLLER_EVENT));

    DbgPrintEx(DPFLTR_HPS_ID,
               HPS_WMI_LEVEL,
               "HPS-Send Controller Event slots=0x%x Code=0x%x Power=%d Atten=%d State=%d\n",
               Event->SlotNums,
               Event->Command.SlotOperation.CommandCode,
               Event->Command.SlotOperation.PowerIndicator,
               Event->Command.SlotOperation.AttentionIndicator,
               Event->Command.SlotOperation.SlotState
                );
    IoWMIWriteEvent(Wnode);
}

VOID
HpsCommandCompleted(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    )
/*++

Function Description:

    This routine is called whenever a controller command completes.

Arguments:

    DeviceExtension - the devext representing the SHPC

Return Value:

    VOID

--*/
{
    PSHPC_WORKING_REGISTERS workingRegisters = &DeviceExtension->RegisterSet.WorkingRegisters;

    //
    // Sometimes we get here because we've just sent a non-command to usermode (like
    // reporting an SERR.)  In that case, we don't need to clear anything up.
    //
    if (workingRegisters->Command.Status.ControllerBusy) {
        workingRegisters->Command.Status.ControllerBusy = 0x0;
        workingRegisters->SERRInt.SERRIntDetected |= SHPC_DETECTED_COMMAND_COMPLETE;

        //
        // Completing the command may cause an interrupt.  Update the lines.
        //
        HpsPerformInterruptRipple(DeviceExtension);
    }


}

VOID
HpsPerformInterruptRipple(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Function Description:

    This routine is called when the simulator detects a condition that could
    potentially cause an interrupt (like a command completing).
    It does the appropriate rippling of these signals through masks up to the
    top level.
    If interrupts are enabled, it calls the ISR to simulate an interrupt

Arguments:

    DeviceExtension - the devext representing the SHPC

Return Value:

    VOID

--*/

{
    PSHPC_WORKING_REGISTERS workingRegisters;
    PSHPC_SLOT_REGISTER slotRegister;
    UCHAR intEnable;
    ULONG slotNum;
    BOOLEAN intPending,serrPending;
    
    workingRegisters = &DeviceExtension->RegisterSet.WorkingRegisters;

    //
    // First, set slot specific pending bits.
    //
    for (slotNum=0; slotNum < SHPC_MAX_SLOT_REGISTERS; slotNum++) {
        slotRegister = &workingRegisters->SlotRegisters[slotNum];

        //
        // Invert the mask to get an enable
        //
        intEnable = ~slotRegister->IntSERRMask;

        if ((intEnable & SHPC_SLOT_INT_ALL) &
            (slotRegister->SlotEventLatch & SHPC_SLOT_EVENT_ALL)) {
            //
            // We have an interrupt causing event.  set the pending bit.
            //
            workingRegisters->IntLocator.InterruptLocator |= 1<<slotNum;

        } else {
            workingRegisters->IntLocator.InterruptLocator &= ~(1<<slotNum);
        }

        if (((intEnable & SHPC_SLOT_SERR_ALL) >> 2) &
            (slotRegister->SlotEventLatch & SHPC_SLOT_EVENT_ALL)) {
            //
            // We have an SERR causing event.  set the pending bit.
            //
            workingRegisters->SERRLocator.SERRLocator |= 1<<slotNum;

        } else {
            workingRegisters->SERRLocator.SERRLocator &= ~(1<<slotNum);
        }
    }

    //
    // Next set the other pending bits.
    //
    if ((workingRegisters->SERRInt.SERRIntDetected & SHPC_DETECTED_COMMAND_COMPLETE) &&
        ((~workingRegisters->SERRInt.SERRIntMask) & SHPC_MASK_INT_COMMAND_COMPLETE)) {
        //
        // Command Complete detected and enabled.  Make it pending.
        //
        workingRegisters->IntLocator.CommandCompleteIntPending = 1;

    } else {
        workingRegisters->IntLocator.CommandCompleteIntPending = 0;
    }

    if ((workingRegisters->SERRInt.SERRIntDetected & SHPC_DETECTED_ARBITER_TIMEOUT) &&
        ((~workingRegisters->SERRInt.SERRIntMask) & SHPC_MASK_SERR_ARBITER_TIMEOUT)) {
        //
        // Arbiter timeout detected and enabled.  Make it pending.
        //
        workingRegisters->SERRLocator.ArbiterSERRPending = 1;

    } else {
        workingRegisters->SERRLocator.ArbiterSERRPending = 0;
    }

    //
    // If anything in the locator register is set, set the config space
    // controller interrupt pending bit.
    //
    if (workingRegisters->IntLocator.CommandCompleteIntPending ||
        workingRegisters->IntLocator.InterruptLocator) {

        intPending = 1;

    } else {
        intPending = 0;
    }

    //
    // If anything in the SERR locator register is set, make an SERR pending
    //
    if (workingRegisters->SERRLocator.ArbiterSERRPending ||
        workingRegisters->SERRLocator.SERRLocator) {

        serrPending = 1;

    } else {
        serrPending = 0;
    }

    //
    // We made changes to the register set.  Make sure the config space
    // and HBRB representations get updated.
    //
    HpsResync(DeviceExtension);
    
    //
    // If interrupts are enabled and we have a pending interrupt,
    // fire it off.
    //
    if (intPending && ((~workingRegisters->SERRInt.SERRIntMask) & SHPC_MASK_INT_GLOBAL)) {

        HpsInterruptExecution(DeviceExtension);
    }

    //
    // If serrs are enabled and we have a pending serr,
    // fire it off
    //
    if (serrPending && ((~workingRegisters->SERRInt.SERRIntMask) & SHPC_MASK_SERR_GLOBAL)) {

        HpsSerrConditionDetected(DeviceExtension);
    }

}

VOID
HpsSerrConditionDetected(
    IN OUT PHPS_DEVICE_EXTENSION DeviceExtension
    )
/*++

Function Description:

    This routine is called when the simulator detects a condition that could
    potentially cause an interrupt (like a command completing).
    If interrupts are enabled, it calls the ISR to simulate an interrupt

Arguments:

    DeviceExtension - the devext representing the SHPC

Return Value:

    VOID

--*/
{
    HPS_CONTROLLER_EVENT controllerEvent;

    if (~DeviceExtension->RegisterSet.WorkingRegisters.SERRInt.SERRIntMask & SHPC_MASK_SERR_GLOBAL) {

        controllerEvent.SlotNums = 0;  // All slots
        controllerEvent.Command.SlotOperation.SlotState = SHPC_SLOT_OFF;
        controllerEvent.Command.SlotOperation.PowerIndicator = SHPC_INDICATOR_OFF;
        controllerEvent.Command.SlotOperation.AttentionIndicator = SHPC_INDICATOR_OFF;
        controllerEvent.SERRAsserted = 0x1;

        HpsSendControllerEvent(DeviceExtension,
                               &controllerEvent
                               );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\inc\interface.h ===
#ifndef INTERFACE_H
#define INTERFACE_H

typedef
NTSTATUS
(*PHPS_REGISTER_INTERRUPT)(
    IN PVOID Context,
    IN PKSERVICE_ROUTINE  ServiceRoutine,
    IN PVOID  ServiceContext
    );

typedef
VOID
(*PHPS_UNREGISTER_INTERRUPT)(
    IN PVOID Context
    );

typedef
BOOLEAN
(*PHPS_SYNCHRONIZE_EXECUTION)(
    IN PVOID Context,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

typedef struct _HPS_REGISTER_INTERRUPT_INTERFACE {


    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    PHPS_REGISTER_INTERRUPT ConnectISR;
    PHPS_UNREGISTER_INTERRUPT DisconnectISR;
    PHPS_SYNCHRONIZE_EXECUTION SyncExecutionRoutine;


} HPS_REGISTER_INTERRUPT_INTERFACE, *PHPS_REGISTER_INTERRUPT_INTERFACE;

typedef
VOID
(*PHPS_READWRITE_BUFFER)(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

typedef struct _HPS_MEMORY_INTERFACE {

    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    PHPS_READWRITE_BUFFER ReadRegister;
    PHPS_READWRITE_BUFFER WriteRegister;

} HPS_MEMORY_INTERFACE, *PHPS_MEMORY_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\inc\simguid.h ===
#ifndef _SIMGUIDH_
#define _SIMGUIDH_


#include <initguid.h>

//
//      ****  SOFTPCI DEFINES  ****
//


//
// Device Interface GUID used by driver and UI.
//
DEFINE_GUID( GUID_SOFTPCI_INTERFACE, 0x5301a278L, 0x8fa9, 0x4141, 0xaa, 0xc2, 0x1c, 0xbf, 0x7a,  0x41, 0x2c, 0xd5);

//
// IOCTL Code definitions in "User Defined" range of 0x800 to 0xFFF.
//
#define SOFTPCI_IOCTL_TYPE 0x202B

#define SOFTPCI_IOCTL_CREATE_DEVICE CTL_CODE(SOFTPCI_IOCTL_TYPE,    \
                                             0x800,                 \
                                             METHOD_BUFFERED,       \
                                             FILE_ANY_ACCESS        \
                                             )
    
#define SOFTPCI_IOCTL_DELETE_DEVICE CTL_CODE(SOFTPCI_IOCTL_TYPE,    \
                                             0x801,                 \
                                             METHOD_BUFFERED,       \
                                             FILE_ANY_ACCESS        \
                                             )
    
#define SOFTPCI_IOCTL_GET_DEVICE CTL_CODE(SOFTPCI_IOCTL_TYPE,       \
                                          0x802,                    \
                                          METHOD_BUFFERED,          \
                                          FILE_ANY_ACCESS           \
                                          )
    
#define SOFTPCI_IOCTL_RW_CONFIG CTL_CODE(SOFTPCI_IOCTL_TYPE,      \
                                         0x803,                   \
                                         METHOD_BUFFERED,         \
                                         FILE_ANY_ACCESS          \
                                         )
    
//#define SOFTPCI_IOCTL_WRITE_CONFIG CTL_CODE(SOFTPCI_IOCTL_TYPE,     \
//                                            0x804,                  \
//                                            METHOD_BUFFERED,        \
//                                            FILE_ANY_ACCESS         \
//                                            )

#define SOFTPCI_IOCTL_GET_DEVICE_COUNT CTL_CODE(SOFTPCI_IOCTL_TYPE,    \
                                                0x804,                 \
                                                METHOD_BUFFERED,       \
                                                FILE_ANY_ACCESS        \
                                                )

//
//  Max number of IOCTL Codes we currently allow.
//
#define MAX_IOCTL_CODE_SUPPORTED    0x4

//
// This macro takes the IOCTL code and breaks it into a zero based index.
//
#define SOFTPCI_IOCTL(ioctl) ((IoGetFunctionCodeFromCtlCode(ioctl)) - 0x800)


//
//      ****  HOTPLUG DEFINES  ****
//

//
// Slot to controller communication structures and defines
//

DEFINE_GUID(GUID_HPS_DEVICE_CLASS,0xad76cffc,0xb5e0,0x4981,
            0x80, 0xc1, 0x3c, 0x29, 0xe3, 0x0e, 0xe2, 0x15);


#define IOCTL_HPS_SLOT_COMMAND CTL_CODE(FILE_DEVICE_BUS_EXTENDER,   \
                                        0xc02,                      \
                                        METHOD_BUFFERED,            \
                                        FILE_ANY_ACCESS             \
                                        )

#define IOCTL_HPS_PEND_COMMAND CTL_CODE(FILE_DEVICE_BUS_EXTENDER,   \
                                        0xc03,                      \
                                        METHOD_BUFFERED,            \
                                        FILE_ANY_ACCESS             \
                                        )

#define IOCTL_HPS_READ_REGISTERS CTL_CODE(FILE_DEVICE_BUS_EXTENDER,   \
                                          0xc04,                      \
                                          METHOD_BUFFERED,            \
                                          FILE_ANY_ACCESS             \
                                          )

#define IOCTL_HPS_READ_CAPABILITY CTL_CODE(FILE_DEVICE_BUS_EXTENDER,   \
                                           0xc05,                      \
                                           METHOD_BUFFERED,            \
                                           FILE_ANY_ACCESS             \
                                           )

#define IOCTL_HPS_WRITE_CAPABILITY CTL_CODE(FILE_DEVICE_BUS_EXTENDER,   \
                                            0xc06,                      \
                                            METHOD_BUFFERED,            \
                                            FILE_ANY_ACCESS             \
                                            )

#define IOCTL_HPS_BRIDGE_INFO CTL_CODE(FILE_DEVICE_BUS_EXTENDER,   \
                                       0xc07,                      \
                                       METHOD_BUFFERED,            \
                                       FILE_ANY_ACCESS             \
                                       )


//
// Interface between shpc and hpsim
//

DEFINE_GUID(GUID_REGISTER_INTERRUPT_INTERFACE, 0xa6485b93, 0x77d9, 0x4d89,
            0x92, 0xaa, 0x25, 0x30, 0x8a, 0xb8, 0xd0, 0x7a);

DEFINE_GUID(GUID_HPS_MEMORY_INTERFACE, 0x437217bb, 0x23ca, 0x4ac7,
            0x8b, 0x97, 0xa5, 0x5c, 0xa1, 0xcd, 0x8a, 0x68);

#endif //_SIMGUIDH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\inc\hpwmi.h ===
#ifndef _HPWMI_
#define _HPWMI_

//
// WMI stuff
//
#define HPS_CONTROLLER_EVENT_GUID_INDEX 0
#define HPS_EVENT_CONTEXT_GUID_INDEX 1
#define HPS_INIT_DATA_GUID_INDEX 2
#define HPS_SLOT_METHOD_GUID_INDEX 3

//
// Set slot state events
//
DEFINE_GUID(GUID_HPS_CONTROLLER_EVENT, 0x0cfc84ce, 0xbfd9, 0x4724,
                                       0x9c, 0xaa, 0xc0, 0xea, 0xef, 0x95, 0x2e, 0x26);

//
// Data Instance giving context to controller events
//
DEFINE_GUID(GUID_HPS_EVENT_CONTEXT, 0x2488ab8b, 0xdd5e, 0x48a8,
                                    0x83, 0x98, 0x52, 0x4d, 0x2b, 0xf5, 0x67, 0xea);

//
// Data Instance of the SHPC's initialization data
//
DEFINE_GUID(GUID_HPS_INIT_DATA, 0x085ac722, 0x2c84, 0x4c4e,
                                0xa3, 0xe7, 0xff, 0xd8, 0xc8, 0x6e, 0x4b, 0x12);
//
// Method called when there is a slot event (attention button, etc)
//
DEFINE_GUID(GUID_HPS_SLOT_METHOD, 0x1842b66a, 0xb405, 0x4f84,
                                  0x9c, 0xc6, 0x29, 0xde, 0x1d, 0xc1, 0xe1, 0x2a);
#define SlotMethod 1
#define AddDeviceMethod 2
#define RemoveDeviceMethod 3
#define GetDeviceMethod 4
#define GetSlotStatusMethod 5
#define CommandCompleteMethod 6

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\cmdata.h ===
PWCHAR SoftPCI_CmProblemTable[NUM_CM_PROB+1] = {

    L"No Problem",
    L"CM_PROB_NOT_CONFIGURED",              //(0x00000001)   // no config for device
    L"CM_PROB_DEVLOADER_FAILED",            //(0x00000002)   // service load failed
    L"CM_PROB_OUT_OF_MEMORY",               //(0x00000003)   // out of memory
    L"CM_PROB_ENTRY_IS_WRONG_TYPE",         //(0x00000004)   //
    L"CM_PROB_LACKED_ARBITRATOR",           //(0x00000005)   //
    L"CM_PROB_BOOT_CONFIG_CONFLICT",        //(0x00000006)   // boot config conflict
    L"CM_PROB_FAILED_FILTER",               //(0x00000007)   //
    L"CM_PROB_DEVLOADER_NOT_FOUND",         //(0x00000008)   // Devloader not found
    L"CM_PROB_INVALID_DATA",                //(0x00000009)   //
    L"CM_PROB_FAILED_START",                //(0x0000000A)   //
    L"CM_PROB_LIAR",                        //(0x0000000B)   //
    L"CM_PROB_NORMAL_CONFLICT",             //(0x0000000C)   // config conflict
    L"CM_PROB_NOT_VERIFIED",                //(0x0000000D)   //
    L"CM_PROB_NEED_RESTART",                //(0x0000000E)   // requires restart
    L"CM_PROB_REENUMERATION",               //(0x0000000F)   //
    L"CM_PROB_PARTIAL_LOG_CONF",            //(0x00000010)   //
    L"CM_PROB_UNKNOWN_RESOURCE",            //(0x00000011)   // unknown res type
    L"CM_PROB_REINSTALL",                   //(0x00000012)   //
    L"CM_PROB_REGISTRY",                    //(0x00000013)   //
    L"CM_PROB_VXDLDR",                      //(0x00000014)   // WINDOWS 95 ONLY
    L"CM_PROB_WILL_BE_REMOVED",             //(0x00000015)   // devinst will remove
    L"CM_PROB_DISABLED",                    //(0x00000016)   // devinst is disabled
    L"CM_PROB_DEVLOADER_NOT_READY",         //(0x00000017)   // Devloader not ready
    L"CM_PROB_DEVICE_NOT_THERE",            //(0x00000018)   // device doesn't exist
    L"CM_PROB_MOVED",                       //(0x00000019)   //
    L"CM_PROB_TOO_EARLY",                   //(0x0000001A)   //
    L"CM_PROB_NO_VALID_LOG_CONF",           //(0x0000001B)   // no valid log config
    L"CM_PROB_FAILED_INSTALL",              //(0x0000001C)   // install failed
    L"CM_PROB_HARDWARE_DISABLED",           //(0x0000001D)   // device disabled
    L"CM_PROB_CANT_SHARE_IRQ",              //(0x0000001E)   // can't share IRQ
    L"CM_PROB_FAILED_ADD",                  //(0x0000001F)   // driver failed add
    L"CM_PROB_DISABLED_SERVICE",            //(0x00000020)   // service's Start = 4
    L"CM_PROB_TRANSLATION_FAILED",          //(0x00000021)   // resource translation failed
    L"CM_PROB_NO_SOFTCONFIG",               //(0x00000022)   // no soft config
    L"CM_PROB_BIOS_TABLE",                  //(0x00000023)   // device missing in BIOS table
    L"CM_PROB_IRQ_TRANSLATION_FAILED",      //(0x00000024)   // IRQ translator failed
    L"CM_PROB_FAILED_DRIVER_ENTRY",         //(0x00000025)   // DriverEntry() failed.
    L"CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD",  //(0x00000026)   // Driver should have unloaded.
    L"CM_PROB_DRIVER_FAILED_LOAD",          //(0x00000027)   // Driver load unsuccessful.
    L"CM_PROB_DRIVER_SERVICE_KEY_INVALID",  //(0x00000028)   // Error accessing driver's service key
    L"CM_PROB_LEGACY_SERVICE_NO_DEVICES",   //(0x00000029)   // Loaded legacy service created no devices
    L"CM_PROB_DUPLICATE_DEVICE",            //(0x0000002A)   // Two devices were discovered with the same name
    L"CM_PROB_FAILED_POST_START",           //(0x0000002B)   // The drivers set the device state to failed
    L"CM_PROB_HALTED",                      //(0x0000002C)   // This device was failed post start via usermode
    L"CM_PROB_PHANTOM",                     //(0x0000002D)   // The devinst currently exists only in the registry
    L"CM_PROB_SYSTEM_SHUTDOWN",             //(0x0000002E)   // The system is shutting down
    L"CM_PROB_HELD_FOR_EJECT",              //(0x0000002F)   // The device is offline awaiting removal
    L"CM_PROB_DRIVER_BLOCKED",              //(0x00000030)   // One or more drivers is blocked from loading
    L"CM_PROB_REGISTRY_TOO_LARGE",          //(0x00000031)   // System hive has grown too large
    NULL                                    //(0x00000032)   // NUM_CM_PROB
};

TCHAR *SoftPCI_CmResultTable[] = {
    TEXT("CR_SUCCESS"),                  // 0x00000000
    TEXT("CR_DEFAULT"),                  // 0x00000001
    TEXT("CR_OUT_OF_MEMORY"),            // 0x00000002
    TEXT("CR_INVALID_POINTER"),          // 0x00000003
    TEXT("CR_INVALID_FLAG"),             // 0x00000004
    TEXT("CR_INVALID_DEVNODE"),          // 0x00000005
    TEXT("CR_INVALID_RES_DES"),          // 0x00000006
    TEXT("CR_INVALID_LOG_CONF"),         // 0x00000007
    TEXT("CR_INVALID_ARBITRATOR"),       // 0x00000008
    TEXT("CR_INVALID_NODELIST"),         // 0x00000009
    TEXT("CR_DEVNODE_HAS_REQS"),         // 0x0000000A
    TEXT("CR_INVALID_RESOURCEID"),       // 0x0000000B
    TEXT("CR_DLVXD_NOT_FOUND"),          // 0x0000000C
    TEXT("CR_NO_SUCH_DEVNODE"),          // 0x0000000D
    TEXT("CR_NO_MORE_LOG_CONF"),         // 0x0000000E
    TEXT("CR_NO_MORE_RES_DES"),          // 0x0000000F
    TEXT("CR_ALREADY_SUCH_DEVNODE"),     // 0x00000010
    TEXT("CR_INVALID_RANGE_LIST"),       // 0x00000011
    TEXT("CR_INVALID_RANGE"),            // 0x00000012
    TEXT("CR_FAILURE"),                  // 0x00000013
    TEXT("CR_NO_SUCH_LOGICAL_DEV"),      // 0x00000014
    TEXT("CR_CREATE_BLOCKED"),           // 0x00000015
    TEXT("CR_NOT_SYSTEM_VM"),            // 0x00000016
    TEXT("CR_REMOVE_VETOED"),            // 0x00000017
    TEXT("CR_APM_VETOED"),               // 0x00000018
    TEXT("CR_INVALID_LOAD_TYPE"),        // 0x00000019
    TEXT("CR_BUFFER_SMALL"),             // 0x0000001A
    TEXT("CR_NO_ARBITRATOR"),            // 0x0000001B
    TEXT("CR_NO_REGISTRY_HANDLE"),       // 0x0000001C
    TEXT("CR_REGISTRY_ERROR"),           // 0x0000001D
    TEXT("CR_INVALID_DEVICE_ID"),        // 0x0000001E
    TEXT("CR_INVALID_DATA"),             // 0x0000001F
    TEXT("CR_INVALID_API"),              // 0x00000020
    TEXT("CR_DEVLOADER_NOT_READY"),      // 0x00000021
    TEXT("CR_NEED_RESTART"),             // 0x00000022
    TEXT("CR_NO_MORE_HW_PROFILES"),      // 0x00000023
    TEXT("CR_DEVICE_NOT_THERE"),         // 0x00000024
    TEXT("CR_NO_SUCH_VALUE"),            // 0x00000025
    TEXT("CR_WRONG_TYPE"),               // 0x00000026
    TEXT("CR_INVALID_PRIORITY"),         // 0x00000027
    TEXT("CR_NOT_DISABLEABLE"),          // 0x00000028
    TEXT("CR_FREE_RESOURCES"),           // 0x00000029
    TEXT("CR_QUERY_VETOED"),             // 0x0000002A
    TEXT("CR_CANT_SHARE_IRQ"),           // 0x0000002B
    TEXT("CR_NO_DEPENDENT"),             // 0x0000002C
    TEXT("CR_SAME_RESOURCES"),           // 0x0000002D
    TEXT("CR_NO_SUCH_REGISTRY_KEY"),     // 0x0000002E
    TEXT("CR_INVALID_MACHINENAME"),      // 0x0000002F
    TEXT("CR_REMOTE_COMM_FAILURE"),      // 0x00000030
    TEXT("CR_MACHINE_UNAVAILABLE"),      // 0x00000031
    TEXT("CR_NO_CM_SERVICES"),           // 0x00000032
    TEXT("CR_ACCESS_DENIED"),            // 0x00000033
    TEXT("CR_CALL_NOT_IMPLEMENTED"),     // 0x00000034
    TEXT("CR_INVALID_PROPERTY"),         // 0x00000035
    TEXT("CR_DEVICE_INTERFACE_ACTIVE"),  // 0x00000036
    TEXT("CR_NO_SUCH_DEVICE_INTERFACE"), // 0x00000037
    TEXT("CR_INVALID_REFERENCE_STRING"), // 0x00000038
    TEXT("CR_INVALID_CONFLICT_LIST"),    // 0x00000039
    TEXT("CR_INVALID_INDEX"),            // 0x0000003A
    TEXT("CR_INVALID_STRUCTURE_SIZE")    // 0x0000003B
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\inc\spci.h ===
#ifndef _SPCIH_
#define _SPCIH_


#define IS_BRIDGE(x)    ((PCI_CONFIGURATION_TYPE(&x->Config.Current)) == PCI_BRIDGE_TYPE)
#define IS_ROOTBUS(x)                               \
        ((x->Config.PlaceHolder == TRUE) &&         \
         (x->Config.Current.VendorID == 0xAAAA) &&  \
         (x->Config.Current.DeviceID == 0xBBBB))


typedef struct _SOFTPCI_DEVICE  *PSOFTPCI_DEVICE;

typedef union _SOFTPCI_SLOT{
    
    struct{
        UCHAR Function;
        UCHAR Device;
    };
    USHORT  AsUSHORT;

} SOFTPCI_SLOT, *PSOFTPCI_SLOT;

typedef enum _SOFTPCI_READWRITE_CONFIG{
    Unsupported = 0,
    SoftPciReadConfig,
    SoftPciWriteConfig         
} SOFTPCI_READWRITE_CONFIG;

typedef struct _SOFTPCI_RW_CONTEXT{

    SOFTPCI_READWRITE_CONFIG WriteConfig;
    ULONG Bus;
    SOFTPCI_SLOT Slot;
    ULONG Offset;
    PVOID Data;
    
} SOFTPCI_RW_CONTEXT, *PSOFTPCI_RW_CONTEXT;

typedef enum
{
    TYPE_UNKNOWN = -1,
    TYPE_DEVICE,
    TYPE_PCI_BRIDGE,
    TYPE_HOTPLUG_BRIDGE,
    TYPE_CARDBUS_DEVICE,
    TYPE_CARDBUS_BRIDGE,
    TYPE_UNSUPPORTED

} SOFTPCI_DEV_TYPE;

typedef struct _SOFTPCI_CONFIG{

    BOOLEAN PlaceHolder;          // True if this device is a bridge place holder
                                  // to keep our view of PCI matching with
                                  // the actual hardware.

    PCI_COMMON_CONFIG Current;    // Current configspace
    PCI_COMMON_CONFIG Mask;       // Configspace Mask
    PCI_COMMON_CONFIG Default;    // Default configspace

} SOFTPCI_CONFIG, *PSOFTPCI_CONFIG;

typedef struct _SOFTPCI_DEVICE{
    
    PSOFTPCI_DEVICE Parent;
    PSOFTPCI_DEVICE Sibling;
    PSOFTPCI_DEVICE Child;

    SOFTPCI_DEV_TYPE DevType;
    UCHAR Bus;
    SOFTPCI_SLOT Slot;
    SOFTPCI_CONFIG Config;          // Config space buffers

} SOFTPCI_DEVICE;

typedef struct _SOFTPCI_SCRIPT_DEVICE{
    
    SINGLE_LIST_ENTRY ListEntry;
    BOOLEAN SlotSpecified;
    SOFTPCI_DEVICE SoftPciDevice;
    ULONG ParentPathLength;
    WCHAR ParentPath[1];  //variable length path
    
} SOFTPCI_SCRIPT_DEVICE, *PSOFTPCI_SCRIPT_DEVICE;

//
// Cardbus has extra configuration information beyond the common
// header. (stolen from the PCI driver)
//
typedef struct _PCI_TYPE2_HEADER_EXTRAS {
    USHORT  SubVendorID;
    USHORT  SubSystemID;
    ULONG   LegacyModeBaseAddress;
} PCI_TYPE2_HEADER_EXTRAS, *PPCI_TYPE2_HEADER_EXTRAS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\cmutil.h ===
extern PWCHAR SoftPCI_CmProblemTable[];

typedef struct _CM_RES_DATA *PCM_RES_DATA;

typedef struct _CM_RES_DATA{

    RESOURCEID      ResourceId;
    ULONG           DescriptorSize;
    PULONG          ResourceDescriptor;
    //PCM_RES_DATA    NextResourceDescriptor;

}CM_RES_DATA;

VOID
SoftPCI_EnableDisableDeviceNode(
    IN DEVNODE DeviceNode,
    IN BOOL EnableDevice
    );

BOOL
SoftPCI_GetDeviceNodeProblem(
    IN DEVNODE DeviceNode,
    OUT PULONG DeviceProblem
    );

BOOL
SoftPCI_GetBusDevFuncFromDevnode(
    IN DEVNODE Dn,
    OUT PULONG Bus,
    OUT PSOFTPCI_SLOT Slot
    );

BOOL
SoftPCI_GetPciRootBusNumber(
    IN DEVNODE Dn,
    OUT PULONG Bus
    );

BOOL
SoftPCI_GetFriendlyNameFromDevNode(
    IN DEVNODE Dn,
    IN PWCHAR Buffer
    );

BOOL
SoftPCI_GetResources(
    PPCI_DN Pdn,
    PWCHAR Buffer,
    ULONG ConfigType
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\cmutil.c ===
#include "pch.h"
#include "cmdata.h"

BOOL
SoftPCI_GetNextResourceDescriptorData(
   IN OUT PRES_DES      ResourceDescriptor,
    OUT PCM_RES_DATA    CmResData
    );

VOID
SoftPCI_FreeResourceDescriptorData(
    IN PCM_RES_DATA CmResData
    );

VOID 
SoftPCI_DumpCmResData(
    IN PCM_RES_DATA CmResData,
    OUT PWCHAR  Buffer
    );

VOID
SoftPCI_EnableDisableDeviceNode(
    IN DEVNODE DeviceNode,
    IN BOOL EnableDevice
    )
{
    
    if (EnableDevice) {

        CM_Enable_DevNode(DeviceNode, 0);

    }else{

        if ((MessageBox(g_SoftPCIMainWnd,
                       L"This option will disable and unloaded the driver for this device.  HW remains physically present.",
                       L"WARNING", MB_OKCANCEL)) == IDOK){

            CM_Disable_DevNode(DeviceNode, 0);
        }
    }
}

BOOL
SoftPCI_GetDeviceNodeProblem(
    IN DEVNODE DeviceNode,
    OUT PULONG DeviceProblem
    )
{
    CONFIGRET cr;
    ULONG dnStatus;
    
    cr = CM_Get_DevNode_Status(&dnStatus, DeviceProblem, DeviceNode, 0);

    if (cr == CR_SUCCESS && 
        ((dnStatus & DN_HAS_PROBLEM) != 0)) {
        //
        //  We have a problem, if it that we are disabled then return TRUE 
        //
        return TRUE;
    }

    return FALSE;

}


BOOL
SoftPCI_GetBusDevFuncFromDevnode(
    IN DEVNODE Dn,
    OUT PULONG Bus,
    OUT PSOFTPCI_SLOT Slot
    )
/*--
Routine Description:

   This function takes a devnode and works out the devices Bus, Device, and Function
   numbers.

Arguments:

    Dn  - DeviceNode to get location info for
    Bus - retrieved bus number
    Dev - retrieved device number
    Func - retrieved function number

Return Value:

    TRUE if successful, FALSE otherwise
--*/

{

    WCHAR locationinfo[MAX_PATH];
    ULONG length = MAX_PATH;
    ULONG device = 0, function = 0;

    //
    //  Get the Location info of the device via the registry api
    //
    if ((CM_Get_DevNode_Registry_Property(Dn,
                                          CM_DRP_LOCATION_INFORMATION,
                                          NULL,
                                          &locationinfo,
                                          &length,
                                          0
                                          ))==CR_SUCCESS){

        //
        //  Now scan the returned information for the numbers we are after.
        //
        //  Note: This is dependant on the format of the loaction information
        //  taken from the registry and if it should ever change this will break.
        //  Should probably look into better solution.
        //

        if (swscanf(locationinfo,
                    L"PCI bus %d, device %d, function %d",
                    Bus, &device, &function)) {

            Slot->Device = (UCHAR)device;
            Slot->Function = (UCHAR)function;
            
            SoftPCI_Debug(SoftPciDevice, 
                      L"Bus 0x%02x, Device 0x%02x, Function 0x%02x\n",
                      *Bus, device, function);

            return TRUE;
        }
    }

    SoftPCI_Debug(SoftPciDevice, L"Failed to get Bus Dev Func for devnode 0x%x\n", Dn);

    return FALSE;
}

BOOL
SoftPCI_GetFriendlyNameFromDevNode(
    IN DEVNODE Dn,
    IN PWCHAR Buffer
    )
{

    ULONG length = MAX_PATH;

    //
    //  Get the FriendlyName of the device
    //
    if ((CM_Get_DevNode_Registry_Property(Dn,
                                          CM_DRP_DEVICEDESC,
                                          NULL,
                                          Buffer,
                                          &length,
                                          0
                                          )) != CR_SUCCESS){
        
        SoftPCI_Debug(SoftPciDevice, L"Failed to get friendly name for devnode 0x%x\n", Dn);
        return FALSE;
    }

    return TRUE;

}


BOOL
SoftPCI_GetPciRootBusNumber(
    IN DEVNODE Dn,
    OUT PULONG Bus
    )
{

    DEVNODE child = 0;
    ULONG length = sizeof(ULONG);


    *Bus = 0xFFFFFFFF;

    if ((CM_Get_Child(&child, Dn, 0)==CR_SUCCESS)){

        if ((CM_Get_DevNode_Registry_Property(child,
                                              CM_DRP_BUSNUMBER,
                                              NULL,
                                              Bus,
                                              &length,
                                              0
                                              ))!=CR_SUCCESS){

            SoftPCI_Debug(SoftPciDevice, L"Failed to get bus number from child 0x%x for devnode 0x%x\n", 
                          child, Dn);
            return FALSE;
        }
    }
    return TRUE;
}

BOOL
SoftPCI_GetNextResourceDescriptorData(
 IN OUT PRES_DES        ResourceDescriptor,
    OUT PCM_RES_DATA    CmResData
    )
{
    
    RES_DES         resDes;
    ULONG           resSize = 0;
    PULONG          resBuf = NULL;
    RESOURCEID      resID;
    CONFIGRET       cr = CR_SUCCESS;
    

    if (CmResData->ResourceDescriptor) {
        free(CmResData->ResourceDescriptor);
        CmResData->ResourceDescriptor = NULL;
    }
    

    //
    //  Stash away the current RES_DES handle so we dont lose it and leak mem
    //
    resDes = *ResourceDescriptor;

    if ((CM_Get_Next_Res_Des(ResourceDescriptor, 
                             *ResourceDescriptor, 
                             ResType_All, 
                             &resID, 
                             0
                             )==CR_SUCCESS)){
        
        if ((CM_Get_Res_Des_Data_Size(&resSize, *ResourceDescriptor, 0)) == CR_SUCCESS){
            
            resBuf = (PULONG) calloc(1, resSize);
            
            if (resBuf == NULL) {
                return FALSE;
            }
            
            CmResData->ResourceId = resID;
            CmResData->DescriptorSize = resSize;
            CmResData->ResourceDescriptor = resBuf;
            
            SoftPCI_Debug(SoftPciCmData, L"GetNextResourceDescriptorData - ResourceId = 0x%x\n", resID);
            SoftPCI_Debug(SoftPciCmData, L"GetNextResourceDescriptorData - DescriptorSize = 0x%x\n", resSize);
            
            if ((cr = CM_Get_Res_Des_Data(*ResourceDescriptor, resBuf, resSize, 0)) == CR_SUCCESS){

                SoftPCI_Debug(SoftPciCmData, L"GetNextResourceDescriptorData - ResourceDescriptor = 0x%x\n", resBuf);
                //
                //  Free out last handle
                //
                CM_Free_Res_Des_Handle(resDes);
                return TRUE;

            }else{
                SoftPCI_Debug(SoftPciCmData, L"GetNextResourceDescriptorData - failed to get ResData. (%s)\n", SoftPCI_CmResultTable[cr]);
            }
        }
    }

    if (CmResData->ResourceDescriptor) {
        free(CmResData->ResourceDescriptor);
        CmResData->ResourceDescriptor = NULL;
    }

    return FALSE;
    
}

VOID
SoftPCI_FreeResourceDescriptorData(
    IN PCM_RES_DATA CmResData
    )
{

    if (CmResData->ResourceDescriptor) {
        free(CmResData->ResourceDescriptor);
        CmResData->ResourceDescriptor = NULL;
    }
}

BOOL
SoftPCI_GetResources(
    PPCI_DN Pdn,
    PWCHAR  Buffer,
    ULONG   ConfigType
    )
{

    BOOL            result = FALSE;
    LOG_CONF        logConf;
    RES_DES         resDes;
    CM_RES_DATA     cmResData;

    
    RtlZeroMemory(&cmResData, sizeof(CM_RES_DATA));
    
    //
    //  First get the logconf.
    //  Next get the first resource descrpitor.
    //
    if ((CM_Get_First_Log_Conf(&logConf, Pdn->DevNode, ConfigType)) == CR_SUCCESS){

        resDes = (RES_DES)logConf;

        while (SoftPCI_GetNextResourceDescriptorData((PRES_DES)&resDes,
                                                     &cmResData)) {

            SoftPCI_Debug(SoftPciCmData, L"GetCurrentResources - Success!\n");

            SoftPCI_DumpCmResData(&cmResData, Buffer);

            SoftPCI_FreeResourceDescriptorData(&cmResData);
            result = TRUE;
        }

        //
        //  Free out remaining RES_DES handle and then release the logconf handle
        //
        CM_Free_Res_Des_Handle(resDes);

        CM_Free_Log_Conf_Handle(logConf);


    }
    return result;

}

VOID 
SoftPCI_DumpCmResData(
    IN PCM_RES_DATA CmResData,
    OUT PWCHAR  Buffer
    )
{

    PMEM_DES        memDes;
    PIO_DES         ioDes;
    PDMA_DES        dmaDes;
    PIRQ_DES        irqDes;
    PBUSNUMBER_DES  busDes;

    //PMEM_RANGE      memRange;
    //PIO_RANGE       ioRange;
    //PDMA_RANGE      dmaRange;
    //PIRQ_RANGE      irqRange;

    INT             i = 0;
    UCHAR           busNum;
    
    switch (CmResData->ResourceId){
    
    case ResType_Mem:
        
        memDes = (PMEM_DES) CmResData->ResourceDescriptor;
        
        if (CmResData->DescriptorSize < sizeof(MEM_DES)) {

            SoftPCI_Debug(SoftPciCmData, L"MEM No information available\n");
            break;
        }

        wsprintf(Buffer + wcslen(Buffer), 
                 L"  MEM  \tStart:  0x%08X\tEnd:  0x%08X\r\n", 
                 //L"\tMEM  \t0x%08x  -  0x%08x\r\n", 
                 (DWORD)memDes->MD_Alloc_Base,
                 (DWORD)memDes->MD_Alloc_End
                 );
        
        SoftPCI_Debug(SoftPciCmData, 
                      L"MEM Count:%08x Type: %08x Bas:%08x End:%08x Flags:%04x\n",
                      memDes->MD_Count,
                      memDes->MD_Type,
                      (DWORD)memDes->MD_Alloc_Base,
                      (DWORD)memDes->MD_Alloc_End,
                      memDes->MD_Flags
                      );
#if 0
        memRange = (PMEM_RANGE)((LPBYTE)memDes + sizeof(MEM_DES));

        for (i = 0; i < (INT)(memDes->MD_Count); i++){

            SoftPCI_Debug(SoftPciCmData,
                          L"    Align:%08lx Bytes:%08lx Min:%08lx Max:%08lx Flags:%04x\n",
                         (DWORD)memRange->MR_Align,
                         memRange->MR_nBytes,
                         (DWORD)memRange->MR_Min,
                         (DWORD)memRange->MR_Max,
                         memRange->MR_Flags
                         );
            
            memRange++;
        }
#endif
        break;

    case ResType_IO:
        
        ioDes = (PIO_DES) CmResData->ResourceDescriptor;

        if (CmResData->DescriptorSize < sizeof(IO_DES)) {

            SoftPCI_Debug(SoftPciCmData, L"IO  No information available\n");
            
            break;
        }

        wsprintf(Buffer + wcslen(Buffer),
                 L"  IO  \tStart:  0x%08X\tEnd:  0x%08X\r\n",
                 //L"\tIO  \t0x%08x  -  0x%08x\r\n",
                 (DWORD)ioDes->IOD_Alloc_Base,
                 (DWORD)ioDes->IOD_Alloc_End
                 );


        SoftPCI_Debug(SoftPciCmData,
                      L"IO  Count:%08x Type: %08x Bas:%08x End:%08x Flags:%04x %s\n",
                      ioDes->IOD_Count,
                      ioDes->IOD_Type,
                      (DWORD)ioDes->IOD_Alloc_Base,
                      (DWORD)ioDes->IOD_Alloc_End,
                      ioDes->IOD_DesFlags,
                      ((ioDes->IOD_DesFlags & fIOD_PortType)==fIOD_Memory) ? L"(memory)" : L""
                      );
        break;

    case ResType_IRQ:

        irqDes = (PIRQ_DES) CmResData->ResourceDescriptor;
            
        if (CmResData->DescriptorSize < sizeof(IRQ_DES)) {

            SoftPCI_Debug(SoftPciCmData, L"IRQ  No information available\n");
            break;
        }

        wsprintf(Buffer + wcslen(Buffer),
                 L"  IRQ  \tStart:  0x%08X\tEnd:  0x%08X\r\n",
                 //L"\tIRQ  \t0x%08\r\n",
                 irqDes->IRQD_Alloc_Num,

                 irqDes->IRQD_Alloc_Num
                 );

        SoftPCI_Debug(SoftPciCmData,
                      L"IRQ Count:%04X Type:%04X Channel:%04X Affinity:%0Xx Flags:%04x\n",
                      irqDes->IRQD_Count,
                      irqDes->IRQD_Type,
                      irqDes->IRQD_Alloc_Num,
                      irqDes->IRQD_Affinity,
                      irqDes->IRQD_Flags);
        
        break;

    case ResType_BusNumber:

        busDes = (PBUSNUMBER_DES) CmResData->ResourceDescriptor;

        if (CmResData->DescriptorSize < sizeof(BUSNUMBER_DES)) {

            SoftPCI_Debug(SoftPciCmData, L"BUS  No information available\n");
            break;
        }

        wsprintf(Buffer + wcslen(Buffer),
                 L"  BUS  \tStart:  0x%08X\tEnd:  0x%08X\r\n",
                 busDes->BUSD_Alloc_Base,
                 busDes->BUSD_Alloc_End
                 );

        

        break;

    case ResType_DMA:
            
        dmaDes = (PDMA_DES) CmResData->ResourceDescriptor;
        
        if (CmResData->DescriptorSize < sizeof(DMA_DES)) {

            SoftPCI_Debug(SoftPciCmData, L"DMA  No information available\n");
            break;
        }

        wsprintf(Buffer + wcslen(Buffer),
                 L"  DMA  \tStart:  0x%08X\t End:  0x%08X\r\n",
                 dmaDes->DD_Alloc_Chan,
                 dmaDes->DD_Alloc_Chan
                 );


        SoftPCI_Debug(SoftPciCmData,
                      L"DMA Count:%04x Type:%04x Channel:%04x Flags:%04x\n",
                      dmaDes->DD_Count,
                      dmaDes->DD_Type,
                      dmaDes->DD_Alloc_Chan,
                      dmaDes->DD_Flags
                      );
        break;


    default:
        SoftPCI_Debug(SoftPciCmData, L"ResourceId 0x%x not handled!\n", CmResData->ResourceId);
        break;

    }

}
#if 0
        // Display the header information on one line.
        wsprintf(szBuf, TEXT("MEM Count:%08x Type: %08x Bas:%08x End:%08x Flags:%04x ("),
                             lpMemDes->MD_Count,
                             lpMemDes->MD_Type,
                             (DWORD)lpMemDes->MD_Alloc_Base,
                             (DWORD)lpMemDes->MD_Alloc_End,
                             lpMemDes->MD_Flags );
        PrintMemFlags(lpMemDes->MD_Flags, szBuf+lstrlen(szBuf)) ;
        lstrcat(szBuf, TEXT(")\r\n")) ;

                lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);

                lpMemRange = (MEM_RANGE *)((LPBYTE)lpMemDes+sizeof(MEM_DES));
                for (iX = 0; iX < (int)(lpMemDes->MD_Count); iX++ )
                {
                    wsprintf(szBuf, TEXT("    Align:%08lx Bytes:%08lx Min:%08lx Max:%08lx Flags:%04x ("),
                                         (DWORD)lpMemRange->MR_Align,
                                         lpMemRange->MR_nBytes,
                                         (DWORD)lpMemRange->MR_Min,
                                         (DWORD)lpMemRange->MR_Max,
                                         lpMemRange->MR_Flags
                                         );
                    
                    PrintMemFlags(lpMemRange->MR_Flags, szBuf+lstrlen(szBuf)) ;
                    lstrcat(szBuf, TEXT(")\r\n")) ;
 
                    lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);
                    lpMemRange++;
                }
                break;

            case ResType_IO:
                lpIODes = (IO_DES *) lpbConfig;

                if (dwSize<sizeof(IO_DES)) {
                    wsprintf(szBuf, TEXT("IO  No information available\r\n"));
                    lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);
                    break;
                }

                wsprintf(szBuf, TEXT("IO  Count:%08x Type: %08x Bas:%08x End:%08x Flags:%04x %s\r\n"),
                                     lpIODes->IOD_Count,
                                     lpIODes->IOD_Type,
                                     (DWORD)lpIODes->IOD_Alloc_Base,
                                     (DWORD)lpIODes->IOD_Alloc_End,
                                     lpIODes->IOD_DesFlags,
                                     ((lpIODes->IOD_DesFlags&fIOD_PortType)==fIOD_Memory) ? TEXT("(memory)") : TEXT("")
                                     );

                lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);
                
                lpIORange = (IO_RANGE *)((LPBYTE)lpIODes+sizeof(IO_DES));

                for (iX = 0; iX < (int)(lpIODes->IOD_Count); iX++ )
                {
                    nAliasType=GetAliasType((DWORD)lpIORange->IOR_Alias) ;
                    wsprintf(szBuf, TEXT("    Align:%08x Ports:%08x Min:%08x Max:%08x Flags:%04x %sAls:%02x (%s)\r\n"),
                                         (DWORD)lpIORange->IOR_Align,
                                         lpIORange->IOR_nPorts,
                                         (DWORD)lpIORange->IOR_Min,
                                         (DWORD)lpIORange->IOR_Max,
                                         lpIORange->IOR_RangeFlags,
                                         ((lpIORange->IOR_RangeFlags&fIOD_PortType)==fIOD_Memory) ? TEXT("(memory) ") : TEXT(""),
                                         (DWORD)lpIORange->IOR_Alias,
                                         lpszAliasNames[nAliasType]);

                    lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);
                    lpIORange++;
                }                                         
                
                break;
                
            case ResType_DMA:
                lpDMADes = (DMA_DES *) lpbConfig;

                if (dwSize<sizeof(DMA_DES)) {
                    wsprintf(szBuf, TEXT("DMA No information available\r\n"));
                    lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);
                    break;
                }

                wsprintf(szBuf, TEXT("DMA Count:%04x Type:%04x Channel:%04x Flags:%04x ("),
                                    lpDMADes->DD_Count,
                                    lpDMADes->DD_Type,
                                    lpDMADes->DD_Alloc_Chan,
                                    lpDMADes->DD_Flags);

                PrintDmaFlags(lpDMADes->DD_Flags, szBuf+lstrlen(szBuf)) ;                
                lstrcat(szBuf, TEXT(")\r\n")) ;
                lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);

                lpDMARange = (DMA_RANGE *)((LPBYTE)lpDMADes+sizeof(DMA_DES));

                for (iX = 0; iX < (int)(lpDMADes->DD_Count); iX++)
                {
                    wsprintf(szBuf, TEXT("    Min:%04x  Max:%04x  Flags:%04x ("),
                                        lpDMARange->DR_Min,
                                        lpDMARange->DR_Max,
                                        lpDMARange->DR_Flags);
                    
                    PrintDmaFlags(lpDMARange->DR_Flags, szBuf+lstrlen(szBuf)) ;                
                    lstrcat(szBuf, TEXT(")\r\n")) ;
  
                    lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);
                    lpDMARange++;
                }

                break;
                
            case ResType_IRQ:
                lpIRQDes = (IRQ_DES *) lpbConfig;
                
                if (dwSize<sizeof(IRQ_DES)) {
                    wsprintf(szBuf, TEXT("IRQ No information available\r\n"));
                    lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);
                    break;
                }

                wsprintf(szBuf, TEXT("IRQ Count:%04x Type:%04x Channel:%04x Affinity:%08x Flags:%04x ("),
                                    lpIRQDes->IRQD_Count,
                                    lpIRQDes->IRQD_Type,
                                    lpIRQDes->IRQD_Alloc_Num,
                                    lpIRQDes->IRQD_Affinity,
                                    lpIRQDes->IRQD_Flags);
                
                PrintIrqFlags(lpIRQDes->IRQD_Flags, szBuf+lstrlen(szBuf)) ;                
                lstrcat(szBuf, TEXT(")\r\n")) ;

                lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);

                lpIRQRange = (IRQ_RANGE *)((LPBYTE)lpIRQDes+sizeof(IRQ_DES));

                for (iX = 0; iX < (int)(lpIRQDes->IRQD_Count); iX++)
                {
                    wsprintf(szBuf, TEXT("    Min:%04x   Max:%04x  Flags:%04x ("),
                                        lpIRQRange->IRQR_Min,
                                        lpIRQRange->IRQR_Max,
                                        lpIRQRange->IRQR_Flags);
        
                    PrintIrqFlags(lpIRQRange->IRQR_Flags, szBuf+lstrlen(szBuf)) ;                
                    lstrcat(szBuf, TEXT(")\r\n")) ;
                    
                    lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);
                    lpIRQRange++;
                }

                break;

            case 0x43:
                bBus  = *lpbConfig;
                
                if (dwSize<sizeof(*lpbConfig)) {
                    wsprintf(szBuf, TEXT("BUS No information available\r\n"));
                    lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);
                    break;
                }

                wsprintf(szBuf, TEXT("BUS %02x\r\n"), bBus);

                lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);

                break;

            default:
                wsprintf(szBuf, TEXT("UKN Unknown resource %04x\r\n"), ridCurResType);

                lstrcat(lpszBuf+lstrlen(lpszBuf), szBuf);

                break;
        }
        
        lpbConfig+=dwSize;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\debug.h ===
typedef enum{
    SoftPciAlways         = 0x00000000,
    SoftPciDialog         = 0x00000001,   // Dialog Box manipulation
    SoftPciTree           = 0x00000002,   // Tree manipulation Prints
    SoftPciDevice         = 0x00000004,   // SoftPCI Device and Bridge prints 
    SoftPciDeviceVerbose  = 0x00000008,   // Verbose device output

    SoftPciInstall        = 0x00000010,   // Installation specific prints
    SoftPciHotPlug        = 0x00000020,   // Hotplug specific prints
    SoftPciCmData         = 0x00000040,   // CmUtil.c prints
    SoftPciProperty       = 0x00000080,   // Devprop.c prints 
    
    SoftPciScript         = 0x00000100,   // Script file related prints 

    SoftPciMainWndMsg     = 0x01000000,   // Display Window Message to MainWnd Message Pump
    SoftPciTreeWndMsg     = 0x02000000,   // Display Window Message to TreeWnd Message Pump
    SoftPciNewDevMsg      = 0x04000000,   // Display Window Message to NewDevDlg Message Pump
    SoftPciDevPropMsg     = 0x08000000,   // Display Window Message to DevPropDlg Message Pump

    SoftPciNoPrepend      = 0x10000000
    
}SOFTPCI_DEBUGLEVEL;

#if DBG

VOID
SoftPCI_DebugDumpConfig(
    IN PPCI_COMMON_CONFIG Config
    );

extern SOFTPCI_DEBUGLEVEL g_SoftPCIDebugLevel;

#define SOFTPCI_DEBUG_BUFFER_SIZE 256

#define SoftPCI_Debug   SoftPCI_DebugPrint

#define SOFTPCI_ASSERT( exp )   \
    ((!(exp)) ? \
    (SoftPCI_Assert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
    TRUE)
    
#define SOFTPCI_ASSERTMSG( msg, exp ) \
    ((!(exp)) ? \
    (SoftPCI_Assert( #exp, __FILE__, __LINE__, msg ),FALSE) : \
    TRUE)

VOID
SoftPCI_DebugPrint(
    SOFTPCI_DEBUGLEVEL DebugLevel,
    PWCHAR DebugMessage,
    ...
    );

VOID
SoftPCI_Assert(
    IN CONST CHAR* FailedAssertion,
    IN CONST CHAR* FileName,
    IN      ULONG  LineNumber,
    IN CONST CHAR* Message  OPTIONAL
    );

#else

#define SOFTPCI_ASSERT(exp)         ((void) 0)
#define SOFTPCI_ASSERTMSG(msg, exp) ((void) 0)
#define SoftPCI_Debug

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\debug.c ===
#include "pch.h"

#if DBG

SOFTPCI_DEBUGLEVEL g_SoftPCIDebugLevel = SoftPciAlways;

WCHAR g_SoftPCIDebugBuffer[SOFTPCI_DEBUG_BUFFER_SIZE];

#define MAX_BUF_SIZE    512

VOID
SoftPCI_DebugPrint(
    SOFTPCI_DEBUGLEVEL DebugLevel,
    PWCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for SoftPCI UI.

Arguments:


Return Value:

    None

--*/

{

    va_list ap;
    WCHAR debugBuffer[SOFTPCI_DEBUG_BUFFER_SIZE];

    va_start(ap, DebugMessage);

    if ((DebugLevel == SoftPciAlways) || 
        (DebugLevel & g_SoftPCIDebugLevel)) {

        _vsnwprintf(debugBuffer, (sizeof(debugBuffer)/sizeof(debugBuffer[0])), DebugMessage, ap);

        if (!(DebugLevel & SoftPciNoPrepend)) {
            wcscpy(g_SoftPCIDebugBuffer, L"SOFTPCI: ");
            wcscat(g_SoftPCIDebugBuffer, debugBuffer);
        }else{
            wcscpy(g_SoftPCIDebugBuffer, debugBuffer);
        }
        

        OutputDebugString(g_SoftPCIDebugBuffer);
    }

    va_end(ap);

}


VOID
SoftPCI_Assert(
    IN CONST CHAR* FailedAssertion,
    IN CONST CHAR* FileName,
    IN      ULONG  LineNumber,
    IN CONST CHAR* Message  OPTIONAL
    )
{

    INT  result;
    CHAR buffer[MAX_BUF_SIZE];
    PWCHAR wbuffer = NULL, p;

    sprintf(buffer,
             "%s%s\nSource File: %s, line %ld\n\n",
             Message ? Message : "",
             Message ? "" : FailedAssertion,
             FileName,
             LineNumber
             );

    wbuffer = (PWCHAR) malloc(MAX_BUF_SIZE * sizeof(WCHAR));

    if (wbuffer) {

        //
        //  Build a string to output to the debugger window
        //
        p = wbuffer;

        if (Message == NULL) {
            wcscpy(wbuffer, L"\nAssertion Failed: ");
            p += wcslen(wbuffer);
        }

        //
        //  Convert it to unicode so we can debug print it.
        //
        MultiByteToWideChar(CP_THREAD_ACP,
                            MB_PRECOMPOSED,
                            buffer,
                            -1,
                            p,
                            MAX_BUF_SIZE
                            );

        
    }

    strcat(buffer, "OK to debug, CANCEL to ignore\n\n");
    
    result = MessageBoxA(g_SoftPCIMainWnd ? g_SoftPCIMainWnd : NULL, 
                         buffer,
                         "*** Assertion failed ***", 
                         MB_OKCANCEL);

    if (wbuffer) {
        SoftPCI_Debug(SoftPciAlways, wbuffer);
        free(wbuffer);
    }

    if (result == IDOK) {
        //
        //  User wants to debug this so init a breakin
        //
        DebugBreak();
    }
}

VOID
SoftPCI_DebugDumpConfig(
    IN PPCI_COMMON_CONFIG Config
    )
{

    
    PULONG  p = (PULONG)&Config;
    ULONG   i = 0;
    
    //
    //  Dump the configspace buffer we are going to send in the ioctl
    //
    SoftPCI_Debug(SoftPciDeviceVerbose, L"CreateDevice - ConfigSpace\n");

    for (i=0; i < (sizeof(PCI_COMMON_CONFIG) / sizeof(ULONG)); i++) {
            
        SoftPCI_Debug(SoftPciDeviceVerbose | SoftPciNoPrepend, L"%08x", *p);
        
        if ((((i+1) % 4) == 0) ||
            ((i+1) == (sizeof(PCI_COMMON_CONFIG) / sizeof(ULONG)))) {
            SoftPCI_Debug(SoftPciDeviceVerbose | SoftPciNoPrepend, L"\n");
        }else{
            SoftPCI_Debug(SoftPciDeviceVerbose | SoftPciNoPrepend, L",");
        }
        p++;
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\devdlg.c ===
#include "pch.h"
#include "dialogp.h"

HWND                    g_NewDevDlg;

PSOFTPCI_DEVICE g_NewDevice;
PHPS_HWINIT_DESCRIPTOR  g_HPSInitDesc;
PPCI_DN                 g_ParentPdn;
ULONG                   g_PossibleDeviceNums;

#define HPS_HWINIT_OFFSET   0x4a
#define HPS_MAX_SLOTS       0x1f  //Max number of slots for each type
#define HPS_MAX_SLOT_LABEL  0xff  //Max number to start slot labeling


struct _BAR_CONTROL{

    INT tb;
    INT mrb;
    INT irb;
    INT pref;
    INT bit64;
    INT tx;

    ULONG   Bar;

}BarControl[PCI_TYPE0_ADDRESSES] = {
    {IDC_BAR0_TB, IDC_BAR0MEM_RB, IDC_BAR0IO_RB, IDC_BAR0_PREF_XB, IDC_BAR0_64BIT_XB, IDC_SLIDER0_TX, 0},
    {IDC_BAR1_TB, IDC_BAR1MEM_RB, IDC_BAR1IO_RB, IDC_BAR1_PREF_XB, IDC_BAR1_64BIT_XB, IDC_SLIDER1_TX, 0},
    {IDC_BAR2_TB, IDC_BAR2MEM_RB, IDC_BAR2IO_RB, IDC_BAR2_PREF_XB, IDC_BAR2_64BIT_XB, IDC_SLIDER2_TX, 0},
    {IDC_BAR3_TB, IDC_BAR3MEM_RB, IDC_BAR3IO_RB, IDC_BAR3_PREF_XB, IDC_BAR3_64BIT_XB, IDC_SLIDER3_TX, 0},
    {IDC_BAR4_TB, IDC_BAR4MEM_RB, IDC_BAR4IO_RB, IDC_BAR4_PREF_XB, IDC_BAR4_64BIT_XB, IDC_SLIDER4_TX, 0},
    {IDC_BAR5_TB, IDC_BAR5MEM_RB, IDC_BAR5IO_RB, IDC_BAR5_PREF_XB,                 0, IDC_SLIDER5_TX, 0 }
};


INT_PTR
CALLBACK
SoftPCI_NewDevDlgProc(
    IN HWND Dlg,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++
Routine Description:
    Dialog handling routine for new device creation

Arguments:


Return Value:

--*/
{
    BOOL rc = FALSE;
    LONG width, height, i;
    RECT mainRect, dlgRect;
    HWND devtype;
    WCHAR buffer[256];
    LONG_PTR dlgstyle;
    PPCI_DN pdn = (PPCI_DN)lParam;
    PPCI_DN bridgePdn;
    PHPS_HWINIT_DESCRIPTOR hotplugData;

    switch ( Msg ) {
    case WM_INITDIALOG:

        SOFTPCI_ASSERT(pdn != NULL);

        if (pdn == NULL) {
            PostMessage(Dlg, WM_CLOSE, 0, 0);
            break;
        }

        //
        //  Allocate a new device. We will fill this out as the user selects
        //  options.
        //
        g_NewDevice = (PSOFTPCI_DEVICE) calloc(1, sizeof(SOFTPCI_DEVICE));

        if (!g_NewDevice) {

            MessageBox(Dlg, L"Failed to allocate memory for new device!",
                       NULL, MB_OK | MB_ICONEXCLAMATION);

            SoftPCI_ResetNewDevDlg();
            return FALSE;

        }

        g_ParentPdn = pdn;
        g_PossibleDeviceNums = SoftPCI_GetPossibleDevNumMask(g_ParentPdn);

        //
        //  Clear our BarControl BARS
        //
        for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {
            BarControl[i].Bar = 0;
        }

        //
        //  Grab the bus we are going to reside on
        //
        bridgePdn = pdn;
        while (bridgePdn->SoftDev == NULL) {
            bridgePdn = bridgePdn->Parent;
        }
        g_NewDevice->Bus = bridgePdn->SoftDev->Config.Current.u.type1.SecondaryBus;

        //
        //  Initialize our drop list
        //
        devtype =  GetDlgItem(Dlg, IDC_DEVTYPE_CB);
        
        SendMessage(devtype, CB_ADDSTRING, 0L, (LPARAM) L"DEVICE");
        SendMessage(devtype, CB_ADDSTRING, 0L, (LPARAM) L"PCI BRIDGE");
        SendMessage(devtype, CB_ADDSTRING, 0L, (LPARAM) L"HOTPLUG BRIDGE");
        SendMessage(devtype, CB_ADDSTRING, 0L, (LPARAM) L"CARDBUS DEVICE");
        SendMessage(devtype, CB_ADDSTRING, 0L, (LPARAM) L"CARDBUS BRIDGE");

        SetFocus(devtype);

        //
        //  Set the Window size
        //
        GetWindowRect(g_SoftPCIMainWnd, &mainRect );
        GetWindowRect(Dlg, &dlgRect );

        width = (mainRect.right - mainRect.left) + 30;
        height = (mainRect.bottom - mainRect.top);
        dlgRect.right -= dlgRect.left;
        dlgRect.bottom -= dlgRect.top;

        //MoveWindow(Dlg, mainRect.right, mainRect.top, dlgRect.right, dlgRect.bottom, TRUE );
        MoveWindow(Dlg, mainRect.left, mainRect.top, dlgRect.right, dlgRect.bottom, TRUE );

        g_NewDevDlg = Dlg;
        break;

    HANDLE_MSG(Dlg, WM_COMMAND, SoftPCI_DlgOnCommand);

    case WM_HSCROLL:

        HANDLE_TRACKBAR(wParam, lParam);
        //SoftPCI_HandleTrackBar(Dlg, wParam, lParam);

        break;


    case WM_VSCROLL:


        HANDLE_SPINNER(wParam, lParam);

        //HANDLE_TRACKBAR(wParam, lParam);
        //SoftPCI_HandleTrackBar(Dlg, wParam, lParam);

        break;



    case WM_CLOSE:
        g_NewDevDlg = 0;

        if (g_NewDevice) {
            free(g_NewDevice);
        }

        EndDialog(Dlg, 0);
        break;


    default:
        break;
    }

    return rc; //DefDlgProc(Dlg, Msg, wParam, lParam);
}

ULONG
SoftPCI_GetPossibleDevNumMask(
    IN PPCI_DN ParentDn
    )
{
    HPS_HWINIT_DESCRIPTOR hpData;
    BOOL status;

    if (!ParentDn->SoftDev) {

        return 0;
    }

    if (ParentDn->Flags & SOFTPCI_HOTPLUG_CONTROLLER) {
        //
        // For hotplug bridges, we remove any hotplug slots, because devices
        // have to be children of the slot objects to be in hotplug slots.
        //
        status = SoftPCI_GetHotplugData(ParentDn,
                                        &hpData
                                        );
        if (!status) {

            return 0;

        } else {
            return (((ULONG)(-1)) -
                    ((ULONG)(1 << (hpData.FirstDeviceID + hpData.NumSlots)) - 1) +
                    ((ULONG)(1 << (hpData.FirstDeviceID)) - 1));
        }
    } else if (ParentDn->Flags & SOFTPCI_HOTPLUG_SLOT) {
        //
        // The only legal device number is the one controlled by this slot.
        //
        return (1 << ParentDn->Slot.Device);

    } else {

        return (ULONG)-1;
    }
}

VOID
SoftPCI_DisplayDlgOptions(
    IN SOFTPCI_DEV_TYPE DevType
    )
{
    HWND control, bargroup;
    ULONG i;
    RECT barRect, dlgRect, rect;
    LONG width, height;
    POINT pt;
    WCHAR buffer[100];

    SoftPCI_ResetNewDevDlg();
    SoftPCI_ShowCommonNewDevDlg();

    bargroup = GetDlgItem(g_NewDevDlg, IDC_BARS_GB);

    GetClientRect(bargroup, &barRect);

    width = barRect.right - barRect.left;
    height = barRect.bottom - barRect.top;

    //
    // Disable our Bars until something is selected.
    //
    for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {

      control = GetDlgItem(g_NewDevDlg, BarControl[i].tb);
      SoftPCI_DisableWindow(control);
      control = GetDlgItem(g_NewDevDlg, BarControl[i].tx);
      SoftPCI_DisableWindow(control);
      control = GetDlgItem(g_NewDevDlg, BarControl[i].pref);
      SoftPCI_DisableWindow(control);
      control = GetDlgItem(g_NewDevDlg, BarControl[i].bit64);
      SoftPCI_DisableWindow(control);
    }

    SoftPCI_ResetLowerBars(-1);

    //
    //  We want this checked by default for now....
    //
    CheckDlgButton(g_NewDevDlg, IDC_DEFAULTDEV_XB, BST_CHECKED);

    //
    //  Start with a clean configspace
    //
    RtlZeroMemory(&g_NewDevice->Config.Current, (sizeof(PCI_COMMON_CONFIG) * 3));

    switch (DevType) {
    case TYPE_DEVICE:

        for (i = IDC_BAR2_TB; i < IDC_BRIDGEWIN_GB; i++) {

            control = GetDlgItem(g_NewDevDlg, i);

            if (control) {
                SoftPCI_ShowWindow(control);
            }

        }

        SoftPCI_InitializeDevice(g_NewDevice, TYPE_DEVICE);

        height = 215;

        break;
    case TYPE_PCI_BRIDGE:

        for (i = IDC_DECODE_GB; i < LAST_CONTROL_ID; i++) {

            control = GetDlgItem(g_NewDevDlg, i);

            if (control) {
                SoftPCI_ShowWindow(control);
            }

        }

        SoftPCI_InitializeDevice(g_NewDevice, TYPE_PCI_BRIDGE);

        //
        //  update the height of our bar group box
        //
        height = 78;

        break;

    case TYPE_HOTPLUG_BRIDGE:


        for (i=IDC_ATTBTN_XB; i < LAST_CONTROL_ID; i++) {

            control = GetDlgItem(g_NewDevDlg, i);

            if (control) {
                SoftPCI_ShowWindow(control);
            }
        }

        //
        //  Allocate our HPS Descriptor
        //
        g_HPSInitDesc  = (PHPS_HWINIT_DESCRIPTOR)((PUCHAR)&g_NewDevice->Config.Current + HPS_HWINIT_OFFSET);


        g_HPSInitDesc->ProgIF = 1;


        SoftPCI_InitializeHotPlugControls();

        SoftPCI_InitializeDevice(g_NewDevice, TYPE_HOTPLUG_BRIDGE);

        //
        //  update the height of our bar group box
        //
        height = 78;

        break;


    case TYPE_CARDBUS_DEVICE:
    case TYPE_CARDBUS_BRIDGE:


        //
        //  These are currently not implemented yet....
        //
        SoftPCI_ResetNewDevDlg();

        control = GetDlgItem(g_NewDevDlg, IDC_NEWDEVINFO_TX);
        SoftPCI_ShowWindow(control);


        SetWindowText (control, L"DEVICE TYPE NOT IMPLEMENTED YET");

        break;
    }
    //
    //  Update our various window positions
    //
    SetWindowPos(bargroup, HWND_TOP, 0, 0, width, height, SWP_NOMOVE | SWP_NOZORDER);
}

VOID
SoftPCI_DlgOnCommand(
    IN HWND Wnd,
    IN INT ControlID,
    IN HWND ControlWnd,
    IN UINT NotificationCode
    )
{

    SOFTPCI_DEV_TYPE selection = 0;

    switch (ControlID){

    case IDC_DEVTYPE_CB:

        switch (NotificationCode){

        case CBN_SELENDOK:

            selection = SendDlgItemMessage(Wnd,
                                           IDC_DEVTYPE_CB,
                                           CB_GETCURSEL,
                                           (WPARAM) 0,
                                           (LPARAM) 0
                                           );

            SoftPCI_DisplayDlgOptions(selection);

            break;

            default:
                break;
            }

        //
        //  Handle our CheckBoxes
        //

    case IDC_SAVETOREG_XB:
    case IDC_DEFAULTDEV_XB:
    case IDC_MEMENABLE_XB:
    case IDC_IOENABLE_XB:
    case IDC_BUSMSTR_XB:
    case IDC_BAR0_PREF_XB:
    case IDC_BAR0_64BIT_XB:
    case IDC_BAR1_PREF_XB:
    case IDC_BAR1_64BIT_XB:
    case IDC_BAR2_PREF_XB:
    case IDC_BAR2_64BIT_XB:
    case IDC_BAR3_PREF_XB:
    case IDC_BAR3_64BIT_XB:
    case IDC_BAR4_PREF_XB:
    case IDC_BAR4_64BIT_XB:
    case IDC_BAR5_PREF_XB:
    case IDC_POSDECODE_XB:
    case IDC_SUBDECODE_XB:
    case IDC_ATTBTN_XB:
    case IDC_MRL_XB:
        SoftPCI_HandleCheckBox(ControlWnd, ControlID, NotificationCode);
        break;


        //
        //  Handle our TrackBar/Sliders
        //
    case IDC_BAR0_TB:
    case IDC_BAR1_TB:
    case IDC_BAR2_TB:
    case IDC_BAR3_TB:
    case IDC_BAR4_TB:
    case IDC_BAR5_TB:
    case IDC_BRIDGEMEM_TB:
    case IDC_BRIDGEIO_TB:

        break;

        //
        //  Handle the Radio Buttons
        //
    case IDC_BAR0IO_RB:
    case IDC_BAR0MEM_RB:
    case IDC_BAR1IO_RB:
    case IDC_BAR1MEM_RB:
    case IDC_BAR2IO_RB:
    case IDC_BAR2MEM_RB:
    case IDC_BAR3IO_RB:
    case IDC_BAR3MEM_RB:
    case IDC_BAR4IO_RB:
    case IDC_BAR4MEM_RB:
    case IDC_BAR5IO_RB:
    case IDC_BAR5MEM_RB:
            SoftPCI_HandleRadioButton(ControlWnd, ControlID, NotificationCode);
        break;

    case IDC_SLOTLABELUP_RB:
        g_HPSInitDesc->UpDown = 1;
        break;
    case IDC_SLOTLABELDN_RB:
        g_HPSInitDesc->UpDown = 0;
        break;
        //
        //  Handle our Edit boxes (attached to our spinners)
        //
    case IDC_33CONV_EB:
    case IDC_66CONV_EB:
    case IDC_66PCIX_EB:
    case IDC_100PCIX_EB:
    case IDC_133PCIX_EB:
    case IDC_ALLSLOTS_EB:
    case IDC_1STDEVSEL_EB:
    case IDC_1STSLOTLABEL_EB:

        if (g_HPSInitDesc && (NotificationCode == EN_CHANGE)) {

            //
            //  ISSUE: This should probably be done some other way as this
            //  makes us dependant on the numbering in resource.h
            //
            SoftPCI_HandleSpinnerControl(GetDlgItem(g_NewDevDlg, ControlID+1), SB_ENDSCROLL, 0);
        }

        break;

    case IDC_INSTALL_BUTTON:
        //
        //  Add code to vaildate selection and install new device.
        //
        if (NotificationCode == BN_CLICKED) {

            SoftPCI_HandleDlgInstallDevice(Wnd);

            PostMessage(Wnd, WM_CLOSE, 0, 0);
        }
        break;

    case IDC_CANCEL_BUTTON:

        if (NotificationCode == BN_CLICKED) {
            //
            //  User wants to Cancel creation of new device
            //
            PostMessage(Wnd, WM_CLOSE, 0, 0);
        }

        break;

    default:
        break;

    }

}

VOID
SoftPCI_HandleCheckBox(
    IN HWND Wnd,
    IN INT ControlID,
    IN UINT NotificationCode
    )
{

    HWND control;
    BOOL isChecked;
    ULONG barIndex = 0;

    isChecked = (BOOL)IsDlgButtonChecked(g_NewDevDlg, ControlID);

    if (!SoftPCI_GetAssociatedBarControl(ControlID, &barIndex)){
        //
        //  Not sure what I should do here...
        //
    }

    if (NotificationCode == BN_CLICKED) {

        switch (ControlID) {

            case IDC_SAVETOREG_XB:
    
                //
                //  ISSUE: Add code here to save device selection to registry.
                //
                MessageBox(NULL, L"This is still under developement...", L"NOT IMPLEMENTED YET", MB_OK | MB_ICONEXCLAMATION);
    
                SoftPCI_UnCheckDlgBox(Wnd);
                SoftPCI_DisableWindow(Wnd);
                break;
    
            case IDC_DEFAULTDEV_XB:
    
                MessageBox(NULL, L"This is still under developement...", L"NOT FULLY IMPLEMENTED YET", MB_OK | MB_ICONEXCLAMATION);
    
                SoftPCI_CheckDlgBox(Wnd);
    
                break;

            //
            //  Now deal with our Command Register
            //
            case IDC_MEMENABLE_XB:

                if (isChecked) {
                    g_NewDevice->Config.Current.Command |= PCI_ENABLE_MEMORY_SPACE;
                }else{
                    g_NewDevice->Config.Current.Command &= ~PCI_ENABLE_MEMORY_SPACE;
                }
                break;

            case IDC_IOENABLE_XB:

                if (isChecked) {
                    g_NewDevice->Config.Current.Command |= PCI_ENABLE_IO_SPACE;
                }else{
                    g_NewDevice->Config.Current.Command &= ~PCI_ENABLE_IO_SPACE;
                }
                break;

            case IDC_BUSMSTR_XB:
                if (isChecked) {
                    g_NewDevice->Config.Current.Command |= PCI_ENABLE_BUS_MASTER;
                }else{
                    g_NewDevice->Config.Current.Command &= ~PCI_ENABLE_BUS_MASTER;
                }
                break;

            case IDC_BAR0_PREF_XB:
            case IDC_BAR1_PREF_XB:
            case IDC_BAR2_PREF_XB:
            case IDC_BAR3_PREF_XB:
            case IDC_BAR4_PREF_XB:
            case IDC_BAR5_PREF_XB:

                if (isChecked) {
                    BarControl[barIndex].Bar |= PCI_ADDRESS_MEMORY_PREFETCHABLE;
                    g_NewDevice->Config.Mask.u.type0.BaseAddresses[barIndex] |= PCI_ADDRESS_MEMORY_PREFETCHABLE;
                }else{
                    BarControl[barIndex].Bar &= ~PCI_ADDRESS_MEMORY_PREFETCHABLE;
                    g_NewDevice->Config.Mask.u.type0.BaseAddresses[barIndex] &= ~PCI_ADDRESS_MEMORY_PREFETCHABLE;
                }
    
                //SendMessage(g_NewDevDlg, WM_HSCROLL, (WPARAM)SB_THUMBPOSITION, (LPARAM)Wnd);
    
                break;

            case IDC_BAR0_64BIT_XB:
            case IDC_BAR1_64BIT_XB:
            case IDC_BAR2_64BIT_XB:
            case IDC_BAR3_64BIT_XB:
            case IDC_BAR4_64BIT_XB:

                SoftPCI_ResetLowerBars(barIndex);
    
                if (isChecked) {
    
                    //
                    //  Disable the next BAR
                    //
                    control = GetDlgItem(g_NewDevDlg, BarControl[barIndex+1].mrb);
                    SoftPCI_UnCheckDlgBox(control);
                    SoftPCI_DisableWindow(control);
    
                    control = GetDlgItem(g_NewDevDlg, BarControl[barIndex+1].irb);
                    SoftPCI_UnCheckDlgBox(control);
                    SoftPCI_DisableWindow(control);
    
                    control = GetDlgItem(g_NewDevDlg, BarControl[barIndex+1].pref);
                    SoftPCI_UnCheckDlgBox(control);
                    SoftPCI_DisableWindow(control);
    
                    control = GetDlgItem(g_NewDevDlg, BarControl[barIndex+1].bit64);
                    SoftPCI_UnCheckDlgBox(control);
                    SoftPCI_DisableWindow(control);
    
                    control = GetDlgItem(g_NewDevDlg, BarControl[barIndex+1].tb);
                    SoftPCI_ResetTrackBar(control);
                    SoftPCI_DisableWindow(control);
    
                    control = GetDlgItem(g_NewDevDlg, BarControl[barIndex+1].tx);
                    SoftPCI_DisableWindow(control);
    
                    BarControl[barIndex].Bar |= PCI_TYPE_64BIT;
    
                }else{
    
                    //
                    //  Enable next BAR
                    //
                    control = GetDlgItem(g_NewDevDlg, BarControl[barIndex+1].mrb);
                    SoftPCI_UnCheckDlgBox(control);
                    SoftPCI_EnableWindow(control);
    
                    control = GetDlgItem(g_NewDevDlg, BarControl[barIndex+1].irb);
                    SoftPCI_UnCheckDlgBox(control);
                    SoftPCI_EnableWindow(control);
    
                    BarControl[barIndex].Bar &= ~PCI_TYPE_64BIT;
    
                }
    
                SoftPCI_InitializeBar(barIndex);
    
                break;

            case IDC_ATTBTN_XB:
            case IDC_MRL_XB:

                if (isChecked) {
                    g_HPSInitDesc->MRLSensorsImplemented = 1;
                    g_HPSInitDesc->AttentionButtonImplemented = 1;
    
                }else{
                    g_HPSInitDesc->MRLSensorsImplemented = 0;
                    g_HPSInitDesc->AttentionButtonImplemented = 0;
                }
    
                break;

            case IDC_POSDECODE_XB:
            case IDC_SUBDECODE_XB:
                
                SOFTPCI_ASSERT(IS_BRIDGE(g_NewDevice));
                if (isChecked) {

                    g_NewDevice->Config.Current.ProgIf = 0x1;
                    g_NewDevice->Config.Mask.ProgIf = 0x1;

                }else{

                    g_NewDevice->Config.Current.ProgIf = 0;
                    g_NewDevice->Config.Mask.ProgIf = 0;

                }
            break;

        }
    }
}


VOID
SoftPCI_HandleDlgInstallDevice(
    IN HWND Wnd
    )
{

    BOOL defaultDev = FALSE;
    SOFTPCI_DEV_TYPE selection = 0;

    SOFTPCI_ASSERTMSG("Attempting to install a NULL device!\n\nHave BrandonA check this out!!",
                      (g_NewDevice != NULL));

    if (!g_NewDevice){
        return;
    }

    //
    // If we're inserting in a hotplug slot, store the device away
    // in hpsim and return without telling softpci.sys about it.
    //
    if (g_ParentPdn->Flags & SOFTPCI_HOTPLUG_SLOT) {

        g_NewDevice->Slot.Device = g_ParentPdn->Slot.Device;

        SoftPCI_AddHotplugDevice(g_ParentPdn->Parent,
                                 g_NewDevice
                                 );
        SoftPCI_CreateTreeView();
        return;
    }

    switch (g_NewDevice->DevType) {
    case TYPE_CARDBUS_DEVICE:
    case TYPE_CARDBUS_BRIDGE:

        MessageBox(Wnd, L"This device type has not been implemented fully!",
                   L"NOT IMPLEMENTED YET", MB_OK | MB_ICONEXCLAMATION);

        return;
    }

#if DBG
    if ((IS_BRIDGE(g_NewDevice)) &&
        ((g_NewDevice->Config.Mask.u.type1.PrimaryBus == 0) ||
         (g_NewDevice->Config.Mask.u.type1.SecondaryBus == 0) ||
         (g_NewDevice->Config.Mask.u.type1.SubordinateBus == 0))){

        SOFTPCI_ASSERTMSG("A bus number config mask is zero!",
                          ((g_NewDevice->Config.Mask.u.type1.PrimaryBus != 0) ||
                           (g_NewDevice->Config.Mask.u.type1.SecondaryBus != 0) ||
                           (g_NewDevice->Config.Mask.u.type1.SubordinateBus != 0)));
    return;
    }
#endif


    defaultDev = IsDlgButtonChecked(Wnd , IDC_DEFAULTDEV_XB);

    if (!SoftPCI_CreateDevice(g_NewDevice, g_PossibleDeviceNums, FALSE)){
        MessageBox(Wnd, L"Failed to install specified SoftPCI device.....", L"ERROR", MB_OK);
    }

}

VOID
SoftPCI_HandleRadioButton(
    IN HWND     Wnd,
    IN INT      ControlID,
    IN UINT     NotificationCode
    )
{


    HWND control;
    ULONG i = 0;

    if (!SoftPCI_GetAssociatedBarControl(ControlID, &i)){
        //
        //  Not sure what I should do here...
        //
        SOFTPCI_ASSERTMSG("SoftPCI_GetAssociatedBarControl() failed!", FALSE);
    }

    if (NotificationCode == BN_CLICKED) {

        switch (ControlID) {
        case IDC_BAR0IO_RB:
        case IDC_BAR1IO_RB:
        case IDC_BAR2IO_RB:
        case IDC_BAR3IO_RB:
        case IDC_BAR4IO_RB:
        case IDC_BAR5IO_RB:

            control = GetDlgItem(g_NewDevDlg, BarControl[i].tb);
            SoftPCI_EnableWindow(control);

            control = GetDlgItem(g_NewDevDlg, BarControl[i].tx);
            SoftPCI_EnableWindow(control);

            control = GetDlgItem(g_NewDevDlg, BarControl[i].pref);
            SoftPCI_UnCheckDlgBox(control);
            SoftPCI_DisableWindow(control);

            control = GetDlgItem(g_NewDevDlg, BarControl[i].bit64);

            //
            //  Reset the bars below this one if it was
            //  set to 64 bit mem bar
            //
            if (IsDlgButtonChecked(g_NewDevDlg, BarControl[i].bit64)) {
                SoftPCI_ResetLowerBars(i);
            }
            SoftPCI_UnCheckDlgBox(control);
            SoftPCI_DisableWindow(control);

            //
            //  Initialize BAR
            //
            BarControl[i].Bar |= PCI_ADDRESS_IO_SPACE;

            SoftPCI_InitializeBar(i);

            break;

        case IDC_BAR0MEM_RB:
        case IDC_BAR1MEM_RB:
        case IDC_BAR2MEM_RB:
        case IDC_BAR3MEM_RB:
        case IDC_BAR4MEM_RB:
        case IDC_BAR5MEM_RB:

            //
            //  Initialize BAR
            //
            BarControl[i].Bar &= ~PCI_ADDRESS_IO_SPACE;

            SoftPCI_InitializeBar(i);

            control = GetDlgItem(g_NewDevDlg, BarControl[i].tb);
            SoftPCI_EnableWindow(control);

            control = GetDlgItem(g_NewDevDlg, BarControl[i].tx);
            SoftPCI_EnableWindow(control);

            control = GetDlgItem(g_NewDevDlg, BarControl[i].pref);
            SoftPCI_EnableWindow(control);


            if (g_NewDevice &&
                IS_BRIDGE(g_NewDevice) &&
                ControlID == IDC_BAR1MEM_RB) {
                //
                //  We only have two BARs on a bridge and therefore cannot
                //  allow the second bar to set 64Bit.
                //
                break;

            }

            control = GetDlgItem(g_NewDevDlg, BarControl[i].bit64);
            SoftPCI_EnableWindow(control);

            break;

        }
    }

}

VOID
SoftPCI_HandleTrackBar(
    IN HWND Wnd,
    IN WORD NotificationCode,
    IN WORD CurrentPos
    )
{

    HWND sliderWnd;
    UINT controlID;
    ULONG currentPos = 0;
    WCHAR buffer[MAX_PATH];
    ULONG barIndex = 0, *pbar = NULL, saveBar = 0;
    ULONGLONG bar = 0, barMask = 0, barSize = 0;


    SOFTPCI_ASSERTMSG("Attempting to init a NULL device!\n\nHave BrandonA check this out!!",
                      (g_NewDevice != NULL));

    if (!g_NewDevice){
        return;
    }

    switch (NotificationCode) {
    case SB_ENDSCROLL:
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:

        controlID = GetDlgCtrlID(Wnd);

        if ((controlID == IDC_BRIDGEMEM_TB) || (controlID == IDC_BRIDGEIO_TB)) {
            //
            //  Implement this...
            //
            return;
        }

        if (!SoftPCI_GetAssociatedBarControl(controlID, &barIndex)){
            //
            //  Not sure what I should do here...
            //
        }

        sliderWnd = GetDlgItem(g_NewDevDlg, BarControl[barIndex].tx);

        //
        //  Save our current Bar value so we can restore any important bits after we
        //  mangle it.
        //
        saveBar = BarControl[barIndex].Bar;

        //
        //  Set intial BAR values
        //
        if (BarControl[barIndex].Bar & PCI_ADDRESS_IO_SPACE) {

            bar = PCI_ADDRESS_IO_ADDRESS_MASK;

        }else{

            bar = PCI_ADDRESS_MEMORY_ADDRESS_MASK;
        }

        //
        //  Get the current position of the slider
        //
        currentPos = (ULONG) SoftPCI_GetTrackBarPosition(Wnd);

        //
        //  Fill in the rest of the BAR if we are dealing with 64 bit
        //
        if ((BarControl[barIndex].Bar & PCI_TYPE_64BIT)) {
            pbar = &((ULONG)bar);
            pbar++;
            *pbar = 0xffffffff;
        }

        //
        //  Shift the bar by the sliders returned position
        //
        bar <<= currentPos;
        barMask = bar;
        
        //
        //  Update our Bar Control for this bar
        //
        if (saveBar & PCI_ADDRESS_IO_SPACE) {
            bar &= 0xffff;
            barMask &= 0xffff;
            bar |= PCI_ADDRESS_IO_SPACE;
        
        } else {

            bar |= (saveBar & (PCI_ADDRESS_MEMORY_TYPE_MASK | PCI_ADDRESS_MEMORY_PREFETCHABLE));
        }
        
        if (IS_BRIDGE(g_NewDevice)){

            g_NewDevice->Config.Current.u.type1.BaseAddresses[barIndex] = (ULONG)bar;
            g_NewDevice->Config.Mask.u.type1.BaseAddresses[barIndex] = (ULONG) barMask;

            SOFTPCI_ASSERTMSG("A bus number config mask is zero!",
                               ((g_NewDevice->Config.Mask.u.type1.PrimaryBus != 0) ||
                                (g_NewDevice->Config.Mask.u.type1.SecondaryBus != 0) ||
                                (g_NewDevice->Config.Mask.u.type1.SubordinateBus != 0)));

        }else{
            g_NewDevice->Config.Current.u.type0.BaseAddresses[barIndex] = (ULONG)bar;
            g_NewDevice->Config.Mask.u.type0.BaseAddresses[barIndex] = (ULONG) barMask ;
        }

        GetDlgItem(g_NewDevDlg, BarControl[barIndex].tx);

        //
        //  Update the next bar if we are dealing with 64 bit
        //
        if ((BarControl[barIndex].Bar & PCI_TYPE_64BIT)) {
            g_NewDevice->Config.Mask.u.type0.BaseAddresses[barIndex+1] = (ULONG)(bar >> 32);
        }

        //
        //  Get the size so we can display its current setting
        //
        barSize = SoftPCI_GetLengthFromBar(bar);

        SOFTPCI_ASSERT(barSize != 0);

        //
        //  Update our sliders text field
        //
        SoftPCI_UpdateBarText(buffer, barSize);

        SetWindowText (sliderWnd, buffer);

        break;

    default:
        break;
    }
}

VOID
SoftPCI_HandleSpinnerControl(
    IN HWND Wnd,
    IN WORD NotificationCode,
    IN WORD CurrentPos
    )
{


    SOFTPCI_ASSERTMSG("Attempting to init a NULL device!\n\nHave BrandonA check this out!!",
                      (g_NewDevice != NULL));

    if (!g_NewDevice){
        PostMessage(g_NewDevDlg, WM_CLOSE, 0, 0);
    }

    switch (NotificationCode) {
    case SB_ENDSCROLL:
    case SB_THUMBPOSITION:

        switch (GetDlgCtrlID(Wnd)) {

        case IDC_33CONV_SP:
            g_HPSInitDesc->NumSlots33Conv = (WORD) SoftPCI_GetSpinnerValue(Wnd);
            break;
        case IDC_66CONV_SP:
            g_HPSInitDesc->NumSlots66Conv = (WORD) SoftPCI_GetSpinnerValue(Wnd);
            break;
        case IDC_66PCIX_SP:
            g_HPSInitDesc->NumSlots66PciX = (WORD) SoftPCI_GetSpinnerValue(Wnd);
            break;
        case IDC_100PCIX_SP:
            g_HPSInitDesc->NumSlots100PciX = (WORD) SoftPCI_GetSpinnerValue(Wnd);
            break;
        case IDC_133PCIX_SP:
            g_HPSInitDesc->NumSlots133PciX = (WORD) SoftPCI_GetSpinnerValue(Wnd);
            break;
        case IDC_ALLSLOTS_SP:
            g_HPSInitDesc->NumSlots = (WORD) SoftPCI_GetSpinnerValue(Wnd);
            break;
        case IDC_1STDEVSEL_SP:
            g_HPSInitDesc->FirstDeviceID = (UCHAR) SoftPCI_GetSpinnerValue(Wnd);
            break;
        case IDC_1STSLOTLABEL_SP:
                g_HPSInitDesc->FirstSlotLabelNumber = (UCHAR)SoftPCI_GetSpinnerValue(Wnd);
            break;

        default:
            break;

        }
    }
}

VOID
SoftPCI_InitializeBar(
    IN INT  Bar
    )
{

    HWND control;
    WCHAR buffer[50];
    ULONGLONG bar64 = 0;

    //
    //  Get the track bar associated with this bar
    //
    control = GetDlgItem(g_NewDevDlg, BarControl[Bar].tb);

    if (BarControl[Bar].Bar & PCI_ADDRESS_IO_SPACE) {
        //
        //  IO Bar
        //
        SendMessage(control, TBM_SETRANGE, (WPARAM)TRUE, (LPARAM)MAKELONG(0, 6));
        SendMessage(control, TBM_SETPOS, (WPARAM)TRUE, 0);
        SendMessage(g_NewDevDlg, WM_HSCROLL, (WPARAM)SB_THUMBPOSITION, (LPARAM)control);

    }else{
        //
        //  Mem Bar
        //
        control = GetDlgItem(g_NewDevDlg, BarControl[Bar].tb);

        if (IsDlgButtonChecked(g_NewDevDlg, BarControl[Bar].bit64)) {

            //
            //  Init this as 64 bit bar.  Bit Range 0 - 60
            //
            SendMessage(control, TBM_SETRANGE, (WPARAM)TRUE, (LPARAM)MAKELONG(0, 59));
            SendMessage(control, TBM_SETPOS, (WPARAM)TRUE, 0);
            SendMessage(g_NewDevDlg, WM_HSCROLL, (WPARAM)SB_THUMBPOSITION, (LPARAM)control);

        }else{

            //
            //  Standard 32bit bar.  Bit Range 0 - 28
            //
            SendMessage(control, TBM_SETRANGE, (WPARAM)TRUE, (LPARAM)MAKELONG(0, 27));
            SendMessage(control, TBM_SETPOS, (WPARAM)TRUE, 0);
            SendMessage(g_NewDevDlg, WM_HSCROLL, (WPARAM)SB_THUMBPOSITION, (LPARAM)control);
        }
    }
}


VOID
SoftPCI_InitializeHotPlugControls(
    VOID
    )
{

    INT controlID = IDC_ATTBTN_XB;
    HWND controlWnd;

    while (controlID < LAST_CONTROL_ID) {

        controlWnd = GetDlgItem(g_NewDevDlg, controlID);

        switch (controlID) {
        case IDC_ATTBTN_XB:
        case IDC_MRL_XB:

            SoftPCI_CheckDlgBox(controlWnd);

            g_HPSInitDesc->MRLSensorsImplemented = 1;
            g_HPSInitDesc->AttentionButtonImplemented = 1;
            break;

            //
            //  init our Spinners
            //
        case IDC_33CONV_SP:
        case IDC_66CONV_SP:
        case IDC_66PCIX_SP:
        case IDC_100PCIX_SP:
        case IDC_133PCIX_SP:
        case IDC_ALLSLOTS_SP:
        case IDC_1STDEVSEL_SP:

            SoftPCI_InitSpinnerControl(controlWnd, 0, HPS_MAX_SLOTS, 0);
            
            //if (controlID == IDC_1STDEVSEL_SP) {
            //    SendMessage(GetDlgItem(g_NewDevDlg, controlID), UDM_SETBASE, (WPARAM) 16, 0);
            //}
            break;

        case IDC_1STSLOTLABEL_SP:
            SoftPCI_InitSpinnerControl(controlWnd, 0, HPS_MAX_SLOT_LABEL, 1);
            break;

        case IDC_SLOTLABELUP_RB:
            SoftPCI_CheckDlgBox(controlWnd);
            g_HPSInitDesc->UpDown = 1;
            break;

        case IDC_33CONV_EB:
        case IDC_66CONV_EB:
        case IDC_66PCIX_EB:
        case IDC_100PCIX_EB:
        case IDC_133PCIX_EB:
        case IDC_ALLSLOTS_EB:
        case IDC_1STDEVSEL_EB:
        case IDC_1STSLOTLABEL_EB:
            break;


        default:
            break;
        }

        controlID++;

    }

}


BOOL
SoftPCI_GetAssociatedBarControl(
    IN INT ControlID,
    OUT INT *Bar
    )
{


    INT i = 0;

    *Bar = 0;

    for (i=0; i < PCI_TYPE0_ADDRESSES; i++ ) {

        if ((ControlID == BarControl[i].tb)    ||
            (ControlID == BarControl[i].mrb)   ||
            (ControlID == BarControl[i].irb)   ||
            (ControlID == BarControl[i].pref)  ||
            (ControlID == BarControl[i].bit64) ||
            (ControlID == BarControl[i].tx)) {

            *Bar = i;

            return TRUE;
        }
    }

    return FALSE;
}

VOID
SoftPCI_ResetLowerBars(
    IN INT  Bar
    )
{

    INT i;
    HWND control;
    WCHAR buffer[10];

    for (i = Bar+1; i < PCI_TYPE0_ADDRESSES; i++ ) {

         control = GetDlgItem(g_NewDevDlg, BarControl[i].mrb);
         SoftPCI_UnCheckDlgBox(control);
         SoftPCI_EnableWindow(control);

         control = GetDlgItem(g_NewDevDlg, BarControl[i].irb);
         SoftPCI_UnCheckDlgBox(control);
         SoftPCI_EnableWindow(control);

         control = GetDlgItem(g_NewDevDlg, BarControl[i].pref);
         SoftPCI_UnCheckDlgBox(control);
         SoftPCI_DisableWindow(control);

         control = GetDlgItem(g_NewDevDlg, BarControl[i].bit64);
         SoftPCI_UnCheckDlgBox(control);
         SoftPCI_DisableWindow(control);

         control = GetDlgItem(g_NewDevDlg, BarControl[i].tb);
         SoftPCI_ResetTrackBar(control);
         SoftPCI_DisableWindow(control);

         control = GetDlgItem(g_NewDevDlg, BarControl[i].tx);
         wsprintf(buffer, L"BAR%d", i);
         SetWindowText (control, buffer);
         SoftPCI_DisableWindow(control);
    }
}

VOID
SoftPCI_ResetNewDevDlg(VOID)
{

    HWND control;
    ULONG i = 0;

    for (i = IDC_SAVETOREG_XB; i < LAST_CONTROL_ID; i++) {

        control = GetDlgItem(g_NewDevDlg, i);

        if (control) {
            SoftPCI_HideWindow(control);
        }
    }

}

VOID
SoftPCI_ShowCommonNewDevDlg(VOID)
{

    HWND control;
    ULONG i = 0;

    for (i = IDC_SAVETOREG_XB; i < IDC_BAR2_TB; i++) {

        control = GetDlgItem(g_NewDevDlg, i);

        if (control) {
            SoftPCI_ShowWindow(control);
        }

    }

    control = GetDlgItem(g_NewDevDlg, IDC_INSTALL_BUTTON);
    SoftPCI_ShowWindow(control);

    control = GetDlgItem(g_NewDevDlg, IDC_CANCEL_BUTTON);
    SoftPCI_ShowWindow(control);

}

VOID
SoftPCI_UpdateBarText(
    IN PWCHAR Buffer,
    IN ULONGLONG BarSize
    )
{

    #define SIZE_1KB    0x400
    #define SIZE_1MB    0x100000
    #define SIZE_1GB    0x40000000
    #define SIZE_1TB    0x10000000000
    #define SIZE_1PB    0x4000000000000
    #define SIZE_1XB    0x1000000000000000

    if (BarSize < SIZE_1KB) {

        wsprintf(Buffer, L"%d Bytes", BarSize);

    }else if ((BarSize >= SIZE_1KB) && (BarSize < SIZE_1MB)) {

        wsprintf(Buffer, L"%d KB", (BarSize / SIZE_1KB));

    }else if ((BarSize >= SIZE_1MB) && (BarSize < SIZE_1GB)) {

        wsprintf(Buffer, L"%d MB", (BarSize / SIZE_1MB));

    }else if ((BarSize >= SIZE_1GB) && (BarSize < SIZE_1TB)) {

        wsprintf(Buffer, L"%d GB", (BarSize / SIZE_1GB));

    }else if ((BarSize >= SIZE_1TB) && (BarSize < SIZE_1PB)) {

        wsprintf(Buffer, L"%d TB", (BarSize / SIZE_1TB));

    }else if ((BarSize >= SIZE_1PB) && (BarSize < SIZE_1XB)) {

        wsprintf(Buffer, L"%d PB", (BarSize / SIZE_1PB));

    }else if (BarSize >= SIZE_1XB) {

        wsprintf(Buffer, L"%d XB", (BarSize / SIZE_1XB));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\parseini.h ===
extern SINGLE_LIST_ENTRY    g_NewDeviceList;

extern WCHAR   g_ScriptError[MAX_PATH];


BOOL
SoftPCI_BuildDeviceInstallList(
    IN PWCHAR ScriptFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\install.h ===
BOOL
SoftPCI_InstallDriver(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\device.c ===
#include "pch.h"

BOOL
SoftPCI_GetSlotPathList(
    IN PPCI_DN Pdn,
    OUT PULONG SlotCount, 
    OUT PLIST_ENTRY SlotPathList
    )
{
    PPCI_DN currentPdn = Pdn;
    PSLOT_PATH_ENTRY currentSlot;

    while (currentPdn) {

        currentSlot = calloc(1, sizeof(SLOT_PATH_ENTRY));
        if (currentSlot == NULL) {
            return FALSE;
        }
        currentSlot->Slot.AsUSHORT = currentPdn->Slot.AsUSHORT;
        InsertHeadList(SlotPathList, &currentSlot->ListEntry);
        (*SlotCount)++;
        currentPdn = currentPdn->Parent;
    }
    return TRUE;
}

VOID
SoftPCI_DestroySlotPathList(
    PLIST_ENTRY SlotPathList
    )
{

    PLIST_ENTRY listEntry;
    PLIST_ENTRY nextEntry;
    PSLOT_PATH_ENTRY currentSlotEntry;

    listEntry = SlotPathList->Flink;
    while (listEntry != SlotPathList) {

        nextEntry = listEntry->Flink;
        currentSlotEntry = CONTAINING_RECORD(listEntry, 
                                             SLOT_PATH_ENTRY, 
                                             ListEntry
                                             );
        free(currentSlotEntry);
        listEntry = nextEntry;
    }

    InitializeListHead(SlotPathList);
}

BOOL
SoftPCI_GetDevicePathList(
    IN PPCI_DN Pdn,
    OUT PLIST_ENTRY DevicePathList
    )
{

    PPCI_DN currentPdn = Pdn;

    while (currentPdn) {
        InsertHeadList(DevicePathList, &currentPdn->ListEntry);
        currentPdn = currentPdn->Parent;
    }
    return TRUE;
}

PWCHAR
SoftPCI_GetPciPathFromDn(
    IN PPCI_DN Pdn
    )
{

    PWCHAR pciPath;
    WCHAR currentSlot[25];
    ULONG pathCount, bufferSize;
    PSLOT_PATH_ENTRY currentSlotEntry;
    LIST_ENTRY slotList;
    PLIST_ENTRY listEntry = NULL;
    
    InitializeListHead(&slotList);

    //
    //  First figure out how many parents we have and tag them
    //
    pathCount = 0;
    if (!SoftPCI_GetSlotPathList(Pdn, &pathCount, &slotList)){
        return NULL;
    }
    
    //
    //  Add in the size of each slot path + size for each "\" and 
    //  one NULL terminator
    //
    bufferSize = (wcslen(L"XXXX") * pathCount) + pathCount + 1;;
    
    //
    //  Now convert it to WCHARs
    //
    bufferSize *= sizeof(WCHAR);
    
    //
    //  Now allocate our path
    //
    pciPath = (PWCHAR) calloc(1, bufferSize);

    if (pciPath == NULL) {
        return NULL;
    }
    
    //
    //  We now have a list that starts with our root. Build out pcipath
    //
    for (listEntry = slotList.Flink;
         listEntry != &slotList;
         listEntry = listEntry->Flink) {

        currentSlotEntry = CONTAINING_RECORD(listEntry, 
                                             SLOT_PATH_ENTRY, 
                                             ListEntry
                                             );

        wsprintf(currentSlot, L"%04x", currentSlotEntry->Slot.AsUSHORT);

#if 0
{
        USHORT testValue = 0;
        testValue = SoftPCIStringToUSHORT(currentSlot);
        SoftPCI_Debug(SoftPciAlways, L"testValue = %04x\n", testValue);
}
#endif

        wcscat(pciPath, currentSlot);

        if (listEntry->Flink != &slotList) {
            wcscat(pciPath, L"\\");
        }
    }

    SoftPCI_DestroySlotPathList(&slotList);

    return pciPath;

}


VOID
SoftPCI_EnumerateDevices(
    IN PPCI_TREE PciTree,
    IN PPCI_DN *Pdn,
    IN DEVNODE Dn,
    IN PPCI_DN Parent
    )
{

    PPCI_DN pdn = NULL;
    DEVNODE dnNew = Dn;
    BOOL isValid = FALSE;
    BOOL skipChildEnum;
    HPS_HWINIT_DESCRIPTOR hpData;

    isValid = SoftPCI_IsDevnodePCIRoot(Dn, TRUE);
    skipChildEnum = FALSE;

    if (isValid) {

        SoftPCI_Debug(SoftPciDevice, L"SoftPCI_EnumerateDevices() - Found valid PCI Device!\n");

        pdn = (PPCI_DN) calloc(1, sizeof(PCI_DN));
        if (!pdn) return;
        *Pdn = pdn;
        pdn->PciTree = PciTree;
        pdn->Parent = Parent;
        pdn->DevNode = Dn;
        SoftPCI_CompletePciDevNode(pdn);

        //
        // We have special enumeration for hotplug bridges.
        // See if this device supports this special enumeration.  If this device
        // doesn't support the required WMI goop to do this, it'll return FALSE
        // and we will fall back to the default enumeration mechanism.
        //
        skipChildEnum = SoftPCI_EnumerateHotplugDevices(PciTree,
                                                        pdn
                                                        );
    }

    if (!skipChildEnum) {

        if ((CM_Get_Child(&dnNew, Dn, 0) == CR_SUCCESS)){

            //
            //  Get the next child
            //
            SoftPCI_EnumerateDevices(PciTree,
                                     (isValid ? &(pdn->Child) : Pdn),
                                     dnNew,
                                     pdn
                                     );
        }
    }

    if ((CM_Get_Sibling(&dnNew, Dn, 0) == CR_SUCCESS)){

        //
        //  Get the next sibling
        //
        SoftPCI_EnumerateDevices(PciTree,
                                 (isValid ? &(pdn->Sibling) : Pdn),
                                 dnNew,
                                 Parent
                                 );
    }
}

VOID
SoftPCI_CompletePciDevNode(
    IN PPCI_DN Pdn
    )
{

    ULONG bytesReturned = 0;
    DEVNODE childNode = 0;
    PSOFTPCI_DEVICE device = NULL;
    SP_DEVINFO_DATA devInfoData;

    Pdn->Child = NULL;
    Pdn->Sibling = NULL;

    if ((CM_Get_Device_ID(Pdn->DevNode, Pdn->DevId, MAX_PATH, 0)) != CR_SUCCESS) {

        wcscpy(Pdn->DevId, L"Failed to get DevID...");
        SoftPCI_Debug(SoftPciDevice, L"CompletePciDevNode - Failed to retrieve DevID\n");
    }

    SoftPCI_Debug(SoftPciDevice, L"CompletePciDevNode - DevID - %s\n", Pdn->DevId);

    SOFTPCI_ASSERT(Pdn->PciTree->DevInfoSet != INVALID_HANDLE_VALUE);
    
    devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    if (SetupDiOpenDeviceInfo(Pdn->PciTree->DevInfoSet, Pdn->DevId, NULL, 0, &devInfoData)){
        
        if (Pdn->DevNode == devInfoData.DevInst){
            Pdn->DevInfoData = devInfoData;
        }
    }
    
    SoftPCI_AllocWmiInstanceName(Pdn->WmiId,
                                 Pdn->DevId
                                 );
    
    SoftPCI_Debug(SoftPciHotPlug, L"CompletePciDevNode - WmiID - %s\n", Pdn->WmiId);

    //
    //  Now we need to see if this is a root bus as getting its bus number
    //  is not quite as easy as a PCI device
    //
    if (SoftPCI_IsDevnodePCIRoot(Pdn->DevNode, FALSE)) {

        if (!SoftPCI_GetPciRootBusNumber(Pdn->DevNode, &Pdn->Bus)){
            //
            //  Not sure what I should do in this case.....should probably disable this device (if a bridge)
            //  from allowing devices behind it.....
            //
        }

        //
        //  Setup our root Slot info
        //
        Pdn->Slot.Device = 0xff;
        Pdn->Slot.Function = (UCHAR)Pdn->Bus;

    }else{

        if (!SoftPCI_GetBusDevFuncFromDevnode(Pdn->DevNode, &Pdn->Bus, &Pdn->Slot)) {
            //
            //  Not sure what I should do in this case.....should probably disable this device (if a bridge)
            //  from allowing devices behind it.....
            //
        }

    }

    if (!SoftPCI_GetFriendlyNameFromDevNode(Pdn->DevNode, Pdn->FriendlyName)) {

        //
        //  Not sure what I should do in this case.....
        //
        wcscpy(Pdn->FriendlyName, L"Failed to get friendly name...");
    }


    if ((Pdn->Parent) &&
        ((Pdn->Parent->Bus == Pdn->Bus) &&
         (Pdn->Parent->Slot.AsUSHORT == Pdn->Slot.AsUSHORT))){
        //
        //  Our parent (probably a root bus) matches us. We dont want dupes.
        //
        return;
    }

    if (g_DriverHandle){

        //
        //  Grab any softPCI device information there may be
        //
        device = (PSOFTPCI_DEVICE) calloc(1, sizeof(SOFTPCI_DEVICE));

        if (device) {

            device->Bus = (UCHAR)Pdn->Bus;
            device->Slot.AsUSHORT = Pdn->Slot.AsUSHORT;

            if (!DeviceIoControl(g_DriverHandle,
                                 (DWORD) SOFTPCI_IOCTL_GET_DEVICE,
                                 device,
                                 sizeof(SOFTPCI_DEVICE),
                                 device,
                                 sizeof(SOFTPCI_DEVICE),
                                 &bytesReturned,
                                 NULL
                                 )){

                SoftPCI_Debug(SoftPciDeviceVerbose, 
                              L"CompletePciDevNode - Failed to get SoftPCI device info (bus %02x dev %02x func %02x)\n",
                              Pdn->Bus, Pdn->Slot.Device, Pdn->Slot.Function);

                free(device);

            }else{
                Pdn->SoftDev = device;
            }
        }

    }

}

BOOL
SoftPCI_EnumerateHotplugDevices(
    IN PPCI_TREE PciTree,
    IN PPCI_DN Pdn
    )
{
    HPS_HWINIT_DESCRIPTOR hpData;
    PPCI_DN deviceTable[PCI_MAX_DEVICES];
    PPCI_DN newPdn, currentPdn, slotHeadPdn;
    DEVNODE devNode, childDn;
    UCHAR slotNum, devNum;
    ULONG slotLabelNum, slotsMask;
    CONFIGRET configRet;
    BOOL status, skipChildEnum;
    PSOFTPCI_DEVICE softDevice;

    if (!SoftPCI_SetEventContext(Pdn)) {
        return FALSE;
    }

    if (!SoftPCI_GetHotplugData(Pdn,
                                &hpData
                                )) {

        return FALSE;
    }

    //
    // This device is actually a hotplug controller.  Mark it as such for the future.
    //
    Pdn->Flags |= SOFTPCI_HOTPLUG_CONTROLLER;
    SoftPCI_Debug(SoftPciDevice, L"SoftPCI_EnumerateDevices() - Found HOTPLUG PCI Bridge!\n");

    //SoftPCI_CompleteCommand(Pdn);

    currentPdn = NULL;
    slotLabelNum = hpData.FirstSlotLabelNumber;
    RtlZeroMemory(deviceTable,sizeof(deviceTable));

    //
    // First create slot objects for each slot and add them
    // to the tree.
    //
    for (slotNum=0; slotNum < hpData.NumSlots; slotNum++) {

        devNum = slotNum + hpData.FirstDeviceID;

        newPdn = (PPCI_DN) calloc(1, sizeof(PCI_DN));
        if (!newPdn) {
            break;
        }

        //
        // For slots, we co-opt the Function field to be
        // the slot number.
        //
        newPdn->Slot.Device = devNum;
        newPdn->Slot.Function = slotNum;

        newPdn->PciTree = PciTree;
        newPdn->Parent = Pdn;
        newPdn->Flags = SOFTPCI_HOTPLUG_SLOT;
        
        if (currentPdn) {
            currentPdn->Sibling = newPdn;
        } else {
            slotHeadPdn = newPdn;
        }

        wsprintf(newPdn->FriendlyName,L"Slot %d",slotLabelNum);
        RtlZeroMemory(newPdn->WmiId,MAX_PATH);

        SOFTPCI_ASSERT(devNum < PCI_MAX_DEVICES);

        //
        // Add this slot to the table that maps slot objects to the
        // PCI device numbers that they correspond to.
        //
        if (devNum < PCI_MAX_DEVICES) {

            deviceTable[devNum] = newPdn;

        } else {

            free(newPdn);
            break;
        }

        currentPdn = newPdn;
        if (hpData.UpDown) {
            slotLabelNum++;

        } else {
            slotLabelNum--;
        }
    }

    //
    // Now enumerate all the devices and put them underneath the
    // appropriate slots.
    //
    configRet = CM_Get_Child(&devNode, Pdn->DevNode, 0);

    while (configRet == CR_SUCCESS){

        //
        // The controller has a child.  Create the PCI_DN for it.
        //
        newPdn = (PPCI_DN) calloc(1, sizeof(PCI_DN));
        if (!newPdn) {
            break;
        }

        newPdn->PciTree = PciTree;
        newPdn->DevNode = devNode;
        SoftPCI_CompletePciDevNode(newPdn);

        SOFTPCI_ASSERT(newPdn->Slot.Device < PCI_MAX_DEVICES);
        if (newPdn->Slot.Device < PCI_MAX_DEVICES) {
            //
            // Add this PCI_DN to the tree underneath the
            // slot object for the appropriate slot.
            // If there is no corresponding slot, add it
            // directly underneat the controller.
            //
            if (deviceTable[newPdn->Slot.Device]) {
                SoftPCI_AddChild(deviceTable[newPdn->Slot.Device],
                                 newPdn
                                 );
            } else {
                SoftPCI_AddChild(Pdn,
                                 newPdn
                                 );
            }

            skipChildEnum = SoftPCI_EnumerateHotplugDevices(PciTree,
                                                            newPdn
                                                            );
            //
            // We've done the hotplug specific enumeration.
            // If there are more devices underneath this one
            // (there is a bridge in the hotplug slot), return
            // to the default enumeration
            //
            if (!skipChildEnum &&
                (CM_Get_Child(&childDn,devNode,0) == CR_SUCCESS)) {
                SoftPCI_EnumerateDevices(PciTree,
                                         &newPdn->Child,
                                         childDn,
                                         newPdn
                                         );
            }
        } else {

            free(newPdn);
        }

        //
        // After enumerating the first child of the controller, get the
        // rest of the devices by getting the first child's sibling.
        //
        configRet = CM_Get_Sibling(&devNode, devNode, 0);
    }

    //
    // Next run through all the slots again and if they don't have real
    // children, call GetDevice to get the unenumerated device from hpsim.
    //
    for (slotNum=0; slotNum < hpData.NumSlots; slotNum++) {
        devNum = slotNum + hpData.FirstDeviceID;
        if (deviceTable[devNum] && !deviceTable[devNum]->Child) {

            softDevice = (PSOFTPCI_DEVICE)malloc(sizeof(SOFTPCI_DEVICE));
            if (!softDevice) {

                break;
            }
            status = SoftPCI_GetHotplugDevice(Pdn,
                                              slotNum,
                                              softDevice
                                              );
            if (status == FALSE) {

                SoftPCI_Debug(SoftPciHotPlug, L"EnumerateHotplugDevices - Couldn't get device for slot %d\n", slotNum);
                free(softDevice);
                continue;
            }

            newPdn = (PPCI_DN) calloc(1, sizeof(PCI_DN));
            if (!newPdn) {
                free(softDevice);
                break;
            }

            newPdn->PciTree = PciTree;
            newPdn->Parent = deviceTable[devNum];
            newPdn->Bus = newPdn->Parent->Bus;
            newPdn->Slot.AsUSHORT = softDevice->Slot.AsUSHORT;
            newPdn->SoftDev = softDevice;
            newPdn->Flags = SOFTPCI_UNENUMERATED_DEVICE;

            wcscpy(newPdn->FriendlyName, L"Unpowered Device");
            RtlZeroMemory(newPdn->WmiId,MAX_PATH);

            deviceTable[devNum]->Child = newPdn;
        }
    }

    //
    // Now add the slot objects to the tree, along with whatever's been added
    // beneath them.  Do this now so that they show up at the end of the list
    // rather than at the top.
    //
    currentPdn = Pdn->Child;
    
    if (currentPdn == NULL) {
        Pdn->Child = slotHeadPdn;

    } else {
        while (currentPdn->Sibling != NULL) {
            currentPdn = currentPdn->Sibling;    
        }
        currentPdn->Sibling = slotHeadPdn;
    }
    
    return TRUE;
}

VOID
SoftPCI_BringHotplugDeviceOnline(
    IN PPCI_DN PciDn,
    IN UCHAR SlotNumber
    )
{
    BOOL status;
    SOFTPCI_DEVICE softDevice;
    
    SoftPCI_Debug(SoftPciHotPlug, L"Bringing slot %d online\n", SlotNumber);
    
    status = SoftPCI_GetHotplugDevice(PciDn,
                                      SlotNumber,
                                      &softDevice
                                      );
    if (status == FALSE) {

        SoftPCI_Debug(SoftPciHotPlug, L"Couldn't get device for slot\n");
        return;
    }

    if (!SoftPCI_CreateDevice(&softDevice,
                              1<<softDevice.Slot.Device,
                              FALSE
                              )){
        SoftPCI_Debug(SoftPciHotPlug, L"Failed to bring device at slot %d online\n", SlotNumber);
    }
}

VOID
SoftPCI_TakeHotplugDeviceOffline(
    IN PPCI_DN PciDn,
    IN UCHAR SlotNumber
    )
{
    SOFTPCI_DEVICE softDevice;
    BOOL status;
    
    SoftPCI_Debug(SoftPciHotPlug, L"Taking slot %d offline\n", SlotNumber);

    status = SoftPCI_GetHotplugDevice(PciDn,
                                      SlotNumber,
                                      &softDevice
                                      );
    if (status == FALSE) {
        SoftPCI_Debug(SoftPciHotPlug, L"Couldn't get device for slot\n");
        return;
    }

    status = SoftPCI_DeleteDevice(&softDevice);
    if (status == FALSE) {
        SoftPCI_Debug(SoftPciHotPlug, L"Couldn't delete device\n");
        
    } else {
        SoftPCI_Debug(SoftPciHotPlug, L"Slot %d offline\n", SlotNumber);
    }
}

VOID
SoftPCI_AddChild(
    IN PPCI_DN Parent,
    IN PPCI_DN Child
    )
{
    PPCI_DN sibling;

    Child->Parent = Parent;

    if (Parent->Child == NULL) {
        Parent->Child = Child;

    } else {

        sibling = Parent->Child;
        while (sibling->Sibling != NULL) {
            sibling = sibling->Sibling;
        }
        sibling->Sibling = Child;
    }
}

BOOL
SoftPCI_IsBridgeDevice(
    IN PPCI_DN Pdn
    )
{
    //  ISSUE:  BrandonA - This should probably just be a macro
    if ((Pdn->SoftDev != NULL) &&
        (IS_BRIDGE(Pdn->SoftDev))) {
        return TRUE;
    }

    return FALSE;

}


BOOL
SoftPCI_IsSoftPCIDevice(
    IN PPCI_DN Pdn
    )
{
    //  ISSUE:  BrandonA - This should probably just be a macro
    if ((Pdn->SoftDev) &&
        !(Pdn->SoftDev->Config.PlaceHolder)) {
        return TRUE;
    }

    return FALSE;

}

BOOL
SoftPCI_IsDevnodePCIRoot(
    IN DEVNODE Dn,
    IN BOOL ValidateAll
    )
{

    WCHAR devId[MAX_PATH];
    ULONG size = 0;
    PWCHAR p = NULL, idList = NULL, id = NULL;

    if ((CM_Get_Device_ID(Dn, devId, MAX_PATH, 0))==CR_SUCCESS){

        if (ValidateAll &&
            ((p = wcsstr(devId, L"PCI\\VEN")) != NULL)){
            return TRUE;
        }

        if ((p = wcsstr(devId, L"PNP0A03")) != NULL){
            return TRUE;
        }
    }

    //
    //  Check our compat ids as well
    //
    if ((CM_Get_DevNode_Registry_Property(Dn, CM_DRP_COMPATIBLEIDS, NULL, NULL, &size, 0)) == CR_BUFFER_SMALL){

        idList = (PWCHAR) calloc(1, size);

        if (!idList) {
            return FALSE;
        }

        if ((CM_Get_DevNode_Registry_Property(Dn,
                                              CM_DRP_COMPATIBLEIDS,
                                              NULL,
                                              idList,
                                              &size,
                                              0)) == CR_SUCCESS){


            for (id = idList; *id; id+=wcslen(id)+1) {

                if ((p = wcsstr(id, L"PNP0A03")) != NULL){
                    free(idList);
                    return TRUE;
                }
            }
        }
    }

    return FALSE;

}

BOOL
SoftPCI_UpdateDeviceFriendlyName(
    IN DEVNODE DeviceNode,
    IN PWCHAR NewName
    )

{

    WCHAR friendlyName[MAX_PATH];
    ULONG length = 0;

    //
    //  If we are updating a root bus we append to the current name
    //
    if (wcscmp(NewName, SOFTPCI_BUS_DESC) == 0) {

        if (!SoftPCI_GetFriendlyNameFromDevNode(DeviceNode, friendlyName)){
            return FALSE;
        }

        length = (wcslen(friendlyName) + 1) + (wcslen(NewName) + 1);

        //
        //  Make sure there is enough room
        //
        if (length < MAX_PATH) {

            wcscat(friendlyName, NewName);
        }

    }else{

        //
        //  Otherwise, we replace the name entirely
        //
        wcscpy(friendlyName, NewName);

        length = wcslen(friendlyName) + 1;
    }

    length *= sizeof(WCHAR);

    if ((CM_Set_DevNode_Registry_Property(DeviceNode,
                                          CM_DRP_DEVICEDESC,
                                          (PVOID)friendlyName,
                                          length,
                                          0
                                          )) != CR_SUCCESS){
        return FALSE;
    }

    return TRUE;

}



HANDLE
SoftPCI_OpenHandleToDriver(VOID)
{

    HANDLE hFile = NULL;
    BOOL success = TRUE;
    ULONG requiredSize, error;
    HDEVINFO deviceInfoSet;
    SP_DEVICE_INTERFACE_DATA deviceInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetailData;


    deviceInfoSet = SetupDiGetClassDevs((LPGUID)&GUID_SOFTPCI_INTERFACE,
                                        NULL,
                                        NULL,
                                        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
                                        );

    if (deviceInfoSet == INVALID_HANDLE_VALUE) {

        SoftPCI_Debug(SoftPciAlways,
                      L"OpenHandleToDriver() - SetupDiGetClassDevs failed! Error - \"%s\"\n", 
                      SoftPCI_GetLastError());
        return NULL;
    }

    deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    success = SetupDiEnumDeviceInterfaces(deviceInfoSet,
                                          NULL,
                                          (LPGUID)&GUID_SOFTPCI_INTERFACE,
                                          0,
                                          &deviceInterfaceData
                                          );
    if (success) {

        //
        // Call it once to find out how big the buffer needs to be.
        //
        SetupDiGetDeviceInterfaceDetail(deviceInfoSet,
                                        &deviceInterfaceData,
                                        NULL,
                                        0,
                                        &requiredSize,
                                        NULL
                                        );

        //
        // Allocate the required size for the buffer
        // and initialize the buffer.
        //
        deviceInterfaceDetailData = malloc(requiredSize);
        
        if (deviceInterfaceDetailData) {

            deviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

            success = SetupDiGetDeviceInterfaceDetail(deviceInfoSet,
                                                      &deviceInterfaceData,
                                                      deviceInterfaceDetailData,
                                                      requiredSize,
                                                      NULL,
                                                      NULL
                                                      );
            if (success) {

                hFile = CreateFile(deviceInterfaceDetailData->DevicePath,
                                   0,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                   );

                if (hFile == INVALID_HANDLE_VALUE) {

                    SoftPCI_Debug(SoftPciAlways,
                                  L"OpenHandleToDriver() - CreateFile failed! Error - \"%s\"\n", 
                                  SoftPCI_GetLastError());

                    SOFTPCI_ASSERT(FALSE);

                    hFile = NULL;
                }
            } else {

                SoftPCI_Debug(SoftPciAlways,
                                  L"OpenHandleToDriver() - SetupDiGetDeviceInterfaceDetail() failed! Error - \"%s\"\n", 
                                  SoftPCI_GetLastError());

                SOFTPCI_ASSERT(FALSE);
            }

            free(deviceInterfaceDetailData);
        }
    } else {

        SoftPCI_Debug(SoftPciAlways,
                      L"OpenHandleToDriver() - SetupDiEnumDeviceInterfaces() failed! Error - \"%s\"\n", 
                      SoftPCI_GetLastError());
    }

    SetupDiDestroyDeviceInfoList(deviceInfoSet);

    return hFile;
}

VOID
SoftPCI_InstallScriptDevices(
    VOID
    )
{
    ULONG deviceMask;
    PSINGLE_LIST_ENTRY listEntry;
    PSOFTPCI_SCRIPT_DEVICE installDevice;

    if (g_DriverHandle) {

        //
        //  We have a handle to our driver.  Drain our script queue if we have one.
        //
        listEntry = g_NewDeviceList.Next;
        while (listEntry) {
            
            installDevice = NULL;
            installDevice = CONTAINING_RECORD(listEntry, SOFTPCI_SCRIPT_DEVICE, ListEntry);
            listEntry = listEntry->Next;

            deviceMask = (ULONG) -1;
            if (installDevice->SlotSpecified) {
                deviceMask = (1 << installDevice->SoftPciDevice.Slot.Device);
            }

            if (!SoftPCI_CreateDevice(installDevice, 
                                      deviceMask, 
                                      TRUE)){
                SoftPCI_Debug(SoftPciAlways, L"Failed to install scriptdevice");
            }
            
            //
            //  We no longer need this memory so free it
            //
            free(installDevice);
        }
        g_NewDeviceList.Next = NULL;
    }
}

BOOL
SoftPCI_CreateDevice(
    IN PVOID CreateDevice,
    IN ULONG PossibleDeviceMask,
    IN BOOL ScriptDevice
    )
{

    BOOL success = FALSE, status = FALSE;
    ULONG error, bytesReturned, type;
    ULONG newDeviceSize;
    PVOID newDevice;
    PSOFTPCI_SCRIPT_DEVICE scriptDevice;
    PSOFTPCI_SLOT softPciSlot;

    newDevice = CreateDevice;
    newDeviceSize = sizeof(SOFTPCI_DEVICE);
    scriptDevice = NULL;
    softPciSlot = NULL;

    if (ScriptDevice) {

        scriptDevice = (PSOFTPCI_SCRIPT_DEVICE) CreateDevice;
        softPciSlot = &scriptDevice->SoftPciDevice.Slot;
        
        if (scriptDevice->ParentPathLength) {
        
            SOFTPCI_ASSERT(scriptDevice->ParentPath != NULL);
            newDeviceSize = sizeof(SOFTPCI_SCRIPT_DEVICE) + scriptDevice->ParentPathLength;

        }else{

            newDevice = (PVOID)&scriptDevice->SoftPciDevice;
        }

    }else{

        softPciSlot = &((PSOFTPCI_DEVICE)CreateDevice)->Slot;
    }

    softPciSlot->Device = 0;
    bytesReturned = 0;
    while (PossibleDeviceMask != 0) {

        if (PossibleDeviceMask & 0x1) {
            status = DeviceIoControl(g_DriverHandle,
                                     (DWORD) SOFTPCI_IOCTL_CREATE_DEVICE,
                                     newDevice,
                                     newDeviceSize,
                                     &success,
                                     sizeof (BOOLEAN),
                                     &bytesReturned,
                                     NULL
                                     );

            if ((status == TRUE) ||
                (softPciSlot->Device == PCI_MAX_DEVICES)) {
                break;
            }
        }

        softPciSlot->Device++;
        PossibleDeviceMask >>= 1;

    }

    if ((bytesReturned < sizeof(BOOLEAN)) || !status){
          
        if (GetLastError() == ERROR_ACCESS_DENIED) {

              MessageBox(NULL, L"A device exists at the location (slot) specified!", NULL, MB_OK);

          }else{
              
              SoftPCI_Debug(SoftPciAlways, L"CreateDevice - Failed! (%d) - \"%s\"\n", 
                            GetLastError(),
                            SoftPCI_GetLastError());
          }
          return FALSE;
    }

    return TRUE;
}


BOOL
SoftPCI_DeleteDevice(
    IN PSOFTPCI_DEVICE Device
    )
{


    BOOL success, status = TRUE;
    ULONG error, bytesReturned;

    
    SOFTPCI_ASSERT((g_DriverHandle != NULL) &&
                   (g_DriverHandle != INVALID_HANDLE_VALUE));
    
    //
    //  Tell our driver to delete the device.
    //
    status = DeviceIoControl(g_DriverHandle,
                             (DWORD) SOFTPCI_IOCTL_DELETE_DEVICE,
                             Device,
                             sizeof(SOFTPCI_DEVICE),
                             &success,       //ISSUE    do I need a result here?
                             sizeof (BOOLEAN),
                             &bytesReturned,
                             NULL
                             );

    if (!success || !status){

        MessageBox(NULL, L"Failed to delete specified device or one of its children", NULL, MB_OK);
        SoftPCI_Debug(SoftPciAlways, L"DeleteDevice - IOCTL failed! Error - \"%s\"\n", 
                      SoftPCI_GetLastError());
        
        return FALSE;
    }

    return TRUE;

}

VOID
SoftPCI_InitializeDevice(
    IN PSOFTPCI_DEVICE Device,
    IN SOFTPCI_DEV_TYPE Type
    )
{

    PSOFTPCI_CONFIG config;
    PPCI_COMMON_CONFIG commonConfig;

    //
    // Set the type of the device
    //
    Device->DevType = Type;

    config = &Device->Config;
    commonConfig = &config->Current;

    switch (Type) {

        case TYPE_DEVICE:

            commonConfig->VendorID = 0xABCD;
            commonConfig->DeviceID = 0xDCBA;
            //commonConfig->Command = 0;
            commonConfig->Status = 0x0200;
            commonConfig->RevisionID = 0x0;
            //commonConfig->ProgIf = 0x00;
            commonConfig->SubClass = 0x80;
            commonConfig->BaseClass = 0x04;
            commonConfig->CacheLineSize = 0x11;
            commonConfig->LatencyTimer = 0x99;
            commonConfig->HeaderType= 0x80;
            //commonConfig->BIST = 0x0;
            //commonConfig->u.type0.BaseAddresses[0] = 0;
            //commonConfig->u.type0.BaseAddresses[1] = 0;
            //commonConfig->u.type0.BaseAddresses[2] = 0;
            //commonConfig->u.type0.BaseAddresses[3] = 0;
            //commonConfig->u.type0.BaseAddresses[4] = 0;
            //commonConfig->u.type0.BaseAddresses[5] = 0;
            //commonConfig->u.type0.CIS = 0x0;
            commonConfig->u.type0.SubVendorID = 0xABCD;
            commonConfig->u.type0.SubSystemID = 0xDCBA;
            //commonConfig->u.type0.ROMBaseAddress = 0;
            //commonConfig->u.type0.CapabilitiesPtr = 0x0;
            //commonConfig->u.type0.Reserved1[0] = 0x0;
            //commonConfig->u.type0.Reserved1[1] = 0x0;
            //commonConfig->u.type0.Reserved1[2] = 0x0;
            //commonConfig->u.type0.Reserved2 = 0x0;
            //commonConfig->u.type0.InterruptLine = 0xFF;
            //commonConfig->u.type0.InterruptPin = 0;
            //commonConfig->u.type0.MinimumGrant = 0x0;
            //commonConfig->u.type0.MaximumLatency = 0x0;


            //
            //  Now set the Mask
            //
            commonConfig = &config->Mask;

            //commonConfig->VendorID = 0;
            //commonConfig->DeviceID = 0;
            commonConfig->Command = 0x143;
            commonConfig->Status = 0x0200;
            //commonConfig->RevisionID = 0x0;
            //commonConfig->ProgIf = 0x00;
            commonConfig->SubClass = 0x80;
            commonConfig->BaseClass = 0x04;
            commonConfig->CacheLineSize = 0xff;
            commonConfig->LatencyTimer = 0xff;
            //commonConfig->HeaderType= 0x80;
            //commonConfig->BIST = 0x0;
            //commonConfig->u.type0.BaseAddresses[0] = 0;//0xffff0000;
            //commonConfig->u.type0.BaseAddresses[1] = 0;
            //commonConfig->u.type0.BaseAddresses[2] = 0;
            //commonConfig->u.type0.BaseAddresses[3] = 0;
            //commonConfig->u.type0.BaseAddresses[4] = 0;
            //commonConfig->u.type0.BaseAddresses[5] = 0;
            //commonConfig->u.type0.CIS = 0x0;
            //commonConfig->u.type0.SubVendorID = 0xABCD;
            //commonConfig->u.type0.SubSystemID = 0xDCBA;
            //commonConfig->u.type0.ROMBaseAddress = 0;
            //commonConfig->u.type0.CapabilitiesPtr = 0x0;
            //commonConfig->u.type0.Reserved1[0] = 0x0;
            //commonConfig->u.type0.Reserved1[1] = 0x0;
            //commonConfig->u.type0.Reserved1[2] = 0x0;
            //commonConfig->u.type0.Reserved2 = 0x0;
            commonConfig->u.type0.InterruptLine = 0xFF;
            //commonConfig->u.type0.InterruptPin = 0;
            //commonConfig->u.type0.MinimumGrant = 0x0;
            //commonConfig->u.type0.MaximumLatency = 0x0;
            break;

        case TYPE_PCI_BRIDGE:
        case TYPE_HOTPLUG_BRIDGE:

            if (Type == TYPE_PCI_BRIDGE) {
                commonConfig->VendorID = 0xABCD;
                commonConfig->DeviceID = 0xDCBB;

                commonConfig->Status = 0x0400;
            }else{
                commonConfig->VendorID = 0xABCD;
                commonConfig->DeviceID = 0xDCBC;

                commonConfig->Status = 0x0410;

                commonConfig->u.type1.CapabilitiesPtr = 0x40;

                commonConfig->DeviceSpecific[0] = 0xc;  //CapID
                commonConfig->DeviceSpecific[1] = 0x48; //Next Cap

                commonConfig->DeviceSpecific[8] = 0xd;  //CapID for hwinit
                commonConfig->DeviceSpecific[9] = 0;    //Next Cap

            }

            commonConfig->Command = 0x80;

            //commonConfig->RevisionhpsinitOffsetID = 0x0;
            commonConfig->ProgIf = 0x80;
            commonConfig->SubClass = 0x04;
            commonConfig->BaseClass = 0x06;
            commonConfig->CacheLineSize = 0x8;
            //commonConfig->LatencyTimer = 0x00;
            commonConfig->HeaderType= 0x81;
            //commonConfig->BIST = 0x0;
            //commonConfig->u.type1.BaseAddresses[0] = 0;
            //commonConfig->u.type1.BaseAddresses[1] = 0;
            //commonConfig->u.type1.PrimaryBus = 0x0;
            //commonConfig->u.type1.SecondaryBus = 0x0;
            //commonConfig->u.type1.SubordinateBus = 0x0;
            //commonConfig->u.type1.SecondaryLatency = 0;
            //commonConfig->u.type1.CapabilitiesPtr = 0;
            //commonConfig->u.type1.IOBase = 0;
            //commonConfig->u.type1.IOLimit = 0;
            //commonConfig->u.type1.SecondaryStatus = 0x0;
            //commonConfig->u.type1.MemoryBase = 0x0;
            //commonConfig->u.type1.MemoryLimit = 0;
            //commonConfig->u.type1.PrefetchBase = 0;
            //commonConfig->u.type1.MemoryLimit = 0x0;
            //commonConfig->u.type1.PrefetchBaseUpper32 = 0x0;
            //commonConfig->u.type1.IOBaseUpper16 = 0x0;
            //commonConfig->u.type1.IOLimitUpper16 = 0x0;
            //commonConfig->u.type1.CapabilitiesPtr = 0x0;
            //commonConfig->u.type1.Reserved1[0] = 0x0;
            //commonConfig->u.type1.Reserved1[1] = 0x0;
            //commonConfig->u.type1.Reserved1[2] = 0x0;
            //commonConfig->u.type1.ROMBaseAddress = 0x0;
            //commonConfig->u.type1.InterruptLine = 0x0;
            //commonConfig->u.type1.InterruptPin = 0x0;
            //commonConfig->u.type1.BridgeControl = 0x0;


            //
            //  Now set the Mask
            //
            commonConfig = &config->Mask;

            //commonConfig->VendorID = 0x0;
            //commonConfig->DeviceID = 0x0;
            commonConfig->Command = 0xff;
            //commonConfig->Status = 0x0;
            //commonConfig->RevisionID = 0x0;
            //commonConfig->ProgIf = 0x0;
            //commonConfig->SubClass = 0x0;
            //commonConfig->BaseClass = 0x0;
            //commonConfig->CacheLineSize = 0;
            //commonConfig->LatencyTimer = 0;
            //commonConfig->HeaderType= 0;
            //commonConfig->BIST = 0x0;
            //commonConfig->u.type1.BaseAddresses[0] = 0;
            //commonConfig->u.type1.BaseAddresses[1] = 0;
            commonConfig->u.type1.PrimaryBus = 0xff;
            commonConfig->u.type1.SecondaryBus = 0xff;
            commonConfig->u.type1.SubordinateBus = 0xff;
            //commonConfig->u.type1.SecondaryLatency = 0;
            //commonConfig->u.type1.CapabilitiesPtr = 0;
            commonConfig->u.type1.IOBase = 0xf0;
            commonConfig->u.type1.IOLimit = 0xf0;
            //commonConfig->u.type1.SecondaryStatus = 0x0;
            commonConfig->u.type1.MemoryBase = 0xfff0;
            commonConfig->u.type1.MemoryLimit = 0xfff0;
            commonConfig->u.type1.PrefetchBase = 0xfff0;
            commonConfig->u.type1.PrefetchLimit = 0xfff0;
            //commonConfig->u.type1.PrefetchBaseUpper32 = 0xffffffff;
            //commonConfig->u.type1.PrefetchLimitUpper32 = 0xffffffff;
            //commonConfig->u.type1.IOBaseUpper16 = 0;
            //commonConfig->u.type1.IOLimitUpper16 = 0;
            //commonConfig->u.type1.CapabilitiesPtr = 0x0;
            //commonConfig->u.type1.Reserved1[0] = 0x0;
            //commonConfig->u.type1.Reserved1[1] = 0x0;
            //commonConfig->u.type1.Reserved1[2] = 0x0;
            //commonConfig->u.type1.ROMBaseAddress = 0x0;
            //commonConfig->u.type1.InterruptLine = 0x0;
            //commonConfig->u.type1.InterruptPin = 0x0;
            //commonConfig->u.type1.BridgeControl = 0x0;

            //
            // For a hotplug bridge, the pending byte is not a read/write
            // register, but it has to be in softpci because the hotplug
            // simulator needs to write to it.
            //
            if (Type == TYPE_HOTPLUG_BRIDGE) {
                commonConfig->DeviceSpecific[2] = 0xff; // DWORD Select
                commonConfig->DeviceSpecific[3] = 0xff; // Pending
                commonConfig->DeviceSpecific[4] = 0xff; // Data
                commonConfig->DeviceSpecific[5] = 0xff;
                commonConfig->DeviceSpecific[6] = 0xff;
                commonConfig->DeviceSpecific[7] = 0xff;

            }

            break;

    }


    //
    //  Now set our default config
    //
    RtlCopyMemory(&config->Default, &config->Current, sizeof(PCI_COMMON_CONFIG));


}

ULONGLONG
SoftPCI_GetLengthFromBar(
    ULONGLONG BaseAddressRegister
    )

/*++

Routine Description:

    STOLEN FROM PCI.SYS and modified to support 64 bit bars

    Given the contents of a PCI Base Address Register, after it
    has been written with all ones, this routine calculates the
    length (and alignment) requirement for this BAR.

    This method for determining requirements is described in
    section 6.2.5.1 of the PCI Specification (Rev 2.1).

Arguments:

    BaseAddressRegister contains something.

Return Value:

    Returns the length of the resource requirement.  This will be a number
    in the range 0 thru 0x80000000 (0 thru 0x8000000000000000 on 64bit bar).

--*/

{
    ULONGLONG Length;

    //
    // A number of least significant bits should be ignored in the
    // determination of the length.  These are flag bits, the number
    // of bits is dependent on the type of the resource.
    //

    if (BaseAddressRegister & PCI_ADDRESS_IO_SPACE) {

        //
        // PCI IO space.
        //
        BaseAddressRegister &= PCI_ADDRESS_IO_ADDRESS_MASK;

    } else {

        //
        // PCI Memory space.
        //
        //BaseAddressRegister &= PCI_ADDRESS_MEMORY_ADDRESS_MASK;
        BaseAddressRegister &= 0xfffffffffffffff0;
    }

    //
    // BaseAddressRegister now contains the maximum base address
    // this device can reside at and still exist below the top of
    // memory.
    //
    // The value 0xffffffff was written to the BAR.  The device will
    // have adjusted this value to the maximum it can really use.
    //
    // Length MUST be a power of 2.
    //
    // For most devices, h/w will simply have cleared bits from the
    // least significant bit positions so that the address 0xffffffff
    // is adjusted to accomodate the length.  eg: if the new value is
    // 0xffffff00, the device requires 256 bytes.
    //
    // The difference between the original and new values is the length (-1).
    //
    // For example, if the value fead back from the BAR is 0xffff0000,
    // the length of this resource is
    //
    //     0xffffffff - 0xffff0000 + 1
    //   = 0x0000ffff + 1
    //   = 0x00010000
    //
    //  ie 64KB.
    //
    // Some devices cannot reside at the top of PCI address space.  These
    // devices will have adjusted the value such that length bytes are
    // accomodated below the highest address.  For example, if a device
    // must reside below 1MB, and occupies 256 bytes, the value will now
    // be 0x000fff00.
    //
    // In the first case, length can be calculated as-
    //


    Length = (0xffffffffffffffff - BaseAddressRegister) + 1;

    if (((Length - 1) & Length) != 0) {

        //
        // We didn't end up with a power of two, must be the latter
        // case, we will have to scan for it.
        //

        Length = 4;     // start with minimum possible

        while ((Length | BaseAddressRegister) != BaseAddressRegister) {

            //
            // Length *= 2, note we will eventually drop out of this
            // loop for one of two reasons (a) because we found the
            // length, or (b) because Length left shifted off the end
            // and became 0.
            //

            Length <<= 1;
        }
    }

    //
    // Check that we got something.
    //
    return Length;
}


BOOL
SoftPCI_ReadWriteConfigSpace(
    IN PPCI_DN Device,
    IN ULONG Offset,
    IN ULONG Length,
    IN OUT PVOID Buffer,
    IN BOOL WriteConfig
    )
{
/*++
    
Abstract:

    This is the function used to send an IOCTL telling the PCIDRV driver to read or write config space.
            
Arguments:

    Device - device we are going to mess with
    Offset - offset in config space to start at
    Length - length of the read or write
    Buffer - pointer to data to be written, or location to store value read
    WriteConfig - boolean value indicating write if true, or read if false 
    
Return Value:
    
    TRUE if success
    FALSE if not

--*/


    BOOL status = FALSE, success = FALSE;
    ULONG bytesReturned = 0;
    SOFTPCI_RW_CONTEXT context;


    context.WriteConfig = ((WriteConfig == TRUE) ? SoftPciWriteConfig : SoftPciReadConfig);
    context.Bus = Device->Bus;
    context.Slot.AsUSHORT = Device->Slot.AsUSHORT;
    context.Offset = Offset;
    context.Data = Buffer;
    
    
    //
    //  Call our driver
    //
    status = DeviceIoControl(g_DriverHandle,
                             (DWORD) SOFTPCI_IOCTL_RW_CONFIG,
                             &context,
                             sizeof(SOFTPCI_RW_CONTEXT),
                             Buffer,
                             Length,
                             &bytesReturned,
                             NULL
                             );

    if (!status) {
        //
        //  Something failed
        //
        wprintf(TEXT("DeviceIoControl() Failed! 0x%x\n"), GetLastError());
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\dialogp.h ===
#define HANDLE_TRACKBAR(wparam, lparam)     \
    SoftPCI_HandleTrackBar((HWND) lparam, LOWORD(wparam), HIWORD(wparam));

#define HANDLE_SPINNER(wparam, lparam)     \
    SoftPCI_HandleSpinnerControl((HWND) lparam, LOWORD(wparam), HIWORD(wparam));

#define SoftPCI_DisableWindow(Wnd)  \
    EnableWindow(Wnd, FALSE);

#define SoftPCI_EnableWindow(Wnd)  \
    EnableWindow(Wnd, TRUE);

#define SoftPCI_HideWindow(Wnd)  \
    ShowWindow(Wnd, SW_HIDE);

#define SoftPCI_ShowWindow(Wnd)  \
    ShowWindow(Wnd, SW_SHOW);

#define SoftPCI_CheckDlgBox(WND)  \
    SendMessage(WND, BM_SETCHECK, BST_CHECKED, 0);

#define SoftPCI_UnCheckDlgBox(WND)  \
    SendMessage(WND, BM_SETCHECK, BST_UNCHECKED, 0);

#define SoftPCI_ResetTrackBar(TrackBar) \
    SendMessage(TrackBar, TBM_SETPOS, (WPARAM)TRUE, 0);
    
#define SoftPCI_GetTrackBarPosition(Wnd)    \
    SendMessage(Wnd, TBM_GETPOS, 0, 0);
        
#define SoftPCI_SetSpinnerValue(Wnd, NewValue)  \
    SendMessage(Wnd, UDM_SETPOS, 0, NewValue);

#define SoftPCI_GetSpinnerValue(Wnd)  \
    SendMessage(Wnd, UDM_GETPOS, 0, 0);

#define SoftPCI_InitSpinnerControl(Wnd, LowerRange, UpperRange, DefaultValue)  \
    SendMessage(Wnd, UDM_SETRANGE, (WPARAM)0, (LPARAM) MAKELONG((SHORT)UpperRange, (SHORT)LowerRange)); \
    SoftPCI_SetSpinnerValue(Wnd, DefaultValue);


VOID
SoftPCI_DlgOnCommand(
    IN HWND     Wnd,
    IN INT      ControlID,
    IN HWND     ControlWnd,
    IN UINT     NotificationCode
    );

ULONG
SoftPCI_GetPossibleDevNumMask(
    IN PPCI_DN ParentDn
    );

VOID
SoftPCI_DisplayDlgOptions(
    IN SOFTPCI_DEV_TYPE DevType
    );

VOID
SoftPCI_HandleCheckBox(
    IN HWND     Wnd,
    IN INT      ControlID,
    IN UINT     NotifyCode
    );

VOID
SoftPCI_HandleDlgInstallDevice(
    IN HWND     Wnd
    );

VOID
SoftPCI_HandleRadioButton(
    IN HWND     Wnd,
    IN INT      ControlID,
    IN UINT     NotificationCode
    );

VOID
SoftPCI_HandleTrackBar(
    IN HWND Wnd,
    IN WORD NotificationCode,
    IN WORD CurrentPos
    );

VOID
SoftPCI_HandleSpinnerControl(
    IN HWND Wnd,
    IN WORD NotificationCode,
    IN WORD CurrentPos
    );

VOID
SoftPCI_InitializeBar(
    IN INT  Bar
    );

VOID
SoftPCI_InitializeHotPlugControls(
    VOID
    );

BOOL
SoftPCI_GetAssociatedBarControl(
    IN  INT ControlID,
    OUT INT *Bar
    );

VOID
SoftPCI_ResetLowerBars(
    IN INT  Bar
    );

VOID
SoftPCI_ResetNewDevDlg(
    VOID
    );

VOID
SoftPCI_ShowCommonNewDevDlg(
    VOID
    );

VOID
SoftPCI_UpdateBarText(
    IN PWCHAR       Buffer,
    IN ULONGLONG    BarSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\parseini.c ===
#include <pch.h>


BOOL
SoftPCI_CopyLine(
    OUT PWCHAR Destination,
    IN PWCHAR CurrentLine,
    IN ULONG DestinationSize
    );

BOOL
SoftPCI_GetConfigValue(
    IN PWCHAR CurrentDataPtr,
    IN PULONG DataValue,
    IN PULONG DataSize
    );

BOOL
SoftPCI_GetDeviceInstallCount(
    IN PWCHAR InstallSection,
    OUT PULONG DeviceCount
    );

BOOL
SoftPCI_GetDeviceInstallList(
    IN PWCHAR InstallSection,
    IN OUT PWCHAR *DeviceInstallList
    );

BOOL
SoftPCI_GetNextConfigOffset(
    IN OUT PWCHAR *ConfigDataPtr,
    OUT PUCHAR ConfigOffset
    );

PWCHAR
SoftPCI_GetNextLinePtr(
    PWCHAR  CurrentLine
    );

PWCHAR
SoftPCI_GetNextSectionPtr(
    IN PWCHAR CurrentLine
    );

VOID
SoftPCI_GetCurrentParameter(
    OUT PWCHAR Destination,
    IN PWCHAR CurrentLine
    );

PWCHAR
SoftPCI_GetParameterValuePtr(
    IN PWCHAR CurrentLine
    );

VOID
SoftPCI_InsertEntryAtTail(
    IN PSINGLE_LIST_ENTRY Entry
    );

BOOL
SoftPCI_LocateSoftPCISection(
    VOID
    );

PWCHAR
SoftPCI_LocateFullParentPath(
    IN PWCHAR ParentInstallSection
    );

HANDLE
SoftPCI_OpenFile(
    IN PWCHAR FilePath
    );

BOOL
SoftPCI_ProcessInstallSection(
    VOID
    );

BOOL
SoftPCI_ProcessDeviceInstallSection(
    IN PWCHAR DeviceInstallSection
    );       

BOOL
SoftPCI_ProcessDeviceInstallParameters(
    IN PWCHAR DeviceInstallSection
    );

BOOL
SoftPCI_ProcessTypeParameter(
    IN PWCHAR ParameterPtr,
    IN OUT PSOFTPCI_SCRIPT_DEVICE *InstallDevice
    );

BOOL
SoftPCI_ProcessSlotParameter(
    IN PWCHAR ParameterPtr,
    IN OUT PSOFTPCI_SCRIPT_DEVICE *InstallDevice
    );

BOOL
SoftPCI_ProcessParentPathParameter(
    IN PWCHAR ParameterPtr,
    IN OUT PSOFTPCI_SCRIPT_DEVICE *InstallDevice
    );

BOOL
SoftPCI_ProcessCfgSpaceParameter(
    IN PWCHAR ParameterPtr,
    IN OUT PSOFTPCI_SCRIPT_DEVICE *InstallDevice
    );

BOOL
SoftPCI_ProcessCfgMaskParameter(
    IN PWCHAR ParameterPtr,
    IN OUT PSOFTPCI_SCRIPT_DEVICE *InstallDevice
    );

BOOL
SoftPCI_ParseConfigSpace(
    IN PWCHAR ParameterPtr,
    IN PPCI_COMMON_CONFIG CommonConfig
    );

BOOL
SoftPCI_ParseConfigData(
    IN UCHAR ConfigOffset,
    IN PUCHAR ConfigBuffer,
    IN PWCHAR ConfigData
    );

BOOL
SoftPCI_ReadFile(
    VOID
    );

USHORT
SoftPCI_StringToUSHORT(
    IN PWCHAR String
    );

BOOL
SoftPCI_ValidatePciPath(
    IN PWCHAR PciPath
    );


//
//  This is the list we fill out as we parse the ini file for
//  new devices to be installed
//
SINGLE_LIST_ENTRY    g_NewDeviceList;

WCHAR   g_ScriptError[MAX_PATH];

BOOL
typedef  (*PSCRIPT_PARAMETER_PARSER) (
    IN   PWCHAR                    ParameterPtr,
  IN OUT PSOFTPCI_SCRIPT_DEVICE  *InstallDevice
    );

#define  INI_SOFTPCI_SECTION    L"[softpci]"
#define  INI_INSTALL_SECTION    L"[install]"

//
//  Currently supported parameter tags
//
#define TYPEPARAMTER        L"type"
#define SLOTPARAMTER        L"slot"
#define PPATHPARAMETER      L"parentpath"
#define CFGSPACEPARAMETER   L"configspace"
#define CFGMASKPARAMETER    L"configspacemask"

//
//  This is the Parameter table we use to handle
//  parseing for each supported parameter tag
//
struct {
    
    PWCHAR  Parameter;
    PSCRIPT_PARAMETER_PARSER    ParameterParser;

} g_ScriptParameterTable[] = {
    TYPEPARAMTER,       SoftPCI_ProcessTypeParameter,
    SLOTPARAMTER,       SoftPCI_ProcessSlotParameter,
    PPATHPARAMETER,     SoftPCI_ProcessParentPathParameter,
    CFGSPACEPARAMETER,  SoftPCI_ProcessCfgSpaceParameter,
    CFGMASKPARAMETER,   SoftPCI_ProcessCfgMaskParameter,
    NULL,               NULL
};

//
//  We use this table to match up which "Type" tag to the
//  device type we are installing
//
struct {
    
    PWCHAR  TypeParamter;
    SOFTPCI_DEV_TYPE  DevType;

} g_ParameterTypeTable[] = {
    L"device",      TYPE_DEVICE,
    L"ppbridge",    TYPE_PCI_BRIDGE,
    L"hpbridge",    TYPE_HOTPLUG_BRIDGE,
    L"cbdevice",    TYPE_CARDBUS_DEVICE,
    L"cbbridge",    TYPE_CARDBUS_BRIDGE,
    L"private",     TYPE_UNKNOWN,
    NULL,           0
};

struct {
    HANDLE  FileHandle;
    ULONG   FileSize;
    PWCHAR  FileBuffer;
} g_ScriptFile; 

#define CRLF    L"\r\n"
#define MAX_LINE_SIZE               100
#define MAX_PARAMETER_LENGTH        50
#define MAX_PARAMETER_TYPE_LENGTH   25


#define IGNORE_WHITESPACE_FORWARD(x)       \
    while ((*x == ' ') || (*x == '\t')) {   \
        x++;                                \
    }
    
#define IGNORE_WHITESPACE_BACKWARD(x)      \
    while ((*x == ' ') || (*x == '\t')) {   \
        x--;                                \
    }

VOID
SoftPCI_InsertEntryAtTail(
    IN PSINGLE_LIST_ENTRY Entry
    )
{
    PSINGLE_LIST_ENTRY previousEntry;

    //
    // Find the end of the list.
    //
    previousEntry = &g_NewDeviceList;

    while (previousEntry->Next) {
        previousEntry = previousEntry->Next;
    }

    //
    // Append the entry.
    //
    previousEntry->Next = Entry;
    
}

BOOL
SoftPCI_BuildDeviceInstallList(
    IN PWCHAR ScriptFile
    )
{

    BOOL status = FALSE;
#if 0
    HINF hInf;
    UINT errorLine;
    INFCONTEXT infContext;

    errorLine = 0;
    hInf = SetupOpenInfFile(
        ScriptFile,
        NULL,
        INF_STYLE_OLDNT,
        &errorLine
        );

    if (hInf == INVALID_HANDLE_VALUE) {

        SoftPCI_Debug(SoftPciScript, L"Failed to open handle to %s\n", ScriptFile);
        return FALSE;
    }


    if (SetupFindFirstLine(hInf,
                           L"softpci",
                           NULL,
                           &infContext
                           )){

        SoftPCI_Debug(SoftPciScript, L"found our section!\n");
    }
    SoftPCI_Debug(SoftPciScript, L"Ready to party on %s\n", ScriptFile);
    SetupCloseInfFile(hInf);
    return FALSE;
#endif
    
    wcscpy(g_ScriptError, L"Unknown Error");
    
    g_ScriptFile.FileHandle = SoftPCI_OpenFile(ScriptFile);
    if (g_ScriptFile.FileHandle != INVALID_HANDLE_VALUE) {

        status = SoftPCI_ReadFile();

        //
        //  We no longer need the file
        //
        CloseHandle(g_ScriptFile.FileHandle);

        if (!status) {
            return status;
        }

        //
        //  Ensure the buffer is all lower case. 
        //
        _wcslwr(g_ScriptFile.FileBuffer);

        //
        //  Validate install section exits
        //
        if (!SoftPCI_LocateSoftPCISection()) {
            status = FALSE;
            goto CleanUp;
        }

        if (!SoftPCI_ProcessInstallSection()) {
            status = FALSE;
            goto CleanUp;
        }

    }

#if DBG
    else{
        SoftPCI_Debug(SoftPciScript, L"Failed to open handle to %s\n", ScriptFile);
    }
#endif

    
CleanUp:

    free(g_ScriptFile.FileBuffer);
    
    return status;
}

BOOL
SoftPCI_CopyLine(
    OUT PWCHAR Destination,
    IN PWCHAR CurrentLine,
    IN ULONG DestinationSize
    )
{

    PWCHAR lineEnd = NULL;
    PWCHAR copyBuffer = Destination;
    PWCHAR currentLine = CurrentLine;
    ULONG bufferSize;
    ULONG lineSize;
    
    lineEnd = wcsstr(CurrentLine, CRLF);
    if (!lineEnd) {
        //
        //  We must be at the last line
        //
        wcscpy(copyBuffer, currentLine);
        return TRUE;
    }

    lineSize = ((ULONG)(lineEnd - CurrentLine) * sizeof(WCHAR));

    //
    //  If our destination buffer size is less than the size of
    //  the line we only copy the size of the buffer.  Otherwise
    //  we zero the input buffer and copy just the line size.
    //
    if (DestinationSize){

        bufferSize = (DestinationSize * sizeof(WCHAR));
        RtlZeroMemory(Destination, bufferSize);

        if (lineSize > bufferSize) {
            lineSize = bufferSize - sizeof(WCHAR);
        }
    }
    
    RtlCopyMemory(Destination, CurrentLine, lineSize);
    
    return TRUE;
}

BOOL
SoftPCI_GetDeviceInstallCount(
    IN PWCHAR InstallSection,
    OUT PULONG DeviceCount
    )
{

    PWCHAR  installDevice;
    PWCHAR  installDeviceSectionStart = NULL;
    ULONG   deviceCount = 0;

    installDevice = SoftPCI_GetNextLinePtr(InstallSection);
    installDeviceSectionStart = wcsstr(installDevice, L"[");
    if (!installDeviceSectionStart) {
        wcscpy(g_ScriptError, L"Device install section missing or invalid!");
        return FALSE;
    }

    while (installDevice != installDeviceSectionStart) {

        deviceCount++;
        installDevice = SoftPCI_GetNextLinePtr(installDevice);

        if (installDevice == NULL) {
            //
            //  We reached the EOF way to early!
            //
            wcscpy(g_ScriptError, L"Unexpected EOF reached!");
            return FALSE;
        }
    }
    
    *DeviceCount = deviceCount;

    return TRUE;
}

BOOL
SoftPCI_GetDeviceInstallList(
    IN PWCHAR InstallSection,
    IN OUT PWCHAR *DeviceInstallList
    )
{

    PWCHAR  *deviceInstallList;
    PWCHAR  installDevice;
    PWCHAR  installDeviceSectionStart;

    deviceInstallList = DeviceInstallList;
    installDevice = SoftPCI_GetNextLinePtr(InstallSection);
    installDeviceSectionStart = wcsstr(installDevice, L"[");
    if (!installDeviceSectionStart) {
        return FALSE;
    }

    while (installDevice != installDeviceSectionStart) {

        IGNORE_WHITESPACE_FORWARD(installDevice);

        *deviceInstallList = installDevice;

        installDevice = SoftPCI_GetNextLinePtr(installDevice);

        if (installDevice == NULL) {
            //
            //  We reached the EOF way to early!
            //
            wcscpy(g_ScriptError, L"Unexpected EOF reached!");
            return FALSE;
        }
        deviceInstallList++;
    }

    if ((*(installDevice - 1) == '\n') && (*(installDevice - 3) == '\n')) {
        
        //
        //  Ignore the whitespace here
        //
        deviceInstallList--;
        *deviceInstallList = NULL;
    }

    return TRUE;

}

BOOL
SoftPCI_GetNextConfigOffset(
    IN OUT PWCHAR *ConfigDataPtr,
    OUT PUCHAR ConfigOffset
    )
{

    PWCHAR configOffsetPtr, dummy;
    PWCHAR nextConfigSpace;
    WCHAR offset[2];
    ULONG i;

    configOffsetPtr = *ConfigDataPtr;
    if (configOffsetPtr == NULL) {
        return FALSE;
    }

    //
    //  make sure that the next offset we find is without the current
    //  configspace we are parsing
    //
    nextConfigSpace = wcsstr(configOffsetPtr, L"config");
    if (nextConfigSpace == NULL) {
        nextConfigSpace = configOffsetPtr + wcslen(configOffsetPtr);
    }
    
    configOffsetPtr = wcsstr(configOffsetPtr, L":");
    if ((configOffsetPtr == NULL) ||
        (configOffsetPtr > nextConfigSpace)) {
        return FALSE;
    }

    IGNORE_WHITESPACE_BACKWARD(configOffsetPtr);
    
    configOffsetPtr -= 2;

    for (i=0; i<2; i++) {
        offset[i] = *configOffsetPtr;
        configOffsetPtr++;
    }
    
    IGNORE_WHITESPACE_FORWARD(configOffsetPtr);
    configOffsetPtr++;
    IGNORE_WHITESPACE_FORWARD(configOffsetPtr);
    
    *ConfigDataPtr = configOffsetPtr;

    *ConfigOffset = (UCHAR) wcstoul(offset, &dummy, 16);

    return TRUE;
}

PWCHAR
SoftPCI_GetNextLinePtr(
    IN PWCHAR CurrentLine
    )

{
    PWCHAR nextLine = NULL;
    PWCHAR currentLine = CurrentLine;
    BOOL lineSkipped = FALSE;
    
    if (!CurrentLine) {
        return NULL;
    }
    
    nextLine = wcsstr(CurrentLine, CRLF);

    if (nextLine && *(nextLine+2) == ';'){
        currentLine = nextLine;
    }

    while (nextLine == currentLine) {
        currentLine += 2;
        nextLine = wcsstr(currentLine, CRLF);
        
        if (!nextLine) {
            nextLine = currentLine;
            break;
        }
    
        if (*currentLine == ';') {
            currentLine = nextLine;
        }
        lineSkipped = TRUE;
    }

    if (lineSkipped) {
        return ((nextLine != NULL) ? currentLine: nextLine);
    }
    
    if (nextLine){
        nextLine += 2;
    }

    return nextLine;
}

PWCHAR
SoftPCI_GetNextSectionPtr(
    IN PWCHAR CurrentLine
    )
{

    PWCHAR nextSection;

    nextSection = wcsstr(CurrentLine, L"[");
    
    if (nextSection == NULL) {
        nextSection = CurrentLine + wcslen(CurrentLine);
    }

    return nextSection;

}

VOID
SoftPCI_GetCurrentParameter(
    OUT PWCHAR Destination,
    IN PWCHAR CurrentLine
    )
{
    PWCHAR p = Destination;
    PWCHAR currentLine = CurrentLine;

    IGNORE_WHITESPACE_FORWARD(currentLine);

    SoftPCI_CopyLine(Destination, currentLine, MAX_PARAMETER_LENGTH);

    p = wcsstr(Destination, L"=");

    if (p) {
        p--;
        IGNORE_WHITESPACE_BACKWARD(p);
        p++;
        *p =  0;
    }
}

BOOL
SoftPCI_GetParameterValue(
    OUT PWCHAR Destination,
    IN PWCHAR CurrentLine,
    IN ULONG DestinationLength
    )
{
    
    PWCHAR  valuePtr = NULL;
    
    valuePtr = wcsstr(CurrentLine, L"=");

    if (!valuePtr) {
        return FALSE;
    }
    valuePtr++;

    IGNORE_WHITESPACE_FORWARD(valuePtr);
    
    SoftPCI_CopyLine(Destination, valuePtr, DestinationLength);

    return TRUE;
}

PWCHAR
SoftPCI_GetParameterValuePtr(
    IN PWCHAR CurrentLine
    )
{

    PWCHAR  valuePtr;
    PWCHAR  nextSectionPtr;
    
    valuePtr = wcsstr(CurrentLine, L"=");
    
    if (!valuePtr) {
        return NULL;
    }

    nextSectionPtr = SoftPCI_GetNextSectionPtr(CurrentLine);

    if (valuePtr > nextSectionPtr) {
        return NULL;
    }
    
    valuePtr++;

    IGNORE_WHITESPACE_FORWARD(valuePtr);

    return valuePtr;
}


BOOL
SoftPCI_LocateSoftPCISection(
    VOID
    )
{
    PWCHAR  p = NULL;

    p = wcsstr(g_ScriptFile.FileBuffer, INI_SOFTPCI_SECTION);

    return (p != NULL);
}

PWCHAR
SoftPCI_LocateFullParentPath(
    IN PWCHAR ParentInstallSection
    )
{
    WCHAR parentSection[MAX_PATH];
    PWCHAR deviceSectionPtr;
    PWCHAR parentPathPtr;

    wsprintf(parentSection, L"[%s]", ParentInstallSection);

    SoftPCI_Debug(SoftPciScript, L" - - Searching for %s section...\n", parentSection);

    deviceSectionPtr = wcsstr(g_ScriptFile.FileBuffer, parentSection);

    if (!deviceSectionPtr) {
        return NULL;
    }

    //
    //  Now jump to the parentpath section.
    //
    parentPathPtr = wcsstr(deviceSectionPtr, PPATHPARAMETER);

    if (!parentPathPtr) {
        return NULL;
    }

    return NULL;
}

BOOL
SoftPCI_ProcessInstallSection(
    VOID
    )
{
    PWCHAR installSection;
    PWCHAR *installDeviceList;
    PWCHAR *installDeviceCurrent;
    ULONG installDeviceCount;
    BOOL result = TRUE;

    installSection = wcsstr(g_ScriptFile.FileBuffer, INI_INSTALL_SECTION);

    if (installSection) {
        
        //
        //  We have our install section.  Build our install list
        //
        installDeviceCount = 0;
        if (!SoftPCI_GetDeviceInstallCount(installSection, &installDeviceCount)){
             return FALSE;
        }

        //
        //  Allocate an array of PWCHAR plus an extra NULL
        //
        installDeviceList = calloc(installDeviceCount + 1, sizeof(PWCHAR));

        if (!SoftPCI_GetDeviceInstallList(installSection, installDeviceList)) {
            free(installDeviceList);
            return FALSE;
        }

        //
        //  Now we have our list.  Install each device
        //
        installDeviceCurrent = installDeviceList;

        while(*installDeviceCurrent){
            
            //
            //  Loop through each device to install and parse
            //  it's InstallParamters
            //
            result = SoftPCI_ProcessDeviceInstallSection(*installDeviceCurrent);

#if 0
        {

            WCHAR failedSection[MAX_PATH];

            SoftPCI_CopyLine(failedSection, *installDeviceCurrent, MAX_PATH);

            if (!result) {

                SoftPCI_Debug(SoftPciScript, L"Error parsing [%s] section!\n", failedSection);

            }else{

                SoftPCI_Debug(SoftPciScript, L" -- successfully parsed %s section!\n", failedSection);
            }
        }
#endif

            installDeviceCurrent++;
        }
    }

    free(installDeviceList);

    return TRUE;
}

BOOL
SoftPCI_ProcessDeviceInstallSection(
    IN PWCHAR DeviceInstallSection
    )
{
    WCHAR deviceSectionString[MAX_PATH];
    WCHAR deviceSection[MAX_PATH];
    PWCHAR deviceSectionPtr;

    SoftPCI_CopyLine(deviceSection, DeviceInstallSection, MAX_PATH);

    wsprintf(deviceSectionString, L"[%s]", deviceSection);

    SoftPCI_Debug(SoftPciScript, L"Searching for %s section...\n", deviceSectionString);

    deviceSectionPtr = wcsstr(DeviceInstallSection, deviceSectionString);

    if (!deviceSectionPtr) {
        return FALSE;
    }

    SoftPCI_Debug(SoftPciScript, L" - found %s section!\n", deviceSectionString);

    //
    //  We have an install section.  Process InstallParamters
    //
    return SoftPCI_ProcessDeviceInstallParameters(deviceSectionPtr);
}

BOOL
SoftPCI_ProcessDeviceInstallParameters(
    IN PWCHAR DeviceInstallSection
    )
{
    
    ULONG i;
    BOOL result;
    WCHAR currentParameter[MAX_PARAMETER_LENGTH];
    PWCHAR currentParameterPtr;
    PWCHAR nextSectionPtr;
    PSOFTPCI_SCRIPT_DEVICE currentDevice;
    PSOFTPCI_SCRIPT_DEVICE installDevice;

    nextSectionPtr = SoftPCI_GetNextSectionPtr(DeviceInstallSection+1);

    if (SoftPCI_GetNextLinePtr(DeviceInstallSection) == NULL) {
        return FALSE;
    }

    currentParameterPtr = SoftPCI_GetNextLinePtr(DeviceInstallSection);
    SoftPCI_Debug(SoftPciScript, L"nextSectionPtr = %p\n", nextSectionPtr);
    SoftPCI_Debug(SoftPciScript, L"currentParameterPtr = %p\n", currentParameterPtr);

    if (!currentParameterPtr) {
        //
        //  We dont have a Parameter to process
        //
        SoftPCI_Debug(SoftPciScript, L"EOF reached before parameters processed!\n");
        return FALSE;
    }
    
    result = FALSE;
    while (currentParameterPtr < nextSectionPtr) {
        
        //
        //  Grab our parameters and run the respective parser
        //
        SoftPCI_GetCurrentParameter(currentParameter, currentParameterPtr);

        SoftPCI_Debug(SoftPciScript, L"currentParameter = %s\n", currentParameter);

        i = 0;
        while (g_ScriptParameterTable[i].Parameter) {

            if ((wcscmp(currentParameter, g_ScriptParameterTable[i].Parameter) == 0)) {

                result = g_ScriptParameterTable[i].ParameterParser(currentParameterPtr, &currentDevice);
            }
            i++;
        }

        currentParameterPtr = SoftPCI_GetNextLinePtr(currentParameterPtr);

        if (currentParameterPtr == NULL) {
            //
            //  EOF
            //
            break;
        }
    }

    SoftPCI_Debug(SoftPciScript, L"currentParameterPtr = %p\n", currentParameterPtr);
    
    if (currentDevice && 
        currentDevice->SoftPciDevice.Config.Current.VendorID) {
                
        //
        //  We have something so assume all is well
        //
        SoftPCI_Debug(SoftPciScript, 
                      L"New device ready to install! Ven %04x Dev %04x\n", 
                      currentDevice->SoftPciDevice.Config.Current.VendorID,
                      currentDevice->SoftPciDevice.Config.Current.DeviceID
                      );

        
        SoftPCI_InsertEntryAtTail(&currentDevice->ListEntry);
        
        //free(currentDevice->ParentPath);
        //free(currentDevice);
        return TRUE;
    }

    return FALSE;

}

BOOL
SoftPCI_ProcessTypeParameter(
    IN PWCHAR ParameterPtr,
    IN OUT PSOFTPCI_SCRIPT_DEVICE *InstallDevice
    )
{
    WCHAR parameterType[MAX_PARAMETER_TYPE_LENGTH];
    PSOFTPCI_SCRIPT_DEVICE installDevice;
    ULONG i;


    SoftPCI_Debug(SoftPciScript, L"ProcessTypeParameter called\n");

    if (!SoftPCI_GetParameterValue(parameterType, ParameterPtr, MAX_PARAMETER_TYPE_LENGTH)){
        return FALSE;
    }

    SoftPCI_Debug(SoftPciScript, L"   parameterType = %s\n", parameterType);

    installDevice = (PSOFTPCI_SCRIPT_DEVICE) calloc(1, FIELD_OFFSET(SOFTPCI_SCRIPT_DEVICE, ParentPath));

    if (installDevice == NULL) {
        SoftPCI_Debug(SoftPciScript, L"failed to alloate memory for device!\n");
        return FALSE;
    }
    
    i = 0;
    while (g_ParameterTypeTable[i].TypeParamter) {

        if ((wcscmp(parameterType, g_ParameterTypeTable[i].TypeParamter) == 0)) {

            SoftPCI_InitializeDevice(&installDevice->SoftPciDevice,
                                     g_ParameterTypeTable[i].DevType);
        }
        i++;
    }

    *InstallDevice = installDevice;

    return TRUE;
}

BOOL
SoftPCI_ProcessSlotParameter(
    IN PWCHAR ParameterPtr,
    IN OUT PSOFTPCI_SCRIPT_DEVICE *InstallDevice
    )
{
    
    WCHAR slotParameter[MAX_PARAMETER_TYPE_LENGTH];
    SOFTPCI_SLOT deviceSlot;
    PSOFTPCI_SCRIPT_DEVICE installDevice;

    SoftPCI_Debug(SoftPciScript, L"ProcessSlotParameter called\n");

    installDevice = *InstallDevice;
    if (installDevice == NULL) {
        return FALSE;
    }

    if (!SoftPCI_GetParameterValue(slotParameter, ParameterPtr, MAX_PARAMETER_TYPE_LENGTH)){
        return FALSE;
    }

    SoftPCI_Debug(SoftPciScript, L"   slotParameter = %s\n", slotParameter);

    deviceSlot.AsUSHORT = SoftPCI_StringToUSHORT(slotParameter);
    
    SoftPCI_Debug(SoftPciScript, L"   deviceSlot = %04x\n", deviceSlot.AsUSHORT);

    installDevice->SoftPciDevice.Slot.AsUSHORT = deviceSlot.AsUSHORT;
    installDevice->SlotSpecified = TRUE;

    return TRUE;
}

BOOL
SoftPCI_ProcessParentPathParameter(
    IN PWCHAR ParameterPtr,
    IN OUT PSOFTPCI_SCRIPT_DEVICE *InstallDevice
    )
{
    PWCHAR parentPathPtr;
    PWCHAR parentPath;
    PWCHAR endPath;
    PWCHAR nextSectionPtr;
    ULONG parentPathLength;
    PSOFTPCI_SCRIPT_DEVICE installDevice;
    
    SoftPCI_Debug(SoftPciScript, L"ProcessParentPathParameter called\n");
    //
    //  ParentPath could in theory be as long as (256 buses * sizeof Slot * sizeof(WCHAR))
    //  which is 2k.  Let's dynamically allocate storage needed.
    //
    installDevice = *InstallDevice;
    if (installDevice == NULL) {
        return FALSE;
    }

    parentPathPtr = SoftPCI_GetParameterValuePtr(ParameterPtr);
    
    if (!parentPathPtr) {
        return FALSE;
    }

    endPath = wcsstr(parentPathPtr, CRLF);
    parentPathLength = 0;
    if (endPath) {
        parentPathLength = (ULONG)((endPath - parentPathPtr) + 1);
    }else{
        parentPathLength = wcslen(parentPathPtr) + 1;
    }

    parentPath = (PWCHAR) calloc(sizeof(WCHAR), parentPathLength + 1);

    if (!parentPath) {
        return FALSE;
    }

    SoftPCI_CopyLine(parentPath, parentPathPtr, 0);

    SoftPCI_Debug(SoftPciScript, L"     ParentPath - %s\n", parentPath);

    //
    //  Now things get interesting.  We need to parse out our parent paths
    //  if the parent path specified here is a pointer to a previous device
    //  instead of a actual parent path.
    //
    //
    //  ISSUE: BrandonA - Implement this later!!!
    //
    //InstallDevice->ParentPath = SoftPCI_LocateFullParentPath(parentPath);

    parentPathLength *= sizeof(WCHAR);

    //
    //  Now re-allocate the memory used for the installDevice with additional space for the 
    //  parentPathLength
    //
    installDevice = realloc(installDevice, sizeof(SOFTPCI_SCRIPT_DEVICE) + parentPathLength);
    
    if (installDevice) {
        wcscpy(installDevice->ParentPath, parentPath);
        installDevice->ParentPathLength = parentPathLength;
        *InstallDevice = installDevice;
    }else{
        *InstallDevice = NULL;
        return FALSE;
    }
    
    if (SoftPCI_ValidatePciPath(installDevice->ParentPath)){
        return TRUE;
    }
    
    free(installDevice);
    *InstallDevice = NULL;

    return FALSE;
}

BOOL
SoftPCI_ProcessCfgSpaceParameter(
    IN PWCHAR ParameterPtr,
    IN OUT PSOFTPCI_SCRIPT_DEVICE *InstallDevice
    )
{
    PSOFTPCI_SCRIPT_DEVICE installDevice;
    
    SoftPCI_Debug(SoftPciScript, L"ProcessCfgSpaceParameter called\n");
    
    installDevice = *InstallDevice;
    if (installDevice == NULL) {
        return FALSE;
    }

    return SoftPCI_ParseConfigSpace(
        ParameterPtr,
        &installDevice->SoftPciDevice.Config.Current
        );

}

BOOL
SoftPCI_ProcessCfgMaskParameter(
    IN PWCHAR ParameterPtr,
    IN OUT PSOFTPCI_SCRIPT_DEVICE *InstallDevice
    )
{
    PSOFTPCI_SCRIPT_DEVICE installDevice;

    SoftPCI_Debug(SoftPciScript, L"ProcessCfgMaskParameter called\n");
    
    installDevice = *InstallDevice;
    if (installDevice == NULL) {
        return FALSE;
    }

    return SoftPCI_ParseConfigSpace(
        ParameterPtr,
        &installDevice->SoftPciDevice.Config.Mask
        );
}


BOOL
SoftPCI_ParseConfigSpace(
    IN PWCHAR ParameterPtr,
    IN PPCI_COMMON_CONFIG CommonConfig
    )
{

    PWCHAR cfgSpacePtr;
    PWCHAR endLine, nextSection;
    PUCHAR configPtr;
    UCHAR configOffset;
    WCHAR lineBuffer[MAX_LINE_SIZE];

    cfgSpacePtr = SoftPCI_GetParameterValuePtr(ParameterPtr);

    if (cfgSpacePtr == NULL) {
        return FALSE;
    }

    if (*cfgSpacePtr == '\r') {
        //
        //  Our first offset must start at the next line
        //
        cfgSpacePtr = SoftPCI_GetNextLinePtr(cfgSpacePtr);
    }
    
    nextSection = SoftPCI_GetNextSectionPtr(cfgSpacePtr);
    

    configPtr = (PUCHAR) CommonConfig;
    configOffset = 0;
    while (cfgSpacePtr && (cfgSpacePtr < nextSection)) {

        IGNORE_WHITESPACE_FORWARD(cfgSpacePtr)

        //
        //  We should now be pointing to a configspace offset that we need
        //  to parse.  Validate that the line is less than our stack buffer size.
        //
        endLine = wcsstr(cfgSpacePtr, CRLF);

        if (endLine == NULL) {
            endLine = cfgSpacePtr + wcslen(cfgSpacePtr);
        }

        if ((endLine - cfgSpacePtr) > MAX_PATH) {
            //
            //  Too much to parse on one line, Error out.
            //
            SoftPCI_Debug(SoftPciScript, L"ParseConfigSpace - cannot parse configspace offset!\n");
            return FALSE;
        }
        
        //
        //  Now grab our next offset
        //
        if (!SoftPCI_GetNextConfigOffset(&cfgSpacePtr, &configOffset)) {
            //
            //  We didnt find and offset, fail
            //
            return FALSE;
        }

        SoftPCI_Debug(SoftPciScript, L"ParseConfigSpace - first offset - %02x\n", configOffset);

        SoftPCI_CopyLine(lineBuffer, cfgSpacePtr, MAX_LINE_SIZE);
        SoftPCI_Debug(SoftPciScript, L"ParseConfigSpace - lineBuffer - %s\n", lineBuffer);

        //
        //  Parse the specified data
        //
        SoftPCI_ParseConfigData(
            configOffset, 
            configPtr + configOffset, 
            lineBuffer
            );


        cfgSpacePtr = SoftPCI_GetNextLinePtr(cfgSpacePtr);
    }

    return TRUE;

}

BOOL
SoftPCI_ParseConfigData(
    IN UCHAR ConfigOffset,
    IN PUCHAR ConfigBuffer,
    IN PWCHAR ConfigData
    )
{
    
    USHORT configOffset;
    PUCHAR configBuffer;
    PWCHAR currentDataPtr, endLine;
    ULONG dataSize;
    ULONG dataValue;

    configOffset = (USHORT)ConfigOffset;
    currentDataPtr = ConfigData;
    configBuffer = ConfigBuffer;
    while (currentDataPtr) {

        SoftPCI_Debug(SoftPciScript, L"ParseConfigData - next offset - %04x\n", configOffset);
        
        if (!SoftPCI_GetConfigValue(currentDataPtr, &dataValue, &dataSize)){
            return FALSE;
        }
        SoftPCI_Debug(
            SoftPciScript, 
            L"ParseConfigData - dataValue - %x dataSize - %x\n", 
            dataValue, 
            dataSize
            );

        if ((configOffset + dataSize) > sizeof(PCI_COMMON_CONFIG)){
            //
            //  We cannot write more than the common config
            //
            return FALSE;
        }
        
        RtlCopyMemory(configBuffer, &dataValue, dataSize);
                                                                  
        currentDataPtr = wcsstr(currentDataPtr, L",");
     
        while (currentDataPtr && (*currentDataPtr == ',')) {
            
            //
            //  For each comma encountered we increment to the next DWORD
            //
            if ((configOffset & 0x3) == 0){
                configOffset += sizeof(ULONG);
                configBuffer += sizeof(ULONG);
            }else{

                while ((configOffset & 0x3) != 0) {
                    configOffset++;
                    configBuffer++;
                }
            }
            currentDataPtr++;
            
            if (*currentDataPtr == 0) {
                currentDataPtr = NULL;
                break;
            }

            IGNORE_WHITESPACE_FORWARD(currentDataPtr)
        }
    }
    return TRUE;
}

BOOL
SoftPCI_GetConfigValue(
    IN PWCHAR CurrentDataPtr,
    IN PULONG DataValue,
    IN PULONG DataSize
    )
{

    ULONG value, size;
    PWCHAR endScan;

    *DataValue = 0;
    *DataSize = 0;
    value = 0;

    endScan = NULL;

    value = wcstoul(CurrentDataPtr, &endScan, 16);

    if (endScan == CurrentDataPtr) {
        //
        //  no valid number was found
        //
        return FALSE;
    }

    size = (ULONG)(endScan - CurrentDataPtr);
    
    if (size % 2) {
        size++;
    }

    //
    //  If we have more than 8 characters then max our size out at 8
    //
    if (size > 8) {
        size = 8;
    }
    
    SoftPCI_Debug(SoftPciScript, L"GetConfigValue - dataSize - %x\n", size);

    //
    //  Now return our values.  Note that size needs to be converted to bytes.
    //
    *DataSize = (size / 2);
    *DataValue = value;

    return TRUE;
    
}


HANDLE
SoftPCI_OpenFile(
    IN PWCHAR FilePath
    )
{
    return CreateFile(FilePath,
                      GENERIC_READ,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_ARCHIVE,
                      NULL
                      );
}

BOOL
SoftPCI_ReadFile(
    VOID
    )
/*--
Routine Description:

    Reads the file specified by FileHandle into a buffer and returns a pointer
    to the buffer

Arguments:

    none

Return Value:

    TRUE on success, FALSE otherwise
    
--*/
{

    INT sizeWritten = 0;
    ULONG fileSize = 0, readSize = 0;
    PUCHAR ansiFile = NULL;
    
    
    //
    //  Obtain the File Size
    //
    fileSize = GetFileSize(g_ScriptFile.FileHandle, NULL);
    
    if (fileSize == 0xFFFFFFFF) {
        
        SoftPCI_Debug(SoftPciScript,
                      L"Failed to determine size of script file! Error - \"%s\"\n", 
                      SoftPCI_GetLastError());
        
        return FALSE;
    }

    //
    //  Allocate our buffer (with a little padding).  It will be zeroed by default
    //
    ansiFile = (PUCHAR) calloc(1, fileSize + sizeof(ULONG));
    g_ScriptFile.FileBuffer = (PWCHAR) calloc(sizeof(WCHAR), fileSize + sizeof(ULONG));
    
    if ((g_ScriptFile.FileBuffer) && ansiFile) {

        //
        //  Read the file
        //
        if (!ReadFile(g_ScriptFile.FileHandle,    
                      ansiFile, 
                      fileSize, 
                      &readSize, 
                      NULL
                      )){

            SoftPCI_Debug(SoftPciScript,
                          L"Failed to read file! Error - \"%s\"\n", 
                          SoftPCI_GetLastError());
            
            goto CleanUp;
        }

        if (readSize != fileSize) {

            SoftPCI_Debug(SoftPciScript,
                          L"Failed to read entire file! Error - \"%s\"\n", 
                          SoftPCI_GetLastError());
            
            goto CleanUp;
        }

        //
        //  Now convert the file to Unicode.
        //
        sizeWritten = MultiByteToWideChar(CP_THREAD_ACP,
                                          MB_PRECOMPOSED,
                                          ansiFile,
                                          -1,
                                          g_ScriptFile.FileBuffer,
                                          ((fileSize * sizeof(WCHAR)) + sizeof(ULONG))
                                          );

        if (sizeWritten != (strlen(ansiFile) + 1)) {

            SoftPCI_Debug(SoftPciScript,
                          L"Failed to convert file to unicode!\n");
            goto CleanUp;

        }

        g_ScriptFile.FileSize = sizeWritten;

        free(ansiFile);
        
        return TRUE;
    }

    SoftPCI_Debug(SoftPciScript,
                  L"Failed to allocate required memory!");

CleanUp:

    if (g_ScriptFile.FileBuffer) {
        free(g_ScriptFile.FileBuffer);
    }

    if (ansiFile) {
        free(ansiFile);
    }

    return FALSE;
}



USHORT
SoftPCI_StringToUSHORT(
    IN PWCHAR String
    )
{

    WCHAR numbers[] = L"0123456789abcdef";
    PWCHAR p1, p2;
    USHORT convertedValue = 0;
    BOOLEAN converted = FALSE;
    
    p1 = numbers;
    p2 = String;

    while (*p2) {

        while (*p1 && (converted == FALSE)) {

            if (*p1 == *p2) {
                
                //
                //  Reset our pointer
                //
                convertedValue <<= 4;
                
                convertedValue |= (((UCHAR)(p1 - numbers)) & 0x0f);

                converted = TRUE;
            }
            p1++;
        }

        if (converted == FALSE) {
            //
            //  Encountered something we couldnt convert.  Return what we have
            //
            return convertedValue;
        }

        p2++;
        p1 = numbers;
        converted = FALSE;
    }

    return convertedValue;
}

BOOL
SoftPCI_ValidatePciPath(
    IN PWCHAR PciPath
    )
{

    ULONG pathLength = wcslen(PciPath);
    ULONG validSize = pathLength;
    PWCHAR pciPath = PciPath;
    PWCHAR p1, p2;
    WCHAR validChars[] = L"0123456989abcdef\\";
    BOOLEAN valid = FALSE;
    
    //
    //  First ignore any pre and ending "\"
    //
    //if (*pciPath == '\\'){
    //    validSize -= 1;
    //}

    //if (*(pciPath+pathLength) == '\\'){
    //    validSize -= 1;
    //}

    //
    //  Now see if everything looks good size wise.
    //
    if (((validSize - 4) % 5) != 0) {
        SoftPCI_Debug(SoftPciScript, L"  Path size invalid!\n");
        return FALSE;
    }
    
    //
    //  Make sure all characters are legal.
    //
    p1 = PciPath;
    
    while (*p1) {

        p2 = validChars;
        while (*p2) {

            if (*p1 == *p2) {
                valid = TRUE;
                break;
            }
            p2++;
        }

        if (!valid) {
            SoftPCI_Debug(SoftPciScript, L"  Invalid character encounter in ParentPath!\n");
            return FALSE;
        }
        
        p1++;
        valid = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\dialog.h ===
extern HWND g_DevPropDlg;
extern HWND g_NewDevDlg;


#define DISPLAY_NEWDEV_DLG(param)   \
    DialogBoxParam(g_Instance, MAKEINTRESOURCE(IDD_INSTALLDEV), g_SoftPCIMainWnd, \
                   SoftPCI_NewDevDlgProc, (LPARAM)param);
                   
/*
#define DISPLAY_PROPERTIES_DLG(param)   \
    DialogBoxParam(g_Instance, MAKEINTRESOURCE(IDD_DEVPROP), NULL, \
                   SoftPCI_DevicePropDlgProc, (LPARAM)param);


INT_PTR
CALLBACK
SoftPCI_DevicePropDlgProc( 
    IN HWND Dlg,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam 
    );*/

INT_PTR
CALLBACK
SoftPCI_NewDevDlgProc( 
    IN HWND Dlg,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam 
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\install.c ===
#include "pch.h"

#define SOFTPCI_FILTER_SECTION          L"SOFTPCI_DRV.Services"
#define SOFTPCI_FILTER_SERVICE_NAME     L"SoftPCI"
//#define SOFTPCIDRV                      L"softpci"

typedef enum{
    DriverInf = 0,
    DriverCat,
    DriverSoftPci,
    DriverHpSim,
    DriverShpc,
    DriverUnknown
} IMAGE_TYPE;

BOOL 
_lwritef(
    IN HANDLE hFile,
    IN PTSTR Format, 
    ...);

BOOL 
SoftPCI_ExpandResourceFile(
    IN LPTSTR DriverPath, 
    IN LPTSTR ResName
    );

BOOL
SoftPCI_ExtractImageToDrive(
    IN IMAGE_TYPE ImageType
    );

BOOL
SoftPCI_InstallFilterKey(
    IN DEVNODE RootBus
    );

BOOL
SoftPCI_InstallDriverInf(
    VOID
    );

VOID
SoftPCI_LocateRootPciBusesForInstall(
    IN PPCI_DN  Pdn,
    OUT PBOOL   Success
    );

BOOL
SoftPCI_RebootSystem(
    VOID
    );

BOOL
SoftPCI_InstallDriver(VOID){
    
    BOOL        success = TRUE;
    INT         infLen = 0, reboot = IDNO;
    IMAGE_TYPE  imageType;
    WCHAR       winDir[MAX_PATH];
    WCHAR       infPath[MAX_PATH];
    
    
    //
    //  Spit out our images....
    //
    for (imageType = DriverInf; imageType < DriverUnknown; imageType++ ) {

        if (!SoftPCI_ExtractImageToDrive(imageType)){
            return FALSE;
        }
    }

    //
    //  We need a service key
    //
    if (!SoftPCI_InstallDriverInf()) {
        //
        //  Failed to install our service key
        //
        return FALSE;
    }

    //
    //  Now we need to update each root buses reg data
    //
    SoftPCI_LocateRootPciBusesForInstall(g_PciTree->RootDevNode, &success);

    SoftPCI_InitializeRegistry();

    if (success) {
        
        reboot = MessageBox(g_SoftPCIMainWnd, 
                            L"SoftPCI Support is now installed and your system must be rebooted. OK to reboot?",
                            L"Install Complete",
                            MB_YESNO
                            );

        if (reboot == IDYES) {
            return SoftPCI_RebootSystem();
        }
    }
    
    return success;
    
}

BOOL 
SoftPCI_ExpandResourceFile(
    IN LPTSTR DriverPath, 
    IN LPTSTR ResName
    )
/*++

Routine Description:

    This routine was stolen from DVNT to expand our driver out of our *.exe so it can be installed.
    
Arguments:

    DriverPath - count of arguments
    ResName - arguments from the command line

Return Value:

    none

--*/
{
   HGLOBAL  obj;
   HRSRC    resource;
   LPTSTR   lpStr;
   INT      size;
   BOOL     success = FALSE;

   if ((resource = FindResource(NULL, ResName, RT_RCDATA))) {
      
       if ((obj = LoadResource(NULL,resource))) {

         if ((lpStr = (LPTSTR)LockResource(obj)) ) {        

            HANDLE file;
            DWORD written;

            size = SizeofResource(NULL, resource);
             
            if ((file = CreateFile(DriverPath,
                                   GENERIC_WRITE,
                                   0,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL
                                   )) != INVALID_HANDLE_VALUE) {

                if (WriteFile(file,
                              lpStr,
                              size,
                              &written,
                              NULL
                              )) {
                  
                    success = TRUE ;
                 }

               CloseHandle(file);

              }

            UnlockResource(obj);

           }
        }
     }
   
   return success;
}


BOOL
SoftPCI_ExtractImageToDrive(
    IN IMAGE_TYPE ImageType
    )
{


    WCHAR   imagePath[MAX_PATH];
    WCHAR   winDir[MAX_PATH];
   
    if (GetWindowsDirectory(winDir, MAX_PATH)==0) return FALSE ;

    wcscat(winDir, L"\\pcisim");
    
    CreateDirectory(winDir, NULL);

    switch (ImageType) {
    
    case DriverInf:
        wsprintf(imagePath, L"%s\\softpci.inf", winDir);
        return SoftPCI_ExpandResourceFile(imagePath, L"InfDriverResource");
        break;

    case DriverCat:
        wsprintf(imagePath, L"%s\\delta.cat", winDir);
        return SoftPCI_ExpandResourceFile(imagePath, L"CatalogDriverResource");
        break;

    case DriverSoftPci:
        
        //
        //
        //  OK softpci.sys needs to be treated special as it is 
        //  not installed by normal means (as a filter).  Therefore, we need
        //  to make sure it exists in both our media source location as well
        //  as the \system32\drivers directory.
        //
        //
        wsprintf(imagePath, L"%s\\softpci.sys", winDir);
        
        if (SoftPCI_ExpandResourceFile(imagePath, L"SoftPciDriverResource")) {

            WCHAR   driverDir[MAX_PATH];
            ULONG   i;
          
            //
            //  Save our current media source image path
            //
            wcscpy(driverDir, imagePath);

            //
            //  now remove the \\pcisim
            //
            for (i = wcslen(winDir); i > 0 && winDir[i] != '\\'; i--);
            winDir[i] = 0;
            
            //
            //  Build our new image path
            //
            wsprintf(imagePath, L"%s\\system32\\drivers\\softpci.sys", winDir);

            return CopyFile(driverDir, imagePath, FALSE);
        }
        
        return FALSE;
        break;

    case DriverHpSim:
        wsprintf(imagePath, L"%s\\hpsim.sys", winDir);
        return SoftPCI_ExpandResourceFile(imagePath, L"HpSimDriverResource");
        break;

    case DriverShpc:
        wsprintf(imagePath, L"%s\\shpc.sys", winDir);
        return SoftPCI_ExpandResourceFile(imagePath, L"ShpcDriverResource");
        break;
    default:
        return FALSE;
    }


}



BOOL
SoftPCI_InstallDriverInf(
    VOID
    )
/*++

Routine Description:

    This routine takes the INF we created and installs the Services section

Arguments:

    InfPath - Path to the INF we created

Return Value:

    TRUE if success

--*/
{

    HINF    infHandle;
    UINT    errorLine, i;
    WCHAR   infPath[MAX_PATH];
    WCHAR   winDir[MAX_PATH];

    
    if (GetWindowsDirectory(winDir, MAX_PATH)==0) return FALSE ;

    wcscat(winDir, L"\\pcisim");

    wsprintf(infPath, L"%s\\softpci.inf", winDir);
    
    infHandle = SetupOpenInfFile(infPath, NULL, INF_STYLE_WIN4, &errorLine);
    
    if (infHandle == INVALID_HANDLE_VALUE) {
        SoftPCI_Debug(SoftPciInstall, L"InstallDriverInf - failed open inf. Error = \"%s\"\n", SoftPCI_GetLastError());
        return FALSE;
    }

    if (!SetupInstallServicesFromInfSection(infHandle, SOFTPCI_FILTER_SECTION, 0)){
        SoftPCI_Debug(SoftPciInstall, L"InstallDriverInf - failed to install service key. Error = \"%s\"\n", SoftPCI_GetLastError());
        return FALSE;
    }

    SetupCloseInfFile(infHandle);
    
    return SetupCopyOEMInf(infPath, 
                           winDir, 
                           SPOST_PATH,
                           SP_COPY_DELETESOURCE,
                           NULL,
                           0,
                           NULL,
                           NULL
                           );


}

BOOL
SoftPCI_InstallFilterKey(
    IN DEVNODE RootBus
    )
/*++

Routine Description:

    This routine takes updates or adds the LowerFilters Key to the registry
    so that our driver is loaded each boot    

Arguments:

    RootBus -  the devnode for the root bus we want to filter

Return Value:
    
    TRUE if success

--*/
{

   BOOL                 status = FALSE;
   PWCHAR               buffer = NULL, newBuffer, entry = NULL, entry2 = NULL;
   DWORD                requiredSize = 0, size = ((wcslen(SOFTPCI_FILTER_SERVICE_NAME)+1) * sizeof(WCHAR));
   CONFIGRET            cr = CR_SUCCESS;
   
   //
   //   First call is to get required buffer size
   //
   if ((cr = CM_Get_DevNode_Registry_Property(RootBus,               //Devnode
                                              CM_DRP_LOWERFILTERS,   //Reg Propert
                                              NULL,                  //REG data type
                                              NULL,                  //Buffer
                                              &requiredSize,         //Buffer size
                                              0                      //flags
                                              )) != CR_SUCCESS){
       if (cr == CR_NO_SUCH_VALUE) {
           
           //
           //   No filter.  Add ours.
           //
           if ((cr = CM_Set_DevNode_Registry_Property(RootBus,
                                                      CM_DRP_LOWERFILTERS,
                                                      (PVOID)SOFTPCI_FILTER_SERVICE_NAME, 
                                                      size, 
                                                      0
                                                      )) != CR_SUCCESS){
               return FALSE;
           }
           
           return TRUE;
       }
       
       //
       //   If there is already a filter key, then we need to append to it
       //
       if (requiredSize) {

           buffer = (PWCHAR) calloc(1, requiredSize);

           if (buffer == NULL) {
               return FALSE;
           }

           //
           //  Call again and get the current filter value
           //
           if ((CM_Get_DevNode_Registry_Property(RootBus,
                                                 CM_DRP_LOWERFILTERS,
                                                 NULL,
                                                 buffer,
                                                 &requiredSize,
                                                 0
                                                 )) != CR_SUCCESS){
               status = FALSE;
               goto cleanup;
           }

           newBuffer = (PWCHAR) calloc(1, (requiredSize + size));

           if (newBuffer == NULL) {
               return FALSE;
           }

           entry2 = newBuffer;

           //
           //   Run the list. If we are already present bail
           //
           for (entry = buffer; *entry; entry += (wcslen(entry)+1)) {
           
               if (wcscmp(entry, SOFTPCI_FILTER_SERVICE_NAME) == 0) {
                   //
                   //   We are already installed
                   //
                   MessageBox(NULL, L"SoftPCI driver support already installed!", L"Install Error", MB_OK);
                   status = FALSE;
                   goto cleanup;
               }

               //
               //   copy each entry to our new list
               //
               wcscpy(entry2, entry);

               entry2 += (wcslen(entry)+1);
           }
           
           //
           //   Add our entry to the list
           //
           wcscpy(entry2, SOFTPCI_FILTER_SERVICE_NAME);

           if ((cr = CM_Set_DevNode_Registry_Property(RootBus,
                                                      CM_DRP_LOWERFILTERS,
                                                      newBuffer, 
                                                      requiredSize + size, 
                                                      0
                                                      )) != CR_SUCCESS){
               
               status = FALSE;
               goto cleanup;
           }

           status = TRUE;
           goto cleanup;

       }

       //
       //   Failed to get required size
       //
       
    
   }
#ifdef DEBUG
   else{
       
       SOFTPCI_ASSERT(FALSE);
       //
       // VERY BAD!! Should never get back success here!
       //

   }
#endif

cleanup:

    if (buffer) {
        free(buffer);
    }

    if (newBuffer) {
        free(newBuffer);
    }
   
   return status;
}

VOID
SoftPCI_LocateRootPciBusesForInstall(
    IN PPCI_DN  Pdn,
    OUT PBOOL   Success
    )
/*++

Routine Description:

    This routine searches our tree for all root pci buses and then installs
    our filter on them
    
Arguments:

    RootBus - Location to return first root bus.

Return Value:

    TRUE if success.

--*/
{
    PPCI_DN     child, sibling;
    
    if (Pdn == NULL) {
        *Success = FALSE;
        return;
    }

    child = Pdn->Child;
    sibling = Pdn->Sibling;
    
    if (SoftPCI_IsDevnodePCIRoot(Pdn->DevNode, FALSE)) {
        *Success = SoftPCI_InstallFilterKey(Pdn->DevNode);

        if (*Success) {
            SoftPCI_UpdateDeviceFriendlyName(Pdn->DevNode, SOFTPCI_BUS_DESC);
        }
    }

    if (*Success && child) {
        SoftPCI_LocateRootPciBusesForInstall(child, Success);
    }
    
    if (*Success && sibling) {
        SoftPCI_LocateRootPciBusesForInstall(sibling, Success);
    }

}


BOOL
SoftPCI_RebootSystem(
    VOID
    )
{
    HANDLE token;
    TOKEN_PRIVILEGES tp;
    LUID luid;

    if (!OpenProcessToken(GetCurrentProcess(), 
                          (TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY), 
                          &token)){ 
        return FALSE;
    }
                
    if (!LookupPrivilegeValue(NULL,
                              SE_SHUTDOWN_NAME,
                              &luid)) {
        return FALSE; 
    }
    
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    
    AdjustTokenPrivileges(token, 
                          FALSE, 
                          &tp, 
                          sizeof(TOKEN_PRIVILEGES), 
                          (PTOKEN_PRIVILEGES) NULL, 
                          (PDWORD) NULL
                          ); 
   
    
    if (GetLastError() != ERROR_SUCCESS) { 
        return FALSE; 
    }

    //
    //  We should now be able to reboot the system.
    //
    return InitiateSystemShutdown(NULL, NULL, 0, TRUE, TRUE);

}

#if 0

BOOL 
_lwritef(
    IN HANDLE hFile,
    IN PTSTR Format, 
    ...)
/*++

Routine Description:

    This routine provides "fprintf" like functionality. (code stolen from DVNT)

Arguments:

    hFile - Handle to INF file
    Format - String of data to be formatted and written

Return Value:

    FALSE if no failures.

--*/
{
   va_list  arglist;
   WCHAR    buffer[514];
   INT      cb;
   DWORD    written;

   va_start(arglist, Format);

   cb = wvsprintf(buffer, Format, arglist);
   if (cb == -1) // handle buffer overflow
     {
      cb = sizeof(buffer) ;
     }
   else 
     {
      cb+=2 ;
     }
   lstrcpy(buffer+cb-2, TEXT("\r\n")) ;

   return (WriteFile(hFile,
                     buffer,
                     cb*sizeof(WCHAR),
                     &written,
                     NULL
                     ));

}


BOOL
SoftPCI_CreateDriverINF(
    IN LPTSTR InfPath
    )
/*++

Routine Description:

    This routine build our INF file needed to install our SoftPCI devices.
    
Arguments:
    
       InfPath = Path to INF we need to create

Return Value:

    TRUE if successful.

--*/
{

    BOOL        result = TRUE;
    HANDLE      hFile;
    SYSTEMTIME  systime;

    GetLocalTime(&systime);

    if ((hFile = CreateFile(InfPath,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           )) == INVALID_HANDLE_VALUE) {

       return FALSE;
   }

    result &= _lwritef(hFile, TEXT("[Version]"));
    result &= _lwritef(hFile, TEXT("Signature=\"$WINDOWS NT$\""));
    result &= _lwritef(hFile, TEXT("Class=System"));
    result &= _lwritef(hFile, TEXT("ClassGuid={4D36E97D-E325-11CE-BFC1-08002BE10318}"));
    result &= _lwritef(hFile, TEXT("Provider=%%MSFT%%"));
    result &= _lwritef(hFile, TEXT("LayoutFile=layout.inf"));
    
    result &= _lwritef(hFile, 
                       TEXT("DriverVer=%02d/%02d/%04d,5.1.%d.0\r\n"), 
                       systime.wMonth,
                       systime.wDay,
                       systime.wYear,
                       VER_PRODUCTBUILD);
    
    result &= _lwritef(hFile, TEXT("[DestinationDirs]"));
    result &= _lwritef(hFile, TEXT("DefaultDestDir = 12\r\n"));
    
    result &= _lwritef(hFile, TEXT("[Manufacturer]"));
    result &= _lwritef(hFile, TEXT("%%GENDEV_MFG%%=GENDEV_SYS\r\n"));

    result &= _lwritef(hFile, TEXT("[GENDEV_SYS]"));
    result &= _lwritef(hFile, TEXT("%%VEN_ABCD&DEV_DCBA.DeviceDesc%% = SOFTPCI_FDO_Install, PCI\\VEN_ABCD&DEV_DCBA&SUBSYS_DCBAABCD"));
    result &= _lwritef(hFile, TEXT("%%VEN_ABCD&DEV_DCBC.DeviceDesc%% = HPPCI_DRV, PCI\\VEN_ABCD&DEV_DCBC\r\n"));
    
    result &= _lwritef(hFile, TEXT(";****************************************************"));
    result &= _lwritef(hFile, TEXT("; SoftPci filter"));
    result &= _lwritef(hFile, TEXT("[%s]"), SOFTPCI_FILTER_SECTION);
    result &= _lwritef(hFile, TEXT("AddService = %s,0,softpci_ServiceInstallSection\r\n"), SOFTPCI_FILTER_SERVICE_NAME);

    result &= _lwritef(hFile, TEXT("[softpci_ServiceInstallSection]"));
    result &= _lwritef(hFile, TEXT("DisplayName    = %%softpci_filterdesc%%"));
    result &= _lwritef(hFile, TEXT("ServiceType    = %%SERVICE_KERNEL_DRIVER%%"));
    result &= _lwritef(hFile, TEXT("StartType      = %%SERVICE_BOOT_START%%"));
    result &= _lwritef(hFile, TEXT("ErrorControl   = %%SERVICE_ERROR_NORMAL%%"));
    result &= _lwritef(hFile, TEXT("ServiceBinary  = %%12%%\\%s.sys\r\n"), SOFTPCIDRV);

    result &= _lwritef(hFile, TEXT(";****************************************************"));
    result &= _lwritef(hFile, TEXT("; SoftPci function driver"));
    result &= _lwritef(hFile, TEXT("[SOFTPCI_FDO_Install]"));
    result &= _lwritef(hFile, TEXT("CopyFiles=%s.sys\r\n"), SOFTPCIDRV);

    result &= _lwritef(hFile, TEXT("[SOFTPCI_FDO_Install.Services]"));
    result &= _lwritef(hFile, TEXT("AddService = SoftPCI_FDO,0x000001fa,SOFTPCI_FDO_ServiceInstallSection\r\n"));

    result &= _lwritef(hFile, TEXT("[SOFTPCI_FDO_ServiceInstallSection]"));
    result &= _lwritef(hFile, TEXT("DisplayName    = %%softpci_fdodesc%%"));
    result &= _lwritef(hFile, TEXT("ServiceType    = %%SERVICE_KERNEL_DRIVER%%"));
    result &= _lwritef(hFile, TEXT("StartType      = %%SERVICE_DEMAND_START%%"));
    result &= _lwritef(hFile, TEXT("ErrorControl   = %%SERVICE_ERROR_NORMAL%%"));
    result &= _lwritef(hFile, TEXT("ServiceBinary  = %%12%%\\%s.sys\r\n"), SOFTPCIDRV);

    result &= _lwritef(hFile, TEXT(";****************************************************"));
    result &= _lwritef(hFile, TEXT("; Hotplug Controller simulator and driver"));
    result &= _lwritef(hFile, TEXT("[HPPCI_DRV]"));
    result &= _lwritef(hFile, TEXT("CopyFiles=HPPCI.CopyFiles\r\n"));
    
    result &= _lwritef(hFile, TEXT("[HPPCI_DRV.HW]"));
    result &= _lwritef(hFile, TEXT("AddReg = HPPCI_Filter_Reg\r\n"));

    result &= _lwritef(hFile, TEXT("[HPPCI_DRV.Services]"));
    result &= _lwritef(hFile, TEXT("AddService = hpsim,0,hpsim_ServiceInstallSection"));
    result &= _lwritef(hFile, TEXT("AddService = shpc,0,shpc_ServiceInstallSection"));
    result &= _lwritef(hFile, TEXT("AddService = pci, %%SPSVCINST_ASSOCSERVICE%%, pci_ServiceInstallSection\r\n"));

    result &= _lwritef(hFile, TEXT("[HPPCI_Filter_Reg]"));
    result &= _lwritef(hFile, TEXT("HKR,,\"LowerFilters\", 0x00010000,\"hpsim\""));
    result &= _lwritef(hFile, TEXT("HKR,,\"UpperFilters\", 0x00010000,hpsim,shpc\r\n"));
    
    result &= _lwritef(hFile, TEXT("[HPPCI.CopyFiles]"));
    result &= _lwritef(hFile, TEXT("hpsim.sys"));
    result &= _lwritef(hFile, TEXT("shpc.sys\r\n"));

    result &= _lwritef(hFile, TEXT("[hpsim_ServiceInstallSection]"));
    result &= _lwritef(hFile, TEXT("DisplayName 	= %%hpsim_svcdesc%%"));
    result &= _lwritef(hFile, TEXT("ServiceType    = %%SERVICE_KERNEL_DRIVER%%"));
    result &= _lwritef(hFile, TEXT("StartType      = %%SERVICE_DEMAND_START%%"));
    result &= _lwritef(hFile, TEXT("ErrorControl   = %%SERVICE_ERROR_NORMAL%%"));
    result &= _lwritef(hFile, TEXT("ServiceBinary  = %%12%%\\hpsim.sys\r\n"));

    result &= _lwritef(hFile, TEXT("[shpc_ServiceInstallSection]]"));
    result &= _lwritef(hFile, TEXT("DisplayName 	= %%shpc_svcdesc%%"));
    result &= _lwritef(hFile, TEXT("ServiceType    = %%SERVICE_KERNEL_DRIVER%%"));
    result &= _lwritef(hFile, TEXT("StartType      = %%SERVICE_DEMAND_START%%"));
    result &= _lwritef(hFile, TEXT("ErrorControl   = %%SERVICE_ERROR_NORMAL%%"));
    result &= _lwritef(hFile, TEXT("ServiceBinary  = %%12%%\\shpc.sys\r\n"));

    result &= _lwritef(hFile, TEXT(";****************************************************"));
    result &= _lwritef(hFile, TEXT(";Device descriptions"));
    result &= _lwritef(hFile, TEXT("[Strings]"));
    result &= _lwritef(hFile, TEXT("GENDEV_MFG = \"(Standard system devices)\""));
    result &= _lwritef(hFile, TEXT("SystemClassName = \"System devices\""));
    result &= _lwritef(hFile, TEXT("MSFT            = \"Microsoft\""));

    result &= _lwritef(hFile, TEXT("VEN_ABCD&DEV_DCBA.DeviceDesc = \"%s\""), SOFTPCI_DEVICE_DESC);
    result &= _lwritef(hFile, TEXT("VEN_ABCD&DEV_DCBC.DeviceDesc = \"%s\"\r\n"),  SOFTPCI_HOTPLUG_DESC);

    result &= _lwritef(hFile, TEXT(";****************************************************"));
    result &= _lwritef(hFile, TEXT(";Service descriptions"));
    result &= _lwritef(hFile, TEXT("softpci_fdodesc = \"Microsoft SoftPCI Device Driver\""));
    result &= _lwritef(hFile, TEXT("softpci_filterdesc = \"Microsoft SoftPCI Bus Filter\""));
    result &= _lwritef(hFile, TEXT("hpsim_svcdesc = \"Hotplug Controller Simulator Filter\""));
    result &= _lwritef(hFile, TEXT("shpc_svcdesc = \"Hotplug Controller Bus Filter\"\r\n"));

    result &= _lwritef(hFile, TEXT(";****************************************************"));
    result &= _lwritef(hFile, TEXT(";Handy macro substitutions (non-localizable)"));
    result &= _lwritef(hFile, TEXT("SPSVCINST_ASSOCSERVICE = 0x00000002"));
    result &= _lwritef(hFile, TEXT("SERVICE_KERNEL_DRIVER  = 1"));
    result &= _lwritef(hFile, TEXT("SERVICE_BOOT_START     = 0"));
    result &= _lwritef(hFile, TEXT("SERVICE_DEMAND_START   = 3"));
    result &= _lwritef(hFile, TEXT("SERVICE_ERROR_NORMAL   = 1"));
    result &= _lwritef(hFile, TEXT("SERVICE_ERROR_CRITICAL = 3"));

    
    CloseHandle(hFile);

    return result;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\device.h ===
#ifndef _SOFTPCIDEVICEH_
#define _SOFTPCIDEVICEH_


#define SoftPCI_GetCurrentConfigSpace(pdn, commonConfig)    \
    SoftPCI_ReadWriteConfigSpace(pdn,                       \
                                 0,                         \
                                 sizeof(PCI_COMMON_CONFIG), \
                                 commonConfig,              \
                                 FALSE                      \
                                 )


BOOL
SoftPCI_GetSlotPathList(
    IN PPCI_DN Pdn,
    OUT PULONG SlotCount, 
    OUT PLIST_ENTRY SlotPathList
    );

BOOL
SoftPCI_GetDevicePathList(
    IN PPCI_DN Pdn,
    OUT PLIST_ENTRY DevicePathList
    );

VOID
SoftPCI_DestroySlotPathList(
    PLIST_ENTRY SlotPathList
    );

PWCHAR
SoftPCI_GetPciPathFromDn(
    IN PPCI_DN Pdn
    );

VOID
SoftPCI_EnumerateDevices(
    IN PPCI_TREE PciTree,
    IN PPCI_DN *Pdn,
    IN DEVNODE Dn,
    IN PPCI_DN Parent
    );

BOOL
SoftPCI_EnumerateHotplugDevices(
    IN PPCI_TREE PciTree,
    IN PPCI_DN ControllerDevnode
    );

VOID
SoftPCI_AddChild(
    IN PPCI_DN Parent,
    IN PPCI_DN Child
    );

VOID
SoftPCI_BringHotplugDeviceOnline(
    IN PPCI_DN PciDn,
    IN UCHAR SlotNumber
    );

VOID
SoftPCI_TakeHotplugDeviceOffline(
    IN PPCI_DN PciDn,
    IN UCHAR SlotNumber
    );

ULONGLONG
SoftPCI_GetLengthFromBar(
    ULONGLONG BaseAddressRegister
    );

VOID
SoftPCI_CompletePciDevNode(
    IN PPCI_DN Pdn
    );        

HANDLE
SoftPCI_OpenHandleToDriver(
    VOID
    );

BOOL
SoftPCI_IsBridgeDevice(
    IN PPCI_DN Pdn
    );

BOOL
SoftPCI_IsSoftPCIDevice(
    IN PPCI_DN Pdn
    );

BOOL
SoftPCI_IsDevnodePCIRoot(
    IN DEVNODE Dn,
    IN BOOL ValidateAll
    );

BOOL
SoftPCI_UpdateDeviceFriendlyName(
    IN DEVNODE DeviceNode,
    IN PWCHAR NewName
    );

VOID
SoftPCI_InitializeDevice(
    IN PSOFTPCI_DEVICE Device,
    IN SOFTPCI_DEV_TYPE Type
    );

VOID
SoftPCI_InstallScriptDevices(
    VOID
    );

BOOL
SoftPCI_CreateDevice(
    IN PVOID CreateDevice,
    IN ULONG PossibleDeviceMask,
    IN BOOL PathBasedDevice
    );

BOOL
SoftPCI_DeleteDevice(
    IN PSOFTPCI_DEVICE Device
    );

BOOL
SoftPCI_ReadWriteConfigSpace(
    IN PPCI_DN Device,
    IN ULONG Offset,
    IN ULONG Length,
    IN OUT PVOID Buffer,
    IN BOOL WriteConfig
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\softpciui.h ===
#ifndef _SOFTPCIUI_
#define _SOFTPCIUI_

#define SOFTPCI_BUS_DESC        L" - SoftPCI Installed"
#define SOFTPCI_DEVICE_DESC     L"Microsoft SoftPCI Device"
#define SOFTPCI_PPBRIDGE_DESC   L"Microsoft SoftPCI-PCI Bridge"
#define SOFTPCI_HOTPLUG_DESC    L"Microsoft SoftPCI-HotPlug PCI Bridge"

typedef struct _PCI_DN *PPCI_DN;

typedef struct _PCI_TREE
{
    PPCI_DN                 RootDevNode;
    HTREEITEM               RootTreeItem;
    HDEVINFO                DevInfoSet;
    SP_CLASSIMAGELIST_DATA  ClassImageListData ;

} PCI_TREE, *PPCI_TREE;

//
//  PCI Devnode Info
//

//
// Flags bit definitions
//
#define SOFTPCI_HOTPLUG_SLOT 0x1
#define SOFTPCI_UNENUMERATED_DEVICE 0x2
#define SOFTPCI_HOTPLUG_CONTROLLER 0x4

typedef struct _PCI_DN
{
   PPCI_TREE            PciTree;
   PPCI_DN              Parent;
   PPCI_DN              Child;
   PPCI_DN              Sibling;
   LIST_ENTRY           ListEntry;
   DEVNODE              DevNode;

   ULONG                Bus;
   SOFTPCI_SLOT         Slot;
   PSOFTPCI_DEVICE      SoftDev;
   ULONG                Flags;
   
   WCHAR                DevId[MAX_PATH];
   WCHAR                FriendlyName[MAX_PATH];
   WCHAR                WmiId[MAX_PATH];
   SP_DEVINFO_DATA      DevInfoData;

} PCI_DN, *PPCI_DN ;

typedef struct _SLOT_PATH_ENTRY{
    LIST_ENTRY ListEntry;
    SOFTPCI_SLOT Slot;
} SLOT_PATH_ENTRY, *PSLOT_PATH_ENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\spciwmi.h ===
#ifndef _SPCIWMI_
#define _SPCIWMI_

BOOL
SoftPCI_AllocWmiInstanceName(
    OUT PWCHAR WmiInstanceName,
    IN PWCHAR DeviceId
    );

BOOL
SoftPCI_AllocWnodeSI(
    IN PPCI_DN Pdn,
    IN LPGUID Guid,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PWNODE_SINGLE_INSTANCE *WnodeForBuffer
    );

BOOL
SoftPCI_SetEventContext(
    IN PPCI_DN ControllerDevnode
    );

BOOL
SoftPCI_GetHotplugData(
    IN PPCI_DN          ControllerDevnode,
    IN PHPS_HWINIT_DESCRIPTOR HpData
    );

BOOL
SoftPCI_ExecuteHotplugSlotMethod(
    IN PPCI_DN ControllerDevnode,
    IN UCHAR SlotNum,
    IN HPS_SLOT_EVENT_TYPE EventType
    );

BOOL
SoftPCI_AddHotplugDevice(
    IN PPCI_DN ControllerDevnode,
    IN PSOFTPCI_DEVICE Device
    );

BOOL
SoftPCI_RemoveHotplugDevice(
    IN PPCI_DN ControllerDevnode,
    IN UCHAR SlotNum
    );

BOOL
SoftPCI_GetHotplugDevice(
    IN PPCI_DN ControllerDevnode,
    IN UCHAR SlotNum,
    OUT PSOFTPCI_DEVICE Device
    );

BOOL
SoftPCI_GetSlotStatus(
    IN PPCI_DN ControllerDevnode,
    IN UCHAR SlotNum,
    OUT PSHPC_SLOT_STATUS_REGISTER StatusReg
    );

VOID
SoftPCI_CompleteCommand(
    IN PPCI_DN ControllerDevnode
    );

VOID
SoftPCI_RegisterHotplugEvents(
    VOID
    );

VOID
SoftPCI_HotplugEventCallback(
    IN PWNODE_HEADER WnodeHeader,
    IN ULONG Context
    );

#define EQUAL_GUID(a,b) (RtlEqualMemory(a,b,sizeof(GUID)))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\spciwnd.h ===
#ifndef _SOFTPCIWNDH_
#define _SOFTPCIWNDH_

extern HINSTANCE g_Instance;
extern const TCHAR g_SoftPCIMainClassName[];

extern HWND     g_SoftPCIMainWnd;
extern HWND     g_TreeViewWnd;
extern HWND     g_SoftPCITreeWnd;
extern INT      g_PaneSplit;
extern HANDLE   g_DriverHandle;


HWND
SoftPCI_CreateMainWnd(
    VOID
    );

LRESULT
WINAPI
SoftPCI_MainWndProc(
    IN HWND hWnd, 
    IN UINT Message, 
    IN WPARAM wParam, 
    IN LPARAM lParam
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\spcimain.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    spcimain.c

Abstract:

    This module contains the main entry point for the user mode portion of SoftPCI

Author:

    Brandon Allsop (BrandonA)

Revision History:


--*/

#include "pch.h"


BOOL
SoftPCI_RegisterClasses(
    VOID
    );

VOID
SoftPCI_ParseArgs( 
    IN PWCHAR ArgList
    );

//  Instance handle of this application.
HINSTANCE   g_Instance;
HWND        g_SoftPCIMainWnd;
HWND        g_TreeViewWnd;
HANDLE      g_DriverHandle;

const WCHAR g_SoftPCIMainClassName[] = L"SoftPciMainClass";
const WCHAR g_SoftPCIDevPropClassName[] = L"SoftPciDevPropClass";


INT
APIENTRY
WinMain(
    IN HINSTANCE Instance,
    IN HINSTANCE PrevInstance,
    IN LPSTR     CmdLine,
    IN INT       CmdShow
    )
{
    MSG msg;
    HWND popupWnd;
    PSINGLE_LIST_ENTRY listEntry;
    
    g_Instance = Instance;

    InitCommonControls();

    if ((g_SoftPCIMainWnd = FindWindow(g_SoftPCIMainClassName, NULL)) != NULL){

        if (IsIconic(g_SoftPCIMainWnd)){

            ShowWindow(g_SoftPCIMainWnd, SW_RESTORE);

        }else {

            BringWindowToTop(g_SoftPCIMainWnd);

            if ((popupWnd = GetLastActivePopup(g_SoftPCIMainWnd)) != g_SoftPCIMainWnd)
                BringWindowToTop(popupWnd);

            SetForegroundWindow(popupWnd);
        }
        return 0;
    }

    if (!SoftPCI_RegisterClasses()) return 0;

    //
    // Register for hotplug driver event notification
    //
    SoftPCI_RegisterHotplugEvents();

    //
    //  Try and open a handle to our driver.  If this fails then the user will have the
    //  option from the "OPTIONS" menu to install SoftPCI support.  If we succeed then we
    //  disable this option.
    //
    g_DriverHandle = SoftPCI_OpenHandleToDriver();

    //
    // The command line is supplied in ANSI format only at the WinMain entry
    // point.  When running in UNICODE, we ask for the command line in UNICODE from
    // Windows directly.
    //
    SoftPCI_ParseArgs(GetCommandLine());

    //
    //  If we have any script devices to install then do so now.
    //
    SoftPCI_InstallScriptDevices();

    if ((g_SoftPCIMainWnd = SoftPCI_CreateMainWnd()) != NULL){

        UpdateWindow(g_SoftPCIMainWnd);

        while (GetMessage(&msg, NULL, 0, 0)) {

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return 0;
}

BOOL
SoftPCI_RegisterClasses(VOID)
/*++

Routine Description:

    Registers SoftPCI main window class

Arguments:

    none

Return Value:

    TRUE on success

--*/
{

    WNDCLASS wndClass;

    wndClass.style = CS_DBLCLKS | CS_BYTEALIGNWINDOW | CS_GLOBALCLASS;
    wndClass.lpfnWndProc = SoftPCI_MainWndProc;
    wndClass.cbClsExtra = 0;
    wndClass.cbWndExtra = 0;
    wndClass.hInstance = g_Instance;
    wndClass.hIcon = LoadIcon(g_Instance, MAKEINTRESOURCE(IDI_SPCI));
    wndClass.hCursor = LoadCursor(g_Instance, MAKEINTRESOURCE(IDC_SPLIT));
    wndClass.hbrBackground = (HBRUSH) (COLOR_3DSHADOW + 1);
    //WndClass.hbrBackground = (HBRUSH) (COLOR_3DFACE + 1);
    wndClass.lpszMenuName = MAKEINTRESOURCE(IDM_SPCI);
    wndClass.lpszClassName = g_SoftPCIMainClassName;
  
    return RegisterClass(&wndClass);

}


VOID
SoftPCI_ParseArgs( 
    IN PWCHAR CommandLine
    )
/*++

Routine Description:

    This routine takes our command line information and parses out what we care about.
    
Arguments:

    CommandLine - Null terminated string containing out command line
    
Return Value:

    TRUE if we have args that allow us to continue running

--*/
{
    PWCHAR  p = CommandLine, p2 = NULL;
    WCHAR   pathToIni[MAX_PATH];
    
    //
    //  First make sure everything is lowercase
    //
    _wcslwr(CommandLine);

    if (((p = wcsstr(CommandLine, L"-s")) != NULL) ||
        ((p = wcsstr(CommandLine, L"/s")) != NULL)){


        if (g_DriverHandle == NULL) {
            MessageBox(
                NULL, 
                L"Cannot process script file! SoftPCI support not installed!",
                L"Script Error",
                MB_OK
                );
        }

        //
        //  We found an Install command line.
        //
        p += wcslen(L"-s");

        //
        //  Parse out the specified ini path
        //
        if ((*p == '=') || (*p == ':')) {
            
            p++;
            p2 = pathToIni;
    
            while (*p && (*p != ' ')) {
                *p2 = *p;
                p2++;
                p++;
            }
            
            *p2 = 0;

            if (!SoftPCI_BuildDeviceInstallList(pathToIni)){
                SoftPCI_MessageBox(L"Error Parsing Script File!",
                                   L"%s\n",
                                   g_ScriptError
                                   );
            }
        }
    }

}// SoftPCI_ParseArgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\pch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <shellapi.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <regstr.h>
#include <dbt.h>
#include <winioctl.h>
#include <wmium.h>
#include <stdio.h>


//
//#include <malloc.h>
//#include <string.h>
//#include <memory.h>

//#include <objbase.h>
//#include <initguid.h>
//#include <tchar.h>


//
// ISSUE: BrandonA - 9/14/00
//        Remove when this it is put somewhere PCI.h can get at...
typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);
#include <pci.h>

#include "spci.h"     //common header shared between driver and UI
#include "simguid.h"
#include "softpciui.h"
#include "hpsim.h"
#include "resource.h"
#include "spciwnd.h"
#include "device.h"
#include "tree.h"
#include "install.h"
#include "dialog.h"
#include "tabwnd.h"
#include "utils.h"
#include "shpc.h"
#include "spciwmi.h"
#include "cmutil.h"
#include "parseini.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\resource.h ===
//
//  General
//
#define IDS_APPTITLE        1

//
//  Window Control IDs
//
#define IDC_TREEVIEW        1
#define IDC_TABPANE         2
#define IDC_TABCTL          3
#define IDC_EDITVIEW        4

//
//  Icons/cursors
//
#define IDC_SPLIT           100
#define IDI_SPCI            101

//
//  Main Menu
//
#define IDM_SPCI            100
#define ID_EXIT             101
#define ID_OPTIONS_INSTALL  102
#define ID_IMPORTDEVICES    103

//
//  Tree right click menu
//
#define IDM_TREEMENU            200
#define ID_INSTALLDEVICE        201
#define ID_ENABLEDISABLEDEVICE  202
#define ID_DELETEDEVICE         203
#define ID_STATICDEVICE         204
#define ID_REFRESHTREE          205
#define ID_PROPERTIES           206

//
//  Hotplug slot right click menu
//
#define IDM_HOTPLUGSLOTMENU 250
#define ID_REMOVEHPDEVICE   251
#define ID_OPENMRL          252
#define ID_CLOSEMRL         253
#define ID_ATTENBUTTON      254
#define ID_POWERINDICATOR   255
#define ID_ATTENINDICATOR   256


//
// DevProp Dialog
//
#define IDD_DEVPROP             300
#define IDC_DEVID               301
#define IDC_BUSDEVFUNC          302



//
//  NewDev Dialog
//
//  _CB  = ComboBox
//  _XB  = CheckBox Button
//  _RB  = Raidio Button
//  _TB  = Trackbar/slider
//  _GB  = GroupBox
//  _TX  = Text
//
//
#define IDD_INSTALLDEV                  400
#define IDC_DEVTYPE_CB                  401
#define IDC_DEVTYPELABEL_TX             402
#define IDC_SAVETOREG_XB                403
#define IDC_DEFAULTDEV_XB               404

#define IDC_COMMAND_GB                  405
#define IDC_MEMENABLE_XB                406
#define IDC_IOENABLE_XB                 407
#define IDC_BUSMSTR_XB                  408

#define IDC_BARS_GB                     409

#define IDC_BAR0_TB                     410
#define IDC_BAR0IO_RB                   411
#define IDC_BAR0MEM_RB                  412
#define IDC_BAR0_PREF_XB                413
#define IDC_BAR0_64BIT_XB               414
#define IDC_SLIDER0_TX                  415

#define IDC_BAR1_TB                     416
#define IDC_BAR1IO_RB                   417
#define IDC_BAR1MEM_RB                  418
#define IDC_BAR1_PREF_XB                419
#define IDC_BAR1_64BIT_XB               420
#define IDC_SLIDER1_TX                  421

#define IDC_BAR2_TB                     422
#define IDC_BAR2IO_RB                   423
#define IDC_BAR2MEM_RB                  424
#define IDC_BAR2_PREF_XB                425
#define IDC_BAR2_64BIT_XB               426
#define IDC_SLIDER2_TX                  427

#define IDC_BAR3_TB                     428
#define IDC_BAR3IO_RB                   429
#define IDC_BAR3MEM_RB                  430
#define IDC_BAR3_PREF_XB                431
#define IDC_BAR3_64BIT_XB               432
#define IDC_SLIDER3_TX                  433

#define IDC_BAR4_TB                     434
#define IDC_BAR4IO_RB                   435
#define IDC_BAR4MEM_RB                  436
#define IDC_BAR4_PREF_XB                437
#define IDC_BAR4_64BIT_XB               438
#define IDC_SLIDER4_TX                  439

#define IDC_BAR5_TB                     440
#define IDC_BAR5IO_RB                   441
#define IDC_BAR5MEM_RB                  442
#define IDC_BAR5_PREF_XB                443
#define IDC_SLIDER5_TX                  444

#define IDC_BRIDGEWIN_GB                445

#define IDC_BRIDGEMEM_TB                446
#define IDC_BRIDGEIO_TB                 447
#define IDC_BRIDGEMEMWINLABEL_TX        448
#define IDC_BRIDGEIOWINLABEL_TX         449
#define IDC_BRIDGEMEM_TX                450
#define IDC_BRIDGEIO_TX                 451

#define IDC_INSTALL_BUTTON              452
#define IDC_CANCEL_BUTTON               453
#define IDC_NEWDEVINFO_TX               454

#define IDC_ATTBTN_XB                   455
#define IDC_MRL_XB                      456
#define IDC_SLOTLABELUP_RB              457
#define IDC_SLOTLABELDN_RB              458
#define IDC_HOTPLUG_GB                  459
#define IDC_33CONV_EB                   460
#define IDC_33CONV_SP                   461
#define IDC_33CONV_TX                   462
#define IDC_66CONV_EB                   463
#define IDC_66CONV_SP                   464
#define IDC_66CONV_TX                   465
#define IDC_1STDEVSEL_EB                466
#define IDC_1STDEVSEL_SP                467
#define IDC_1STDEVSEL_TX                468
#define IDC_66PCIX_EB                   469
#define IDC_66PCIX_SP                   470
#define IDC_66PCIX_TX                   471
#define IDC_100PCIX_EB                  472
#define IDC_100PCIX_SP                  473
#define IDC_100PCIX_TX                  474
#define IDC_133PCIX_EB                  475
#define IDC_133PCIX_SP                  476
#define IDC_133PCIX_TX                  477
#define IDC_ALLSLOTS_EB                 478
#define IDC_ALLSLOTS_SP                 479
#define IDC_ALLSLOTS_TX                 480
#define IDC_1STSLOTLABEL_EB             481
#define IDC_1STSLOTLABEL_SP             482
#define IDC_LOTLABEL_TX                 483
#define IDC_SLOTLABEL_GB                484

#define IDC_DECODE_GB                   485
#define IDC_POSDECODE_XB                486
#define IDC_SUBDECODE_XB                487

#define LAST_CONTROL_ID                 488
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\spciwnd.c ===
#include "pch.h"

HWND
SoftPCI_CreateTabCtrlPane(
    IN HWND Wnd
    );

HWND
SoftPCI_CreateTreeViewPane(
    IN HWND Wnd
    );

BOOL
SoftPCI_OnCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    );

VOID
SoftPCI_OnCommand(
    IN HWND hWnd,
    IN INT DlgItem,
    IN HWND hControlWnd,
    IN UINT NotificationCode
    );

VOID
SoftPCI_OnDestroy(
    IN HWND hWnd
    );

SoftPCI_OnNotify(
    IN HWND     Wnd,
    IN INT      DlgItem,
    IN LPNMHDR  PNMHdr
    );

VOID
WINAPI
SoftPCI_OnLButtonDown(
    HWND	hWnd,
    BOOL	fDoubleClick,
    int		nX,
    int		nY,
    UINT	uKeyFlags
    );

VOID
SoftPCI_OnSize(
    HWND Wnd,
    UINT State,
    INT Cx,
    INT Cy
    );

VOID
SoftPCI_ResizeWindow(
    HWND Wnd,
    UINT ResizeFrom
    );

#define RESIZEFROM_OTHER	0
#define RESIZEFROM_SPLIT	1

//
//  Since we do not have a status bar this array does practically nothing for us.
//  If we ever implement a status bar across the bottom we will need this.
//
const int g_EffectiveClientRectData[] = {
    1, 0,                               //  For the menu bar, but is unused
    0, 0                                //  First zero marks end of data
};

INT     g_PixelsPerInch = 0;
INT     g_PaneSplit = 0;

BOOL    g_TimerSet = FALSE;
HCURSOR g_OldCursor;

#define TREETIMER     0xABAB

HWND
SoftPCI_CreateMainWnd(VOID)
/*++

Routine Description:

    Creates an instance of the SoftPCI Main View window.

Arguments:

    none

Return Value:

    The Device View HWND (or NULL on error).

--*/
{
    BOOL result;
    HWND mainWnd;
    HDC hdc;
    WCHAR title[MAX_PATH];
    SOFTPCI_WNDVIEW wndView;

    hdc = GetDC(NULL);
    g_PixelsPerInch = GetDeviceCaps(hdc, LOGPIXELSX);
    ReleaseDC(NULL, hdc);
    
    result = SoftPCI_QueryWindowSettings(&wndView);

    //
    //  Default to a pane split of 4 inches unless we have a registry over-ride
    //
    g_PaneSplit = (result ? wndView.PaneSplit : (g_PixelsPerInch * 4));

    LoadString(g_Instance, IDS_APPTITLE, title, (sizeof(title) / sizeof(title[0])));
    mainWnd = CreateWindowEx(
        WS_EX_WINDOWEDGE | WS_EX_ACCEPTFILES,
        g_SoftPCIMainClassName,
        title,
        WS_OVERLAPPEDWINDOW | WS_SYSMENU | WS_THICKFRAME | 
        WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_CLIPCHILDREN,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        g_Instance,
        NULL
        );

    if (result) {

        wndView.WindowPlacement.length = sizeof(wndView.WindowPlacement);
        if (wndView.WindowPlacement.showCmd == SW_SHOWMINIMIZED){
            wndView.WindowPlacement.showCmd = SW_SHOWDEFAULT;
        }
        SetWindowPlacement(mainWnd, &wndView.WindowPlacement);
    }else{
        ShowWindow(mainWnd, SW_SHOWDEFAULT);
    }

    return mainWnd;
}

HWND
SoftPCI_CreateTreeViewPane(
    IN HWND Wnd
    )
{

    g_TreeViewWnd = CreateWindowEx(
        WS_EX_CLIENTEDGE,
        WC_TREEVIEW,
        NULL,
        WS_CHILD | WS_VISIBLE | WS_TABSTOP | TVS_HASBUTTONS |
        TVS_LINESATROOT | TVS_HASLINES, //| WS_SIZEBOX,
        0, 0, 0, 0, Wnd,
        (HMENU) IDC_TREEVIEW,
        g_Instance,
        NULL);

    return g_TreeViewWnd;
}



LRESULT
WINAPI
SoftPCI_MainWndProc(
    IN HWND     Wnd,
    IN UINT     Message,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
/*++

Routine Description:

    Windows message processing

Arguments:

    hWnd    -   Window handle
    Message -   Message to process
    wParam  -   Message param
    lParam  -   Message param

Return Value:

    return value depends on message handled.

--*/
{

    HMENU rmenu;
    PWCHAR filePath;
    UINT filePathSize;
    UINT_PTR timerSet;

//    SoftPCI_Debug(SoftPciAlways, L"message - %x\n", Message);

    switch (Message) {
    
            //
            //  ISSUE: Should handle WM_CREATE better since it is
            //  critical to everything working properly. If it fails
            //  then we should complain and exit.
            //
            HANDLE_MSG(Wnd, WM_CREATE,  SoftPCI_OnCreate);
            HANDLE_MSG(Wnd, WM_COMMAND, SoftPCI_OnCommand);
            HANDLE_MSG(Wnd, WM_DESTROY, SoftPCI_OnDestroy);
            HANDLE_MSG(Wnd, WM_NOTIFY,  SoftPCI_OnNotify);
            HANDLE_MSG(Wnd, WM_LBUTTONDOWN,  SoftPCI_OnLButtonDown);
            HANDLE_MSG(Wnd, WM_SIZE,  SoftPCI_OnSize);
    
        case WM_ACTIVATE:
    
            if (wParam != WA_INACTIVE) {
                SetFocus(g_TreeViewWnd);
            }
    
            break;
    
        case WM_DEVICECHANGE:

            if (wParam == DBT_DEVNODES_CHANGED) {
    
                //
                //  Refresh the tree if it isnt locked.
                //
                if (g_TreeLocked){
                    g_PendingRefresh = TRUE;
                    break;
                }
    
                if (!g_TimerSet){
                    
                    //
                    //  Set a timer for 5 seconds so that we dont
                    //  repaint the tree like a freaking epeleptic
                    //
                    SoftPCI_CreateTreeView();

                    timerSet = SetTimer(
                        Wnd,
                        TREETIMER,
                        5 * 1000,
                        NULL
                        );

                    if (timerSet != 0) {

                        g_TimerSet = TRUE;
                        
                    }

                }else{

                    g_PendingRefresh = TRUE;
                }
            }
            break;

        case WM_TIMER:
            

            if (wParam == TREETIMER) {
                //
                //  Our timer fired, kill it and rebuild the tree
                //
                if (g_PendingRefresh){
                    g_PendingRefresh = FALSE;
                    SoftPCI_CreateTreeView();
                }
                
                KillTimer(Wnd, TREETIMER);
                g_TimerSet = FALSE;

            }
            break;
    
    
        case WM_INITMENU:{
    
            HMENU   menu = GetMenu(g_SoftPCIMainWnd);
    
            if (g_DriverHandle) {
                SoftPCI_DisableMenuItem(menu, ID_OPTIONS_INSTALL);
            }
        }
            break;

        case WM_DROPFILES:
            
            if (g_DriverHandle != NULL) {
                
                filePathSize = DragQueryFile(
                    (HDROP)wParam,
                    0,
                    NULL,
                    0
                    );     
    
                filePath = calloc(sizeof(WCHAR), filePathSize + 1);
                if (filePath) {
    
                    DragQueryFile(
                        (HDROP)wParam,
                        0,
                        filePath,
                        filePathSize + 1
                        );
                    
                    if (SoftPCI_BuildDeviceInstallList(filePath)){
                        
                        SoftPCI_InstallScriptDevices();

                    }else{
                        
                        SoftPCI_MessageBox(L"Error Parsing Script File!",
                                           L"%s\n",
                                           g_ScriptError
                                           );
                    }
                    free(filePath);
                }
            }else{
                MessageBox(g_SoftPCIMainWnd, 
                           L"Cannot process script file! SoftPCI support not installed!",
                           L"Script Error",
                           MB_OK
                           );
            }
            
            DragFinish((HDROP)wParam);

            break;

    
        default:
            return DefWindowProc(Wnd, Message, wParam, lParam);
    }

    return 0;
}


VOID
SoftPCI_OnCommand(
    IN HWND     Wnd,
    IN INT      ItemID,
    IN HWND     ControlWnd,
    IN UINT     NotificationCode
)
/*++

Routine Description:

    Windows message processing

Arguments:

    hWnd    -   Window handle
    DlgItem -
    hControlWnd  -
    NotificationCode  -

Return Value:

    None

--*/
{

    HMENU menu = GetMenu(Wnd);
    BOOL result = FALSE;

    switch (ItemID) {
        case ID_EXIT:
            PostMessage(Wnd, WM_CLOSE, 0, 0);
            break;
        
        
        case ID_OPTIONS_INSTALL:
        
            result = MessageBox(g_SoftPCIMainWnd,
                                L"SoftPCI Support will now be installed....",
                                L"INSTALL",
                                MB_OKCANCEL | MB_DEFBUTTON2
                                );
        
            if (result == IDOK) {
                if (!SoftPCI_InstallDriver()) {
                    MessageBox(g_SoftPCIMainWnd,
                               L"Failed to Install SoftPCI Support",
                               NULL,
                               MB_OK | MB_ICONEXCLAMATION);
                }
            }
            break;

        case ID_IMPORTDEVICES:

            SoftPCI_HandleImportDevices();

            break;
    
        default:
            break;
    }
}

BOOL
SoftPCI_OnCreate(
    IN HWND Wnd,
    IN LPCREATESTRUCT CreateStruct
    )
/*++

Routine Description:

    Creates our other subwindows (tree view)

Arguments:

    Wnd    -   Parent window handle
    CreateStruct -

Return Value:

    None

--*/
{
    
    
    if (SoftPCI_CreateTreeViewPane(Wnd) == NULL || 
        SoftPCI_CreateTabCtrlPane(Wnd) == NULL) {
        return FALSE;
    }

    //
    //  Subclass our tree view window proc
    //
    g_DefTreeWndProc = GetWindowLongPtr(g_TreeViewWnd, GWLP_WNDPROC);

    if (!SetWindowLongPtr(g_TreeViewWnd,
                          GWLP_WNDPROC,
                          ((LONG_PTR)SoftPCI_TreeWndProc))){

        SOFTPCI_ASSERT(FALSE);
        return FALSE;

    }

    SoftPCI_CreateTreeView();

    SetFocus(g_TreeViewWnd);

    return TRUE;
}

VOID
SoftPCI_OnDestroy(
    IN HWND Wnd
    )
{

    SoftPCI_SaveWindowSettings();

    if (g_TreeCreated) {
        SoftPCI_DestroyTree(g_PciTree);
    }

    if (g_LastSelection) {
        free(g_LastSelection);
    }

    //
    //  This keeps us from doing funky repainting when the tree is destroyed.
    //
    //TreeView_SelectItem(g_TreeViewWnd, NULL);

    PostQuitMessage(0);
}

SoftPCI_OnNotify(
    IN HWND Wnd,
    IN INT DlgItem,
    IN LPNMHDR PNMHdr
    )
{

    
    switch (DlgItem) {
        
        case IDC_TABCTL:
            
            switch (PNMHdr->code) {
                case TCN_SELCHANGE:
                    SoftPCI_OnTabCtrlSelectionChange();
                    break;
            }
            break;
    
        case IDC_TREEVIEW:

            switch (PNMHdr->code) {
        
            case TVN_SELCHANGED:
                SoftPCI_OnTreeSelectionChange(Wnd);
                break;
            }
        default:
            break;
        }

    return 0;
}

VOID
WINAPI
SoftPCI_OnLButtonDown(
    HWND	hWnd,
    BOOL	fDoubleClick,
    int		nX,
    int		nY,
    UINT	uKeyFlags
    )
{

    LONG lStyle;
    RECT clientRect;
    int nCxIcon;
    int nDx;
    int nDy;
    HDC hDC;
    MSG msg;
    int nXLow;
    int nXHigh;
    HBRUSH hDitherBrush;
    HBRUSH hPrevBrush;

    if (!IsIconic(hWnd)){

		lStyle = GetWindowLong(hWnd, GWL_STYLE);
		SetWindowLong(hWnd, GWL_STYLE, lStyle & (~WS_CLIPCHILDREN));

		GetEffectiveClientRect(hWnd, &clientRect, (LPINT)g_EffectiveClientRectData);

		nCxIcon = GetSystemMetrics(SM_CXICON);
		clientRect.left += nCxIcon;
		clientRect.right -= nCxIcon;

		nDx = GetSystemMetrics(SM_CXSIZEFRAME);
		nY = GetSystemMetrics(SM_CYEDGE);
		nDy = clientRect.bottom - clientRect.top - nY * 2;

		hDC = GetDC(hWnd);
		hDitherBrush = SoftPCI_CreateDitheredBrush();
		if (hDitherBrush != NULL) {

			hPrevBrush = SelectBrush(hDC, hDitherBrush);
		}

		PatBlt(hDC, nX - nDx / 2, nY, nDx, nDy, PATINVERT);

		SetCapture(hWnd);

		while (GetMessage(&msg, NULL, 0, 0)) {

			if (msg.message == WM_KEYDOWN || 
				msg.message == WM_SYSKEYDOWN ||
				(msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST)) {

				if (msg.message == WM_LBUTTONUP || 
					msg.message == WM_LBUTTONDOWN ||
					msg.message == WM_RBUTTONDOWN) {

					break;
				}

				if (msg.message == WM_KEYDOWN) {

					if (msg.wParam == VK_LEFT) {

						msg.message = WM_MOUSEMOVE;
						msg.pt.x -= 2;
					} else if (msg.wParam == VK_RIGHT) {

						msg.message = WM_MOUSEMOVE;
						msg.pt.x += 2;

					} else if (msg.wParam == VK_RETURN || msg.wParam == VK_ESCAPE) {

						break;
					}

					if (msg.pt.x > clientRect.right) {

						msg.pt.x = clientRect.right;
					} else if (msg.pt.x < clientRect.left) {

						msg.pt.x = clientRect.left;
					}

					SetCursorPos(msg.pt.x, msg.pt.y);

				}

				if (msg.message == WM_MOUSEMOVE) {

					ScreenToClient(hWnd, &msg.pt);

					if (msg.pt.x > clientRect.right) {

						msg.pt.x = clientRect.right;
					} else if (msg.pt.x < clientRect.left) {

						msg.pt.x = clientRect.left;
					}

					if (nX < msg.pt.x) {

						nXLow = nX;
						nXHigh = msg.pt.x;
					} else {

						nXLow = msg.pt.x;
						nXHigh = nX;
					}

					nXLow -= nDx / 2;
					nXHigh -= nDx / 2;

					if (nXHigh < nXLow + nDx) {

						ExcludeClipRect(hDC, nXHigh, nY, nXLow + nDx, nY + nDy);
					} else {

						ExcludeClipRect(hDC, nXLow + nDx, nY, nXHigh, nY + nDy);
					}

					PatBlt(hDC, nXLow, nY, nXHigh - nXLow + nDx, nDy, PATINVERT);
					SelectClipRgn(hDC, NULL);

					nX = msg.pt.x;
				}
			} else {

				DispatchMessage(&msg);
			}

		}

		ReleaseCapture();

		PatBlt(hDC, nX - nDx / 2, nY, nDx, nDy, PATINVERT);

		if (hDitherBrush != NULL) {

			DeleteObject(SelectBrush(hDC, hPrevBrush));
		}

		ReleaseDC(hWnd, hDC);

		SetWindowLong(hWnd, GWL_STYLE, lStyle);

		g_PaneSplit = nX - nDx / 2;

		SoftPCI_ResizeWindow(hWnd, RESIZEFROM_SPLIT);
	}
}

VOID
SoftPCI_OnSize(
    HWND Wnd,
    UINT State,
    INT Cx,
    INT Cy
    )
{
	SoftPCI_ResizeWindow(Wnd, RESIZEFROM_OTHER);
}

VOID
SoftPCI_ResizeWindow(
    HWND Wnd,
    UINT ResizeFrom
    )
{

    RECT    clientRect;
    INT     x, y, height, width;
    HDWP    hdwp;

    //
    //  Currently we do not use the ResizeFrom argument but should we ever
    //  decide to implement a status bar we will need it.
    //
    if ((hdwp = BeginDeferWindowPos(3)) != NULL){

        GetClientRect(Wnd, &clientRect);
        
        x = 0;
        y = 0;
        height = (clientRect.bottom - clientRect.top);
        width = g_PaneSplit;

        DeferWindowPos(hdwp,
                       g_TreeViewWnd,
                       NULL,
                       x,
                       y,
                       width + GetSystemMetrics(SM_CXSIZEFRAME),
                       height,
                       SWP_NOZORDER | SWP_NOACTIVATE
                       );

        x += width + GetSystemMetrics(SM_CXSIZEFRAME);
        width = (clientRect.right - clientRect.left) - x;
        DeferWindowPos(hdwp,
                       g_TabCtrlWnd,
                       NULL,
                       x,
                       y,
                       width,
                       height,
                       SWP_NOZORDER | SWP_NOACTIVATE
                       );
        
        SetRect(&clientRect, x, y, width, height);
        TabCtrl_AdjustRect(g_TabCtrlWnd, FALSE, &clientRect) ;
        
        height = (clientRect.bottom - clientRect.top) + GetSystemMetrics(SM_CXSIZEFRAME);
        width -= GetSystemMetrics(SM_CXSIZEFRAME);
        DeferWindowPos(hdwp,
                       g_EditWnd,
                       HWND_TOP,
                       clientRect.left + 3,
                       clientRect.top + 3,
                       width - 3,
                       height - 3,
                       SWP_NOACTIVATE
                       );

        EndDeferWindowPos(hdwp);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\spciwmi.c ===
#include "pch.h"
#include "hpwmi.h"


//
// When SoftPCI creates a SHPC devnode, it needs to do the following:
//
// 1) Call SoftPCI_SetEventContext to set the event callback context.
// 2) Call SoftPCI_RegisterHotplugEvents to register for event callbacks.
//
// Potentially we should get the WMI instance name for the device by calling
//      SoftPCI_AllocWmiInstanceName once when the devnode is created instead
//      of every time we do something WMI related.
//

BOOL
SoftPCI_AllocWmiInstanceName(
    OUT PWCHAR WmiInstanceName,
    IN PWCHAR DeviceId
    )
{
    ULONG numChar;

    numChar = WmiDevInstToInstanceNameW(WmiInstanceName,
                                        MAX_PATH,
                                        DeviceId,
                                        0
                                        );
    if (numChar > MAX_PATH) {
        return FALSE;

    } else {
        return TRUE;
    }
}

BOOL
SoftPCI_AllocWnodeSI(
    IN PPCI_DN Pdn,
    IN LPGUID Guid,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PWNODE_SINGLE_INSTANCE *WnodeForBuffer
    )
{
    PWNODE_HEADER Wnode;
    PWNODE_SINGLE_INSTANCE WnodeSI;
    ULONG sizeNeeded;
    PUCHAR WnodeDataPtr;

    SOFTPCI_ASSERT(Buffer != NULL);
    SOFTPCI_ASSERT(BufferSize != 0);

    if ((Buffer == NULL) ||
        (BufferSize == 0)) {

        return FALSE;
    }
    sizeNeeded = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData) +
                 BufferSize;

    Wnode = (PWNODE_HEADER)malloc(sizeNeeded);
    if (!Wnode) {

        return FALSE;
    }

    Wnode->Flags = WNODE_FLAG_SINGLE_INSTANCE | WNODE_FLAG_PDO_INSTANCE_NAMES;
    Wnode->BufferSize = sizeNeeded;
    Wnode->Guid = *Guid;

    WnodeSI = (PWNODE_SINGLE_INSTANCE)Wnode;
    WnodeSI->DataBlockOffset = FIELD_OFFSET(WNODE_SINGLE_INSTANCE, VariableData);
    WnodeSI->InstanceIndex = 0;
    WnodeSI->SizeDataBlock = BufferSize;

    WnodeDataPtr = (PUCHAR)Wnode + WnodeSI->DataBlockOffset;
    RtlCopyMemory(WnodeDataPtr, Buffer, BufferSize);

    *WnodeForBuffer = WnodeSI;

    return TRUE;
}

BOOL
SoftPCI_SetEventContext(
    IN PPCI_DN ControllerDevnode
    )
{
    WMIHANDLE methodHandle = NULL;
    ULONG status;
    BOOL returnVal;


    if (!(ControllerDevnode->WmiId[0])) {
        return FALSE;
    }

    status = WmiOpenBlock((LPGUID)&GUID_HPS_EVENT_CONTEXT,
                          WMIGUID_SET,
                          &methodHandle
                          );
    if (status != ERROR_SUCCESS) {

        returnVal = FALSE;
        goto cleanup;
    }

    status = WmiSetSingleInstanceW(methodHandle,
                                   ControllerDevnode->WmiId,
                                   1,
                                   sizeof(PCI_DN),
                                   ControllerDevnode
                                   );

    if (status != ERROR_SUCCESS) {

        returnVal = FALSE;
        goto cleanup;
    }

    returnVal = TRUE;

cleanup:

    if (methodHandle) {
        WmiCloseBlock(methodHandle);
    }


    return returnVal;
}

BOOL
SoftPCI_GetHotplugData(
    IN PPCI_DN          ControllerDevnode,
    IN PHPS_HWINIT_DESCRIPTOR HpData
    )
{
    WMIHANDLE methodHandle = NULL;
    PWNODE_SINGLE_INSTANCE wnodeSI = NULL;
    ULONG status;
    ULONG size;
    BOOL returnVal = FALSE;


    if (!(ControllerDevnode->WmiId[0])) {
        return FALSE;
    }

    status = WmiOpenBlock((LPGUID)&GUID_HPS_INIT_DATA,
                          WMIGUID_QUERY,
                          &methodHandle
                          );
    if (status != ERROR_SUCCESS) {

        goto cleanup;
    }

	size = sizeof(WNODE_TOO_SMALL);
	wnodeSI = malloc(size);
	if (wnodeSI == NULL) {

        goto cleanup;
    }

    status = WmiQuerySingleInstanceW(methodHandle,
                                    ControllerDevnode->WmiId,
                                    &size,
                                    wnodeSI);
    if (status == ERROR_INSUFFICIENT_BUFFER)
    {
        free(wnodeSI);
        wnodeSI = malloc(size);
        if (wnodeSI == NULL) {

            goto cleanup;
        }

        status = WmiQuerySingleInstanceW(methodHandle,
                                        ControllerDevnode->WmiId,
                                        &size,
                                        wnodeSI);

    }	

	if (status == ERROR_SUCCESS) {
        returnVal = TRUE;
        if (wnodeSI->SizeDataBlock) {
            RtlCopyMemory(HpData,(PUCHAR)wnodeSI+wnodeSI->DataBlockOffset,wnodeSI->SizeDataBlock);
        }

    }

cleanup:

    if (methodHandle) {
        WmiCloseBlock(methodHandle);
    }

    if (wnodeSI) {
        free(wnodeSI);
    }

    return returnVal;
}

BOOL
SoftPCI_ExecuteHotplugSlotMethod(
    IN PPCI_DN ControllerDevnode,
    IN UCHAR SlotNum,
    IN HPS_SLOT_EVENT_TYPE EventType
    )
{
    HPS_SLOT_EVENT slotEvent;
    WMIHANDLE methodHandle = NULL;
    ULONG status;
    ULONG outSize;
    BOOL returnVal;

    if (!(ControllerDevnode->WmiId[0])) {
        return FALSE;
    }

    status = WmiOpenBlock((LPGUID)&GUID_HPS_SLOT_METHOD,
                          WMIGUID_EXECUTE,
                          &methodHandle
                          );
    if (status != ERROR_SUCCESS) {

        returnVal = FALSE;
        goto cleanup;
    }


    slotEvent.SlotNum = SlotNum;
    slotEvent.EventType = EventType;
    outSize = 0;
    status = WmiExecuteMethodW(methodHandle,
                               ControllerDevnode->WmiId,
                               SlotMethod,
                               sizeof(HPS_SLOT_EVENT),
                               &slotEvent,
                               &outSize,
                               NULL
                               );
    if (status != ERROR_SUCCESS) {

        returnVal = FALSE;
        goto cleanup;
    }

    returnVal = TRUE;

cleanup:

    if (methodHandle) {
        WmiCloseBlock(methodHandle);
    }

    return returnVal;
}

BOOL
SoftPCI_AddHotplugDevice(
    IN PPCI_DN ControllerDevnode,
    IN PSOFTPCI_DEVICE Device
    )
{
    WMIHANDLE methodHandle = NULL;
    ULONG status = ERROR_INVALID_DATA;
    ULONG outSize;
    BOOL returnVal;
    
    if (!(ControllerDevnode->WmiId[0])) {
        SoftPCI_Debug(SoftPciHotPlug, L"GetHotplugDevice - No WMI id!\n");
        returnVal= FALSE;
        goto cleanup;
    }

    status = WmiOpenBlock((LPGUID)&GUID_HPS_SLOT_METHOD,
                          WMIGUID_EXECUTE,
                          &methodHandle
                          );
    if (status != ERROR_SUCCESS) {

        returnVal = FALSE;
        goto cleanup;
    }

    outSize = 0;
    status = WmiExecuteMethodW(methodHandle,
                               ControllerDevnode->WmiId,
                               AddDeviceMethod,
                               sizeof(SOFTPCI_DEVICE),
                               Device,
                               &outSize,
                               NULL
                               );
    if (status != ERROR_SUCCESS) {

        returnVal = FALSE;
        goto cleanup;
    }

    returnVal = TRUE;

cleanup:

    if (returnVal == TRUE) {
        SoftPCI_Debug(SoftPciHotPlug, L"Add Device succeeded\n");
    } else {
        SoftPCI_Debug(SoftPciHotPlug, L"Add Device failed status=0x%x\n", status);
    }

    if (methodHandle) {
        WmiCloseBlock(methodHandle);
    }

    return returnVal;
}

BOOL
SoftPCI_RemoveHotplugDevice(
    IN PPCI_DN ControllerDevnode,
    IN UCHAR SlotNum
    )
{
    WMIHANDLE methodHandle = NULL;
    ULONG status = ERROR_INVALID_DATA;
    ULONG outSize;
    BOOL returnVal;
    
    if (!(ControllerDevnode->WmiId[0])) {
        SoftPCI_Debug(SoftPciHotPlug, L"GetHotplugDevice - No WMI id!\n");
        returnVal=FALSE;
        goto cleanup;
    }

    status = WmiOpenBlock((LPGUID)&GUID_HPS_SLOT_METHOD,
                          WMIGUID_EXECUTE,
                          &methodHandle
                          );
    if (status != ERROR_SUCCESS) {

        returnVal = FALSE;
        goto cleanup;
    }

    outSize = 0;
    status = WmiExecuteMethodW(methodHandle,
                               ControllerDevnode->WmiId,
                               RemoveDeviceMethod,
                               sizeof(UCHAR),
                               &SlotNum,
                               &outSize,
                               NULL
                               );
    if (status != ERROR_SUCCESS) {
        returnVal = FALSE;
        goto cleanup;
    }

    returnVal = TRUE;

cleanup:

    if (returnVal == TRUE) {
        SoftPCI_Debug(SoftPciHotPlug, L"Remove Device - Slot %d succeeded\n", SlotNum);
    } else {
        SoftPCI_Debug(SoftPciHotPlug, L"Remove Device - Slot %d failed status=0x%x\n", SlotNum, status);
    }
    if (methodHandle) {
        WmiCloseBlock(methodHandle);
    }

    return returnVal;
}

BOOL
SoftPCI_GetHotplugDevice(
    IN PPCI_DN ControllerDevnode,
    IN UCHAR SlotNum,
    OUT PSOFTPCI_DEVICE Device
    )
{
    WMIHANDLE methodHandle = NULL;
    ULONG status = ERROR_INVALID_DATA;
    ULONG outSize;
    BOOL returnVal;
    PSOFTPCI_DEVICE bogus = NULL;

    if (!(ControllerDevnode->WmiId[0])) {
        SoftPCI_Debug(SoftPciHotPlug, L"GetHotplugDevice - No WMI id!\n");
        returnVal=FALSE;
        goto cleanup;
    }

    status = WmiOpenBlock((LPGUID)&GUID_HPS_SLOT_METHOD,
                          WMIGUID_EXECUTE,
                          &methodHandle
                          );
    if (status != ERROR_SUCCESS) {
        SoftPCI_Debug(SoftPciHotPlug, L"GetHotplugDevice - Couldn't open wmi block! status = 0x%x\n", status);
        returnVal = FALSE;
        goto cleanup;
    }

    outSize = sizeof(SOFTPCI_DEVICE);
    
    SoftPCI_Debug(SoftPciHotPlug, L"GetHotplugDevice - WMI Id -\n\t");
    SoftPCI_Debug(SoftPciHotPlug, L"%s\n", ControllerDevnode->WmiId);
    
    status = WmiExecuteMethodW(methodHandle,
                               ControllerDevnode->WmiId,
                               GetDeviceMethod,
                               sizeof(UCHAR),
                               &SlotNum,
                               &outSize,
                               Device
                               );

    if (status != ERROR_SUCCESS) {
        returnVal = FALSE;
        goto cleanup;
    }

    //SoftPCI_Debug(SoftPciHotPlug, L"succeeded\n");
    returnVal = TRUE;

cleanup:

    if (returnVal == TRUE) {
        
        SoftPCI_Debug(SoftPciHotPlug, L"GetHotplugDevice - Slot %d succeeded\n", SlotNum);
        
    } else {
        
        SoftPCI_Debug(SoftPciHotPlug, L"GetHotplugDevice - Slot %d failed status=0x%x\n", SlotNum, status);
        
    }

    if (methodHandle) {
        WmiCloseBlock(methodHandle);
    }

    return returnVal;
}

BOOL
SoftPCI_GetSlotStatus(
    IN PPCI_DN ControllerDevnode,
    IN UCHAR SlotNum,
    OUT PSHPC_SLOT_STATUS_REGISTER StatusReg
    )
{
    WMIHANDLE methodHandle = NULL;
    ULONG status;
    ULONG outSize;
    BOOL returnVal;

    if (!(ControllerDevnode->WmiId[0])) {
        return FALSE;
    }

    status = WmiOpenBlock((LPGUID)&GUID_HPS_SLOT_METHOD,
                          WMIGUID_EXECUTE,
                          &methodHandle
                          );
    if (status != ERROR_SUCCESS) {
        SoftPCI_Debug(SoftPciHotPlug, L"GetSlotStatus - Couldn't open wmi block! status = 0x%x\n", status);
        returnVal = FALSE;
        goto cleanup;
    }

    outSize = sizeof(SHPC_SLOT_STATUS_REGISTER);
    status = WmiExecuteMethodW(methodHandle,
                               ControllerDevnode->WmiId,
                               GetSlotStatusMethod,
                               sizeof(UCHAR),
                               &SlotNum,
                               &outSize,
                               StatusReg
                               );
    
    if (status != ERROR_SUCCESS) {
        SoftPCI_Debug(SoftPciHotPlug, L"GetSlotStatus - Slot %d failed status=0x%x\n", SlotNum, status);
        returnVal = FALSE;
        goto cleanup;
    }

    returnVal = TRUE;

cleanup:

    if (methodHandle) {
        WmiCloseBlock(methodHandle);
    }

    return returnVal;
}

VOID
SoftPCI_CompleteCommand(
    IN PPCI_DN ControllerDevnode
    )
{
    WMIHANDLE methodHandle = NULL;
    ULONG status;
    ULONG outSize, inBuffer, outBuffer;

    if (!(ControllerDevnode->WmiId[0])) {
        return;
    }

    status = WmiOpenBlock((LPGUID)&GUID_HPS_SLOT_METHOD,
                          WMIGUID_EXECUTE,
                          &methodHandle
                          );
    
    if (status != ERROR_SUCCESS) {
        SoftPCI_Debug(SoftPciHotPlug, L"CompleteCommand - Couldn't open wmi block! status = 0x%x\n", status);
        goto cleanup;
    }

    outSize = sizeof(ULONG);
    status = WmiExecuteMethodW(methodHandle,
                               ControllerDevnode->WmiId,
                               CommandCompleteMethod,
                               0,
                               &inBuffer,
                               &outSize,
                               &outBuffer
                               );
    
    if (status != ERROR_SUCCESS) {
        SoftPCI_Debug(SoftPciHotPlug, L"CompleteCommand - failed status=0x%x\n", status);
        goto cleanup;
    }

cleanup:

    if (methodHandle) {
        WmiCloseBlock(methodHandle);
    }

    return;
}

VOID
SoftPCI_RegisterHotplugEvents(
    VOID
    )
{
    WmiNotificationRegistrationW((LPGUID)&GUID_HPS_CONTROLLER_EVENT,
                                 TRUE,
                                 SoftPCI_HotplugEventCallback,
                                 (ULONG_PTR)0,
                                 NOTIFICATION_CALLBACK_DIRECT
                                 );
}

VOID
SoftPCI_UnregisterHotplugEvents(
    VOID
    )
{
    WmiNotificationRegistrationW((LPGUID)&GUID_HPS_CONTROLLER_EVENT,
                                 FALSE,
                                 SoftPCI_HotplugEventCallback,
                                 (ULONG_PTR)0,
                                 NOTIFICATION_CALLBACK_DIRECT
                                 );
}

VOID
SoftPCI_HotplugEventCallback(
    IN PWNODE_HEADER WnodeHeader,
    IN ULONG Context
    )
{
    PWNODE_SINGLE_INSTANCE WnodeSI = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWNODE_HEADER Wnode = WnodeHeader;
    PUCHAR WnodeDataPtr;
    LPGUID EventGuid = &WnodeHeader->Guid;
    WCHAR s[MAX_PATH];
    ULONG Status;
    WMIHANDLE Handle;
    PPCI_DN controllerDevnode;
    PHPS_CONTROLLER_EVENT event;
    ULONG slotNums;
    UCHAR currentSlot;

    SOFTPCI_ASSERT(EQUAL_GUID(EventGuid,&GUID_HPS_CONTROLLER_EVENT));
    if (!EQUAL_GUID(EventGuid,&GUID_HPS_CONTROLLER_EVENT)) {
        //
        // Not the event we expected.  Return.
        //
        return;
    }

    SOFTPCI_ASSERT(WnodeSI->SizeDataBlock == (sizeof(HPS_CONTROLLER_EVENT) + sizeof(PCI_DN)));
    if (WnodeSI->SizeDataBlock != (sizeof(HPS_CONTROLLER_EVENT) + sizeof(PCI_DN))) {
        //
        // Not the buffer we expected.  Return.
        //
        return;
    }

    WnodeDataPtr = (PUCHAR)WnodeHeader + WnodeSI->DataBlockOffset;
    controllerDevnode = (PPCI_DN)WnodeDataPtr;

    WnodeDataPtr += sizeof(PCI_DN);
    event = (PHPS_CONTROLLER_EVENT)WnodeDataPtr;

    if (event->SERRAsserted) {
        SoftPCI_UnregisterHotplugEvents();
        wsprintf(s, L"Hotplug Controller at bus 0x%x device 0x%x function 0x%x just caused an SERR!",
                 controllerDevnode->Bus, controllerDevnode->Slot.Device, controllerDevnode->Slot.Function
                 );
        MessageBox(g_SoftPCIMainWnd,
                   s,
                   L"FATAL ERROR",
                   MB_OK
                   );

    }

    currentSlot = 0;
    slotNums = event->SlotNums;
    while (slotNums != 0) {
        if (slotNums & 0x1) {

            if (event->Command.SlotOperation.SlotState == SHPC_SLOT_ENABLED) {
                SoftPCI_BringHotplugDeviceOnline(controllerDevnode,
                                                 currentSlot
                                                 );

            } else if (event->Command.SlotOperation.SlotState == SHPC_SLOT_OFF) {
                SoftPCI_TakeHotplugDeviceOffline(controllerDevnode,
                                                 currentSlot
                                                 );
            }
        }
        slotNums >>= 1;
        currentSlot++;
    }

    SoftPCI_CompleteCommand(controllerDevnode);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\tabwnd.h ===
//extern HWND     g_TabCtrlPaneWnd;
extern HWND     g_TabCtrlWnd;
extern HWND     g_EditWnd;
extern PPCI_DN  g_PdnToDisplay;
extern ULONG    g_CurrentTabSelection;

LRESULT
WINAPI
SoftPCI_TabCtrlWndProc(
    IN HWND     Wnd,
    IN UINT     Message,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    );

BOOL
SoftPCI_ShowDeviceProperties(
    PPCI_DN Pdn
    );


VOID
SoftPCI_SetWindowFont(
    IN HWND Wnd,
    IN PWCHAR  FontName
    );

VOID
SoftPCI_UpdateTabCtrlWindow(
    IN INT CurrentSelection
    );

HWND
SoftPCI_CreateTabCtrlPane(
    IN HWND Wnd
    );

VOID
SoftPCI_OnTabCtrlSelectionChange(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\debug.c ===
#include "pch.h"



VOID
SoftPCIDbgPrint(
    IN ULONG   DebugPrintLevel,
    IN PCCHAR  DebugMessage,
    ...
    )
/*++

Routine Description:

    This is the debug print routine
    
Arguments:

    DebugPrintLevel - The bit mask that when anded with the debuglevel, must
                        equal itself
    DebugMessage    - The string to feed through vsprintf

Return Value:

    None

--*/
{
#if DBG
    
    va_list ap;
    CHAR debugBuffer[SOFTPCI_DEBUG_BUFFER_SIZE];

    //
    // Get the variable arguments
    //
    va_start(ap, DebugMessage );

    //
    // Call the kernel function to print the message
    //
    _vsnprintf(debugBuffer, SOFTPCI_DEBUG_BUFFER_SIZE, DebugMessage, ap);
    DbgPrintEx(DPFLTR_SOFTPCI_ID, DebugPrintLevel, "%s", debugBuffer);

    //
    // We are done with the varargs
    //
    va_end(ap);

#else 

    UNREFERENCED_PARAMETER(DebugPrintLevel);
    UNREFERENCED_PARAMETER(DebugMessage);
    
#endif //DBG

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\tabwnd.c ===
#include "pch.h"

typedef VOID (*PSOFTPCI_TABCTRLUPDATE)(VOID);

VOID 
SoftPCI_AddTabCtrlWindow(
    IN PWCHAR TabText, 
    IN PSOFTPCI_TABCTRLUPDATE UpdateTab
    );

HWND
SoftPCI_CreateTabCtrlEditWindow(
    IN HWND Wnd
    );

SoftPCI_ChangeTabSelection(
    BOOL IncrementCurrent
    );

VOID
SoftPCI_UpdateGeneralTab(
    VOID
    );

VOID
SoftPCI_UpdateConfigSpaceTab(
    VOID
    );

VOID
SoftPCI_UpdateResourceTab(
    VOID
    );

#define MAX_TABS    5
#define EDITWND_BUFFERSIZE     0x8000  //32k

typedef struct _SOFTPCI_TABCTRL{

   PSOFTPCI_TABCTRLUPDATE   UpdateTab;
   
} SOFTPCI_TABCTRL, *PSOFTPCI_TABCTRL;

SOFTPCI_TABCTRL     g_TabCtrl[MAX_TABS];

HWND        g_TabCtrlWnd;
HWND        g_EditWnd;
PPCI_DN     g_PdnToDisplay;
PWCHAR      g_EditWndBuffer;
LONG_PTR    g_TabCtrlWndProc;
ULONG       g_CurrentTabCount = 0;
ULONG       g_CurrentTabSelection = 0;

BOOL        g_CtrlKeyDown = FALSE;
BOOL        g_ShiftKeyDown = FALSE;


VOID 
SoftPCI_AddTabCtrlWindow(
    IN PWCHAR TabText, 
    IN PSOFTPCI_TABCTRLUPDATE   UpdateTab
    )
{

    HWND wndNew;
    TC_ITEM tciNew;
    
    tciNew.mask = TCIF_TEXT;
    tciNew.iImage = -1;
    tciNew.pszText = TabText;
    
    if (g_CurrentTabCount > MAX_TABS) {
        SOFTPCI_ASSERT(FALSE);
        return;
    }

    g_TabCtrl[g_CurrentTabCount].UpdateTab = UpdateTab;   

    TabCtrl_InsertItem(g_TabCtrlWnd, g_CurrentTabCount++, &tciNew) ;

}

SoftPCI_ChangeTabSelection(
    BOOL    IncrementCurrent
    )
{

    SoftPCI_Debug(SoftPciProperty, L"ChangeTabSelection - %s\n", (IncrementCurrent == TRUE) ? L"TRUE" : L"FALSE");
    
    if (IncrementCurrent) {

        g_CurrentTabSelection++;

        if (g_CurrentTabSelection >= g_CurrentTabCount) {
            g_CurrentTabSelection = 0;
        }

    }else{

        g_CurrentTabSelection--;

        if (g_CurrentTabSelection <= 0) {
            g_CurrentTabSelection = g_CurrentTabCount;
        }

    }
    
    TabCtrl_SetCurSel(g_TabCtrlWnd, g_CurrentTabSelection);

}

HWND
SoftPCI_CreateTabCtrlEditWindow(
    IN HWND Wnd
    )
{

    SOFTPCI_ASSERT(g_EditWndBuffer == NULL);
    
    if ((g_EditWndBuffer = (PWCHAR) calloc(1, EDITWND_BUFFERSIZE)) == NULL){
        SoftPCI_Debug(SoftPciProperty, L"CreateTabCtrlEditWindow - Failed to allocate required memory!\n");
        return NULL;
    }
    
    return CreateWindowEx(
        WS_EX_CLIENTEDGE,// | WS_EX_TRANSPARENT,//WS_EX_STATICEDGE
        TEXT("EDIT"), 
        NULL, 
        WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | WS_TABSTOP | 
        WS_VSCROLL | WS_HSCROLL | ES_LEFT | ES_MULTILINE | 
        ES_READONLY,
        0, 0, 0, 0,
        Wnd,
        (HMENU) IDC_EDITVIEW,
        g_Instance, 
        NULL);
}

HWND
SoftPCI_CreateTabCtrlPane(
    IN HWND Wnd
    )
{

    
    //
    //  Create our TabCtrl pane window
    // 
    g_TabCtrlWnd = CreateWindowEx(
        WS_EX_CLIENTEDGE,
        WC_TABCONTROL,
        NULL,
        WS_CHILD | WS_VISIBLE | WS_TABSTOP,
        0, 0, 0, 0,
        Wnd,
        (HMENU) IDC_TABCTL,
        g_Instance,
        NULL
        );
    
    if (g_TabCtrlWnd == NULL){
        SoftPCI_Debug(
            SoftPciAlways, 
            L"CreateTabCtrlPane - Failed to create Tab Control! Error - \"%s\"\n",
            SoftPCI_GetLastError()
            );
        return NULL;
    }
    SoftPCI_SetWindowFont(g_TabCtrlWnd, L"Comic Sans MS");
    
    //
    //  Insert ourself as a filter to our tab control
    //
    g_TabCtrlWndProc = GetWindowLongPtr(g_TabCtrlWnd, GWLP_WNDPROC);
    if (!SetWindowLongPtr(g_TabCtrlWnd,
                          GWLP_WNDPROC,
                          ((LONG_PTR)SoftPCI_TabCtrlWndProc))){
        SOFTPCI_ASSERT(FALSE);
        return FALSE;
    }

    //
    //  Init out edit window and its buffer.
    //
    g_EditWnd = SoftPCI_CreateTabCtrlEditWindow(Wnd);
    if (g_EditWnd == NULL){
        SoftPCI_Debug(
            SoftPciAlways, 
            L"CreateTabCtrlPane - Failed to create g_EditWnd! Error - \"%s\"\n",
            SoftPCI_GetLastError()
            );
        return NULL;
    }
    SoftPCI_SetWindowFont(g_EditWnd, L"Courier New");

    SoftPCI_AddTabCtrlWindow(L"General", SoftPCI_UpdateGeneralTab);
    SoftPCI_AddTabCtrlWindow(L"Resources", SoftPCI_UpdateResourceTab);
    SoftPCI_AddTabCtrlWindow(L"ConfigSpace", SoftPCI_UpdateConfigSpaceTab);
    
    return g_TabCtrlWnd;
}

VOID
SoftPCI_OnTabCtrlSelectionChange(
    VOID
    )
{
    INT currentTabSelection = 0;

    SoftPCI_Debug(SoftPciAlways, L"DevPropWndProc - WM_NOTIFY - TCN_SELCHANGE\n");
        
    currentTabSelection = TabCtrl_GetCurSel(g_TabCtrlWnd);

    SoftPCI_Debug(SoftPciAlways, L"DevPropWndProc - currentTabSelection = 0x%x\n", currentTabSelection);

    if (currentTabSelection == -1) return;
    
    //if (g_CurrentTabSelection == (ULONG) currentTabSelection) return;

    g_CurrentTabSelection = (ULONG) currentTabSelection;

    g_PdnToDisplay = SoftPCI_GetDnFromTreeItem(NULL);

    SoftPCI_UpdateTabCtrlWindow(currentTabSelection);

}

VOID
SoftPCI_SetWindowFont(
    IN HWND Wnd,
    IN PWCHAR  FontName
    )
{


    HDC     hdc;
    LOGFONT lf;
    HFONT   hFont;

    hdc = GetDC(NULL);    
    lf.lfHeight = -9 * GetDeviceCaps(hdc, LOGPIXELSY) / 72;
    lf.lfWidth = 0;              // Auto
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfWeight = FF_DONTCARE;
    lf.lfItalic = 0;
    lf.lfUnderline = 0;
    lf.lfStrikeOut = 0;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_TT_PRECIS;
    lf.lfClipPrecision = CLIP_TT_ALWAYS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH;
    
    wcscpy(lf.lfFaceName, FontName);

    hFont = CreateFontIndirect(&lf);
    ReleaseDC(NULL, hdc);

    SendMessage(Wnd, WM_SETFONT, (WORD)hFont, 0L);

}

LRESULT
WINAPI
SoftPCI_TabCtrlWndProc(
    IN HWND     Wnd,
    IN UINT     Message,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    POINT   pt;  
    
    switch (Message) {
        
        case WM_NCHITTEST:
            
            //
            //  Here we filter this message so as to keep the main windows
            //  from getting them exept for the small left side border of the 
            //  control as we are using that for our SPLIT Pane.
            //
            pt.x = (SHORT)GET_X_LPARAM(lParam); 
            ScreenToClient(Wnd, &pt);
            
            if (pt.x <= GetSystemMetrics(SM_CXSIZEFRAME)) {
                return CallWindowProc((WNDPROC)g_TabCtrlWndProc, Wnd, Message, wParam, lParam); 
            }else{
                return DefWindowProc(Wnd, Message, wParam, lParam);
            }
            break;
    
        default:
            
            return CallWindowProc((WNDPROC)g_TabCtrlWndProc, Wnd, Message, wParam, lParam);
    }

    return 0;
}

VOID
SoftPCI_UpdateGeneralTab(
    VOID
    )
{
    INT         len;
    ULONG       cmProb = 0;
    GUID        *guid;
    LOG_CONF    logConf;
    PULONG      resBuf = NULL;
    ULONG       resSize = 0;

    SoftPCI_GetDeviceNodeProblem(g_PdnToDisplay->DevNode, &cmProb);
    
    wsprintf(g_EditWndBuffer, L"Bus 0x%02x Device 0x%02x Function 0x%02x\r\n\r\n", 
             g_PdnToDisplay->Bus, 
             g_PdnToDisplay->Slot.Device, 
             g_PdnToDisplay->Slot.Function);
    wsprintf(g_EditWndBuffer + wcslen(g_EditWndBuffer), L"Dev Inst ID: %s\r\n\r\n", g_PdnToDisplay->DevId);
    wsprintf(g_EditWndBuffer + wcslen(g_EditWndBuffer), L"Dev WMI ID: %s\r\n\r\n", g_PdnToDisplay->WmiId);

    guid = &g_PdnToDisplay->DevInfoData.ClassGuid;

    wsprintf(g_EditWndBuffer + wcslen(g_EditWndBuffer), L"ClassGUID: %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\r\n\r\n", 
             guid->Data1, guid->Data2, guid->Data3, 
             guid->Data4[0], guid->Data4[1], guid->Data4[2], guid->Data4[3],
             guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7]);

    wsprintf(g_EditWndBuffer + wcslen(g_EditWndBuffer), L"CM Problem Code:\t%s\r\n\r\n", SoftPCI_CmProblemTable[cmProb]);

    wsprintf(g_EditWndBuffer + wcslen(g_EditWndBuffer), L"SoftPCI Private Flags:\t0x%08x\r\n\r\n", g_PdnToDisplay->Flags);
    
    SetWindowText(g_EditWnd, g_EditWndBuffer);
}

VOID
SoftPCI_UpdateConfigSpaceTab(
    VOID
    )
{
    
    
    BOOL                maskDumped = FALSE;
    PPCI_COMMON_CONFIG  commonConfig = NULL;

    if (g_DriverHandle == NULL) {
        wcscpy(g_EditWndBuffer, L"\r\nSoftPCI Support not installed !\r\n");

    }else{

        //
        //  Get the current configspace for this device.
        //
        commonConfig = (PPCI_COMMON_CONFIG) calloc(1, sizeof(PCI_COMMON_CONFIG));

        if ((commonConfig != NULL) &&
            (SoftPCI_GetCurrentConfigSpace(g_PdnToDisplay, commonConfig))) {
            
            wcscpy(g_EditWndBuffer, L"Current Config:\r\n");
        
            SoftPCI_FormatConfigBuffer(g_EditWndBuffer, commonConfig);
            
        }else{
        
            wcscpy(g_EditWndBuffer, 
                   L"Failed to retrieve current config information\r\n"
                   L"from the hardware!\r\n\r\n");
            
        }
        
        if ((g_PdnToDisplay->SoftDev) &&
            (!g_PdnToDisplay->SoftDev->Config.PlaceHolder)) {

            //
            //  
            //
            wcscat(g_EditWndBuffer, L"\r\nSoftPCI Mask:\r\n");
            SoftPCI_FormatConfigBuffer(g_EditWndBuffer, &g_PdnToDisplay->SoftDev->Config.Mask);
        }
    }

    if (commonConfig) {
        free(commonConfig);
    }

    SetWindowText(g_EditWnd, g_EditWndBuffer);
}

VOID
SoftPCI_UpdateResourceTab(
    VOID
    )
{
    
    wcscpy(g_EditWndBuffer, L"Current Resources:\r\n");
    
    if (!SoftPCI_GetResources(g_PdnToDisplay, g_EditWndBuffer, ALLOC_LOG_CONF)){
        wcscat(g_EditWndBuffer, L"\tNo Resources Assigned\r\n");
    }

    wcscat(g_EditWndBuffer, L"\r\n");

    wsprintf(g_EditWndBuffer + wcslen(g_EditWndBuffer), 
                 L"%s\r\n", L"BootConfig Resources:");
    
    if (!SoftPCI_GetResources(g_PdnToDisplay, g_EditWndBuffer, BOOT_LOG_CONF)){
        wcscat(g_EditWndBuffer, L"\tNo BootConfig Available\r\n");
    }

    wcscat(g_EditWndBuffer, L"\r\n");

    SetWindowText(g_EditWnd, g_EditWndBuffer);

}

VOID
SoftPCI_UpdateTabCtrlWindow(
    IN INT CurrentSelection
    )
{
    SoftPCI_Debug(SoftPciProperty, L"UpdateTabCtrlWindow - CurrentSelection = 0x%x\n", CurrentSelection);
    
    
    if (g_TabCtrl[CurrentSelection].UpdateTab) {

        SoftPCI_Debug(SoftPciProperty, L"UpdateTabCtrlWindow - g_TabCtrl[CurrentSelection].UpdateTab = %p\n", 
                      g_TabCtrl[CurrentSelection].UpdateTab);

        g_TabCtrl[CurrentSelection].UpdateTab();

    }

    UpdateWindow(g_TabCtrlWnd);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\tree.c ===
#include "pch.h"

PPCI_TREE
SoftPCI_BuildTree(
    VOID
    );

VOID
SoftPCI_DisplayTreeMenu(
    IN PPCI_DN Pdn,
    IN POINT Pt
    );

VOID
SoftPCI_DisplayStandardTreeMenu(
    IN PPCI_DN Pdn,
    IN POINT Pt
    );

VOID
SoftPCI_DisplayHotplugTreeMenu(
    IN PPCI_DN Pdn,
    IN POINT Pt
    );

VOID
SoftPCI_FreeBranch(
    IN PPCI_DN Dn
    );

VOID
SoftPCI_InsertTreeItem(
    IN PPCI_DN Pdn,
    IN HTREEITEM HtiParent
    );

VOID
SoftPCI_ExpandItem(
    IN HTREEITEM Hti,
    IN PVOID Arg1,
    IN PVOID Arg2
    );

VOID
SoftPCI_RestoreSelection(
    IN HTREEITEM Hti,
    IN PVOID Data1,
    IN PVOID Data2
    );

BOOL            g_TreeCreated = FALSE;
BOOL            g_TreeLocked = FALSE;
BOOL            g_PendingRefresh = FALSE;
PPCI_TREE       g_PciTree;
LONG_PTR        g_DefTreeWndProc;
PWCHAR          g_LastSelection = NULL;


VOID
SoftPCI_CreateTreeView(
    VOID
    )
{


    HTREEITEM htiParent;
    TVITEM tvitem;
    PPCI_DN rootDevNode = NULL;
    HMENU menu = GetMenu(g_SoftPCIMainWnd);
    PPCI_DN pdn = NULL;
    PCI_DN selectedDevNode;
    BOOL selectionFound;
    PWCHAR p;
    //HCURSOR           oldCursor;

    //
    // Empty the tree.
    //
    TreeView_DeleteAllItems(g_TreeViewWnd);

    if (g_TreeCreated) {

        SoftPCI_DestroyTree(g_PciTree);

    }

    g_PciTree = SoftPCI_BuildTree();

    if (!g_PciTree) {
        MessageBox(g_SoftPCIMainWnd, L"Failed to create g_PciTree!", L"ERROR", MB_OK);
        return;
    }

    g_TreeCreated = TRUE;

    SOFTPCI_ASSERT(g_PciTree->ClassImageListData.ImageList != INVALID_HANDLE_VALUE);
    TreeView_SetImageList(g_TreeViewWnd, g_PciTree->ClassImageListData.ImageList, TVSIL_NORMAL);

    //
    // Insert the rest of the items.
    //
    SoftPCI_InsertTreeItem(g_PciTree->RootDevNode, TVI_ROOT);

    //
    // Currently we always expand the entire tree when it is built. Should see
    // if there is a way to avoid this....
    //
    SoftPCI_WalkTree(
        g_PciTree->RootTreeItem, 
        SoftPCI_ExpandItem, 
        NULL, 
        NULL
        );
    
    //
    //  Restore last selection if any
    //
    if (g_LastSelection){
    
        selectionFound = FALSE;
        SoftPCI_WalkTree(
            g_PciTree->RootTreeItem, 
            SoftPCI_RestoreSelection,
            &selectionFound, 
            NULL
            );

        if (!selectionFound) {

            //
            //  If the last selection no longer exists then we back up to the 
            //  parent and check one more time.
            //
            p = g_LastSelection;
            p += wcslen(g_LastSelection);
            while(*p != '\\'){
                p--;
            }
            *p = 0;

            //
            //  Now run the tree one more time looking for the parent
            //
            SoftPCI_WalkTree(
                g_PciTree->RootTreeItem, 
                SoftPCI_RestoreSelection,
                &selectionFound, 
                NULL
                );
        }

    }else{

        TreeView_Select(g_TreeViewWnd, g_PciTree->RootTreeItem, TVGN_CARET);
        TreeView_EnsureVisible(g_TreeViewWnd, g_PciTree->RootTreeItem);
    }

    SoftPCI_UpdateTabCtrlWindow(g_CurrentTabSelection);

}

PPCI_TREE
SoftPCI_BuildTree(VOID)
/*++

Routine Description:

    This function is the entry point for building our PCI_TREE
    
Arguments:

    none

Return Value:

    PPCI_TREE we have created
    
--*/
{

    DEVNODE dn = 0;
    PPCI_DN pdn;
    PPCI_TREE pcitree;

    pcitree = (PPCI_TREE) calloc(1, sizeof(PCI_TREE));
    if (!pcitree) return NULL;

    CM_Locate_DevNode(&dn, NULL, CM_LOCATE_DEVNODE_NORMAL);
    SOFTPCI_ASSERT(dn != 0);

    pcitree->ClassImageListData.ImageList = INVALID_HANDLE_VALUE ;
    pcitree->ClassImageListData.cbSize = sizeof(SP_CLASSIMAGELIST_DATA) ;

    if (!SetupDiGetClassImageList(&pcitree->ClassImageListData)){
        pcitree->ClassImageListData.ImageList = INVALID_HANDLE_VALUE;
    }

    pcitree->DevInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL) ;

    SOFTPCI_ASSERT(pcitree->DevInfoSet != INVALID_HANDLE_VALUE);
    
    //
    //  Now find all things PCI and build a PCI_DN tree
    //
    pdn = NULL;
    SoftPCI_EnumerateDevices(pcitree, &pdn, dn, NULL);

    pcitree->RootDevNode = pdn;

    return pcitree;
}

VOID
SoftPCI_DestroyTree(
    IN PPCI_TREE   PciTree
    )
/*++

Routine Description:

    This routine frees all our allocations for the Tree
    
Arguments:

    PciTree   -   Tree to distroy
    
Return Value:

    none
    
--*/
{
    PPCI_DN dn = PciTree->RootDevNode;

    //
    //  First set the tree view image list to NULL
    //
    TreeView_SetImageList(g_TreeViewWnd, NULL, TVSIL_NORMAL);

    //
    //  Now free all our allocated PCI_DN structs
    //
    SoftPCI_FreeBranch(dn);

    //
    //  Destroy our image and info lists
    //
    if (PciTree->ClassImageListData.ImageList != INVALID_HANDLE_VALUE){
        SetupDiDestroyClassImageList(&PciTree->ClassImageListData);
        PciTree->ClassImageListData.ImageList = INVALID_HANDLE_VALUE;
    }
    
    if (PciTree->DevInfoSet != INVALID_HANDLE_VALUE){
        SetupDiDestroyDeviceInfoList(PciTree->DevInfoSet);
        PciTree->DevInfoSet = INVALID_HANDLE_VALUE;
    }

    //
    //  And finally....
    //
    free(PciTree);

}

VOID
SoftPCI_DisplayTreeMenu(
    IN PPCI_DN Pdn,
    IN POINT Pt
    )
/*++

Routine Description:

    This routine dispatches the menu request to the appropriate menu function
    
Arguments:

    Pdn   -   PCI_DN of the item we are displaying the menu for
    Pt    -   coordinates for the item

Return Value:

    none
    
--*/
{
    if (Pdn->Flags & SOFTPCI_HOTPLUG_SLOT) {

        SoftPCI_DisplayHotplugTreeMenu(Pdn,Pt);

    } else if (Pdn->Flags & SOFTPCI_UNENUMERATED_DEVICE) {
        //
        // If it's an unenumerated device (in an unpowered hotplug slot),
        // you can't do anything with it.
        //
        return;

    } else {

        SoftPCI_DisplayStandardTreeMenu(Pdn, Pt);
    }

    return;
}

VOID
SoftPCI_DisplayStandardTreeMenu(
    IN PPCI_DN Pdn,
    IN POINT Pt
    )
/*++

Routine Description:

    This routine displays the standard context menu when the user right-clicks a device
    
Arguments:

    Pdn   -   PCI_DN of the slot
    Pt    -   coordinates for the device

Return Value:

    none
    
--*/
{

    HMENU menu, popup;
    ULONG dnProblem;
    BOOL enableDevice = FALSE;
    INT selection = 0;

    menu = LoadMenu(g_Instance, MAKEINTRESOURCE(IDM_TREEMENU));

    if (!menu) {
        MessageBox(g_SoftPCIMainWnd, L"failed to display menu!", NULL, MB_OK);
        return;
    }

    popup = GetSubMenu(menu, 0);

    //
    //  If SoftPCI support is not installed or this isnt a bridge device,
    //  disable the option to add devices.
    //
    if ((g_DriverHandle == NULL) ||
        !SoftPCI_IsBridgeDevice(Pdn)) {

        SoftPCI_DisableMenuItem(menu, ID_INSTALLDEVICE);
    }

    if (!SoftPCI_IsSoftPCIDevice(Pdn)) {

        SoftPCI_DisableMenuItem(menu, ID_DELETEDEVICE);
        SoftPCI_DisableMenuItem(menu, ID_STATICDEVICE);
    }

    if (SoftPCI_GetDeviceNodeProblem(Pdn->DevNode, &dnProblem)) {

        if (dnProblem == CM_PROB_DISABLED) {
            enableDevice = TRUE;
            SoftPCI_SetMenuItemText(menu, ID_ENABLEDISABLEDEVICE, L"E&nable Device");
        }else{
            //
            //  For now we will not allow the option to disable a non-working device
            //
            SoftPCI_DisableMenuItem(menu, ID_ENABLEDISABLEDEVICE);
        }
    }

    //
    // If this device is in a hotplug slot, can't just rip out
    // the hardware.  You have to go through the appropriate
    // mechanism.
    //
    if (Pdn->Parent && (Pdn->Parent->Flags & SOFTPCI_HOTPLUG_SLOT)) {

        SoftPCI_DisableMenuItem(menu, ID_DELETEDEVICE);
    }

    //
    //  Make sure it pops up in the right place....
    //
    ClientToScreen(g_SoftPCIMainWnd, &Pt);

    //
    //  lets see the menu
    //
    selection = TrackPopupMenuEx(
        popup,
        TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD,
        Pt.x, Pt.y,
        g_SoftPCIMainWnd,
        NULL
        );

    //
    //  Now we will handle our Floating Tree View menu items
    //
    switch (selection) {
        case ID_INSTALLDEVICE:
            DISPLAY_NEWDEV_DLG(Pdn);
            break;
    
        case ID_ENABLEDISABLEDEVICE:

            SoftPCI_EnableDisableDeviceNode(
                Pdn->DevNode, 
                enableDevice
                );
    
            break;
    
        case ID_DELETEDEVICE:
    
            if ((MessageBox(g_SoftPCIMainWnd,
                           L"This option will delete or surprise remove the device from the system.",
                           L"WARNING", MB_OKCANCEL)) == IDOK){
    
    
                //
                //  Here we tell our driver to delete the specified device.  This will
                //  cause a re-enum of everything that will result in the cleanup
                //  of this device in user mode.
                //
                if (!SoftPCI_DeleteDevice(Pdn->SoftDev)) {
                    MessageBox(g_SoftPCIMainWnd, L"Failed to delete device!", NULL, MB_OK);
                }
    
            }
    
            break;
    
        case ID_STATICDEVICE:
            if (SoftPCI_SaveDeviceToRegisty(Pdn)){
                MessageBox(g_SoftPCIMainWnd, L"Successfully saved devices to registry!", NULL, MB_OK);
            }else{
                MessageBox(g_SoftPCIMainWnd, L"Failed to save devices to registry!", NULL, MB_OK);
            }
            break;

        case ID_REFRESHTREE:
            CM_Reenumerate_DevNode(Pdn->DevNode, 0);
            SoftPCI_CreateTreeView();
            break;
    
        default:
            break;
    }
    
}

VOID
SoftPCI_DisplayHotplugTreeMenu(
    IN PPCI_DN Pdn,
    IN POINT Pt
    )
/*++

Routine Description:

    This routine displays the hotplug specific context menu when the user right-clicks a hotplug slot.
    
Arguments:

    Pdn   -   PCI_DN of the slot
    Pt    -   coordinates for the slot

Return Value:

    none

--*/
{

    HMENU menu, popup;
    INT selection;
    PPCI_DN parentDn;
    BOOL status;
    SHPC_SLOT_STATUS_REGISTER slotStatus;

    menu = LoadMenu(g_Instance, MAKEINTRESOURCE(IDM_HOTPLUGSLOTMENU));

    if (!menu) {
        MessageBox(g_SoftPCIMainWnd, L"failed to display menu!", NULL, MB_OK);
        return;
    }

    popup = GetSubMenu(menu, 0);

    //
    //  If SoftPCI support is not installed disable the option to add devices.
    //
    if (!g_DriverHandle) {

        SoftPCI_DisableMenuItem(menu, ID_INSTALLDEVICE);
    }

    //
    //  If our Device Property dialog is open dont allow properties to be
    //  selected again.
    //
    if (g_NewDevDlg) {

        //
        //  ISSUE: BrandonA - Figure out why we hang if the first Dialog 
        //  launched is killed before the second...
        //
        SoftPCI_DisableMenuItem(menu, ID_INSTALLDEVICE);
    }
    //
    // DWALKER
    // Get slot status from driver
    // appropriately grey out open/close MRL menu item.
    // if MRL is closed, disable removing the device.
    //
    parentDn = Pdn->Parent;
    status = SoftPCI_GetSlotStatus(parentDn,
                                   Pdn->Slot.Function,
                                   &slotStatus
                                   );
    if (status == FALSE) {
        MessageBox(g_SoftPCIMainWnd, L"failed to display menu!", NULL, MB_OK);
        return;
    }
    //
    // If the MRL is closed, you can't insert or remove the device.
    // Otherwise, disable the appropriate menu item based on the presence
    // of a device in the slot.
    //
    if (slotStatus.MRLSensorState == SHPC_MRL_CLOSED) {

        SoftPCI_DisableMenuItem(menu, ID_REMOVEHPDEVICE);
        SoftPCI_DisableMenuItem(menu, ID_INSTALLDEVICE);

    } else if (Pdn->Child == NULL) {

        SoftPCI_DisableMenuItem(menu, ID_REMOVEHPDEVICE);

    } else {

        SoftPCI_DisableMenuItem(menu, ID_INSTALLDEVICE);
    }

    if (slotStatus.MRLSensorState == SHPC_MRL_CLOSED) {

        RemoveMenu(menu, ID_CLOSEMRL, MF_BYCOMMAND);

    } else {

        RemoveMenu(menu, ID_OPENMRL, MF_BYCOMMAND);
    }

    AppendMenu(popup, MF_SEPARATOR, 0, NULL);

    switch (slotStatus.PowerIndicatorState) {
        case SHPC_INDICATOR_OFF:
            AppendMenu(popup, MF_STRING | MF_GRAYED, ID_POWERINDICATOR, L"Power Indicator: Off");
            break;
        case SHPC_INDICATOR_ON:
            AppendMenu(popup, MF_STRING | MF_GRAYED, ID_POWERINDICATOR, L"Power Indicator: On");
            break;
        case SHPC_INDICATOR_BLINK:
            AppendMenu(popup, MF_STRING | MF_GRAYED, ID_POWERINDICATOR, L"Power Indicator: Blinking");
            break;
        case SHPC_INDICATOR_NOP:
            AppendMenu(popup, MF_STRING | MF_GRAYED, ID_POWERINDICATOR, L"Power Indicator: Unspecified");
            break;
    }

    switch (slotStatus.AttentionIndicatorState) {
        case SHPC_INDICATOR_OFF:
            AppendMenu(popup, MF_STRING | MF_GRAYED, ID_ATTENINDICATOR, L"Attention Indicator: Off");
            break;
        case SHPC_INDICATOR_ON:
            AppendMenu(popup, MF_STRING | MF_GRAYED, ID_ATTENINDICATOR, L"Attention Indicator: On");
            break;
        case SHPC_INDICATOR_BLINK:
            AppendMenu(popup, MF_STRING | MF_GRAYED, ID_ATTENINDICATOR, L"Attention Indicator: Blinking");
            break;
        case SHPC_INDICATOR_NOP:
            AppendMenu(popup, MF_STRING | MF_GRAYED, ID_POWERINDICATOR, L"Attention Indicator: Unspecified");
            break;
    }

    //
    // Get the menu updated after our additions.
    //
    //DrawMenuBar(g_SoftPCIMainWnd);

    //
    //  Make sure it pops up in the right place....
    //
    ClientToScreen(g_SoftPCIMainWnd, &Pt);

    //
    //  lets see the menu
    //
    selection = TrackPopupMenuEx(popup,
                                 TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD,
                                 Pt.x, Pt.y,
                                 g_SoftPCIMainWnd,
                                 NULL
                                 );


    //
    //  Now we will handle our Floating Tree View menu items
    //
    switch (selection) {

    case ID_INSTALLDEVICE:

        //
        //  For now kill any dialogs we may already have open before starting this one
        //
        //if (g_DevPropDlg) {
        //    SendMessage(g_DevPropDlg, WM_CLOSE, 0L, 0L);
        //}

        DISPLAY_NEWDEV_DLG(Pdn);

        break;

    case ID_REMOVEHPDEVICE:

        SoftPCI_RemoveHotplugDevice(parentDn,
                                    Pdn->Slot.Function
                                    );
        SoftPCI_CreateTreeView();
        break;

    case ID_CLOSEMRL:
        SoftPCI_ExecuteHotplugSlotMethod(parentDn,
                                         Pdn->Slot.Function,
                                         MRLClose
                                         );
        break;

    case ID_OPENMRL:
        SoftPCI_ExecuteHotplugSlotMethod(parentDn,
                                         Pdn->Slot.Function,
                                         MRLOpen
                                         );
        break;

    case ID_ATTENBUTTON:
        SoftPCI_ExecuteHotplugSlotMethod(parentDn,
                                         Pdn->Slot.Function,
                                         AttentionButton
                                         );
        break;

    default:
        break;
    }

    //
    //  Make sure we dont lose our focus
    //
    //SetFocus(g_TreeViewWnd);

}

VOID
SoftPCI_FreeBranch(
    IN PPCI_DN Dn
    )
/*++

Routine Description:

    This routine will free the specified PCI_DN struct along with all siblings and children.  
    
Arguments:

    Dn   -   PCI_DN to free

Return Value:

    none

--*/
{

    PPCI_DN child, sibling;

    if (Dn) {

        child = Dn->Child;
        sibling = Dn->Sibling;

        if (Dn->SoftDev) {
            free(Dn->SoftDev);
        }

        SetupDiDeleteDeviceInfo(Dn->PciTree->DevInfoSet, &Dn->DevInfoData) ;

        free(Dn);

        SoftPCI_FreeBranch(child);

        SoftPCI_FreeBranch(sibling);
    }
}

VOID
SoftPCI_OnTreeSelectionChange(
    IN HWND Wnd
    )
/*++

Routine Description:

    This routine informs our properties sheet that the selection has changes so that it can update
    
Arguments:

    Wnd   -   

Return Value:

    none

--*/
{

    TV_ITEM tviItem;
    PPCI_DN pdn = NULL;
    RECT itemRect;
    ULONG slotCount;

    //
    // Get the Current Item
    //
    tviItem.mask = TVIF_PARAM;
    tviItem.hItem = TreeView_GetSelection(g_TreeViewWnd);
    tviItem.lParam = 0;
    TreeView_GetItem(g_TreeViewWnd, &tviItem);

    if (tviItem.lParam) {

        g_PdnToDisplay = (PPCI_DN)tviItem.lParam;

        if (g_LastSelection) {
            free(g_LastSelection);
            g_LastSelection = NULL;
        }

        //
        //  Save the last selection so we can restore it if the tree
        //  is rebuilt.
        //
        g_LastSelection = SoftPCI_GetPciPathFromDn(g_PdnToDisplay);

        SoftPCI_UpdateTabCtrlWindow(g_CurrentTabSelection);
    }
}


LRESULT
WINAPI
SoftPCI_TreeWndProc(
    IN HWND Wnd,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    This routine hooks the Tree Window message proc and is responsible
    for resizing our pane window when it is resized.

Arguments:

    hWnd    -   Window handle
    Message -   Message to process
    wParam  -   Message param
    lParam  -   Message param

Return Value:

    return value depends on message handled.

--*/
{

    RECT rectMain, rectTree;
    TV_ITEM tviItem;
    TVHITTESTINFO hitinfo;
    PPCI_DN pdn;
    PCI_DN dn;
    RECT itemRect;
    POINT pt;

    //
    // Get the Current Item
    //
    //

    switch (Message) {

    case WM_KEYDOWN:

        switch (wParam){

        case VK_APPS:

            //
            //  Grab the PCI_DN from the current tree item
            //
            pdn = SoftPCI_GetDnFromTreeItem(NULL);

            
            //
            //  We copy this to a new DN because the TREE is constantly being
            //  rebuilt and we cannot rely on the TV_ITEM.lParam value to always
            //  be accurate later (we may have changed it).
            //
            RtlCopyMemory(&dn, pdn, sizeof(PCI_DN));

            if (TreeView_GetItemRect(g_TreeViewWnd,
                                     TreeView_GetSelection(g_TreeViewWnd),
                                     &itemRect,
                                     TRUE)) {

                //
                //  Adjust the location for our menu
                //
                pt.x = itemRect.right;
                pt.y = itemRect.top;

                SoftPCI_DisplayTreeMenu(&dn, pt);
            }
            break;

        default:
            return CallWindowProc((WNDPROC)g_DefTreeWndProc, Wnd, Message, wParam, lParam);

        }

        break;

    case WM_RBUTTONDOWN:

        ZeroMemory(&hitinfo, sizeof(TVHITTESTINFO));

        hitinfo.pt.x = GET_X_LPARAM(lParam);
        hitinfo.pt.y = GET_Y_LPARAM(lParam);

        if (TreeView_HitTest(g_TreeViewWnd, &hitinfo)) {

            g_TreeLocked = TRUE;

            pdn = SoftPCI_GetDnFromTreeItem(hitinfo.hItem);

            //
            //  See comment above for reason why we copy this here....
            //
            RtlCopyMemory(&dn, pdn, sizeof(PCI_DN));

            //
            //  If an item in the tree is already selected this will cause the selection to change
            //  as each item is right clicked.
            //
            TreeView_Select(g_TreeViewWnd, hitinfo.hItem, TVGN_CARET);

            SoftPCI_DisplayTreeMenu(&dn, hitinfo.pt);

            g_TreeLocked = FALSE;

            if (g_PendingRefresh) {
                g_PendingRefresh = FALSE;
                SoftPCI_CreateTreeView();
            }
        }

        break;

    default:
        return CallWindowProc((WNDPROC)g_DefTreeWndProc, Wnd, Message, wParam, lParam);
    }

    return 0;
}

PPCI_DN
SoftPCI_GetDnFromTreeItem(
    IN HTREEITEM TreeItem
    )
/*++

Routine Description:

    This routine returns a PCI_DN for either the currently selected TreeItem
    or the one specified by the caller.

Arguments:

    TreeItem   -   Handle to TreeItem we want to query.  If NULL then we default to current selection.

Return Value:

    return value will be TV_ITEM.lParam value

--*/
{

    TV_ITEM tviItem;

    tviItem.mask = TVIF_PARAM;
    tviItem.hItem = (TreeItem ? TreeItem : TreeView_GetSelection(g_TreeViewWnd));
    tviItem.lParam = 0;
    TreeView_GetItem(g_TreeViewWnd, &tviItem);

    SOFTPCI_ASSERT(((PPCI_DN)tviItem.lParam) != NULL);
    
    return (PPCI_DN)tviItem.lParam;
}

VOID
SoftPCI_InsertTreeItem(
    IN PPCI_DN Pdn,
    IN HTREEITEM HtiParent
)
/*++

Routine Description:

    This routine takes our tree of PCI_DN structs and builds the UI representaion of it.
    
Arguments:

    Pdn         Current Pdn being intserted
    HtiParent   The HTREEITEM that is to be the parent of this Pdn

Return Value:

    none

--*/
{
    PPCI_DN childDevNode;
    PPCI_DN siblingDevNode;
    TV_INSERTSTRUCT tvInsertStruct;
    HTREEITEM htiNewParent;
    TV_ITEM tvi;
    INT index;
    ULONG problem;

    SOFTPCI_ASSERT(Pdn != NULL);

    do {

        childDevNode = Pdn->Child;
        siblingDevNode = Pdn->Sibling;

        //
        // Get the parent item, and tell it it has children now
        //
        if (HtiParent != TVI_ROOT) {

            tvi.mask = TVIF_CHILDREN;
            tvi.hItem = HtiParent;

            TreeView_GetItem(g_TreeViewWnd, &tvi);

            //
            // Increment the ChildCount;
            //
            ++tvi.cChildren;
            TreeView_SetItem(g_TreeViewWnd, &tvi);
        }

        //
        // Add This Device at the current Level
        //
        tvInsertStruct.hParent = HtiParent;
        tvInsertStruct.hInsertAfter = TVI_LAST;
        tvInsertStruct.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_STATE;
        tvInsertStruct.item.cChildren = 0;
        tvInsertStruct.item.lParam = (ULONG_PTR) Pdn;

        tvInsertStruct.item.state = INDEXTOOVERLAYMASK(0);
        
        //
        //  If the device has a problem make let's reflect so....
        //
        if (SoftPCI_GetDeviceNodeProblem(Pdn->DevNode, &problem)){

            if (problem == CM_PROB_DISABLED) {
                tvInsertStruct.item.state = INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
            }else{
                tvInsertStruct.item.state = INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
            }
        }

        tvInsertStruct.item.stateMask = TVIS_OVERLAYMASK | TVIS_CUT;

        tvInsertStruct.item.pszText = (LPTSTR) Pdn->FriendlyName;

        //
        //  Figure out which icon goes which each device.
        //
        if (SetupDiGetClassImageIndex(&Pdn->PciTree->ClassImageListData, &Pdn->DevInfoData.ClassGuid, &index)){
            tvInsertStruct.item.iImage = tvInsertStruct.item.iSelectedImage = index ;
        }else{
           tvInsertStruct.item.iImage = tvInsertStruct.item.iSelectedImage = -1 ;
        }
        
        htiNewParent = TreeView_InsertItem(g_TreeViewWnd, &tvInsertStruct);

        if (g_PciTree->RootTreeItem == NULL) {
            g_PciTree->RootTreeItem = htiNewParent;
        }

        //
        //  if this device has a child lets walk them next
        //
        if (childDevNode){
            SoftPCI_InsertTreeItem(childDevNode, htiNewParent);
        }

    }while ((Pdn = siblingDevNode) != NULL);
}

VOID
SoftPCI_ExpandItem(
    IN HTREEITEM Hti,
    IN PULONG Data1,
    IN PULONG Data2
    )
{
    //
    //  Expand this item.
    //
    TreeView_Expand(g_TreeViewWnd, Hti, TVE_EXPAND);

}

VOID
SoftPCI_RestoreSelection(
    IN HTREEITEM Hti,
    IN PVOID Data1,
    IN PVOID Data2
    )
{

    PWCHAR slotPath, p;
    PPCI_DN pdn;
    PBOOL selectionFound;

    selectionFound = (PBOOL)Data1;

    pdn = SoftPCI_GetDnFromTreeItem(Hti);
    if (pdn == NULL) {
        return;
    }

    slotPath = SoftPCI_GetPciPathFromDn(pdn);

    if ((wcscmp(slotPath, g_LastSelection)) == 0) {
        
        //
        //  Restore the selection to this point.
        //
        TreeView_Select(g_TreeViewWnd, Hti, TVGN_CARET);
        TreeView_EnsureVisible(g_TreeViewWnd, Hti);
        *selectionFound = TRUE;
    }

    free(slotPath);
}


VOID
SoftPCI_WalkTree(
    IN HTREEITEM Hti,
    IN PSOFTPCI_TREECALLBACK TreeCallback,
    IN PVOID Arg1,
    IN PVOID Arg2
    )
{
    if (Hti) {

        //
        // Call the CallBack.
        //
        (*TreeCallback)(Hti, Arg1, Arg2);

        //
        // Call this on my first child.
        //
        SoftPCI_WalkTree(TreeView_GetChild(g_TreeViewWnd, Hti),
                         TreeCallback,
                         Arg1,
                         Arg2
                         );

        //
        // Call this on my first sibling.
        //
        SoftPCI_WalkTree(TreeView_GetNextSibling(g_TreeViewWnd, Hti),
                         TreeCallback,
                         Arg1,
                         Arg2
                         );

      }
}

#if 0
VOID
SoftPCI_GetDnFromTree(
    IN HTREEITEM Hti,
    IN OUT PVOID Pdn,    //PPCI_DN *
    IN PVOID PdnToFind
    )
{

    TV_ITEM tvi;
    PPCI_DN pdn = NULL;
    PPCI_DN pdnToFind = (PPCI_DN)PdnToFind;

    tvi.lParam = 0;
    tvi.hItem = Hti;

    TreeView_GetItem(g_TreeViewWnd, &tvi);

    pdn = (PPCI_DN)tvi.lParam;

    if (pdn) {

        if ((pdnToFind->Bus == pdn->Bus) &&
            (pdnToFind->Device == pdn->Device) &&
            (pdnToFind->Function == pdn->Function)) {

            *(PPCI_DN *)Pdn = pdn;
        }

    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\tree.h ===
#ifndef _SOFTPCITREEH_
#define _SOFTPCITREEH_

extern BOOL         g_TreeCreated;
extern BOOL         g_TreeLocked;
extern BOOL         g_PendingRefresh;
extern PPCI_TREE    g_PciTree;
extern LONG_PTR     g_DefTreeWndProc;
extern PWCHAR       g_LastSelection;

typedef VOID (*PSOFTPCI_TREECALLBACK)(HTREEITEM, PVOID, PVOID);

VOID
SoftPCI_CreateTreeView(
    VOID
    );

VOID
SoftPCI_DestroyTree(
    IN PPCI_TREE PciTree
    );

VOID
SoftPCI_OnTreeSelectionChange(
    IN  HWND    Wnd
    );

LRESULT
WINAPI
SoftPCI_TreeWndProc(
    IN HWND hWnd, 
    IN UINT Message, 
    IN WPARAM wParam, 
    IN LPARAM lParam
    );

PPCI_DN
SoftPCI_GetDnFromTreeItem(
    IN HTREEITEM    TreeItem
    );

#if 0
VOID
SoftPCI_GetDnFromTree(
    IN HTREEITEM Hti,
    IN OUT PVOID Pdn,    //PPCI_DN *
    IN PVOID PdnToFind
    );
#endif

VOID 
SoftPCI_WalkTree(
    IN HTREEITEM             Hti, 
    IN PSOFTPCI_TREECALLBACK TreeCallback, 
    IN PVOID                 Arg1,
    IN PVOID                 Arg2
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\utils.h ===
#define USERMS          L"Software\\Microsoft"
#define USERMS_SOFTPCI  L"Software\\Microsoft\\SoftPCI"
#define CCS             L"SYSTEM\\CurrentControlSet\\Control"
#define CCS_SOFTPCI     L"SYSTEM\\CurrentControlSet\\Control\\SoftPCI"
#define SOFTPCI_KEY     L"SoftPCI"

typedef struct _SOFTPCI_WNDVIEW {
    WINDOWPLACEMENT WindowPlacement;
    INT PaneSplit;
}SOFTPCI_WNDVIEW, *PSOFTPCI_WNDVIEW;


#define SoftPCI_DisableMenuItem(Menu, MenuItem) \
    EnableMenuItem(Menu, MenuItem, MF_GRAYED)

#define SoftPCI_SetMenuItemText(Menu, MenuItem, ItemText)   \
    ModifyMenu(Menu, MenuItem, MF_STRING, MenuItem, ItemText)


HBRUSH
PASCAL
SoftPCI_CreateDitheredBrush(
    VOID
    );

VOID
SoftPCI_FormatConfigBuffer(
    IN PWCHAR   Buffer,
    IN PPCI_COMMON_CONFIG   Config
    );

VOID
SoftPCI_HandleImportDevices(
    VOID
    );

BOOL
SoftPCI_InitializeRegistry(
    VOID
    );

BOOL
SoftPCI_QueryWindowSettings(
    OUT PSOFTPCI_WNDVIEW ViewSettings
    );

VOID
SoftPCI_StringToLowerW(
    IN PWCHAR   String
    );

VOID
SoftPCI_StringToLower(
    IN PWCHAR   String
    );

BOOL
SoftPCI_SaveDeviceToRegisty(
    IN PPCI_DN          Pdn
    );

VOID
SoftPCI_SaveWindowSettings(
    VOID
    );

PWCHAR
SoftPCI_GetLastError(
    VOID
    );

VOID
SoftPCI_MessageBox(
    IN PWCHAR  MessageTitle,
    IN PWCHAR  DebugMessage,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\exe\utils.c ===
#include "pch.h"

#define SOFTPCIVIEW     L"ViewSettings" 
WCHAR   g_LastError[MAX_PATH];

BOOL
SoftPCI_WriteDeviceListToRegistry(
    IN PHKEY RegKeyHandle,
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY CurrentEntry
    );

HBRUSH
PASCAL
SoftPCI_CreateDitheredBrush(
    VOID
    )
{

    WORD graybits[] = {0x5555,0xAAAA,0x5555,0xAAAA,0x5555,0xAAAA,0x5555,0xAAAA};
    HBRUSH hBrush;
    HBITMAP hBitmap;

    if ((hBitmap = CreateBitmap(8, 8, 1, 1, graybits)) != NULL) {

        hBrush = CreatePatternBrush(hBitmap);
        DeleteObject(hBitmap);
    }else{
        hBrush = NULL;
    }
    return hBrush;
}

VOID
SoftPCI_FormatConfigBuffer(
    IN PWCHAR   Buffer,
    IN PPCI_COMMON_CONFIG   Config
    )
{

    ULONG   i = 0, offset;
    PULONG  p = NULL;
    
    p = (PULONG)Config;

    offset = 0;

    wsprintf(Buffer + wcslen(Buffer), L"%02X: ", offset);
    
    for (i=0; i < (sizeof(PCI_COMMON_CONFIG) / sizeof(ULONG)); i++) {
        
        wsprintf(Buffer + wcslen(Buffer), L"%08X", *p);

        if ((((i+1) % 4) == 0) ||
            ((i+1) == (sizeof(PCI_COMMON_CONFIG) / sizeof(ULONG)))) {
            wcscat(Buffer, L"\r\n");

            if (((offset+=0x10) < sizeof(PCI_COMMON_CONFIG))) {
                wsprintf(Buffer + wcslen(Buffer), L"%02X: ", offset);
            }

        }else{
            wsprintf(Buffer + wcslen(Buffer), L",");
        }

        p++;
    }
}

PWCHAR
SoftPCI_GetLastError(
    VOID
    )
{

    DWORD  len = 0;
    
    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        GetLastError(),
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR) g_LastError,
                        MAX_PATH,
                        NULL 
                        );

    if (len) {
        //
        //  Drop the extra CR
        //
        g_LastError[len - 2] = 0;
    }else{
        wcscpy(g_LastError, L"Failed to retrive LastError() info!");
    }

    return g_LastError;

}

VOID
SoftPCI_HandleImportDevices(
    VOID
    )
{
    OPENFILENAME openFileName;
    WCHAR filePath[MAX_PATH];
    WCHAR initialDir[MAX_PATH];
    WCHAR importTitle[] = L"Import Devices";
    BOOL result;

    RtlZeroMemory(&openFileName, sizeof(OPENFILENAME));

    if ((GetCurrentDirectory(MAX_PATH, initialDir)) == 0){
        //
        //  error out
        //
        return;
    }

    filePath[0] = 0;

    openFileName.lStructSize = sizeof(OPENFILENAME);
    openFileName.hwndOwner = g_SoftPCIMainWnd;
    openFileName.hInstance = g_Instance;
    openFileName.lpstrFile = filePath;
    openFileName.nMaxFile = MAX_PATH;
    openFileName.lpstrTitle = importTitle;
    openFileName.lpstrInitialDir = initialDir;

    openFileName.Flags = OFN_HIDEREADONLY | OFN_EXPLORER | OFN_FILEMUSTEXIST;

    result = GetOpenFileName(&openFileName);

    if (result) {

        if (SoftPCI_BuildDeviceInstallList(filePath)){

            SoftPCI_InstallScriptDevices();

        }else{

            SoftPCI_MessageBox(L"Error Parsing Script File!",
                               L"%s\n",
                               g_ScriptError
                               );
        }
    }
}

BOOL
SoftPCI_InitializeRegistry(
    VOID
    )
{
    HKEY key, key2;
    LONG cr;
    DWORD result;
    
    cr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CCS_SOFTPCI, 0, KEY_ALL_ACCESS, &key);

    if (cr != ERROR_SUCCESS) {
        
        //
        //  If we failed to open our key then we need to try and create it
        //
        if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE, CCS, 0, KEY_ALL_ACCESS, &key)) == ERROR_SUCCESS){

            if ((RegCreateKeyEx(key, 
                                SOFTPCI_KEY, 
                                0, 
                                NULL, 
                                REG_OPTION_NON_VOLATILE, 
                                KEY_ALL_ACCESS, 
                                NULL, 
                                &key2, 
                                &result)) == ERROR_SUCCESS) {

#if 0
                if (result = REG_CREATED_NEW_KEY) {
                    PRINTF("Key didnt exist so we created a new one!\n");
                }else if (result = REG_OPENED_EXISTING_KEY) {
                    PRINTF("Key already exists so we just opened it!\n");
                }else{
                    PRINTF("Key Created successfully!\n");
                }
#endif
                //
                //  Our key now exists
                //
                RegCloseKey(key2);
            }

        }else{

            //
            //  Failed to open CCS!  Very bad!
            //
            return FALSE;
        }
    }
    
    RegCloseKey(key);

    return TRUE;
}

VOID
SoftPCI_MessageBox(
    IN PWCHAR  MessageTitle,
    IN PWCHAR  MessageBody,
    ...
    )
{

    va_list ap;
    WCHAR   buffer[MAX_PATH];

    va_start(ap, MessageBody);

    _vsnwprintf(buffer, (sizeof(buffer)/sizeof(buffer[0])), MessageBody, ap);
    
    MessageBox(NULL, buffer, MessageTitle, MB_OK);
}

BOOL
SoftPCI_QueryWindowSettings(
    OUT PSOFTPCI_WNDVIEW ViewSettings
    )
{

    BOOL result;
    HKEY key;
    LONG cr;
    ULONG size, regType;
    
    result = FALSE;
    cr = RegOpenKeyEx(HKEY_CURRENT_USER, USERMS_SOFTPCI, 0, KEY_ALL_ACCESS, &key);
    if (cr == ERROR_SUCCESS) {
        
        //
        //  Grab our window settings from the registry
        // 
        size = sizeof(SOFTPCI_WNDVIEW);
        cr = RegQueryValueEx(
            key, 
            SOFTPCIVIEW, 
            NULL, 
            &regType, 
            (LPBYTE)ViewSettings, 
            &size
            );

        if ((cr == ERROR_SUCCESS) && 
            (regType == REG_BINARY) && 
            (size == sizeof(SOFTPCI_WNDVIEW))) {
            
            result = TRUE;
        }

        RegCloseKey(key);

    }

    return result;
    
}

BOOL
SoftPCI_SaveDeviceToRegisty(
    IN PPCI_DN Pdn
    )
{
    HKEY regKeyHandle;
    BOOL result = FALSE;
    LIST_ENTRY devicePathList;
    
    InitializeListHead(&devicePathList);

    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE, CCS_SOFTPCI, 0, KEY_ALL_ACCESS, &regKeyHandle)) == ERROR_SUCCESS){

        if (SoftPCI_GetDevicePathList(Pdn, &devicePathList)) {

            result = SoftPCI_WriteDeviceListToRegistry(&regKeyHandle, &devicePathList, devicePathList.Flink);
        }

        RegCloseKey(regKeyHandle);
    }

    return result;
}

VOID
SoftPCI_SaveWindowSettings(
    VOID
    )
{

    HKEY key, key2;
    LONG cr;
    ULONG status;
    SOFTPCI_WNDVIEW wndView;

    RtlZeroMemory(&wndView, sizeof(SOFTPCI_WNDVIEW));
    
    if (!GetWindowPlacement(g_SoftPCIMainWnd, &wndView.WindowPlacement)) {
        return;
    }

    wndView.PaneSplit = g_PaneSplit;
    
    cr = RegOpenKeyEx(
        HKEY_CURRENT_USER, 
        USERMS_SOFTPCI, 
        0, 
        KEY_ALL_ACCESS, 
        &key
        );
    if (cr == ERROR_SUCCESS) {
        
        cr = RegSetValueEx(
            key, 
            SOFTPCIVIEW, 
            0, 
            REG_BINARY, 
            (PBYTE)&wndView, 
            sizeof(SOFTPCI_WNDVIEW)
            );
        
        RegCloseKey(key);
    }else{

        cr = RegOpenKeyEx(
            HKEY_CURRENT_USER, 
            USERMS, 
            0, 
            KEY_ALL_ACCESS, 
            &key
            );
        if (cr == ERROR_SUCCESS){

            cr = RegCreateKeyEx(
                key,
                SOFTPCI_KEY, 
                0, 
                NULL, 
                REG_OPTION_NON_VOLATILE, 
                KEY_ALL_ACCESS, 
                NULL, 
                &key2, 
                &status
                );
            if (cr == ERROR_SUCCESS) {
            
                RegSetValueEx(
                    key2, 
                    SOFTPCIVIEW, 
                    0, 
                    REG_BINARY, 
                    (PBYTE)&wndView, 
                    sizeof(SOFTPCI_WNDVIEW)
                    );
            }
            RegCloseKey(key2);
        }
        RegCloseKey(key);
    }
}


BOOL
SoftPCI_WriteDeviceListToRegistry(
    IN PHKEY RegKeyHandle,
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY CurrentEntry
    )
{
    BOOL result = FALSE;
    LONG cr;
    ULONG createStatus;
    HKEY newKey;
    PPCI_DN pdn;
    WCHAR buffer[sizeof(L"XXXX")];
    PSOFTPCI_CONFIG softConfig;

    if (ListHead == CurrentEntry) {
        //
        //  We are done.
        //
        return TRUE;
    }

    pdn = CONTAINING_RECORD(CurrentEntry, PCI_DN, ListEntry);

    softConfig = &pdn->SoftDev->Config;
    
    wsprintf(buffer, L"%04x", pdn->Slot.AsUSHORT);

    SoftPCI_Debug(SoftPciAlways, L"Saving Slot %04x to registry\n", pdn->Slot.AsUSHORT);

    if ((RegCreateKeyEx(*RegKeyHandle,
                        buffer, 
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_ALL_ACCESS, 
                        NULL, 
                        &newKey, 
                        &createStatus)) == ERROR_SUCCESS) {
        
        if (createStatus = REG_CREATED_NEW_KEY) {
            SoftPCI_Debug(SoftPciAlways, L"Key didnt exist so we created a new one!\n");
        }else if (createStatus = REG_OPENED_EXISTING_KEY) {
            SoftPCI_Debug(SoftPciAlways, L"Key already exists so we just opened it!\n");
        }else{
            SoftPCI_Debug(SoftPciAlways, L"Key Created successfully!\n");
        }

        cr = RegSetValueEx(newKey, L"Config", 0, REG_BINARY, (PBYTE)softConfig, sizeof(SOFTPCI_CONFIG));
        
        if (cr != ERROR_SUCCESS) {

            MessageBox(NULL, L"Failed to update Registry!", L"FAILED", MB_OK);
            return FALSE;
        }

        //
        //  Write out anything remaining in the list
        //
        result = SoftPCI_WriteDeviceListToRegistry(&newKey, ListHead, CurrentEntry->Flink);

        RegCloseKey(newKey);

        return result;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\debug.h ===
#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef DBG

//
//  Standard output levels
//
#define SOFTPCI_ERROR       DPFLTR_ERROR_LEVEL      //0
#define SOFTPCI_WARNING     DPFLTR_WARNING_LEVEL    //1
#define SOFTPCI_VERBOSE     DPFLTR_TRACE_LEVEL      //2
#define SOFTPCI_INFO        DPFLTR_INFO_LEVEL       //3

//
//  SoftPci Specific output levels
//
#define SOFTPCI_IRP_PNP         0x00000010
#define SOFTPCI_FDO_PO          0x00000020
#define SOFTPCI_ADD_DEVICE      0x00000040
#define SOFTPCI_FIND_DEVICE     0x00000080
#define SOFTPCI_REMOVE_DEVICE   0x00000100
#define SOFTPCI_QUERY_CAP       0x00000200
#define SOFTPCI_BUS_NUM         0x00000400
#define SOFTPCI_IOCTL_LEVEL     0x00000800


#define SOFTPCI_DEBUG_BUFFER_SIZE  256

VOID
SoftPCIDbgPrint(
    IN ULONG   DebugPrintLevel,
    IN PCCHAR  DebugMessage,
    ...
    );


#else

#define SoftPCIDbgPrint()

#endif //DBG

#endif //_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\device.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    device.c

Abstract:

    This module contains functions for handling Read/Write to Config Space.

Author:

    Nicholas Owens (Nichow)

Revision History:

    BrandonA - Feb. 2000 - Updated to support Read/Write from PCI_COMMON_CONFIG instead of private headers.

--*/

#include "pch.h"

BOOLEAN
SoftPCIValidSlot(
    IN PSOFTPCI_DEVICE  FirstDevice,
    IN PSOFTPCI_SLOT Slot
    );

VOID
WriteByte(
    IN PSOFTPCI_DEVICE device,
    IN ULONG Register,
    IN UCHAR Data
    );

VOID
WriteByte(
    IN PSOFTPCI_DEVICE Device,
    IN ULONG Register,
    IN UCHAR Data
    )
{

    PSOFTPCI_DEVICE child;
    PUCHAR config;
    PUCHAR mask;

    ASSERT(Register < sizeof(PCI_COMMON_CONFIG));
    
    config = (PUCHAR)&Device->Config.Current;
    mask   = (PUCHAR)&Device->Config.Mask;
    
    if (Register < sizeof(PCI_COMMON_CONFIG)) {

        config += Register;
        mask += Register;

        //
        //  If we are writing to a SoftPCI-PCI Bridge lets check and see it
        //  it happens to be the SecondaryBusNumber Register.
        //
        if (IS_BRIDGE(Device)) {

            if (Register == (UCHAR) FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.SecondaryBus)) {

                SoftPCIDbgPrint(
                    SOFTPCI_BUS_NUM, 
                    "SOFTPCI: Assigning DEV_%02x&FUN_%02x Bus #%02x\n",
                    Device->Slot.Device, 
                    Device->Slot.Function, 
                    Data
                    );

                //
                //  If we have children update thier bus numbers as well.
                //
                child = Device->Child; 
                while(child){
                    child->Bus = Data;
                    child = child->Sibling;
                }

            }
        }

        //
        //  Preserve the read-only bits first
        //
        *config &= ~(*mask);

        //
        //  Verify the bits trying to be written are allowed.
        //
        Data &= *mask;

        //
        //  Update the register with the new value if any
        //
        *config |= Data;
    }
}

NTSTATUS
SoftPCIAddNewDevice(
    IN PSOFTPCI_DEVICE NewDevice
    )
/*++

Routine Description:

    This function is called by SoftPciAddDeviceIoctl when and ADDDEVICE IOCTL is send
    from our user mode app.  Here we create a new SoftPCI device and attach it to our
    tree.

Arguments:

    DeviceExtension - Device Extension for our BUS 0 (or first root bus) Filter DO.
    NewDevice - SoftPCI device to create

Return Value:

    NT status.

--*/
{

    NTSTATUS status;
    PSOFTPCI_DEVICE device;
    PSOFTPCI_DEVICE currentDevice;
    KIRQL irql;

    status = STATUS_UNSUCCESSFUL;

    //
    //  Allocate some NonPagedPool for our new device
    //
    device = ExAllocatePool(NonPagedPool, sizeof(SOFTPCI_DEVICE));
    if (device) {

        RtlZeroMemory(device, sizeof(SOFTPCI_DEVICE));

        RtlCopyMemory(device, NewDevice, sizeof(SOFTPCI_DEVICE));

        SoftPCIDbgPrint(
            SOFTPCI_INFO,
            "SOFTPCI: AddNewDevice - New Device! BUS_%02x&DEV_%02x&FUN_%02x (%p)\n",
            device->Bus, 
            device->Slot.Device, 
            device->Slot.Function, 
            device
            );

        //
        //  Grab our lock
        //
        SoftPCILockDeviceTree(&irql);

        currentDevice = SoftPciTree.RootDevice;
        if (currentDevice == NULL) {

            //
            // We found our first root bus
            //
            SoftPciTree.RootDevice = device;

            SoftPciTree.DeviceCount++;
            status = STATUS_SUCCESS;

        } else {

            //
            //  Not on bus zero (or fist root bus) so lets see if we can find it.
            //
            while(currentDevice){

                if (IS_ROOTBUS(device)) {

                    SoftPCIDbgPrint(
                        SOFTPCI_INFO, 
                        "SOFTPCI: AddNewDevice - New Device is a PlaceHolder device\n"
                        );

                    //
                    //  A root bus.
                    //
                    while (currentDevice->Sibling) {
                        currentDevice = currentDevice->Sibling;
                    }

                    currentDevice->Sibling = device;

                    SoftPciTree.DeviceCount++;

                    status = STATUS_SUCCESS;

                    break;

                }

                //
                //  Don't forget that we pretend that each root bus we have are bridges....
                //
                if (IS_BRIDGE(currentDevice) &&
                    currentDevice->Config.Current.u.type1.SecondaryBus == device->Bus) {

                    SoftPCIDbgPrint(
                        SOFTPCI_INFO, 
                        "SOFTPCI: AddNewDevice - New Device is on bus 0x%02x\n",
                        currentDevice->Config.Current.u.type1.SecondaryBus
                        );
                    //
                    //  Found it. Update the tree.
                    //
                    device->Sibling = currentDevice->Child;
                    currentDevice->Child = device;
                    device->Parent = currentDevice;
                    device->Child = NULL;

                    SoftPciTree.DeviceCount++;

                    status = STATUS_SUCCESS;

                    break;

                }else if (IS_BRIDGE(currentDevice) &&
                          device->Bus >= currentDevice->Config.Current.u.type1.SecondaryBus &&
                          device->Bus <= currentDevice->Config.Current.u.type1.SubordinateBus) {

                    if (currentDevice->Child) {

                        currentDevice = currentDevice->Child;

                    } else {

                        //
                        //  There is no device to attach too.
                        //
                        SoftPCIDbgPrint(
                            SOFTPCI_ERROR, 
                            "SOFTPCI: AddNewDevice - Failed to find a device to attach to!\n"
                            );
                    }

                } else {

                    currentDevice = currentDevice->Sibling;
                }
            }

        }

        SoftPCIUnlockDeviceTree(irql);

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(status)) {

        SoftPCIDbgPrint(
            SOFTPCI_ERROR, 
            "SOFTPCI: AddNewDevice - Failed to attach device! status = (0x%x)\n", 
            status
            );
        ExFreePool(device);

    }else{

        //
        //  Cause a rescan of PCI if this is a new fake device
        //
        if (!device->Config.PlaceHolder) {
            SoftPCIEnumerateTree();
        }

    }

    return status;
}

NTSTATUS
SoftPCIAddNewDeviceByPath(
    IN PSOFTPCI_SCRIPT_DEVICE ScriptDevice
    )
/*++

Routine Description:

    This function is called by SoftPciAddDeviceIoctl when to add a device via
    a specified PCI device path.  Here we create a new SoftPCI device and attach 
    it to our tree.

Arguments:

    ScriptDevice - Contains the device and path used for installing the device

Return Value:

    NT status.

--*/
{
    PSOFTPCI_DEVICE parentDevice;
    PSOFTPCI_DEVICE currentDevice;
    PSOFTPCI_DEVICE newDevice;
    
    parentDevice = SoftPCIFindDeviceByPath((PWCHAR)&ScriptDevice->ParentPath);
    if (parentDevice) {
        
        SoftPCIDbgPrint(
            SOFTPCI_ADD_DEVICE, 
            "SOFTPCI: AddNewDeviceByPath - Found parent device! (%p)\n", 
            parentDevice
            );

        //
        //  Found our parent.  Allocate a new child
        //
        newDevice = ExAllocatePool(NonPagedPool, sizeof(SOFTPCI_DEVICE));

        if (!newDevice) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(newDevice, &ScriptDevice->SoftPciDevice, sizeof(SOFTPCI_DEVICE));

        newDevice->Parent = parentDevice;
        newDevice->Bus = parentDevice->Config.Current.u.type1.SecondaryBus;

        if (parentDevice->Child) {

            currentDevice = parentDevice->Child;

            if (SoftPCIRealHardwarePresent(newDevice) ||
                !SoftPCIValidSlot(currentDevice, &newDevice->Slot)) {

                    //
                    //  Either real hardware is present or we already have a fake one.
                    //
                    SoftPCIDbgPrint(
                        SOFTPCI_ADD_DEVICE, 
                        "SOFTPCI: AddNewDeviceByPath - Cannot add device at specified Slot (%04x)!\n", 
                        newDevice->Slot.AsUSHORT
                        );

                    ExFreePool(newDevice);
                    return STATUS_ACCESS_DENIED;
            }

            while (currentDevice->Sibling) {

                currentDevice = currentDevice->Sibling;
            }
                
            currentDevice->Sibling = newDevice;
            
        }else{

            parentDevice->Child = newDevice;

        }
        
        SoftPciTree.DeviceCount++;

        //
        //  New device is in our tree, re-enum
        //
        SoftPCIEnumerateTree();

    }else{
        return STATUS_NO_SUCH_DEVICE;
    }

    return STATUS_SUCCESS;
}

PSOFTPCI_DEVICE
SoftPCIFindDevice(
    IN UCHAR Bus,
    IN USHORT Slot,
    OUT PSOFTPCI_DEVICE *PreviousSibling OPTIONAL,
    IN BOOLEAN ReturnAll
    )
/*++

Routine Description:

    This routine searches our tree of SoftPci devices looking for the specified device.
    It requires that SoftPCILockDeviceTree() has been previously called to
    lock the device tree.

Arguments:

    Bus      - Bus number of device we are searching for
    Device   - Device number of device we are searching for
    Function - Function of device we are searching for

Return Value:

    Returns the softpci device we are looking for.  NULL otherwise.

--*/
{

    PSOFTPCI_DEVICE currentDevice; 
    PSOFTPCI_DEVICE previousDevice;
    PSOFTPCI_DEVICE deviceFound;
    SOFTPCI_SLOT slot;

    currentDevice = SoftPciTree.RootDevice;
    previousDevice = SoftPciTree.RootDevice;;
    deviceFound = NULL;
    slot.AsUSHORT = Slot;

    SoftPCIDbgPrint(
        SOFTPCI_FIND_DEVICE,
        "SOFTPCI: FindDevice - Searching for BUS_%02x&DEV_%02x&FUN_%02x\n",
        Bus, 
        slot.Device, 
        slot.Function
        );

    while (currentDevice) {

        SoftPCIDbgPrint(
            SOFTPCI_FIND_DEVICE,
            "SOFTPCI: FindDevice - Does %02x.%02x.%02x = %02x.%02x.%02x ?\n",
            Bus, slot.Device, slot.Function,
            currentDevice->Bus, 
            currentDevice->Slot.Device, 
            currentDevice->Slot.Function
            );

        if (currentDevice->Bus == Bus &&
            currentDevice->Slot.AsUSHORT == Slot) {

            //
            // Found it! Only return it if caller specified ReturnAll
            //
            if (!currentDevice->Config.PlaceHolder || ReturnAll) {

                if (PreviousSibling) {
                    *PreviousSibling = previousDevice;
                }

                SoftPCIDbgPrint(
                    SOFTPCI_FIND_DEVICE,
                    "SOFTPCI: FindDevice - Found Device! (0x%p)\n",
                    currentDevice);


                deviceFound = currentDevice;
            }

            break;

        }else if ((IS_BRIDGE(currentDevice)) &&
                  (Bus >= currentDevice->Config.Current.u.type1.SecondaryBus) &&
                  (Bus <= currentDevice->Config.Current.u.type1.SubordinateBus)) {

            SoftPCIDbgPrint(
                SOFTPCI_FIND_DEVICE,
                "SOFTPCI: FindDevice - 0x%p exposes bus %02x-%02x\n",
                currentDevice,
                currentDevice->Config.Current.u.type1.SecondaryBus,
                currentDevice->Config.Current.u.type1.SubordinateBus
                );


            if (!(currentDevice->Config.PlaceHolder) &&
                !(currentDevice->Config.Current.u.type1.SecondaryBus) &&
                !(currentDevice->Config.Current.u.type1.SubordinateBus)){

                //
                //  We have a bridge but it hasnt been given its bus numbers
                //  yet.  Therefore cant have children.
                //
                SoftPCIDbgPrint(
                    SOFTPCI_FIND_DEVICE,
                    "SOFTPCI: FindDevice - Skipping unconfigured bridge (0x%p)\n",
                    currentDevice
                    );

                previousDevice = currentDevice;
                currentDevice = currentDevice->Sibling;

            }else{

                //
                //  Our bus is behind this bridge.  Keep looking
                //
                previousDevice = NULL;
                currentDevice = currentDevice->Child;

            }

        }else{

            //
            //  Not a bridge, check our sibling
            //
            previousDevice = currentDevice;
            currentDevice = currentDevice->Sibling;

        }

    }

    return deviceFound;

}

PSOFTPCI_DEVICE
SoftPCIFindDeviceByPath(
    IN  PWCHAR          PciPath
    )
/*++

Routine Description:

    This function will take a given PCIPATH and return the device located at that path.
    
Arguments:

    PciPath - Path to device.  Syntax is FFXX\DEVFUNC\DEVFUNC\....
    
Return Value:

    SoftPCI device located at path

--*/
{

    PWCHAR nextSlotStart;
    SOFTPCI_SLOT currentSlot;
    PSOFTPCI_DEVICE currentDevice;
    
    currentSlot.AsUSHORT = 0;
    currentDevice = SoftPciTree.RootDevice;
    nextSlotStart = PciPath;
    while (nextSlotStart) {

        nextSlotStart = SoftPCIGetNextSlotFromPath(nextSlotStart, &currentSlot);

        SoftPCIDbgPrint(
            SOFTPCI_FIND_DEVICE,
            "SOFTPCI: FindDeviceByPath - nextSlotStart = %ws\n",
            nextSlotStart
            );
        
        while(currentDevice){

            SoftPCIDbgPrint(
                SOFTPCI_FIND_DEVICE,
                "SOFTPCI: FindDeviceByPath - currentDevice.Slot = %04x, currentSlot.Slot = %04x\n",
                currentDevice->Slot.AsUSHORT,
                currentSlot.AsUSHORT
                );

            if (currentDevice->Slot.AsUSHORT == currentSlot.AsUSHORT) {
            
                //
                //  This device is in our path
                //
                if (nextSlotStart &&
                    (!(IS_BRIDGE(currentDevice)))){
                    //
                    //  This device is in our path but since it isnt a bridge it
                    //  cannot have children!
                    //
                    SoftPCIDbgPrint(
                        SOFTPCI_FIND_DEVICE,
                        "SOFTPCI: FindDeviceByPath - ERROR! Path contains a parent that isnt a bridge!\n"
                        );

                    return NULL;
                }

                if (currentDevice->Child && nextSlotStart) {
                    currentDevice = currentDevice->Child;
                }
                break;
    
            }else{
    
                //
                //  Not in our path, look at our next sibling
                //
                currentDevice = currentDevice->Sibling;
            }
        }
    }

#if 0
    if (currentDevice) {
        //
        //  looks like we found it
        //
        *TargetDevice = currentDevice;
        return STATUS_SUCCESS;

    }
#endif

    
    return currentDevice;
}


BOOLEAN
SoftPCIRealHardwarePresent(
    IN PSOFTPCI_DEVICE Device
    )
/*++

Routine Description:

    This function does a quick check to see if real hardware exists at the bus/slot
    specified in the provided SOFTPCI_DEVICE

Arguments:

    Device - Contains the Bus / Slot we want to check for

Return Value:

    TRUE if real hardware is present

--*/
{

    ULONG bytesRead;
    USHORT vendorID;
    PCI_SLOT_NUMBER slot;
    PSOFTPCI_PCIBUS_INTERFACE busInterface;

    busInterface = SoftPciTree.BusInterface;
    ASSERT((busInterface->ReadConfig != NULL) ||
           (busInterface->WriteConfig != NULL));

    slot.u.AsULONG = 0;
    slot.u.bits.DeviceNumber = ((ULONG)Device->Slot.Device & 0xff);
    slot.u.bits.FunctionNumber = ((ULONG)Device->Slot.Function & 0xff);
    vendorID = 0;

    bytesRead = busInterface->ReadConfig(
        busInterface->Context,
        Device->Bus,
        slot.u.AsULONG,
        &vendorID,
        0,
        sizeof(USHORT)
        );

    if (bytesRead == sizeof(USHORT)) {

        if (vendorID == 0xFFFF || vendorID == 0) {
            return FALSE;
        }

    }else{
        ASSERT(FALSE);
    }

    //
    //  Play it safe and assume there is hardware present
    //
    return TRUE;

}


NTSTATUS
SoftPCIRemoveDevice(
    IN PSOFTPCI_DEVICE Device
    )
/*++

Routine Description:

    This routine is called to remove/delete a specified SoftPCI device

Arguments:

    DeviceExtension -

Return Value:

    Returns a count of bytes written.

--*/
{


    NTSTATUS status = STATUS_SUCCESS;
    PSOFTPCI_DEVICE device;
    PSOFTPCI_DEVICE previous;
    PSOFTPCI_DEVICE current;
    PSOFTPCI_DEVICE end;
    KIRQL irql;

    //
    //  Lock the tree while we remove our device from the tree
    //
    SoftPCILockDeviceTree(&irql);

    previous = NULL;
    device = SoftPCIFindDevice(
        Device->Bus,
        Device->Slot.AsUSHORT,
        &previous,
        FALSE
        );

    //
    //  We should never get back our root node
    //
    ASSERT(device != SoftPciTree.RootDevice);

    if (device) {

        //
        //  We found the device we want to delete.
        //
        SoftPCIDbgPrint(
            SOFTPCI_REMOVE_DEVICE,
            "SOFTPCI: RemoveDevice - Removing BUS_%02x&DEV_%02x&FUN_%02x and all its children\n",
            device->Bus, 
            device->Slot.Device, 
            device->Slot.Function
            );

        if (previous){

            //
            //  Patch the link between our previous and next if any
            //
            previous->Sibling = device->Sibling;

        }else{

            //
            //  Update our parent
            //
            device->Parent->Child = device->Sibling;
        }

        //
        //  Release the tree lock now that we have severed the link
        //  between the device and the tree
        //
        SoftPCIUnlockDeviceTree(irql);

        if (device->Child) {

            //
            //  We have at least one child.  Traverse and free everything.
            //
            current = device;

            while (current) {

                //
                //  Find the last Child.
                //
                while (current->Child) {
                    previous = current;
                    current=current->Child;
                }

                //
                //  We have a sibling. Free our current node and
                //  set the previous parent node's child to our
                //  sibling (if any) and restart the list.
                //
                end = current;
                previous->Child = current->Sibling;
                current = device;

                SoftPCIDbgPrint(
                    SOFTPCI_REMOVE_DEVICE,
                    "SOFTPCI: RemoveDevice - Freeing BUS_%02x&DEV_%02x&FUN_%02x\n",
                    end->Bus, 
                    end->Slot.Device, 
                    end->Slot.Function
                    );

                ExFreePool(end);

                if (device->Child == NULL) {

                    //
                    //  All our children are now gone. Free the requested device.
                    //
                    SoftPCIDbgPrint(
                        SOFTPCI_REMOVE_DEVICE,
                        "SOFTPCI: RemoveDevice - Freeing BUS_%02x&DEV_%02x&FUN_%02x\n",
                        device->Bus, 
                        device->Slot.Device, 
                        device->Slot.Function
                        );

                    ExFreePool(device);

                    break;
                }

            }

        }else{

            //
            //  Cool, no children. Free the device.
            //
            SoftPCIDbgPrint(
                SOFTPCI_REMOVE_DEVICE,
                "SOFTPCI: RemoveDevice - Freeing BUS_%02x&DEV_%02x&FUN_%02x\n",
                device->Bus, device->Slot.Device, device->Slot.Function
                );

            ExFreePool(device);
        }

    }else{

        //
        //  We cant delete one if we dont have one.
        //
        SoftPCIDbgPrint(
            SOFTPCI_REMOVE_DEVICE,
            "SOFTPCI: RemoveDevice - No device at BUS_%02x&DEV_%02x&FUN_%02x\n",
            Device->Bus, 
            Device->Slot.Device, 
            Device->Slot.Function
            );

        SoftPCIUnlockDeviceTree(irql);
    }

    if (NT_SUCCESS(status)) {

        SoftPciTree.DeviceCount--;
        ASSERT(SoftPciTree.DeviceCount != 0);

        //
        //  If we changed the tree, queue an enum
        //
        SoftPCIEnumerateTree();
    }



    return status;
}

ULONG
SoftPCIReadConfigSpace(
    IN PSOFTPCI_PCIBUS_INTERFACE BusInterface,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine is called by the PCI driver in place of the normal interface call to
    the HAL.

Arguments:

    BusInterface - Interface contexts we gave PCI during the query
              for PCI_BUS_INTERFACE_STANDARD.

    BusOffset - BusOffset provided by PCI
    Slot      - Slot provided by PCI
    Buffer    - Buffer for returned data
    Offset    - Configspace Offset to Read from
    Length    - Length of requested read.

Return Value:

    Returns a count of bytes read..

--*/
{

    PCI_SLOT_NUMBER slotNum;
    SOFTPCI_SLOT softSlot;
    PSOFTPCI_DEVICE device;
    PSOFTPCI_CONFIG config;
    ULONG count;
    PUCHAR softConfig = NULL;
    KIRQL irql;

    slotNum.u.AsULONG = Slot;
    softSlot.Device = (UCHAR) slotNum.u.bits.DeviceNumber;
    softSlot.Function = (UCHAR) slotNum.u.bits.FunctionNumber;

    SoftPCILockDeviceTree(&irql);
    //
    //  First look for a matching fake device
    //
    device = SoftPCIFindDevice(
        BusOffset,
        softSlot.AsUSHORT,
        NULL,
        FALSE
        );

    SoftPCIUnlockDeviceTree(irql);

    //
    // If we found a device, then read it's config space.
    //
    if (device) {

        config = &device->Config;

        SoftPCIDbgPrint(SOFTPCI_INFO, "SOFTPCI: ReadConfig - SoftConfigSpace for VEN_%04x&DEV_%04x, HeaderType = 0x%02x\n",
                         config->Current.VendorID, config->Current.DeviceID, config->Current.HeaderType);

        ASSERT(Offset <= sizeof(PCI_COMMON_CONFIG));
        ASSERT(Length <= (sizeof(PCI_COMMON_CONFIG) - Offset));

        softConfig = (PUCHAR) &config->Current;

        softConfig += (UCHAR)Offset;

        RtlCopyMemory((PUCHAR)Buffer, softConfig, Length);

        //
        //  We assume everything copied ok.  Set count to Length.
        //
        count = Length;

    } else {

        //
        // We don't have a softdevice so see if we have a real one.
        //
        count = BusInterface->ReadConfig(
            BusInterface->Context,
            BusOffset,
            Slot,
            Buffer,
            Offset,
            Length
            );

        //
        //  Here we snoop the config space header reads
        //  and if we find a bridge we make sure we have
        //  it in our tree.
        //
        if ((Offset == 0) &&
            (Length == PCI_COMMON_HDR_LENGTH) && 
            ((PCI_CONFIGURATION_TYPE((PPCI_COMMON_CONFIG)Buffer)) == PCI_BRIDGE_TYPE)) {

            //
            //  OK, look one more time, only this time we want placeholders as well
            //
            SoftPCILockDeviceTree(&irql);
            device = SoftPCIFindDevice(
                BusOffset,
                softSlot.AsUSHORT,
                NULL,
                TRUE
                );
            SoftPCIUnlockDeviceTree(irql);

            if (!device) {

                //
                //  This real bridge doesnt exist in our tree, add it.
                //
                device = (PSOFTPCI_DEVICE) ExAllocatePool(NonPagedPool,
                                                          sizeof(SOFTPCI_DEVICE));
                if (device) {

                    RtlZeroMemory(device, sizeof(SOFTPCI_DEVICE));

                    device->Bus = BusOffset;
                    device->Slot.AsUSHORT = softSlot.AsUSHORT;
                    device->Config.PlaceHolder = TRUE;

                    RtlCopyMemory(&device->Config.Current, Buffer, Length);

                    if (!NT_SUCCESS(SoftPCIAddNewDevice(device))){

                        SoftPCIDbgPrint(
                            SOFTPCI_INFO,
                            "SOFTPCI: ReadConfig - Failed to add new PlaceHolder Device! VEN_%04x&DEV_%04x",
                            device->Config.Current.VendorID, 
                            device->Config.Current.DeviceID
                            );
                    }

                }else{

                    SoftPCIDbgPrint(
                        SOFTPCI_INFO,
                        "SOFTPCI: ReadConfig - Failed to allocate memory for new placeholder!\n"
                        );

                }

            }

        }

    }

    return count;

}

ULONG
SoftPCIWriteConfigSpace(
    IN PSOFTPCI_PCIBUS_INTERFACE BusInterface,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This routine is called by the PCI driver in place of the normal interface call to
    the HAL.

Arguments:

    Context - Interface contexts we gave PCI during the query
              for PCI_BUS_INTERFACE_STANDARD.

    BusOffset - BusOffset provided by PCI
    Slot      - Slot provided by PCI
    Buffer    - Data to be written to configspace
    Offset    - Configspace Offset to start writting
    Length    - Length of requested write.

Return Value:

    Returns a count of bytes written.

--*/
{


    PCI_SLOT_NUMBER slotNum;
    SOFTPCI_SLOT softSlot;
    PSOFTPCI_DEVICE device;
    ULONG count = 0;
    KIRQL irql;
    PPCI_COMMON_CONFIG bridgeConfig;
    PUCHAR bridgeOffset;

    slotNum.u.AsULONG = Slot;
    softSlot.Device = (UCHAR) slotNum.u.bits.DeviceNumber;
    softSlot.Function = (UCHAR) slotNum.u.bits.FunctionNumber;

    SoftPCILockDeviceTree(&irql);
    //
    //  First look for a matching fake or placeholder device
    //
    device = SoftPCIFindDevice(
        BusOffset,
        softSlot.AsUSHORT,
        NULL,
        TRUE
        );

    //
    // If we found a device, then write to it's config space.
    //
    if (device && (!device->Config.PlaceHolder)) {


        ULONG   reg;
        PUCHAR  value = (PUCHAR) Buffer;

        for (reg = Offset; reg < Offset + Length; reg ++) {

            WriteByte(device, reg, *value);

            value++;
            count++;
        }


    } else {

        
        if (device && (IS_BRIDGE(device))) {

            ASSERT(device->Config.PlaceHolder == TRUE);
            
            //
            //  We have a place holder to update as well as real hardware
            //
            bridgeConfig = &device->Config.Current;
            bridgeOffset = (PUCHAR) bridgeConfig;
            bridgeOffset += Offset;
            RtlCopyMemory(bridgeOffset, Buffer, Length);
        }
        
        //
        // We don't have a softdevice so write to the real one.
        // 
        count = BusInterface->WriteConfig(
            BusInterface->Context,
            BusOffset,
            Slot,
            Buffer,
            Offset,
            Length
            );
    }

    SoftPCIUnlockDeviceTree(irql);

    return count;

}

BOOLEAN
SoftPCIValidSlot(
    IN PSOFTPCI_DEVICE  FirstDevice,
    IN PSOFTPCI_SLOT    Slot
    )
/*++

Routine Description:

    This function makes sure that there isnt already a device at the specified Slot

Arguments:

    FirstDevice - First device we will compare against.  We will then only check siblings.

Return Value:

    TRUE if the Slot is valid

--*/
{

    PSOFTPCI_DEVICE currentDevice;
    SOFTPCI_SLOT mfSlot;
    BOOLEAN mfSlotRequired;
    BOOLEAN mfSlotFound;

    RtlZeroMemory(&mfSlot, sizeof(SOFTPCI_SLOT));

    mfSlotRequired = FALSE;
    mfSlotFound = FALSE;
    if (Slot->Function) {

        //
        //  We have a multi-function slot.  Make sure function 0
        //  is present or we must fail
        //
        mfSlot.AsUSHORT = 0;
        mfSlot.Device = Slot->Device;
        mfSlotRequired = TRUE;
    }

    currentDevice = FirstDevice;
    while (currentDevice) {
        
        if (currentDevice->Slot.AsUSHORT == mfSlot.AsUSHORT) {
            mfSlotFound = TRUE;
        }
        
        if (currentDevice->Slot.AsUSHORT == Slot->AsUSHORT) {
            return FALSE;
        }

        currentDevice = currentDevice->Sibling;
    }

    if (mfSlotRequired && !mfSlotFound) {
        //
        //  Didnt find function 0
        //
        SoftPCIDbgPrint(
            SOFTPCI_ERROR, 
            "SOFTPCI: VerifyValidSlot - Multi-function slot (%04x) without function 0 !\n", 
            Slot->AsUSHORT
            );
        return FALSE;
    }

    return TRUE;
}

VOID
SoftPCILockDeviceTree(
    IN PKIRQL OldIrql
    )
{
    KeRaiseIrql(HIGH_LEVEL,
                OldIrql
                );
    KeAcquireSpinLockAtDpcLevel(&SoftPciTree.TreeLock);
}

VOID
SoftPCIUnlockDeviceTree(
    IN KIRQL NewIrql
    )
{
    KeReleaseSpinLockFromDpcLevel(&SoftPciTree.TreeLock);

    KeLowerIrql(NewIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\dispatch.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    
    dispatch.c
    
Abstract:

    This module contains the PNP, IOCTL, and Power dispatch routines for softpci.sys
    
Author:

    Nicholas Owens (nichow) 11-Mar-1999

Revision History:

--*/
#include "pch.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, SoftPCIDispatchPnP)
#pragma alloc_text (PAGE, SoftPCIDispatchPower)
#pragma alloc_text (PAGE, SoftPCIDispatchDeviceControl)
#endif


#define MAX_PNP_IRP_SUPPORTED       0x18


PDRIVER_DISPATCH SoftPciFilterPnPDispatchTable[] = {

    SoftPCIFilterStartDevice,           // IRP_MN_START_DEVICE                 0x00
    SoftPCIPassIrpDownSuccess,          // IRP_MN_QUERY_REMOVE_DEVICE          0x01
    SoftPCIIrpRemoveDevice,             // IRP_MN_REMOVE_DEVICE                0x02
    SoftPCIPassIrpDownSuccess,          // IRP_MN_CANCEL_REMOVE_DEVICE         0x03
    SoftPCIPassIrpDownSuccess,          // IRP_MN_STOP_DEVICE                  0x04
    SoftPCIPassIrpDownSuccess,          // IRP_MN_QUERY_STOP_DEVICE            0x05
    SoftPCIPassIrpDownSuccess,          // IRP_MN_CANCEL_STOP_DEVICE           0x06
    
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_DEVICE_RELATIONS       0x07
    SoftPCIFilterQueryInterface,        // IRP_MN_QUERY_INTERFACE              0x08
    SoftPCIPassIrpDownSuccess,          // IRP_MN_QUERY_CAPABILITIES           0x09
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_RESOURCES              0x0A
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_DEVICE_TEXT            0x0C
    SoftPCIPassIrpDown,                 // IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
    
    SoftPCIPassIrpDown,                 // IRP_MN_IRP_UNKNOWN                  0x0E
    
    SoftPCIPassIrpDown,                 // IRP_MN_READ_CONFIG                  0x0F
    SoftPCIPassIrpDown,                 // IRP_MN_WRITE_CONFIG                 0x10
    SoftPCIPassIrpDown,                 // IRP_MN_EJECT                        0x11
    SoftPCIPassIrpDown,                 // IRP_MN_SET_LOCK                     0x12
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_ID                     0x13
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_BUS_INFORMATION        0x15
    SoftPCIPassIrpDown,                 // IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
    SoftPCIPassIrpDownSuccess,          // IRP_MN_SURPRISE_REMOVAL             0x17
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_LEGACY_BUS_REQUIREMENTS0x18

};

PDRIVER_DISPATCH SoftPciFdoPnPDispatchTable[] = {

#ifdef SIMULATE_MSI
    SoftPCI_FdoStartDevice,             // IRP_MN_START_DEVICE                 0x00
#else
    SoftPCIPassIrpDownSuccess,          // IRP_MN_START_DEVICE                 0x00
#endif
    SoftPCIPassIrpDownSuccess,          // IRP_MN_QUERY_REMOVE_DEVICE          0x01
    SoftPCIIrpRemoveDevice,             // IRP_MN_REMOVE_DEVICE                0x02
    SoftPCIPassIrpDownSuccess,          // IRP_MN_CANCEL_REMOVE_DEVICE         0x03
    SoftPCIPassIrpDownSuccess,          // IRP_MN_STOP_DEVICE                  0x04
    SoftPCIPassIrpDownSuccess,          // IRP_MN_QUERY_STOP_DEVICE            0x05
    SoftPCIPassIrpDownSuccess,          // IRP_MN_CANCEL_STOP_DEVICE           0x06
    
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_DEVICE_RELATIONS       0x07
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_INTERFACE              0x08
    SoftPCIPassIrpDownSuccess,          // IRP_MN_QUERY_CAPABILITIES           0x09
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_RESOURCES              0x0A
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_DEVICE_TEXT            0x0C
    SoftPCI_FdoFilterRequirements,      // IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
    
    SoftPCIPassIrpDown,                 // IRP_MN_IRP_UNKNOWN                  0x0E
    
    SoftPCIPassIrpDown,                 // IRP_MN_READ_CONFIG                  0x0F
    SoftPCIPassIrpDown,                 // IRP_MN_WRITE_CONFIG                 0x10
    SoftPCIPassIrpDown,                 // IRP_MN_EJECT                        0x11
    SoftPCIPassIrpDown,                 // IRP_MN_SET_LOCK                     0x12
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_ID                     0x13
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_BUS_INFORMATION        0x15
    SoftPCIPassIrpDown,                 // IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
    SoftPCIPassIrpDownSuccess,          // IRP_MN_SURPRISE_REMOVAL             0x17
    SoftPCIPassIrpDown,                 // IRP_MN_QUERY_LEGACY_BUS_REQUIREMENTS0x18

};

PDRIVER_DISPATCH SoftPciIOCTLDispatchTable[] = {

    SoftPCIIoctlAddDevice,              // SOFTPCI_IOCTL_CREATE_DEVICE
    SoftPCIIoctlRemoveDevice,           // SOFTPCI_IOCTL_WRITE_DELETE_DEVICE
    SoftPCIIoctlGetDevice,              // SOFTPCI_IOCTL_GET_DEVICE
    SoftPCIIocltReadWriteConfig,        // SOFTPCI_IOCTL_RW_CONFIG
    SoftPCIIoctlGetDeviceCount          // SOFTPCI_IOCTL_GET_DEVICE_COUNT
};


NTSTATUS
SoftPCIDispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatches PnP Irps for FDO and FilterDOs

Arguments:

    DeviceObject    - pointer to the device object.
    Irp             - PnP Irp to be dispatched.
    
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS                    status = STATUS_SUCCESS;
    PIO_STACK_LOCATION          irpSp;
    PSOFTPCI_DEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Call the appropriate minor Irp Code handler.
    //
    if (irpSp->MinorFunction <= MAX_PNP_IRP_SUPPORTED) {
    
        if (deviceExtension->FilterDevObj) {
        
        status = SoftPciFilterPnPDispatchTable[irpSp->MinorFunction](DeviceObject,
                                                                     Irp
                                                                     );
        } else {

        status = SoftPciFdoPnPDispatchTable[irpSp->MinorFunction](DeviceObject,
                                                         Irp
                                                         );
        }
    } else {

        status = SoftPCIPassIrpDown(DeviceObject, Irp);
    }

    return status;

}

NTSTATUS
SoftPCIDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatches Power IRPs

Arguments:

    DeviceObject    - pointer to the device object.
    Irp             - PnP Irp to be dispatched.
    
Return Value:

    NTSTATUS.

--*/
{
    PSOFTPCI_DEVICE_EXTENSION   devExt = (PSOFTPCI_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    

    if (devExt->FilterDevObj) {
    
        //
        // If this is our FilterDO just pass the IRP on down
        //
        return SoftPCIDefaultPowerHandler(DeviceObject,
                                           Irp);

    }else{

        //
        // Otherwise lets pretend to power manage our device
        //
        return SoftPCIFDOPowerHandler(DeviceObject,
                                       Irp);

    }
       
    
}

NTSTATUS
SoftPCIDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatches IOCTLS for FilterDOs.

Arguments:

    DeviceObject    - pointer to the device object.
    Irp             - PnP Irp to be dispatched.
    
Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS                    status = STATUS_SUCCESS;
    ULONG                       ioControlCode = IoGetCurrentIrpStackLocation(Irp)->
                                                    Parameters.DeviceIoControl.IoControlCode;
    
    //
    //  Make sure it is our IOCTL Type
    //
    if ((DEVICE_TYPE_FROM_CTL_CODE(ioControlCode)) == SOFTPCI_IOCTL_TYPE) {

        //
        //  Make sure it is an IOCTL function we support
        //
        if (SOFTPCI_IOCTL(ioControlCode) <= MAX_IOCTL_CODE_SUPPORTED) {

            //
            // Dispatch Device Control IOCTL
            //
            status = SoftPciIOCTLDispatchTable[SOFTPCI_IOCTL(ioControlCode)](DeviceObject,
                                                                             Irp
                                                                             );
            //
            // Set Status of Irp and complete it
            //
            Irp->IoStatus.Status = status;
    
            //
            // Complete the Irp.
            //
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

        }else{

            //
            //  We dont support this IOCTL function so fail and complete.
            //
            status = STATUS_NOT_SUPPORTED;

            Irp->IoStatus.Status = status;
            
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            
            return status;

        }

    } else {

        
        status = SoftPCIPassIrpDown(DeviceObject, Irp);     

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\ioctldispatch.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    Iocltdispatch.c

Abstract:

    This module contains functions for handling supported IOCTL codes.

Author:

    Nicholas Owens (Nichow) - 1999

Revision History:


--*/

#include "pch.h"


NTSTATUS
SoftPCIOpenDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles all CREATES' we receive

Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp to be dispatched.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Set Irp Status and Information
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    //  Increment Reference Count
    //
    ObReferenceObject(
                DeviceObject
                );

    //
    // Complete the Irp
    //
    IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );

    return status;
}

NTSTATUS
SoftPCICloseDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles all CLOSES' we receive

Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp to be dispatched.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Set Irp Status and Information
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    //  Decrement Reference Count
    //
    ObDereferenceObject(
            DeviceObject
            );

    //
    // Complete the Irp
    //
    IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );

    return status;
}

NTSTATUS
SoftPCIIoctlAddDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles all SOFTPCI_IOCTL_CREATE_DEVICE IOCLTS we receive.  Here we attempt to create a
    new SoftPCI device.

Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp to be dispatched.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION irpSl;
    PVOID inputBuffer;
    PBOOLEAN outputBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    KIRQL irql;
    PSOFTPCI_DEVICE newSoftPciDevice; 
    PSOFTPCI_DEVICE previousDevice; 
    PSOFTPCI_DEVICE existingDevice;
    PSOFTPCI_SCRIPT_DEVICE scriptDevice;

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // Get Current Stack Location
    //
    irpSl = IoGetCurrentIrpStackLocation(Irp);

    //
    // Initialize input and output buffers to Irp->AssociatedIrp.SystemBuffer
    //
    inputBuffer = Irp->AssociatedIrp.SystemBuffer;
    outputBuffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Initialize input and output lengths.
    //
    inputBufferLength = irpSl->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpSl->Parameters.DeviceIoControl.OutputBufferLength;

    if (inputBufferLength == sizeof (SOFTPCI_DEVICE)) {

        newSoftPciDevice = (PSOFTPCI_DEVICE) inputBuffer;

        SoftPCIDbgPrint(
            SOFTPCI_INFO,
            "SOFTPCI: AddDeviceIoctl - BUS_%02x&DEV_%02x&FUN_%02x (0x%x)\n",
            newSoftPciDevice->Bus, 
            newSoftPciDevice->Slot.Device, 
            newSoftPciDevice->Slot.Function, 
            &newSoftPciDevice->Config
            );

        previousDevice = NULL;
        SoftPCILockDeviceTree(&irql);
        existingDevice = SoftPCIFindDevice(
            newSoftPciDevice->Bus,
            newSoftPciDevice->Slot.AsUSHORT,
            &previousDevice,
            FALSE
            );
        SoftPCIUnlockDeviceTree(irql);

        if (!existingDevice) {

            if (!SoftPCIRealHardwarePresent(newSoftPciDevice)) {

#if DBG
                if (IS_BRIDGE(newSoftPciDevice)){
    
                    ASSERT((newSoftPciDevice->Config.Mask.u.type1.PrimaryBus != 0) &&
                           (newSoftPciDevice->Config.Mask.u.type1.SecondaryBus != 0) &&
                           (newSoftPciDevice->Config.Mask.u.type1.SubordinateBus != 0));
                }
#endif
                //
                //  Doesnt look like real hardware is here so lets allow a fake one.
                //
                status = SoftPCIAddNewDevice(newSoftPciDevice);

            }else{

                //
                //  We dont allow fake devices to be placed on real ones!
                //
                SoftPCIDbgPrint(
                    SOFTPCI_ERROR, 
                    "SOFTPCI: AddDeviceIoctl - Physical Hardware exists at BUS_%02x&DEV_%02x&FUN_%02x\n",
                    newSoftPciDevice->Bus, 
                    newSoftPciDevice->Slot.Device, 
                    newSoftPciDevice->Slot.Function
                    );

                status = STATUS_ACCESS_DENIED;
            }
        }

    }else{
        //
        //  We must be installing a path based device
        //
        ASSERT(inputBufferLength > sizeof(SOFTPCI_DEVICE));

        scriptDevice = (PSOFTPCI_SCRIPT_DEVICE) inputBuffer;

        ASSERT(scriptDevice->ParentPathLength > 0 );
        ASSERT(scriptDevice->ParentPath != NULL);

        status = SoftPCIAddNewDeviceByPath(scriptDevice);
    }

    //
    // Set outputBuffer to True
    //
    if (outputBufferLength >= sizeof(BOOLEAN)) {

        if (NT_SUCCESS(status)) {

            *outputBuffer = TRUE;

        } else {

            *outputBuffer = FALSE;

        }

        //
        // Set IoStatus.Information to the size of a Boolean or to outputBufferLength, whichever is lesser.
        //
        Irp->IoStatus.Information = (sizeof(BOOLEAN)<outputBufferLength?sizeof(BOOLEAN):outputBufferLength);
    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }
    
    return status;
}

NTSTATUS
SoftPCIIoctlRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles all SOFTPCI_IOCTL_WRITE_DELETE_DEVICE IOCLTS we receive.  Here we will try and remove a specified
    SoftPCI device.

Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp to be dispatched.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSl;
    PSOFTPCI_DEVICE inputBuffer;
    PBOOLEAN outputBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;


    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // Get Current Stack Location
    //
    irpSl = IoGetCurrentIrpStackLocation(Irp);

    //
    // Initialize input and output buffers to Irp->AssociatedIrp.SystemBuffer
    //
    inputBuffer = Irp->AssociatedIrp.SystemBuffer;
    outputBuffer = Irp->AssociatedIrp.SystemBuffer;
    //
    // Initialize input and output lengths.
    //
    inputBufferLength = irpSl->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpSl->Parameters.DeviceIoControl.OutputBufferLength;
    Irp->IoStatus.Information = 0;

    if (inputBufferLength == sizeof(SOFTPCI_DEVICE)) {

            SoftPCIDbgPrint(
                SOFTPCI_INFO,
                "SOFTPCI: RemoveDeviceIoctl - BUS_%02x&DEV_%02x&FUN_%02x\n",
                inputBuffer->Bus, 
                inputBuffer->Slot.Device, 
                inputBuffer->Slot.Function
                );

            status = SoftPCIRemoveDevice(inputBuffer);
    }

    //
    // Set outputBuffer to True
    //
    if (outputBufferLength >= sizeof(BOOLEAN)) {

        if (NT_SUCCESS(status)) {

            *outputBuffer = TRUE;

        } else {

            *outputBuffer = FALSE;

        }
        //
        // Set IoStatus.Information to the size of a Boolean
        //
        Irp->IoStatus.Information = sizeof(BOOLEAN);
    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    SoftPCIDbgPrint(
        SOFTPCI_IOCTL_LEVEL,
        "SOFTPCI: RemoveDeviceIoctl - BUS_%02x&DEV_%02x&FUN_%02x status=0x%x\n",
        inputBuffer->Bus, 
        inputBuffer->Slot.Device, 
        inputBuffer->Slot.Function, 
        status
        );

    return status;
}

NTSTATUS
SoftPCIIoctlGetDeviceCount(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles all SOFTPCI_IOCTL_GET_NUMBER_OF_DEVICES IOCLTS we receive.


Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp to be dispatched.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSl;
    PULONG outputBuffer;
    ULONG outputBufferLength;

    UNREFERENCED_PARAMETER(DeviceObject);
    
    //
    // Get Current Stack Location
    //
    irpSl = IoGetCurrentIrpStackLocation(Irp);

    //
    // Initialize input and output buffers to Irp->AssociatedIrp.SystemBuffer
    //
    outputBuffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Initialize input and output lengths.
    //
    outputBufferLength = irpSl->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Set outputBuffer to True
    //
    if (outputBufferLength >= sizeof(ULONG)) {

        *outputBuffer = SoftPciTree.DeviceCount;

        //
        // Set IoStatus.Information to the size of a Boolean or to outputBufferLength, whichever is lesser.
        //
        Irp->IoStatus.Information = (sizeof(ULONG)<outputBufferLength?sizeof(ULONG):outputBufferLength);
    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }

    return status;
}

NTSTATUS
SoftPCIIoctlGetDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles all SOFTPCI_IOCTL_GET_DEVICE IOCLTS we receive.


Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp to be dispatched.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION irpSp;
    PSOFTPCI_DEVICE device;
    PSOFTPCI_DEVICE inputBuffer, outputBuffer;
    ULONG inputBufferLength, outputBufferLength;
    KIRQL irql;

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // Get Current Stack Location
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    SoftPCILockDeviceTree(&irql);
    //
    // Initialize input and output buffers to Irp->AssociatedIrp.SystemBuffer
    //
    inputBuffer = (PSOFTPCI_DEVICE)Irp->AssociatedIrp.SystemBuffer;
    outputBuffer = (PSOFTPCI_DEVICE)Irp->AssociatedIrp.SystemBuffer;

    //
    // Initialize input and output lengths.
    //
    inputBufferLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    device = NULL;
    if (inputBufferLength == sizeof(SOFTPCI_DEVICE)) {

        device = SoftPCIFindDevice(
            inputBuffer->Bus,
            inputBuffer->Slot.AsUSHORT,
            NULL,
            TRUE
            );
    }

    //
    // Set outputBuffer to True
    //
    if (outputBufferLength >= sizeof(SOFTPCI_DEVICE)) {

        if (device) {

            RtlCopyMemory(outputBuffer, device, sizeof(SOFTPCI_DEVICE));

            outputBufferLength = sizeof(SOFTPCI_DEVICE);

            status = STATUS_SUCCESS;

        } else {

            outputBufferLength = 0;

        }

        //
        // Set IoStatus.Information to number of bytes returned
        //
        Irp->IoStatus.Information = outputBufferLength;

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }
    SoftPCIUnlockDeviceTree(irql);

    return status;
}

NTSTATUS
SoftPCIIocltReadWriteConfig(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handles all SOFTPCI_IOCTL_RW_CONFIG  we receive.

Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp to be dispatched.

Return Value:

    NTSTATUS.

--*/
{
    PIO_STACK_LOCATION irpSl;
    PUCHAR outputBuffer;
    ULONG outputBufferLength;
    ULONG bytes;
    PSOFTPCI_RW_CONTEXT context;
    PCI_SLOT_NUMBER slot;
    
    UNREFERENCED_PARAMETER(DeviceObject);

    irpSl = IoGetCurrentIrpStackLocation(Irp);

    //
    // Initialize input and output buffers
    //
    context = (PSOFTPCI_RW_CONTEXT) Irp->AssociatedIrp.SystemBuffer;
    outputBuffer = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;

    //
    // Initialize input and output lengths.
    //
    outputBufferLength = irpSl->Parameters.DeviceIoControl.OutputBufferLength;

    slot.u.AsULONG = 0;
    slot.u.bits.DeviceNumber = context->Slot.Device;
    slot.u.bits.FunctionNumber = context->Slot.Function;

    Irp->IoStatus.Information = 0;
    bytes = 0;
    switch (context->WriteConfig) {
    
    case SoftPciWriteConfig:
                
        bytes = SoftPCIWriteConfigSpace(
            SoftPciTree.BusInterface,
            (UCHAR)context->Bus,
            slot.u.AsULONG,
            context->Data,
            context->Offset,
            outputBufferLength
            );


        break;

    case SoftPciReadConfig:

        bytes = SoftPCIReadConfigSpace(
            SoftPciTree.BusInterface,
            (UCHAR)context->Bus,
            slot.u.AsULONG,
            outputBuffer,
            context->Offset,
            outputBufferLength
            );

        break;

    default:
        return STATUS_UNSUCCESSFUL;
    }

    if (bytes != outputBufferLength) {
        
        //
        //  We failed to get all the data we wanted.
        //
        return STATUS_UNSUCCESSFUL;

    }

    //
    //  Set IoStatus.Information to the number of bytes returned
    //
    Irp->IoStatus.Information = bytes;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\init.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    
    init.c
    
Abstract:

    This module contains the initialization code for softpci.sys
    
Author:

    Nicholas Owens (nichow) 11-Mar-1999

Revision History:

    Brandon Allsop (BrandonA) Feb, 2000 - added support to load devices from the registry during boot

--*/

#include "pch.h"


UNICODE_STRING  driverRegistryPath;

SOFTPCI_TREE    SoftPciTree;

BOOLEAN         SoftPciFailSafe = FALSE;  //  Setting this to true will cause adddevice to fail
BOOLEAN         SoftPciInterfaceRegistered = FALSE;


NTSTATUS
SoftPCIDriverAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
SoftPCIDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called when the driver is loaded to initalize the driver.

Arguments:

    DriverObject    - Pointer to the driver object.
    RegistryPath    - Registry path of the device object.

Return Value:

    NTSTATUS.

--*/

{

    //
    // Fill in Entry points for Dispatch Routines
    //
    DriverObject->DriverExtension->AddDevice            = SoftPCIDriverAddDevice;
    DriverObject->DriverUnload                          = SoftPCIDriverUnload;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = SoftPCIDispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = SoftPCIDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = SoftPCIPassIrpDown;  //Currenly no WMI
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = SoftPCIDispatchDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = SoftPCIOpenDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = SoftPCICloseDeviceControl;
    
    //
    // Save the registry path to the driver.
    //
    RtlInitUnicodeString(&driverRegistryPath,
                         RegistryPath->Buffer
                         );

    return STATUS_SUCCESS;

}

NTSTATUS
SoftPCIDriverAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine adds the DeviceObjects for the FDO's and Filter DO's.


Arguments:

    DriverObject            - Pointer to the driver object.
    PhysicalDeviceObject    - Pointer to the PDO.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PSOFTPCI_DEVICE_EXTENSION deviceExtension;
    BOOLEAN isFDO;
    
#if 0
    DbgBreakPoint();
#endif

    if (SoftPciFailSafe) {
        return STATUS_UNSUCCESSFUL;
    }

    deviceExtension = NULL;
    status = IoCreateDevice(DriverObject,
                            sizeof(SOFTPCI_DEVICE_EXTENSION),
                            NULL,
                            FILE_DEVICE_NULL,
                            0,
                            FALSE,
                            &deviceObject
                            );

    if (!NT_SUCCESS(status)) {
        
        SoftPCIDbgPrint(
            SOFTPCI_ERROR, 
            "SOFTPCI: DriverAddDevice - IoCreateDevice failed! status = 0x%x\n", 
            status
            );
        
        goto Cleanup;
    }
    
    deviceExtension = deviceObject->DeviceExtension;

    //
    // Attach our Filter/FDO to the device stack.
    //
    deviceExtension->LowerDevObj = IoAttachDeviceToDeviceStack(deviceObject,
                                                               PhysicalDeviceObject
                                                               );
    if (deviceExtension->LowerDevObj==NULL) {

        SoftPCIDbgPrint(
            SOFTPCI_ERROR, 
            "SOFTPCI: DriverAddDevice - IoAttachDeviceToDeviceStack failed!\n"
            );
  
        goto Cleanup;
        
    }

    //
    //  Mark it as ours
    //
    deviceExtension->Signature = SPCI_SIG;

    //
    // Save the PDO in the device extension.
    //
    deviceExtension->PDO = PhysicalDeviceObject;
    
    //
    //  Now lets see if we are an FDO or a FilterDO
    //
    isFDO = TRUE;
    status = SoftPCIQueryDeviceObjectType(deviceExtension->LowerDevObj, &isFDO);
    
    if (!NT_SUCCESS(status)) {

        SoftPCIDbgPrint(
            SOFTPCI_ERROR, 
            "SOFTPCI: DriverAddDevice - QueryDeviceObjectType() failed! status = 0x%x\n", 
            status
            );

        goto Cleanup;
    }

    if (isFDO) {

        //
        // This is a FDO so mark it in the device extension.
        //
        deviceExtension->FilterDevObj = FALSE;

    }else{

        //
        // This is a Filter DO so mark it in the device extension.
        //
        deviceExtension->FilterDevObj = TRUE;
        
        if (SoftPciTree.BusInterface == NULL) {

            SoftPciTree.BusInterface = ExAllocatePool(NonPagedPool,
                                                      sizeof(SOFTPCI_PCIBUS_INTERFACE)
                                                      );

            if (SoftPciTree.BusInterface == NULL) {
                
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlZeroMemory(SoftPciTree.BusInterface, sizeof(SOFTPCI_PCIBUS_INTERFACE));
        }

        //
        //  We save our filter device extensions in a global list for later use.
        //
        SoftPCIInsertEntryAtTail(&deviceExtension->ListEntry);
        
        //
        //  Register a DeviceInterface. Since we can possibly be filtering more than one root bus
        //  and we only need to access the first one, only bother with the first one.
        //
        if (!SoftPciInterfaceRegistered){
            
            deviceExtension->InterfaceRegistered = TRUE;
            
            status = IoRegisterDeviceInterface(PhysicalDeviceObject,
                                               (LPGUID)&GUID_SOFTPCI_INTERFACE,
                                               NULL,
                                               &(deviceExtension->SymbolicLinkName)
                                               );

            if (!NT_SUCCESS(status)) {

                SoftPCIDbgPrint(
                    SOFTPCI_ERROR, 
                    "SOFTPCI: DriverAddDevice - Failed to register a device interface!\n"
                    );
            }

            SoftPciInterfaceRegistered = TRUE;

        }

        //
        //  Initialize our tree spinlock
        //
        KeInitializeSpinLock(&SoftPciTree.TreeLock);
    }
    
    if (NT_SUCCESS(status)) {
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        return status;
    }

Cleanup:

    //
    //  Undo whatever was done
    //
    if (NT_SUCCESS(status)) {

        //
        //  If we got here with STATUS_SUCCESS then we must have failed to attach to the stack.
        //
        status = STATUS_UNSUCCESSFUL;
    }
    
    if (deviceExtension && deviceExtension->LowerDevObj) {
        IoDetachDevice(deviceExtension->LowerDevObj);
    }
    
    if (deviceObject) {
        IoDeleteDevice(deviceObject);
    }
    
    return status;
    
}

VOID
SoftPCIDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine does all clean-up work neccesary to remove the driver from memory.


Arguments:

    DriverObject            - Pointer to the driver object.

Return Value:

    NTSTATUS.

--*/
{

    //TODO
    UNREFERENCED_PARAMETER(DriverObject);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\dispatch.h ===
//
// General dispatch prototypes
// dispatch.c
//

NTSTATUS
SoftPCIDispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
SoftPCIDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\ioctldispatch.h ===
//
// IOCTL Device Control routines
// Function prototypes for Ioctoldispatch.c
//

NTSTATUS
SoftPCIOpenDeviceControl(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );

NTSTATUS
SoftPCICloseDeviceControl(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );

NTSTATUS
SoftPCIIoctlAddDevice(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );

NTSTATUS
SoftPCIIoctlRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIIoctlGetDeviceCount(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIIoctlGetDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIIocltReadWriteConfig(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\device.h ===
//
// Config Space prototypes
// device.c
//

ULONG
SoftPCIReadConfigSpace(
    IN PSOFTPCI_PCIBUS_INTERFACE BusInterface,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
SoftPCIWriteConfigSpace(
    IN PSOFTPCI_PCIBUS_INTERFACE BusInterface,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


NTSTATUS
SoftPCIAddNewDevice(
    IN PSOFTPCI_DEVICE NewDevice
    );

NTSTATUS
SoftPCIAddNewDeviceByPath(
    IN PSOFTPCI_SCRIPT_DEVICE ScriptDevice
    );

NTSTATUS
SoftPCIRemoveDevice(
    IN PSOFTPCI_DEVICE Device
    );

PSOFTPCI_DEVICE
SoftPCIFindDevice(
    IN UCHAR Bus,
    IN USHORT Slot,
    OUT PSOFTPCI_DEVICE *PreviousSibling OPTIONAL,
    IN BOOLEAN ReturnAll
    );

PSOFTPCI_DEVICE
SoftPCIFindDeviceByPath(
    IN  PWCHAR          PciPath
    );

BOOLEAN
SoftPCIRealHardwarePresent(
    IN PSOFTPCI_DEVICE Device
    );

VOID
SoftPCILockDeviceTree(
    IN PKIRQL OldIrql
    );

VOID
SoftPCIUnlockDeviceTree(
    IN KIRQL NewIrql
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\pch.h ===
#define _NTDRIVER_
#define _NTSRV_
#define _NTDDK_

#include <stdio.h>
#include <wchar.h>
#include <ntos.h>
#include <pci.h>
#include "spci.h"
#include "simguid.h"
#include <wdmguid.h>
#include <zwapi.h>


#include "softpci.h"
#include "dispatch.h"
#include "pnpdispatch.h"
#include "ioctldispatch.h"
#include "device.h"
#include "power.h"
#include "utils.h"
#include "pcipath.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\pcipath.h ===
PWCHAR
SoftPCIGetNextSlotFromPath(
    IN PWCHAR PciPath,
    OUT PSOFTPCI_SLOT Slot
    );

USHORT
SoftPCIGetTargetSlotFromPath(
    IN PWCHAR PciPath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\pnpdispatch.h ===
NTSTATUS
SoftPCIFilterStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIFilterQueryInterface(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIPassIrpDown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIPassIrpDownSuccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIPassIrpDown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCICompleteSuccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIIrpRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIQueryFilterCaps(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCI_FdoFilterRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCI_FdoStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\power.c ===
/*Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    
    power.c
    
Abstract:

    This module contains the Power routines for softpci.sys
    
Author:

    Brandon Allsop (BrandonA) Feb. 2000

Revision History:

--*/

#include "pch.h"


NTSTATUS
SoftPCIDefaultPowerHandler(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    Default routine to pass down power irps

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    NTSTATUS                         status;
    PSOFTPCI_DEVICE_EXTENSION        devExt = (PSOFTPCI_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
     
    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);

    status = PoCallDriver(devExt->LowerDevObj, Irp);

    return status;


}

NTSTATUS
SoftPCIFDOPowerHandler(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Handles Power IRPs for FDO

Arguments:

    DeviceObject    - pointer to the device object.
    Irp             - PnP Irp to be dispatched.
    
Return Value:

    NTSTATUS.

--*/

{
    
    
    
    PIO_STACK_LOCATION          irpSp;
    //PSOFTPCI_DEVICE_EXTENSION   devExt = (PSOFTPCI_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS                    status;
    
    irpSp   = IoGetCurrentIrpStackLocation(Irp);
    
    //              
    //BUGBUG BrandonA:   
    //      Currently we do not really keep track of our device state and therefore
    //      we dont check if we have been removed etc before dealing with these IRPS.
    //          
    //      Later when we start dynamically removing our SoftPCI devices and are keeping
    //      track of things more closely we will want to update this code as well to
    //      stay in sync.
    

    //
    // Check the request type.
    //

    switch  (irpSp->MinorFunction)  {

        case IRP_MN_SET_POWER   :

            
            status = SoftPCISetPower(DeviceObject, Irp);

            break;


        case IRP_MN_QUERY_POWER   :

            
            status = SoftPCIQueryPowerState(DeviceObject, Irp);
            break;

        case IRP_MN_WAIT_WAKE   :
        case IRP_MN_POWER_SEQUENCE   :

            
        default:
            //
            // Pass it down
            //
            status = SoftPCIDefaultPowerHandler(DeviceObject, Irp);
            
            break;
    }

    return status;
}



NTSTATUS
SoftPCISetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    //Currently we do nothing but pass the IRP down

    return SoftPCIDefaultPowerHandler(DeviceObject, Irp);
    

}




NTSTATUS
SoftPCIQueryPowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    
    //Currently we do nothing but pass the IRP down

    return SoftPCIDefaultPowerHandler(DeviceObject, Irp);

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\pnpdispatch.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    pnpdispatch.c

Abstract:

    This module contains functions for General PnP Irp Handlers.

Author:

    Nicholas Owens (Nichow) - 1999

Revision History:

    Brandon Allsop (BrandonA) Feb, 2000 - Bug fixes and general cleanup.
   
--*/


#include "pch.h"


NTSTATUS
SoftPCISetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SoftPCIPostProcessIrp(
    IN PSOFTPCI_DEVICE_EXTENSION DeviceExtension,
    IN OUT PIRP                  Irp
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,SoftPCISetEventCompletion)
#pragma alloc_text(PAGE,SoftPCIPostProcessIrp)
#pragma alloc_text(PAGE,SoftPCICompleteSuccess)
#pragma alloc_text(PAGE,SoftPCIPassIrpDown)
#pragma alloc_text(PAGE,SoftPCIPassIrpDownSuccess)
#pragma alloc_text(PAGE,SoftPCIIrpRemoveDevice)
#pragma alloc_text(PAGE,SoftPCIFilterStartDevice)
#pragma alloc_text(PAGE,SoftPCIFilterQueryInterface)
#pragma alloc_text(PAGE,SoftPCI_FdoStartDevice)
#endif


NTSTATUS
SoftPCISetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Completetion routine for synchronous IRP processing.

Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp we are handling
    Context         - Pointer to our event
    
Return Value:

    NTSTATUS.

--*/
{
    
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    //
    // Set event
    //

    KeSetEvent(Context,
               IO_NO_INCREMENT,
               FALSE
               );

    return STATUS_MORE_PROCESSING_REQUIRED;

}


NTSTATUS
SoftPCIPostProcessIrp(
    IN PSOFTPCI_DEVICE_EXTENSION DeviceExtension,
    IN OUT PIRP                  Irp
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine uses an IoCompletion routine along with an event to
    wait until the lower level drivers have completed processing of
    the irp.

Arguments:

    Extension - device extension for the devobj in question

    Irp - Pointer to the IRP_MJ_PNP IRP to defer

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Set our completion routine
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);
    
    IoSetCompletionRoutine(Irp,
                           SoftPCISetEventCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    status = IoCallDriver(DeviceExtension->LowerDevObj, Irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}



NTSTATUS
SoftPCIPassIrpDown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is used to pass down all PnP IRPs we dont care about.

Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp we are sending down
    
    
Return Value:

    NTSTATUS.

--*/
{
    PSOFTPCI_DEVICE_EXTENSION   deviceExtension;

    //
    // Get the device extension.
    //
    deviceExtension = (PSOFTPCI_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Pass it down
    //
    IoSkipCurrentIrpStackLocation(Irp);
    
    return IoCallDriver(deviceExtension->LowerDevObj,
                        Irp
                        );
}

NTSTATUS
SoftPCIPassIrpDownSuccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine deals with the required PnP IRPS which we dont really
    do anything with currently.

Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp to succeed.
    
    
Return Value:

    NTSTATUS.

--*/
{
    PSOFTPCI_DEVICE_EXTENSION   deviceExtension;
    NTSTATUS                    status = STATUS_SUCCESS;
    
    //
    // Set Status of Irp and pass it down
    //

    IoSkipCurrentIrpStackLocation(Irp);

    //
    // Get the device extension.
    //
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Set the status to STATUS_SUCCESS
    //
    Irp->IoStatus.Status = status;

    //
    // Send the Irp to the next driver.
    //
    status = IoCallDriver( deviceExtension->LowerDevObj,
                           Irp
                           );
    
    return status;

}

NTSTATUS
SoftPCIIrpRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Here we handle all IRP_MN_REMOVE_DEVICE IRPS

Arguments:

    DeviceObject    - Pointer to the device object of device we are removing
    Irp             - PnP Irp for remove
    
Return Value:

    NTSTATUS.

--*/
{
    PSOFTPCI_DEVICE_EXTENSION   deviceExtension;
    NTSTATUS                    status = STATUS_SUCCESS;
    
    
    //
    // Get the device extension.
    //
    deviceExtension = DeviceObject->DeviceExtension;

#ifdef SIMULATE_MSI
    deviceExtension->StopMsiSimulation = TRUE;
#endif
    
    //
    // Free up any resources.
    //
    if (deviceExtension->FilterDevObj) {
        
        //
        // Disable the device interface.
        // 
        if (deviceExtension->InterfaceRegistered) {
            
            IoSetDeviceInterfaceState(
                    &(deviceExtension->SymbolicLinkName),
                    FALSE
                    );
        }
        
        //
        // Free any remaing children
        //
        if (SoftPciTree.RootDevice) {
        
            status = SoftPCIRemoveDevice(SoftPciTree.RootDevice);

            ASSERT(NT_SUCCESS(status));
    
        }
        
    }

    //
    // Detatch from the stack.
    //
    IoDetachDevice(deviceExtension->LowerDevObj);

    //
    // Delete the device object.
    //
    IoDeleteDevice(DeviceObject);

    //
    // Set the status to STATUS_SUCCESS
    //
    Irp->IoStatus.Status = status;

    //
    // Skip and pass down
    //
    IoSkipCurrentIrpStackLocation(Irp);
    
    status = IoCallDriver(deviceExtension->LowerDevObj,
                          Irp
                          );

    
    return status;
}

//
// Filter DO PnP Irp Handlers
//

NTSTATUS
SoftPCIFilterStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Here we handle all IRP_MN_START_DEVICE IRPS for our Filter DOs

Arguments:

    DeviceObject    - Pointer to the device object of device we are starting
    Irp             - PnP Start Irp 
    
Return Value:

    NTSTATUS.

--*/
{



    NTSTATUS                        status = STATUS_SUCCESS;
    PDRIVER_OBJECT                  upperDrvObj;
    PIO_STACK_LOCATION              irpSp;
    PSOFTPCI_DEVICE_EXTENSION       deviceExtension = DeviceObject->DeviceExtension;
    PCM_RESOURCE_LIST               resList = NULL;
    
    //
    //  We do our work on the way up...
    //
    status = SoftPCIPostProcessIrp(deviceExtension,
                                   Irp
                                   );
    
        
    ASSERT(status == Irp->IoStatus.Status);

    //
    // Set the status to success if the status is correct.
    //
    if (NT_SUCCESS(status)) {
    
        //
        // Get current stack location
        //
        irpSp = IoGetCurrentIrpStackLocation(Irp);
        
        //
        // Patch PCI.SYS' Irp dispatch routines so we can get a handle to the device.
        // ISSUE - BrandonA 03-02-00: Remove this hack if PCI.SYS ever makes it so
        //         we can be an upper filter instead of a lower filter.
        upperDrvObj = DeviceObject->AttachedDevice->DriverObject;
        upperDrvObj->MajorFunction[IRP_MJ_CREATE] = SoftPCIOpenDeviceControl;
        upperDrvObj->MajorFunction[IRP_MJ_CLOSE] = SoftPCICloseDeviceControl;
    
        //
        // Enable the device interface if there is one
        //
        if (deviceExtension->InterfaceRegistered) {
            
            IoSetDeviceInterfaceState(&(deviceExtension->SymbolicLinkName),
                                      TRUE
                                      );
        }

        //
        //  At this point we need to grab the Bus number info for this root bus
        //  and use it to create a PlaceHolder device.
        //
        //  This will be required for Multi-root support

        resList = (PCM_RESOURCE_LIST) irpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

        if (resList){

            status = SoftPCIProcessRootBus(resList);

            if (!NT_SUCCESS(status)) {
                //
                //  If we fail this then we have to bail
                //
            }
        }
    }

    //
    // Complete the Irp.
    //
    IoCompleteRequest(Irp,
                      IO_NO_INCREMENT
                      );
    
    
    return status;

}

NTSTATUS
SoftPCI_FdoStartDeviceCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PSOFTPCI_DEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION          irpStack;
#ifdef SIMULATE_MSI
    PIO_WORKITEM                workItem;
#endif

    UNREFERENCED_PARAMETER(Context);

    deviceExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Keep track of the assigned resources.
    //

    deviceExtension->RawResources = irpStack->Parameters.StartDevice.AllocatedResources;
    deviceExtension->TranslatedResources = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
    deviceExtension->StopMsiSimulation = FALSE;

    //
    // Spin off a work item that will connect the interrupts and
    // simulate some device interrupts.
    //

#ifdef SIMULATE_MSI
    workItem = IoAllocateWorkItem(DeviceObject);

    if (workItem) {

        IoQueueWorkItem(workItem,
                        SoftPCISimulateMSI,
                        DelayedWorkQueue,
                        workItem);
    }
#endif

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SoftPCI_FdoStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PSOFTPCI_DEVICE_EXTENSION   deviceExtension;
    NTSTATUS                    status = STATUS_SUCCESS;
    
    PAGED_CODE();

    //
    // Set Status of Irp and pass it down
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Set a completion routine.
    //

    IoSetCompletionRoutine(Irp, 
                           SoftPCI_FdoStartDeviceCompletion,
                           NULL,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Get the device extension.
    //
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Set the status to STATUS_SUCCESS
    //
    Irp->IoStatus.Status = status;

    //
    // Send the Irp to the next driver.
    //
    status = IoCallDriver( deviceExtension->LowerDevObj,
                           Irp
                           );
    
    return status;
}



NTSTATUS
SoftPCI_FdoFilterRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack;
    PIO_RESOURCE_REQUIREMENTS_LIST resList;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    ULONG currentRequirement;
    
    ULONG   memRangeStart   = 0;
    ULONG   memRangeLength  = 0;
    ULONG   ioRangeStart    = 0;
    ULONG   ioRangeLength   = 0;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    resList = irpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;

    if ((resList != NULL) &&
        (SoftPCIGetResourceValueFromRegistry(&memRangeStart, &memRangeLength, &ioRangeStart, &ioRangeLength))){
        
        for (currentRequirement = 0;
             currentRequirement < resList->List[0].Count;
             currentRequirement++) {
            
            descriptor = &resList->List[0].Descriptors[currentRequirement];
            
            if ((descriptor->Type == CmResourceTypePort) &&
                (descriptor->u.Port.Length == ioRangeLength)) {
    
                descriptor->u.Port.MinimumAddress.QuadPart = ioRangeStart;
                descriptor->u.Port.MaximumAddress.QuadPart = (ioRangeStart + ioRangeLength) - 1;
            }

            if ((descriptor->Type == CmResourceTypeMemory) &&
                (descriptor->u.Port.Length == memRangeLength)) {
    
                descriptor->u.Port.MinimumAddress.QuadPart = memRangeStart;
                descriptor->u.Port.MaximumAddress.QuadPart = (memRangeStart + memRangeLength) - 1;
            }

        }

    }

    return SoftPCIPassIrpDown(DeviceObject, Irp);
}

NTSTATUS
SoftPCIFilterQueryInterface(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Here we handle all IRP_MN_QUERY_INTERFACE IRPS for our Filter DOs.  The objective here
    is to hijack the BUS_INTERFACE used for accessing configspace on the machine so that 
    we can replace it with out own.

Arguments:

    DeviceObject    - Pointer to the device object of device we are starting
    Irp             - PnP Start Irp 
    
Return Value:

    NTSTATUS.

--*/
{

    NTSTATUS                    status = STATUS_SUCCESS;
    PSOFTPCI_DEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION          irpSp;
    
    //
    // Get current stack location
    //
    irpSp = IoGetCurrentIrpStackLocation(Irp);
    
    //
    // If this is the right interface replace the whole lot,
    // otherwise handle it just like any other Irp.
    //
    if (IsEqualGUID(&GUID_PCI_BUS_INTERFACE_STANDARD, irpSp->Parameters.QueryInterface.InterfaceType)) {
        
        //
        //  We do our work on the way up...
        //
        status = SoftPCIPostProcessIrp(deviceExtension,
                                       Irp
                                       );

        //
        // Only finish up if the Irp succeeded.
        //
        if ((NT_SUCCESS(status)) &&
            SoftPciTree.BusInterface != NULL) {

            PPCI_BUS_INTERFACE_STANDARD pciStandard;
            PSOFTPCI_PCIBUS_INTERFACE   busInterface = SoftPciTree.BusInterface;
            
            //
            // Grab the interface
            //
            pciStandard = (PPCI_BUS_INTERFACE_STANDARD) irpSp->Parameters.QueryInterface.Interface;
    
            //
            // Save the old [Read/Write]Config routines
            //
            busInterface->ReadConfig = pciStandard->ReadConfig;
    
            busInterface->WriteConfig = pciStandard->WriteConfig;
    
            //
            // Put our [Read/Write]Config routines in the Interface
            // so PCI calls us instead of the Hal.
            //
            pciStandard->ReadConfig = SoftPCIReadConfigSpace;
            pciStandard->WriteConfig = SoftPCIWriteConfigSpace;
            
            //
            // Save the old context and update the context the caller will recieve.
            //
            busInterface->Context = pciStandard->Context;
            pciStandard->Context = busInterface;
            
         }

        //
        // Complete the Irp.
        //
        IoCompleteRequest(Irp,
                          IO_NO_INCREMENT
                          );

    } else {

        //
        // Pass the Irp down the stack, this is some 
        // other interface than GUID_PCI_BUS_INTERFACE_STANDARD.
        //
        status = SoftPCIPassIrpDown(DeviceObject,
                                    Irp
                                    );
    }


    return status;

}

#if 0   //Currently not used.

NTSTATUS
SoftPCIQueryFilterCaps(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
/*++

Routine Description:

    Routine used to filter QUERY_CAPABILITIES

Arguments:

    DeviceObject    - Pointer to the device object.
    Irp             - PnP Irp we are handling
    
Return Value:

    NTSTATUS.

--*/

{


    KEVENT                      event;
    NTSTATUS                    status = STATUS_SUCCESS;
    PSOFTPCI_DEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION          irpSp = IoGetCurrentIrpStackLocation (Irp);
    PDEVICE_CAPABILITIES	    devCaps = irpSp->Parameters.DeviceCapabilities.Capabilities;


    //
    // Initialize and Set event for post-processing Irp
    //
    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE
                      );

    //
    // Set up the next stack location for
    // the next driver down the stack.
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Set completion routine
    //

    IoSetCompletionRoutine(Irp,
                           SoftPCISetEventCompletion,
                           &event,
                           TRUE,
                           FALSE,
                           FALSE
                           );
    //
    // Get the device extension.
    //
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Send the Irp to the next driver.
    //

    status = IoCallDriver(deviceExtension->LowerDevObj,
                          Irp
                          );

    //
    // If our completion routine has not been called
    // then wait here until it is done.
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              0
                              );

        status = Irp->IoStatus.Status;
    }
    
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    return status;



}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\softpci.h ===
#ifndef _SOFTPCIDRV_
#define _SOFTPCIDRV_

//
// Registry Path to driver's registry key
//
#define SOFTPCI_CONTROL     L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SoftPCI"

#define SPCI_SIG    0xFFBBFFBB

typedef const GUID * PGUID;

//
// These are the states FDO transition to upon
// receiving a specific PnP Irp.
//
typedef enum _DEVICE_PNP_STATE {

    NotStarted = 0,         // Not started yet
    Started,                // Device has received the START_DEVICE IRP
    StopPending,            // Device has received the QUERY_STOP IRP
    Stopped,                // Device has received the STOP_DEVICE IRP
    RemovePending,          // Device has received the QUERY_REMOVE IRP
    SurpriseRemovePending,  // Device has received the SURPRISE_REMOVE IRP
    Deleted                 // Device has received the REMOVE_DEVICE IRP

} DEVICE_PNP_STATE;

//
// Device Extension definitions.
//
typedef struct _SOFTPCI_DEVICE_EXTENSION *PSOFTPCI_DEVICE_EXTENSION;

typedef struct _SOFTPCI_PCIBUS_INTERFACE{
    PCI_READ_WRITE_CONFIG ReadConfig;
    PCI_READ_WRITE_CONFIG WriteConfig;
    PVOID Context;
} SOFTPCI_PCIBUS_INTERFACE, *PSOFTPCI_PCIBUS_INTERFACE;

typedef struct _SOFTPCI_DEVICE_EXTENSION{

    ULONG               Signature;
    BOOLEAN             FilterDevObj;
    PDEVICE_OBJECT      PDO;
    PDEVICE_OBJECT      LowerDevObj;
    SINGLE_LIST_ENTRY   ListEntry;
    
#if 0   //enable these once we implement support for them
    SYSTEM_POWER_STATE  SystemPowerState;
    DEVICE_POWER_STATE  DevicePowerState;
    
    DEVICE_PNP_STATE    DevicePnPState;
    DEVICE_PNP_STATE    PreviousPnPState;
#endif
    
//    PSOFTPCI_DEVICE     Root;          
//    ULONG               DeviceCount;
    UNICODE_STRING      SymbolicLinkName;
    BOOLEAN             InterfaceRegistered;

    PCM_RESOURCE_LIST   RawResources;
    PCM_RESOURCE_LIST   TranslatedResources;

    BOOLEAN             StopMsiSimulation;
    
} SOFTPCI_DEVICE_EXTENSION;

typedef struct _SOFTPCI_TREE{

   ULONG                       DeviceCount;
   PSOFTPCI_DEVICE             RootDevice;
   PSOFTPCI_PCIBUS_INTERFACE   BusInterface;
   SINGLE_LIST_ENTRY           RootPciBusDevExtList;
   KSPIN_LOCK                  TreeLock;
   
} SOFTPCI_TREE, *PSOFTPCI_TREE;


//
// Global pointer to DevExt in our Filter DO
//
//extern PSOFTPCI_DEVICE_EXTENSION      SoftPciRootDevExt;

extern SOFTPCI_TREE     SoftPciTree;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\power.h ===
//
//prototypes for Power.c
//
NTSTATUS
SoftPCIFDOPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCISetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIQueryPowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SoftPCIDefaultPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\pcipath.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pcipath.c

Abstract:

    This module contains functions for handling our Pci device path strings

Author:

    Brandon Allsop (BrandonA)

Revision History:
    

--*/


#include "pch.h"

#define WCharToLower(ch)                 \
    if (ch >= 'A' &&  ch <= 'Z') {      \
        ch += 'a' - 'A';                \
    }

USHORT
SoftPCIStringToUSHORT(
    IN PWCHAR String
    );

PWCHAR
SoftPCIGetNextSlotFromPath(
    IN PWCHAR PciPath,
    OUT PSOFTPCI_SLOT Slot
    )
/*++

Routine Description:

    This function takes a PCIPATH and parses out each individual SOFTPCI_SLOT

Arguments:

    PciPath - Path to device.  Syntax is FFXX\DEVFUNC\DEVFUNC\....
    Slot - Slot value that is filled in

Return Value:

    Pointer to the beginning of the next Slot in the Path

--*/
{

    WCHAR slotString[10];
    PWCHAR pciSlot, pciPath;
    
    ASSERT(PciPath != NULL);

    RtlZeroMemory(slotString, sizeof(slotString));

    SoftPCIDbgPrint(
        SOFTPCI_FIND_DEVICE, 
        "SOFTPCI: GetNextSlotFromPath - \"%ws\"\n", 
        PciPath
        );
    
    pciSlot = slotString;
    pciPath = PciPath;
    while (*pciPath != '\\'){

        if (*pciPath == 0) {
            break;
        }
        
        *pciSlot = *pciPath;
        pciSlot++;
        pciPath++;
    }
    
    Slot->AsUSHORT = SoftPCIStringToUSHORT(slotString);

    if (*pciPath == 0) {

        //
        //  We are at the end of our path
        //
        pciPath = NULL;
    }else{
        pciPath++;
    }
    
    return pciPath;
}

USHORT
SoftPCIGetTargetSlotFromPath(
    IN PWCHAR PciPath
    )
/*++

Routine Description:

    This function takes a PCIPATH and converts a given Slot from string to number

Arguments:

    PciPath - Path to device.  Syntax is FFXX\DEVFUNC\DEVFUNC\....
    
Return Value:

    USHORT or (SOFTPCI_SLOT) that was converted from the string

--*/
{
    ULONG slotLength;
    PWCHAR slotString;

    slotLength = (ULONG) wcslen(PciPath);
    slotString = PciPath + slotLength;

    while (*slotString != '\\') {
        slotString--;
    }

    return SoftPCIStringToUSHORT(slotString+1);
}

USHORT
SoftPCIStringToUSHORT(
    IN PWCHAR String
    )
/*++

Routine Description:

    This function takes a string and manually converts it to a USHORT number. This
    was needed because there doesnt appear to be a kernel mode runtime that will do
    this at any IRQL.

Arguments:

    String - String to convert
    
Return Value:

    USHORT number converted

--*/
{

    WCHAR numbers[] = L"0123456789abcdef";
    PWCHAR p1, p2;
    USHORT convertedValue = 0;
    BOOLEAN converted = FALSE;

    SoftPCIDbgPrint(
        SOFTPCI_FIND_DEVICE, 
        "SOFTPCI: StringToUSHORT - \"%ws\"\n", 
        String
        );
    
    p1 = numbers;
    p2 = String;

    while (*p2) {

        //
        //  Ensure our hex letters are lowercase
        //
        WCharToLower(*p2);

        while (*p1 && (converted == FALSE)) {

            if (*p1 == *p2) {
                
                //
                //  Shift anything we already have aside to make room
                //  for the next digit
                //
                convertedValue <<= 4;
                
                convertedValue |= (((UCHAR)(p1 - numbers)) & 0x0f);

                converted = TRUE;
            }
            p1++;
        }

        if (converted == FALSE) {
            //
            //  Encountered something we couldnt convert.  Return what we have
            //
            return convertedValue;
        }

        p2++;
        
        //
        //  reset everything
        //
        p1 = numbers;
        converted = FALSE;
    }

    return convertedValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\utils.c ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains misc functions that were stolen from PCI.SYS' Utils.c/Debug.c

Author:

    Brandon Allsop (BranodnA) Feb, 2000

Revision History:

   
--*/

#include "pch.h"

#define IOSTART     L"IoRangeStart"
#define IOLENGTH    L"IoRangeLength"
#define MEMSTART    L"MemRangeStart"
#define MEMLENGTH   L"MemRangeLength"

#ifdef ALLOC_PRAGMA
#ifdef SIMULATE_MSI
#pragma alloc_text (PAGE, SoftPCISimulateMSI)
#endif
#endif


BOOLEAN
SoftPCIOpenKey(
    IN PWSTR KeyName,
    IN HANDLE ParentHandle,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    )

/*++

Description:

    Open a registry key.

Arguments:

    KeyName      Name of the key to be opened.
    ParentHandle Pointer to the parent handle (OPTIONAL)
    Handle       Pointer to a handle to recieve the opened key.

Return Value:

    TRUE is key successfully opened, FALSE otherwise.

--*/

{
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES nameAttributes;
    NTSTATUS localStatus;

    PAGED_CODE();

    RtlInitUnicodeString(&nameString, KeyName);

    InitializeObjectAttributes(&nameAttributes,
                               &nameString,
                               OBJ_CASE_INSENSITIVE,
                               ParentHandle,
                               (PSECURITY_DESCRIPTOR)NULL
                               );
    localStatus = ZwOpenKey(Handle,
                            KEY_READ,
                            &nameAttributes
                            );

    if (Status != NULL) {

        //
        // Caller wants underlying status.
        //

        *Status = localStatus;
    }

    //
    // Return status converted to a boolean, TRUE if
    // successful.
    //

    return (BOOLEAN)(NT_SUCCESS(localStatus));
}

NTSTATUS
SoftPCIGetRegistryValue(
    IN PWSTR ValueName,
    IN PWSTR KeyName,
    IN HANDLE ParentHandle,
    OUT PVOID *Buffer,
    OUT ULONG *Length
    )
{
    NTSTATUS status;
    HANDLE keyHandle;
    ULONG neededLength;
    ULONG actualLength;
    UNICODE_STRING unicodeValueName;

    if (!SoftPCIOpenKey(KeyName, ParentHandle, &keyHandle, &status)) {
        return status;
    }

    unicodeValueName.Buffer = ValueName;
    unicodeValueName.MaximumLength = (USHORT)(wcslen(ValueName) + 1) * sizeof(WCHAR);
    unicodeValueName.Length = unicodeValueName.MaximumLength - sizeof(WCHAR);

    //
    // Find out how much memory we need for this.
    //

    status = ZwQueryValueKey(
                 keyHandle,
                 &unicodeValueName,
                 KeyValuePartialInformation,
                 NULL,
                 0,
                 &neededLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        PKEY_VALUE_PARTIAL_INFORMATION info;

        ASSERT(neededLength != 0);

        //
        // Get memory to return the data in.  Note this includes
        // a header that we really don't want.
        //

        info = ExAllocatePool(
                   PagedPool,
                   neededLength);
        if (info == NULL) {
            ZwClose(keyHandle);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Get the data.
        //

        status = ZwQueryValueKey(
                 keyHandle,
                 &unicodeValueName,
                 KeyValuePartialInformation,
                 info,
                 neededLength,
                 &actualLength
                 );
        if (!NT_SUCCESS(status)) {

            ASSERT(NT_SUCCESS(status));
            ExFreePool(info);
            ZwClose(keyHandle);
            return status;
        }

        ASSERT(neededLength == actualLength);

        //
        // Subtract out the header size and get memory for just
        // the data we want.
        //

        neededLength -= FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);

        *Buffer = ExAllocatePool(
                      PagedPool,
                      neededLength
                      );
        if (*Buffer == NULL) {
            ExFreePool(info);
            ZwClose(keyHandle);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Copy data sans header.
        //

        RtlCopyMemory(*Buffer, info->Data, neededLength);
        ExFreePool(info);

        if (Length) {
            *Length = neededLength;
        }

    } else {

        if (NT_SUCCESS(status)) {

            //
            // We don't want to report success when this happens.
            //

            status = STATUS_UNSUCCESSFUL;
        }
    }
    ZwClose(keyHandle);
    return status;
}

VOID
SoftPCIInsertEntryAtTail(
    IN PSINGLE_LIST_ENTRY Entry
    )
{
    PSINGLE_LIST_ENTRY previousEntry;

    //
    // Find the end of the list.
    //
    previousEntry = &SoftPciTree.RootPciBusDevExtList;

    while (previousEntry->Next) {
        previousEntry = previousEntry->Next;
    }

    //
    // Append the entry.
    //
    previousEntry->Next = Entry;
    
}

NTSTATUS
SoftPCIProcessRootBus(
    IN PCM_RESOURCE_LIST    ResList
    )
{

    ULONG i,j;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    HANDLE spciHandle;
    WCHAR rootSlot[sizeof("XXXX")];
    PSOFTPCI_DEVICE rootBus = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR fullList;
	PCM_PARTIAL_RESOURCE_LIST partialList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR	partialDesc;
    
    for (i = 0; i < ResList->Count; i++){
        
        fullList = ResList->List;
        partialList = &fullList->PartialResourceList;
        
        for (j = 0; j < partialList->Count; j++){
            
            partialDesc = &partialList->PartialDescriptors[j];
            
            switch (partialDesc->Type){
            
            case CmResourceTypeBusNumber:
                
                ASSERT(partialDesc->u.BusNumber.Start < 0xff);

                SoftPCIDbgPrint(
                    SOFTPCI_INFO, 
                    "SOFTPCI: FilterStartDevice - Found root bus 0x%x-0x%x\n", 
                    partialDesc->u.BusNumber.Start,
                    (partialDesc->u.BusNumber.Start + (partialDesc->u.BusNumber.Length-1))
                    );
                
                //
                //  Allocate pool for a place holder device.  We need this so we can
                //  place devices on any root bus desired.
                //
                rootBus = (PSOFTPCI_DEVICE) ExAllocatePool(NonPagedPool, sizeof(SOFTPCI_DEVICE)); 

                RtlZeroMemory(rootBus, sizeof(SOFTPCI_DEVICE)); 
                    
                if (rootBus) {
                    
                    rootBus->Bus = (UCHAR)partialDesc->u.BusNumber.Start;
                    rootBus->Config.PlaceHolder = TRUE;

                    //
                    //  Pretend a little here...
                    //
                    rootBus->Config.Current.VendorID = 0xAAAA;
                    rootBus->Config.Current.DeviceID = 0xBBBB;
                    rootBus->Config.Current.HeaderType = 1;
                    rootBus->Config.Current.u.type1.SecondaryBus = rootBus->Bus;
                    rootBus->Config.Current.u.type1.SubordinateBus = (UCHAR)((partialDesc->u.BusNumber.Start +
                                                                      partialDesc->u.BusNumber.Length) - 1);

                    //
                    //  Update our Slot information so we know which root this is when
                    //  we parse the tree via a path
                    //
                    rootBus->Slot.Device = 0xff;
                    rootBus->Slot.Function = rootBus->Bus;
                    
                    status = SoftPCIAddNewDevice(rootBus);

                    if (!NT_SUCCESS(status)){
                        
                        SoftPCIDbgPrint(
                            SOFTPCI_ERROR, 
                            "SOFTPCI: FilterStartDevice - Failed add root node!\n"
                            );
                        
                        ASSERT(NT_SUCCESS(status));
                    }

                    //
                    //  Device is now in our list, free this memory
                    //
                    ExFreePool(rootBus);

                    
                    if (!SoftPCIOpenKey(SOFTPCI_CONTROL, NULL, &spciHandle, &status)) {

                        //
                        //  If we failed this then we probably havent ever run our cool user
                        //  mode app (SOFTPCI.EXE) to create any fake devices. Lets not fail 
                        //  start
                        //
                        SoftPCIDbgPrint(
                            SOFTPCI_ERROR, 
                            "SOFTPCI: FilterStartDevice - Failed to open SoftPCI registry key!! (%x)\n",
                            status
                            );

                        status = STATUS_SUCCESS;
                        
                    }else{

                        rootBus = SoftPCIFindDevice(
                            (UCHAR)partialDesc->u.BusNumber.Start,
                            (0xff00 + (UCHAR)partialDesc->u.BusNumber.Start),
                            NULL,
                            TRUE
                            );

                        ASSERT(rootBus != NULL);

                        //
                        //  Now lets enumerate any children this root may have
                        //  in the registry
                        //
                        _snwprintf(rootSlot,
                                   (sizeof(rootSlot) / sizeof(rootSlot[0])),
                                   L"%04x",
                                   rootBus->Slot.AsUSHORT
                                   );

                        SoftPCIEnumRegistryDevs(rootSlot, &spciHandle, rootBus);

                        ZwClose(spciHandle);

                    }
                
                }else{

                    SoftPCIDbgPrint(
                        SOFTPCI_ERROR, 
                        "SOFTPCI: FilterStartDevice - Failed to allocate memory for root node!\n"
                        );
                    
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;

               
            default:
                break;

            }
    
        }
    
    }

    return status;

}

NTSTATUS
SoftPCIEnumRegistryDevs(
    IN PWSTR            KeyName,
    IN PHANDLE          ParentHandle,
    IN PSOFTPCI_DEVICE  ParentDevice
    )
/*++

Routine Description:

    This routine searches the registry for SoftPCI devices.  We start from
    \HLM\CCS\Control\SoftPCI and work our way through the devices.  When we
    encounter a SoftPCI-PCI bridge device we will search for devices behind it
    recursively.


Arguments:

    KeyName       - Name of Key to search for devices.
    ParentHandle  - Pointer to handle for KeyName.
    ParentDevice  - Pointer to parent SoftPCI-PCI Bridge or RootBus
    
Return Value:

    NTSTATUS.

--*/
{

    NTSTATUS status;
    HANDLE spciHandle;
    PSOFTPCI_DEVICE newDevice, currentChild;
    ULONG device, function, configLength;
    WCHAR buffer[sizeof(L"XXXX")];
    PSOFTPCI_CONFIG softConfig;
    //PPCI_COMMON_CONFIG commonConfig = NULL;
    
    PAGED_CODE();

    ASSERT(ParentDevice != NULL);

    if (!SoftPCIOpenKey(KeyName, *ParentHandle, &spciHandle, &status)) {
        
        return status;
    }
    
    //
    //  Now that we have opened our key lets search for devices.
    //
    for (device=0; device < PCI_MAX_DEVICES; device++) {
        
        for (function=0; function < PCI_MAX_FUNCTION ; function++) {

            _snwprintf(
                buffer,
                (sizeof(buffer) / sizeof(buffer[0])),
                L"%02x%02x",
                device,
                function
                );
            

            status = SoftPCIGetRegistryValue(
                L"Config", 
                buffer, 
                spciHandle, 
                &softConfig, 
                &configLength
                );
            
            if (NT_SUCCESS(status)){
    
                SoftPCIDbgPrint(SOFTPCI_INFO, 
                                "SOFTPCI: EnumRegistryDevs found %ws in registry!\n", 
                                buffer);
                
                //
                // Lets allocate a new device
                //
                newDevice = ExAllocatePool(NonPagedPool, sizeof(SOFTPCI_DEVICE));
    
                if (!newDevice) {
                    
                    //
                    //  Better luck next time.
                    //
                    ZwClose(spciHandle);
                    ExFreePool(softConfig);
                    
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
                
                //
                //  Until we determine its place in this world, zero everything out.
                //
                RtlZeroMemory(newDevice, sizeof(SOFTPCI_DEVICE));

                //
                // Copy the config from the registry to our new (NonPagedPool) device
                //
                RtlCopyMemory(&newDevice->Config, softConfig, configLength);
                
                //
                //  Free the PagedPool
                //
                ExFreePool(softConfig);
                
#if 0
                if (newDevice->Config.PlaceHolder) {
                    
                    commonConfig = &ParentDevice->Config.Current;

                    //
                    //  We are on the bus our parent exposes.
                    //
                    newDevice->Bus = commonConfig->u.type1.SecondaryBus;
                }else{
                    
                    //
                    //  Let PCI sort it all out for us.
                    //
                    newDevice->Bus = 0;
                }
#endif
                newDevice->Bus = ParentDevice->Config.Current.u.type1.SecondaryBus;
                
                newDevice->Slot.Device = (UCHAR) device;
                newDevice->Slot.Function = (UCHAR) function;
                
                //
                //  Attach device to devicetree
                //
                currentChild = ParentDevice->Child;

                if (currentChild) {

                    while (currentChild->Sibling) {
                        currentChild=currentChild->Sibling;
                    }
    
                    currentChild->Sibling = newDevice;

                }else{
                    
                    ParentDevice->Child = newDevice;
                    newDevice->Parent = ParentDevice;
                }
                                  
                SoftPciTree.DeviceCount++;
                
                if (IS_BRIDGE(newDevice)) {

                    //
                    //  We found a SoftPCI-PCI bridge device.  Guess we better
                    //  see if there are any devices "behind" it.
                    //
                    SoftPCIEnumRegistryDevs(buffer, &spciHandle, newDevice);
                }
                
                if (!PCI_MULTIFUNCTION_DEVICE(&newDevice->Config.Current)){
                    //
                    //  This is not a multifunction device, skip the other functions.
                    //
                    break;
                }
                
            }else{

                if (function == 0) {
                    //
                    //  No need to check the other functions of this one failed.
                    //
                    break;

                }
            }

        }
    
    }
    ZwClose(spciHandle);

    return status;


}

VOID
SoftPCIEnumerateTree(
    VOID
    )
{
    PSOFTPCI_DEVICE_EXTENSION deviceExtension;
    PSINGLE_LIST_ENTRY listEntry;

    listEntry = SoftPciTree.RootPciBusDevExtList.Next;
    while (listEntry) {

        deviceExtension = CONTAINING_RECORD(listEntry,
                                            SOFTPCI_DEVICE_EXTENSION,
                                            ListEntry);
        
        ASSERT(deviceExtension != NULL);
        
        IoInvalidateDeviceRelations(deviceExtension->PDO, BusRelations);
        
        listEntry = listEntry->Next;
    }
}

NTSTATUS
SoftPCIQueryDeviceObjectType(
    IN PDEVICE_OBJECT DeviceObject, 
    IN OUT PBOOLEAN       IsFDO
    )
/*++

Routine Description:

    This routine sends a PCI_BUS_INTERFACE_STANDARD query down the stack.  If we get one back
    then we are not an FDO.  Since this routine is called from our AddDevice we have no worry
    of not sending this to the entire stack.
    
Arguments:

    DeviceObject            - Next Lower DeviceObject
    IsFDO                   - Set TRUE if we fail to get an interface.

Return Value:

    NTSTATUS.

--*/

{
    
    
    NTSTATUS status;
    PPCI_BUS_INTERFACE_STANDARD interface;
    KEVENT irpCompleted;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    IO_STATUS_BLOCK statusBlock;

    PAGED_CODE();

    SoftPCIDbgPrint(SOFTPCI_VERBOSE, "SOFTPCI: QueryDeviceObjectType ENTER\n");

    interface = ExAllocatePool(NonPagedPool, 
                               sizeof(PCI_BUS_INTERFACE_STANDARD));

    if (!interface) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    //
    // Initialize our event
    //
    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);
    
    //
    // Get an IRP
    //
    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       DeviceObject,
                                       NULL,    // Buffer
                                       0,       // Length
                                       0,       // StartingOffset
                                       &irpCompleted,
                                       &statusBlock
                                       );
    if (!irp) {
        ExFreePool(interface);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    //
    // Initialize the stack location
    //
    irpStack = IoGetNextIrpStackLocation(irp);

    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    irpStack->Parameters.QueryInterface.InterfaceType = (PGUID) &GUID_PCI_BUS_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Version = PCI_BUS_INTERFACE_STANDARD_VERSION;
    irpStack->Parameters.QueryInterface.Size = sizeof (PCI_BUS_INTERFACE_STANDARD);
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) interface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the driver and wait for completion
    //
    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    if (NT_SUCCESS(status)) {
        
        //
        //  We have and interface therefore we must load as a filter DO
        //
        *IsFDO = FALSE; 

        SoftPCIDbgPrint(
            SOFTPCI_ADD_DEVICE, 
            "SOFTPCI: QueryDeviceObjectType - found FilterDO\n"
            );
        
    }else if (status == STATUS_NOT_SUPPORTED) {

        //
        //  We didnt get an interface therefore we must be an FDO
        //
        SoftPCIDbgPrint(
            SOFTPCI_ADD_DEVICE, 
            "SOFTPCI: QueryDeviceObjectType - found FDO \n"
            );

        status = STATUS_SUCCESS;

    }

    //
    // Ok we're done with this stack
    //
    ExFreePool(interface);

    SoftPCIDbgPrint(
        SOFTPCI_VERBOSE, 
        "SOFTPCI: QueryDeviceObjectType - EXIT\n"
        );

    return status;
}

BOOLEAN
SoftPCIGetResourceValueFromRegistry(
    OUT PULONG MemRangeStart,
    OUT PULONG MemRangeLength,
    OUT PULONG IoRangeStart,
    OUT PULONG IoRangeLength
    )
{
    ULONG keySize = 0;
    PULONG memRangeStart = NULL;
    PULONG memRangeLength = NULL;
    PULONG ioRangeStart = NULL;
    PULONG ioRangeLength = NULL;
    
    
    SoftPCIGetRegistryValue(MEMSTART,
                            SOFTPCI_CONTROL,
                            NULL, 
                            &memRangeStart, 
                            &keySize);

    if (memRangeStart) {

        *MemRangeStart = *memRangeStart;
        ExFreePool(memRangeStart);
    }

    SoftPCIGetRegistryValue(MEMLENGTH,
                            SOFTPCI_CONTROL,
                            NULL, 
                            &memRangeLength, 
                            &keySize);

    if (memRangeLength) {
        *MemRangeLength = *memRangeLength;
        ExFreePool(memRangeLength);
    }
    
    SoftPCIGetRegistryValue(IOSTART, 
                            SOFTPCI_CONTROL,
                            NULL, 
                            &ioRangeStart, 
                            &keySize);

    if (ioRangeStart) {
        *IoRangeStart = *ioRangeStart;
        ExFreePool(ioRangeStart);
    }

    SoftPCIGetRegistryValue(IOLENGTH, 
                            SOFTPCI_CONTROL,
                            NULL, 
                            &ioRangeLength, 
                            &keySize);

    if (ioRangeLength) {
        *IoRangeLength = *ioRangeLength;
        ExFreePool(ioRangeLength);
    }

    return TRUE;

}

#ifdef SIMULATE_MSI
BOOLEAN
SoftPCIMessageIsr(
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext,
    IN ULONG MessageID
    )
{
    UNREFERENCED_PARAMETER(Interrupt);
    UNREFERENCED_PARAMETER(ServiceContext);

    DbgPrint("SoftPCI: received interrupt message %x\n", MessageID);
    return TRUE;
}

VOID
SoftPCISimulateMSI(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PSOFTPCI_DEVICE_EXTENSION   deviceExtension;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR tDesc, rDesc;
    ULONG                       buffSize, i;
    PIO_INTERRUPT_MESSAGE_INFO  mInfo = NULL;
    BOOLEAN identityMappedMachine = TRUE;
    NTSTATUS        status;
    LARGE_INTEGER   waitLength;
    USHORT          *vAddr;
    BOOLEAN         msiEnabled = FALSE;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    
    ASSERT(deviceExtension->RawResources);
    ASSERT(deviceExtension->TranslatedResources);

    //
    // First, see if any of the assigned resources were
    // for an MSI.
    //

    for (i = 0; i < deviceExtension->RawResources->List[0].PartialResourceList.Count; i++) {

        rDesc = &deviceExtension->RawResources->List[0].PartialResourceList.PartialDescriptors[i];
        tDesc = &deviceExtension->TranslatedResources->List[0].PartialResourceList.PartialDescriptors[i];
        ASSERT(rDesc->Type == tDesc->Type);

        switch (rDesc->Type) {
        case CmResourceTypePort:
        case CmResourceTypeMemory:

            DbgPrint("%s: %x-%x\n",
                     rDesc->Type == CmResourceTypePort ? "Port" : "Memory",
                     rDesc->u.Generic.Start.LowPart,
                     rDesc->u.Generic.Start.LowPart + rDesc->u.Generic.Length - 1);

            if (rDesc->u.Generic.Start.QuadPart != tDesc->u.Generic.Start.QuadPart) {
                identityMappedMachine = FALSE;
                DbgPrint("%s: %x-%x - translated\n",
                     tDesc->Type == CmResourceTypePort ? "Port" : "Memory",
                     tDesc->u.Generic.Start.LowPart,
                     tDesc->u.Generic.Start.LowPart + tDesc->u.Generic.Length - 1);
            }
            break;

        case CmResourceTypeInterrupt:

            DbgPrint("L:%x V:%x A:%p %s\n",
                     rDesc->u.Interrupt.Level,
                     rDesc->u.Interrupt.Vector,
                     rDesc->u.Interrupt.Affinity,
                     rDesc->Flags & CM_RESOURCE_INTERRUPT_MESSAGE ? "message signaled" : "");

            if (rDesc->Flags & CM_RESOURCE_INTERRUPT_MESSAGE) {

                DbgPrint("\tMessageCount: %x Payload: %04x TargetAddr: %p\n",
                         rDesc->u.MessageInterrupt.Raw.MessageCount,
                         rDesc->u.MessageInterrupt.Raw.DataPayload,
                         rDesc->u.MessageInterrupt.Raw.MessageTargetAddress);

                msiEnabled = TRUE;
            }
            
            DbgPrint("L:%x V:%x A:%p %s\n",
                     tDesc->u.Interrupt.Level,
                     tDesc->u.Interrupt.Vector,
                     tDesc->u.Interrupt.Affinity,
                     tDesc->Flags & CM_RESOURCE_INTERRUPT_MESSAGE ? "message signaled" : "");

            if (tDesc->Flags & CM_RESOURCE_INTERRUPT_MESSAGE) {

                DbgPrint("\tIRQL:%x IDT:%x\n",
                         tDesc->u.Interrupt.Level,
                         tDesc->u.Interrupt.Vector);

                msiEnabled = TRUE;
            }
            break;

        default:

            DbgPrint("other\n");
        }
    }

    if (!msiEnabled) goto SoftPCISimulateMSIExit;

    //
    // Call IoConnectInterruptMessage to see what size buffer is necessary.
    //

    buffSize = 0;
    status = IoConnectInterruptMessage(NULL,
                                       &buffSize,
                                       deviceExtension->PDO,
                                       SoftPCIMessageIsr,
                                       deviceExtension,
                                       NULL,
                                       0,
                                       FALSE,
                                       FALSE);

    ASSERT(!NT_SUCCESS(status));
    if (status != STATUS_BUFFER_TOO_SMALL) goto SoftPCISimulateMSIExit;

    ASSERT(buffSize >= sizeof(IO_INTERRUPT_MESSAGE_INFO));
    mInfo = (PIO_INTERRUPT_MESSAGE_INFO)ExAllocatePool(NonPagedPool,
                                                       buffSize);
    if (!mInfo) goto SoftPCISimulateMSIExit;

    status = IoConnectInterruptMessage(mInfo,
                                       &buffSize,
                                       deviceExtension->PDO,
                                       SoftPCIMessageIsr,
                                       deviceExtension,
                                       NULL,
                                       0,
                                       FALSE,
                                       FALSE);

    if (!NT_SUCCESS(status)) {
        ASSERT(!"Failed to connect the message handler.\n");
        goto SoftPCISimulateMSIExit;
    }

    //
    // Now simulate some interrupts.
    //

    if (!identityMappedMachine) goto SoftPCISimulateMSIExit;

    //
    // This machine's address-space resources are the same when raw and
    // translated, which probably means that the processor can generate
    // an MSI using the same write transaction that the device would
    // use, which is convenient when simulating.
    //

    waitLength.QuadPart = -20000; // 2 seconds, relative time
    
    while (TRUE) {

        //
        // Cycle through each of the messages, periodically triggering
        // them.
        //

        for (i = 0; i < mInfo->MessageCount; i++) {

            status = KeDelayExecutionThread(KernelMode,
                                            FALSE,
                                            &waitLength);
            ASSERT(NT_SUCCESS(status));
    
            //
            // Get a virtual address for the physical one listed
            // in the array of messages.
            //

            vAddr = MmMapIoSpace(mInfo->MessageInfo[i].MessageAddress,
                                 sizeof(ULONG),
                                 TRUE);

            WRITE_REGISTER_USHORT(vAddr, (USHORT)mInfo->MessageInfo[i].MessageData);

            MmUnmapIoSpace(vAddr, sizeof(ULONG));

            if (deviceExtension->StopMsiSimulation) goto SoftPCISimulateMSIExitDisconnectInterrupt;
        }
    }

SoftPCISimulateMSIExitDisconnectInterrupt:

    IoDisconnectInterrupt(mInfo->InterruptObject);

SoftPCISimulateMSIExit:

    if (mInfo) ExFreePool(mInfo);
    IoFreeWorkItem(Context);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\scrubber\scrubber.c ===
/*
 Note: This program creates the following files in %systemroot%\system32\config:

  system.sc0	Backup at start of operations
  system.scc	Backup if compression is on (win2k only)
  system.scb	Backup after removing devnodes (win2k only)
  system.scn	Temporary during replacement of system (should go away)
  system		Updated system hive (should match system.scb)

  Modification History:
  10/3/2000		original version from jasconc
  10/4/2000		put back compression option, version 0.9
  10/10/2000	if compression (no removals), save backup as .scc, else as .sc0
  10/13/2000	Add version check (Win2K only, not NT4, not Whistler, etc.)
  10/20/2000	Return DevicesRemoved to help with diskpart in scripts
  12/11/2001	Updated headers, check for .NET and added NtCompressKey for inplace registry compression. v1.01
*/

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless strut/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <tchar.h>

#include <setupapi.h>
#include <sputils.h>
#include <cfgmgr32.h>
#include <regstr.h>
#include <initguid.h>
#include <devguid.h>
#include <winioctl.h>

#pragma warning( default : 4201 )

#define SIZECHARS(x)         (sizeof((x))/sizeof(TCHAR))


CONST GUID *ClassesToClean[2] = {
    &GUID_DEVCLASS_DISKDRIVE,
    &GUID_DEVCLASS_VOLUME
};

CONST GUID *DeviceInterfacesToClean[5] = {
    &DiskClassGuid,
    &PartitionClassGuid,
    &WriteOnceDiskClassGuid,
    &VolumeClassGuid,
    &StoragePortClassGuid
};


void PERR(void);

BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    b = AllocateAndInitializeSid(&NtAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 &AdministratorsGroup
                                 );

    if (b) {

        if (!CheckTokenMembership(NULL,
                                  AdministratorsGroup,
                                  &b
                                  )) {
            b = FALSE;
        }

        FreeSid(AdministratorsGroup);
    }

    return (b);
}

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    HDEVINFO DeviceInfoSet;
    HDEVINFO InterfaceDeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    int DevicesRemoved = 0;
    int i, InterfaceIndex;
    int MemberIndex, InterfaceMemberIndex;
    BOOL bDoRemove = TRUE, bDoCompress = FALSE;
    DWORD Status, Problem;
    CONFIGRET cr;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
	TCHAR DirBuff[MAX_PATH], DirBuffX[MAX_PATH], BackupDir[MAX_PATH];
	UINT uPathLen;
	HKEY hKey;
	DWORD dwMessage;
	TOKEN_PRIVILEGES tp;
	HANDLE hToken;
	LUID luid;
	LPTSTR MachineName=NULL; // pointer to machine name
	OSVERSIONINFO osvi;
    BOOL bWindows2000 = TRUE;
	FARPROC CompressKey = NULL;
	HANDLE hModule = NULL;

    // 
    // enable backup privilege at least
    // 
	printf("SCRUBBER 1.01 Storage Device Node Cleanup\nCopyright (c) Microsoft Corp. All rights reserved.\n");

	//
    // parse parameters.
    //
    for (i = 1; i < argc; i++) {
		//
		// Check for help
		//
		if ( (lstrcmpi(argv[i], TEXT("-?")) == 0) ||
				(lstrcmpi(argv[i], TEXT("/?")) == 0) ){

			printf("\nSCRUBBER will remove phantom storage device nodes from this machine.\n\n");
			printf("Usage: scrubber [/n] [/c]\n");
			printf("\twhere /n displays but does not remove the phantom devnodes.\n");
			printf("\t  and /c will compress the registry hive even if no changes are made.\n");
			printf("\nBackup and Restore privileges are required to run this utility.\n");
			printf("A copy of the registry will saved in %%systemroot%%\\system32\\config\\system.sc0\n");
			return 0;
		}

		//
		// Check for -n which means just list the devices that
		// we will remove.
		//
		if ( (lstrcmpi(argv[i], TEXT("-n")) == 0) ||
			 (lstrcmpi(argv[i], TEXT("/n")) == 0) ) {
			bDoRemove = FALSE;
		}

		//
        // Force compress mode?
        //
		if ( (lstrcmpi(argv[i], TEXT("-c")) == 0) ||
			 (lstrcmpi(argv[i], TEXT("/c")) == 0) ){
			bDoCompress = TRUE;
		}
	}

    //
    // Only run on Windows 2000 (not XP, etc.) Initialize the OSVERSIONINFOEX structure.
    //

    //
    // Only run on Windows 2000 (version 5.0) and Windows XP/.NET server (version 5.1).
    //
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (!GetVersionEx(&osvi)) {

		fprintf(stderr, "SCRUBBER: Unable to verify Windows version, exiting...\n");
		return -1;
	}

	if ( (osvi.dwMajorVersion == 5) && (osvi.dwMinorVersion == 0) ) {
        bWindows2000 = TRUE;
    }
	else if ((osvi.dwMajorVersion == 5) && 
              ((osvi.dwMinorVersion == 1) || (osvi.dwMinorVersion == 2))) {
        bWindows2000 = FALSE;
		hModule = LoadLibrary(TEXT("ntdll.dll"));
		CompressKey = GetProcAddress(hModule, TEXT("NtCompressKey"));
    }
    else
	{
		fprintf(stderr, "SCRUBBER: This utility is only designed to run on Windows 2000/XP/.NET server\n");
		return -1;
	}

    //
    // The process must have admin credentials.
    //
    if (!IsUserAdmin()) {
		fprintf(stderr, "SCRUBBER: You must be an administrator to run this utility.\n");
		return -1;
    }

    //
	// see if we can do the task, need backup privelege.
    //
    if(!OpenProcessToken(GetCurrentProcess(),
                        TOKEN_ADJUST_PRIVILEGES,
                        &hToken )) {

		fprintf(stderr, "SCRUBBER: Unable to obtain process token.\nCheck privileges.\n");
        return -1;
    }

    if(!LookupPrivilegeValue(MachineName, SE_BACKUP_NAME, &luid)) {

		fprintf(stderr, "SCRUBBER: Backup Privilege is required to save the registry.\n"
			"Please rerun from a privileged account\n");
        return -1;
    }

    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),
                                NULL, NULL )) {

		fprintf(stderr, "SCRUBBER: Unable to set Backup Privilege.\n");
        return -1;
    }

    //
	// Backup the file if we aren't doing a dry run
    //
	if ( bDoCompress || bDoRemove)
	{
		if(!LookupPrivilegeValue(MachineName, SE_RESTORE_NAME, &luid))

		if(!LookupPrivilegeValue(MachineName, SE_RESTORE_NAME, &luid)) {

			fprintf(stderr, "SCRUBBER: Restore Privilege is required to make changes to the registry.\n"
				"Please rerun from a privileged account\n");
			return -1;
		}

		tp.Privileges[0].Luid       = luid;

		AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),
									NULL, NULL );

		if (GetLastError() != ERROR_SUCCESS) {

			fprintf(stderr, "SCRUBBER: Unable to set Restore Privilege.\n");
			return -1;
		}


		if (RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("System"), &hKey) == ERROR_SUCCESS) {

			uPathLen = GetSystemDirectory(DirBuffX, SIZECHARS(DirBuffX));
			if (uPathLen < SIZECHARS(DirBuffX) - strlen(TEXT("\\config\\system.scx")) - 1) {

				strcat(DirBuffX, TEXT("\\config\\system.scx"));

				dwMessage = RegSaveKey(hKey, DirBuffX, NULL);

				if (dwMessage == ERROR_ALREADY_EXISTS) {

					DeleteFile(DirBuffX);
					dwMessage = RegSaveKey(hKey, DirBuffX, NULL);
				}

				RegCloseKey(hKey);

				if (dwMessage != ERROR_SUCCESS) {

					fprintf(stderr, "Unable to save a backup copy of the system hive.\n"
						"No changes have been made.\n\n");
					return -1;
				}
			}
		}
	}

    for (i=0; (i<sizeof(ClassesToClean)) && (bDoRemove || !bDoCompress); i++) {

        DeviceInfoSet = SetupDiGetClassDevs(ClassesToClean[i],
                                            NULL,
                                            NULL,
                                            0
                                            );

        if (DeviceInfoSet != INVALID_HANDLE_VALUE) {

            DeviceInfoData.cbSize = sizeof(DeviceInfoData);
            MemberIndex = 0;

            while (SetupDiEnumDeviceInfo(DeviceInfoSet,
                                         MemberIndex++,
                                         &DeviceInfoData
                                         )) {

                //
                // Check if this device is a Phantom
                //
                cr = CM_Get_DevNode_Status(&Status,
                                           &Problem,
                                           DeviceInfoData.DevInst,
                                           0
                                           );

                if ((cr == CR_NO_SUCH_DEVINST) ||
                    (cr == CR_NO_SUCH_VALUE)) {

                    //
                    // This is a phantom.  Now get the DeviceInstanceId so we
                    // can display this as output.
                    //
                    if (CM_Get_Device_ID(DeviceInfoData.DevInst,
                                         DeviceInstanceId,
                                         SIZECHARS(DeviceInstanceId),
                                         0) == CR_SUCCESS) {
    
        
                        if (bDoRemove) {
        
                            printf("SCRUBBER: %s will be removed.\n",
                                   DeviceInstanceId
                                   );

                            //
                            // On Windows 2000 DIF_REMOVE doesn't always clean
                            // out all of the device's interfaces for RAW
                            // devnodes. Because of this we need to manually
                            // build up a list of device interfaces that we care
                            // about that are associated with this DeviceInfoData
                            // and manually remove them.
                            //
                            if (bWindows2000) {
                                for (InterfaceIndex = 0;
                                     InterfaceIndex < sizeof(DeviceInterfacesToClean);
                                     InterfaceIndex++) {
    
                                    //
                                    // Build up a list of the interfaces for this specific
                                    // device.
                                    //
                                    InterfaceDeviceInfoSet = 
                                        SetupDiGetClassDevs(DeviceInterfacesToClean[InterfaceIndex],
                                                            DeviceInstanceId,
                                                            NULL,
                                                            DIGCF_DEVICEINTERFACE
                                                            );
    
                                    if (InterfaceDeviceInfoSet != INVALID_HANDLE_VALUE) {
    
                                        //
                                        // Enumerate through the interfaces that we just 
                                        // built up.
                                        //
                                        DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
                                        InterfaceMemberIndex = 0;
                                        while (SetupDiEnumDeviceInterfaces(InterfaceDeviceInfoSet,
                                                                           NULL,
                                                                           DeviceInterfacesToClean[InterfaceIndex],
                                                                           InterfaceMemberIndex++,
                                                                           &DeviceInterfaceData
                                                                           )) {
                                            
                                            //
                                            // Remove this Interface from the registry.
                                            //
                                            SetupDiRemoveDeviceInterface(InterfaceDeviceInfoSet,
                                                                         &DeviceInterfaceData
                                                                         );
                                        }
    
                                        //
                                        // Destroy the list of Interfaces that we built up.
                                        //
                                        SetupDiDestroyDeviceInfoList(InterfaceDeviceInfoSet);
                                    }
                                }
                            }


                            //
                            // Call DIF_REMOVE to remove the device's hardware
                            // and software registry keys.
                            //
                            if (SetupDiCallClassInstaller(DIF_REMOVE,
                                                          DeviceInfoSet,
                                                          &DeviceInfoData
                                                          )) {
                                
                                DevicesRemoved++;

                            } else {
                            
                                fprintf(stderr, "SCRUBBER: Error 0x%X removing phantom\n",
                                       GetLastError());
                            }


                        } else {
        
                            printf("SCRUBBER: %s would have been removed.\n",
                                   DeviceInstanceId
                                   );
                        }
                    }
                }
            }


            SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        }
    }
	
	//
    // Compress registry now
    //
	if (DevicesRemoved || bDoCompress) {

		uPathLen = GetSystemDirectory(DirBuff, SIZECHARS(DirBuff));
		SetLastError(0);
		if (uPathLen < SIZECHARS(DirBuff) - strlen(TEXT("\\config\\system.scn")) - 1) {
            //
			// Rename our backup copy
            //
			if (!DevicesRemoved) {

				strcat(DirBuff, TEXT("\\config\\system.scc"));
			
            } else {

				strcat(DirBuff, TEXT("\\config\\system.sc0"));
			}

			DeleteFile(DirBuff);
			if (rename(DirBuffX, DirBuff)) {

				fprintf(stderr, "SCRUBBER: Failed to rename backup file (system.scx)\n");
			
            } else {

				printf("System hive backup saved in %s\n", DirBuff);
			}
		} else {
			
            fprintf(stderr, "SCRUBBER: Path name too long. Registry not compressed.\n");
		}

		if (RegOpenKey(HKEY_LOCAL_MACHINE, "System", &hKey) == ERROR_SUCCESS)
		{
			if (bWindows2000)
			{
				// Make an additional copy now because it gets blown away on replace
				uPathLen = GetSystemDirectory(DirBuff, sizeof(DirBuff));
				strcat(DirBuff, "\\config\\system.scn");
				dwMessage = RegSaveKey(hKey, DirBuff, NULL);

				if (dwMessage == ERROR_ALREADY_EXISTS)
				{
					DeleteFile(DirBuff);
					dwMessage = RegSaveKey(hKey, DirBuff, NULL);
				}

				if (dwMessage == ERROR_SUCCESS)
				{
					if (bDoCompress) {
	                
    					TCHAR *tcPtr;
	    
	    
    					sprintf(BackupDir, DirBuff);
    					tcPtr = strstr(BackupDir, ".scn");
    					strcpy(tcPtr, ".scb");
    					if (!DeleteFile(BackupDir))
    					{
    						dwMessage = GetLastError();
    					}
	    
    					dwMessage = RegReplaceKey(hKey, NULL, DirBuff, BackupDir);
	    
    					if (dwMessage != ERROR_SUCCESS)
    						PERR();
    					else
    						printf("Saved new system hive.\n");
					}
				}
				else
				{
					PERR();
				}
			}
			else		// XP/.NET
			{
				if ((CompressKey)(hKey) == ERROR_SUCCESS)
				{
					printf("Compressed system hive.\n");
				}
				else
				{
					PERR();
				}
				FreeLibrary(hModule);
			}
			RegCloseKey(hKey);
		}
	} else {
		DeleteFile(DirBuffX);
    }
    
    return DevicesRemoved;
}

void PERR(void)
{
	LPVOID lpMsgBuf;

	FormatMessage( 
				FORMAT_MESSAGE_ALLOCATE_BUFFER | 
				FORMAT_MESSAGE_FROM_SYSTEM | 
				FORMAT_MESSAGE_IGNORE_INSERTS,
				NULL,
				GetLastError(),
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				(LPTSTR) &lpMsgBuf,
				0,
				NULL);
	
    fprintf(stderr, lpMsgBuf);
	LocalFree(lpMsgBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pnpreg\pnpreg.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpreg.c

Abstract:

    This module contains code to performs "locking" and "unlocking" of the Plug
    and Play "Enum" branch in the registry.  It is for development purposes
    only.

    The tool "locks" the Enum branch by granting Full Control of the Enum key
    and all subkeys to LocalSystem only.  All others are granted Read access,
    except for the "Device Parameters" subkeys of each instance key, to which
    Admins are always granted Full Control.  This is the default security
    configuration on the Enum branch.

    The tool "unlocks" the Enum branch by granting Full Control to
    Administrators and LocalSystem to all subkeys.  Effectively, all Enum
    subkeys have the same permissions as the "Device Parameters" key.  This mode
    lowers the barrier for users to make changes to the registry directly,
    rather than by the Plug and Play manager.  This configuration level should
    not be maintained on a running system for any length of time.

Author:

    Robert B. Nelson (robertn) 10-Feb-1998

Revision History:

    10-Feb-1998     Robert B. Nelson (robertn)

        Creation and initial implementation.

    17-Apr-2002     James G. Cavalaris (jamesca)

        Modified ACLs to reflect current Enum branch permissions.

--*/

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <aclapi.h>
#include <regstr.h>
#include <strsafe.h>


PSID                g_pWorldSid;
PSID                g_pAdminSid;
PSID                g_pSystemSid;

SECURITY_DESCRIPTOR g_DeviceParametersSD;
PACL                g_pDeviceParametersDacl;

SECURITY_DESCRIPTOR g_LockedPrivateKeysSD;
PACL                g_pLockedPrivateKeysDacl;


#if DBG || UMODETEST
#define DBGF_ERRORS                 0x00000001
#define DBGF_WARNINGS               0x00000002

#define DBGF_REGISTRY               0x00000010

void    RegFixDebugMessage(LPTSTR format, ...);
#define DBGTRACE(l, x)  (g_RegFixDebugFlag & (l) ? RegFixDebugMessage x : (void)0)

DWORD   g_RegFixDebugFlag = DBGF_WARNINGS | DBGF_ERRORS;

TCHAR   g_szCurrentKeyName[4096];
DWORD   g_dwCurrentKeyNameLength = 0;

#else
#define DBGTRACE(l, x)
#endif



VOID
FreeSecurityDescriptors(
    VOID
    )

/*++

Routine Description:

    This function deallocates the data structures allocated and initialized by
    CreateDeviceParametersSD.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_pDeviceParametersDacl != NULL) {
        LocalFree(g_pDeviceParametersDacl);
        g_pDeviceParametersDacl = NULL;
    }

    if (g_pLockedPrivateKeysDacl != NULL) {
        LocalFree(g_pLockedPrivateKeysDacl);
        g_pLockedPrivateKeysDacl = NULL;
    }

    if (g_pAdminSid != NULL) {
        FreeSid(g_pAdminSid);
        g_pAdminSid = NULL;
    }

    if (g_pWorldSid != NULL) {
        FreeSid(g_pWorldSid);
        g_pWorldSid = NULL;
    }

    if (g_pSystemSid != NULL) {
        FreeSid(g_pSystemSid);
        g_pSystemSid = NULL;
    }

    return;

} // FreeSecurityDescriptors



BOOL
CreateSecurityDescriptors(
    VOID
    )

/*++

Routine Description:

    This function creates a properly initialized Security Descriptor for the
    Device Parameters key and its subkeys.  The SIDs and DACL created by this
    routine must be freed by calling FreeDeviceParametersSD.

Arguments:

    None.

Return Value:

    Returns TRUE if all required security descriptors were successfully created,
    otherwise returns FALSE.

--*/

{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    EXPLICIT_ACCESS             ExplicitAccess[3];

    DWORD                       dwError;
    BOOL                        bSuccess;

    DWORD                       i;

    //
    // Create SIDs - Admins and System
    //

    bSuccess =             AllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &g_pAdminSid);

    bSuccess = bSuccess && AllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &g_pSystemSid);

    bSuccess = bSuccess && AllocateAndInitializeSid( &WorldAuthority,
                                                     1,
                                                     SECURITY_WORLD_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &g_pWorldSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  World  Read
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //

        for (i = 0; i < 3; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;
            ExplicitAccess[i].grfInheritance = CONTAINER_INHERIT_ACE;
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }

        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)g_pSystemSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_READ;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)g_pWorldSid;

        ExplicitAccess[2].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[2].Trustee.ptstrName = (LPTSTR)g_pAdminSid;

        //
        // Create the DACL with all of the above ACEs for the DeviceParameters
        //
        dwError = SetEntriesInAcl( 3,
                                   ExplicitAccess,
                                   NULL,
                                   &g_pDeviceParametersDacl );

        if (dwError == ERROR_SUCCESS) {
            //
            // Create the DACL with just the system and world ACEs for the
            // locked private keys.
            //
            dwError = SetEntriesInAcl( 2,
                                       ExplicitAccess,
                                       NULL,
                                       &g_pLockedPrivateKeysDacl );
        }

        bSuccess = dwError == ERROR_SUCCESS;
    }

    //
    // Initialize the DeviceParameters security descriptor
    //
    bSuccess = bSuccess && InitializeSecurityDescriptor( &g_DeviceParametersSD,
                                                         SECURITY_DESCRIPTOR_REVISION );

    //
    // Set the new DACL in the security descriptor
    //
    bSuccess = bSuccess && SetSecurityDescriptorDacl( &g_DeviceParametersSD,
                                                      TRUE,
                                                      g_pDeviceParametersDacl,
                                                      FALSE);

    //
    // validate the new security descriptor
    //
    bSuccess = bSuccess && IsValidSecurityDescriptor( &g_DeviceParametersSD );


    //
    // Initialize the DeviceParameters security descriptor
    //
    bSuccess = bSuccess && InitializeSecurityDescriptor( &g_LockedPrivateKeysSD,
                                                         SECURITY_DESCRIPTOR_REVISION );

    //
    // Set the new DACL in the security descriptor
    //
    bSuccess = bSuccess && SetSecurityDescriptorDacl( &g_LockedPrivateKeysSD,
                                                      TRUE,
                                                      g_pLockedPrivateKeysDacl,
                                                      FALSE);

    //
    // validate the new security descriptor
    //
    bSuccess = bSuccess && IsValidSecurityDescriptor( &g_LockedPrivateKeysSD );


    if (!bSuccess) {
        FreeSecurityDescriptors();
    }

    return bSuccess;

} // CreateSecurityDescriptors



VOID
EnumKeysAndApplyDacls(
    IN HKEY                 hParentKey,
    IN LPTSTR               pszKeyName,
    IN DWORD                dwLevel,
    IN BOOL                 bInDeviceParameters,
    IN BOOL                 bApplyTopDown,
    IN PSECURITY_DESCRIPTOR pPrivateKeySD,
    IN PSECURITY_DESCRIPTOR pDeviceParametersSD
    )

/*++

Routine Description:

    This function applies the DACL in pSD to all the keys rooted at hKey
    including hKey itself.

Arguments:

    hParentKey      Handle to a registry key.
    pszKeyName      Name of the key.
    dwLevel         Number of levels remaining to recurse.
    pSD             Pointer to a security descriptor containing a DACL.

Return Value:

    None.


--*/

{
    LONG        RegStatus;
    DWORD       dwMaxSubKeySize;
    LPTSTR      pszSubKey;
    DWORD       index;
    HKEY        hKey;
    BOOL        bNewInDeviceParameters;

#if DBG || UMODETEST
    DWORD       dwStartKeyNameLength = g_dwCurrentKeyNameLength;

    if (g_dwCurrentKeyNameLength != 0)  {
        g_szCurrentKeyName[ g_dwCurrentKeyNameLength++ ] = TEXT('\\');
    }

    if (SUCCEEDED(StringCchCopy(
                      &g_szCurrentKeyName[g_dwCurrentKeyNameLength],
                      (sizeof(g_szCurrentKeyName) / sizeof(g_szCurrentKeyName[0])) -
                          g_dwCurrentKeyNameLength,
                      pszKeyName))) {
        g_dwCurrentKeyNameLength += (DWORD)_tcslen(pszKeyName);
    }

#endif

    DBGTRACE( DBGF_REGISTRY,
              (TEXT("EnumKeysAndApplyDacls(0x%08X, \"%s\", %d, %s, %s, 0x%08X, 0x%08X)\n"),
              hParentKey,
              g_szCurrentKeyName,
              dwLevel,
              bInDeviceParameters ? TEXT("TRUE") : TEXT("FALSE"),
              bApplyTopDown ? TEXT("TRUE") : TEXT("FALSE"),
              pPrivateKeySD,
              pDeviceParametersSD) );

    if (bApplyTopDown) {

        RegStatus = RegOpenKeyEx( hParentKey,
                                  pszKeyName,
                                  0,
                                  WRITE_DAC,
                                  &hKey
                                  );

        if (RegStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumKeysAndApplyDacls(\"%s\") RegOpenKeyEx() failed, error = %d\n"),
                      g_szCurrentKeyName, RegStatus));

            return;
        }

        DBGTRACE( DBGF_REGISTRY,
                  (TEXT("Setting security on %s on the way down\n"),
                  g_szCurrentKeyName) );

        //
        // apply the new security to the registry key
        //
        RegStatus = RegSetKeySecurity( hKey,
                                       DACL_SECURITY_INFORMATION,
                                       bInDeviceParameters ?
                                           pDeviceParametersSD :
                                           pPrivateKeySD
                                       );

        if (RegStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumKeysAndApplyDacls(\"%s\") RegSetKeySecurity() failed, error = %d\n"),
                      g_szCurrentKeyName, RegStatus));
        }

        //
        // Close the key and reopen it later for read (which hopefully was just
        // granted in the DACL we just wrote
        //
        RegCloseKey( hKey );
    }

    RegStatus = RegOpenKeyEx( hParentKey,
                              pszKeyName,
                              0,
                              KEY_READ | WRITE_DAC,
                              &hKey
                              );

    if (RegStatus != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumKeysAndApplyDacls(\"%s\") RegOpenKeyEx() failed, error = %d\n"),
                  g_szCurrentKeyName, RegStatus));

        return;
    }

    //
    // Determine length of longest subkey
    //
    RegStatus = RegQueryInfoKey( hKey,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwMaxSubKeySize,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL );

    if (RegStatus == ERROR_SUCCESS) {

        //
        // Allocate a buffer to hold the subkey names. RegQueryInfoKey returns the
        // size in characters and doesn't include the NUL terminator.
        //
        pszSubKey = LocalAlloc(0, ++dwMaxSubKeySize * sizeof(TCHAR));

        if (pszSubKey != NULL) {

            //
            // Enumerate all the subkeys and then call ourselves recursively for each
            // until dwLevel reaches 0.
            //

            for (index = 0; ; index++) {

                RegStatus = RegEnumKey( hKey,
                                        index,
                                        pszSubKey,
                                        dwMaxSubKeySize
                                        );

                if (RegStatus != ERROR_SUCCESS) {

                    if (RegStatus != ERROR_NO_MORE_ITEMS) {

                        DBGTRACE( DBGF_ERRORS,
                                  (TEXT("EnumKeysAndApplyDacls(\"%s\") RegEnumKeyEx() failed, error = %d\n"),
                                  g_szCurrentKeyName,
                                  RegStatus) );
                    }

                    break;
                }

                bNewInDeviceParameters = bInDeviceParameters ||
                                         (dwLevel == 3 &&
                                            _tcsicmp( pszSubKey,
                                                      REGSTR_KEY_DEVICEPARAMETERS ) == 0);

                EnumKeysAndApplyDacls( hKey,
                                       pszSubKey,
                                       dwLevel + 1,
                                       bNewInDeviceParameters,
                                       bApplyTopDown,
                                       pPrivateKeySD,
                                       pDeviceParametersSD
                                       );
            }

            LocalFree( pszSubKey );
        }
    }
    else
    {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumKeysAndApplyDacls(\"%s\") RegQueryInfoKey() failed, error = %d\n"),
                  g_szCurrentKeyName, RegStatus));
    }

    if (!bApplyTopDown) {

        DBGTRACE( DBGF_REGISTRY,
                  (TEXT("Setting security on %s on the way back up\n"),
                  g_szCurrentKeyName) );

        //
        // apply the new security to the registry key
        //
        RegStatus = RegSetKeySecurity( hKey,
                                       DACL_SECURITY_INFORMATION,
                                       bInDeviceParameters ?
                                           pDeviceParametersSD :
                                           pPrivateKeySD
                                       );

        if (RegStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumKeysAndApplyDacls(\"%s\") RegSetKeySecurity() failed, error = %d\n"),
                      g_szCurrentKeyName, RegStatus));
        }
    }

    RegCloseKey( hKey );

#if DBG || UMODETEST
    g_dwCurrentKeyNameLength = dwStartKeyNameLength;
    g_szCurrentKeyName[g_dwCurrentKeyNameLength] = TEXT('\0');
#endif

    return;

} // EnumKeysAndApplyDacls



VOID
LockUnlockEnumTree(
    LPTSTR  pszMachineName,
    BOOL    bLock
    )
{
    HKEY                    hParentKey = NULL;
    LONG                    RegStatus;

    if (pszMachineName != NULL) {

        RegStatus = RegConnectRegistry( pszMachineName,
                                        HKEY_LOCAL_MACHINE,
                                        &hParentKey );

        if (RegStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("Could not connect to remote registry on %s, status = %d\n"),
                      pszMachineName,
                      RegStatus) );
            return;
        }

    } else {

        hParentKey = HKEY_LOCAL_MACHINE;
    }

    if (CreateSecurityDescriptors()) {

        EnumKeysAndApplyDacls( hParentKey,
                               REGSTR_PATH_SYSTEMENUM,
                               0,
                               FALSE,
                               !bLock,
                               bLock ? &g_LockedPrivateKeysSD : &g_DeviceParametersSD,
                               &g_DeviceParametersSD
                               );

        FreeSecurityDescriptors();
    }

    if (pszMachineName != NULL) {
        RegCloseKey(hParentKey);
    }

    return;

} // LockUnlockEnumTree



#if DBG || UMODETEST
void
RegFixDebugMessage(
    LPTSTR format,
    ...
    )
{
    va_list args;

    va_start(args, format);

    _vtprintf(format, args);

    return;

} // RegFixDebugMessage
#endif



#if UMODETEST
void
usage(int argc, TCHAR **argv)
{
    PTCHAR  pszProgram;

    UNREFERENCED_PARAMETER(argc);

    if ((pszProgram = _tcsrchr(argv[0], TEXT('\\'))) != NULL) {
        pszProgram++;
    } else {
        pszProgram = argv[0];
    }

    _tprintf(TEXT("%s: Lock or Unlock PnP Registry (Enum key)\n\n"), pszProgram);
    _tprintf(TEXT("Usage: %s [-m <machine>] -l | -u\n"), pszProgram);
    _tprintf(TEXT("    -m <machine>    Remote machine without leading \\\\\n"));
    _tprintf(TEXT("    -l              Locks Enum key\n"));
    _tprintf(TEXT("    -u              Unlocks Enum key\n\n"));
    _tprintf(TEXT("Note: -m is optional.  Only one of -l or -u may be used.\n"));
    return;
}

int __cdecl
_tmain(int argc, TCHAR **argv)
{
    LPTSTR      pszMachineName = NULL;
    LPTSTR      pszArg;
    int         idxArg;

    if ( argc == 1 )
    {
        usage(argc, argv);
        return 0;
    }

    for (idxArg = 1; idxArg < argc; idxArg++)
    {
        pszArg = argv[ idxArg ];

        if (*pszArg == '/' || *pszArg == '-')
        {
            pszArg++;

            while (pszArg != NULL && *pszArg != '\0') {

                switch (*pszArg)
                {
                case '/':   // Ignore these, caused by cmds like /m/l
                    pszArg++;
                    break;

                case 'l':
                case 'L':
                    pszArg++;
                    LockUnlockEnumTree( pszMachineName, TRUE );
                    break;

                case 'm':
                case 'M':
                    pszArg++;

                    if (*pszArg == ':' || *pszArg == '=')
                    {
                        if (pszArg[ 1 ] != '\0')
                        {
                            pszMachineName = ++pszArg;
                        }
                    }
                    else if (*pszArg != '\0')
                    {
                        pszMachineName = pszArg;
                    }
                    else if ((idxArg + 1) < argc && (argv[ idxArg + 1 ][0] != '/' && argv[ idxArg + 1 ][0] != '-'))
                    {
                        pszMachineName = argv[ ++idxArg ];
                    }

                    if (pszMachineName == NULL)
                    {
                        _tprintf(
                            TEXT("%c%c : missing machine name argument\n"),
                            argv[ idxArg ][ 0 ], pszArg [ - 1 ]
                            );

                        usage(argc, argv);

                        return 1;
                    }
                    pszArg = NULL;
                    break;

                case 'u':
                case 'U':
                    pszArg++;

                    LockUnlockEnumTree( pszMachineName, FALSE );
                    break;

                case 'v':
                case 'V':
                    pszArg++;

                    g_RegFixDebugFlag |= DBGF_REGISTRY;
                    break;

                default:
                    _tprintf(
                        TEXT("%c%c : invalid option\n"),
                        argv[ idxArg ][ 0 ], *pszArg
                        );
                    pszArg++;
                    break;
                }
            }
        }
    }

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\osver.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    osver.c

Abstract:

    This module contains utility routines for identifying different NT product
    version types, suites, and feature attributes.

Author:

    Jim Cavalaris (jamesca) 03-07-2001

Environment:

    User-mode only.

Revision History:

    07-March-2001     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"


//
// global data
//

const TCHAR RegWinlogonKeyName[] =
      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");

const TCHAR RegAllowMultipleTSSessionsValueName[] =
      TEXT("AllowMultipleTSSessions");




BOOL
IsEmbeddedNT(
    VOID
    )
/*++

Routine Description:

    Check if this is Embedded product suite of NT.

Arguments:

    None.

Return Value:

    Return TRUE / FALSE.

--*/
{
    static BOOL bVerified = FALSE;
    static BOOL bIsEmbeddedNT = FALSE;

    if (!bVerified) {
        OSVERSIONINFOEX osvix;
        DWORDLONG dwlConditionMask = 0;

        ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
        osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osvix.wSuiteMask = VER_SUITE_EMBEDDEDNT;
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        if (VerifyVersionInfo(&osvix,
                              VER_SUITENAME,
                              dwlConditionMask)) {
            bIsEmbeddedNT = TRUE;
        }

        bVerified = TRUE;
    }

    return bIsEmbeddedNT;

} // IsEmbeddedNT



BOOL
IsTerminalServer(
    VOID
    )
/*++

Routine Description:

    Check if Terminal Services are available on this version of NT.

Arguments:

    None.

Return Value:

    Return TRUE / FALSE.

--*/
{
    static BOOL bVerified = FALSE;
    static BOOL bIsTerminalServer = FALSE;

    if (!bVerified) {
        OSVERSIONINFOEX osvix;
        DWORDLONG dwlConditionMask = 0;

        ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
        osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osvix.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        if (VerifyVersionInfo(&osvix, VER_SUITENAME, dwlConditionMask)) {
            bIsTerminalServer = TRUE;
        }

        bVerified = TRUE;
    }

    return bIsTerminalServer;

} // IsTerminalServer



BOOL
IsFastUserSwitchingEnabled(
    VOID
    )
/*++

Routine Description:

    Checks to see if Terminal Services Fast User Switching is enabled.  This is
    to check if we should use the physical console session for UI dialogs, or
    always use session 0.

    Fast User Switching exists only on workstation product version, where terminal
    services are available, when AllowMultipleTSSessions is set.

    On server and above, or when multiple TS users are not allowed, session 0
    can only be attached remotely be special request, in which case it should be
    considered the "Console" session.

Arguments:

    None.

Return Value:

    Returns TRUE if Fast User Switching is currently enabled, FALSE otherwise.

--*/
{
    static BOOL bVerified = FALSE;
    static BOOL bIsTSWorkstation = FALSE;

    HKEY   hKey;
    ULONG  ulSize, ulValue;
    BOOL   bFusEnabled;

    //
    // Verify the product version if we haven't already.
    //
    if (!bVerified) {
        OSVERSIONINFOEX osvix;
        DWORDLONG dwlConditionMask = 0;

        ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
        osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        osvix.wProductType = VER_NT_WORKSTATION;
        VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

        osvix.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        if (VerifyVersionInfo(&osvix,
                              VER_PRODUCT_TYPE | VER_SUITENAME,
                              dwlConditionMask)) {
            bIsTSWorkstation = TRUE;
        }

        bVerified = TRUE;
    }

    //
    // Fast user switching (FUS) only applies to the Workstation product where
    // Terminal Services are enabled (i.e. Personal, Professional).
    //
    if (!bIsTSWorkstation) {
        return FALSE;
    }

    //
    // Check if multiple TS sessions are currently allowed.  We can't make this
    // info static because it can change dynamically.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     RegWinlogonKeyName,
                     0,
                     KEY_READ,
                     &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    ulValue = 0;
    ulSize = sizeof(ulValue);
    bFusEnabled = FALSE;

    if (RegQueryValueEx(hKey,
                        RegAllowMultipleTSSessionsValueName,
                        NULL,
                        NULL,
                        (LPBYTE)&ulValue,
                        &ulSize) == ERROR_SUCCESS) {
        bFusEnabled = (ulValue != 0);
    }
    RegCloseKey(hKey);

    return bFusEnabled;

} // IsFastUserSwitchingEnabled




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\main.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    main.c

Abstract:

    This module contains the startup and termination code for the
    User-mode Plug-and-Play service.

Author:

    Paula Tomlinson (paulat) 6-20-1995

Environment:

    User mode only.

Revision History:

    3-Mar-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"


//
// global data
//
HANDLE  ghPnPHeap;                  // Private heap for PNP Manager
HANDLE  ghInst;                     // Module handle
HKEY    ghEnumKey = NULL;           // Key to HKLM\System\CCC\Enum
HKEY    ghServicesKey = NULL;       // Key to HKLM\System\CCC\Services
HKEY    ghClassKey = NULL;          // key to HKLM\System\CCC\Class
HKEY    ghPerHwIdKey = NULL;        // key to HKLM\Software\Microsoft\Windows NT\CurrentVersion\PerHwIdStorage

CRITICAL_SECTION PnpSynchronousCall;



BOOL
DllMainCRTStartup(
   PVOID hModule,
   ULONG Reason,
   PCONTEXT pContext
   )

/*++

Routine Description:

   This is the standard DLL entrypoint routine, called whenever a process
   or thread attaches or detaches.
   Arguments:

   hModule -   PVOID parameter that specifies the handle of the DLL

   Reason -    ULONG parameter that specifies the reason this entrypoint
               was called (either PROCESS_ATTACH, PROCESS_DETACH,
               THREAD_ATTACH, or THREAD_DETACH).

   pContext -  Reserved, not used.

Return value:

   Returns true if initialization compeleted successfully, false is not.

--*/

{
    UNREFERENCED_PARAMETER(pContext);

    ghInst = (HANDLE)hModule;

    switch (Reason) {

    case DLL_PROCESS_ATTACH:

        ghPnPHeap = HeapCreate(0, 65536, 0);

        if (ghPnPHeap == NULL) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: Failed to create heap, error = %d\n",
                       GetLastError()));

            ghPnPHeap = GetProcessHeap();
        }

        try {
            InitializeCriticalSection(&PnpSynchronousCall);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // InitializeCriticalSection may raise STATUS_NO_MEMORY exception
            //
            return FALSE;
        }

        if (ghEnumKey == NULL) {

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegPathEnum, 0,
                                KEY_ALL_ACCESS, &ghEnumKey)
                                != ERROR_SUCCESS) {
                //
                // The Enum key must exist by the time the service controller
                // loads this DLL into it's process.  It is created by the
                // kernel-mode plug and play manager, with special
                // (non-inherited) ACLs applied.  It is not valid to attempt and
                // create it here if it does not exist.
                //
                ghEnumKey = NULL;
            }
        }

        if (ghServicesKey == NULL) {

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegPathServices, 0,
                                KEY_ALL_ACCESS, &ghServicesKey)
                                != ERROR_SUCCESS) {
                ghServicesKey = NULL;
            }
        }

        if (ghClassKey == NULL) {

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegPathClass, 0,
                                KEY_ALL_ACCESS, &ghClassKey)
                                != ERROR_SUCCESS) {
                ghClassKey = NULL;
            }
        }

        if(ghPerHwIdKey == NULL) {

            if(ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                               pszRegPathPerHwIdStorage,
                                               0, 
                                               NULL, 
                                               REG_OPTION_NON_VOLATILE,
                                               KEY_ALL_ACCESS, 
                                               NULL, 
                                               &ghPerHwIdKey,
                                               NULL)) {
                ghPerHwIdKey = NULL;
            }
        }

        //
        // Initialize notification lists.
        //

        if (!InitNotification()) {
            return FALSE;
        }
        break;

    case DLL_PROCESS_DETACH:

        if (ghEnumKey != NULL) {
            RegCloseKey(ghEnumKey);
            ghEnumKey = NULL;
        }

        if (ghServicesKey != NULL) {
            RegCloseKey(ghServicesKey);
            ghServicesKey = NULL;
        }

        if (ghClassKey != NULL) {
            RegCloseKey(ghClassKey);
            ghClassKey = NULL;
        }

        if (ghPerHwIdKey != NULL) {
            RegCloseKey(ghPerHwIdKey);
            ghPerHwIdKey = NULL;
        }

        try {
            DeleteCriticalSection(&PnpSynchronousCall);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }

        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;

} // DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\pcisim\softpci\sys\utils.h ===
//
// prototypes for Utils.c
//

BOOLEAN
SoftPCIOpenKey(
    IN PWSTR KeyName,
    IN HANDLE ParentHandle,
    OUT PHANDLE Handle,
    OUT PNTSTATUS Status
    );

NTSTATUS
SoftPCIGetRegistryValue(
    IN PWSTR ValueName,
    IN PWSTR KeyName,
    IN HANDLE ParentHandle,
    OUT PVOID *Buffer,
    OUT ULONG *Length
    );


VOID
SoftPCIInsertEntryAtTail(
    IN PSINGLE_LIST_ENTRY Entry
    );

NTSTATUS
SoftPCIProcessRootBus(
    IN PCM_RESOURCE_LIST ResList
    );

NTSTATUS
SoftPCIEnumRegistryDevs(
    IN PWSTR KeyName, 
    IN PHANDLE ParentHandle,
    IN PSOFTPCI_DEVICE ParentDevice
    );

NTSTATUS
SoftPCIQueryDeviceObjectType(
    IN PDEVICE_OBJECT PhysicalDeviceObject, 
    IN PBOOLEAN IsFilterDO
    );

VOID
SoftPCIEnumerateTree(
    VOID
    );


BOOLEAN
SoftPCIGetResourceValueFromRegistry(
    OUT PULONG MemRangeStart,
    OUT PULONG MemRangeLength,
    OUT PULONG IoRangeStart,
    OUT PULONG IoRangeLength
    );

VOID
SoftPCISimulateMSI(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\tools\wmiinst\wmiinst.c ===
/*++
    
    Microsoft Windows
    Copyright (c) Microsoft Corporation.  All rights reserved.

    File:       WMIInst.C

    Contents:   co-installer hook to setup security on wmi guids

                The assumption is that the INF is setup to have an install
                section decorated with a "WMI" keyword.  Then there should
                be a section defining a WMIInterface that has 3 fields: a 
                GUID, flags, and WMIInterfaceSection.  
                WMIINterface = <GUID>, flags, <SectionName>
                A security field should then be defined under that 
                SectionName, that contains the SDDL need to setup WMI 
                security.  
                [WMIInterfaceSectionName]
                    security = <SDDL>                  
  
                This example shows both a way to install INF's for a
                multi-function device for Windows 2000, and also how
                to add to the INF syntax for other purposes.

    Notes:      For a complete description of CoInstallers, please see the
                   Microsoft Windows 2000 DDK Documentation

@@BEGIN_DDKSPLIT
    
    Author:     AlanWar 03/29/02
    Revision History:

@@END_DDKSPLIT

--*/

#include <windows.h>
#include <setupapi.h>
#include <stdio.h>
#include <malloc.h>
#include <sddl.h>
#include <aclapi.h>
#include <strsafe.h>

#define AllocMemory malloc
#define FreeMemory free

DWORD
__inline
pSetupGetLastError(
    VOID
    )
/*++

Routine Description:

    This inline routine retrieves a Win32 error, and guarantees that the error
    isn't NO_ERROR.  This routine should not be called unless the preceding
    call failed, and GetLastError() is supposed to contain the problem's cause.

Arguments:

    None.

Return Value:

    Win32 error code retrieved via GetLastError(), or ERROR_UNIDENTIFIED_ERROR
    if GetLastError() returned NO_ERROR.

--*/
{
    DWORD Err = GetLastError();

    return ((Err == NO_ERROR) ? ERROR_INVALID_DATA : Err);
}


//
// Macro to simplify calling of a function that reports error status via
// GetLastError().  This macro allows the caller to specify what Win32 error
// code should be returned if the function reports success.  (If the default of
// NO_ERROR is desired, use the GLE_FN_CALL macro instead.)
//
// The "prototype" of this macro is as follows:
//
// DWORD
// GLE_FN_CALL_WITH_SUCCESS(
//     SuccessfulStatus, // Win32 error code to return if function succeeded
//     FailureIndicator, // value returned by function to indicate failure (e.g., FALSE, NULL, INVALID_HANDLE_VALUE)
//     FunctionCall      // actual call to the function
// );
//

#define GLE_FN_CALL_WITH_SUCCESS(SuccessfulStatus,      \
                                 FailureIndicator,      \
                                 FunctionCall)          \
                                                        \
            (SetLastError(NO_ERROR),                    \
             (((FunctionCall) != (FailureIndicator))    \
                 ? (SuccessfulStatus)                   \
                 : pSetupGetLastError()))

//
// Macro to simplify calling of a function that reports error status via
// GetLastError().  If the function call is successful, NO_ERROR is returned.
// (To specify an alternate value returned upon success, use the
// GLE_FN_CALL_WITH_SUCCESS macro instead.)
//
// The "prototype" of this macro is as follows:
//
// DWORD
// GLE_FN_CALL(
//     FailureIndicator, // value returned by function to indicate failure (e.g., FALSE, NULL, INVALID_HANDLE_VALUE)
//     FunctionCall      // actual call to the function
// );
//

#define GLE_FN_CALL(FailureIndicator, FunctionCall)                           \
            GLE_FN_CALL_WITH_SUCCESS(NO_ERROR, FailureIndicator, FunctionCall)



//
// ** Function Prototypes **
//

ULONG 
ParseSection(
    IN     INFCONTEXT  InfLineContext,
    IN OUT PTCHAR     *GuidString,
    IN OUT ULONG      *GuidStringLen,
       OUT PDWORD      Flags,
    IN OUT PTCHAR     *SectionNameString,
    IN OUT ULONG      *SectionNameStringLen
    );

ULONG 
EstablishGuidSecurity(
    IN PTCHAR GuidString,
    IN PTCHAR SDDLString,
    IN DWORD  Flags
    );


ULONG
GetSecurityKeyword(
    IN     HINF     InfFile,
    IN     LPCTSTR  WMIINterfaceSection,
    IN OUT PTCHAR  *SDDLString,
    IN OUT ULONG   *SDDLStringLen
    );

ULONG 
ParseSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR   SD,
    OUT PSECURITY_INFORMATION  SecurityInformation,
    OUT PSID                  *Owner,
    OUT PSID                  *Group,
    OUT PACL                  *Dacl,
    OUT PACL                  *Sacl
    );


//+-----------------------------------------------------------------------------
//
// WARNING!
//
// A Coinstaller must not generate any popup to the user when called with
// DI_QUIETINSTALL. However, it's generally never a good idea to generate
// popups.
//
// OutputDebugString is a fine way to output information for debugging
//
#if DBG
VOID
DebugPrintX(
           PCHAR DebugMessage,
           ...
           );

    #define DbgOut(x) DebugPrintX x
    #define DEBUG_BUFFER_LENGTH 1024
#else
    #define DbgOut(Text)
#endif

//
// these are keywords introduced by this co-installer
// note that the names are not case sensitive
//
#define WMI_KEY TEXT(".WMI")
#define WMIINTERFACE_KEY TEXT("WmiInterface")
#define WMIGUIDSECURITYSECTION_KEY TEXT("security")

#define MAX_GUID_STRING_LEN   39          // 38 chars + terminator null



DWORD
ProcessWMIInstallation(
    IN     HINF    InfFile,
    IN     LPCTSTR CompSectionName
    )
/*++

Routine Description:

    Process all WmiInterface lines from the WMI install sections, by parsing  
    the directives to obatins the GUID and SDDL strings.  For each corresponding 
    SDDL for GUID, then establish the appropriate security descriptors.

Arguments:

    InfFile - handle to INF file
    CompSectionName - name of the WMI install section

Return Value:

    Status, normally NO_ERROR

--*/ 
{
    PTCHAR     GuidString, SDDLString, SectionNameString;
    ULONG      GuidStringLen, SDDLStringLen, SectionNameStringLen;
    DWORD      Flags;
    INFCONTEXT InfLineContext;
    DWORD      Status;

    Status = NO_ERROR;

    //
    // we look for keyword "WmiInterface" in the CompSectionName section
    //
    GuidString = NULL;
    GuidStringLen = 0;
    SectionNameString = NULL;
    SectionNameStringLen = 0;
    SDDLString = NULL;
    SDDLStringLen = 0;
    Flags = 0;

    if(SetupFindFirstLine(InfFile,
                          CompSectionName,
                          WMIINTERFACE_KEY,
                          &InfLineContext)) {
       
        do {
            //
            // WMIInterface = GUID, flags, SectionName
            // The GIUD should be at index 1, flags at index 2, and section
            // name at index 3
            //
            Status = ParseSection(InfLineContext,
                                  &GuidString,
                                  &GuidStringLen,
                                  &Flags,
                                  &SectionNameString,
                                  &SectionNameStringLen
                                  );

            if(Status != NO_ERROR) {
                break;
            }

            //
            // Get SDDL string from the section specified by the interface
            //
            Status = GetSecurityKeyword(InfFile,
                                        SectionNameString,
                                        &SDDLString,
                                        &SDDLStringLen
                                        );
            if(Status != NO_ERROR) {  
                break;
            }
                
            Status = EstablishGuidSecurity(GuidString, SDDLString, Flags);

            if(Status != NO_ERROR) {  
                break;
            }

                       
        } while(SetupFindNextMatchLine(&InfLineContext,
                                       WMIINTERFACE_KEY,
                                       &InfLineContext));

        //
        // Cleanup any strings allocated
        //
        if(GuidString != NULL) {
            FreeMemory(GuidString);         
        }
                
        if(SectionNameString != NULL) {
           FreeMemory(SectionNameString);         
        }

        if(SDDLString != NULL) {
            FreeMemory(SDDLString);
        }
    }

    return Status;
}



DWORD
PreProcessInstallDevice (
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
/*++

    Function:   
    
        PreProcessInstallDevice

    Purpose:    
        
        Handle DIF_INSTALLDEVICE PostProcessing 
        Opens the INF file, locates the install section with the decoration
        ".WMI" (as defined by WMI_KEY above).  Then performs the WMI installation.

    Arguments:
    
        DeviceInfoSet     [in]
        DeviceInfoData    [in]
        Context           [in,out]

    Returns:    
    
        NO_ERROR or an error code.
    
--*/
{
    DWORD Status = NO_ERROR;
    DWORD FinalStatus;
    HINF InfFile = INVALID_HANDLE_VALUE;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    TCHAR InstallSectionName[255];  //MAX_SECT_NAME_LEN
    TCHAR CompSectionName[255];     //MAX_SECT_NAME_LEN

    INFCONTEXT CompLine;
    DWORD FieldCount, FieldIndex;

    FinalStatus = NO_ERROR;

    //
    // Find name of INF and name of install section
    //

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    Status = GLE_FN_CALL(FALSE,
                         SetupDiGetSelectedDriver(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  &DriverInfoData)
                        );
    if(Status != NO_ERROR) {
        DbgOut(("Fail: SetupDiGetSelectedDriver %d\n", Status));
        goto clean;
    }

    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    Status = GLE_FN_CALL(FALSE,
                         SetupDiGetDriverInfoDetail(
                             DeviceInfoSet,
                             DeviceInfoData,
                             &DriverInfoData,
                             &DriverInfoDetailData,
                             sizeof(SP_DRVINFO_DETAIL_DATA),
                             NULL)
                        );
    if(Status != NO_ERROR) {
        if(Status == ERROR_INSUFFICIENT_BUFFER) {
            //
            // We don't need the extended information.  Ignore.
            //
        } else {
            DbgOut(("Fail: SetupDiGetDriverInfoDetail %d\n", Status));
            goto clean;
        }
    }

    //
    // We have InfFileName, open the INF
    //
    InfFile = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                               NULL,
                               INF_STYLE_WIN4,
                               NULL);
    if(InfFile == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        DbgOut(("Fail: SetupOpenInfFile %d", Status));
        goto clean;
    }

    //
    // determine section used for the install which might be different
    // from the section name specified in DriverInfoDetailData.
    //
    Status = GLE_FN_CALL(FALSE,
                        SetupDiGetActualSectionToInstall(
                            InfFile, 
                            DriverInfoDetailData.SectionName,
                            InstallSectionName,
                            (sizeof(InstallSectionName)/sizeof(InstallSectionName[0])),
                            NULL,
                            NULL)
                        );
    if(Status != NO_ERROR) {
        DbgOut(("Fail: SetupDiGetActualSectionToInstall %d\n", Status));
        goto clean;
    }

    //
    // We need to append the WMI_KEY to find the correct decorated section
    //
    if(FAILED(StringCchCat(InstallSectionName,
                          (sizeof(InstallSectionName)/sizeof(InstallSectionName[0])),
                          WMI_KEY))) {
        DbgOut(("WMICoInstaller: Fail - StringCchCat\n"));
        goto clean;
    }
     
    //
    // we have a listed section
    // 
    
    Status = ProcessWMIInstallation(InfFile,
                                    InstallSectionName);
    if(Status != NO_ERROR) { 
        FinalStatus = Status;
        goto clean;
    }
          

  clean:

    if(InfFile) {
        SetupCloseInfFile(InfFile);
    }

    //
    // since what we are doing does not affect primary device installation
    // always return success
    //
    return FinalStatus;
}

ULONG 
ParseSecurityDescriptor(
    IN  PSECURITY_DESCRIPTOR   SD,
    OUT PSECURITY_INFORMATION  SecurityInformation,
    OUT PSID                  *Owner,
    OUT PSID                  *Group,
    OUT PACL                  *Dacl,
    OUT PACL                  *Sacl
    )
/*++

    Function:   
    
        ParseSecurityDescriptor

    Purpose:    
    
        Checks information provided in the security descriptor to make sure that 
        at least the dacl, sacl, owner or group security was specified.  Otherwise
        it will return an error.        
                 
    
    Arguments:
        
        SD                  [in]    
        SecurityInformation [out]
        Owner               [out]
        Group               [out]
        Dacl                [out]
        Sacl                [out]

    Returns:    
    
        NO_ERROR or an error code.
        
--*/
{
    BOOL Ok, Present, Defaulted;

    *SecurityInformation = 0;

    *Dacl = NULL;
    *Sacl = NULL;
    *Owner = NULL;
    *Group = NULL;

    Ok = GetSecurityDescriptorOwner(SD,
                                    Owner,
                                    &Defaulted);
    if(Ok && (Owner != NULL)) {
        *SecurityInformation |= OWNER_SECURITY_INFORMATION;
    }

    Ok = GetSecurityDescriptorGroup(SD,
                                    Group,
                                    &Defaulted);
    if(Ok && (Group != NULL)) {
        *SecurityInformation |= GROUP_SECURITY_INFORMATION;
    }

    Ok = GetSecurityDescriptorDacl(SD,
                                   &Present,
                                   Dacl,
                                   &Defaulted);

    if(Ok && Present) {
        *SecurityInformation |= DACL_SECURITY_INFORMATION;
    }


    Ok = GetSecurityDescriptorSacl(SD,
                                   &Present,
                                   Sacl,
                                   &Defaulted);

    if(Ok && Present) {
        *SecurityInformation |= SACL_SECURITY_INFORMATION;
    }


    //
    // If no security info in the security descriptor then it is an
    // error
    //
    return((*SecurityInformation == 0) ?
            ERROR_INVALID_PARAMETER :
            NO_ERROR);
}

#define WMIGUIDSECURITYKEY TEXT("System\\CurrentControlSet\\Control\\Wmi\\Security")
// path should be moved to regstr.h, nt\base\published\regstr.w

ULONG 
EstablishGuidSecurity(
    IN PTCHAR GuidString,
    IN PTCHAR SDDLString,
    IN DWORD  Flags
    )
/*++

    Function:   
        
        EstablishGuidSecurity

    Purpose:    
        
        Writes security information to registry key (specified by WMIGUIDSECURITYKEY in
        regstr.w).  Makes sure that the DACL is not null. Function will only write 
        security information if it is not specified or the SCWMI_OVERWRITE_SECURITY is set.
                 
    
    Arguments:
        
        GuidString  [in]    
        SDDLString  [in]
        Flags       [in]    - SCWMI_OVERWRITE_SECURITY flag only
        
    Returns:    
        
        Status, normally NO_ERROR
        
--*/
{
    HKEY Key;
    PACL Dacl, Sacl;
    PSID Owner, Group;
    SECURITY_INFORMATION SecurityInformation;
    PSECURITY_DESCRIPTOR SD;
    ULONG Status;
    ULONG SizeNeeded;
    BOOL Present, Ok;


    Key = INVALID_HANDLE_VALUE;
    SD = NULL;
    SizeNeeded = 0;

    //
    // First check if security has already been set for this guid. If
    // so then we don't want to overwrite it.
    //
    Status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        WMIGUIDSECURITYKEY,
                        &Key);

    if(Status != ERROR_SUCCESS) {      
            //
            // Ensure key remains INVALID_HANDLE_VALUE so we don't try to free 
            // it later
            //
            Key = INVALID_HANDLE_VALUE;
            goto clean;
    } 

    if((Flags &  SCWMI_CLOBBER_SECURITY) ||
       (ERROR_SUCCESS != RegQueryValueEx(Key,
                                         GuidString,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &SizeNeeded))) {
    
         
        //
        // No security already setup so, lets go ahead and set it up
        // Lets create a SD from the SDDL string
        //
        Status = GLE_FN_CALL(FALSE,
                             ConvertStringSecurityDescriptorToSecurityDescriptor(
                                                                SDDLString,
                                                                SDDL_REVISION_1,
                                                                &SD,
                                                                NULL)
                             );

        if(Status != NO_ERROR) {
            //
            // Ensure SD remains NULL so it isn't freed later.
            //
            SD = NULL;
            goto clean;
        }
        //
        // Break up the SD into its components
        //
        Status = ParseSecurityDescriptor(SD,
                                         &SecurityInformation,
                                         &Owner,
                                         &Group,
                                         &Dacl,
                                         &Sacl);
        if(Status != NO_ERROR) {
            goto clean;
        }

        //
        // Don't allow any SD to be setup with a NULL DACL
        // as this results in full access for anyone
        //
        if(Dacl != NULL) {
            //
            // For wmiguids, the owner, group and sacl don't mean
            // much so we just set the DACL.
            //
            SecurityInformation = DACL_SECURITY_INFORMATION;
            Owner = NULL;
            Group = NULL;
            Sacl = NULL;

            Status = SetNamedSecurityInfo(GuidString,
                                          SE_WMIGUID_OBJECT,
                                          SecurityInformation,
                                          Owner,
                                          Group,
                                          Dacl,
                                          Sacl);
            if(Status != ERROR_SUCCESS) {
                DbgOut(("SetNamedSecurityInfo failed %d\n",
                        Status));
                goto clean;
            }
        } else {
            Status = ERROR_INVALID_PARAMETER;
            goto clean;
        }
    } 


  clean:
    if(SD) {
        //
        //  Explicity must use LocalFree for Security Descriptors returned by
        //  ConvertStringSecurityDescriptorToSecurityDescriptor
        //
        LocalFree(SD);
    }
    if(Key != INVALID_HANDLE_VALUE) {
        RegCloseKey(Key);
    }


    return(Status);
}
ULONG 
ParseSection(
            IN     INFCONTEXT  InfLineContext,
            IN OUT PTCHAR     *GuidString, 
            IN OUT ULONG      *GuidStringLen,
            OUT    PDWORD      Flags,
            IN OUT PTCHAR     *SectionNameString,
            IN OUT ULONG      *SectionNameStringLen
            ) 
/*++


    Routinte Description:    
        
        This section parses the GUID, flags, and SectionName, respectively.  
        There should only be 3 fields in the WMIInterface section, otherwise an
        error will be returned.                  
    
    Arguments:
        
        InfLineContext          [in]       - The line from the INF we are parsing
        GuidString              [in, out]  - Passed as NULL by the caller, then memory is allocated
                                             and filled with the corresponding GUID string.
        GuidStringLen           [in, out]  - Passed as zero by the caller, and then set to the 
                                             maximum length for the GUID.
        Flags                   [in, out]  - SCWMI_CLOBBER_SECURITY flag only
        SectionNameString       [in, out]  - assed as NULL by the caller, then memory is allocated
                                             and filled with the corresponding section name.
        SectionNameStringLen    [in, out]  - assed as zero by the caller, and then set to the 
                                             maximum length for the section name
                  
    Returns:    
        
        Status, normally NO_ERROR

--*/ 
{
    PTCHAR TempGuidString = NULL;
    ULONG FieldCount;
    ULONG Status;
    INT infFlags;
    int i;
    size_t Length;

    Status = NO_ERROR;

    //
    // Make sure there are 3 fields specified in the section 
    //
    FieldCount = SetupGetFieldCount(&InfLineContext);
    if(FieldCount < 3) {
        Status = ERROR_INVALID_PARAMETER;
        goto clean;
    }

   //
   // Get the guid string
   //
   *GuidStringLen = MAX_GUID_STRING_LEN;
   *GuidString = AllocMemory((*GuidStringLen) * sizeof(TCHAR));
   
   //
   // If the memory wasn't allocated, then return an error
   //
   if(!(*GuidString)) {
       Status = ERROR_NOT_ENOUGH_MEMORY;
       goto clean;
   }

   Status = GLE_FN_CALL(FALSE,
                        SetupGetStringField(&InfLineContext,
                                            1,
                                            (PTSTR)(*GuidString),
                                            *GuidStringLen,
                                            NULL)
                       );

   if(Status != NO_ERROR) {
       goto clean;
   }


   //
   // If the GUID string has curly braces take them off
   //

   //
   // String has curly braces as first and last character
   // Checks to make sure it has the same length as a GUID, otherwise, this function
   // relies on the WMI security API to handle and invalid GUID.
   //
   if(((*GuidString)[0] == TEXT('{')) &&
          SUCCEEDED(StringCchLength(*GuidString,MAX_GUID_STRING_LEN,&Length)) &&
            (Length == (MAX_GUID_STRING_LEN-1)) &&
          ((*GuidString)[MAX_GUID_STRING_LEN-2] == TEXT('}'))) {

       TempGuidString = AllocMemory((MAX_GUID_STRING_LEN-2) * sizeof(TCHAR));
       if(TempGuidString == NULL) {
           Status = ERROR_NOT_ENOUGH_MEMORY;
           goto clean;
       }

       //
       // Copy the GuidString, except the first and last character (the braces)
       //
       if(FAILED(StringCchCopyN(TempGuidString, 
                                MAX_GUID_STRING_LEN-2,
                                &(*GuidString)[1],
                                MAX_GUID_STRING_LEN-3))) {
           Status = ERROR_INVALID_PARAMETER;
           FreeMemory(TempGuidString);
           TempGuidString = NULL;
           goto clean;
       }

       FreeMemory(*GuidString);         

       //
       // Set GuidString equal to our new one without braces
       //
       *GuidString = TempGuidString;
       TempGuidString = NULL;

   }

   //
   // Now get the flags string
   //

   Status = GLE_FN_CALL(FALSE,
                        SetupGetIntField(&InfLineContext,
                                         2,
                                         &infFlags)
                       );
   
   if(Status != NO_ERROR) {
       goto clean;
   }
       
   //
   // if the flags in the INF were not set then use the flags indicated in the INF,
   // otherwise default to use the ones passed in by the calling function.
   //
   if(!(*Flags)) {
      *Flags = infFlags; 
   }

   *SectionNameStringLen = MAX_INF_STRING_LENGTH;
   *SectionNameString = AllocMemory(*SectionNameStringLen * sizeof(TCHAR));

   //
   // If the memory wasn't allocated, then return an error
   //
   if(!(*SectionNameString)) {
       Status = ERROR_NOT_ENOUGH_MEMORY;
       goto clean;
   }

   Status = GLE_FN_CALL(FALSE,
                        SetupGetStringField(&InfLineContext,
                                            3,
                                            (PTSTR)(*SectionNameString),
                                            (*SectionNameStringLen),
                                            NULL)
                       );
    
   
clean:
    //
    // If the function exits abnormally then clean up any strings allocated.
    //
    if(Status != NO_ERROR) {
        if(*GuidString){
             FreeMemory(*GuidString);         
             *GuidString = NULL;
         }
        if(TempGuidString) {
            FreeMemory(TempGuidString);
   
        }
        if(*SectionNameString){
             FreeMemory(*SectionNameString);
             *SectionNameString = NULL;
        }
    }
   
    return Status;
}



ULONG
GetSecurityKeyword(
                  IN     HINF     InfFile,
                  IN     LPCTSTR  WMIInterfaceSection,
                  IN OUT PTCHAR  *SDDLString,
                  IN OUT ULONG   *SDDLStringLen
                  )
/*++
        
    Routine Description:    
        
        The section name specified under the WMIInterface should contain a 
        security section the specifies the SDDL.  It should be in the form
        security = <SDDL>.  This fcuntion extracts the SDDL.  There should
        only be one security section, otherwise an error will be returned.                 
    
    Arguments:
        
        InfLineContext          [in]      - the line from the INF file
        WMIInterfaceSection     [in]      - the section name indicating what
                                            section contains the security info
        SDDLString              [in, out] - passed in as NULL by the caller, is
                                            allocated and filled in with the 
                                            corresponding security description
                                            string.
        SDDLStringLen           [in, out] - passed in as 0 by the caller and set
                                            to the maximum length of an INF field.
                  
    Returns:    
        
        Status, normally NO_ERROR

--*/ 
{
    INFCONTEXT InfLineContext;
    DWORD Status;
    ULONG FieldCount;

    Status = NO_ERROR;

    

    if(SetupFindFirstLine(InfFile,
                          WMIInterfaceSection,
                          WMIGUIDSECURITYSECTION_KEY,
                          &InfLineContext)) {

        //
        // WmiGuidSecurity = <SDDL>
        // sddl will be at index 1
        //  
        FieldCount = SetupGetFieldCount(&InfLineContext);
        if(FieldCount < 1) {
            Status = ERROR_INVALID_PARAMETER;
            goto clean;
        }
        //
        // Get the SDDL string
        //
        *SDDLStringLen =  MAX_INF_STRING_LENGTH;
        *SDDLString = AllocMemory(*SDDLStringLen * sizeof(TCHAR));

        //
        // If the memory wasn't allocated, then return an error
        //
        if(!(*SDDLString)) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto clean;
        }

        Status = GLE_FN_CALL(FALSE,
                             SetupGetStringField(&InfLineContext,
                                                 1,
                                                 (PTSTR)(*SDDLString),
                                                 (*SDDLStringLen),
                                                 NULL)
                            );

        if(Status == NO_ERROR) {

            //
            // There should not be more than one security entry
            //

            if(SetupFindNextMatchLine(&InfLineContext,
                                      WMIGUIDSECURITYSECTION_KEY,
                                      &InfLineContext)) {
                Status = ERROR_INVALID_PARAMETER;
                goto clean;
            }
        }

     
    }
 
    
clean:
    //
    // If the function exits abnormally then clean up any strings allocated.
    //
    if(Status != NO_ERROR) {
        if(*SDDLString) {
            FreeMemory(*SDDLString);         
            *SDDLString = NULL;
        }
    }

    return Status;
}


DWORD
__stdcall WmiGuidSecurityINF (
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
/*++
    
    Function:   
    
        WmiGuidSecurityINF

    Purpose:    
    
        Responds to co-installer messages

    Arguments:
        
        InstallFunction   [in]
        DeviceInfoSet     [in]
        DeviceInfoData    [in]
        Context           [in,out]

    Returns:    
        
        NO_ERROR, or an error code.

--*/
{
    DWORD Status = NO_ERROR;

    switch(InstallFunction) {
        case DIF_INSTALLDEVICE:
            //
            // We want to set security on the device before we install to eliminate
            // the race condition of setting up a device without security.
            // (No Post Processing required)
            //
            Status = PreProcessInstallDevice(DeviceInfoSet,
                                             DeviceInfoData,
                                             Context);

            break;

        default:
            break;
    }

    return Status;
}

#if DBG
VOID
DebugPrintX(
    PCHAR DebugMessage,
    ...
    )
{   
    CHAR SpewBuffer[DEBUG_BUFFER_LENGTH];
    va_list ap;

    va_start(ap, DebugMessage);

    StringCchVPrintf(SpewBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

    OutputDebugStringA("WMIInst: ");
    OutputDebugStringA(SpewBuffer);

    va_end(ap);

} 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\pnpsec.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpsec.c

Abstract:

    This module implements the security checks required to access the Plug and
    Play manager APIs.

        VerifyClientPrivilege
        VerifyClientAccess
        VerifyKernelInitiatedEjectPermissions

Author:

    James G. Cavalaris (jamesca) 05-Apr-2002

Environment:

    User-mode only.

Revision History:

    05-Apr-2002     Jim Cavalaris (jamesca)

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"

#include <svcsp.h>

#pragma warning(disable:4204)
#pragma warning(disable:4221)


//
// Global data provided by the service controller.
// Specifies well-known account and group SIDs for us to use.
//
extern PSVCS_GLOBAL_DATA PnPGlobalData;

//
// Security descriptor of the Plug and Play Manager security object, used to
// control access to the Plug and Play Manager APIs.
//
PSECURITY_DESCRIPTOR PlugPlaySecurityObject = NULL;

//
// Generic security mapping for the Plug and Play Manager security object.
//
GENERIC_MAPPING PlugPlaySecurityObjectMapping = PLUGPLAY_GENERIC_MAPPING;



//
// Function prototypes.
//

BOOL
VerifyTokenPrivilege(
    IN HANDLE       hToken,
    IN ULONG        Privilege,
    IN LPCWSTR      ServiceName
    );



//
// Access and privilege check routines.
//

BOOL
VerifyClientPrivilege(
    IN handle_t     hBinding,
    IN ULONG        Privilege,
    IN LPCWSTR      ServiceName
    )

/*++

Routine Description:

    This routine impersonates the client associated with hBinding and checks
    if the client possesses the specified privilege.

Arguments:

    hBinding        RPC Binding handle

    Privilege       Specifies the privilege to be checked.

Return value:

    The return value is TRUE if the client possesses the privilege, FALSE if not
    or if an error occurs.

--*/

{
    RPC_STATUS      rpcStatus;
    BOOL            bResult;
    HANDLE          hToken;

    //
    // If the specified RPC binding handle is NULL, this is an internal call so
    // we assume that the privilege has already been checked.
    //

    if (hBinding == NULL) {
        return TRUE;
    }

    //
    // Impersonate the client to retrieve the impersonation token.
    //

    rpcStatus = RpcImpersonateClient(hBinding);

    if (rpcStatus != RPC_S_OK) {
        //
        // Since we can't impersonate the client we better not do the security
        // checks as ourself (they would always succeed).
        //
        return FALSE;
    }

    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {

        bResult =
            VerifyTokenPrivilege(
                hToken, Privilege, ServiceName);

        CloseHandle(hToken);

    } else {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: OpenThreadToken failed, error = %d\n",
                   GetLastError()));

        bResult = FALSE;
    }

    rpcStatus = RpcRevertToSelf();

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                   rpcStatus));
        ASSERT(rpcStatus == RPC_S_OK);
    }

    return bResult;

} // VerifyClientPrivilege



BOOL
VerifyTokenPrivilege(
    IN HANDLE       hToken,
    IN ULONG        Privilege,
    IN LPCWSTR      ServiceName
    )

/*++

Routine Description:

    This routine checks if the specified token possesses the specified
    privilege.

Arguments:

    hToken          Specifies a handle to the token whose privileges are to be
                    checked

    Privilege       Specifies the privilege to be checked.

    ServiceName     Specifies the privileged subsystem service (operation
                    requiring the privilege).

Return value:

    The return value is TRUE if the client possesses the privilege, FALSE if not
    or if an error occurs.

--*/

{
    PRIVILEGE_SET   privilegeSet;
    BOOL            bResult = FALSE;

    //
    // Specify the privilege to be checked.
    //
    ZeroMemory(&privilegeSet, sizeof(PRIVILEGE_SET));

    privilegeSet.PrivilegeCount = 1;
    privilegeSet.Control = 0;
    privilegeSet.Privilege[0].Luid = RtlConvertUlongToLuid(Privilege);
    privilegeSet.Privilege[0].Attributes = 0;

    //
    // Perform the actual privilege check.
    //
    if (!PrivilegeCheck(hToken, &privilegeSet, &bResult)) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: PrivilegeCheck failed, error = %d\n",
                   GetLastError()));

        bResult = FALSE;
    }

    //
    // Generate an audit of the attempted privilege use, using the result of the
    // previous check.
    //
    if (!PrivilegedServiceAuditAlarm(
            PLUGPLAY_SUBSYSTEM_NAME,
            ServiceName,
            hToken,
            &privilegeSet,
            bResult)) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: PrivilegedServiceAuditAlarm failed, error = %d\n",
                   GetLastError()));
    }

    return bResult;

} // VerifyTokenPrivilege



BOOL
VerifyKernelInitiatedEjectPermissions(
    IN  HANDLE  UserToken   OPTIONAL,
    IN  BOOL    DockDevice
    )
/*++

Routine Description:

   Checks that the user has eject permissions for the specified type of
   hardware.

Arguments:

    UserToken - Token of the logged in console user, NULL if no console user
                is logged in.

    DockDevice - TRUE if a dock is being ejected, FALSE if an ordinary device
                 was specified.

Return Value:

   TRUE if the eject should procceed, FALSE otherwise.

--*/
{
    LONG            Result = ERROR_SUCCESS;
    BOOL            AllowUndock;
    WCHAR           RegStr[MAX_CM_PATH];
    HKEY            hKey = NULL;
    DWORD           dwSize, dwValue, dwType;
    TOKEN_PRIVILEGES NewPrivs, OldPrivs;


    //
    // Only enforce eject permissions for dock devices.  We do not specify per
    // device ejection security for other types of devices, since most devices
    // are in no way secure from removal.
    //
    if (!DockDevice) {
        return TRUE;
    }

    //
    // Unless the policy says otherwise, we do NOT allow undock without
    // privilege check.
    //
    AllowUndock = FALSE;

    //
    // First, check the "Allow undock without having to log on" policy.  If the
    // policy does NOT allow undock without logon, we require that there is an
    // interactive user logged on to the physical Console session, and that user
    // has the SE_UNDOCK_PRIVILEGE.
    //

    //
    // Open the System policies key.
    //
    if (SUCCEEDED(
            StringCchPrintf(
                RegStr,
                SIZECHARS(RegStr),
                L"%s\\%s",
                pszRegPathPolicies,
                pszRegKeySystem))) {

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                RegStr,
                0,
                KEY_READ,
                &hKey) == ERROR_SUCCESS) {

            //
            // Retrieve the "UndockWithoutLogon" value.
            //
            dwType  = 0;
            dwValue = 0;
            dwSize  = sizeof(dwValue);

            Result =
                RegQueryValueEx(
                    hKey,
                    pszRegValueUndockWithoutLogon,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwSize);

            if ((Result == ERROR_SUCCESS) && (dwType == REG_DWORD)) {

                //
                // If the value exists and is non-zero, we allow undock without
                // privilege check.  If the value id zero, the policy requires
                // us to check the privileges of the supplied user token.
                //
                AllowUndock = (dwValue != 0);

            } else if (Result == ERROR_FILE_NOT_FOUND) {

                //
                // No value means allow any undock.
                //
                AllowUndock = TRUE;

            } else {

                //
                // For all remaining cases, the policy check either failed, or
                // an error was encountered reading the policy.  We have
                // insufficient information to determine whether the eject
                // should be allowed based on policy alone, so we defer any
                // decision and check the privileges of the supplied user token.
                //
                AllowUndock = FALSE;
            }

            //
            // Close the policy key.
            //
            RegCloseKey(hKey);
        }
    }

    //
    // If the policy allowed undock without logon, there is no need to check
    // token privileges.
    //
    if (AllowUndock) {
        return TRUE;
    }

    //
    // If the policy requires privileges to be checked, but no user token was
    // supplied, deny the request.
    //
    if (UserToken == NULL) {
        return FALSE;
    }

    //
    // Enable the required SE_UNDOCK_PRIVILEGE token privilege.
    // The TOKEN_PRIVILEGES structure contains 1 LUID_AND_ATTRIBUTES, which is
    // all we need for now.
    //
    ZeroMemory(&NewPrivs, sizeof(TOKEN_PRIVILEGES));
    ZeroMemory(&OldPrivs, sizeof(TOKEN_PRIVILEGES));

    NewPrivs.PrivilegeCount = 1;
    NewPrivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    NewPrivs.Privileges[0].Luid = RtlConvertUlongToLuid(SE_UNDOCK_PRIVILEGE);

    dwSize = sizeof(TOKEN_PRIVILEGES);

    if (!AdjustTokenPrivileges(
            UserToken,
            FALSE,
            &NewPrivs,
            sizeof(TOKEN_PRIVILEGES),
            &OldPrivs,
            &dwSize)) {
        return FALSE;
    }

    //
    // Check if the required SE_UNDOCK_PRIVILEGE privilege is enabled.  Note
    // that this routine also audits the use of this privilege.
    //
    AllowUndock =
        VerifyTokenPrivilege(
            UserToken,
            SE_UNDOCK_PRIVILEGE,
            L"UNDOCK: EJECT DOCK DEVICE");

    //
    // Adjust the privilege back to its previous state.
    //
    AdjustTokenPrivileges(
        UserToken,
        FALSE,
        &OldPrivs,
        sizeof(TOKEN_PRIVILEGES),
        (PTOKEN_PRIVILEGES)NULL,
        (PDWORD)NULL);

    return AllowUndock;

} // VerifyKernelInitiatedEjectPermissions



BOOL
CreatePlugPlaySecurityObject(
    VOID
    )

/*++

Routine Description:

    This function creates the self-relative security descriptor which
    represents the Plug and Play security object.

Arguments:

    None.

Return Value:

    TRUE if the object was successfully created, FALSE otherwise.

--*/

{
    BOOL   Status = TRUE;
    NTSTATUS NtStatus;
    BOOLEAN WasEnabled;
    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    HANDLE TokenHandle = NULL;


    //
    // This routine is called from our service start routine, so we must have
    // been provided with the global data block by now.
    //

    ASSERT(PnPGlobalData != NULL);

    //
    // SE_AUDIT_PRIVILEGE privilege is required to perform object access and
    // privilege auditing, and must be enabled in the process token.  Leave it
    // enabled since we will be auditing frequently.  Note that we share this
    // process (services.exe) with the SCM, which also performs auditing, and
    // most likely has already enabled this privilege for the process.
    //

    RtlAdjustPrivilege(SE_AUDIT_PRIVILEGE,
                       TRUE,
                       FALSE,
                       &WasEnabled);

    //
    // SE_SECURITY_PRIVILEGE privilege is required to create a security
    // descriptor with a SACL.  Impersonate ourselves to safely enable the
    // privilege on our thread only.
    //

    NtStatus =
        RtlImpersonateSelf(
            SecurityImpersonation);

    ASSERT(NT_SUCCESS(NtStatus));

    if (!NT_SUCCESS(NtStatus)) {
        return FALSE;
    }

    NtStatus =
        RtlAdjustPrivilege(
            SE_SECURITY_PRIVILEGE,
            TRUE,
            TRUE,
            &WasEnabled);

    ASSERT(NT_SUCCESS(NtStatus));

    if (NT_SUCCESS(NtStatus)) {

        //
        // Specify the ACEs for the security object.
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //
        // ISSUE-2002/06/25-jamesca: Description of PlugPlaySecurityObject ACEs.
        //   For consistent read/write access between the server-side PlugPlay
        //   APIs and direct registry access by the client, we apply a DACL on
        //   the PlugPlaySecurityObject that similar to what is applied by
        //   default to the client accesible parts of the Plug and Play registry
        //   -- specifically, SYSTEM\CCS\Control\Class.  Note however that
        //   "Power Users" are NOT special-cased here as they are in the
        //   registry ACLs; they must be authenticated as a group listed below
        //   for any access to be granted.  If the access requirements for Plug
        //   and Play objects such as the registry ever change, you must
        //   re-evaluate the ACEs below to make sure they are still
        //   appropriate!!
        //

        RTL_ACE_DATA  PlugPlayAceData[] = {

            //
            // Local System Account is granted all access.
            //
            { ACCESS_ALLOWED_ACE_TYPE,
              0,
              0,
              GENERIC_ALL,
              &(PnPGlobalData->LocalSystemSid) },

            //
            // Local Administrators Group is granted all access.
            //
            { ACCESS_ALLOWED_ACE_TYPE,
              0,
              0,
              GENERIC_ALL,
              &(PnPGlobalData->AliasAdminsSid) },

            //
            // Network Group is denied any access.
            // (unless granted by Local Administrators ACE, above)
            //
            { ACCESS_DENIED_ACE_TYPE,
              0,
              0,
              GENERIC_ALL,
              &(PnPGlobalData->NetworkSid) },

            //
            // Users are granted read and execute access.
            // (unless denied by Network ACE, above)
            //
            { ACCESS_ALLOWED_ACE_TYPE,
              0,
              0,
              GENERIC_READ | GENERIC_EXECUTE,
              &(PnPGlobalData->AliasUsersSid) },

            //
            // Any access request not explicitly granted above is denied.
            //

            //
            // Audit object-specific write access requests for everyone, for
            // failure or success.  Audit all access request failures.
            //
            // We don't audit successful read access requests, because they
            // occur too frequently to be useful.  We don't audit successful
            // execute requests because they result in privilege checks, which
            // are audited separately.
            //
            // Also note that we only audit the PLUGPLAY_WRITE object-specific
            // right.  Since the GENERIC_WRITE mapping shares standard rights
            // with GENERIC_READ and GENERIC_EXECUTE, auditing successful access
            // grants for any of the GENERIC_WRITE bits would also result in
            // auditing any sucessful request for GENERIC_READ (and/or
            // GENERIC_EXECUTE access) - which as mentioned, are too frequent.
            //
            { SYSTEM_AUDIT_ACE_TYPE,
              0,
              FAILED_ACCESS_ACE_FLAG | SUCCESSFUL_ACCESS_ACE_FLAG,
              PLUGPLAY_WRITE,
              &(PnPGlobalData->WorldSid) },

            //
            // Audit all access failures for everyone.
            //
            // ISSUE-2002/06/25-jamesca: Everyone vs. Anonymous group SIDs:
            //     Note that for the purposes of auditing, the Everyone SID also
            //     includes Anonymous, though in all other cases the two groups
            //     are now disjoint (Windows XP and later).  The named pipe used
            //     for our RPC endpoint only grants access to everyone however,
            //     so technically we will never receive RPC calls from an
            //     Anonymous caller.
            //
            { SYSTEM_AUDIT_ACE_TYPE,
              0,
              FAILED_ACCESS_ACE_FLAG,
              GENERIC_ALL,
              &(PnPGlobalData->WorldSid) },
        };

        //
        // Create a new Absolute Security Descriptor, specifying the LocalSystem
        // account SID for both Owner and Group.
        //

        NtStatus =
            RtlCreateAndSetSD(
                PlugPlayAceData,
                RTL_NUMBER_OF(PlugPlayAceData),
                PnPGlobalData->LocalSystemSid,
                PnPGlobalData->LocalSystemSid,
                &AbsoluteSd);

        ASSERT(NT_SUCCESS(NtStatus));

        if (NT_SUCCESS(NtStatus)) {

            NtStatus =
                NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    FALSE,
                    &TokenHandle);

            ASSERT(NT_SUCCESS(NtStatus));

            if (NT_SUCCESS(NtStatus)) {

                //
                // Create the security object (a user-mode object is really a pseudo-
                // object represented by a security descriptor that have relative
                // pointers to SIDs and ACLs).  This routine allocates the memory to
                // hold the relative security descriptor so the memory allocated for the
                // DACL, ACEs, and the absolute descriptor can be freed.
                //

                NtStatus =
                    RtlNewSecurityObject(
                        NULL,
                        AbsoluteSd,
                        &PlugPlaySecurityObject,
                        FALSE,
                        TokenHandle,
                        &PlugPlaySecurityObjectMapping);

                ASSERT(NT_SUCCESS(NtStatus));

                NtClose(TokenHandle);

            }

            //
            // Free the Absolute Security Descriptor allocated by
            // RtlCreateAndSetSD in the process heap.  If sucessful, we should
            // have a self-relative one in PlugPlaySecurityObject.
            //

            RtlFreeHeap(RtlProcessHeap(), 0, AbsoluteSd);
        }
    }

    ASSERT(IsValidSecurityDescriptor(PlugPlaySecurityObject));

    //
    // If not successful, we could not create the security object.
    //

    if (!NT_SUCCESS(NtStatus)) {
        ASSERT(PlugPlaySecurityObject == NULL);
        PlugPlaySecurityObject = NULL;
        Status = FALSE;
    }

    //
    // Stop impersonating.
    //

    TokenHandle = NULL;

    NtStatus =
        NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            (PVOID)&TokenHandle,
            sizeof(TokenHandle));

    ASSERT(NT_SUCCESS(NtStatus));

    return Status;

} // CreatePlugPlaySecurityObject



VOID
DestroyPlugPlaySecurityObject(
    VOID
    )

/*++

Routine Description:

    This function deletes the self-relative security descriptor which
    represents the Plug and Play security object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (PlugPlaySecurityObject != NULL) {
        RtlDeleteSecurityObject(&PlugPlaySecurityObject);
        PlugPlaySecurityObject = NULL;
    }

    return;

} // DestroyPlugPlaySecutityObject



BOOL
VerifyClientAccess(
    IN  handle_t     hBinding,
    IN  ACCESS_MASK  DesiredAccess
    )

/*++

Routine Description:

    This routine determines if the client associated with hBinding is granted
    trhe desired access.

Arguments:

    hBinding        RPC Binding handle

    DesiredAccess   Access desired

Return value:

    The return value is TRUE if the client is granted access, FALSE if not or if
    an error occurs.

--*/

{
    RPC_STATUS rpcStatus;
    BOOL AccessStatus = FALSE;
    BOOL GenerateOnClose;
    ACCESS_MASK GrantedAccess;

    //
    // If the specified RPC binding handle is NULL, this is an internal call so
    // we assume that the access has already been checked.
    //

    if (hBinding == NULL) {
        return TRUE;
    }

    //
    // If we have no security object, we cannot perform access checks, and no
    // access is granted.
    //

    ASSERT(PlugPlaySecurityObject != NULL);

    if (PlugPlaySecurityObject == NULL) {
        return FALSE;
    }

    //
    // If any generic access rights were specified, map them to the specific and
    // standard rights specified in the object's generic access map.
    //

    MapGenericMask(
        (PDWORD)&DesiredAccess,
        &PlugPlaySecurityObjectMapping);

    //
    // Impersonate the client.
    //

    rpcStatus = RpcImpersonateClient(hBinding);

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcImpersonateClient failed, error = %d\n",
                   rpcStatus));
        return FALSE;
    }

    //
    // Perform the access check while impersonating the client - the
    // impersonation token is automatically used.  Generate audit and alarm,
    // as specified by the security object.
    //
    // Note that auditing requires the SE_AUDIT_PRIVILEGE to be enabled in the
    // *process* token.  Most likely, the SCM would have enabled this privilege
    // for the services.exe process at startup (since it also performs
    // auditing).  If not, we would have attempted to enable it during our
    // initialization, when we created the PlugPlaySecurityObject.
    //

    if (!AccessCheckAndAuditAlarm(
            PLUGPLAY_SUBSYSTEM_NAME,           // subsystem name
            NULL,                              // handle to object
            PLUGPLAY_SECURITY_OBJECT_TYPE,     // type of object
            PLUGPLAY_SECURITY_OBJECT_NAME,     // name of object
            PlugPlaySecurityObject,            // SD
            DesiredAccess,                     // requested access rights
            &PlugPlaySecurityObjectMapping,    // mapping
            FALSE,                             // creation status
            &GrantedAccess,                    // granted access rights
            &AccessStatus,                     // result of access check
            &GenerateOnClose                   // audit generation option
            )) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: AccessCheckAndAuditAlarm failed, error = %d\n",
                   GetLastError()));
        AccessStatus = FALSE;
    }

    //
    // Stop impersonating.
    //

    rpcStatus = RpcRevertToSelf();

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                   rpcStatus));
        ASSERT(rpcStatus == RPC_S_OK);
    }

    return AccessStatus;

} // VerifyClientAccess



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\pnpsec.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpsec.c

Abstract:

    This module contains definitions used with the Plug and Play manager
    security object.

Author:

    James G. Cavalaris (jamesca) 05-Apr-2002

Environment:

    User-mode only.

Revision History:

    05-Apr-2002     Jim Cavalaris (jamesca)

        Creation and initial implementation.

--*/



//
// Audit subsystem and object names
//

#define PLUGPLAY_SUBSYSTEM_NAME        L"PlugPlayManager"
#define PLUGPLAY_SECURITY_OBJECT_NAME  L"PlugPlaySecurityObject"
#define PLUGPLAY_SECURITY_OBJECT_TYPE  L"Security"


//
// PlugPlayManager object specific access rights
//

#define PLUGPLAY_READ       (0x0001)
#define PLUGPLAY_WRITE      (0x0002)
#define PLUGPLAY_EXECUTE    (0x0004)

#define PLUGPLAY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | \
                             PLUGPLAY_READ            | \
                             PLUGPLAY_WRITE           | \
                             PLUGPLAY_EXECUTE)


//
// Structure that describes the mapping of Generic access rights to object
// specific access rights for the Plug and Play Manager security object.
//

#define PLUGPLAY_GENERIC_MAPPING { \
    STANDARD_RIGHTS_READ    |      \
        PLUGPLAY_READ,             \
    STANDARD_RIGHTS_WRITE   |      \
        PLUGPLAY_WRITE,            \
    STANDARD_RIGHTS_EXECUTE |      \
        PLUGPLAY_EXECUTE,          \
    PLUGPLAY_ALL_ACCESS }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\precomp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file for the user-mode Plug and Play Manager.

Author:

    Jim Cavalaris (jamesca) 03-01-2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpnpapi.h>

//
// Win32 Public Header Files
//
#include <windows.h>
#include <cfgmgr32.h>
#include <dbt.h>
#include <regstr.h>
#include <infstr.h>
#include <strsafe.h>

//
// Win32 Private Header Files
//
#include <pnpmgr.h>
#include <winuserp.h>

//
// CRT Header Files
//
#include <stdlib.h>

//
// Private Header Files
//
#include "pnp.h"        // midl generated, rpc interfaces
#include "cfgmgrp.h"    // private shared header, needs handle_t so must follow pnp.h
#include "umpnplib.h"   // private shared header, for routines in shared umpnplib
#include "ppmacros.h"   // private macros / debug header

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\pnp_s_stub.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnp_s_stub.c

Abstract:

    Stub file to allow pnp_s.c to work with precompiled headers.

Author:

    Jim Cavalaris (jamesca) 04-06-2001

Environment:

    User-mode only.

Revision History:

    06-April-2001     jamesca

        Creation and initial implementation.

Notes:

    The included file pnp_s.c contains the server side stubs for the PNP RPC
    interface.  The stubs are platform specific, and are included from
    ..\idl\$(O).  You must first build ..\idl for the current platform prior to
    building umpnpmgr.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop


//
// Disable some level-4 warnings for the MIDL-generated RPC server stubs.
//
#pragma warning(disable:4211) // warning C4211: nonstandard extension used: redefined extern to static
#pragma warning(disable:4232) // warning C4232: address of dllimport is not static
#pragma warning(disable:4310) // warning C4310: cast truncates constant value

//
// Include the RPC server-side stubs
//
#include "pnp_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\rdevnode.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rdevnode.c

Abstract:

    This module contains the server-side device node APIs.

                  PNP_CreateDevInst
                  PNP_DeviceInstanceAction
                  PNP_GetDeviceStatus
                  PNP_SetDeviceProblem
                  PNP_UninstallDevInst
                  PNP_AddID
                  PNP_RegisterDriver
                  PNP_QueryRemove
                  PNP_DisableDevInst
                  PNP_RequestDeviceEject

Author:

    Paula Tomlinson (paulat) 7-11-1995

Environment:

    User-mode only.

Revision History:

    11-July-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"


//
// private prototypes
//
CONFIGRET
SetupDevInst(
   IN PCWSTR   pszDeviceID,
   IN ULONG    ulFlags
   );

CONFIGRET
CreateDefaultDeviceInstance(
   IN PCWSTR   pszDeviceID,
   IN PCWSTR   pszParentID,
   IN BOOL     bPhantom,
   IN BOOL     bMigrated
   );

ULONG
GetCurrentConfigFlag(
   IN PCWSTR   pDeviceID
   );

BOOL
MarkDevicePhantom(
   IN HKEY     hKey,
   IN ULONG    ulValue
   );

CONFIGRET
GenerateDeviceInstance(
   OUT LPWSTR   pszFullDeviceID,
   IN  LPWSTR   pszDeviceID,
   IN  ULONG    ulDevId
   );

BOOL
IsDeviceRegistered(
    IN LPCWSTR  pszDeviceID,
    IN LPCWSTR  pszService
    );

BOOL
IsPrivatePhantomFromFirmware(
    IN HKEY hKey
    );

typedef struct {

    LIST_ENTRY  ListEntry;
    WCHAR       DevInst[ANYSIZE_ARRAY];

} ENUM_ELEMENT, *PENUM_ELEMENT;

CONFIGRET
EnumerateSubTreeTopDownBreadthFirstWorker(
    IN      handle_t    BindingHandle,
    IN      LPCWSTR     DevInst,
    IN OUT  PLIST_ENTRY ListHead
    );

//
// global data
//
extern HKEY ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY
extern HKEY ghServicesKey;  // Key to HKLM\CCC\System\Services - DO NOT MODIFY



CONFIGRET
PNP_CreateDevInst(
   IN handle_t    hBinding,
   IN OUT LPWSTR  pszDeviceID,
   IN LPWSTR      pszParentDeviceID,
   IN ULONG       ulLength,
   IN ULONG       ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Create_DevNode routine.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Device instance to create.

   pszParentDeviceID Parent of the new device.

   ulLength          Max length of pszDeviceID on input and output.

   ulFlags           Supplies flags specifying options for the creation of the
                     device instance.  May be one of the following values:

               CM_CREATE_DEVNODE_NORMAL
                     Create the device instance now, and perform installation
                     for it at a later time.

               CM_CREATE_DEVNODE_PHANTOM
                     Create a phantom device instance (i.e., a handle to a
                     device instance that is not alive as far as the ConfigMgr
                     APIs are concerned).  This may be used for CM APIs that
                     require a devnode handle, but for which no real devnode
                     currently exists (e.g., registry property APIs).  This
                     flag may not be specified with CR_CREATE_DEVNODE_NORMAL.

               CM_CREATE_DEVNODE_GENERATE_ID
                     Create a Root-enumerated devnode using a unique device
                     instance ID generated from the supplied device ID in
                     pszDeviceID.  If this flag is set, then pszDeviceID is
                     assumed to contain simply a device ID (i.e., no enumerator
                     key prefix, and no device instance suffix).  A unique
                     4-digit, base-10 identifier string will be created under
                     Enum\Root\<pszDeviceID>, and the devnode will be created
                     based on that device instance ID.  For instance, to add a
                     new legacy COM port devnode, this API would be called with
                     a pszDeviceID of *PNP0500.  Assuming there was already one
                     COM port instance in the registry (instance 0000), the new
                     device instance ID would be: Root\*PNP0500\0001 The caller
                     may find out what device instance name was generated by
                     calling CM_Get_Device_ID with the devnode returned from
                     this API.

               CM_CREATE_DEVNODE_DO_NOT_INSTALL
                     If this flag is set, the device will be registered as
                     controlled by the Service currently specified for the
                     device, by the CM_DRP_SERVICE device registry property.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS. Otherwise it
   returns a CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szFullDeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulStatusFlag=0, ulConfigFlag=0, ulCSConfigFlag=0, ulProblem=0;
    ULONG       ulPhantom = 0, ulMigrated = 0;
    ULONG       ulSize=0;
    PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA ControlData;
    WCHAR       szService[MAX_PATH];
    NTSTATUS    ntStatus;
    HRESULT     hr;
    size_t      DeviceIDLen = 0;


    try {
        //
        // Verify client "write" access.
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate parameters
        //

        if (INVALID_FLAGS(ulFlags, CM_CREATE_DEVNODE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pszDeviceID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        ASSERT(ARGUMENT_PRESENT(pszParentDeviceID));

        if (!ARGUMENT_PRESENT(pszParentDeviceID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Additionally, Windows NT does not support the
        // CM_CREATE_DEVNODE_NO_WAIT_INSTALL flag.
        //

        if (ulFlags & CM_CREATE_DEVNODE_NO_WAIT_INSTALL) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Validate that parent is the root devnode.  This routine only allows
        // the creation of root-enumerated devices.
        //

        if (!IsRootDeviceID(pszParentDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // create a unique instance value if requested
        //

        if (ulFlags & CM_CREATE_DEVNODE_GENERATE_ID) {

            Status =
                GenerateDeviceInstance(
                    szFullDeviceID,
                    pszDeviceID,
                    MAX_DEVICE_ID_LEN);

            if (Status != CR_SUCCESS) {
                goto Clean0;
            }

            if (FAILED(StringCchLength(
                           szFullDeviceID,
                           MAX_DEVICE_ID_LEN,
                           &DeviceIDLen))) {
                Status = CR_INVALID_DEVICE_ID;
                goto Clean0;
            }

            ASSERT(DeviceIDLen > 0);
            ASSERT(DeviceIDLen < MAX_DEVICE_ID_LEN);

            if (((ULONG)(DeviceIDLen + 1)) > ulLength) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            hr = StringCchCopyEx(pszDeviceID,
                                 ulLength,
                                 szFullDeviceID,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);

            ASSERT(HRESULT_CODE(hr) != ERROR_INSUFFICIENT_BUFFER);

            if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            } else if (FAILED(hr)) {
                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        //
        // try opening the registry key for this device instance
        //
        RegStatus = RegOpenKeyEx(ghEnumKey, pszDeviceID, 0,
                                 KEY_READ | KEY_WRITE, &hKey);

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_REGISTRY,
                   "UMPNPMGR: PNP_CreateDevInst opened key %ws\n",
                   pszDeviceID));

        //
        // if the key already exists, check if it is marked as "Migrated".
        //
        if (RegStatus == ERROR_SUCCESS) {
            ulSize = sizeof(ULONG);
            if (RegQueryValueEx(hKey,
                                pszRegValueMigrated,
                                NULL,
                                NULL,
                                (LPBYTE)&ulMigrated,
                                &ulSize) != ERROR_SUCCESS) {
                ulMigrated = 0;
            } else {
                //
                // if the value exists at all, be paranoid and check that it's 1
                //
                ASSERT(ulMigrated == 1);
            }
        }

        //
        // first handle phantom devnode case
        //
        if (ulFlags & CM_CREATE_DEVNODE_PHANTOM) {
            //
            // for a phantom devnode, it must not already exist in the registry
            // unless it's an unregistered firmware mapper device instance.
            //
            if (RegStatus == ERROR_SUCCESS) {
                ASSERT(hKey != NULL);
                //
                // Check to see if the device is migrated, or is a firmware
                // mapper-created phantom--if so, it's OK to allow the create to
                // succeed.
                //
                if (ulMigrated != 0) {
                    //
                    // this key was specifically request (not generated) so it
                    // will be used -- remove the migrated value.
                    //
                    RegDeleteValue(hKey, pszRegValueMigrated);
                    Status = CR_SUCCESS;
                } else if (IsPrivatePhantomFromFirmware(hKey)) {
                    Status = CR_SUCCESS;
                } else {
                    Status = CR_ALREADY_SUCH_DEVINST;
                }
                goto Clean0;
            }

            //
            // it doesn't exist in the registry so create a phantom devnode
            //
            CreateDefaultDeviceInstance(pszDeviceID,
                                        pszParentDeviceID,
                                        TRUE,
                                        FALSE);

            goto Clean0;
        }

        //
        // for a normal devnode, fail if the device is already present in the
        // registry and alive, and not migrated
        //
        if ((RegStatus == ERROR_SUCCESS)     &&
            (IsDeviceIdPresent(pszDeviceID)) &&
            (ulMigrated == 0)) {
            //
            // Set status to NEEDS ENUM and fail the create call.
            //
            Status = CR_ALREADY_SUCH_DEVINST;
            goto Clean0;
        }

        //
        // if couldn't open the device instance, or the key was migrated, then
        // most likely the key doesn't exist yet, or should be treated as if it
        // doesn't exist yet, so create a device instance key with default
        // values.
        //
        if ((RegStatus != ERROR_SUCCESS) || (ulMigrated != 0)) {

            //
            // this key will be used -- remove the migrated value
            // and close the key.
            //
            if (ulMigrated != 0) {
                ASSERT(RegStatus == ERROR_SUCCESS);
                ASSERT(hKey != NULL);
                RegDeleteValue(hKey, pszRegValueMigrated);
                RegCloseKey(hKey);
                hKey = NULL;
            }

            //
            // create the default device instance, finding and unused instance
            // if necessary.  if the key was migrated, a new key will not be
            // created, but the default instance data will be added to the
            // existing key.
            //
            CreateDefaultDeviceInstance(pszDeviceID,
                                        pszParentDeviceID,
                                        FALSE,
                                        (ulMigrated != 0));

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_REGISTRY,
                       "UMPNPMGR: PNP_CreateDevInst opened key %ws\n",
                       pszDeviceID));

            RegStatus = RegOpenKeyEx(ghEnumKey, pszDeviceID, 0,
                                     KEY_READ | KEY_WRITE, &hKey);

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }
        }

        //
        // retrieve flags
        //

        ulConfigFlag = GetDeviceConfigFlags(pszDeviceID, hKey);
        ulCSConfigFlag = GetCurrentConfigFlag(pszDeviceID);

        //
        // check if the device is blocked
        //

        if ((ulCSConfigFlag & CSCONFIGFLAG_DO_NOT_CREATE) ||
            (ulConfigFlag & CONFIGFLAG_REMOVED) ||
            (ulConfigFlag & CONFIGFLAG_NET_BOOT)) {

            Status = CR_CREATE_BLOCKED;
            goto Clean0;
        }

        //
        // Call kernel-mode to create the device node
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        ControlData.Flags = 0;

        ntStatus = NtPlugPlayControl(PlugPlayControlInitializeDevice,
                                     &ControlData,
                                     sizeof(ControlData));
        if (!NT_SUCCESS(ntStatus)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Retrieve devnode status
        //

        GetDeviceStatus(pszDeviceID, &ulStatusFlag, &ulProblem);

        //
        // Are we converting a phantom into a real devnode?
        //

        ulSize = sizeof(ULONG);
        if (RegQueryValueEx(hKey, pszRegValuePhantom, NULL, NULL,
                            (LPBYTE)&ulPhantom, &ulSize) != ERROR_SUCCESS) {
            ulPhantom = 0;
        }

        if (ulPhantom) {

            //
            // If we're turning a phantom into a real devnode, suppress the found new
            // hardware popup for this device, then clear the phantom flag.
            //

            RegDeleteValue(hKey, pszRegValuePhantom);

        } else {

            //
            // if device not installed, set a problem
            //

            if (ulConfigFlag & CONFIGFLAG_REINSTALL ||
                ulConfigFlag & CONFIGFLAG_FAILEDINSTALL) {

                SetDeviceStatus(pszDeviceID, DN_HAS_PROBLEM, CM_PROB_NOT_CONFIGURED);
            }
        }

        if (ulFlags & CM_CREATE_DEVNODE_DO_NOT_INSTALL) {

            //
            // If the device has a service, register it
            //

            ulSize = MAX_PATH * sizeof(WCHAR);
            if (RegQueryValueEx(hKey, pszRegValueService, NULL, NULL,
                    (LPBYTE)szService, &ulSize) == ERROR_SUCCESS) {

                if (szService[0] != L'\0') {

                    memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
                    RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
                    ControlData.Flags = 0;

                    NtPlugPlayControl(PlugPlayControlRegisterNewDevice,
                                      &ControlData,
                                      sizeof(ControlData));
                }
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_CreateDevInst



CONFIGRET
PNP_DeviceInstanceAction(
   IN handle_t   hBinding,
   IN ULONG      ulAction,
   IN ULONG      ulFlags,
   IN PCWSTR     pszDeviceInstance1,
   IN PCWSTR     pszDeviceInstance2
   )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager routines that
  perform some operation on DevNodes (such as create, setup, disable,
  and enable, etc). It handles various routines in this one routine by
  accepting a major and minor action value.

Arguments:

   hBinding          RPC binding handle.

   ulMajorAction     Specifies the requested action to perform (one of the
                     PNP_DEVINST_* values)

   ulFlags           This value depends on the value of the ulMajorAction and
                     further defines the specific action to perform

   pszDeviceInstance1   This is a device instance string to be used in
                     performing the specified action, it's value depends on
                     the ulMajorAction value.

   pszDeviceInstance2   Not used, must be NULL.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_ALREADY_SUCH_DEVNODE,
         CR_INVALID_DEVICE_ID,
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG,
         CR_FAILURE,
         CR_NOT_DISABLEABLE,
         CR_INVALID_POINTER, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    BOOL        Locked = FALSE;
    PWSTR       PrivilegedServiceAction = NULL;

    //
    // Verify client "execute" access
    //
    if (!VerifyClientAccess(hBinding,
                            PLUGPLAY_EXECUTE)) {
        return CR_ACCESS_DENIED;
    }

    //
    // Verify client privilege
    //
    switch (ulAction) {

    case PNP_DEVINST_SETUP:
        PrivilegedServiceAction = L"Device Action (setup device)";
        break;

    case PNP_DEVINST_ENABLE:
        PrivilegedServiceAction = L"Device Action (enable device)";
        break;

    case PNP_DEVINST_REENUMERATE:
        PrivilegedServiceAction = L"Device Action (re-enumerate device)";
        break;

    case PNP_DEVINST_DISABLE:
    case PNP_DEVINST_QUERYREMOVE:
    case PNP_DEVINST_REMOVESUBTREE:
    case PNP_DEVINST_REQUEST_EJECT:
    case PNP_DEVINST_MOVE:
        PrivilegedServiceAction = L"Device Action (action not implemented)";
        break;

    default:
        PrivilegedServiceAction = L"Device Action (unknown action)";
        break;
    }

    if (!VerifyClientPrivilege(
            hBinding,
            SE_LOAD_DRIVER_PRIVILEGE,
            PrivilegedServiceAction)) {
        return CR_ACCESS_DENIED;
    }

    //
    // NOTE: We enter a critical section here to guard against concurrent
    // read/write operations to the "DisableCount" registry value of any
    // single device instance by SetupDevInst, EnableDevInst (called by this
    // routine, below), and DisableDevInst.
    //
    PNP_ENTER_SYNCHRONOUS_CALL();
    Locked = TRUE;

    try {
        //
        // Validate parameters.
        //
        if (ARGUMENT_PRESENT(pszDeviceInstance2)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // pass the request on to a private routine that handles each major
        // device instance action request
        //
        switch (ulAction) {

        case PNP_DEVINST_SETUP:
            if (IsLegalDeviceId(pszDeviceInstance1)) {
                Status = SetupDevInst(pszDeviceInstance1, ulFlags);
            } else {
                Status = CR_INVALID_DEVNODE;
            }
            break;

        case PNP_DEVINST_ENABLE:
            if (IsLegalDeviceId(pszDeviceInstance1)) {
                Status = EnableDevInst(pszDeviceInstance1, TRUE);
            } else {
                Status = CR_INVALID_DEVNODE;
            }
            break;

        case PNP_DEVINST_REENUMERATE:
            if (IsLegalDeviceId(pszDeviceInstance1)) {
                Status = ReenumerateDevInst(pszDeviceInstance1, TRUE, ulFlags);
            } else {
                Status = CR_INVALID_DEVNODE;
            }
            break;

        case PNP_DEVINST_DISABLE:
            Status = CR_CALL_NOT_IMPLEMENTED;
            break;

        case PNP_DEVINST_QUERYREMOVE:
            Status = CR_CALL_NOT_IMPLEMENTED;
            break;

        case PNP_DEVINST_REMOVESUBTREE:
            Status = CR_CALL_NOT_IMPLEMENTED;
            break;

        case PNP_DEVINST_REQUEST_EJECT:
            Status = CR_CALL_NOT_IMPLEMENTED;
            break;

        case PNP_DEVINST_MOVE:
            Status = CR_CALL_NOT_IMPLEMENTED;
            break;

        default:
            Status = CR_INVALID_FLAG;
            break;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        Locked = Locked;
    }

    if (Locked) {
        PNP_LEAVE_SYNCHRONOUS_CALL();
    }

    return Status;

} // PNP_DeviceInstanceAction



CONFIGRET
PNP_GetDeviceStatus(
   IN  handle_t   hBinding,
   IN  LPCWSTR    pDeviceID,
   OUT PULONG     pulStatus,
   OUT PULONG     pulProblem,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager
  CM_Get_DevNode_Status routines.  It retrieves device instance specific
  status information.

Arguments:

   hBinding          RPC binding handle.

   pDeviceID         This is a device instance string to retrieve status
                     information for.

   pulStatus         Pointer to ULONG variable to return Status Flags in

   pulProblem        Pointer to ULONG variable to return Problem in

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG, or
         CR_INVALID_POINTER.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       PropertyData, DataSize, DataTransferLen, DataType;
    size_t      DeviceIDLen = 0;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters.
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pulStatus)) ||
            (!ARGUMENT_PRESENT(pulProblem))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *pulStatus = 0;
        *pulProblem = 0;

        if (FAILED(StringCchLength(
                       pDeviceID,
                       MAX_DEVICE_ID_LEN,
                       &DeviceIDLen))) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        ASSERT(DeviceIDLen < MAX_DEVICE_ID_LEN);

        if (DeviceIDLen == 0) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Retrieve the Flags information from the DeviceNode (which is then
        // mapped into status and problem values).
        //

        Status = GetDeviceStatus(pDeviceID, pulStatus, pulProblem);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Map special flags that aren't stored in the DeviceNode Flags field
        //

        //
        // DN_ROOT_ENUMERATED?
        //

        if (IsDeviceRootEnumerated(pDeviceID)) {
            //
            // Do not mark PnP BIOS enumerated as ROOT enumerated
            //
            //  Bios enumerated devices look like:
            //      Root\*aaannnn\PnPBIOS_n
            //

            if ((DeviceIDLen < (4 + 1 + 8 + 1 + 8)) ||
                (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE,
                               &pDeviceID[14], 8,
                               TEXT("PnPBIOS__"), 8) != CSTR_EQUAL)) {
                *pulStatus |= DN_ROOT_ENUMERATED;
            }
        }

        //
        // DN_REMOVABLE?
        //
        DataSize = DataTransferLen = sizeof(ULONG);
        if (CR_SUCCESS == PNP_GetDeviceRegProp(NULL,
                                               pDeviceID,
                                               CM_DRP_CAPABILITIES,
                                               &DataType,
                                               (LPBYTE)&PropertyData,
                                               &DataTransferLen,
                                               &DataSize,
                                               0)) {

            if (PropertyData & CM_DEVCAP_REMOVABLE) {
                *pulStatus |= DN_REMOVABLE;
            }
        }

        //
        // DN_MANUAL?
        //
        DataSize = DataTransferLen = sizeof(ULONG);
        if (CR_SUCCESS != PNP_GetDeviceRegProp(NULL,
                                               pDeviceID,
                                               CM_DRP_CONFIGFLAGS,
                                               &DataType,
                                               (LPBYTE)&PropertyData,
                                               &DataTransferLen,
                                               &DataSize,
                                               0)) {
            PropertyData = 0;
        }

        if (PropertyData & CONFIGFLAG_MANUAL_INSTALL) {
            *pulStatus |= DN_MANUAL;
        }

        //
        // If there isn't already a problem, check to see if the config flags indicate this
        // was a failed installation.
        //
        if (!(*pulStatus & DN_HAS_PROBLEM) && (PropertyData & CONFIGFLAG_FAILEDINSTALL)) {
            *pulStatus |= DN_HAS_PROBLEM;
            *pulProblem = CM_PROB_FAILED_INSTALL;
        }


    Clean0:
        NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }


   return Status;

} // PNP_GetDeviceStatus



CONFIGRET
PNP_SetDeviceProblem(
   IN handle_t  hBinding,
   IN LPCWSTR   pDeviceID,
   IN ULONG     ulProblem,
   IN ULONG     ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager
  CM_Set_DevNode_Problem routines.  It set device instance specific
  problem information.

Arguments:

   hBinding          RPC binding handle.

   pDeviceID         This is a device instance string to retrieve status
                     information for.

   ulProblem         A ULONG variable that specifies the Problem

   ulFlags           May be one of the following two values:

                         CM_SET_DEVNODE_PROBLEM_NORMAL -- only set problem
                             if currently no problem

                         CM_SET_DEVNODE_PROBLEM_OVERRIDE -- override current
                             problem with new problem

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulCurrentProblem = 0, ulCurrentStatus = 0;

    try {
        //
        // Verify client "execute" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_EXECUTE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Verify client privilege
        //
        if (!VerifyClientPrivilege(hBinding,
                                   SE_LOAD_DRIVER_PRIVILEGE,
                                   L"Device Action (set device problem code)")) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_SET_DEVNODE_PROBLEM_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // If there's already a problem, do nothing unless CM_SET_DEVNODE_PROBLEM_OVERRIDE
        // is specified.
        //

        Status = GetDeviceStatus(pDeviceID, &ulCurrentStatus, &ulCurrentProblem);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        if (ulProblem) {
            //
            // The caller is wanting to set a problem.  Make sure that if the device
            // already has a problem, it's the same one as we're trying to set (unless
            // we're overriding the current problem).
            //
            if ((ulCurrentStatus & DN_HAS_PROBLEM) &&
                (ulCurrentProblem != ulProblem) &&
                ((ulFlags & CM_SET_DEVNODE_PROBLEM_BITS) != CM_SET_DEVNODE_PROBLEM_OVERRIDE)) {

                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        if (!ulProblem) {
            Status = ClearDeviceStatus(pDeviceID, DN_HAS_PROBLEM, ulCurrentProblem);
        } else {
            Status = SetDeviceStatus(pDeviceID, DN_HAS_PROBLEM, ulProblem);
        }

    Clean0:
        NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   return Status;

} // PNP_SetDeviceProblem



CONFIGRET
PNP_UninstallDevInst(
   IN  handle_t         hBinding,
   IN  LPCWSTR          pDeviceID,
   IN  ULONG            ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager
  CM_Deinstall_DevNode routine. It removes the device instance
  registry key and any subkeys (only for phantoms).

Arguments:

   hBinding          RPC binding handle.

   pDeviceID         The device instance to deinstall.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   Otherwise it returns one of the CR_ERROR codes.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulStatus, ulProblem;

    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //------------------------------------------------------------------
        // Uninstall deletes instance key (and all subkeys) for all
        // the hardware keys (this means the main Enum branch, the
        // config specific keys under HKLM, and the Enum branch under
        // HKCU). In the case of the user hardware keys (under HKCU),
        // I delete those whether it's a phantom or not, but since
        // I can't access the user key from the service side, I have
        // to do that part on the client side. For the main hw Enum key
        // and the config specific hw keys, I only delete them outright
        // if they are phantoms. If not a phantom, then I just make the
        // device instance volatile (by saving the original key, deleting
        // old key, creating new volatile key and restoring the old
        // contents) so at least it will go away during the next boot
        //------------------------------------------------------------------

        if ((GetDeviceStatus(pDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) &&
            (ulStatus & DN_DRIVER_LOADED)) {

            //-------------------------------------------------------------
            // device is not a phantom
            //-------------------------------------------------------------

            if ((ulStatus & DN_ROOT_ENUMERATED)!=0 &&
                (ulStatus & DN_DISABLEABLE)==0) {

                //
                // if a device is root enumerated, but not disableable, it is not uninstallable
                // return status is CR_NOT_DISABLEABLE, as that is why it cannot be uninstalled
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_REGISTRY,
                           "UMPNPMGR: PNP_UninstallDevInst failed uninstall of %ws (this root device is not disableable)\n",
                           pDeviceID));

                Status = CR_NOT_DISABLEABLE;

            } else {

                //
                // do the volatile-copy-thing
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_REGISTRY,
                           "UMPNPMGR: PNP_UninstallDevInst doing volatile key thing on %ws\n",
                           pDeviceID));

                Status = UninstallRealDevice(pDeviceID);
            }

        } else {

            //-------------------------------------------------------------
            // device is a phantom
            //-------------------------------------------------------------

            //
            // deregister the device, and delete the registry keys.
            //
            Status = UninstallPhantomDevice(pDeviceID);
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }

            //
            // if it is a root enumerated device, we need to reenumerate the
            // root so that the PDO will go away, otherwise a new device could
            // be created and the root enumerator would get very confused.
            //
            if (IsDeviceRootEnumerated(pDeviceID)) {
                ReenumerateDevInst(pszRegRootEnumerator, FALSE, 0);
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

   return Status;

} // PNP_UninstallDevInst



CONFIGRET
PNP_AddID(
   IN handle_t   hBinding,
   IN LPCWSTR    pszDeviceID,
   IN LPCWSTR    pszID,
   IN ULONG      ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager
  CM_Add_ID routine. It adds a hardware or compatible ID to
  the registry for this device instance.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       The device instance to add an ID for.

   pszID             The hardware or compatible ID to add.

   ulFlags           Specifies the type of ID to add.
                     May be one of the following two values:

                       CM_ADD_ID_HARDWARE   -- add hardware ID

                       CM_ADD_ID_COMPATIBLE -- add compatible ID

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   Otherwise it returns one of the CR_ERROR codes.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szCurrentID[REGSTR_VAL_MAX_HCID_LEN];
    ULONG       ulLength = 0, transferLength, type;
    size_t      IDLen = 0;


    try {
        //
        // Verify client "write" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_WRITE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_ADD_ID_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pszID)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Make sure the NULL-terminated ID, plus the double-NULL terminating
        // character is not larger than the max size for a multi-sz hardware or
        // compatible id.
        //
        if (FAILED(StringCchLength(
                       pszID,
                       REGSTR_VAL_MAX_HCID_LEN - 1,
                       &IDLen))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        ASSERT((IDLen + 2) <= REGSTR_VAL_MAX_HCID_LEN);

        szCurrentID[0] = L'\0';

        ulLength = REGSTR_VAL_MAX_HCID_LEN * sizeof(WCHAR);
        transferLength = ulLength;

        Status = PNP_GetDeviceRegProp(hBinding,
                                      pszDeviceID,
                                      (ulFlags == CM_ADD_ID_HARDWARE)? CM_DRP_HARDWAREID : CM_DRP_COMPATIBLEIDS,
                                      &type,
                                      (LPBYTE)szCurrentID,
                                      &transferLength,
                                      &ulLength,
                                      0);
        if (Status == CR_SUCCESS) {

            if (!MultiSzSearchStringW(szCurrentID, pszID)) {
                //
                // This ID is not already in the list, so append the new ID
                // to the end of the existing IDs and write it back to the
                // registry
                //
                ulLength = REGSTR_VAL_MAX_HCID_LEN*sizeof(WCHAR);
                if (MultiSzAppendW(szCurrentID,
                                   &ulLength,
                                   pszID)) {

                    Status = PNP_SetDeviceRegProp(hBinding,
                                                  pszDeviceID,
                                                  (ulFlags == CM_ADD_ID_HARDWARE)? CM_DRP_HARDWAREID : CM_DRP_COMPATIBLEIDS,
                                                  REG_MULTI_SZ,
                                                  (LPBYTE)szCurrentID,
                                                  ulLength,
                                                  0);
                } else {
                    //
                    // Couldn't append the new ID to the multi-sz.
                    //
                    Status = CR_FAILURE;
                    goto Clean0;
                }
            }

        } else {
            //
            // write out the id with a double null terminator
            //
            PWCHAR pszDestEnd = NULL;
            size_t cchRemaining = 0;

            if (FAILED(StringCchCopyEx(
                           szCurrentID,
                           SIZECHARS(szCurrentID),
                           pszID,
                           &pszDestEnd,
                           &cchRemaining,
                           STRSAFE_NULL_ON_FAILURE))) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            ASSERT(pszDestEnd != NULL);
            ASSERT(cchRemaining > 0);

            if (cchRemaining < 2) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            pszDestEnd[0] = L'\0';
            pszDestEnd[1] = L'\0';

            if (FAILED(StringCchLength(
                           szCurrentID,
                           REGSTR_VAL_MAX_HCID_LEN - 1,
                           &IDLen))) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            ASSERT((IDLen + 1) < REGSTR_VAL_MAX_HCID_LEN);

            Status = PNP_SetDeviceRegProp(hBinding,
                                          pszDeviceID,
                                          (ulFlags == CM_ADD_ID_HARDWARE)? CM_DRP_HARDWAREID : CM_DRP_COMPATIBLEIDS,
                                          REG_MULTI_SZ,
                                          (LPBYTE)szCurrentID,
                                          (ULONG)((IDLen+2)*sizeof(WCHAR)),
                                          0);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

   return Status;

} // PNP_AddID



CONFIGRET
PNP_RegisterDriver(
    IN handle_t hBinding,
    IN LPCWSTR  pszDeviceID,
    IN ULONG    ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager
  CM_Register_Device_Driver routine. It setups flags for the
  driver/device and enumerates it.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       The device instance to register the driver for.

   ulFlags           Flags associated with the driver.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   Otherwise it returns one of the CR_ERROR codes.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulStatusFlag = 0;

    try {
        //
        // Verify client "execute" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_EXECUTE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Verify client privilege
        //
        if (!VerifyClientPrivilege(hBinding,
                                   SE_LOAD_DRIVER_PRIVILEGE,
                                   L"Device Action (register device driver)")) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_REGISTER_DEVICE_DRIVER_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        SetDeviceStatus(pszDeviceID, ulStatusFlag, 0);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
    }

    return Status;

} // PNP_RegisterDriver



CONFIGRET
PNP_QueryRemove(
   IN  handle_t         hBinding,
   IN  LPCWSTR          pszDeviceID,
   OUT PPNP_VETO_TYPE   pVetoType,
   OUT LPWSTR           pszVetoName,
   IN  ULONG            ulNameLength,
   IN  ULONG            ulFlags
   )

/*++

Routine Description:

   This is the RPC server entry point for the CM_Query_And_Remove_SubTree
   routine.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Device instance to query and remove.

   ulFlags           Specifies flags describing how the query removal
                     should be processed.

                     Currently, the following flags are defined:
                       CM_REMOVE_UI_OK
                       CM_REMOVE_UI_NOT_OK,
                       CM_REMOVE_NO_RESTART,

Return Value:

   If the function succeeds, the return value is CR_SUCCESS. Otherwise it
   returns a CR_ error code.

Note:

   Note that this routine actually checks for presence of the CM_REMOVE_* flags,
   not the CR_QUERY_REMOVE_* flags.  Note that currently the following
   CM_QUERY_REMOVE_* and CM_REMOVE_* flags are defined:

     CM_QUERY_REMOVE_UI_OK,     ==   CM_REMOVE_UI_OK
     CM_QUERY_REMOVE_UI_NOT_OK  ==   CM_REMOVE_UI_NOT_OK
                                     CM_REMOVE_NO_RESTART

   Which is why we can simply check for the CM_REMOVE_* flags.

   Also, note that currently the CM_REMOVE_UI_OK and CM_REMOVE_UI_NOT_OK flags
   are ignored here on the server side.  User interface dialogs are displayed
   based on whether veto type and veto name buffers are supplied, so the client
   has used these flags to determine whether a buffer was to be supplied or not.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;

    try {
        //
        // Verify client "execute" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_EXECUTE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Verify client privilege
        //
        if (!VerifyClientPrivilege(hBinding,
                                   SE_LOAD_DRIVER_PRIVILEGE,
                                   L"Device Action (query-remove and remove device)")) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_REMOVE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID) ||
            IsRootDeviceID(pszDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        Status = QueryAndRemoveSubTree(pszDeviceID,
                                       pVetoType,
                                       pszVetoName,
                                       ulNameLength,
                                       (ulFlags & CM_REMOVE_NO_RESTART) ?
                                       PNP_QUERY_AND_REMOVE_NO_RESTART :
                                       0);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_QueryRemove



CONFIGRET
PNP_DisableDevInst(
   IN  handle_t         hBinding,
   IN  LPCWSTR          pszDeviceID,
   OUT PPNP_VETO_TYPE   pVetoType,
   OUT LPWSTR           pszVetoName,
   IN  ULONG            ulNameLength,
   IN  ULONG            ulFlags
   )

/*++

Routine Description:

   This is the RPC server entry point for the CM_Disable_DevNode_Ex routine.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Device instance to disable.

   ulFlags           May specify CM_DISABLE_BITS.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS. Otherwise it
   returns a CR_ error code.

Note:

   Note that although the client may supply flags to this routine, they are not
   used.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;

    try {
        //
        // Verify client "execute" access
        //
        if (!VerifyClientAccess(hBinding,
                                PLUGPLAY_EXECUTE)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Verify client privilege
        //
        if (!VerifyClientPrivilege(hBinding,
                                   SE_LOAD_DRIVER_PRIVILEGE,
                                   L"Device Action (disable device)")) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_DISABLE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID) ||
            IsRootDeviceID(pszDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // NOTE: We enter a critical section here to guard against concurrent
        // read/write operations to the "DisableCount" registry value of any
        // single device instance by DisableDevInst (below), and SetupDevInst,
        // EnableDevInst (called by PNP_DeviceInstanceAction).
        //
        PNP_ENTER_SYNCHRONOUS_CALL();

        Status = DisableDevInst(pszDeviceID,
                                pVetoType,
                                pszVetoName,
                                ulNameLength,
                                TRUE);

        PNP_LEAVE_SYNCHRONOUS_CALL();

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_DisableDevInst



CONFIGRET
PNP_RequestDeviceEject(
    IN  handle_t        hBinding,
    IN  LPCWSTR         pszDeviceID,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulPropertyData, ulDataSize, ulTransferLen, ulDataType;
    BOOL        bDockDevice = FALSE;

    try {
        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Do the appropriate security test
        //
        ulDataSize = ulTransferLen = sizeof(ULONG);
        if (CR_SUCCESS == PNP_GetDeviceRegProp(NULL,
                                               pszDeviceID,
                                               CM_DRP_CAPABILITIES,
                                               &ulDataType,
                                               (LPBYTE)&ulPropertyData,
                                               &ulTransferLen,
                                               &ulDataSize,
                                               0)) {

            if (ulPropertyData & CM_DEVCAP_DOCKDEVICE) {
                bDockDevice = TRUE;
            }
        }

        if (bDockDevice) {
            //
            // Ejecting a dock via the CM APIs always requires the undock
            // privilege (hardware-initiated ejects are handled a little
            // differently, as they may be affected by policy).
            //

            //
            // Verify client "execute" access
            //
            if (!VerifyClientAccess(hBinding,
                                    PLUGPLAY_EXECUTE)) {
                Status = CR_ACCESS_DENIED;
                goto Clean0;
            }

            //
            // Verify client "undock" privilege
            //
            if (!VerifyClientPrivilege(hBinding,
                                       SE_UNDOCK_PRIVILEGE,
                                       L"UNDOCK: EJECT DOCK DEVICE")) {
                Status = CR_ACCESS_DENIED;
                goto Clean0;
            }

        } else {
            //
            // If the client is not interactive, or is not using the active
            // console session, we require the special load-driver privilege.
            //
            if ((!IsClientUsingLocalConsole(hBinding)) ||
                (!IsClientInteractive(hBinding))) {

                //
                // Verify client "execute" access
                //
                if (!VerifyClientAccess(hBinding,
                                        PLUGPLAY_EXECUTE)) {
                    Status = CR_ACCESS_DENIED;
                    goto Clean0;
                }

                //
                // Verify client "load driver" privilege
                //
                if (!VerifyClientPrivilege(hBinding,
                                           SE_LOAD_DRIVER_PRIVILEGE,
                                           L"Device Action (eject device)")) {
                    Status = CR_ACCESS_DENIED;
                    goto Clean0;
                }
            }
        }

        //
        // Call kernel-mode to eject the device node
        //
        Status = QueryAndRemoveSubTree(pszDeviceID,
                                       pVetoType,
                                       pszVetoName,
                                       ulNameLength,
                                       PNP_QUERY_AND_REMOVE_EJECT_DEVICE);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_RequestDeviceEject



//-------------------------------------------------------------------
// Private functions
//-------------------------------------------------------------------

CONFIGRET
SetupDevInst(
   IN PCWSTR   pszDeviceID,
   IN ULONG    ulFlags
   )

/*++

Routine Description:


Arguments:


Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   HKEY        hKey = NULL;
   ULONG       ulStatusFlag=0, ulProblem=0, ulDisableCount=0, ulSize=0;
   PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA ControlData;
   NTSTATUS    ntStatus = STATUS_SUCCESS;

   try {
      //
      // Validate parameters
      //
      if (IsRootDeviceID(pszDeviceID)) {
         goto Clean0;
      }

      if (INVALID_FLAGS(ulFlags, CM_SETUP_BITS)) {
          Status = CR_INVALID_FLAG;
          goto Clean0;
      }

      switch(ulFlags) {

         case CM_SETUP_DOWNLOAD:
         case CM_SETUP_WRITE_LOG_CONFS:
            //
            // On NT, these values are a no-op.
            //
            break;

         case CM_SETUP_DEVNODE_READY:
         case CM_SETUP_DEVNODE_RESET:  

             ulDisableCount = 0;
             if (RegOpenKeyEx(ghEnumKey, pszDeviceID, 0, KEY_READ | KEY_WRITE,
                             &hKey) == ERROR_SUCCESS) {

                //
                // Check the disable count, if greater than zero, do nothing
                //
                ulSize = sizeof(ulDisableCount);
                RegQueryValueEx(hKey, pszRegValueDisableCount, NULL, NULL,
                                    (LPBYTE)&ulDisableCount, &ulSize);
            }

            if (ulDisableCount > 0) {

                break;
            }

            GetDeviceStatus(pszDeviceID, &ulStatusFlag, &ulProblem);

            //
            // If there's no problem or if install was done already
            // (immediately) then there's nothing more to do
            //
            if (ulStatusFlag & DN_STARTED) {
               break;
            }

            if (ulStatusFlag & DN_HAS_PROBLEM) {
                //
                // reset the problem and set status to need to enum
                //
                Status = ClearDeviceStatus(pszDeviceID, DN_HAS_PROBLEM, ulProblem);
            }

            if (Status == CR_SUCCESS) {

                //
                // Have kernel-mode pnp manager start the driver/device now.
                // If kernel-mode doesn't have a pdo for this device then it's
                // probably either a Win32 service or a phantom devnode.
                //

                memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
                RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
                ControlData.Flags = 0;

                if (ulFlags == CM_SETUP_DEVNODE_READY) {

                    ntStatus = NtPlugPlayControl(PlugPlayControlStartDevice,
                                                 &ControlData,
                                                 sizeof(ControlData));

                } else {

                    ntStatus = NtPlugPlayControl(PlugPlayControlResetDevice,
                                                 &ControlData,
                                                 sizeof(ControlData));
                }
            }

            break;

         case CM_SETUP_PROP_CHANGE:
             //
             // Not sure what Win9x does with this, but it ain't implemented on
             // NT.  Let fall through to the default (invalid flag) case...
             //

         default:
             Status = CR_INVALID_FLAG;
      }

   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   if (hKey != NULL) {
      RegCloseKey(hKey);
   }

   return Status;

} // SetupDevInst



CONFIGRET
EnableDevInst(
    IN PCWSTR   pszDeviceID,
    IN BOOL     UseDisableCount
    )

/*++

Routine Description:

    This routine performs the server-side work for CM_Enable_DevNode.  It
    disables the specified device ID

Arguments:

    pszDeviceID    String that contains the device id to enable

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       RegStr[MAX_PATH];
    ULONG       ulDisableCount, ulProblem = 0, ulStatus = 0, ulSize;


    try {

        //
        // Verify it isn't the root, can't disable/enable the root. We can
        // probably get rid of this test once we're sure that the root
        // devnode is always marded as not disablable.
        //

        if (IsRootDeviceID(pszDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Open a key to the specified device instances volatile control key.
        // This is also a partial check whether the device is really present
        // (if so then it has a Control key).
        //

        if (FAILED(StringCchPrintf(
                       RegStr,
                       SIZECHARS(RegStr),
                       L"%s\\%s",
                       pszDeviceID,
                       pszRegKeyDeviceControl))) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if (RegOpenKeyEx(ghEnumKey, RegStr, 0, KEY_READ | KEY_WRITE,
                         &hKey) != ERROR_SUCCESS) {

            //
            // NTRAID #174944-2000/08/30-jamesca:
            // Remove dependence on the presence of volatile Control subkey
            // for present devices.
            //

            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Check the current DisableCount, if we're supposed to.
        //

        if (UseDisableCount) {

            //
            // Get the current disable count from the registry
            //

            ulSize = sizeof(ulDisableCount);
            if (RegQueryValueEx(hKey, pszRegValueDisableCount, NULL, NULL,
                                (LPBYTE)&ulDisableCount, &ulSize) != ERROR_SUCCESS) {

                //
                // disable count not set yet, assume zero
                //

                ulDisableCount = 0;
            }

            //
            // if the DisableCount is zero, then we're already enabled
            //

            if (ulDisableCount > 0) {
                //
                // Decrement disable count.  If the disable count is greater than one,
                // then just return (disable count must drop to zero in order to
                // actually reenable)
                //

                ulDisableCount--;

                RegSetValueEx(hKey, pszRegValueDisableCount, 0, REG_DWORD,
                              (LPBYTE)&ulDisableCount, sizeof(ulDisableCount));

                if (ulDisableCount > 0) {
                    goto Clean0;   // success
                }
            }
        }

        //
        // Retrieve the problem and status values
        //

        if (GetDeviceStatus(pszDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) {

            //
            // If the problem is only that the device instance is disabled,
            // then reenable it now
            //

            if ((ulStatus & DN_HAS_PROBLEM) && (ulProblem == CM_PROB_DISABLED)) {

                Status = SetupDevInst(pszDeviceID, CM_SETUP_DEVNODE_READY);
            }

        } else {

            //
            // The device isn't currently active or it is a service.
            //

            Status = CR_SUCCESS;
        }


        //
        // For now I'm not doing anything if there was a problem other than
        // not being enabled.
        //

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // EnableDevInst



CONFIGRET
DisableDevInst(
    IN  PCWSTR          pszDeviceID,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG           ulNameLength,
    IN  BOOL            UseDisableCount
    )

/*++

Routine Description:

    This routine performs the server-side work for CM_Disable_DevNode.  It
    disables the specified device ID.

Arguments:

    pszDeviceID    String that contains the device id to disable

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

Note:

    This routine does not verify that a client is granted the pre-requisite
    access, or possesses the required privilege(s) to perform this operation.
    It is the caller's responsibility to perform these checks prior to calling
    this routine.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       RegStr[MAX_PATH];
    ULONG       ulDisableCount=0, ulProblem=0, ulStatus=0, ulSize=0;
    PNP_VETO_TYPE VetoType;


    try {

        //
        // Verify it isn't the root, can't disable/enable the root. We can
        // probably get rid of this test once we're sure that the root
        // devnode is always marked as not disablable.
        //

        if (IsRootDeviceID(pszDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Open a key to the specified device instances volatile control key.
        // This is also a partial check whether the device is really present
        // (if so then it has a Control key).
        //

        if (FAILED(StringCchPrintf(
                       RegStr,
                       SIZECHARS(RegStr),
                       L"%s\\%s",
                       pszDeviceID,
                       pszRegKeyDeviceControl))) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if (RegOpenKeyEx(ghEnumKey, RegStr, 0, KEY_READ | KEY_WRITE,
                         &hKey) != ERROR_SUCCESS) {

            //
            // NTRAID #174944-2000/08/30-jamesca:
            // Remove dependence on the presence of volatile Control subkey
            // for present devices.
            //

            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }


        //
        // Check the current DisableCount, if we're supposed to.
        //

        if (UseDisableCount) {

            //
            // Get the current disable count from the registry.
            //

            ulSize = sizeof(ulDisableCount);
            if (RegQueryValueEx(hKey, pszRegValueDisableCount, NULL, NULL,
                                (LPBYTE)&ulDisableCount, &ulSize) != ERROR_SUCCESS) {

                //
                // disable count not set yet, assume zero
                //

                ulDisableCount = 0;
            }

        }

        //
        // If the disable count is currently zero (or we're not using it at
        // all), then this is the first disable, so there's work to do.
        // Otherwise, we just increment the disable count and resave it in the
        // registry.
        //

        if ((!UseDisableCount) || (ulDisableCount == 0)) {

            //
            // determine if the device instance is stopable
            //

            if (GetDeviceStatus(pszDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) {

                if (!(ulStatus & DN_DISABLEABLE)) {
                    Status = CR_NOT_DISABLEABLE;
                    goto Clean0;
                }

                //
                // Attempt to query remove and remove this device instance.
                //

                VetoType = PNP_VetoTypeUnknown;
                Status = QueryAndRemoveSubTree(pszDeviceID,
                                               &VetoType,
                                               pszVetoName,
                                               ulNameLength,
                                               PNP_QUERY_AND_REMOVE_DISABLE);
                if(pVetoType != NULL) {
                    *pVetoType = VetoType;
                }
                if (Status != CR_SUCCESS) {
                    if (VetoType == PNP_VetoNonDisableable) {
                        //
                        // specially handle this Veto case
                        // this case is unlikely to occur unless something becomes
                        // non-disableable between the status-check and when we
                        // try to remove it
                        //
                        Status = CR_NOT_DISABLEABLE;
                    }
                    goto Clean0;
                }
            } else {

                //
                // The device isn't active or it is a service.
                //

                Status = CR_SUCCESS;
            }
        }

        if (UseDisableCount) {

            //
            // update and save the disable count
            //

            ulDisableCount++;
            RegSetValueEx(hKey, pszRegValueDisableCount, 0, REG_DWORD,
                          (LPBYTE)&ulDisableCount, sizeof(ulDisableCount));
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // DisableDevInst



CONFIGRET
ReenumerateDevInst(
    IN PCWSTR   pszDeviceID,
    IN BOOL     EnumSubTree,
    IN ULONG    ulFlags
    )

/*++

Routine Description:

   This routine performs the server-side work for CM_Reenumerate_DevNode.  It
   reenumerates the specified device instance.

Arguments:

   pszDeviceID    String that contains the device id to reenumerate.

   EnumSubTree    Specifies whether to reenumerate the entire device subtree.

   ulFlags        Any enumeration control flags.

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA ControlData;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    ULONG       ulEnumFlags = 0;
    QI_CONTEXT  qiContext;

    //
    // NOTE: For Windows 95, the devnode is marked as needing to be
    // reenumerating (by or'ing StatusFlags with DN_NEED_TO_ENUM), then
    // sometime later, after the initial flurry of reenumeration requests,
    // the whole tree is processed
    //

    if (INVALID_FLAGS(ulFlags, CM_REENUMERATE_BITS)) {
        return CR_INVALID_FLAG;
    }

    try {

        //
        // Attempt to handle this via kernel-mode, if kernel-mode
        // doesn't have a pdo for this device then it's probably either a
        // Win32 service or a phantom devnode.
        //

        if (!EnumSubTree) {
            ulEnumFlags |= PNP_ENUMERATE_DEVICE_ONLY;
        }

        if (ulFlags & CM_REENUMERATE_ASYNCHRONOUS) {
            ulEnumFlags |= PNP_ENUMERATE_ASYNCHRONOUS;
        }

        if (ulFlags & CM_REENUMERATE_RETRY_INSTALLATION) {

            qiContext.HeadNodeSeen = FALSE;
            qiContext.SingleLevelEnumOnly = !EnumSubTree;
            qiContext.Status = CR_SUCCESS;

            Status = EnumerateSubTreeTopDownBreadthFirst(
                NULL,
                pszDeviceID,
                QueueInstallationCallback,
                (PVOID) &qiContext
                );

            if (Status != CR_SUCCESS) {

                return Status;
            }

            if (qiContext.Status != CR_SUCCESS) {

                return qiContext.Status;
            }
        }

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        ControlData.Flags = ulEnumFlags;

        ntStatus = NtPlugPlayControl(PlugPlayControlEnumerateDevice,
                                     &ControlData,
                                     sizeof(ControlData));

        if (!NT_SUCCESS(ntStatus)) {
            if (ntStatus == STATUS_NO_SUCH_DEVICE) {
                Status = CR_INVALID_DEVNODE;    // probably a win32 service
            } else {
                Status = MapNtStatusToCmError(ntStatus);
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // ReenumerateDevInst



CONFIGRET
QueryAndRemoveSubTree(
   IN  PCWSTR           pszDeviceID,
   OUT PPNP_VETO_TYPE   pVetoType,
   OUT LPWSTR           pszVetoName,
   IN  ULONG            ulNameLength,
   IN  ULONG            ulFlags
   )

/*++

Routine Description:

   This routine performs the server-side work for CM_Query_Remove_Subtree.  It
   determines whether subtree can be removed.

Arguments:

   pszDeviceID    String that contains the device id to query remove

   ulFlags        Specifies flags for PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA
                  May be one of:
                    PNP_QUERY_AND_REMOVE_NO_RESTART
                    PNP_QUERY_AND_REMOVE_DISABLE
                    PNP_QUERY_AND_REMOVE_UNINSTALL
                    PNP_QUERY_AND_REMOVE_EJECT_DEVICE

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA ControlData;
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pVetoType)) {
        *pVetoType = 0;
    }

    if (ARGUMENT_PRESENT(pszVetoName) && (ulNameLength > 0)) {
        *pszVetoName = L'\0';
    }

    //---------------------------------------------------------------------
    // Attempt to handle this via kernel-mode first, if kernel-mode
    // doesn't have a pdo for this device then it's probably either a
    // Win32 service or a phantom devnode, so we'll do the old default
    // Windows NT 4.0 behaviour for now.
    //---------------------------------------------------------------------

    memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA));
    RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
    ControlData.Flags = ulFlags;
    ControlData.VetoType = PNP_VetoTypeUnknown;
    ControlData.VetoName = pszVetoName;
    ControlData.VetoNameLength = ulNameLength;

    ntStatus = NtPlugPlayControl(PlugPlayControlQueryAndRemoveDevice,
                                 &ControlData,
                                 sizeof(ControlData));

    if (!NT_SUCCESS(ntStatus)) {
        if (ntStatus == STATUS_NO_SUCH_DEVICE) {
            Status = CR_INVALID_DEVNODE;    // probably a win32 service or legacy driver
        } else if (ntStatus == STATUS_PLUGPLAY_QUERY_VETOED) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS,
                       "Query vetoed: Type = %d, Name = %ws\n",
                       ControlData.VetoType,
                       ControlData.VetoName));

            if (pVetoType != NULL) {
                *pVetoType = ControlData.VetoType;
            }

            if (ARGUMENT_PRESENT(pszVetoName) &&
                (ulNameLength > ControlData.VetoNameLength)) {
                pszVetoName[ControlData.VetoNameLength] = L'\0';
            }
            Status = CR_REMOVE_VETOED;
        } else {
            Status = MapNtStatusToCmError(ntStatus);
        }
    }

    return Status;

} // QueryRemoveSubTree



CONFIGRET
CreateDefaultDeviceInstance(
    IN PCWSTR   pszDeviceID,
    IN PCWSTR   pszParentID,
    IN BOOL     bPhantom,
    IN BOOL     bMigrated
    )

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKey1 = NULL, hKey2 = NULL;
    WCHAR       szBase[MAX_DEVICE_ID_LEN];
    WCHAR       szDevice[MAX_DEVICE_ID_LEN];
    WCHAR       szInstance[MAX_DEVICE_ID_LEN];
    WCHAR       RegStr[MAX_DEVICE_ID_LEN];
    ULONG       ulDisposition=0, i=0;

    UNREFERENCED_PARAMETER(pszParentID);

    //
    // make sure we were specified a valid instance path.
    //
    if (!IsLegalDeviceId(pszDeviceID)) {
        Status = CR_INVALID_DEVNODE;
        goto Clean0;
    }

    //
    // split the supplied instance path into enumerator, device, and instance
    //
    SplitDeviceInstanceString(pszDeviceID, szBase, szDevice, szInstance);

    //
    // open a key to base enumerator (create if doesn't already exist)
    //
    RegStatus = RegCreateKeyEx(ghEnumKey, szBase, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                               NULL, &hKey2, NULL);

    if (RegStatus != ERROR_SUCCESS) {
        Status = CR_REGISTRY_ERROR;
        goto Clean0;
    }

    //
    // open a key to device (create if doesn't already exist)
    //
    RegStatus = RegCreateKeyEx(hKey2, szDevice, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                               NULL, &hKey1, NULL);

    if (RegStatus != ERROR_SUCCESS) {
        Status = CR_REGISTRY_ERROR;
        goto CleanupOnFailure;
    }

    RegCloseKey(hKey2);           // done with Base Key
    hKey2 = NULL;

    //
    // open a key to instance (if already exists)
    //
    RegStatus = RegOpenKeyEx(hKey1, szInstance, 0, KEY_SET_VALUE, &hKey2);

    //
    // if the key was migrated, an existing instance id should have been
    // supplied.  for non-migrated instances, the key should not exist yet.
    //
    if (bMigrated) {
        ASSERT(RegStatus == ERROR_SUCCESS);
    } else {
        ASSERT(RegStatus != ERROR_SUCCESS);
    }

    //
    // if the specified key exists, but the instance is not migrated, find an
    // unused instance value.  if a migrated instance was specified, don't
    // bother finding an unused instance - we can just use this one.
    //
    if ((RegStatus == ERROR_SUCCESS) && (!bMigrated)) {
        //
        // find a new instance id to use
        //
        RegCloseKey(hKey2);     // done with Instance key
        hKey2 = NULL;

        for (i=0; i <= 9999; i++) {

            if (SUCCEEDED(StringCchPrintf(
                              szInstance,
                              SIZECHARS(szInstance),
                              L"%04u",
                              i))) {

                //
                // attemnpt to open this instance key
                //
                RegStatus =
                    RegOpenKeyEx(
                        hKey1,
                        szInstance,
                        0,
                        KEY_SET_VALUE,
                        &hKey2);

                if (RegStatus != ERROR_SUCCESS) {
                    //
                    // instance key does not exist, use this instance
                    //
                    break;
                }

                //
                // instance key exists, try next one
                //
                RegCloseKey(hKey2);
                hKey2 = NULL;
            }
        }

        if (i > 9999) {
            Status = CR_FAILURE;     // we ran out of instances (unlikely)
            goto CleanupOnFailure;
        }
    }

    if (hKey2 == NULL) {
        //
        // open the device instance key, if we haven't already.
        //
        RegStatus = RegCreateKeyEx(hKey1, szInstance, 0, NULL,
                                   REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                   NULL, &hKey2, &ulDisposition);

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto CleanupOnFailure;
        }

        ASSERT(ulDisposition == REG_CREATED_NEW_KEY);

    } else {
        //
        // We already opened the instance key above.
        //
        ASSERT(RegStatus == ERROR_SUCCESS);
    }

    RegCloseKey(hKey1);           // done with device key
    hKey1 = NULL;

    //
    // set the default device instance values
    //

    if (bPhantom) {
        //
        // phantoms are not present by definition
        //
        MarkDevicePhantom(hKey2, TRUE);
    }

    //
    // go ahead and create the volatile Control key at this point.
    //

    RegCreateKeyEx(hKey2, pszRegKeyDeviceControl, 0, NULL,
                   REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
                   NULL, &hKey1, &ulDisposition);

    ASSERT(ulDisposition == REG_CREATED_NEW_KEY);

    RegCloseKey(hKey2);           // done with instance key
    hKey2 = NULL;

    goto Clean0;    // success


CleanupOnFailure:

    //
    // attempt to cleanup the device instance (don't delete device or base if
    // other subkeys under it).
    //

    RegDeleteKey(ghEnumKey, pszDeviceID);       // delete instance

    if (SUCCEEDED(StringCchPrintf(
                      RegStr,
                      SIZECHARS(RegStr),
                      L"%s\\%s",
                      szBase,
                      szDevice))) {
        RegDeleteKey(ghEnumKey, RegStr);
    }

 Clean0:

    if (hKey1 != NULL) {
        RegCloseKey(hKey1);
    }
    if (hKey2 != NULL) {
        RegCloseKey(hKey2);
    }

    return Status;

} // CreateDefaultDeviceInstance



ULONG
GetCurrentConfigFlag(
   IN PCWSTR   pDeviceID
   )
{
   HKEY     hKey;
   WCHAR    RegStr[MAX_PATH];
   ULONG    ulSize = 0, ulCSConfigFlag = 0;


   //
   // open a key to the current hardware profile for this device instance
   // System\CCS\Hardware Profiles\Current\System\Enum
   //
   if (FAILED(StringCchPrintf(
                  RegStr,
                  SIZECHARS(RegStr),
                  L"%s\\%s\\%s\\%s",
                  pszRegPathHwProfiles,
                  pszRegKeyCurrent,
                  pszRegPathEnum,
                  pDeviceID))) {
       return 0;
   }

   if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, KEY_QUERY_VALUE, &hKey)
            != ERROR_SUCCESS) {
      return 0;
   }

   //
   // retrieve the config specific flag
   //
   ulSize = sizeof(ulCSConfigFlag);

   if (RegQueryValueEx(
         hKey, pszRegValueCSConfigFlags, NULL, NULL,
         (LPBYTE)&ulCSConfigFlag, &ulSize) != ERROR_SUCCESS) {
      //
      // status flags not set yet, assume zero
      //
      ulCSConfigFlag = 0;
   }

   RegCloseKey(hKey);

   return ulCSConfigFlag;

} // GetCurrentConfigFlag



BOOL
MarkDevicePhantom(
   IN HKEY     hKey,
   IN ULONG    ulValue
   )
{
   //
   // a phantom device should have a Phantom value of TRUE
   //
   RegSetValueEx(
         hKey, pszRegValuePhantom, 0, REG_DWORD,
         (LPBYTE)&ulValue, sizeof(ULONG));

   return TRUE;

} // MarkDevicePhantom



CONFIGRET
GenerateDeviceInstance(
   OUT LPWSTR   pszFullDeviceID,
   IN  LPWSTR   pszDeviceID,
   IN  ULONG    ulDevIdLen
   )
{
   LONG     RegStatus = ERROR_SUCCESS;
   WCHAR    RegStr[MAX_PATH];
   HKEY     hKey;
   ULONG    ulInstanceID = 0;
   LPWSTR   p;


   //
   // validate the device id component (can't have invalid character or a
   // backslash)
   //
   for (p = pszDeviceID; *p; p++) {
      if (*p <= TEXT(' ')  ||
          *p > (WCHAR)0x7F ||
          *p == TEXT('\\')) {
          return CR_INVALID_DEVICE_ID;
      }
   }

   //
   // make sure the supplied buffer is large enough to hold the name of the ROOT
   // enumerator, the supplied device id, a generated instance id ('0000'), two
   // path separator characters, plus a terminating NULL character.
   //
   if (FAILED(StringCchCopyEx(
                  pszFullDeviceID,
                  ulDevIdLen,
                  pszRegKeyRootEnum,
                  NULL, NULL,
                  STRSAFE_NULL_ON_FAILURE))) {
       return CR_BUFFER_SMALL;
   }

   CharUpper(pszFullDeviceID);

   if (FAILED(StringCchCatEx(pszFullDeviceID,
                             ulDevIdLen,
                             L"\\",
                             NULL, NULL,
                             STRSAFE_NULL_ON_FAILURE))) {
       return CR_BUFFER_SMALL;
   }

   if (FAILED(StringCchCatEx(pszFullDeviceID,
                             ulDevIdLen,
                             pszDeviceID,
                             NULL, NULL,
                             STRSAFE_NULL_ON_FAILURE))) {
       return CR_BUFFER_SMALL;
   }

   //
   // try opening instance ids until we find one that doesn't already exist
   //
   for (ulInstanceID = 0; ulInstanceID <= 9999; ulInstanceID++) {

       if (SUCCEEDED(StringCchPrintf(
                         RegStr,
                         SIZECHARS(RegStr),
                         L"%s\\%04u",
                         pszFullDeviceID,
                         ulInstanceID))) {

           //
           // attemnpt to open this instance key
           //
           RegStatus =
               RegOpenKeyEx(
                   ghEnumKey,
                   RegStr,
                   0,
                   KEY_QUERY_VALUE,
                   &hKey);

           if (RegStatus != ERROR_SUCCESS) {
               //
               // instance key does not exist, use this instance
               //
               break;
           }

           //
           // instance key exists, try next one
           //
           RegCloseKey(hKey);
           hKey = NULL;
       }
   }

   if (ulInstanceID > 9999) {
      return CR_FAILURE;     // instances all used up, seems unlikely
   }

   if (FAILED(StringCchCopyEx(
                  pszFullDeviceID,
                  ulDevIdLen,
                  RegStr,
                  NULL, NULL,
                  STRSAFE_NULL_ON_FAILURE))) {
       return CR_FAILURE;
   }

   return CR_SUCCESS;

} // GenerateDeviceInstance



CONFIGRET
UninstallRealDevice(
   IN LPCWSTR  pszDeviceID
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus;
   WCHAR       RegStr[MAX_CM_PATH];
   WCHAR       szProfile[MAX_PROFILE_ID_LEN];
   ULONG       ulLen = 0, ulIndex = 0;
   HKEY        hKeyHwProfiles = NULL;


   //---------------------------------------------------------------------
   // This is the case where a real device id couldn't be stopped, so we
   // cannot really safely delete the device id at this point since the
   // service may still try to use it. Instead, I'll make this device
   // id registry key volatile so that it will eventually go away when
   // the system is shutdown.  To make the key volatile, I have to copy
   // it to a temporary spot, delete the original key and recreate it
   // as a volatile key and copy everything back.
   //---------------------------------------------------------------------


   //
   // first, convert the device instance key under the main Enum
   // branch to volatile
   //

   Status = MakeKeyVolatile(pszRegPathEnum, pszDeviceID);

   if (Status != CR_SUCCESS) {
       goto Clean0;
   }

   //
   // next, check each hardware profile and delete any entries for this
   // device instance.
   //

   RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegPathHwProfiles,
                            0, KEY_READ,
                            &hKeyHwProfiles);

   if (RegStatus == ERROR_SUCCESS) {

       //
       // Enumerate all existing profile-specific Enum branches.
       //

       ulIndex = 0;

       for ( ; ; ) {

           ulLen = SIZECHARS(szProfile);

           RegStatus = RegEnumKeyEx(hKeyHwProfiles, ulIndex++,
                                    szProfile, &ulLen,
                                    NULL, NULL, NULL, NULL);

           if (RegStatus == ERROR_NO_MORE_ITEMS) {
               //
               // No more keys to enumerate, stop enumerating.
               //
               break;

           } else if (RegStatus == ERROR_MORE_DATA) {
               //
               // Key is not a valid profile key, skip to the next.
               //
               continue;

           } else if (RegStatus != ERROR_SUCCESS) {
               //
               // Some other error, stop enumerating.
               //
               break;

           } else {
               //
               // Form the profile-specific Enum key path.
               //

               if (SUCCEEDED(StringCchPrintf(
                                 RegStr,
                                 SIZECHARS(RegStr),
                                 L"%s\\%s\\%s",
                                 pszRegPathHwProfiles,
                                 szProfile,
                                 pszRegPathEnum))) {

                   //
                   // Attempt to make the profile-specific device instance key
                   // volatile.  Ignore the status for profile-specific keys since
                   // they may not exist.
                   //

                   MakeKeyVolatile(RegStr, pszDeviceID);
               }
           }
       }

       RegCloseKey(hKeyHwProfiles);
   }

   //
   // finally, mark the device as being removed
   //

   SetDeviceStatus(pszDeviceID, DN_WILL_BE_REMOVED, 0);

 Clean0:

   return Status;

} // UninstallRealDevice



CONFIGRET
UninstallPhantomDevice(
    IN  LPCWSTR  pszDeviceID
    )
{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus;
   NTSTATUS    NtStatus = STATUS_SUCCESS;
   PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA  ControlData;
   WCHAR       szEnumerator[MAX_DEVICE_ID_LEN],
               szDevice[MAX_DEVICE_ID_LEN],
               szInstance[MAX_DEVICE_ID_LEN];
   WCHAR       RegStr[MAX_CM_PATH];
   WCHAR       szProfile[MAX_PROFILE_ID_LEN];
   ULONG       ulIndex = 0, ulLen = 0;
   HKEY        hKeyHwProfiles = NULL;


   //
   // 1. Deregister the original device id (only on phantoms)
   //

   memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
   RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
   ControlData.Flags = 0;

   NtStatus = NtPlugPlayControl(PlugPlayControlDeregisterDevice,
                                &ControlData,
                                sizeof(ControlData));

   //
   // Don't bother with the status here, the device might not have
   // been registered which would cause the previous call to fail.
   // Keep trying to clean (uninstall) this device instance.
   //

   //
   // 2. Remove the instance under the main enum branch.  If this is the
   // only instance, then the device will be removed as well. The parent
   // key to DeletePrivateKey is the registry path up to the enumerator
   // and the child key is the device and instance.
   //

   //
   // Get the device id's component parts.
   //

   if (!SplitDeviceInstanceString(
           pszDeviceID,
           szEnumerator,
           szDevice,
           szInstance)) {
       Status = CR_FAILURE;
       goto Clean0;
   }

   if (FAILED(StringCchPrintf(
                  RegStr,
                  SIZECHARS(RegStr),
                  L"%s\\%s",
                  pszRegPathEnum,
                  szEnumerator))) {
       Status = CR_FAILURE;
       goto Clean0;
   }

   if (FAILED(StringCchCat(
                  szDevice,
                  SIZECHARS(szDevice),
                  L"\\"))) {
       Status = CR_FAILURE;
       goto Clean0;
   }

   if (FAILED(StringCchCat(
                  szDevice,
                  SIZECHARS(szDevice),
                  szInstance))) {
       Status = CR_FAILURE;
       goto Clean0;
   }

   //
   // delete the device instance key
   //

   Status = DeletePrivateKey(HKEY_LOCAL_MACHINE, RegStr, szDevice);

   if (Status != CR_SUCCESS) {
       goto Clean0;
   }

   //
   // 3. Now check each hardware profile and delete any entries for this
   // device instance.
   //

   RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegPathHwProfiles,
                            0, KEY_READ,
                            &hKeyHwProfiles);

   if (RegStatus == ERROR_SUCCESS) {

       //
       // Enumerate all existing profile-specific Enum branches.
       //

       ulIndex = 0;

       for ( ; ; ) {

           ulLen = SIZECHARS(szProfile);

           RegStatus = RegEnumKeyEx(hKeyHwProfiles, ulIndex++,
                                    szProfile, &ulLen,
                                    NULL, NULL, NULL, NULL);

           if (RegStatus == ERROR_NO_MORE_ITEMS) {
               //
               // No more keys to enumerate, stop enumerating.
               //
               break;

           } else if (RegStatus == ERROR_MORE_DATA) {
               //
               // Key is not a valid profile key, skip to the next.
               //
               continue;

           } else if (RegStatus != ERROR_SUCCESS) {
               //
               // Some other error, stop enumerating.
               //
               break;

           } else {
               //
               // Form the profile-specific registry key path.
               //

               if (SUCCEEDED(StringCchPrintf(
                                 RegStr,
                                 SIZECHARS(RegStr),
                                 L"%s\\%s\\%s\\%s",
                                 pszRegPathHwProfiles,
                                 szProfile,
                                 pszRegPathEnum,
                                 szEnumerator))) {

                   //
                   // Attempt to delete the profile-specific key for this device.
                   // Ignore the status for profile-specific keys since they may not
                   // exist. DeletePrivateKey() will remove the instance and the
                   // device, if this is the only instance.
                   //

                   DeletePrivateKey(HKEY_LOCAL_MACHINE, RegStr, szDevice);
               }
           }
       }

       RegCloseKey(hKeyHwProfiles);
   }

 Clean0:

   return Status;

} // UninstallPhantomDevice



BOOL
IsDeviceRootEnumerated(
    IN LPCWSTR  pszDeviceID
    )
{
    WCHAR  szEnumerator[MAX_DEVICE_ID_LEN],
           szDevice[MAX_DEVICE_ID_LEN],
           szInstance[MAX_DEVICE_ID_LEN];

    if (!SplitDeviceInstanceString(pszDeviceID,
                                   szEnumerator,
                                   szDevice,
                                   szInstance)) {
        return FALSE;
    }

    if (CompareString(LOCALE_INVARIANT,
                      NORM_IGNORECASE,
                      szEnumerator,
                      -1,
                      pszRegKeyRootEnum,
                      -1) == CSTR_EQUAL) {
        return TRUE;
    }

    return FALSE;

} // IsDeviceRootEnumerated



BOOL
IsDeviceRegistered(
    IN LPCWSTR  pszDeviceID,
    IN LPCWSTR  pszService
    )
{
    WCHAR   RegStr[MAX_PATH], szData[MAX_DEVICE_ID_LEN], szValue[MAX_PATH];
    HKEY    hKey = NULL;
    LONG    RegStatus = ERROR_SUCCESS;
    ULONG   ulIndex = 0, ulDataSize = 0, ulValueSize = 0, i = 0;
    BOOL    Status = FALSE;


    //
    // open the service's volatile enum registry key
    //
    if (FAILED(StringCchPrintf(
                   RegStr,
                   SIZECHARS(RegStr),
                   L"%s\\%s",
                   pszService,
                   pszRegKeyEnum))) {
        return FALSE;
    }

    RegStatus =
        RegOpenKeyEx(
            ghServicesKey,
            RegStr,
            0,
            KEY_READ,
            &hKey);
    if (RegStatus != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    //  Enumerate all the values under this key
    //
    while (RegStatus == ERROR_SUCCESS) {

        ulDataSize = MAX_DEVICE_ID_LEN * sizeof(WCHAR);
        ulValueSize = MAX_PATH;

        RegStatus = RegEnumValue(hKey, ulIndex, szValue, &ulValueSize,
                                 NULL, &i, (LPBYTE)szData, &ulDataSize);

        if (RegStatus == ERROR_SUCCESS) {

            ulIndex++;

            if (CompareString(LOCALE_INVARIANT,
                              NORM_IGNORECASE,
                              pszDeviceID,
                              -1,
                              szData,
                              -1) == CSTR_EQUAL) {
                Status = TRUE;
                break;
            }
        }
    }

    RegCloseKey(hKey);

    return Status;

} // IsDeviceRegistered



BOOL
IsPrivatePhantomFromFirmware(
    IN HKEY hKey
    )
/*++

Routine Description:

   This routine checks to see if the supplied device instance registry key is
   for a firmware mapper-created private phantom.

Arguments:

    hKey - Supplied the handle to the registry key for the device instance to
        be examined.

Return value:

    If the device instance registry key represents a firmware mapper-reported
    phantom, the return value is TRUE.  Otherwise, it is FALSE.

--*/
{
    ULONG ValueSize, Value;
    HKEY hControlKey;
    BOOL b = FALSE;

    //
    // First, make sure that this is indeed a phantom
    //
    ValueSize = sizeof(Value);
    Value = 0;

    if((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                         pszRegValuePhantom,
                                         NULL,
                                         NULL,
                                         (LPBYTE)&Value,
                                         &ValueSize))
       || !Value)
    {
        //
        // Not a phantom
        //
        goto clean0;
    }

    //
    // OK, we have a phantom--did it come from the firmware mapper?
    //
    ValueSize = sizeof(Value);
    Value = 0;

    if((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                         pszRegValueFirmwareIdentified,
                                         NULL,
                                         NULL,
                                         (LPBYTE)&Value,
                                         &ValueSize))
       || !Value)
    {
        //
        // This phantom didn't come from the firmware mapper.
        //
        goto clean0;
    }

    //
    // Finally, we need to check to see whether the device is actually present
    // on this boot.  If not, we want to return FALSE, because we don't want
    // detection modules to be registering devnodes for non-existent hardware.
    //
    if(ERROR_SUCCESS == RegOpenKeyEx(hKey,
                                     pszRegKeyDeviceControl,
                                     0,
                                     KEY_READ,
                                     &hControlKey)) {

        ValueSize = sizeof(Value);
        Value = 0;

        if((ERROR_SUCCESS == RegQueryValueEx(hControlKey,
                                             pszRegValueFirmwareMember,
                                             NULL,
                                             NULL,
                                             (LPBYTE)&Value,
                                             &ValueSize))
           && Value)
        {
            b = TRUE;
        }

        RegCloseKey(hControlKey);
    }

clean0:

    return b;

} // IsPrivatePhantomFromFirmware



CONFIGRET
EnumerateSubTreeTopDownBreadthFirst(
    IN      handle_t        BindingHandle,
    IN      LPCWSTR         DevInst,
    IN      PFN_ENUMTREE    CallbackFunction,
    IN OUT  PVOID           Context
    )
/*++

Routine Description:

    This routine walks a subtree in a breadth-first nonrecursive manner.

Arguments:

    BindingHandle       RPC Binding handle

    DevInst             InstancePath of device to begin with. It is assumed
                        that this InstancePath is valid.

    CallbackFunction    Function to call for each node in the subtree (DevInst
                        included)

    Context             Context information to pass to the callback function.


Return Value:

    CONFIGRET (Success if walk progressed through every node specified by the
               CallbackFunction, failure due to low memory, bad instance path,
               or other problems)

--*/
{
    CONFIGRET       Status = CR_SUCCESS;
    PENUM_ELEMENT   enumElement;
    ENUM_ACTION     enumAction;
    LIST_ENTRY      subTreeHead;
    PLIST_ENTRY     listEntry;
    size_t          DeviceIDLen = 0;

    //
    // This algorithm is a nonrecursive tree walk. It works by building a list.
    // Parents are removed from the head of the list and their children are
    // added to the end of the list. This enforces a breadth-first downward
    // tree walk.
    //
    InitializeListHead(&subTreeHead);

    //
    // This walk includes the head node as well, so insert it into the list.
    //
    if (!ARGUMENT_PRESENT(DevInst)) {
        return CR_INVALID_POINTER;
    }

    if (FAILED(StringCchLength(
                   DevInst,
                   MAX_DEVICE_ID_LEN,
                   &DeviceIDLen))) {
        return CR_INVALID_DEVICE_ID;
    }

    ASSERT(DeviceIDLen < MAX_DEVICE_ID_LEN);

    enumElement = (PENUM_ELEMENT)
        HeapAlloc(ghPnPHeap, 0,
                  sizeof(ENUM_ELEMENT) + (DeviceIDLen * sizeof(WCHAR)));

    if (enumElement == NULL) {
        return CR_OUT_OF_MEMORY;
    }

    if (FAILED(StringCchCopyEx(
                   enumElement->DevInst,
                   DeviceIDLen + 1,
                   DevInst,
                   NULL, NULL,
                   STRSAFE_NULL_ON_FAILURE))) {
        HeapFree(ghPnPHeap, 0, enumElement);
        return CR_FAILURE;
    }

    InsertTailList(&subTreeHead, &enumElement->ListEntry);

    //
    // Remove each entry from the head of the list on downwards.
    //

    while(!IsListEmpty(&subTreeHead)) {

        listEntry = RemoveHeadList(&subTreeHead);

        enumElement = CONTAINING_RECORD(listEntry, ENUM_ELEMENT, ListEntry);

        enumAction = CallbackFunction(enumElement->DevInst, Context);

        if (enumAction == EA_STOP_ENUMERATION) {
            HeapFree(ghPnPHeap, 0, enumElement);
            break;
        }

        if (enumAction != EA_SKIP_SUBTREE) {

            Status = EnumerateSubTreeTopDownBreadthFirstWorker(
                BindingHandle,
                enumElement->DevInst,
                &subTreeHead
                );

            if (Status != CR_SUCCESS) {
                HeapFree(ghPnPHeap, 0, enumElement);
                break;
            }
        }

        HeapFree(ghPnPHeap, 0, enumElement);
    }

    //
    // There might be entries left in the list if we bailed prematurely. Clean
    // them out here.
    //
    while(!IsListEmpty(&subTreeHead)) {

        listEntry = RemoveHeadList(&subTreeHead);
        enumElement = CONTAINING_RECORD(listEntry, ENUM_ELEMENT, ListEntry);
        HeapFree(ghPnPHeap, 0, enumElement);
    }

    return Status;

} // EnumerateSubTreeTopDownBreadthFirst



CONFIGRET
EnumerateSubTreeTopDownBreadthFirstWorker(
    IN      handle_t    BindingHandle,
    IN      LPCWSTR     DevInst,
    IN OUT  PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    This routine inserts all the child relations of DevInst onto the passed in
    list.

Arguments:

    BindingHandle   RPC Binding handle

    DevInst         InstancePath to enumerate.

    ListHead        List to append children to.

Return Value:

    CONFIGRET

--*/
{
    CONFIGRET       Status = CR_SUCCESS;
    ULONG           ulLen;
    LPWSTR          pszRelations, pszCurEntry;
    PENUM_ELEMENT   enumElement;
    size_t          DeviceIDLen = 0;


    //
    // Get the size required for the list of all bus relations
    //
    Status = PNP_GetDeviceListSize(
        BindingHandle,
        DevInst,
        &ulLen,
        CM_GETIDLIST_FILTER_BUSRELATIONS);

    if ((Status != CR_SUCCESS) || (ulLen == 0)) {
        return Status;
    }

    //
    // Allocate an element for the first entry.
    //
    pszRelations = (LPWSTR)
        HeapAlloc(ghPnPHeap, HEAP_ZERO_MEMORY,
                  ((ulLen + 2)*sizeof(WCHAR)));

    if (pszRelations == NULL) {
        return CR_OUT_OF_MEMORY;
    }

    //
    // Get the list of all bus relations
    //
    Status = PNP_GetDeviceList(
        BindingHandle,
        DevInst,
        pszRelations,
        &ulLen,
        CM_GETIDLIST_FILTER_BUSRELATIONS);

    if (Status != CR_SUCCESS) {
        HeapFree(ghPnPHeap, 0, pszRelations);
        return Status;
    }

    //
    // Insert each related device into the list
    //
    for (pszCurEntry = pszRelations;
         *pszCurEntry != L'\0';
         pszCurEntry = pszCurEntry + lstrlen(pszCurEntry)+1) {

        if (FAILED(StringCchLength(
                       pszCurEntry,
                       MAX_DEVICE_ID_LEN,
                       &DeviceIDLen))) {
            continue;
        }

        ASSERT(DeviceIDLen < MAX_DEVICE_ID_LEN);

        enumElement = (PENUM_ELEMENT)
            HeapAlloc(ghPnPHeap, 0,
                      sizeof(ENUM_ELEMENT) +
                      ((DeviceIDLen + 1 - ANYSIZE_ARRAY) * sizeof(WCHAR)));

        if (enumElement == NULL) {
            HeapFree(ghPnPHeap, 0, pszRelations);
            return CR_OUT_OF_MEMORY;
        }

        if (FAILED(StringCchCopy(
                       enumElement->DevInst,
                       DeviceIDLen + 1,
                       pszCurEntry))) {
            HeapFree(ghPnPHeap, 0, enumElement);
            continue;
        }

        //
        // Insert it into the end of the tree.
        //
        InsertTailList(ListHead, &enumElement->ListEntry);
    }

    HeapFree(ghPnPHeap, 0, pszRelations);

    return CR_SUCCESS;

} // EnumerateSubTreeTopDownBreadthFirstWorker





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\rhwprof.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rhwprof.c

Abstract:

    This module contains the server-side hardware profile APIs.

                  PNP_IsDockStationPresent
                  PNP_RequestEjectPC
                  PNP_HwProfFlags
                  PNP_GetHwProfInfo
                  PNP_SetHwProf

Author:

    Paula Tomlinson (paulat) 7-18-1995

Environment:

    User-mode only.

Revision History:

    18-July-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"

#include <profiles.h>


//
// private prototypes
//
BOOL
IsCurrentProfile(
      ULONG  ulProfile
      );



CONFIGRET
PNP_IsDockStationPresent(
    IN  handle_t     hBinding,
    OUT PBOOL        Present
    )

/*++

Routine Description:
    This routine determines whether a docking station is currently present.

Parameters:

    hBinding         RPC binding handle.

    Present          Supplies the address of a boolean variable that is set
                     upon successful return to indicate whether or not a
                     docking station is currently present.

Return Value:

    If the function succeeds, the return value is CR_SUCCESS.
        If the function fails, the return value is a CR failure code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hCurrentDockInfo = NULL, hIDConfigDB = NULL;
    DWORD       dataType;
    ULONG       dockingState;
    ULONG       ejectableDocks;
    ULONG       size;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters.
        //
        if (!ARGUMENT_PRESENT(Present)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        *Present = FALSE;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         pszRegPathIDConfigDB,
                         0,
                         KEY_READ,
                         &hIDConfigDB) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            hIDConfigDB = NULL;
            goto Clean0;
        }

        if (RegOpenKeyEx(hIDConfigDB,
                         pszRegKeyCurrentDockInfo,
                         0,
                         KEY_READ,
                         &hCurrentDockInfo) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            hCurrentDockInfo = NULL;
            goto Clean0;
        }

        size = sizeof (dockingState);

        if ((RegQueryValueEx(hCurrentDockInfo,
                             pszRegValueDockingState,
                             0,
                             &dataType,
                             (PUCHAR) &dockingState,
                             &size) != ERROR_SUCCESS) ||
            (dataType != REG_DWORD)   ||
            (size != sizeof (ULONG))) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        if ((dockingState & HW_PROFILE_DOCKSTATE_UNKNOWN) ==
            HW_PROFILE_DOCKSTATE_DOCKED) {

            size = sizeof(ejectableDocks);

            if ((RegQueryValueEx(hCurrentDockInfo,
                                 pszRegValueEjectableDocks,
                                 0,
                                 &dataType,
                                 (PUCHAR) &ejectableDocks,
                                 &size) == ERROR_SUCCESS) &&
                (dataType == REG_DWORD) &&
                (size == sizeof(ULONG)) &&
                (ejectableDocks > 0)) {
                *Present = TRUE;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hIDConfigDB) {
        RegCloseKey(hIDConfigDB);
    }

    if (hCurrentDockInfo) {
        RegCloseKey(hCurrentDockInfo);
    }

    return Status;

} // PNP_IsDockStationPresent



CONFIGRET
PNP_RequestEjectPC(
    IN  handle_t     hBinding
    )

/*++

Routine Description:

    This routine requests that the PC be ejected (i.e., undocked).

Parameters:

   hBinding          RPC binding handle.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR failure code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus;
    WCHAR       szDockDevInst[MAX_DEVICE_ID_LEN + 1];
    PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA dockData;

    try {
        //
        // Find the dock devnode, if one exists.
        //
        dockData.DeviceInstance = szDockDevInst;
        dockData.DeviceInstanceLength = MAX_DEVICE_ID_LEN;

        ntStatus = NtPlugPlayControl(PlugPlayControlRetrieveDock,
                                     &dockData,
                                     sizeof(PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA));

        if (!NT_SUCCESS(ntStatus)) {
            Status = MapNtStatusToCmError(ntStatus);
            goto Clean0;
        }

        //
        // Request eject on the dock devnode.  Note PNP_RequestDeviceEject may
        // require additional access and/or privileges, as appropriate.
        //
        Status = PNP_RequestDeviceEject(hBinding,
                                        szDockDevInst,
                                        NULL,           // pVetoType
                                        NULL,           // pszVetoName
                                        0,              // ulNameLength
                                        0);             // ulFlags

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_RequestEjectPC



CONFIGRET
PNP_HwProfFlags(
      IN handle_t     hBinding,
      IN ULONG        ulAction,
      IN LPCWSTR      pDeviceID,
      IN ULONG        ulConfig,
      IN OUT PULONG   pulValue,
      OUT PPNP_VETO_TYPE   pVetoType,
      OUT LPWSTR      pszVetoName,
      IN ULONG        ulNameLength,
      IN ULONG        ulFlags
      )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager routines that
  get and set the hardware profile flags.

Arguments:

   hBinding          RPC binding handle.

   ulAction          Specified whether to get or set the flag.  Can be one
                     of the PNP_*_HWPROFFLAGS values.

   pDeviceID         Device instance to get/set the hw profile flag for.

   ulConfig          Specifies which profile to get/set the flag for. A
                     value of zero indicates to use the current profile.

   pulValue          If setting the flag, then this value on entry contains
                     the value to set the hardware profile flag to.  If
                     getting the flag, then this value will return the
                     current hardware profile flag.

   pVetoType         Buffer to receive the type of veto. If this is NULL
                     then no veto information will be received and the OS wil
                     display the veto information.

   pszVetoName       Buffer to receive the veto information. If this is NULL
                     then no veto information will be received and the OS will
                     display the veto information.

   ulNameLength      Size of the pszVetoName buffer.

   ulFlags           Depends on the action being performed.
                     For PNP_GET_HWPROFFLAGS, no flags are valid.
                     For PNP_SET_HWPROFFLAGS, may be CM_SET_HW_PROF_FLAGS_BITS.

Return Value:

   If the function succeeds it returns CR_SUCCESS.  Otherwise it returns one
   of the CR_* values.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       RegStatus = ERROR_SUCCESS;
    WCHAR       RegStr[MAX_CM_PATH];
    HKEY        hKey = NULL, hDevKey = NULL;
    ULONG       ulValueSize = sizeof(ULONG);
    ULONG       ulCurrentValue, ulChange, ulDisposition;
    BOOL        AffectsCurrentProfile;

    //
    // NOTE: The device is not checked for presence or not, this flag is
    // always just set or retrieved directly from the registry, as it is
    // done on Windows 95
    //

    try {
        //
        // validate parameters
        //
        if ((ulAction != PNP_GET_HWPROFFLAGS) &&
            (ulAction != PNP_SET_HWPROFFLAGS)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (ulAction == PNP_GET_HWPROFFLAGS) {
            //
            // Validate flags for PNP_GET_HWPROFFLAGS
            //
            if (INVALID_FLAGS(ulFlags, 0)) {
                Status = CR_INVALID_FLAG;
                goto Clean0;
            }

        } else if (ulAction == PNP_SET_HWPROFFLAGS) {
            //
            // Verify client "write" access
            //
            if (!VerifyClientAccess(hBinding,
                                    PLUGPLAY_WRITE)) {
                Status = CR_ACCESS_DENIED;
                goto Clean0;
            }

            //
            // Validate flags for PNP_SET_HWPROFFLAGS
            //
            if (INVALID_FLAGS(ulFlags, CM_SET_HW_PROF_FLAGS_BITS)) {
                Status = CR_INVALID_FLAG;
                goto Clean0;
            }
        }

        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pulValue)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Validate value for PNP_SET_HWPROFFLAGS
        //
        if ((ulAction == PNP_SET_HWPROFFLAGS) &&
            (INVALID_FLAGS(*pulValue, CSCONFIGFLAG_BITS))) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Construct the path to the Enum branch for the hardware profile
        // specified.
        //

        if (ulConfig == 0) {
            //
            // a configuration value of zero implies to use the current config
            // System\CCS\Hardware Profiles\Current\System\Enum
            //
            if (FAILED(StringCchPrintf(
                           RegStr,
                           MAX_CM_PATH,
                           L"%s\\%s\\%s",
                           pszRegPathHwProfiles,
                           pszRegKeyCurrent,
                           pszRegPathEnum))) {
                Status = CR_FAILURE;
                goto Clean0;
            }

        } else {
            //
            // use the specified profile id
            // System\CCS\Hardware Profiles\xxxx\System\Enum
            //
            if (FAILED(StringCchPrintf(
                           RegStr,
                           MAX_CM_PATH,
                           L"%s\\%04u\\%s",
                           pszRegPathHwProfiles,
                           ulConfig,
                           pszRegPathEnum))) {
                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        //----------------------------------------------------
        // caller wants to retrieve the hw profile flag value
        //----------------------------------------------------

        if (ulAction == PNP_GET_HWPROFFLAGS) {

            //
            // open the profile specific enum key
            //
            RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, RegStr, 0,
                                      KEY_QUERY_VALUE, &hKey);

            if (RegStatus != ERROR_SUCCESS) {
                *pulValue = 0;          // success,this is what Win95 does
                goto Clean0;
            }

            //
            // open the enum\device-instance key under the profile key
            //
            RegStatus = RegOpenKeyEx( hKey, pDeviceID, 0, KEY_QUERY_VALUE, &hDevKey);

            if (RegStatus != ERROR_SUCCESS) {
                *pulValue = 0;          // success,this is what Win95 does
                goto Clean0;
            }

            //
            // query the profile flag
            //
            ulValueSize = sizeof(ULONG);
            RegStatus = RegQueryValueEx( hDevKey, pszRegValueCSConfigFlags,
                                         NULL, NULL, (LPBYTE)pulValue,
                                         &ulValueSize);

            if (RegStatus != ERROR_SUCCESS) {

                *pulValue = 0;

                if (RegStatus != ERROR_CANTREAD && RegStatus != ERROR_FILE_NOT_FOUND) {
                    Status = CR_REGISTRY_ERROR;
                    goto Clean0;
                }
            }
        }


        //----------------------------------------------
        // caller wants to set the hw profile flag value
        //----------------------------------------------

        else if (ulAction == PNP_SET_HWPROFFLAGS) {

            //
            // open the profile specific enum key.
            //
            // note that we may actually end up creating a Hardware Profile key
            // here for the specified profile id, even if no such profile
            // exists.  ideally, we should check that such a profile exists, but
            // we've been doing this for too long to change it now.  the
            // consolation here is that the client must be granted appropriate
            // access to actually do this.
            //
            RegStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE, RegStr, 0, NULL,
                                        REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE,
                                        NULL, &hKey, &ulDisposition);

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            //
            // open the enum\device-instance key under the profile key
            //
            RegStatus = RegCreateKeyEx( hKey, pDeviceID, 0, NULL,
                                        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                        NULL, &hDevKey, NULL);

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            //
            // before setting, query the current profile flag
            //
            ulValueSize = sizeof(ulCurrentValue);
            RegStatus = RegQueryValueEx( hDevKey, pszRegValueCSConfigFlags,
                                         NULL, NULL, (LPBYTE)&ulCurrentValue,
                                         &ulValueSize);

            if (RegStatus == ERROR_CANTREAD || RegStatus == ERROR_FILE_NOT_FOUND) {

                ulCurrentValue = 0;       // success,this is what Win95 does

            } else if (RegStatus != ERROR_SUCCESS) {

                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            //
            // if requested flags different than current, write out to registry
            //
            ulChange = ulCurrentValue ^ *pulValue;

            if (ulChange) {

                AffectsCurrentProfile = (BOOL)(ulConfig == 0 || IsCurrentProfile(ulConfig));

                //
                // we're about to change the disable bit on the current profile,
                // try and disable the device in the process
                //
                if ((ulChange & CSCONFIGFLAG_DISABLED) &&
                    (*pulValue & CSCONFIGFLAG_DISABLED) && AffectsCurrentProfile) {

                    //
                    // Verify client "execute" access and privilege.
                    //
                    // Note that as the PLUGPLAY_* access rights are *currently*
                    // granted, we know that the client should have execute
                    // access (because they were already granted "write" access,
                    // which is granted to a strict subset of groups that are
                    // granted "execute" access).  Since this does not always
                    // have to be the case, we'll make the separate check for
                    // "execute" access here, prior to making the privilege
                    // check, as usual.
                    //
                    if ((!VerifyClientAccess(hBinding,
                                             PLUGPLAY_EXECUTE)) ||
                        (!VerifyClientPrivilege(hBinding,
                                                SE_LOAD_DRIVER_PRIVILEGE,
                                                L"Device Action (disable device)"))) {
                        //
                        // The client either does not possess the privilege, or
                        // did not have the right to use that privilege with the
                        // PlugPlay service.  Since they were able to modify the
                        // persistent state (i.e. granted "write" access),
                        // rather than return "access denied", we'll tell them
                        // that a restart is required for the change to take
                        // place for the device to be disabled.  Set the status,
                        // but fall through so that the CSConfigFlags are still
                        // updated.
                        //
                        // (Note that when Status is set to any failure code
                        // other than CR_NOT_DISABLEABLE, it will always be set
                        // to CR_NEED_RESTART below, but we'll go ahead use that
                        // failure code here as well, rather than confusing the
                        // issue.)
                        //
                        Status = CR_NEED_RESTART;

                    } else {

                        //
                        // NOTE: We enter a critical section here to guard against concurrent
                        // read/write operations to the "DisableCount" registry value of any
                        // single device instance by DisableDevInst (below), and SetupDevInst,
                        // EnableDevInst (called by PNP_DeviceInstanceAction).
                        //
                        PNP_ENTER_SYNCHRONOUS_CALL();

                        //
                        // disable the devnode
                        //
                        Status = DisableDevInst(pDeviceID,
                                                pVetoType,
                                                pszVetoName,
                                                ulNameLength,
                                                FALSE);

                        PNP_LEAVE_SYNCHRONOUS_CALL();
                    }

                    if (Status == CR_NOT_DISABLEABLE) {
                        //
                        // we got refused!
                        // (note that this error also implies *NO* changes to the registry entry)
                        //
                        goto Clean0;

                    } else if (Status != CR_SUCCESS) {
                        //
                        // we can go ahead and disable after restart
                        //
                        Status = CR_NEED_RESTART;
                    }
                }
                //
                // assume Status is valid and typically CR_SUCCESS or CR_NEED_RESTART
                //

                //
                // now update the registry
                //
                RegStatus = RegSetValueEx( hDevKey, pszRegValueCSConfigFlags, 0,
                                        REG_DWORD, (LPBYTE)pulValue,
                                        sizeof(ULONG));

                if (RegStatus != ERROR_SUCCESS) {
                    Status = CR_REGISTRY_ERROR;
                    goto Clean0;
                }

                if (Status == CR_NEED_RESTART) {
                    //
                    // we have to RESTART due to not being able to disable device immediately
                    //
                    goto Clean0;
                }

                //
                // If this doesn't effect the current config, then we're done.
                //
                if (!AffectsCurrentProfile) {
                    goto Clean0;
                }

                //
                // are we enabling the device?
                //

                if ((ulChange & CSCONFIGFLAG_DISABLED) && !(*pulValue & CSCONFIGFLAG_DISABLED)) {
                    //
                    // enable the devnode
                    //

                    //
                    // NOTE: We enter a critical section here to guard against
                    // concurrent read/write operations to the "DisableCount"
                    // registry value of any single device instance by
                    // EnableDevInst (called below), SetupDevInst, and
                    // DisableDevInst.
                    //
                    PNP_ENTER_SYNCHRONOUS_CALL();

                    //
                    // enable the devnode
                    //
                    EnableDevInst(pDeviceID, FALSE);

                    PNP_LEAVE_SYNCHRONOUS_CALL();
                }

                //
                // did the do-not-create bit change?
                //
                if (ulChange & CSCONFIGFLAG_DO_NOT_CREATE) {
                    if (*pulValue & CSCONFIGFLAG_DO_NOT_CREATE) {
                        //
                        // if subtree can be removed, remove it now
                        //
                        if (QueryAndRemoveSubTree( pDeviceID,
                                                pVetoType,
                                                pszVetoName,
                                                ulNameLength,
                                                PNP_QUERY_AND_REMOVE_NO_RESTART) != CR_SUCCESS) {

                            Status = CR_NEED_RESTART;
                            goto Clean0;
                        }
                    }
                    else {
                        //
                        // The DO_NOT_CREATE flag was turned off, reenumerate the devnode
                        //
                        ReenumerateDevInst(pDeviceID, TRUE, 0);
                    }
                }
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (hDevKey != NULL) {
        RegCloseKey(hDevKey);
    }

    return Status;

} // PNP_HwProfFlags



CONFIGRET
PNP_GetHwProfInfo(
      IN  handle_t       hBinding,
      IN  ULONG          ulIndex,
      OUT PHWPROFILEINFO pHWProfileInfo,
      IN  ULONG          ulProfileInfoSize,
      IN  ULONG          ulFlags
      )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager routine
  CM_Get_Hardware_Profile_Info.  It returns a structure of info for
  the specified hardware profile.

Arguments:

   hBinding          RPC binding handle.

   ulIndex           Specifies which profile to use. A value of 0xFFFFFFFF
                     indicates to use the current profile.

   pHWProfileInfo    Pointer to HWPROFILEINFO struct, returns profile info

   ulProfileInfoSize Specifies the size of the HWPROFILEINFO struct

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds it returns CR_SUCCESS.  Otherwise it returns one
   of the CR_* values.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   ULONG       RegStatus = ERROR_SUCCESS;
   WCHAR       RegStr[MAX_CM_PATH];
   HKEY        hKey = NULL, hDockKey = NULL, hCfgKey = NULL;
   ULONG       ulSize, ulDisposition;
   ULONG       enumIndex, targetIndex;

   UNREFERENCED_PARAMETER(hBinding);

   try {
      //
      // validate parameters
      //
      if (INVALID_FLAGS(ulFlags, 0)) {
          Status = CR_INVALID_FLAG;
          goto Clean0;
      }

      //
      // validate the size of the HWPROFILEINFO struct
      //
      if (ulProfileInfoSize != sizeof(HWPROFILEINFO)) {
        Status = CR_INVALID_DATA;
        goto Clean0;
      }

      //
      // initialize the HWPROFILEINFO struct fields
      //
      pHWProfileInfo->HWPI_ulHWProfile = 0;
      pHWProfileInfo->HWPI_szFriendlyName[0] = L'\0';
      pHWProfileInfo->HWPI_dwFlags = 0;

      //
      // open a key to IDConfigDB (create if it doesn't already exist
      //
      RegStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszRegPathIDConfigDB, 0,
                                 NULL, REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE,
                                 NULL, &hKey, &ulDisposition);

      if (RegStatus != ERROR_SUCCESS) {
         Status = CR_REGISTRY_ERROR;
         goto Clean0;
      }

      //
      // open a key to Hardware Profiles (create if it doesn't already exist)
      //
      RegStatus = RegCreateKeyEx(hKey, pszRegKeyKnownDockingStates, 0,
                                 NULL, REG_OPTION_NON_VOLATILE,
                                 KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, NULL,
                                 &hDockKey, &ulDisposition);

      if (RegStatus != ERROR_SUCCESS) {
         Status = CR_REGISTRY_ERROR;
         goto Clean0;
      }


      //
      // a configuration value of 0xFFFFFFFF implies to use the current config
      //
      if (ulIndex == 0xFFFFFFFF) {
         //
         // get the current profile index stored under IDConfigDB
         //
         ulSize = sizeof(ULONG);
         RegStatus = RegQueryValueEx(
                  hKey, pszRegValueCurrentConfig, NULL, NULL,
                  (LPBYTE)&pHWProfileInfo->HWPI_ulHWProfile, &ulSize);

         if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            pHWProfileInfo->HWPI_ulHWProfile = 0;
            goto Clean0;
         }

      }

      //
      // values other than 0xFFFFFFFF mean that we're essentially
      // enumerating profiles (the value is an enumeration index)
      //
      else {
         //
         // enumerate the profile keys under Known Docking States
         //
         Status = CR_SUCCESS;
         enumIndex = 0;
         targetIndex = ulIndex;
         while(enumIndex <= targetIndex) {
             ulSize = MAX_CM_PATH;
             RegStatus = RegEnumKeyEx(hDockKey,
                                      enumIndex,
                                      RegStr,
                                      &ulSize,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
             if (RegStatus == ERROR_NO_MORE_ITEMS) {
                 Status = CR_NO_MORE_HW_PROFILES;
                 goto Clean0;
             } else if (RegStatus != ERROR_SUCCESS) {
                 Status = CR_REGISTRY_ERROR;
                 goto Clean0;
             }

             if (_wtoi(RegStr) == 0) {
                 //
                 // we found the pristine amidst the profiles we're enumerating.
                 // enumerate one extra key to make up for it.
                 //
                 targetIndex++;
             }
             if (enumIndex == targetIndex) {
                 //
                 // this is the one we want.
                 //
                 pHWProfileInfo->HWPI_ulHWProfile = _wtoi(RegStr);
                 Status = CR_SUCCESS;
                 break;
             }
             enumIndex++;
         }
      }

      //
      // open the key for this profile
      //
      if (FAILED(StringCchPrintf(
                     RegStr,
                     MAX_CM_PATH,
                     L"%04u",
                     pHWProfileInfo->HWPI_ulHWProfile))) {
          Status = CR_FAILURE;
          goto Clean0;
      }

      RegStatus =
          RegOpenKeyEx(
              hDockKey,
              RegStr,
              0,
              KEY_QUERY_VALUE,
              &hCfgKey);

      if (RegStatus != ERROR_SUCCESS) {
          Status = CR_REGISTRY_ERROR;
          goto Clean0;
      }

      //
      // retrieve the friendly name
      //
      ulSize = MAX_PROFILE_LEN * sizeof(WCHAR);
      RegStatus = RegQueryValueEx(
               hCfgKey, pszRegValueFriendlyName, NULL, NULL,
               (LPBYTE)(pHWProfileInfo->HWPI_szFriendlyName),
               &ulSize);

      //
      // retrieve the DockState
      //
#if 0
//
// KENRAY
// This is the wrong way to determine docking state caps
// You must instead check the alias tables
//
      StringCchPrintf(
          RegStr,
          MAX_CM_PATH,
          L"%04u",
          pHWProfileInfo->HWPI_ulHWProfile);
      
      ulSize = sizeof(SYSTEM_DOCK_STATE);
      RegStatus = RegQueryValueEx(
               hCfgKey, pszRegValueDockState, NULL, NULL,
               (LPBYTE)&DockState, &ulSize);

      if (RegStatus != ERROR_SUCCESS) {
         pHWProfileInfo->HWPI_dwFlags = CM_HWPI_NOT_DOCKABLE;
      }
      else {
         //
         // map SYSTEM_DOCK_STATE enumerated types into CM_HWPI_ flags
         //
         if (DockState == SystemDocked) {
            pHWProfileInfo->HWPI_dwFlags = CM_HWPI_DOCKED;
         }
         else if (DockState == SystemUndocked) {
            pHWProfileInfo->HWPI_dwFlags = CM_HWPI_UNDOCKED;
         }
         else {
            pHWProfileInfo->HWPI_dwFlags = CM_HWPI_NOT_DOCKABLE;
         }
      }
#endif

   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   if (hKey != NULL) {
      RegCloseKey(hKey);
   }
   if (hDockKey != NULL) {
      RegCloseKey(hDockKey);
   }
   if (hCfgKey != NULL) {
      RegCloseKey(hCfgKey);
   }

   return Status;

} // PNP_GetHwProfInfo



CONFIGRET
PNP_SetHwProf(
    IN  handle_t   hBinding,
    IN  ULONG      ulHardwareProfile,
    IN  ULONG      ulFlags
    )
{
    UNREFERENCED_PARAMETER(ulHardwareProfile);
    UNREFERENCED_PARAMETER(ulFlags);

    //
    // Verify client "execute" access
    //
    if (!VerifyClientAccess(hBinding,
                            PLUGPLAY_EXECUTE)) {
        return CR_ACCESS_DENIED;
    }

    //
    // Verify client privilege
    //
    if (!VerifyClientPrivilege(hBinding,
                               SE_LOAD_DRIVER_PRIVILEGE,
                               L"Set Hardware Profile (not implemented)")) {
        return CR_ACCESS_DENIED;
    }

    return CR_CALL_NOT_IMPLEMENTED;

} // PNP_SetHwProf



//-------------------------------------------------------------------
// Private utility routines
//-------------------------------------------------------------------

BOOL
IsCurrentProfile(
      ULONG  ulProfile
      )

/*++

Routine Description:

  This routine determines if the specified profile matches the current
  profile.

Arguments:

   ulProfile    Profile id value (value from 1 - 9999).

Return Value:

   Return TRUE if this is the current profile, FALSE if it isn't.

--*/

{
   HKEY  hKey;
   ULONG ulSize, ulCurrentProfile;

   //
   // open a key to IDConfigDB
   //
   if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, pszRegPathIDConfigDB, 0,
            KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
       return FALSE;
   }

   //
   // get the current profile index stored under IDConfigDB
   //
   ulSize = sizeof(ULONG);
   if (RegQueryValueEx(
            hKey, pszRegValueCurrentConfig, NULL, NULL,
            (LPBYTE)&ulCurrentProfile, &ulSize) != ERROR_SUCCESS) {
      RegCloseKey(hKey);
      return FALSE;
   }

   RegCloseKey(hKey);

   if (ulCurrentProfile == ulProfile) {
      return TRUE;
   }

   return FALSE;

} // IsCurrentProfile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\rconflist.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rconflist.c

Abstract:

    This module contains the server-side conflict list reporting APIs.

                  PNP_QueryResConfList

Author:

    Paula Tomlinson (paulat) 9-27-1995

Environment:

    User-mode only.

Revision History:

    27-Sept-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"


//
// private prototypes
//
CONFIGRET
ResDesToNtResource(
    IN     PCVOID                           ResourceData,
    IN     RESOURCEID                       ResourceID,
    IN     ULONG                            ResourceLen,
    IN     PCM_PARTIAL_RESOURCE_DESCRIPTOR  pResDes,
    IN     ULONG                            ulTag,
    IN     ULONG                            ulFlags
    );

ULONG
GetResDesSize(
    IN  ULONG   ResourceID,
    IN  ULONG   ulFlags
    );



CONFIGRET
PNP_QueryResConfList(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  RESOURCEID ResourceID,
   IN  LPBYTE     ResourceData,
   IN  ULONG      ResourceLen,
   OUT LPBYTE     clBuffer,
   IN  ULONG      clBufferLen,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine retrieves
  conflict information for a specified resource.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    ResourceID    Type of resource, ResType_xxxx

    ResourceData  Resource specific data

    ResourceLen   length of ResourceData

    clBuffer      Buffer filled with conflict list

    clBufferLen   Size of clBuffer

    ulFlags       Specifies the width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data supplied is assumed to be that native to the
                  platform of the caller.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET           Status = CR_SUCCESS;
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_CONFLICT_DATA ControlData;
    PPLUGPLAY_CONTROL_CONFLICT_LIST pConflicts;
    CM_RESOURCE_LIST    NtResourceList;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // validate res des size
        //
        if (ResourceLen < GetResDesSize(ResourceID, ulFlags)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // look at buffer we need to fill in
        // validate parameters passed in buffer
        // buffer should always be big enough to hold header
        //
        if(clBufferLen < sizeof(PPLUGPLAY_CONTROL_CONFLICT_LIST)) {
            Status = CR_INVALID_STRUCTURE_SIZE;
            goto Clean0;
        }

        pConflicts = (PPLUGPLAY_CONTROL_CONFLICT_LIST)clBuffer;

        //
        // Convert the user-mode version of the resource list to an
        // NT CM_RESOURCE_LIST structure.
        //
        // we'll sort out InterfaceType and BusNumber in kernel
        //
        NtResourceList.Count = 1;
        NtResourceList.List[0].InterfaceType           = InterfaceTypeUndefined;
        NtResourceList.List[0].BusNumber               = 0;
        NtResourceList.List[0].PartialResourceList.Version = NT_RESLIST_VERSION;
        NtResourceList.List[0].PartialResourceList.Revision = NT_RESLIST_REVISION;
        NtResourceList.List[0].PartialResourceList.Count = 1;

        Status = ResDesToNtResource(ResourceData, ResourceID, ResourceLen,
                 &NtResourceList.List[0].PartialResourceList.PartialDescriptors[0], 0, ulFlags);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // now fill in ControlData
        //
        RtlInitUnicodeString(&ControlData.DeviceInstance, pDeviceID);
        ControlData.ResourceList = &NtResourceList;
        ControlData.ResourceListSize = sizeof(NtResourceList);
        ControlData.ConflictBuffer = pConflicts;
        ControlData.ConflictBufferSize = clBufferLen;
        ControlData.Flags = ulFlags;
        ControlData.Status = STATUS_SUCCESS;

        NtStatus = NtPlugPlayControl(PlugPlayControlQueryConflictList,
                                     &ControlData,
                                     sizeof(ControlData));

        if (NtStatus == STATUS_SUCCESS) {
            Status = CR_SUCCESS;
        } else {
            Status = MapNtStatusToCmError(NtStatus);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // unspecified failure
        //
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_QueryResConfList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\umpnpmgr\revent.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    revent.c

Abstract:

    This module contains the server-side event notification and device
    installation routines.

Author:

    Paula Tomlinson (paulat) 6-28-1995

Environment:

    User-mode only.

Revision History:

    28-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnpi.h"
#include "umpnpdat.h"
#include "pnpipc.h"
#include "pnpmsg.h"

#include <process.h>
#pragma warning(push)
#pragma warning(disable:4201) // warning C4201: nonstandard extension used : nameless struct/union
#include <setupapi.h>
#pragma warning(pop)
#include <spapip.h>

#include <wtsapi32.h>
#pragma warning(push)
#pragma warning(disable:4201) // warning C4201: nonstandard extension used : nameless struct/union
#pragma warning(disable:4214) // warning C4214: nonstandard extension used : bit field types other than int
#include <winsta.h>
#pragma warning(pop)
#include <userenv.h>
#include <syslib.h>

#include <initguid.h>
#pragma warning(push)
#pragma warning(disable:4201) // warning C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning(pop)
#include <ntddpar.h>
#include <pnpmgr.h>
#include <wdmguid.h>
#include <ioevent.h>
#include <devguid.h>
#include <winsvcp.h>
#include <svcsp.h>


//
// Maximum number of times (per pass) we will reenumerate the device tree during 
// GUI setup in an attempt to find and install new devices.
//
#define MAX_REENUMERATION_COUNT 128

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);


//
// Private interface device class that is used to register for all devnode change
// notifications. This is no longer supported, but we want to fail anyone who registers
// this GUID.
//
DEFINE_GUID(GUID_DEVNODE_CHANGE, 0xfa1fb208L, 0xf892, 0x11d0, 0x8a, 0x2e, 0x00, 0x00, 0xf8, 0x75, 0x3f, 0x55);


//
// Private interface device class that is assigned to entries registered for
// device interface change notifications, using the
// DEVICE_NOTIFY_ALL_INTERFACE_CLASSES flag.  For internal use only.
//
DEFINE_GUID(GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES,
            0x2121db68, 0x0993, 0x4a29, 0xb8, 0xe0, 0x1e, 0x51, 0x9c, 0x43, 0x72, 0xe6);


//
// SessionId 0 is the main session, and is always created during system startup
// and remains until system shutdown, whether or not terminal services is
// running.  This session always hosts services.exe and all services, so it is
// the only session that our ConsoleCtrlHandler can receive events for.
//
#define MAIN_SESSION      ((ULONG) 0)
#define INVALID_SESSION   ((ULONG)-1)

//
// The active console session is the session currently connected to the physical
// Console.  We store this value in a global variable, whose access is
// controlled by an event.  The routine GetActiveConsoleSessionId() is used to
// retrieve the value when it is safe to do so.
//
// Note that SessionId 0 is the initial console session, and that the
// SessionNotificationHandler is responsible for maintaining state.
//
ULONG   gActiveConsoleSessionId     = MAIN_SESSION; // system always starts with session 0
HANDLE  ghActiveConsoleSessionEvent = NULL;         // nonsignaled while session change is in progress


//
// We always use DeviceEventWorker and BroadcastSystemMessage to deliver
// notification to windows in SessionId 0.  For all other sessions, we use
// WinStationSendWindowMessage and WinStationBroadcastSystemMessage.
// These are the timeout period (in seconds) for messages sent and broadcast to
// sessions other than SessionId 0.  These times should be the same as those
// implemented by their SessionId 0 counterparts.
//
#define DEFAULT_SEND_TIME_OUT     30 // same as DeviceEventWorker
#define DEFAULT_BROADCAST_TIME_OUT 5 // same as BroadcastSystemMessage


//
// Notification list structure.
//
typedef struct _PNP_NOTIFY_LIST {
    PVOID    Next;
    PVOID    Previous;
    LOCKINFO Lock;
} PNP_NOTIFY_LIST, *PPNP_NOTIFY_LIST;

//
// Notification entry structure.
//
typedef struct _PNP_NOTIFY_ENTRY {
    PVOID   Next;
    PVOID   Previous;
    BOOL    Unregistered;
    ULONG   Signature;
    HANDLE  Handle;
    DWORD   Flags;
    ULONG   SessionId;
    ULONG   Freed;
    ULONG64 ClientCtxPtr;
    LPWSTR  ClientName;

    union {
        struct {
            GUID ClassGuid;
        } Class;

        struct {
            HANDLE FileHandle;
            WCHAR  DeviceId[MAX_DEVICE_ID_LEN];
        } Target;

        struct {
            DWORD Reserved;
        } Devnode;

        struct {
            DWORD scmControls;
        } Service;

    } u;

} PNP_NOTIFY_ENTRY, *PPNP_NOTIFY_ENTRY;


//
// Deferred operation list structure.
//
typedef struct _PNP_DEFERRED_LIST {
    PVOID       Next;
    handle_t    hBinding;
    PPNP_NOTIFY_ENTRY Entry;
} PNP_DEFERRED_LIST, *PPNP_DEFERRED_LIST;


//
// Signatures describing which notification list an entry currently belongs to.
//
#define CLASS_ENTRY_SIGNATURE       (0x07625100)
#define TARGET_ENTRY_SIGNATURE      (0x17625100)
#define SERVICE_ENTRY_SIGNATURE     (0x37625100)
#define LIST_ENTRY_SIGNATURE_MASK   (0xFFFFFF00)
#define LIST_ENTRY_INDEX_MASK       (~LIST_ENTRY_SIGNATURE_MASK)

#define MarkEntryWithList(ent,value) { ent->Signature &= LIST_ENTRY_SIGNATURE_MASK;\
                                       ent->Signature |= value; }


//
// Device event notification lists.
//
#define TARGET_HASH_BUCKETS         13
#define CLASS_GUID_HASH_BUCKETS     13
#define SERVICE_NUM_CONTROLS        3

#define HashClassGuid(_Guid) \
            ( ( ((PULONG)_Guid)[0] + ((PULONG)_Guid)[1] + ((PULONG)_Guid)[2] \
                + ((PULONG)_Guid)[3]) % CLASS_GUID_HASH_BUCKETS)

PNP_NOTIFY_LIST TargetList[TARGET_HASH_BUCKETS];
PNP_NOTIFY_LIST ClassList[CLASS_GUID_HASH_BUCKETS];
PNP_NOTIFY_LIST ServiceList[SERVICE_NUM_CONTROLS];

PPNP_DEFERRED_LIST UnregisterList;
PPNP_DEFERRED_LIST RegisterList;
PPNP_DEFERRED_LIST RundownList;

CRITICAL_SECTION RegistrationCS;


//
// These are indices into the global ServiceList array of lists containing
// services registered for the corresponding service control events.
//
enum cBitIndex {
    CINDEX_HWPROFILE  = 0,
    CINDEX_POWEREVENT = 1
};

//
// These are a bit mask for the above lists.
// (the two enums should match! One is 0,1,2,...n. The other 2^n.)
//
enum cBits {
    CBIT_HWPROFILE  = 1,
    CBIT_POWEREVENT = 2
};


//
// Properties describing how a notification entry was freed.
//

// (the entry has been removed from the notification list)
#define DEFER_NOTIFY_FREE   0x80000000

// (used for debugging only)
#define PNP_UNREG_FREE      0x00000100
#define PNP_UNREG_CLASS     0x00000200
#define PNP_UNREG_TARGET    0x00000400
#define PNP_UNREG_DEFER     0x00000800
#define PNP_UNREG_WIN       0x00001000
#define PNP_UNREG_SERVICE   0x00002000
#define PNP_UNREG_CANCEL    0x00004000
#define PNP_UNREG_RUNDOWN   0x00008000


//
// List of devices to be installed.
//
typedef struct _PNP_INSTALL_LIST {
    PVOID    Next;
    LOCKINFO Lock;
} PNP_INSTALL_LIST, *PPNP_INSTALL_LIST;

//
// Device install list entry structure.
//
typedef struct _PNP_INSTALL_ENTRY {
    PVOID   Next;
    DWORD   Flags;
    WCHAR   szDeviceId[MAX_DEVICE_ID_LEN];
} PNP_INSTALL_ENTRY, *PPNP_INSTALL_ENTRY;

//
// Install event list.
//
PNP_INSTALL_LIST InstallList;

//
// Flags for PNP_INSTALL_ENTRY nodes
//
#define PIE_SERVER_SIDE_INSTALL_ATTEMPTED    0x00000001
#define PIE_DEVICE_INSTALL_REQUIRED_REBOOT   0x00000002


//
// Device install client information list structure.
//
typedef struct _INSTALL_CLIENT_LIST {
    PVOID    Next;
    LOCKINFO Lock;
} INSTALL_CLIENT_LIST, *PINSTALL_CLIENT_LIST;

//
// Device install client information list entry structure.
//
typedef struct _INSTALL_CLIENT_ENTRY {
    PVOID   Next;
    ULONG   RefCount;
    ULONG   ulSessionId;
    HANDLE  hEvent;
    HANDLE  hPipe;
    HANDLE  hProcess;
    HANDLE  hDisconnectEvent;
    ULONG   ulInstallFlags;
    WCHAR   LastDeviceId[MAX_DEVICE_ID_LEN];
} INSTALL_CLIENT_ENTRY, *PINSTALL_CLIENT_ENTRY;

//
// Device install client list.
//
INSTALL_CLIENT_LIST InstallClientList;

//
// Global BOOL that tracks if a server side device install reboot is needed.
//
BOOL gServerSideDeviceInstallRebootNeeded = FALSE;


//
// private prototypes
//
DWORD
ThreadProc_DeviceEvent(
    LPDWORD lpParam
    );
DWORD
ThreadProc_DeviceInstall(
    LPDWORD lpParam
    );
DWORD
ThreadProc_GuiSetupDeviceInstall(
    LPDWORD lpThreadParam
    );
DWORD
ThreadProc_FactoryPreinstallDeviceInstall(
    LPDWORD lpThreadParam
    );
DWORD
ThreadProc_ReenumerateDeviceTree(
    LPVOID  lpThreadParam
    );
BOOL
InstallDevice(
    IN     LPWSTR pszDeviceId,
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    );
DWORD
InstallDeviceServerSide(
    IN     LPWSTR pszDeviceId,
    IN OUT PBOOL  RebootRequired,
    IN OUT PBOOL  DeviceHasProblem,
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    );
BOOL
CreateDeviceInstallClient(
    IN  ULONG     SessionId,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    );
BOOL
ConnectDeviceInstallClient(
    IN  ULONG     SessionId,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    );
BOOL
DisconnectDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    );
PINSTALL_CLIENT_ENTRY
LocateDeviceInstallClient(
    IN  ULONG     SessionId
    );
VOID
ReferenceDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    );
VOID
DereferenceDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    );
BOOL
DoDeviceInstallClient(
    IN  LPWSTR    DeviceId,
    IN  PULONG    SessionId,
    IN  ULONG     Flags,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    );
BOOL
InitNotification(
    VOID
    );
VOID
TermNotification(
    VOID
    );
ULONG
ProcessDeviceEvent(
    IN PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN DWORD                 EventBufferSize,
    OUT PPNP_VETO_TYPE       VetoType,
    OUT LPWSTR               VetoName,
    IN OUT PULONG            VetoNameLength
    );

ULONG
NotifyInterfaceClassChange(
    IN DWORD ServiceControl,
    IN DWORD EventId,
    IN DWORD Flags,
    IN PDEV_BROADCAST_DEVICEINTERFACE ClassData
    );

ULONG
NotifyTargetDeviceChange(
    IN  DWORD                   ServiceControl,
    IN  DWORD                   EventId,
    IN  DWORD                   Flags,
    IN  PDEV_BROADCAST_HANDLE   HandleData,
    IN  LPWSTR                  DeviceId,
    OUT PPNP_VETO_TYPE          VetoType       OPTIONAL,
    OUT LPWSTR                  VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    );

ULONG
NotifyHardwareProfileChange(
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     DWORD                Flags,
    OUT    PPNP_VETO_TYPE       VetoType       OPTIONAL,
    OUT    LPWSTR               VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    );

ULONG
NotifyPower(
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     DWORD                EventData,
    IN     DWORD                Flags,
    OUT    PPNP_VETO_TYPE       VetoType       OPTIONAL,
    OUT    LPWSTR               VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    );

BOOL
SendCancelNotification(
    IN     PPNP_NOTIFY_ENTRY    LastEntry,
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     ULONG                Flags,
    IN     PDEV_BROADCAST_HDR   NotifyData  OPTIONAL,
    IN     LPWSTR               DeviceId    OPTIONAL
    );

VOID
BroadcastCompatibleDeviceMsg(
    IN DWORD EventId,
    IN PDEV_BROADCAST_DEVICEINTERFACE ClassData,
    IN PDWORD CurrentMask
    );
VOID
BroadcastVolumeNameChange(
    VOID
    );
DWORD
GetAllVolumeMountPoints(
    VOID
    );

BOOL
EventIdFromEventGuid(
    IN CONST GUID *EventGuid,
    OUT LPDWORD   EventId,
    OUT LPDWORD   Flags,
    OUT LPDWORD   ServiceControl
    );

ULONG
SendHotplugNotification(
    IN CONST GUID           *EventGuid,
    IN       PPNP_VETO_TYPE  VetoType      OPTIONAL,
    IN       LPWSTR          MultiSzList,
    IN OUT   PULONG          SessionId,
    IN       ULONG           Flags
    );

VOID
LogErrorEvent(
    DWORD dwEventID,
    DWORD dwError,
    WORD  nStrings,
    ...
    );

VOID
LogWarningEvent(
    DWORD dwEventID,
    WORD  nStrings,
    ...
    );

BOOL
LockNotifyList(
    IN LOCKINFO *Lock
    );
VOID
UnlockNotifyList(
    IN LOCKINFO *Lock
    );
PPNP_NOTIFY_LIST
GetNotifyListForEntry(
    IN PPNP_NOTIFY_ENTRY entry
    );
BOOL
DeleteNotifyEntry(
    IN PPNP_NOTIFY_ENTRY Entry,
    IN BOOLEAN RpcNotified
    );
VOID
AddNotifyEntry(
    IN PPNP_NOTIFY_LIST  NotifyList,
    IN PPNP_NOTIFY_ENTRY NewEntry
    );
ULONG
HashString(
    IN LPWSTR String,
    IN ULONG  Buckets
    );
DWORD
MapQueryEventToCancelEvent(
    IN DWORD QueryEventId
    );
VOID
FixUpDeviceId(
    IN OUT LPWSTR  DeviceId
    );

ULONG
MapSCMControlsToControlBit(
    IN ULONG scmControls
    );

DWORD
GetFirstPass(
    IN BOOL     bQuery
    );

DWORD
GetNextPass(
    IN DWORD    curPass,
    IN BOOL     bQuery
    );

BOOL
NotifyEntryThisPass(
    IN     PPNP_NOTIFY_ENTRY    Entry,
    IN     DWORD                Pass
    );

DWORD
GetPassFromEntry(
    IN     PPNP_NOTIFY_ENTRY    Entry
    );

BOOL
GetClientName(
    IN  PPNP_NOTIFY_ENTRY entry,
    OUT LPWSTR  lpszClientName,
    IN OUT PULONG  pulClientNameLength
    );

BOOL
GetWindowsExeFileName(
    IN  HWND      hWnd,
    OUT LPWSTR    lpszFileName,
    IN OUT PULONG pulFileNameLength
    );

PPNP_NOTIFY_ENTRY
GetNextNotifyEntry(
    IN PPNP_NOTIFY_ENTRY Entry,
    IN DWORD Flags
    );

PPNP_NOTIFY_ENTRY
GetFirstNotifyEntry(
    IN PPNP_NOTIFY_LIST List,
    IN DWORD Flags
    );

BOOL
InitializeHydraInterface(
    VOID
    );

DWORD
LoadDeviceInstaller(
    VOID
    );

VOID
UnloadDeviceInstaller(
    VOID
    );

BOOL
PromptUser(
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    );

VOID
DoRunOnce(
    VOID
    );

BOOL
GetSessionUserToken(
    IN  ULONG     ulSessionId,
    OUT LPHANDLE  lphUserToken
    );

BOOL
IsUserLoggedOnSession(
    IN  ULONG     ulSessionId
    );

BOOL
IsSessionConnected(
    IN  ULONG     ulSessionId
    );

BOOL
IsSessionLocked(
    IN  ULONG    ulSessionId
    );

BOOL
IsConsoleSession(
    IN  ULONG     ulSessionId
    );

DWORD
CreateUserSynchEvent(
    IN  HANDLE    hUserToken,
    IN  LPCWSTR   lpName,
    OUT HANDLE   *phEvent
    );

BOOL
CreateNoPendingInstallEvent(
    VOID
    );

DWORD
CreateUserReadNamedPipe(
    IN  HANDLE    hUserToken,
    IN  LPCWSTR   lpName,
    IN  ULONG     ulSize,
    OUT HANDLE   *phPipe
    );

ULONG
CheckEjectPermissions(
    IN      LPWSTR          DeviceId,
    OUT     PPNP_VETO_TYPE  VetoType            OPTIONAL,
    OUT     LPWSTR          VetoName            OPTIONAL,
    IN OUT  PULONG          VetoNameLength      OPTIONAL
    );

VOID
LogSurpriseRemovalEvent(
    IN  LPWSTR  MultiSzList
    );

PWCHAR
BuildFriendlyName(
    IN  LPWSTR   InstancePath
    );

CONFIGRET
DevInstNeedsInstall(
    IN  LPCWSTR     DevInst,
    IN  BOOL        CheckReinstallConfigFlag,
    OUT BOOL       *NeedsInstall
    );

PWSTR
BuildBlockedDriverList(
    IN OUT LPGUID  GuidList,
    IN     ULONG   GuidCount
    );

VOID
SendInvalidIDNotifications(
    IN ULONG ulSessionId
    );

//
// global data
//

extern HANDLE ghInst;         // Module handle
extern HKEY   ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY
extern HKEY   ghServicesKey;  // Key to HKLM\CCC\System\Services - DO NOT MODIFY
extern HKEY   ghClassKey;     // Key to HKLM\CCC\System\Class - DO NOT MODIFY
extern DWORD  CurrentServiceState;  // PlugPlay service state - DO NOT MODIFY
extern PSVCS_GLOBAL_DATA PnPGlobalData; // SCM global data

HANDLE        ghInitMutex = NULL;
HANDLE        ghUserToken = NULL;
LOCKINFO      gTokenLock;
BOOL          gbMainSessionLocked = FALSE;

ULONG         gNotificationInProg = 0; // 0 -> No notification or unregister underway.
DWORD         gAllDrivesMask = 0;      // bitmask of all physical volume mountpoints.
BOOL          gbSuppressUI = FALSE;    // TRUE if PNP should never display UI (newdev, hotplug).
BOOL          gbOobeInProgress = FALSE;// TRUE if the OOBE is running during this boot.


BOOL          gbPreservePreInstall = FALSE; // TRUE if PNP should respect a device's pre-install settings.
BOOL          gbStatelessBoot = FALSE;      // TRUE if this is a stateless (rebootless) boot.


const WCHAR RegMemoryManagementKeyName[] =
      TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

const WCHAR RegVerifyDriverLevelValueName[] =
      TEXT("VerifyDriverLevel");


//
// Device Installer instance handle and necessary entrypoints.
// This data is only referenced by the (non-GUI setup) device install thread
// (ThreadProc_DeviceInstall).
//

typedef HDEVINFO (WINAPI *FP_CREATEDEVICEINFOLIST)(CONST GUID *, HWND);
typedef BOOL     (WINAPI *FP_OPENDEVICEINFO)(HDEVINFO, PCWSTR, HWND, DWORD, PSP_DEVINFO_DATA);
typedef BOOL     (WINAPI *FP_BUILDDRIVERINFOLIST)(HDEVINFO, PSP_DEVINFO_DATA, DWORD);
typedef BOOL     (WINAPI *FP_DESTROYDEVICEINFOLIST)(HDEVINFO);
typedef BOOL     (WINAPI *FP_CALLCLASSINSTALLER)(DI_FUNCTION, HDEVINFO, PSP_DEVINFO_DATA);
typedef BOOL     (WINAPI *FP_INSTALLCLASS)(HWND, PCWSTR, DWORD, HSPFILEQ);
typedef BOOL     (WINAPI *FP_GETSELECTEDDRIVER)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DRVINFO_DATA);
typedef BOOL     (WINAPI *FP_GETDRIVERINFODETAIL)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DRVINFO_DATA, PSP_DRVINFO_DETAIL_DATA, DWORD, PDWORD);
typedef BOOL     (WINAPI *FP_GETDEVICEINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DEVINSTALL_PARAMS);
typedef BOOL     (WINAPI *FP_SETDEVICEINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DEVINSTALL_PARAMS);
typedef BOOL     (WINAPI *FP_GETDRIVERINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DRVINFO_DATA, PSP_DRVINSTALL_PARAMS);
typedef BOOL     (WINAPI *FP_SETCLASSINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_CLASSINSTALL_HEADER, DWORD);
typedef BOOL     (WINAPI *FP_GETCLASSINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_CLASSINSTALL_HEADER, DWORD, PDWORD);
typedef HINF     (WINAPI *FP_OPENINFFILE)(PCWSTR, PCWSTR, DWORD, PUINT);
typedef VOID     (WINAPI *FP_CLOSEINFFILE)(HINF);
typedef BOOL     (WINAPI *FP_FINDFIRSTLINE)(HINF, PCWSTR, PCWSTR, PINFCONTEXT);
typedef BOOL     (WINAPI *FP_FINDNEXTMATCHLINE)(PINFCONTEXT, PCWSTR, PINFCONTEXT);
typedef BOOL     (WINAPI *FP_GETSTRINGFIELD)(PINFCONTEXT, DWORD, PWSTR, DWORD, PDWORD);

typedef VOID              (*FP_SETGLOBALFLAGS)(DWORD);
typedef DWORD             (*FP_GETGLOBALFLAGS)(VOID);
typedef PPSP_RUNONCE_NODE (*FP_ACCESSRUNONCENODELIST)(VOID);
typedef VOID              (*FP_DESTROYRUNONCENODELIST)(VOID);

HINSTANCE ghDeviceInstallerLib = NULL;

FP_CREATEDEVICEINFOLIST   fpCreateDeviceInfoList;
FP_OPENDEVICEINFO         fpOpenDeviceInfo;
FP_BUILDDRIVERINFOLIST    fpBuildDriverInfoList;
FP_DESTROYDEVICEINFOLIST  fpDestroyDeviceInfoList;
FP_CALLCLASSINSTALLER     fpCallClassInstaller;
FP_INSTALLCLASS           fpInstallClass;
FP_GETSELECTEDDRIVER      fpGetSelectedDriver;
FP_GETDRIVERINFODETAIL    fpGetDriverInfoDetail;
FP_GETDEVICEINSTALLPARAMS fpGetDeviceInstallParams;
FP_SETDEVICEINSTALLPARAMS fpSetDeviceInstallParams;
FP_GETDRIVERINSTALLPARAMS fpGetDriverInstallParams;
FP_SETCLASSINSTALLPARAMS  fpSetClassInstallParams;
FP_GETCLASSINSTALLPARAMS  fpGetClassInstallParams;
FP_OPENINFFILE            fpOpenInfFile;
FP_CLOSEINFFILE           fpCloseInfFile;
FP_FINDFIRSTLINE          fpFindFirstLine;
FP_FINDNEXTMATCHLINE      fpFindNextMatchLine;
FP_GETSTRINGFIELD         fpGetStringField;
FP_SETGLOBALFLAGS         fpSetGlobalFlags;
FP_GETGLOBALFLAGS         fpGetGlobalFlags;
FP_ACCESSRUNONCENODELIST  fpAccessRunOnceNodeList;
FP_DESTROYRUNONCENODELIST fpDestroyRunOnceNodeList;

//
// typdef for comctl32's DestroyPropertySheetPage API, needed in cases where
// class-/co-installers supply wizard pages (that need to be destroyed).
//
typedef BOOL (WINAPI *FP_DESTROYPROPERTYSHEETPAGE)(HPROPSHEETPAGE);

//
// typedefs for ANSI and Unicode variants of rundll32 proc entrypoint.
//
typedef void (WINAPI *RUNDLLPROCA)(HWND hwndStub, HINSTANCE hInstance, LPSTR pszCmdLine, int nCmdShow);
typedef void (WINAPI *RUNDLLPROCW)(HWND hwndStub, HINSTANCE hInstance, LPWSTR pszCmdLine, int nCmdShow);

//
// typedefs for Terminal Services message dispatch routines, in winsta.dll.
//

typedef LONG (*FP_WINSTABROADCASTSYSTEMMESSAGE)(
    HANDLE  hServer,
    BOOL    sendToAllWinstations,
    ULONG   sessionID,
    ULONG   timeOut,
    DWORD   dwFlags,
    DWORD   *lpdwRecipients,
    ULONG   uiMessage,
    WPARAM  wParam,
    LPARAM  lParam,
    LONG    *pResponse
    );

typedef LONG (*FP_WINSTASENDWINDOWMESSAGE)(
    HANDLE  hServer,
    ULONG   sessionID,
    ULONG   timeOut,
    ULONG   hWnd,
    ULONG   Msg,
    WPARAM  wParam,
    LPARAM  lParam,
    LONG    *pResponse
    );

typedef BOOLEAN (WINAPI * FP_WINSTAQUERYINFORMATIONW)(
    HANDLE  hServer,
    ULONG   LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID   pWinStationInformation,
    ULONG   WinStationInformationLength,
    PULONG  pReturnLength
    );


HINSTANCE ghWinStaLib = NULL;
FP_WINSTASENDWINDOWMESSAGE fpWinStationSendWindowMessage = NULL;
FP_WINSTABROADCASTSYSTEMMESSAGE fpWinStationBroadcastSystemMessage = NULL;
FP_WINSTAQUERYINFORMATIONW fpWinStationQueryInformationW = NULL;

//
// typedefs for Terminal Services support routines, in wtsapi32.dll.
//

typedef BOOL (*FP_WTSQUERYSESSIONINFORMATION)(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN WTS_INFO_CLASS WTSInfoClass,
    OUT LPWSTR * ppBuffer,
    OUT DWORD * pBytesReturned
    );

typedef VOID (*FP_WTSFREEMEMORY)(
    IN PVOID pMemory
    );

HINSTANCE ghWtsApi32Lib = NULL;
FP_WTSQUERYSESSIONINFORMATION fpWTSQuerySessionInformation = NULL;
FP_WTSFREEMEMORY fpWTSFreeMemory = NULL;


//
// Service controller callback routines for authentication and notification to
// services.
//

PSCMCALLBACK_ROUTINE pServiceControlCallback;
PSCMAUTHENTICATION_CALLBACK pSCMAuthenticate;


//
// Device install events
//

#define NUM_INSTALL_EVENTS      2
#define LOGGED_ON_EVENT         0
#define NEEDS_INSTALL_EVENT     1

HANDLE InstallEvents[NUM_INSTALL_EVENTS] = {NULL, NULL};
HANDLE ghNoPendingInstalls = NULL;


//
// Veto definitions
//

#define UnknownVeto(t,n,l) { *(t) = PNP_VetoTypeUnknown; }

#define WinBroadcastVeto(h,t,n,l) { *(t) = PNP_VetoWindowsApp;\
                         GetWindowsExeFileName(h,n,l); }

#define WindowVeto(e,t,n,l) { *(t) = PNP_VetoWindowsApp;\
                         GetClientName(e,n,l); }

#define ServiceVeto(e,t,n,l) { *(t) = PNP_VetoWindowsService;\
                         GetClientName(e,n,l); }

//
// Sentinel for event loop control
//
#define PASS_COMPLETE 0x7fffffff



BOOL
PnpConsoleCtrlHandler(
    DWORD dwCtrlType
    )
/*++

Routine Description:

    This routine handles control signals received by the process for the
    session the process is associated with.

Arguments:

    dwCtrlType - Indicates the type of control signal received by the handler.
                 This value is one of the following:  CTRL_C_EVENT, CTRL_BREAK_EVENT,
                 CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT, CTRL_SHUTDOWN_EVENT


Return Value:

    If the function handles the control signal, it should return TRUE. If it
    returns FALSE, the next handler function in the list of handlers for this
    process is used.

--*/
{
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient;

    switch (dwCtrlType) {

    case CTRL_LOGOFF_EVENT:
        //
        // The system sends the logoff event to the registered console ctrl
        // handlers for a console process when a user is logging off from the
        // session associated with that process.  Since UMPNPMGR runs within the
        // context of the services.exe process, which always resides in session
        // 0, that is the only session for which this handler will receive
        // logoff events.
        //
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: PnpConsoleCtrlHandler: CTRL_LOGOFF_EVENT: Session %d\n",
                   MAIN_SESSION));

        //
        // Close the handle to the user access token for the main session.
        //
        ASSERT(gTokenLock.LockHandles);
        LockPrivateResource(&gTokenLock);
        if (ghUserToken) {
            CloseHandle(ghUserToken);
            ghUserToken = NULL;
        }
        UnlockPrivateResource(&gTokenLock);

        //
        // If the main session was the active Console session, (or should be
        // treated as the active console session because Fast User Switching is
        // disabled) when the user logged off, reset the "logged on" event.
        //
        if (IsConsoleSession(MAIN_SESSION)) {
            if (InstallEvents[LOGGED_ON_EVENT]) {
                ResetEvent(InstallEvents[LOGGED_ON_EVENT]);
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_EVENT,
                           "UMPNPMGR: PnpConsoleCtrlHandler: CTRL_LOGOFF_EVENT: ResetEvent LOGGED_ON_EVENT\n"));
            }
        }

        //
        // If we currently have a device install UI client on this session,
        // we should attempt to close it now, before logging off.
        //
        LockNotifyList(&InstallClientList.Lock);
        pDeviceInstallClient = LocateDeviceInstallClient(MAIN_SESSION);
        if (pDeviceInstallClient) {
            DereferenceDeviceInstallClient(pDeviceInstallClient);
        }
        UnlockNotifyList(&InstallClientList.Lock);

        break;

    default:
        //
        // No special processing for any other events.
        //
        break;

    }

    //
    // Returning FALSE passes this control to the next registered CtrlHandler in
    // the list of handlers for this process (services.exe), so that other
    // services will get a chance to look at this.
    //
    return FALSE;

} // PnpConsoleCtrlHandler



DWORD
InitializePnPManager(
   LPDWORD lpParam
   )
/*++

Routine Description:

  This thread routine is created from srventry.c when services.exe
  attempts to start the plug and play service. The init routine in
  srventry.c does critical initialize then creates this thread to
  do pnp initialization so that it can return back to the service
  controller before pnp init completes.

Arguments:

   lpParam - Not used.


Return Value:

   Currently returns TRUE/FALSE.

--*/
{
    DWORD       dwStatus = TRUE;
    DWORD       ThreadID = 0;
    HANDLE      hThread = NULL, hEventThread = NULL;
    HKEY        hKey = NULL;
    LONG        status;
    BOOL        bGuiModeSetup = FALSE, bFactoryPreInstall = FALSE;
    ULONG       ulSize, ulValue;

    UNREFERENCED_PARAMETER(lpParam);

    KdPrintEx((DPFLTR_PNPMGR_ID,
               DBGF_EVENT,
               "UMPNPMGR: InitializePnPManager\n"));

    //
    // Initialize events that will control when to install devices later.
    //
    InstallEvents[LOGGED_ON_EVENT] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (InstallEvents[LOGGED_ON_EVENT] == NULL) {
        LogErrorEvent(ERR_CREATING_LOGON_EVENT, GetLastError(), 0);
    }

    InstallEvents[NEEDS_INSTALL_EVENT] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (InstallEvents[NEEDS_INSTALL_EVENT] == NULL) {
        LogErrorEvent(ERR_CREATING_INSTALL_EVENT, GetLastError(), 0);
    }

    //
    // Create the pending install event.
    //
    if (!CreateNoPendingInstallEvent()) {
        LogErrorEvent(ERR_CREATING_PENDING_INSTALL_EVENT, GetLastError(), 0);
    }

    ASSERT(ghNoPendingInstalls != NULL);

    //
    // Initialize event to control access to the current session during session
    // change events.  The event state is initially signalled since this service
    // initializes when only session 0 exists (prior to the initialization of
    // termsrv, or the creation of any other sessions).
    //
    ghActiveConsoleSessionEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (ghActiveConsoleSessionEvent == NULL) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL | DBGF_ERRORS,
                   "UMPNPMGR: Failed to initialize ghActiveConsoleSessionEvent!!, error = %d\n",
                   GetLastError()));
    }

    //
    // Setup a console control handler so that I can keep track of logoffs to
    // the main session (SessionId 0).  This is still necessary because Terminal
    // Services may not always be available. (see PNP_ReportLogOn).
    // (I only get logoff notification via this handler so I still
    // rely on the kludge in userinit.exe to tell me about logons).
    //
    if (!SetConsoleCtrlHandler(PnpConsoleCtrlHandler, TRUE)) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT | DBGF_ERRORS,
                   "UMPNPMGR: SetConsoleCtrlHandler failed, error = %d\n",
                   GetLastError()));
    }

    //
    // Acquire a mutex now to make sure I get through this
    // initialization task before getting pinged by a logon
    //
    ghInitMutex = CreateMutex(NULL, TRUE, NULL);
    ASSERT(ghInitMutex != NULL);
    if (ghInitMutex == NULL) {
        return FALSE;
    }

    try {
        //
        // Check if we're running during one of the assorted flavors of setup.
        //
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\Setup"),
                              0,
                              KEY_READ,
                              &hKey);

        if (status == ERROR_SUCCESS) {
            //
            // Determine if factory pre-install is in progress.
            //
            ulValue = 0;
            ulSize = sizeof(ulValue);
            status = RegQueryValueEx(hKey,
                                     TEXT("FactoryPreInstallInProgress"),
                                     NULL,
                                     NULL,
                                     (LPBYTE)&ulValue,
                                     &ulSize);

            if ((status == ERROR_SUCCESS) && (ulValue == 1)) {
                bFactoryPreInstall = TRUE;
                gbSuppressUI = TRUE;
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_EVENT,
                           "UMPNPMGR: Will suppress all UI in Factory Mode\n"));
                LogWarningEvent(WRN_FACTORY_UI_SUPPRESSED, 0, NULL);
            }

            if (!bFactoryPreInstall) {
                //
                // Determine if Gui Mode Setup is in progress (but not mini-setup).
                //
                ulValue = 0;
                ulSize = sizeof(ulValue);
                status = RegQueryValueEx(hKey,
                                         TEXT("SystemSetupInProgress"),
                                         NULL,
                                         NULL,
                                         (LPBYTE)&ulValue,
                                         &ulSize);

                if (status == ERROR_SUCCESS) {
                    bGuiModeSetup = (ulValue == 1);
                }

                if (bGuiModeSetup) {
                    //
                    // Well, we're in GUI-mode setup, but we need to make sure
                    // we're not in mini-setup, or factory pre-install.  We
                    // treat mini-setup like any other boot of the system, and
                    // factory pre-install is a delayed version of a normal
                    // boot.
                    //
                    ulValue = 0;
                    ulSize = sizeof(ulValue);
                    status = RegQueryValueEx(hKey,
                                             TEXT("MiniSetupInProgress"),
                                             NULL,
                                             NULL,
                                             (LPBYTE)&ulValue,
                                             &ulSize);

                    if ((status == ERROR_SUCCESS) && (ulValue == 1)) {
                        //
                        // Well, we're in mini-setup, but we need to make sure
                        // that he doesn't want us to do PnP re-enumeration.
                        //
                        ulValue = 0;
                        ulSize = sizeof(ulValue);
                        status = RegQueryValueEx(hKey,
                                                 TEXT("MiniSetupDoPnP"),
                                                 NULL,
                                                 NULL,
                                                 (LPBYTE)&ulValue,
                                                 &ulSize);

                        if ((status != ERROR_SUCCESS) || (ulValue == 0)) {
                            //
                            // Nope.  Treat this like any other boot of the
                            // system.
                            //
                            bGuiModeSetup = FALSE;
                        }
                    }
                }
            }

            //
            // Determine if this is an OOBE boot.
            //
            ulValue = 0;
            ulSize = sizeof(ulValue);
            status = RegQueryValueEx(hKey,
                                     TEXT("OobeInProgress"),
                                     NULL,
                                     NULL,
                                     (LPBYTE)&ulValue,
                                     &ulSize);

            if (status == ERROR_SUCCESS) {
                gbOobeInProgress = (ulValue == 1);
            }

            //
            // Close the SYSTEM\Setup key.
            //
            RegCloseKey(hKey);
            hKey = NULL;

        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: Failure opening key SYSTEM\\Setup (%d)\n",
                       status));
        }

        //
        // Check if we should consider pre-installation of devices complete.
        //
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\WPA\\PnP"),
                              0,
                              KEY_READ,
                              &hKey);

        if (status == ERROR_SUCCESS) {
            //
            // Check for the "PreservePreInstall" flag to determine if we should
            // preserve settings on preinstalled devices (i.e. do not reinstall
            // finish-install devices).
            //
            ulValue = 0;
            ulSize = sizeof(ulValue);
            status = RegQueryValueEx(hKey,
                                     pszRegValuePreservePreInstall,
                                     NULL,
                                     NULL,
                                     (LPBYTE)&ulValue,
                                     &ulSize);

            if ((status == ERROR_SUCCESS) && (ulValue == 1)) {
                gbPreservePreInstall = TRUE;
            }

            //
            // Check for the "StatelessBoot" flag to determine if this is a
            // stateless boot (no-reboot) boot of the OS.
            //
            ulValue = 0;
            ulSize = sizeof(ulValue);
            status = RegQueryValueEx(hKey,
                                     TEXT("StatelessBoot"),
                                     NULL,
                                     NULL,
                                     (LPBYTE)&ulValue,
                                     &ulSize);

            if ((status == ERROR_SUCCESS) && (ulValue == 1)) {
                gbStatelessBoot = TRUE;
            }

            RegCloseKey(hKey);
            hKey = NULL;
        }

        //
        // If this is EmbeddedNT, check whether PNP should display UI.
        // Note that this is only checked once per system boot, when the
        // service is initialized.
        //
        if (IsEmbeddedNT()) {
            if (RegOpenKeyEx(ghServicesKey,
                             pszRegKeyPlugPlayServiceParams,
                             0,
                             KEY_READ,
                             &hKey) == ERROR_SUCCESS) {

                ulValue = 0;
                ulSize = sizeof(ulValue);

                if ((RegQueryValueEx(hKey,
                                     TEXT("SuppressUI"),
                                     NULL,
                                     NULL,
                                     (LPBYTE)&ulValue,
                                     &ulSize) == ERROR_SUCCESS) && (ulValue == 1)) {
                    gbSuppressUI = TRUE;
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_INSTALL | DBGF_EVENT,
                               "UMPNPMGR: Will suppress all UI on EmbeddedNT\n"));
                    LogWarningEvent(WRN_EMBEDDEDNT_UI_SUPPRESSED, 0, NULL);
                }
                RegCloseKey(hKey);
            }
        }

        //
        // Initialize the interfaces to Hydra, if Hydra is running on this system.
        //
        if (IsTerminalServer()) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT,
                       "UMPNPMGR: Initializing interfaces to Terminal Services.\n"));
            if (!InitializeHydraInterface()) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS | DBGF_EVENT,
                           "UMPNPMGR: Failed to initialize interfaces to Terminal Services!\n"));
            }
        }

        //
        // Initialize the global drive letter mask
        //
        gAllDrivesMask = GetAllVolumeMountPoints();

        //
        // Create a thread that monitors device events.
        //
        hEventThread = CreateThread(NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE)ThreadProc_DeviceEvent,
                                    NULL,
                                    0,
                                    &ThreadID);

        //
        // Create the appropriate thread to handle the device installation.
        // The two cases are when gui mode setup is in progress and for
        // a normal user boot case.
        //

        if (bFactoryPreInstall)  {
            //
            // FactoryPreInstallInProgress
            //
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadProc_FactoryPreinstallDeviceInstall,
                                   NULL,
                                   0,
                                   &ThreadID);
        } else if (bGuiModeSetup) {
            //
            // SystemSetupInProgress,
            // including MiniSetupInProgress with MiniSetupDoPnP
            //
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadProc_GuiSetupDeviceInstall,
                                   NULL,
                                   0,
                                   &ThreadID);
        } else {
            //
            // Standard system boot, or
            // SystemSetupInProgress with MiniSetupInProgress (but not MiniSetupDoPnP)
            //
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadProc_DeviceInstall,
                                   NULL,
                                   0,
                                   &ThreadID);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_EVENT,
                   "UMPNPMGR: Exception in InitializePnPManager!\n"));
        ASSERT(0);
        dwStatus = FALSE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        hThread = hThread;
        hEventThread = hEventThread;
    }

    //
    // signal the init mutex so that logon init activity can procede
    //
    ReleaseMutex(ghInitMutex);

    if (hThread != NULL) {
        CloseHandle(hThread);
    }
    if (hEventThread != NULL) {
        CloseHandle(hEventThread);
    }

    return dwStatus;

} // InitializePnPManager



//------------------------------------------------------------------------
// Post Log-On routines
//------------------------------------------------------------------------



CONFIGRET
PNP_ReportLogOn(
    IN handle_t   hBinding,
    IN BOOL       bAdmin,
    IN DWORD      ProcessID
    )
/*++

Routine Description:

    This routine is used to report logon events.  It is called from the
    userinit.exe process during logon, via CMP_Report_LogOn.

Arguments:

    hBinding  - RPC binding handle.

    bAdmin    - Not used.

    ProcessID - Process ID of the userinit.exe process that will be used to
                retrieve the access token for the user associated with this
                logon.

Return Value:

    Return CR_SUCCESS if the function succeeds, CR_FAILURE otherwise.

Notes:

    When a user logs on to the console session, we signal the "logged on" event,
    which will wake the device installation thread to perform any pending
    client-side device install events.

    Client-side device installation, requires the user access token to create a
    rundll32 process in the logged on user's security context.

    Although Terminal Services is now always running on all flavors of Whistler,
    it is not started during safe mode.  It may also not be started by the time
    session 0 is available for logon as the Console session.  For those reasons,
    SessionId 0 is still treated differently from the other sessions.

    Since Terminal Services may not be available during a logon to session 0, we
    cache a handle to the access token associated with the userinit.exe process.
    The handle is closed when we receive a logoff event for our process's
    session (SessionId 0), via PnpConsoleCtrlHandler.

    Handles to user access tokens for all other sessions are retrieved on
    demand, using GetWinStationUserToken, since Terminal Services must
    necessarily be available for the creation of those sessions.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    HANDLE      hUserProcess = NULL, hUserToken = NULL;
    RPC_STATUS  rpcStatus;
    DWORD       dwWait;
    ULONG       ulSessionId, ulSessionIdCopy;
    PWSTR       MultiSzGuidList = NULL;

    UNREFERENCED_PARAMETER(bAdmin);

    //
    // This routine only services requests from local RPC clients.
    //
    if (!IsClientLocal(hBinding)) {
        return CR_ACCESS_DENIED;
    }

    //
    // Wait for the init mutex - this ensures that the pnp init
    // routine (called when the service starts) has had a chance
    // to complete first.
    //
    if (ghInitMutex != NULL) {

        dwWait = WaitForSingleObject(ghInitMutex, 180000);  // 3 minutes

        if (dwWait != WAIT_OBJECT_0) {
            //
            // mutex was abandoned or timed out during the wait,
            // don't attempt any further init activity
            //
            return CR_FAILURE;
        }
    }

    try {
        //
        // Make sure that the caller is a member of the interactive group.
        //
        if (!IsClientInteractive(hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Impersonate the client and retrieve the SessionId.
        //
        rpcStatus = RpcImpersonateClient(hBinding);
        if (rpcStatus != RPC_S_OK) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: PNP_ReportLogOn: RpcImpersonateClient failed, error = %d\n",
                       rpcStatus));
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Keep track of the client's session.
        //
        ulSessionId = GetClientLogonId();
        ulSessionIdCopy = ulSessionId;
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: PNP_ReportLogOn: SessionId %d\n",
                   ulSessionId));

        //
        // NTRAID #181685-2000/09/11-jamesca:
        //
        //   Currently, terminal services send notification of logons to
        //   "remote" sessions before the server's process creation thread is
        //   running.  If we set the logged on event, and there are devices
        //   waiting to be installed, we will immediately call
        //   CreateProcessAsUser on that session, which will fail.  As a
        //   (temporary?) workaround, we'll continue to use PNP_ReportLogOn to
        //   receive logon notification from userinit.exe, now for all sessions.
        //

        //
        // If this is a logon to SessionId 0, save a handle to the access token
        // associated with the userinit.exe process.  We need this later to
        // create a rundll32 process in the logged on user's security context
        // for client-side device installation and hotplug notifications.
        //
        if (ulSessionId == MAIN_SESSION) {

            ASSERT(gTokenLock.LockHandles);
            LockPrivateResource(&gTokenLock);

            //
            // We should have gotten rid of the cached user token during logoff,
            // so if we still have one, ignore this spurious logon report.
            //
            //ASSERT(ghUserToken == NULL);

            if (ghUserToken == NULL) {
                //
                // While still impersonating the client, open a handle to the user
                // access token of the calling process (userinit.exe).
                //
                hUserProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, ProcessID);

                if (hUserProcess) {

                    if (OpenProcessToken(
                            hUserProcess,
                            TOKEN_ALL_ACCESS,
                            &hUserToken)) {

                        ASSERT(hUserToken != NULL);

                        //
                        // Duplicate the userinit process token so that we have
                        // one of our own that we can safely enable/disable
                        // privileges for, without affecting that process.
                        //
                        if (!DuplicateTokenEx(
                                hUserToken,
                                0, NULL,
                                SecurityImpersonation,
                                TokenPrimary,
                                &ghUserToken)) {

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_ERRORS,
                                       "UMPNPMGR: PNP_ReportLogOn: "
                                       "DuplicateTokenEx failed, error = %d\n",
                                       GetLastError()));
                            ghUserToken = NULL;
                        }

                        CloseHandle(hUserToken);
                    }

                    CloseHandle(hUserProcess);

                } else {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: PNP_ReportLogOn: OpenProcess failed, error = %d\n",
                               rpcStatus));
                    ASSERT(0);
                }
            }

            ASSERT(ghUserToken);
            UnlockPrivateResource(&gTokenLock);
        }

        //
        // Stop impersonating.
        //
        rpcStatus = RpcRevertToSelf();

        if (rpcStatus != RPC_S_OK) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: PNP_ReportLogOn: RpcRevertToSelf failed, error = %d\n",
                       rpcStatus));
            ASSERT(rpcStatus == RPC_S_OK);
        }

        //
        // If this is a logon to the "Console" session, signal the event that
        // indicates a Console user is currently logged on.
        //
        if (IsConsoleSession(ulSessionId)) {
            if (InstallEvents[LOGGED_ON_EVENT]) {
                SetEvent(InstallEvents[LOGGED_ON_EVENT]);
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT | DBGF_INSTALL,
                           "UMPNPMGR: PNP_ReportLogOn: SetEvent LOGGED_ON_EVENT\n"));
            }
        }

        //
        // For every logon to every session, send a generic blocked driver
        // notification if the system has blocked any drivers from loading so
        // far this boot.
        //
        MultiSzGuidList = BuildBlockedDriverList((LPGUID)NULL, 0);
        if (MultiSzGuidList != NULL) {
            SendHotplugNotification((LPGUID)&GUID_DRIVER_BLOCKED,
                                    NULL,
                                    MultiSzGuidList,
                                    &ulSessionId,
                                    0);
            HeapFree(ghPnPHeap, 0, MultiSzGuidList);
            MultiSzGuidList = NULL;
        }
        ulSessionId = ulSessionIdCopy;
        //
        // Check if there were any invalid IDs encountered before we started
        // and send notification to user as needed.
        //
        SendInvalidIDNotifications(ulSessionId);


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in PNP_ReportLogOn\n"));
        ASSERT(0);
        Status = CR_FAILURE;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        ghInitMutex = ghInitMutex;
        MultiSzGuidList = MultiSzGuidList;
    }

    if (ghInitMutex != NULL) {
        ReleaseMutex(ghInitMutex);
    }

    if (MultiSzGuidList != NULL) {
        HeapFree(ghPnPHeap, 0, MultiSzGuidList);
    }

    return Status;

} // PNP_ReportLogon


typedef struct _DEVICE_INSTALL_ENTRY {
    SIZE_T  Index;
    ULONG   Depth;
}DEVICE_INSTALL_ENTRY, *PDEVICE_INSTALL_ENTRY;

int
__cdecl
compare_depth(
    const void *a,
    const void *b
    )
{
    PDEVICE_INSTALL_ENTRY entry1, entry2;

    entry1 = (PDEVICE_INSTALL_ENTRY)a;
    entry2 = (PDEVICE_INSTALL_ENTRY)b;

    if (entry1->Depth > entry2->Depth) {

        return -1;
    } else if (entry1->Depth < entry2->Depth) {

        return 1;
    }
    return 0;
}



DWORD
ThreadProc_GuiSetupDeviceInstall(
    LPDWORD lpThreadParam
    )
/*++

Routine Description:

    This routine is a thread procedure. This thread is only active during GUI-mode setup
    and passes device notifications down a pipe to setup.
    There are two passes, which *must* match exactly with the two passes in GUI-setup
    Once the passes are complete, we proceed to Phase-2 of normal serverside install

Arguments:

   lpThreadParam - Not used.

Return Value:

   Not used, currently returns result of ThreadProc_DeviceInstall - which will normally not return

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    LPWSTR      pDeviceList = NULL, pszDevice = NULL;
    ULONG       ulSize = 0, ulConfig, Pass, threadID;
    ULONG       ulPostSetupSkipPhase1 = TRUE;
    HANDLE      hPipeEvent = NULL, hPipe = NULL, hBatchEvent = NULL, hThread = NULL;
    PPNP_INSTALL_ENTRY entry = NULL;
    PDEVICE_INSTALL_ENTRY pSortArray = NULL;
    LONG        lCount;
    BOOL        needsInstall;
    ULONG       ulReenumerationCount;

    UNREFERENCED_PARAMETER(lpThreadParam);

    try {

        //
        // 2 Passes, must match up with the 2 passes in SysSetup.
        // generally, most, if not all devices, will be picked up
        // and installed by syssetup
        //

        for (Pass = 1; Pass <= 2; Pass++) {

            ulReenumerationCount = 0;
            //
            // If Gui mode setup is in progress, we don't need to wait for a logon
            // event. Just wait on the event that indicates when gui mode setup
            // has opened the pipe and is ready to recieve device names. Attempt to
            // create the event first (in case I beat setup to it), if it exists
            // already then just open it by name. This is a manual reset event.
            //

            hPipeEvent = CreateEvent(NULL, TRUE, FALSE, PNP_CREATE_PIPE_EVENT);
            if (!hPipeEvent) {
                if (GetLastError() == ERROR_ALREADY_EXISTS) {
                    hPipeEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, PNP_CREATE_PIPE_EVENT);
                    if (!hPipeEvent) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                } else {
                    Status = CR_FAILURE;
                    goto Clean0;
                }
            }

            if (WaitForSingleObject(hPipeEvent, INFINITE) != WAIT_OBJECT_0) {
                Status = CR_FAILURE;
                goto Clean0;    // event must have been abandoned
            }

            //
            // Reset the manual-reset event back to the non-signalled state.
            //

            ResetEvent(hPipeEvent);

            hBatchEvent = CreateEvent(NULL, TRUE, FALSE, PNP_BATCH_PROCESSED_EVENT);
            if (!hBatchEvent) {
                if (GetLastError() == ERROR_ALREADY_EXISTS) {
                    hBatchEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, PNP_BATCH_PROCESSED_EVENT);
                    if (!hBatchEvent) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                } else {
                    Status = CR_FAILURE;
                    goto Clean0;
                }
            }

            //
            // Open the client side of the named pipe, the server side was opened
            // by gui mode setup.
            //

            if (!WaitNamedPipe(PNP_NEW_HW_PIPE, PNP_PIPE_TIMEOUT)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_ERRORS,
                           "UMPNPMGR: ThreadProc_GuiSetupDeviceInstall: WaitNamedPipe failed!\n"));
                Status = CR_FAILURE;
                goto Clean0;
            }

            hPipe = CreateFile(PNP_NEW_HW_PIPE,
                               GENERIC_WRITE,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hPipe == INVALID_HANDLE_VALUE) {
                LogErrorEvent(ERR_CREATING_SETUP_PIPE, GetLastError(), 0);
                Status = CR_FAILURE;
                goto Clean0;
            }


            //
            // Retreive the list of all devices for all enumerators
            // Start out with a reasonably-sized buffer (16K characters) in
            // hopes of avoiding 2 calls to get the device list.
            //
            ulSize = 16384;

            for ( ; ; ) {

                pDeviceList = HeapAlloc(ghPnPHeap, 0, ulSize * sizeof(WCHAR));
                if (pDeviceList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                Status = PNP_GetDeviceList(NULL, NULL, pDeviceList, &ulSize, 0);
                if (Status == CR_SUCCESS) {
                    break;
                } else if(Status == CR_BUFFER_SMALL) {
                    //
                    // Our initial buffer wasn't large enough.  Free the current
                    // buffer.
                    //
                    HeapFree(ghPnPHeap, 0, pDeviceList);
                    pDeviceList = NULL;

                    //
                    // Now, go ahead and make the call to retrieve the actual
                    // size required.
                    //
                    Status = PNP_GetDeviceListSize(NULL, NULL, &ulSize, 0);
                    if (Status != CR_SUCCESS) {
                        goto Clean0;
                    }
                } else {
                    //
                    // We failed for some reason other than buffer-too-small.
                    // Bail now.
                    //
                    goto Clean0;
                }
            }

            //
            // Count the number of devices we are installing.
            //
            for (pszDevice = pDeviceList, lCount = 0;
                *pszDevice;
                pszDevice += lstrlen(pszDevice) + 1, lCount++) {
            }

            pSortArray = HeapAlloc(ghPnPHeap, 0, lCount * sizeof(DEVICE_INSTALL_ENTRY));
            if (pSortArray) {

                NTSTATUS    ntStatus;
                PLUGPLAY_CONTROL_DEPTH_DATA depthData;
                LPWSTR      pTempList;
                HRESULT     hr;

                //
                // Initialize all the information we need to sort devices.
                //
                for (pszDevice = pDeviceList, lCount = 0;
                    *pszDevice;
                    pszDevice += lstrlen(pszDevice) + 1, lCount++) {

                    pSortArray[lCount].Index = pszDevice - pDeviceList;
                    depthData.DeviceDepth = 0;
                    RtlInitUnicodeString(&depthData.DeviceInstance, pszDevice);
                    ntStatus = NtPlugPlayControl(PlugPlayControlGetDeviceDepth,
                                                 &depthData,
                                                 sizeof(depthData));
                    pSortArray[lCount].Depth = depthData.DeviceDepth;
                }

                //
                // Sort the array so that deeper devices are ahead.
                //
                qsort(pSortArray, lCount, sizeof(DEVICE_INSTALL_ENTRY), compare_depth);

                //
                // Copy the data so that the device instance strings are sorted.
                //
                pTempList = HeapAlloc(ghPnPHeap, 0, ulSize * sizeof(WCHAR));

                if (pTempList) {

                    for (pszDevice = pTempList, lCount--; lCount >= 0; lCount--) {

                        hr = StringCchCopyEx(
                            pszDevice,
                            ulSize,
                            &pDeviceList[pSortArray[lCount].Index],
                            NULL, NULL,
                            STRSAFE_NULL_ON_FAILURE);

                        ASSERT(SUCCEEDED(hr));

                        if (SUCCEEDED(hr)) {
                            ulSize -= lstrlen(pszDevice);
                        }

                        pszDevice += lstrlen(pszDevice) + 1;
                    }

                    *pszDevice = TEXT('\0');
                    HeapFree(ghPnPHeap, 0, pDeviceList);
                    pDeviceList = pTempList;
                }
                HeapFree(ghPnPHeap, 0, pSortArray);
            }
            //
            // PHASE 1
            //
            // Search the registry for devices to install.
            //

            for (pszDevice = pDeviceList;
                *pszDevice;
                pszDevice += lstrlen(pszDevice) + 1) {

                //
                // Is device present?
                //
                if (IsDeviceIdPresent(pszDevice)) {

                    if (Pass == 1) {

                        //
                        // First time through, pass everything in the registry to
                        // guimode setup via the pipe, whether they are marked as
                        // needing to be installed or not.
                        //

                        if (!WriteFile(hPipe,
                                       pszDevice,
                                       (lstrlen(pszDevice)+1) * sizeof(WCHAR),
                                       &ulSize,
                                       NULL)) {

                            LogErrorEvent(ERR_WRITING_SETUP_PIPE, GetLastError(), 0);
                        }

                    } else {

                        //
                        // Second time through, only pass along anything
                        // that is marked as needing to be installed.
                        //
                        DevInstNeedsInstall(pszDevice, FALSE, &needsInstall);

                        if (needsInstall) {

                            if (!WriteFile(hPipe,
                                           pszDevice,
                                           (lstrlen(pszDevice)+1) * sizeof(WCHAR),
                                           &ulSize,
                                           NULL)) {

                                LogErrorEvent(ERR_WRITING_SETUP_PIPE, GetLastError(), 0);
                            }
                        }
                    }
                } else if (Pass == 1) {
                    //
                    // device ID is not present
                    // we should have marked this as needs re-install
                    //
                    ulConfig = GetDeviceConfigFlags(pszDevice, NULL);

                    if ((ulConfig & CONFIGFLAG_REINSTALL)==0) {

                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_INSTALL | DBGF_WARNINGS,
                                   "UMPNPMGR: Setup - %ws not present and not marked as needing reinstall - setting CONFIGFLAG_REINSTALL\n",
                                   pszDevice));

                        ulConfig |= CONFIGFLAG_REINSTALL;

                        PNP_SetDeviceRegProp(NULL,
                                             pszDevice,
                                             CM_DRP_CONFIGFLAGS,
                                             REG_DWORD,
                                             (LPBYTE)&ulConfig,
                                             sizeof(ulConfig),
                                             0
                                            );

                    }
                }
            }

            //
            // PHASE 2
            //

            do {

                //
                // Write a NULL ID to indicate end of this batch.
                //

                if (!WriteFile(hPipe,
                               TEXT(""),
                               sizeof(WCHAR),
                               &ulSize,
                               NULL)) {

                    LogErrorEvent(ERR_WRITING_SETUP_PIPE, GetLastError(), 0);
                }

                //
                // Wait for gui mode setup to complete processing of the last
                // batch.
                //

                if (WaitForSingleObject(hBatchEvent,
                                        PNP_GUISETUP_INSTALL_TIMEOUT) != WAIT_OBJECT_0) {

                    //
                    // The event was either abandoned or timed out, give up.
                    //
                    goto Clean1;
                }
                ResetEvent(hBatchEvent);

                //
                // Reenumerate the tree from the ROOT on a separate thread.
                //

                hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadProc_ReenumerateDeviceTree,
                                   (LPVOID)pszRegRootEnumerator,
                                   0,
                                   &threadID);
                if (hThread == NULL) {

                    goto Clean1;
                }
                if (WaitForSingleObject(hThread,
                                        PNP_GUISETUP_INSTALL_TIMEOUT) != WAIT_OBJECT_0) {

                    //
                    // The event was either abandadoned or timed out, give up.
                    //
                    goto Clean1;
                }

                //
                // Check if we have reenumerated for too long.
                //

                if (++ulReenumerationCount >= MAX_REENUMERATION_COUNT) {
                    //
                    // Either something is wrong with one of the enumerators in 
                    // the system (more likely) or this device tree is 
                    // unreasonably deep. In the latter case, the remaining 
                    // devices will get installed post setup.
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_INSTALL | DBGF_ERRORS,
                               "UMPNPMGR: ThreadProc_GuiSetupDeviceInstall: "
                               "Reenumerated %d times, some enumerator is misbehaving!\n",
                               ulReenumerationCount));

                    ASSERT(ulReenumerationCount < MAX_REENUMERATION_COUNT);

                    goto Clean1;
                }
                //
                // If we dont have any devices in the install list, we are done.
                //

                if (InstallList.Next == NULL) {
                    break;
                }

                //
                // Install any new devices found as a result of setting up the
                // previous batch of devices.
                //
                lCount = 0;
                LockNotifyList(&InstallList.Lock);
                while (InstallList.Next != NULL) {
                    //
                    // Retrieve and remove the first (oldest) entry in the
                    // install device list.
                    //
                    entry = (PPNP_INSTALL_ENTRY)InstallList.Next;
                    InstallList.Next = entry->Next;
                    UnlockNotifyList(&InstallList.Lock);

                    ASSERT(!(entry->Flags & (PIE_SERVER_SIDE_INSTALL_ATTEMPTED | PIE_DEVICE_INSTALL_REQUIRED_REBOOT)));

                    //
                    // Should we install this device?
                    //
                    DevInstNeedsInstall(entry->szDeviceId, FALSE, &needsInstall);

                    if (needsInstall) {

                        //
                        // Give this device name to gui mode setup via the pipe
                        //
                        if (!WriteFile(hPipe,
                                       entry->szDeviceId,
                                       (lstrlen(entry->szDeviceId)+1) * sizeof(WCHAR),
                                       &ulSize,
                                       NULL)) {

                            LogErrorEvent(ERR_WRITING_SETUP_PIPE, GetLastError(), 0);
                        } else {

                            lCount++;
                        }
                    }
                    HeapFree(ghPnPHeap, 0, entry);

                    LockNotifyList(&InstallList.Lock);
                }

                UnlockNotifyList(&InstallList.Lock);

            } while (lCount > 0);

        Clean1:

            CloseHandle(hPipe);
            hPipe = INVALID_HANDLE_VALUE;

            CloseHandle(hPipeEvent);
            hPipeEvent = NULL;

            CloseHandle(hBatchEvent);
            hBatchEvent = NULL;

            if (hThread) {
                CloseHandle(hThread);
                hThread = NULL;
            }

            HeapFree(ghPnPHeap, 0, pDeviceList);
            pDeviceList = NULL;

        } // for

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_INSTALL,
                   "UMPNPMGR: Exception in ThreadProc_GuiSetupDeviceInstall\n"));
        ASSERT(0);
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        hPipe = hPipe;
        hPipeEvent = hPipeEvent;
        hBatchEvent = hBatchEvent;
        hThread = hThread;
        pDeviceList = pDeviceList;
    }

    if (hPipe != INVALID_HANDLE_VALUE) {
        CloseHandle(hPipe);
    }
    if (hPipeEvent != NULL) {
        CloseHandle(hPipeEvent);
    }
    if (hBatchEvent != NULL) {
        CloseHandle(hBatchEvent);
    }
    if (hThread) {
        CloseHandle(hThread);
    }
    if (pDeviceList != NULL) {
        HeapFree(ghPnPHeap, 0, pDeviceList);
    }

    //
    // will typically never return
    //
    return ThreadProc_DeviceInstall(&ulPostSetupSkipPhase1);

} // ThreadProc_GuiSetupDeviceInstall



DWORD
ThreadProc_FactoryPreinstallDeviceInstall(
    LPDWORD lpThreadParam
    )
/*++

Routine Description:

    This routine is a thread procedure. This thread is only active during
    GUI-mode setup when we are doing a factory preinstall.

    This function simply creates and event, and then waits before kicking off
    normal pnp device install

Arguments:

   lpThreadParam - Not used.

Return Value:

   Not used, currently returns result of ThreadProc_DeviceInstall - which will
   normally not return.

--*/
{
    HANDLE      hEvent = NULL;
    CONFIGRET   Status = CR_SUCCESS;

    UNREFERENCED_PARAMETER(lpThreadParam);

    try {
        hEvent = CreateEvent(NULL, TRUE, FALSE, PNP_CREATE_PIPE_EVENT);
        if (!hEvent) {
            if (GetLastError() == ERROR_ALREADY_EXISTS) {
                hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, PNP_CREATE_PIPE_EVENT);
                if (!hEvent) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

            } else {
                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        if (WaitForSingleObject(hEvent, INFINITE) != WAIT_OBJECT_0) {
            Status = CR_FAILURE;
            goto Clean0;    // event must have been abandoned
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_INSTALL,
                   "UMPNPMGR: Exception in ThreadProc_FactoryPreinstallDeviceInstall\n"));
        ASSERT(0);
        Status = CR_FAILURE;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        hEvent = hEvent;
    }

    if (hEvent != NULL) {
        CloseHandle(hEvent);
    }

    //
    // will typically never return
    //
    return ThreadProc_DeviceInstall(NULL);

} // ThreadProc_FactoryPreinstallDeviceInstall



//-----------------------------------------------------------------------------
// Device enumeration thread - created on demand
//-----------------------------------------------------------------------------

DWORD
ThreadProc_ReenumerateDeviceTree(
    LPVOID  lpThreadParam
    )
/*++

Routine Description:

    This routine is a thread procedure. This thread is created dynamically to
    perform a synchronous device re-enumeration.

    This thread can be waited on and abandoned after a specified timeout, if
    necessary.

Arguments:

    lpThreadParam - Specifies a pointer to the device instance path that should
                    be re-enumerated.

Return Value:

    Not used, currently returns 0.

--*/
{
    PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA controlData;

    //
    // Reenumerate the tree from the root specified.
    //

    memset(&controlData, 0 , sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
    controlData.Flags = 0;
    RtlInitUnicodeString(&controlData.DeviceInstance, (PCWSTR)lpThreadParam);

    NtPlugPlayControl(PlugPlayControlEnumerateDevice,
                      &controlData,
                      sizeof(controlData));

    return 0;

} // ThreadProc_ReenumerateDeviceTree



//-----------------------------------------------------------------------------
// Device installation thread
//-----------------------------------------------------------------------------

DWORD
ThreadProc_DeviceInstall(
    LPDWORD lpParam
    )
/*++

Routine Description:

    This routine is a thread procedure.
    It is invoked during a normal boot, or after the GUI-setup special case has finished
    During Phase-1, all devices are checked
    During Phase-2, all new devices are checked as they arrive.

Arguments:

   lpParam - if given and non-zero (currently only when called from ThreadProc_GuiSetupDeviceInstall)
             skips Phase-1, will never prompt for reboot

Return Value:

   Not used, currently returns Status failure code, should typically not return

--*/
{
    CONFIGRET Status = CR_SUCCESS;
    LPWSTR    pDeviceList = NULL, pszDevice = NULL;
    ULONG     ulSize = 0, ulProblem = 0, ulStatus, ulConfig;
    DWORD     InstallDevStatus, WaitResult;
    PPNP_INSTALL_ENTRY InstallEntry = NULL;
    PPNP_INSTALL_ENTRY current, TempInstallList, CurDupeNode, PrevDupeNode;
    BOOL InstallListLocked = FALSE;
    BOOL RebootRequired, needsInstall;
    BOOL DeviceHasProblem = FALSE, SingleDeviceHasProblem = FALSE;
    BOOL bStillInGuiModeSetup = lpParam ? (BOOL)lpParam[0] : FALSE;
    ULONG ulClientSessionId = INVALID_SESSION;
    ULONG ulFlags = 0;
    HANDLE hAutoStartEvent;
    HRESULT hr;


    if (!bStillInGuiModeSetup) {

        //
        // If the OOBE is not running, wait until the service control manager
        // has begun starting autostart services before we attempt to install
        // any devices.  When the OOBE is running, we don't wait for anything
        // because the OOBE waits on us (via CMP_WaitNoPendingInstallEvents) to
        // finish server-side installing any devices that we can before it lets
        // the SCM autostart services and set this event.
        //
        if (!gbOobeInProgress) {

            hAutoStartEvent = OpenEvent(SYNCHRONIZE,
                                        FALSE,
                                        SC_AUTOSTART_EVENT_NAME);

            if (hAutoStartEvent) {
                //
                // Wait until the service controller allows other services to
                // start before we try to install any devices in phases 1 and 2,
                // below.
                //
                WaitResult = WaitForSingleObject(hAutoStartEvent, INFINITE);
                ASSERT(WaitResult == WAIT_OBJECT_0);

                CloseHandle(hAutoStartEvent);

            } else {
                //
                // The service controller always creates this event, so it must
                // exist by the time our service is started.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_ERRORS,
                           "UMPNPMGR: Failed to open %ws event, error = %d\n",
                           SC_AUTOSTART_EVENT_NAME,
                           GetLastError()));
                ASSERT(0);
            }
        }


        try {
            //
            // Phase 1:
            //
            // Check the enum branch in the registry and attempt to install, one
            // right after the other, any devices that need to be installed right
            // now.  Typically these devices showed up during boot.
            //
            // Retrieve the list of devices that currently need to be installed.
            // Start out with a reasonably-sized buffer (16K characters) in hopes
            // of avoiding 2 calls to get the device list.
            //
            // this phase is skipped during GUI-mode setup, and is handled by
            // ThreadProc_GuiSetupDeviceInstall
            //
            ulSize = 16384;

            for ( ; ; ) {

                pDeviceList = HeapAlloc(ghPnPHeap, 0, ulSize * sizeof(WCHAR));
                if (pDeviceList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean1;
                }

                Status = PNP_GetDeviceList(NULL, NULL, pDeviceList, &ulSize, 0);
                if (Status == CR_SUCCESS) {
                    break;
                } else if(Status == CR_BUFFER_SMALL) {
                    //
                    // Our initial buffer wasn't large enough.  Free the current
                    // buffer.
                    //
                    HeapFree(ghPnPHeap, 0, pDeviceList);
                    pDeviceList = NULL;

                    //
                    // Now, go ahead and make the call to retrieve the actual size
                    // required.
                    //
                    Status = PNP_GetDeviceListSize(NULL, NULL, &ulSize, 0);
                    if (Status != CR_SUCCESS) {
                        goto Clean1;
                    }
                } else {
                    //
                    // We failed for some reason other than buffer-too-small.  Bail
                    // now.
                    //
                    goto Clean1;
                }
            }

            //
            // Make sure we have the device installer APIs at our disposal
            // before starting server-side install.
            //
            InstallDevStatus = LoadDeviceInstaller();
            if (InstallDevStatus != NO_ERROR) {
                goto Clean1;
            }

            //
            // Get the config flag for each device, and install any that need to be
            // installed.
            //
            for (pszDevice = pDeviceList;
                 *pszDevice;
                 pszDevice += lstrlen(pszDevice) + 1) {

                //
                // Should the device be installed?
                //
                if (DevInstNeedsInstall(pszDevice, FALSE, &needsInstall) == CR_SUCCESS) {

                    if (needsInstall) {

                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_INSTALL,
                                   "UMPNPMGR: Installing device (%ws) server-side\n",
                                   pszDevice));

                        RebootRequired = FALSE;

                        //
                        // Make sure we have the device installer APIs at our disposal
                        // before starting server-side install.
                        //
                        InstallDevStatus = LoadDeviceInstaller();

                        if (InstallDevStatus == NO_ERROR) {

                            if (IsFastUserSwitchingEnabled()) {
                                ulFlags = DEVICE_INSTALL_DISPLAY_ON_CONSOLE;
                            } else {
                                ulClientSessionId = MAIN_SESSION;
                                ulFlags = 0;
                            }

                            //
                            // Attempt server-side installation of this device.
                            //
                            InstallDevStatus = InstallDeviceServerSide(pszDevice,
                                                                       &RebootRequired,
                                                                       &SingleDeviceHasProblem,
                                                                       &ulClientSessionId,
                                                                       ulFlags);

                        }

                        if(InstallDevStatus == NO_ERROR) {

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_INSTALL,
                                       "UMPNPMGR: Installing device (%ws), Server-side installation succeeded!\n",
                                       pszDevice));

                            if (SingleDeviceHasProblem) {
                                DeviceHasProblem = TRUE;
                            }

                        } else {

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_INSTALL,
                                       "UMPNPMGR: Installing device (%ws), Server-side installation failed (Status = 0x%08X)\n",
                                       pszDevice,
                                       InstallDevStatus));
                        }

                        if((InstallDevStatus != NO_ERROR) || RebootRequired) {
                            //
                            // Allocate and initialize a new device install entry
                            // block.
                            //
                            InstallEntry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_INSTALL_ENTRY));
                            if(!InstallEntry) {
                                Status = CR_OUT_OF_MEMORY;
                                goto Clean1;
                            }

                            InstallEntry->Next = NULL;
                            InstallEntry->Flags = PIE_SERVER_SIDE_INSTALL_ATTEMPTED;
                            if(InstallDevStatus == NO_ERROR) {
                                //
                                // We didn't get here because the install failed,
                                // so it must've been because the installation
                                // requires a reboot.
                                //
                                ASSERT(RebootRequired);
                                InstallEntry->Flags |= PIE_DEVICE_INSTALL_REQUIRED_REBOOT;

                                //
                                // Set the global server side device install
                                // reboot needed bool to TRUE.
                                //
                                gServerSideDeviceInstallRebootNeeded = TRUE;
                            }

                            //
                            // Copy the Device ID to the install list entry.
                            // Upon failure, we will just end up adding an
                            // install entry with a NULL device id to the list.
                            // Non ideal, but we should still do it so that we
                            // can preserve the flags that may indicate a reboot
                            // is required.
                            //
                            hr = StringCchCopyEx(InstallEntry->szDeviceId,
                                                 MAX_DEVICE_ID_LEN,
                                                 pszDevice,
                                                 NULL, NULL,
                                                 STRSAFE_NULL_ON_FAILURE);
                            ASSERT(SUCCEEDED(hr));

                            //
                            // Insert this entry in the device install list.
                            //
                            LockNotifyList(&InstallList.Lock);
                            InstallListLocked = TRUE;

                            current = (PPNP_INSTALL_ENTRY)InstallList.Next;
                            if(!current) {
                                InstallList.Next = InstallEntry;
                            } else {
                                while((PPNP_INSTALL_ENTRY)current->Next) {
                                    current = (PPNP_INSTALL_ENTRY)current->Next;
                                }
                                current->Next = InstallEntry;
                            }

                            //
                            // Newly-allocated entry now added to the list--NULL
                            // out the pointer so we won't try to free it if we
                            // happen to encounter an exception later.
                            //
                            InstallEntry = NULL;

                            UnlockNotifyList(&InstallList.Lock);
                            InstallListLocked = FALSE;

                            SetEvent(InstallEvents[NEEDS_INSTALL_EVENT]);
                        }
                    }
                } else {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_INSTALL,
                               "UMPNPMGR: Ignoring not present device (%ws)\n",
                               pszDevice));
                }
            }

        Clean1:
            //
            // Up to this point, we have only attempted server-side installation
            // of devices, so any device install clients we might have launched
            // would have been for UI only.  Since we are done installing
            // devices for the time being, we should unload the device installer
            // APIs, and get rid of any device install clients that currently
            // exist.
            //
            UnloadDeviceInstaller();

        } except(EXCEPTION_EXECUTE_HANDLER) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS | DBGF_INSTALL,
                       "UMPNPMGR: Exception in ThreadProc_DeviceInstall\n"));
            ASSERT(0);
            Status = CR_FAILURE;

            //
            // Reference the following variables so the compiler will respect
            // statement ordering w.r.t. assignment.
            //
            pDeviceList = pDeviceList;
            InstallListLocked = InstallListLocked;
            InstallEntry = InstallEntry;
        }

        if(InstallEntry) {
            HeapFree(ghPnPHeap, 0, InstallEntry);
            InstallEntry = NULL;
        }

        if(InstallListLocked) {
            UnlockNotifyList(&InstallList.Lock);
            InstallListLocked = FALSE;
        }

        if(pDeviceList != NULL) {
            HeapFree(ghPnPHeap, 0, pDeviceList);
        }
    }

    //
    // NOTE: We should remove this line if we ever hook up the 'finished
    // installing hardware' balloon so that it comes up if we install devices
    // before a user logs on.
    //
    DeviceHasProblem = FALSE;

    //
    // Maintain a temporary list of PNP_INSTALL_ENTRY nodes that we needed to
    // initiate client-side installation for, but couldn't these nodes get
    // re-added to the master InstallList once all entries have been processed.
    // Also, keep a pointer to the end of the list for efficient appending of
    // nodes to the queue.
    //
    current = TempInstallList = NULL;

    try {
        //
        // Phase 2: Hang around and be prepared to install any devices
        //          that come on line for the first time while we're
        //          running.
        //          we may come into Phase 2 (skipping Phase 1) in GUI-Setup
        //
        for ( ; ; ) {

            //
            // Before starting an indefinite wait, test the event state and set
            // the ghNoPendingInstalls event accordingly.  This event is just a
            // backdoor way for device manager (and others) to see if we're
            // still installing things.
            //
            if(WaitForSingleObject(InstallEvents[NEEDS_INSTALL_EVENT], 0) != WAIT_OBJECT_0) {
                //
                // There's nothing waiting to be installed--set the event.
                //
                SetEvent(ghNoPendingInstalls);
            }

            //
            // Wait until the device event thread tells us we need to
            // dynamically install a new device (or until somebody logs on).
            //
            WaitForMultipleObjects(NUM_INSTALL_EVENTS,
                                   InstallEvents,
                                   FALSE,           // wake up on either event
                                   INFINITE         // I can wait all day
                                   );

            //
            // After I empty the list, this thread can sleep until another new
            // device needs to be installed...
            //
            ResetEvent(InstallEvents[NEEDS_INSTALL_EVENT]);

            //
            // ...or until a user logs in (note that we only want to awake once
            // per log-in.
            //
            ResetEvent(InstallEvents[LOGGED_ON_EVENT]);

            //
            // We now have something to do, so reset the event that lets folks
            // like DevMgr know when we're idle.
            //
            ResetEvent(ghNoPendingInstalls);

#if DBG
            RtlValidateHeap(ghPnPHeap,0,NULL);
#endif
            //
            // Process each device that needs to be installed.
            //
            while (InstallList.Next != NULL) {
                //
                // Retrieve and remove the first (oldest) entry in the
                // install device list.
                //
                LockNotifyList(&InstallList.Lock);
                InstallListLocked = TRUE;

                InstallEntry = (PPNP_INSTALL_ENTRY)InstallList.Next;
                InstallList.Next = InstallEntry->Next;

                //
                // Now, scan the rest of the list looking for additional nodes
                // related to this same device.  If we find any, OR their flags
                // into our 'master' node, and remove the duplicated nodes from
                // the list.  We can get duplicates due to the fact that both
                // the event thread and this thread can be placing items in the
                // list.  We don't want to be attempting (failing) server-side
                // installations multiple times.
                //
                CurDupeNode = (PPNP_INSTALL_ENTRY)InstallList.Next;
                PrevDupeNode = NULL;

                while(CurDupeNode) {

                    if (CompareString(
                            LOCALE_INVARIANT, NORM_IGNORECASE,
                            InstallEntry->szDeviceId, -1,
                            CurDupeNode->szDeviceId, -1) == CSTR_EQUAL) {
                        //
                        // We have a duplicate!  OR the flags into those of
                        // the install entry we retrieved from the head of
                        // the list.
                        //
                        InstallEntry->Flags |= CurDupeNode->Flags;

                        //
                        // Now remove this duplicate node from the list.
                        //
                        if(PrevDupeNode) {
                            PrevDupeNode->Next = CurDupeNode->Next;
                        } else {
                            InstallList.Next = CurDupeNode->Next;
                        }

                        HeapFree(ghPnPHeap, 0, CurDupeNode);

                        if(PrevDupeNode) {
                            CurDupeNode = (PPNP_INSTALL_ENTRY)PrevDupeNode->Next;
                        } else {
                            CurDupeNode = (PPNP_INSTALL_ENTRY)InstallList.Next;
                        }

                    } else {
                        PrevDupeNode = CurDupeNode;
                        CurDupeNode = (PPNP_INSTALL_ENTRY)CurDupeNode->Next;
                    }
                }

                UnlockNotifyList(&InstallList.Lock);
                InstallListLocked = FALSE;

                if(InstallEntry->Flags & PIE_DEVICE_INSTALL_REQUIRED_REBOOT) {
                    //
                    // We've already performed a (successful) server-side
                    // installation on this device.  Remember the fact that a
                    // reboot is needed, so we'll prompt after processing this
                    // batch of new hardware.
                    //
                    // This will be our last chance to prompt for reboot on this
                    // node, because the next thing we're going to do is free
                    // this install entry!
                    //
                    gServerSideDeviceInstallRebootNeeded = TRUE;

                } else {
                    //
                    // Verify that device really needs to be installed
                    //

                    ulConfig = GetDeviceConfigFlags(InstallEntry->szDeviceId, NULL);
                    Status = GetDeviceStatus(InstallEntry->szDeviceId, &ulStatus, &ulProblem);

                    if (Status == CR_SUCCESS) {
                        //
                        // Note that we must explicitly check below for the
                        // presence of the CONFIGFLAG_REINSTALL config flag. We
                        // can't simply rely on the CM_PROB_REINSTALL problem
                        // being set, because we may have encountered a device
                        // during our phase 1 processing whose installation was
                        // deferred because it provided finish-install wizard
                        // pages.  Since we only discover that this is the case
                        // _after_ successful completion of DIF_INSTALLDEVICE,
                        // it's too late to set the problem (kernel-mode PnP
                        // manager only allows us to set a problem of needs-
                        // reboot for a running devnode).
                        //

                        Status =
                            DevInstNeedsInstall(
                                InstallEntry->szDeviceId,
                                TRUE,
                                &needsInstall);

                        if ((Status == CR_SUCCESS) && needsInstall) {

                            if(!(InstallEntry->Flags & PIE_SERVER_SIDE_INSTALL_ATTEMPTED)) {
                                //
                                // We haven't tried to install this device
                                // server-side yet, so try that now.
                                //
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_INSTALL,
                                           "UMPNPMGR: Installing device (%ws) server-side\n\t  Status = 0x%08X\n\t  Problem = %d\n\t  ConfigFlags = 0x%08X\n",
                                           InstallEntry->szDeviceId,
                                           ulStatus,
                                           ulProblem,
                                           ulConfig));

                                //
                                // Make sure we have the device installer APIs at our disposal
                                // before starting server-side install.
                                //
                                InstallDevStatus = LoadDeviceInstaller();

                                if (InstallDevStatus == NO_ERROR) {

                                    if (IsFastUserSwitchingEnabled()) {
                                        ulFlags = DEVICE_INSTALL_DISPLAY_ON_CONSOLE;
                                    } else {
                                        ulClientSessionId = MAIN_SESSION;
                                        ulFlags = 0;
                                    }

                                    InstallDevStatus = InstallDeviceServerSide(
                                        InstallEntry->szDeviceId,
                                        &gServerSideDeviceInstallRebootNeeded,
                                        &SingleDeviceHasProblem,
                                        &ulClientSessionId,
                                        ulFlags);
                                }

                                if(InstallDevStatus == NO_ERROR) {
                                    KdPrintEx((DPFLTR_PNPMGR_ID,
                                               DBGF_INSTALL,
                                               "UMPNPMGR: Installing device (%ws), Server-side installation succeeded!\n",
                                               InstallEntry->szDeviceId));

                                    if (SingleDeviceHasProblem) {
                                        DeviceHasProblem = TRUE;
                                    }

                                } else {
                                    KdPrintEx((DPFLTR_PNPMGR_ID,
                                               DBGF_INSTALL,
                                               "UMPNPMGR: Installing device (%ws), Server-side installation failed (Status = 0x%08X)\n",
                                               InstallEntry->szDeviceId,
                                               InstallDevStatus));

                                    InstallEntry->Flags |= PIE_SERVER_SIDE_INSTALL_ATTEMPTED;
                                }

                            } else {
                                //
                                // Set some bogus error so we'll drop into the
                                // non-server install codepath below.
                                //
                                InstallDevStatus = ERROR_INVALID_DATA;
                            }

                            if(InstallDevStatus != NO_ERROR) {

                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_INSTALL,
                                           "UMPNPMGR: Installing device (%ws) client-side\n\t  Status = 0x%08X\n\t  Problem = %d\n\t  ConfigFlags = 0x%08X\n",
                                           InstallEntry->szDeviceId,
                                           ulStatus,
                                           ulProblem,
                                           ulConfig));

                                if (IsFastUserSwitchingEnabled()) {
                                    ulFlags = DEVICE_INSTALL_DISPLAY_ON_CONSOLE;
                                } else {
                                    ulClientSessionId = MAIN_SESSION;
                                    ulFlags = 0;
                                }

                                if (!InstallDevice(InstallEntry->szDeviceId,
                                                   &ulClientSessionId,
                                                   ulFlags)) {
                                    //
                                    // We weren't able to kick off a device
                                    // install on the client side (probably
                                    // because no one was logged in).  Stick
                                    // this PNP_INSTALL_ENTRY node into a
                                    // temporary list that we'll re-add into
                                    // the InstallList queue once we've emptied
                                    // it.
                                    //
                                    if(current) {
                                        current->Next = InstallEntry;
                                        current = InstallEntry;
                                    } else {
                                        ASSERT(!TempInstallList);
                                        TempInstallList = current = InstallEntry;
                                    }

                                    //
                                    // NULL out the InstallEntry pointer so we
                                    // don't try to free it later.
                                    //
                                    InstallEntry = NULL;
                                }
                            }

                        } else if((ulStatus & DN_HAS_PROBLEM) &&
                                  (ulProblem == CM_PROB_NEED_RESTART)) {
                            //
                            // This device was percolated up from kernel-mode
                            // for the sole purpose of requesting a reboot.
                            // This presently only happens when we encounter a
                            // duplicate devnode, and we then "unique-ify" it
                            // to keep from bugchecking.  We don't want the
                            // unique-ified devnode to actually be installed/
                            // used.  Instead, we just want to give the user a
                            // prompt to reboot, and after they reboot, all
                            // should be well.  The scenario where this has
                            // arisen is in relation to a USB printer (with a
                            // serial number) that is moved from one port to
                            // another during a suspend.  When we resume, we
                            // have both an arrival and a removal to process,
                            // and if we process the arrival first, we think
                            // we've found a dupe.
                            //
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_INSTALL,
                                       "UMPNPMGR: Duplicate device detected (%ws), need to prompt user to reboot!\n",
                                       InstallEntry->szDeviceId));

                            //
                            // Stick this entry into our temporary list to deal
                            // with later...
                            //
                            if(current) {
                                current->Next = InstallEntry;
                                current = InstallEntry;
                            } else {
                                ASSERT(!TempInstallList);
                                TempInstallList = current = InstallEntry;
                            }

                            //
                            // If possible, we want to prompt for reboot right
                            // away (that is, after all install events are
                            // drained)...
                            //
                            gServerSideDeviceInstallRebootNeeded = TRUE;

                            //
                            // If no user is logged in yet, flag this install
                            // entry so we'll try to prompt for reboot the next
                            // time we're awakened (which hopefully will be due
                            // to a user logging in).
                            //
                            InstallEntry->Flags |= PIE_DEVICE_INSTALL_REQUIRED_REBOOT;

                            //
                            // NULL out the InstallEntry pointer so we
                            // don't try to free it later.
                            //
                            InstallEntry = NULL;
                        }
                    }
                }

                if(InstallEntry) {
                    HeapFree(ghPnPHeap, 0, InstallEntry);
                    InstallEntry = NULL;
                }
            }

            //
            // We've processed all device install events known to us at this
            // time.  If we encountered any device whose installation requires
            // a reboot, prompt the logged-in user (if any) to reboot now.
            //
            if (gServerSideDeviceInstallRebootNeeded) {

                ulFlags = DEVICE_INSTALL_FINISHED_REBOOT;

                if (IsFastUserSwitchingEnabled()) {
                    ulFlags |= DEVICE_INSTALL_DISPLAY_ON_CONSOLE;
                } else {
                    ulClientSessionId = MAIN_SESSION;
                }

                if (bStillInGuiModeSetup) {
                    //
                    // if we're still in GUI setup, we're going to suppress
                    // any reboot prompts
                    //
                    gServerSideDeviceInstallRebootNeeded = FALSE;
                } else if (PromptUser(&ulClientSessionId,
                                      ulFlags)) {
                    //
                    // We successfully delivered the reboot prompt, so if the
                    // user chose to ignore it, we don't want to prompt again
                    // for reboot the next time new hardware shows up (unless
                    // that hardware also requires a reboot).
                    //
                    gServerSideDeviceInstallRebootNeeded = FALSE;
                }
            }

            if(TempInstallList) {
                //
                // Add our temporary list of PNP_INSTALL_ENTRY nodes back into
                // the InstallList queue.  We _do not_ set the event that says
                // there's more to do, so these nodes will be seen again only
                // if (a) somebody logs in or (b) more new hardware shows up.
                //
                // Note: we cannot assume that the list is empty, because there
                // may have been an insertion after the last time we checked it
                // above.  We want to add our stuff to the beginning of the
                // InstallList queue, since the items we just finished
                // processing appeared before any new entries that might be
                // there now.
                //
                LockNotifyList(&InstallList.Lock);
                InstallListLocked = TRUE;

                ASSERT(current);

                current->Next = InstallList.Next;
                InstallList.Next = TempInstallList;

                //
                // Null out our temporary install list pointers to indicate
                // that the list is now empty.
                //
                current = TempInstallList = NULL;

                UnlockNotifyList(&InstallList.Lock);
                InstallListLocked = FALSE;

            }

            //
            // Before starting an indefinite wait, test the InstallEvents to see
            // if there any new devices to install, or there are still devices
            // to be installed in the InstallList.  If neither of these is the
            // case after waiting a few seconds, we'll notify the user that
            // we're done installing devices for now, unload setupapi, and close
            // all device install clients.
            //
            WaitResult = WaitForMultipleObjects(NUM_INSTALL_EVENTS,
                                                InstallEvents,
                                                FALSE,
                                                DEVICE_INSTALL_COMPLETE_WAIT_TIME);

            if ((WaitResult != (WAIT_OBJECT_0 + NEEDS_INSTALL_EVENT)) &&
                (InstallList.Next == NULL)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: ThreadProc_DeviceInstall: no more devices to install.\n"));

                //
                // There's nothing waiting to be installed--set the event.
                //
                SetEvent(ghNoPendingInstalls);

                //
                // Notify the user (if any), that we think we're done installing
                // devices for now.  Note that if we never used a device install
                // client at any time in this pass (all server-side or silent
                // installs), then we won't prompt about this.
                //
                ulFlags = DEVICE_INSTALL_BATCH_COMPLETE;

                if (DeviceHasProblem) {
                    ulFlags |= DEVICE_INSTALL_PROBLEM;
                }

                if (IsFastUserSwitchingEnabled()) {
                    ulFlags |= DEVICE_INSTALL_DISPLAY_ON_CONSOLE;
                } else {
                    ulClientSessionId = MAIN_SESSION;
                }

                PromptUser(&ulClientSessionId,
                           ulFlags);

                //
                // Clear the DeviceHasProblem boolean since we just notified the
                // user.
                //
                DeviceHasProblem = FALSE;

                //
                // We notified the user, now wait around for 10 more seconds
                // from the time of prompting before closing the client to make
                // sure that some new device doesn't arrive, in which case we
                // would just immediately load the installer again.
                //
                WaitResult = WaitForMultipleObjects(NUM_INSTALL_EVENTS,
                                                    InstallEvents,
                                                    FALSE,
                                                    DEVICE_INSTALL_COMPLETE_DISPLAY_TIME);
                if ((WaitResult != (WAIT_OBJECT_0 + NEEDS_INSTALL_EVENT)) &&
                    (InstallList.Next == NULL)) {
                    //
                    // Unload the device installer, and get rid of any device
                    // install clients that currently exist on any sessions.
                    // Note that closing the device install client will make the
                    // above prompt go away.
                    //
                    UnloadDeviceInstaller();
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_INSTALL,
                   "UMPNPMGR: Exception in ThreadProc_DeviceInstall\n"));
        ASSERT(0);
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        InstallListLocked = InstallListLocked;
        InstallEntry = InstallEntry;
        TempInstallList = TempInstallList;
    }

    if(InstallListLocked) {
        UnlockNotifyList(&InstallList.Lock);
    }

    if(InstallEntry) {
        HeapFree(ghPnPHeap, 0, InstallEntry);
    }

    while(TempInstallList) {
        current = (PPNP_INSTALL_ENTRY)(TempInstallList->Next);
        HeapFree(ghPnPHeap, 0, TempInstallList);
        TempInstallList = current;
    }

    //
    // meaningless return value, since this thread should never exit.
    //
    return (DWORD)Status;

} // ThreadProc_DeviceInstall



BOOL
InstallDevice(
    IN     LPWSTR pszDeviceId,
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    )
/*++

Routine Description:

    This routine initiates a device installation with the device install client
    (newdev.dll) on the current active console session, creating one if
    necessary.  This routine waits for the client to signal completion, the
    process to signal that it has terminated, or this service to signal that we
    have disconnected ourselves from the client.

Arguments:

    pszDeviceId - device instance ID of the devnode to be installed.

    SessionId - Supplies the address of a variable containing the SessionId on
        which the device install client is to be displayed.  If successful, the
        SessionId will contain the session on which the device install client
        process was launched.  Otherwise, will contain an invalid SessionId,
        INVALID_SESSION (0xFFFFFFFF).

    Flags - Specifies flags describing the behavior of the device install client.
        The following flags are currently defined:

        DEVICE_INSTALL_DISPLAY_ON_CONSOLE - if specified, the value in the
           SessionId variable will be ignored, and the device installclient will
           always be displayed on the current active console session.  The
           SessionId of the current active console session will be returned in
           the SessionId.

Return Value:

    Returns TRUE is the device installation was completed by the device install
    client, FALSE otherwise.

--*/
{
    BOOL b;
    HANDLE hFinishEvents[3] = { NULL, NULL, NULL };
    DWORD dwWait;
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient = NULL;
    HRESULT hr;


    //
    // Assume failure
    //
    b = FALSE;

    //
    // Validate parameters
    //
    ASSERT(SessionId);
    if (SessionId == NULL) {
        return FALSE;
    }

    try {
        //
        // Calling DoDeviceInstallClient will create the newdev.dll process and open a named
        // pipe if it isn't already been done earlier.  It will then send the Device Id to
        // newdev.dll over the pipe.
        //
        if (DoDeviceInstallClient(pszDeviceId,
                                  SessionId,
                                  Flags,
                                  &pDeviceInstallClient)) {

            ASSERT(pDeviceInstallClient);
            ASSERT(pDeviceInstallClient->ulSessionId == *SessionId);

            //
            // Keep track of the device id last sent to this client before we
            // disconnected from it.  This will avoid duplicate popups if we
            // reconnect to this session again, and attempt to client-side
            // install the same device.
            //
            hr = StringCchCopyEx(pDeviceInstallClient->LastDeviceId,
                                 MAX_DEVICE_ID_LEN,
                                 pszDeviceId,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE);
            //
            // Upon failure, the recorded LastDeviceId is NULL, so we will not
            // be able to determine what device this client last handled.  Not
            // ideal, but not fatal either.
            //
            ASSERT(SUCCEEDED(hr));

            //
            // Wait for the device install to be signaled from newdev.dll
            // to let us know that it has completed the installation.
            //
            // Wait on the client's process as well, to catch the case
            // where the process crashes (or goes away) without signaling the
            // device install event.
            //
            // Also wait on the disconnect event in case we have explicitly
            // disconnected from the client while switching sessions.
            //
            hFinishEvents[0] = pDeviceInstallClient->hProcess;
            hFinishEvents[1] = pDeviceInstallClient->hEvent;
            hFinishEvents[2] = pDeviceInstallClient->hDisconnectEvent;

            dwWait = WaitForMultipleObjects(3, hFinishEvents, FALSE, INFINITE);

            if (dwWait == WAIT_OBJECT_0) {
                //
                // If the return is WAIT_OBJECT_0 then the newdev.dll
                // process has gone away.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: InstallDevice: process signalled, closing device install client!\n"));

            } else if (dwWait == (WAIT_OBJECT_0 + 1)) {
                //
                // If the return is WAIT_OBJECT_0 + 1 then the device
                // installer successfully received the request.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: InstallDevice: device install succeeded\n"));
                b = TRUE;

                //
                // This device install client is no longer processing any
                // devices, so clear the device id.
                //
                *pDeviceInstallClient->LastDeviceId = L'\0';

            } else if (dwWait == (WAIT_OBJECT_0 + 2)) {
                //
                // If the return is WAIT_OBJECT_0 + 2 then we were explicitly
                // disconnected from the device install client.  Consider the
                // device install unsuccessful so that this device remains in
                // the install list.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: InstallDevice: device install client disconnected\n"));

            } else {
                //
                // The wait was satisfied for some reason other than the
                // specified objects.  This should never happen, but just in
                // case, we'll close the client.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_ERRORS,
                           "UMPNPMGR: InstallDevice: wait completed unexpectedly!\n"));
            }

            //
            // Remove the reference placed on the client while it was in use.
            //
            LockNotifyList(&InstallClientList.Lock);

            DereferenceDeviceInstallClient(pDeviceInstallClient);

            if ((dwWait != (WAIT_OBJECT_0 + 1)) &&
                (dwWait != (WAIT_OBJECT_0 + 2))) {
                //
                // Unless the client signalled successful receipt of the
                // request, or the client's session was disconnected from the
                // console, the attempt to use this client was unsuccessful.
                // Remove the initial reference so all associated handles will
                // be closed and the entry will be freed when it is no longer in
                // use.
                //

                //
                // Note that if we were unsuccessful because of a
                // logoff, we would have already dereferenced the
                // client then, in which case the above dereference
                // was the final one, and pDeviceInstallClient would
                // be invalid.  Instead, attempt to re-locate the
                // client by the session id.
                //
                pDeviceInstallClient = LocateDeviceInstallClient(*SessionId);
                if (pDeviceInstallClient) {
                    ASSERT(pDeviceInstallClient->RefCount == 1);
                    DereferenceDeviceInstallClient(pDeviceInstallClient);
                }
            }

            UnlockNotifyList(&InstallClientList.Lock);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_INSTALL,
                   "UMPNPMGR: Exception in InstallDevice!\n"));
        ASSERT(0);
        b = FALSE;
    }

    return b;

} // InstallDevice


//-----------------------------------------------------------------------------
// Device event server-side rpc routines
//-----------------------------------------------------------------------------


CONFIGRET
PNP_RegisterNotification(
    IN  handle_t hBinding,
    IN  ULONG_PTR  hRecipient,
    IN  LPWSTR   ServiceName,
    IN  LPBYTE   NotificationFilter,
    IN  ULONG    ulSize,
    IN  DWORD    Flags,
    OUT PNP_NOTIFICATION_CONTEXT *Context,
    IN  ULONG    ProcessId,
    IN  ULONG64  *ClientContext
    )

/*++

Routine Description:

    This routine is the rpc server-side of the CMP_RegisterNotification routine.
    It performs the remaining parameter validation and actually registers the
    notification request appropriately.

Arguments:

   hBinding     - RPC binding handle.

   hRecipient   - The Flags value specifies what type of handle this is,
                  currently it's either a window handle or a service handle.

   NotificationFilter - Specifies a pointer to one of the DEV_BROADCAST_XXX
                  structures.

   ulSize       - Specifies the size of the NotificationFilter structure.

   Flags        - Specifies additional paramters used to describe the client or
                  the supplied parameters.  The Flags parameter is subdivided
                  into multiple fields that are interpreted separately, as
                  described below.

               ** The Flags parameter contains a field that describes the type
                  of the hRecipient handle passed in.  This field should be
                  interpreted as an enum, and can be extracted from the Flags
                  parameter using the following mask:

                      DEVICE_NOTIFY_HANDLE_MASK

                  Currently one of the following values must be specified by
                  this field:

                  DEVICE_NOTIFY_WINDOW_HANDLE - hRecipient is a window handle
                      (HWND) for a window whose WNDPROC will be registered to
                      receive WM_DEVICECHANGE window messages for the filtered
                      events specified by the supplied NotificationFilter.

                  DEVICE_NOTIFY_SERVICE_HANDLE - hRecipient is a service status
                      handle (SERVICE_STATUS_HANDLE) for a service whose
                      HandlerEx routine will be registered to receive
                      SERVICE_CONTROL_DEVICEEVENT service controls for the
                      filtered events specified by the supplied
                      NotificationFilter.

                      NOTE: in reality - hRecipient is just the name of the
                      service, as resolved by the cfgmgr32 client.  the SCM will
                      actually resolve this name for us to the true
                      SERVICE_STATUS_HANDLE for this service.

                  DEVICE_NOTIFY_COMPLETION_HANDLE - not currently implemented.


               ** The Flags parameter contains a field that described additional
                  properties for the notification.  This field should be
                  interpreted as a bitmask, and can be extracted from the Flags
                  parameter using the following mask:

                      DEVICE_NOTIFY_PROPERTY_MASK

                  Currently, the following flags are defined for this field:

                  DEVICE_NOTIFY_ALL_INTERFACE_CLASSES - This flag is only valid
                      when a DBT_DEVTYP_DEVICEINTERFACE type notification filter
                      is supplied.  This flag specifies that the caller wishes
                      to receive notification of events for device interfaces of
                      all classes.  If this flag is specified, the
                      dbcc_classguid member of the NotificationFilter structure
                      is ignored.

               ** The Flags parameter also contains a "Reserved" field, that is
                  reserved for use by the cfgmgr32 client to this interface
                  only.  This field should be interpreted as a bitmask, and can
                  be extracted from the Flags parameter using the following
                  mask:

                      DEVICE_NOTIFY_RESERVED_MASK

                  Currently, the following flags are defined for this field:

                  DEVICE_NOTIFY_WOW64_CLIENT - Specifies to a 64-bit server
                      caller is a 32-bit process running on WOW64.  The 64-bit
                      server uses this information to construct 32-bit
                      compatible notification filters for the client.

   Context      - On return, this value returns the server notification context
                  to the client, that is supplied when unregistering this
                  notification request.

   hProcess     - Process Id of the calling application.

   ClientContext - Specifies a pointer to a 64-bit value that contains the
                  client-context pointer.  This value is the HDEVNOTIFY
                  notification handle returned to caller upon successful
                  registration.  It is actually a pointer to the client memory
                  that will reference the returned server-notification context
                  pointer - but is never used as a pointer here on the
                  server-side.  It is only used by the server to be specified as
                  the dbch_hdevnotify member of the DEV_BROADCAST_HANDLE
                  notification structure, supplied to the caller on
                  DBT_DEVTYP_HANDLE notification events.

                  NOTE: This value is truncated to 32-bits on 32-bit platforms,
                  but is always transmitted as a 64-bit value by the RPC
                  interface - for consistent marshalling of the data by RPC for
                  all 32-bit / 64-bit client / server combinations.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one
    of the CR_* errors.

Notes:

    This RPC server interface is used by local RPC clients only; it is never
    called remotely.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    RPC_STATUS rpcStatus;
    DEV_BROADCAST_HDR UNALIGNED *p;
    PPNP_NOTIFY_ENTRY entry = NULL;
    ULONG hashValue, ulSessionId;
    HANDLE hProcess = NULL, localHandle = NULL;
    PPNP_NOTIFY_LIST notifyList = NULL;
    BOOLEAN bLocked = FALSE, bCritSecHeld = FALSE;


    //
    // This routine only services requests from local RPC clients.
    //
    if (!IsClientLocal(hBinding)) {
        return CR_ACCESS_DENIED;
    }

    try {
        //
        // Validate parameters.
        //
        if (!ARGUMENT_PRESENT(Context)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *Context = NULL;

        if ((!ARGUMENT_PRESENT(NotificationFilter)) ||
            (!ARGUMENT_PRESENT(ClientContext)) ||
            (*ClientContext == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // the RPC interface specifies ServiceName as a [ref] parameter,
        // so it should never be NULL.
        //
        ASSERT(ARGUMENT_PRESENT(ServiceName));

        //
        // DEVICE_NOTIFY_BITS is a private mask, defined specifically for
        // validation by the client and server.  It contains the bitmask for all
        // handle types (DEVICE_NOTIFY_COMPLETION_HANDLE specifically excluded
        // below), and all other flags that are currently defined - both public
        // and reserved.
        //
        if (INVALID_FLAGS(Flags, DEVICE_NOTIFY_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Completion handles are not currently implemented.
        // DEVICE_NOTIFY_COMPLETION_HANDLE defined privately in winuserp.h,
        // reserved for future use (??).
        //
        if ((Flags & DEVICE_NOTIFY_HANDLE_MASK) ==
            DEVICE_NOTIFY_COMPLETION_HANDLE) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Make sure the Notification filter is a valid size.
        //
        if ((ulSize < sizeof(DEV_BROADCAST_HDR)) ||
            (((PDEV_BROADCAST_HDR)NotificationFilter)->dbch_size < sizeof(DEV_BROADCAST_HDR))) {
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        ASSERT(ulSize == ((PDEV_BROADCAST_HDR)NotificationFilter)->dbch_size);

        //
        // Impersonate the client and retrieve the SessionId.
        //
        rpcStatus = RpcImpersonateClient(hBinding);
        if (rpcStatus != RPC_S_OK) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: RpcImpersonateClient failed, error = %d\n",
                       rpcStatus));
            Status = CR_FAILURE;
            goto Clean0;
        }

        ulSessionId = GetClientLogonId();

        rpcStatus = RpcRevertToSelf();
        if (rpcStatus != RPC_S_OK) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                       rpcStatus));
            ASSERT(rpcStatus == RPC_S_OK);
        }

        //
        // Handle the different types of notification filters.
        //
        p = (PDEV_BROADCAST_HDR)NotificationFilter;

        switch (p->dbch_devicetype) {

        case DBT_DEVTYP_OEM:
        case DBT_DEVTYP_VOLUME:
        case DBT_DEVTYP_PORT:
        case DBT_DEVTYP_NET:
            //
            // These structures are either obsolete, or used for broadcast-only
            // notifications.
            //
            Status = CR_INVALID_DATA;
            break;


        case DBT_DEVTYP_HANDLE: {
            //
            // DEV_BROADCAST_HANDLE based notification.
            //
            DEV_BROADCAST_HANDLE UNALIGNED *filter = (PDEV_BROADCAST_HANDLE)NotificationFilter;
            PLUGPLAY_CONTROL_TARGET_RELATION_DATA controlData;
            NTSTATUS ntStatus;
#ifdef _WIN64
            DEV_BROADCAST_HANDLE64 UNALIGNED filter64;

            //
            // Check if the client is running on WOW64.
            //
            if (Flags & DEVICE_NOTIFY_WOW64_CLIENT) {
                //
                // Convert the 32-bit DEV_BROADCAST_HANDLE notification filter
                // to 64-bit.
                //
                DEV_BROADCAST_HANDLE32 UNALIGNED *filter32 = (PDEV_BROADCAST_HANDLE32)NotificationFilter;

                //
                // Validate the 32-bit input filter data
                //
                ASSERT(filter32->dbch_size >= sizeof(DEV_BROADCAST_HANDLE32));
                if (filter32->dbch_size < sizeof(DEV_BROADCAST_HANDLE32) ||
                    ulSize < sizeof(DEV_BROADCAST_HANDLE32)) {
                    Status = CR_INVALID_DATA;
                    goto Clean0;
                }

                memset(&filter64, 0, sizeof(DEV_BROADCAST_HANDLE64));
                filter64.dbch_size = sizeof(DEV_BROADCAST_HANDLE64);
                filter64.dbch_devicetype = DBT_DEVTYP_HANDLE;
                filter64.dbch_handle = (ULONG64)filter32->dbch_handle;

                //
                // use the converted 64-bit filter and size from now on, instead
                // of the caller supplied 32-bit filter.
                //
                filter = (PDEV_BROADCAST_HANDLE)&filter64;
                ulSize = sizeof(DEV_BROADCAST_HANDLE64);
            }
#endif // _WIN64

            //
            // Validate the input filter data
            //
            if (filter->dbch_size < sizeof(DEV_BROADCAST_HANDLE) ||
                ulSize < sizeof(DEV_BROADCAST_HANDLE)) {
                Status = CR_INVALID_DATA;
                goto Clean0;
            }

            //
            // The DEVICE_NOTIFY_INCLUDE_ALL_INTERFACE_CLASSES flag is only
            // valid for the DBT_DEVTYP_DEVICEINTERFACE notification filter
            // type.
            //
            if ((Flags & DEVICE_NOTIFY_PROPERTY_MASK) &
                DEVICE_NOTIFY_ALL_INTERFACE_CLASSES) {
                Status = CR_INVALID_FLAG;
                goto Clean0;
            }

            entry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_NOTIFY_ENTRY));
            if (entry == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            //
            // Find the device id that corresponds to this file handle.
            // In this case, use a duplicated instance of the file handle
            // for this process, not the caller's process.
            //
            rpcStatus = RpcImpersonateClient(hBinding);
            if (rpcStatus != RPC_S_OK) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: RpcImpersonateClient failed, error = %d\n",
                           rpcStatus));
                Status = CR_FAILURE;
                HeapFree(ghPnPHeap, 0, entry);
                goto Clean0;
            }

            hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, ProcessId);
            if (hProcess == NULL) {
                //
                // Last error set by OpenProcess routine
                //
                Status = CR_FAILURE;
                HeapFree(ghPnPHeap, 0, entry);
                rpcStatus = RpcRevertToSelf();
                if (rpcStatus != RPC_S_OK) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                               rpcStatus));
                    ASSERT(rpcStatus == RPC_S_OK);
                }
                goto Clean0;
            }


            if (!DuplicateHandle(hProcess,
                                 (HANDLE)filter->dbch_handle,
                                 GetCurrentProcess(),
                                 &localHandle,
                                 0,
                                 FALSE,
                                 DUPLICATE_SAME_ACCESS)) {
                //
                // Last error set by DuplicateHandle routine
                //
                Status = CR_FAILURE;
                HeapFree(ghPnPHeap, 0, entry);
                CloseHandle(hProcess);
                rpcStatus = RpcRevertToSelf();
                if (rpcStatus != RPC_S_OK) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                               rpcStatus));
                    ASSERT(rpcStatus == RPC_S_OK);
                }
                goto Clean0;
            }

            rpcStatus = RpcRevertToSelf();
            if (rpcStatus != RPC_S_OK) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                           rpcStatus));
                ASSERT(rpcStatus == RPC_S_OK);
            }

            memset(&controlData, 0 , sizeof(PLUGPLAY_CONTROL_TARGET_RELATION_DATA));
            controlData.UserFileHandle = localHandle;
            controlData.DeviceInstance = entry->u.Target.DeviceId;
            controlData.DeviceInstanceLen = sizeof(entry->u.Target.DeviceId);

            ntStatus = NtPlugPlayControl(PlugPlayControlTargetDeviceRelation,
                                         &controlData,
                                         sizeof(controlData));

            CloseHandle(localHandle);
            CloseHandle(hProcess);

            if (!NT_SUCCESS(ntStatus)) {
                Status = MapNtStatusToCmError(ntStatus);
                HeapFree(ghPnPHeap, 0, entry);
                goto Clean0;
            }

            //
            // Sanitize the device id
            //
            FixUpDeviceId(entry->u.Target.DeviceId);

            //
            // Copy the client name for the window or service, supplied by
            // ServiceName.  The maximum service name buffer length required for
            // services is MAX_SERVICE_NAME_LEN (256 characters), which should
            // be a reasonable limit for both.
            //
            if (ARGUMENT_PRESENT(ServiceName)) {

                HRESULT hr;
                size_t  ServiceNameLen = 0;

                hr = StringCchLength(ServiceName,
                                     MAX_SERVICE_NAME_LEN,
                                     &ServiceNameLen);
                if (FAILED(hr)) {
                    ServiceNameLen = MAX_SERVICE_NAME_LEN - 1;
                }

                entry->ClientName =
                    (LPWSTR)HeapAlloc(
                        ghPnPHeap, 0,
                        (ServiceNameLen+1)*sizeof(WCHAR));

                if (entry->ClientName == NULL) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_WARNINGS,
                               "UMPNPMGR: PNP_RegisterNotification "
                               "failed to allocate memory for ClientName!\n"));
                    Status = CR_OUT_OF_MEMORY;
                    HeapFree (ghPnPHeap,0,entry);
                    goto Clean0;
                }

                //
                // Copy to the allocated buffer, truncating if necessary.
                //
                hr = StringCchCopy(entry->ClientName,
                                   ServiceNameLen + 1,
                                   ServiceName);
                ASSERT(SUCCEEDED(hr));

            } else {
                entry->ClientName = NULL;
            }

            //
            // Resolve the service status handle from the supplied service name.
            //
            if ((Flags & DEVICE_NOTIFY_HANDLE_MASK) == DEVICE_NOTIFY_SERVICE_HANDLE) {

                hRecipient = (ULONG_PTR)NULL;

                if ((pSCMAuthenticate != NULL) &&
                    (ARGUMENT_PRESENT(ServiceName))) {

                    SERVICE_STATUS_HANDLE serviceHandle;

                    if (pSCMAuthenticate(ServiceName, &serviceHandle) == NO_ERROR) {
                        hRecipient = (ULONG_PTR)serviceHandle;
                    }
                }

                if (!hRecipient) {
                    Status = CR_INVALID_DATA;
                    if (entry->ClientName) {
                        HeapFree(ghPnPHeap, 0, entry->ClientName);
                    }
                    HeapFree(ghPnPHeap, 0, entry);
                    *Context = NULL;
                    goto Clean0;
                }
            }

            //
            // Add this entry to the target list
            //
            entry->Signature = TARGET_ENTRY_SIGNATURE;
            entry->Handle = (HANDLE)hRecipient;
            entry->Flags = Flags;
            entry->Unregistered = FALSE;
            entry->Freed = 0;
            entry->SessionId = ulSessionId;

            //
            // Save the caller's file handle (to pass back to caller
            // during notification).
            //
            entry->u.Target.FileHandle = filter->dbch_handle;

            EnterCriticalSection(&RegistrationCS);
            bCritSecHeld = TRUE;

            if (gNotificationInProg != 0) {
                //
                // If a notification is happening, add this entry to the list of
                // deferred registrations.
                //
                PPNP_DEFERRED_LIST regNode;
                regNode = (PPNP_DEFERRED_LIST)
                    HeapAlloc(ghPnPHeap,
                              0,
                              sizeof (PNP_DEFERRED_LIST));
                if (!regNode) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS | DBGF_WARNINGS,
                               "UMPNPMGR: Error allocating deferred list entry during registration!\n"));
                    Status = CR_OUT_OF_MEMORY;
                    if (entry->ClientName) {
                        HeapFree(ghPnPHeap, 0, entry->ClientName);
                    }
                    HeapFree(ghPnPHeap, 0, entry);
                    LeaveCriticalSection(&RegistrationCS);
                    bCritSecHeld = FALSE;
                    goto Clean0;
                }
                //
                // Do not notify this entry until after the current
                // notification is finished.
                //
                entry->Unregistered = TRUE;
                regNode->hBinding = 0;
                regNode->Entry = entry;
                regNode->Next = RegisterList;
                RegisterList = regNode;
            }

            hashValue = HashString(entry->u.Target.DeviceId, TARGET_HASH_BUCKETS);
            notifyList = &TargetList[hashValue];
            MarkEntryWithList(entry,hashValue);
            LockNotifyList(&notifyList->Lock);
            bLocked = TRUE;
            AddNotifyEntry(&TargetList[hashValue], entry);
            entry->ClientCtxPtr = (ULONG64)*ClientContext;
            *Context = entry;
            UnlockNotifyList(&notifyList->Lock);
            bLocked = FALSE;

            LeaveCriticalSection(&RegistrationCS);
            bCritSecHeld = FALSE;
            break;
        }


        case DBT_DEVTYP_DEVICEINTERFACE: {

            DEV_BROADCAST_DEVICEINTERFACE UNALIGNED *filter = (PDEV_BROADCAST_DEVICEINTERFACE)NotificationFilter;

            //
            // Validate the input filter data
            //
            if (filter->dbcc_size < sizeof(DEV_BROADCAST_DEVICEINTERFACE) ||
                ulSize < sizeof (DEV_BROADCAST_DEVICEINTERFACE) ) {
                Status = CR_INVALID_DATA;
                goto Clean0;
            }

            //
            // We no longer support the private GUID_DEVNODE_CHANGE interface so return
            // CR_INVALID_DATA if this GUID is passed in.
            //
            if (GuidEqual(&GUID_DEVNODE_CHANGE, &filter->dbcc_classguid)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "UMPNPMGR: RegisterDeviceNotification using GUID_DEVNODE_CHANGE is not supported!\n"));

                Status = CR_INVALID_DATA;
                goto Clean0;
            }

            //
            // The GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES interface is
            // not supported directly.  It is for internal use only.  Return
            // CR_INVALID_DATA if this GUID is passed in.
            //
            if (GuidEqual(&GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES,
                          &filter->dbcc_classguid)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
            