
}

void CTaskpadViewDef::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;

    m_AddToViewMenu = VARIANT_FALSE;
    m_bstrViewMenuText = NULL;
    m_bstrViewMenuStatusBarText = NULL;
    m_UseWhenTaskpadViewPreferred = VARIANT_FALSE;
    m_piTaskpad = NULL;
    m_pwszActualDisplayString = NULL;
}

IUnknown *CTaskpadViewDef::Create(IUnknown * punkOuter)
{
    CTaskpadViewDef *pTaskpadViewDef = New CTaskpadViewDef(punkOuter);
    if (NULL == pTaskpadViewDef)
    {
        return NULL;
    }
    else
    {
        return pTaskpadViewDef->PrivateUnknown();
    }
}



HRESULT CTaskpadViewDef::SetActualDisplayString(OLECHAR *pwszString)
{
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    RRETURN(::CoTaskMemAllocString(pwszString,
                                   &m_pwszActualDisplayString));
}



//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CTaskpadViewDef::OnSetHost                  [CSnapInAutomationObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
//

HRESULT CTaskpadViewDef::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piTaskpad));
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpadViewDef::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistSimpleType(&m_AddToViewMenu, VARIANT_FALSE, OLESTR("AddToViewMenu")));

    IfFailRet(PersistBstr(&m_bstrViewMenuText, L"", OLESTR("ViewMenuText")));

    IfFailRet(PersistBstr(&m_bstrViewMenuStatusBarText, L"", OLESTR("ViewMenuStatusBarText")));

    IfFailRet(PersistSimpleType(&m_UseWhenTaskpadViewPreferred, VARIANT_FALSE, OLESTR("UseWhenTaskpadViewPreferred")));

    IfFailRet(PersistObject(&m_piTaskpad, CLSID_Taskpad,
                            OBJECT_TYPE_TASKPAD, IID_ITaskpad,
                            OLESTR("Taskpad")));
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpadViewDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ITaskpadViewDef == riid)
    {
        *ppvObjOut = static_cast<ITaskpadViewDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\urlvdef.h ===
//=--------------------------------------------------------------------------=
// urlvdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CURLViewDef class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _URLVIEWDEF_DEFINED_
#define _URLVIEWDEF_DEFINED_


class CURLViewDef : public CSnapInAutomationObject,
                    public CPersistence,
                    public IURLViewDef
{
    private:
        CURLViewDef(IUnknown *punkOuter);
        ~CURLViewDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IURLViewDef

        BSTR_PROPERTY_RW(CURLViewDef,       Name,  DISPID_URLVIEWDEF_NAME);
        SIMPLE_PROPERTY_RW(CURLViewDef,     Index, long, DISPID_URLVIEWDEF_INDEX);
        BSTR_PROPERTY_RW(CURLViewDef,       Key, DISPID_URLVIEWDEF_KEY);
        VARIANTREF_PROPERTY_RW(CURLViewDef, Tag, DISPID_URLVIEWDEF_TAG);
        SIMPLE_PROPERTY_RW(CURLViewDef,     AddToViewMenu, VARIANT_BOOL, DISPID_URLVIEWDEF_ADD_TO_VIEW_MENU);
        BSTR_PROPERTY_RW(CURLViewDef,       ViewMenuText, DISPID_URLVIEWDEF_VIEW_MENU_TEXT);
        BSTR_PROPERTY_RW(CURLViewDef,       ViewMenuStatusBarText, DISPID_URLVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT);
        BSTR_PROPERTY_RW(CURLViewDef,       URL, DISPID_URLVIEWDEF_URL);
      
    // Public Utility Methods
    public:
        BSTR GetName() { return m_bstrName; }
        BOOL AddToViewMenu() { return VARIANTBOOL_TO_BOOL(m_AddToViewMenu); }
        LPWSTR GetViewMenuText() { return static_cast<LPWSTR>(m_bstrViewMenuText); }
        LPWSTR GetViewMenuStatusBarText() { return static_cast<LPWSTR>(m_bstrViewMenuStatusBarText); }
        HRESULT SetActualDisplayString(OLECHAR *pwszString);
        OLECHAR *GetActualDisplayString() { return m_pwszActualDisplayString; }

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();

        OLECHAR *m_pwszActualDisplayString; // At runtime this will contain the
                                            // actual display string returned
                                            // to MMC for this result view.

        // Property page CLSIDs for ISpecifyPropertyPages
        
        static const GUID *m_rgpPropertyPageCLSIDs[1];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(URLViewDef,           // name
                                &CLSID_URLViewDef,    // clsid
                                "URLViewDef",         // objname
                                "URLViewDef",         // lblname
                                &CURLViewDef::Create, // creation function
                                TLIB_VERSION_MAJOR,   // major version
                                TLIB_VERSION_MINOR,   // minor version
                                &IID_IURLViewDef,     // dispatch IID
                                NULL,                 // event IID
                                HELP_FILENAME,        // help file
                                TRUE);                // thread safe


#endif // _URLVIEWDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\urlvdefs.cpp ===
//=--------------------------------------------------------------------------=
// urlvdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CURLViewDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "urlvdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CURLViewDefs::CURLViewDefs(IUnknown *punkOuter) :
    CSnapInCollection<IURLViewDef, URLViewDef, IURLViewDefs>(
                                             punkOuter,
                                             OBJECT_TYPE_URLVIEWDEFS,
                                             static_cast<IURLViewDefs *>(this),
                                             static_cast<CURLViewDefs *>(this),
                                             CLSID_URLViewDef,
                                             OBJECT_TYPE_URLVIEWDEF,
                                             IID_IURLViewDef,
                                             static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_URLViewDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CURLViewDefs::~CURLViewDefs()
{
}

IUnknown *CURLViewDefs::Create(IUnknown * punkOuter)
{
    CURLViewDefs *pURLViewDefs = New CURLViewDefs(punkOuter);
    if (NULL == pURLViewDefs)
    {
        return NULL;
    }
    else
    {
        return pURLViewDefs->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CURLViewDefs::Persist()
{
    HRESULT      hr = S_OK;
    IURLViewDef *piURLViewDef = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IURLViewDef, URLViewDef, IURLViewDefs>::Persist(piURLViewDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CURLViewDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IURLViewDefs == riid)
    {
        *ppvObjOut = static_cast<IURLViewDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IURLViewDef, URLViewDef, IURLViewDefs>::InternalQueryInterface(riid, ppvObjOut);
}

// CSnapInCollection specialization

HRESULT CSnapInCollection<IURLViewDef, URLViewDef, IURLViewDefs>::GetMaster(IURLViewDefs **ppiMasterURLViewDefs)
{
    H_RRETURN(GetURLViewDefs(ppiMasterURLViewDefs));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\urlvdefs.h ===
//=--------------------------------------------------------------------------=
// urlvdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CURLViewDefs class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _URLVIEWDEFS_DEFINED_
#define _URLVIEWDEFS_DEFINED_

#define MASTER_COLLECTION

#include "collect.h"

class CURLViewDefs : public CSnapInCollection<IURLViewDef, URLViewDef, IURLViewDefs>,
                     public CPersistence
{
    protected:
        CURLViewDefs(IUnknown *punkOuter);
        ~CURLViewDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(URLViewDefs,           // name
                                &CLSID_URLViewDefs,    // clsid
                                "URLViewDefs",         // objname
                                "URLViewDefs",         // lblname
                                &CURLViewDefs::Create, // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IURLViewDefs,     // dispatch IID
                                NULL,                  // no events IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _URLVIEWDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\view.h ===
//=--------------------------------------------------------------------------=
// view.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CView class definition - implements View object
//
//=--------------------------------------------------------------------------=

#ifndef _VIEW_DEFINED_
#define _VIEW_DEFINED_

#include "spanitms.h"
#include "resview.h"
#include "listview.h"
#include "listitem.h"
#include "ctxtmenu.h"
#include "converbs.h"
#include "prpsheet.h"
#include "ctlbar.h"
#include "enumtask.h"
#include "clipbord.h"
#include "ctxtprov.h"
#include "pshtprov.h"

class CScopePaneItems;
class CSnapIn;
class CResultView;
class CMMCListView;
class CMMCListItem;
class CMMCToolbars;
class CMMCButton;
class CMMCButtonMenu;
class CContextMenu;
class CMMCConsoleVerbs;
class CControlbar;
class CEnumTask;
class CMMCContextMenuProvider;
class CMMCPropertySheetProvider;

//=--------------------------------------------------------------------------=
//
// class CView
//
// This is the object created in CSnapIn::CreateComponent to implement
// IComponentData::CreateComponent. It implements IComponent, persistence,
// MMC extension interfaces, and MMC virtual list and sorting interfaces.
//
// It is exposed to the VB programmer as the View object.
//
//=--------------------------------------------------------------------------=

class CView : public CSnapInAutomationObject,
              public IView,
              public IPersistStreamInit,
              public IPersistStream,
              public IComponent,
              public IExtendControlbar,
              public IExtendControlbarRemote,
              public IExtendContextMenu,
              public IExtendPropertySheet2,
              public IExtendPropertySheetRemote,
              public IExtendTaskPad,
              public IResultOwnerData,
              public IResultDataCompare,
              public IResultDataCompareEx
{
    public:
        CView(IUnknown *punkOuter);
        ~CView();
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IView
        BSTR_PROPERTY_RW(      CView,   Name,                                                                       DISPID_VALUE);
        SIMPLE_PROPERTY_RW(    CView,   Index,                 long,                                                DISPID_VIEW_INDEX);
        BSTR_PROPERTY_RW(      CView,   Key,                                                                        DISPID_VIEW_KEY);
        OBJECT_PROPERTY_RO(    CView,   ScopePaneItems,        IScopePaneItems,                                     DISPID_VIEW_SCOPEPANEITEMS);
        BSTR_PROPERTY_RW(      CView,   Caption,                                                                    DISPID_VIEW_CAPTION);
        VARIANTREF_PROPERTY_RW(CView,   Tag,                                                                        DISPID_VIEW_TAG);
        COCLASS_PROPERTY_RO(   CView,   ContextMenuProvider,   MMCContextMenuProvider,   IMMCContextMenuProvider,   DISPID_VIEW_CONTEXT_MENU_PROVIDER);
        COCLASS_PROPERTY_RO(   CView,   PropertySheetProvider, MMCPropertySheetProvider, IMMCPropertySheetProvider, DISPID_VIEW_PROPERTY_SHEET_PROVIDER);

        STDMETHOD(get_MMCMajorVersion)(long *plVersion);
        STDMETHOD(get_MMCMinorVersion)(long *plVersion);

        STDMETHOD(get_ColumnSettings)(BSTR ColumnSetID, ColumnSettings **ppColumnSettings);
        STDMETHOD(get_SortSettings)(BSTR ColumnSetID, SortKeys **ppSortKeys);

        STDMETHOD(SetStatusBarText)(BSTR Text);
        STDMETHOD(SelectScopeItem)(ScopeItem *ScopeItem, VARIANT ViewType, VARIANT DisplayString);
        STDMETHOD(PopupMenu)(MMCMenu *Menu, long Left, long Top);
        STDMETHOD(ExpandInTreeView)(ScopeNode *ScopeNode);
        STDMETHOD(CollapseInTreeView)(ScopeNode *ScopeNode);
        STDMETHOD(NewWindow)(ScopeNode                      *ScopeNode,
                             SnapInNewWindowOptionConstants  Options,
                             VARIANT                         Caption);

    // IComponent
        STDMETHOD(Initialize(IConsole *piConsole);
        STDMETHOD(Notify)(IDataObject * piDataObject,
                          MMC_NOTIFY_TYPE event,
                          long arg, long param);
        STDMETHOD(Destroy)(long cookie));
        STDMETHOD(QueryDataObject)(long cookie,
                                   DATA_OBJECT_TYPES type,
                                   IDataObject **ppiDataObject);
        STDMETHOD(GetResultViewType)(long cookie,
                                     LPOLESTR *ppViewType,
                                     long *pViewOptions);
        STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *piResultDataItem);
        STDMETHOD(CompareObjects)(IDataObject *piDataObjectA,
                                  IDataObject *piDataObjectB);

    // IExtendControlbar
        STDMETHOD(SetControlbar)(IControlbar *piControlbar);
        STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
                                    LPARAM arg, LPARAM param);

    // IExtendControlbarRemote
        STDMETHOD(MenuButtonClick)(IDataObject   *piDataObject,
                                  int             idCommand,
                                  POPUP_MENUDEF **ppPopupMenuDef);
        STDMETHOD(PopupMenuClick)(IDataObject *piDataObject,
                                  UINT         uIDItem,
                                  IUnknown    *punkParam);

    // IExtendContextMenu - public so CSnapIn can forward calls
        STDMETHOD(AddMenuItems)(IDataObject          *piDataObject,
                                IContextMenuCallback *piContextMenuCallback,
                                long                 *plInsertionAllowed);
        STDMETHOD(Command)(long lCommandID, IDataObject *piDataObject);

    // IExtendPropertySheet2
        STDMETHOD(CreatePropertyPages)(IPropertySheetCallback *piPropertySheetCallback,
                                       LONG_PTR handle,
                                       IDataObject *piDataObject);
        STDMETHOD(QueryPagesFor)(IDataObject *piDataObject);
        STDMETHOD(GetWatermarks)(IDataObject *piDataObject,
                                 HBITMAP     *phbmWatermark,
                                 HBITMAP     *phbmHeader,
                                 HPALETTE    *phPalette,
                                 BOOL        *bStretch);

    // IExtendPropertySheetRemote
        STDMETHOD(CreatePropertyPageDefs)(IDataObject         *piDataObject,
                                          WIRE_PROPERTYPAGES **ppPages);

    // IResultOwnerData
        STDMETHOD(FindItem)(RESULTFINDINFO *pFindInfo, int *pnFoundIndex);
        STDMETHOD(CacheHint)(int nStartIndex, int nEndIndex);
        STDMETHOD(SortItems)(int nColumn, DWORD dwSortOptions, LPARAM lUserParam);

    // IResultDataCompare
        STDMETHOD(Compare)(LPARAM      lUserParam,
                           MMC_COOKIE  cookieA,
                           MMC_COOKIE  cookieB,
                           int        *pnResult);

    // IResultDataCompareEx
        STDMETHOD(Compare)(RDCOMPARE *prdc, int *pnResult);

    // IExtendTaskPad
        STDMETHOD(TaskNotify)(IDataObject *piDataObject,
                              VARIANT     *arg,
                              VARIANT     *param);

        STDMETHOD(EnumTasks)(IDataObject  *piDataObject,
                             LPOLESTR      pwszTaskGroup,
                             IEnumTASK   **ppEnumTASK);

        STDMETHOD(GetTitle)(LPOLESTR pwszGroup, LPOLESTR *ppwszTitle);

        STDMETHOD(GetDescriptiveText)(LPOLESTR  pwszGroup,
                                      LPOLESTR *ppwszDescriptiveText);

        STDMETHOD(GetBackground)(LPOLESTR                 pwszGroup,
                                 MMC_TASK_DISPLAY_OBJECT *pTDO);

        STDMETHOD(GetListPadInfo)(LPOLESTR          pwszGroup,
                                  MMC_LISTPAD_INFO *pListPadInfo);


    // IPersistStreamInit and IPersistStream methods
        STDMETHOD(GetClassID)(CLSID *pCLSID);
        STDMETHOD(IsDirty)();
        STDMETHOD(Load)(IStream *piStream);
        STDMETHOD(Save)(IStream *piStream, BOOL fClearDirty);
        STDMETHOD(GetSizeMax)(ULARGE_INTEGER *puliSize);
        STDMETHOD(InitNew)();

    // CSnapInAutomationObject overrides
        HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    public:

    // Non-interface public methods
        void SetSnapIn(CSnapIn *pSnapIn);
        CSnapIn *GetSnapIn() { return m_pSnapIn; }
        IConsole2 *GetIConsole2() { return m_piConsole2; }
        IConsoleVerb *GetIConsoleVerb() { return m_piConsoleVerb; } 
        IResultData *GetIResultData() { return m_piResultData; }
        IHeaderCtrl2 *GetIHeaderCtrl2() { return m_piHeaderCtrl2; }
        IColumnData *GetIColumnData() { return m_piColumnData; }
        CScopePaneItems *GetScopePaneItems() { return m_pScopePaneItems; }
        HRESULT InsertListItem(CMMCListItem *pMMCListItem);

        enum HeaderOptions { RemoveHeaders, DontRemoveHeaders };
        enum ListItemOptions { KeepListItems, DontKeepListItems };

        HRESULT CleanOutConsoleListView(HeaderOptions   HeaderOption,
                                        ListItemOptions ListItemOption);

        HRESULT GetCurrentListViewSelection(IMMCClipboard  **ppiMMCClipboard,
                                            CMMCDataObject **ppMMCDataObject);

        void ListItemUpdate(CMMCListItem *pMMCListItem);
        HRESULT OnDelete(IDataObject *piDataObject);
        CControlbar *GetControlbar() { return m_pControlbar; }

        HRESULT InternalCreatePropertyPages(IPropertySheetCallback  *piPropertySheetCallback,
                                            LONG_PTR                 handle,
                                            IDataObject             *piDataObject,
                                            WIRE_PROPERTYPAGES     **ppPages);
    private:

        void InitMemberVariables();
        void ReleaseConsoleInterfaces();
        HRESULT PopulateListView(CResultView *pResultView);
        HRESULT SetColumnHeaders(IMMCListView *piMMCListView);
        HRESULT InsertListItems(IMMCListView *piMMCListView);
        HRESULT OnInitOCX(IUnknown *punkControl);
        HRESULT OnShow(BOOL fShow, HSCOPEITEM hsi);
        HRESULT ActivateResultView(CScopePaneItem *pSelectedItem,
                                   CResultView    *pResultView);
        HRESULT DeactivateResultView(CScopePaneItem *pSelectedItem,
                                     CResultView    *pResultView);
        HRESULT OnSelect(IDataObject *piDataObject,
                         BOOL fScopeItem, BOOL fSelected);
        HRESULT GetImage(CMMCListItem *pMMCListItem, int *pnImage);
        HRESULT OnButtonClick(IDataObject *piDataObject, MMC_CONSOLE_VERB verb);
        HRESULT OnAddImages(IDataObject *piDataObject, IImageList *piImageList,
                            HSCOPEITEM hsi);
        HRESULT OnColumnClick(long lColumn, long lSortOptions);
        HRESULT OnDoubleClick(IDataObject *piDataObject);
        void OnActivate(BOOL fActivated);
        void OnMinimized(BOOL fMinimized);
        HRESULT OnListpad(IDataObject *piDataObject, BOOL fAttaching);
        HRESULT OnRestoreView(IDataObject       *piDataObject,
                              MMC_RESTORE_VIEW *pMMCRestoreView,
                              BOOL             *pfRestored);
        HRESULT FindMatchingViewDef(MMC_RESTORE_VIEW              *pMMCRestoreView,
                                    CScopePaneItem                *pScopePaneItem,
                                    BSTR                          *pbstrDisplayString,
                                    SnapInResultViewTypeConstants *pType,
                                    BOOL                          *pfFound);
        HRESULT FixupTaskpadDisplayString(SnapInResultViewTypeConstants   TaskpadType,
                                          BOOL                            fUsingListpad3,
                                          OLECHAR                        *pwszRestoreString,
                                          OLECHAR                       **ppwszFixedString);
        HRESULT ParseRestoreInfo(MMC_RESTORE_VIEW              *pMMCRestoreView,
                                 SnapInResultViewTypeConstants *pType);
        HRESULT IsTaskpad(OLECHAR                       *pwszDisplayString, 
                          SnapInResultViewTypeConstants *pType,
                          BOOL                          *pfUsingWrongNames,
                          BOOL                          *pfUsingListpad3);

        
        HRESULT GetScopeItemDisplayString(CScopeItem *pScopeItem, int nCol,
                                          LPOLESTR *ppwszString);
        HRESULT EnumPrimaryTasks(CEnumTask *pEnumTask);
        HRESULT EnumExtensionTasks(IMMCClipboard *piMMCClipboard,
                                   LPOLESTR pwszTaskGroup, CEnumTask *pEnumTask);
        HRESULT OnExtensionTaskNotify(IMMCClipboard *piMMCClipboard,
                                      VARIANT *arg, VARIANT *param);
        HRESULT OnPrimaryTaskNotify(VARIANT *arg, VARIANT *param);
        HRESULT OnRefresh(IDataObject *piDataObject);
        HRESULT OnPrint(IDataObject *piDataObject);
        HRESULT OnRename(IDataObject *piDataObject, OLECHAR *pwszNewName);
        HRESULT OnViewChange(IDataObject *piDataObject, long idxListItem);
        HRESULT OnQueryPaste(IDataObject *piDataObjectTarget,
                             IDataObject *piDataObjectSource);
        HRESULT OnPaste(IDataObject  *piDataObjectTarget,
                        IDataObject  *piDataObjectSource,
                        IDataObject **ppiDataObjectRetToSource);
        HRESULT OnCutOrMove(IDataObject *piDataObjectFromTarget);
        HRESULT CreateMultiSelectDataObject(IDataObject **ppiDataObject);
        void OnDeselectAll();
        HRESULT OnContextHelp(IDataObject *piDataObject);
                
        enum VirtualListItemOptions { FireGetItemData, FireGetItemDisplayInfo };
        
        HRESULT GetVirtualListItem(long lIndex, CMMCListView *pMMCListView,
                                   VirtualListItemOptions Option,
                                   CMMCListItem **ppMMCListItem);
        HRESULT OnColumnsChanged(IDataObject *piDataObject,
                                 MMC_VISIBLE_COLUMNS *pVisibleColumns);
        HRESULT OnFilterButtonClick(long lColIndex, RECT *pRect);
        HRESULT OnFilterChange(MMC_FILTER_CHANGE_CODE ChangeCode, long lColIndex);
        HRESULT OnPropertiesVerb(IDataObject *piDataObject);
        HRESULT GetScopePaneItem(CScopeItem      *pScopeItem,
                                 CScopePaneItem **ppScopePaneItem);
        HRESULT GetCompareObject(RDITEMHDR     *pItemHdr,
                                 CScopeItem   **ppScopeItem,
                                 CMMCListItem **ppMMCListItem,
                                 IDispatch    **ppdispItem);
        HRESULT AddMenu(CMMCMenu *pMMCMenu, HMENU hMenu, CMMCMenus *pMMCMenus);

        CSnapIn          *m_pSnapIn;
        CScopePaneItems  *m_pScopePaneItems;
        IConsole2        *m_piConsole2;
        IResultData      *m_piResultData; 
        IHeaderCtrl2     *m_piHeaderCtrl2;
        IColumnData      *m_piColumnData;
        IImageList       *m_piImageList;
        IConsoleVerb     *m_piConsoleVerb;

        CMMCConsoleVerbs *m_pMMCConsoleVerbs;   // IMMCConsoleVerb implementation

        CContextMenu     *m_pContextMenu;       // implements MMC's
                                                // IExtendContextMenu and
                                                // our IContextMenu

        CControlbar      *m_pControlbar;        // Implements MMC's
                                                // IExtendControlbar and our
                                                // IMMCControlbar

        ITasks           *m_piTasks;            // Tasks collection for
                                                // IExtendTaskpad

        BOOL              m_fVirtualListView;   // TRUE=m_piResultData is
                                                // currently referencing a
                                                // virtual listview.

        BOOL              m_fPopulatingListView;// TRUE=currently populating
                                                // listview

        CMMCListItem     *m_pCachedMMCListItem; // When display info is first
                                                // requested for a virtual list
                                                // item we fire ResultViews_
                                                // GetVirtualItemDisplayInfo once
                                                // and then store that listitem
                                                // until another item is
                                                // requested or until the snap-in
                                                // changes a dislay property on
                                                // the listitem.

        // IMMCContextMenuProvider implementation
        
        CMMCContextMenuProvider *m_pMMCContextMenuProvider;

        // IMMCPropertySheetProvider implementation

        CMMCPropertySheetProvider *m_pMMCPropertySheetProvider;

        // Cached string of CLSID_MessageView
        static OLECHAR m_wszCLSID_MessageView[39];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(View,                   // name
                                &CLSID_View,            // clsid
                                "View",                 // objname
                                "View",                 // lblname
                                &CView::Create,         // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IView,             // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _VIEW_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\view.cpp ===
//=--------------------------------------------------------------------------=
// view.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CView class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "view.h"
#include "spanitms.h"
#include "listview.h"
#include "colhdrs.h"
#include "colhdr.h"
#include "colsets.h"
#include "listitms.h"
#include "listitem.h"
#include "lsubitms.h"
#include "lsubitem.h"
#include "scopitms.h"
#include "scopitem.h"
#include "scitdef.h"
#include "views.h"
#include "ocxvdef.h"
#include "ocxvdefs.h"
#include "urlvdef.h"
#include "urlvdefs.h"
#include "tpdvdef.h"
#include "tpdvdefs.h"
#include "menu.h"
#include "sortkeys.h"

// for ASSERT and FAIL
//
SZTHISFILE

OLECHAR CView::m_wszCLSID_MessageView[39] = { L'\0' };

#pragma warning(disable:4355)  // using 'this' in constructor

CView::CView(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_VIEW,
                            static_cast<IView *>(this),
                            static_cast<CView *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CView::~CView()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrCaption);
    (void)::VariantClear(&m_varTag);
    RELEASE(m_piScopePaneItems);
    RELEASE(m_piContextMenuProvider);
    RELEASE(m_piPropertySheetProvider);
    if (NULL != m_pMMCConsoleVerbs)
    {
        m_pMMCConsoleVerbs->Release();
    }
    if (NULL != m_pContextMenu)
    {
        m_pContextMenu->Release();
    }
    if (NULL != m_pControlbar)
    {
        m_pControlbar->Release();
    }
    if (NULL != m_pCachedMMCListItem)
    {
        m_pCachedMMCListItem->Release();
    }
    RELEASE(m_piTasks);
    InitMemberVariables();
}

void CView::ReleaseConsoleInterfaces()
{
    (void)CleanOutConsoleListView(RemoveHeaders, DontKeepListItems);
    RELEASE(m_piConsole2);
    RELEASE(m_piResultData); 
    RELEASE(m_piHeaderCtrl2);
    RELEASE(m_piColumnData);
    RELEASE(m_piImageList);
    RELEASE(m_piConsoleVerb);
}




void CView::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrCaption = NULL;

    ::VariantInit(&m_varTag);

    m_piScopePaneItems = NULL;
    m_pScopePaneItems = NULL;
    m_piContextMenuProvider = NULL;
    m_pMMCContextMenuProvider = NULL;
    m_piPropertySheetProvider = NULL;
    m_pMMCPropertySheetProvider = NULL;
    m_pSnapIn = NULL;

    m_piConsole2 = NULL;
    m_piResultData = NULL; 
    m_piHeaderCtrl2 = NULL;
    m_piColumnData = NULL;
    m_piImageList = NULL;
    m_piConsoleVerb = NULL;
    m_pMMCConsoleVerbs = NULL;
    m_pContextMenu = NULL;
    m_pControlbar = NULL;
    m_piTasks = NULL;
    m_fVirtualListView = FALSE;
    m_fPopulatingListView = FALSE;
    m_pCachedMMCListItem = NULL;
}




IUnknown *CView::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkScopePaneItems = CScopePaneItems::Create(NULL);
    IUnknown *punkContextMenu = CContextMenu::Create(NULL);
    IUnknown *punkControlbar = CControlbar::Create(NULL);
    IUnknown *punkMMCConsoleVerbs = CMMCConsoleVerbs::Create(NULL);
    IUnknown *punkMMCContextMenuProvider = CMMCContextMenuProvider::Create(NULL);
    IUnknown *punkMMCPropertySheetProvider = CMMCPropertySheetProvider::Create(NULL);
    CView    *pView = New CView(punkOuter);

    if ( (NULL == pView)                        ||
         (NULL == punkScopePaneItems)           ||
         (NULL == punkContextMenu)              ||
         (NULL == punkControlbar)               ||
         (NULL == punkMMCConsoleVerbs)          ||
         (NULL == punkMMCContextMenuProvider)   ||
         (NULL == punkMMCPropertySheetProvider)
       )
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkScopePaneItems->QueryInterface(IID_IScopePaneItems,
                      reinterpret_cast<void **>(&pView->m_piScopePaneItems)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pView->m_piScopePaneItems,
                                                   &pView->m_pScopePaneItems));
    pView->m_pScopePaneItems->SetParentView(pView);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkContextMenu,
                                                   &pView->m_pContextMenu));
    
    pView->m_pContextMenu->SetView(pView);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkControlbar,
                                                   &pView->m_pControlbar));
    pView->m_pControlbar->SetView(pView);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCConsoleVerbs,
                                                   &pView->m_pMMCConsoleVerbs));
    IfFailGo(pView->m_pMMCConsoleVerbs->SetView(pView));

    IfFailGo(punkMMCContextMenuProvider->QueryInterface(
                    IID_IMMCContextMenuProvider,
                    reinterpret_cast<void **>(&pView->m_piContextMenuProvider)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCContextMenuProvider,
                                             &pView->m_pMMCContextMenuProvider));

    IfFailGo(punkMMCPropertySheetProvider->QueryInterface(
                  IID_IMMCPropertySheetProvider,
                  reinterpret_cast<void **>(&pView->m_piPropertySheetProvider)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                            punkMMCPropertySheetProvider,
                                           &pView->m_pMMCPropertySheetProvider));

Error:
    QUICK_RELEASE(punkScopePaneItems);
    QUICK_RELEASE(punkMMCContextMenuProvider);
    QUICK_RELEASE(punkMMCPropertySheetProvider);
    if (FAILEDHR(hr))
    {
        if (NULL != pView)
        {
            delete pView;
        }
        else
        {
            // Managed to create contained objects but not view.
            QUICK_RELEASE(punkScopePaneItems);
            QUICK_RELEASE(punkContextMenu);
            QUICK_RELEASE(punkControlbar);
            QUICK_RELEASE(punkMMCConsoleVerbs);
            QUICK_RELEASE(punkMMCContextMenuProvider);
            QUICK_RELEASE(punkMMCPropertySheetProvider);
        }
        return NULL;
    }
    else
    {
        return pView->PrivateUnknown();
    }
}



void CView::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
    m_pScopePaneItems->SetSnapIn(pSnapIn);
    m_pContextMenu->SetSnapIn(pSnapIn);
    m_pControlbar->SetSnapIn(pSnapIn);
}



HRESULT CView::OnInitOCX(IUnknown *punkControl)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pResultView->SetControl(punkControl));

Error:
    RRETURN(hr);
}



HRESULT CView::OnShow(BOOL fShow, HSCOPEITEM hsi)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    IfFalseGo(hsi == pSelectedItem->GetScopeItem()->GetScopeNode()->GetHSCOPEITEM(), SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    if (fShow)
    {
        switch (pResultView->GetActualType())
        {
            case siListView:
            case siURLView:
            case siOCXView:
            case siMessageView:
                IfFailGo(ActivateResultView(pSelectedItem, pResultView));
                break;
        }
    }
    else
    {
        switch (pResultView->GetActualType())
        {
            case siListView:
            case siURLView:
            case siOCXView:
            case siTaskpad:
            case siListpad:
            case siMessageView:
                IfFailGo(DeactivateResultView(pSelectedItem, pResultView));
                break;
        }
    }

Error:
    RRETURN(hr);
}



HRESULT CView::ActivateResultView
(
    CScopePaneItem *pSelectedItem,
    CResultView    *pResultView
)
{
    HRESULT       hr = S_OK;
    CMMCListView *pListView = NULL;
    
    // ASSERT(!pSelectedItem->Active(), "CView::ActivateResultView() called for an active ScopePaneItem");

    // The result pane is about to be shown. Fire ResultViews_Activate
    // so that the snap-in knows the result view is about to be displayed.

    // First clean out the current contents of the listview (if any)

    if (siListView == pResultView->GetActualType())
    {
        IfFailGo(CleanOutConsoleListView(RemoveHeaders, DontKeepListItems));
    }

    pSelectedItem->SetActive(TRUE);
    pResultView->SetInActivate(TRUE);

    // For virtual list views we need to set up column headers first because the
    // snap-in will set the item count during ResultViews_Activate and MMC
    // does not permit inserting columns after the item count has been set. This
    // means that snap-ins setting up columns programmatically should do so in
    // ResultViews_Initialize.

    if (siListView == pResultView->GetActualType())
    {
        pListView = pResultView->GetListView();
        if (pListView->IsVirtual())
        {
            IfFailGo(SetColumnHeaders(pListView));
        }
    }
    
    m_pSnapIn->GetResultViews()->FireActivate(pResultView);
    pResultView->SetInActivate(FALSE);

    // If the result view type is a listview or a listpad then we need to
    // populate it in the console

    switch (pResultView->GetActualType())
    {
        case siListView:
        case siListpad:
            IfFailGo(PopulateListView(pResultView));
            break;

        case siMessageView:
            IfFailGo(pResultView->GetMessageView()->Populate());
            break;
    }

Error:
    RRETURN(hr);
}



HRESULT CView::DeactivateResultView
(
    CScopePaneItem *pSelectedItem,
    CResultView    *pResultView
)
{
    HRESULT hr = S_OK;
    BOOL    fKeep = FALSE;

    // Under certain circumstances MMCN_SHOW(FALSE) can be sent twice so we
    // need to check whether the ResultView has already been deactivated.

    // Sample scenario for this case:
    // Node displays taskpad.
    // User clicks task that has URL action.
    // HTML page uses MMCCtrl to send task notify on button push. Snap-in
    // reselects node during notify to redisplay taskpad.
    // Taskpad is redisplayed. User hits back button.
    // Snap-in gets MMCN_SHOW(FALSE)
    // HTML page is displayed again.
    // User hits forward button to return to taskpad.
    // Snap-in gets MMCN_SHOW(FALSE) again.

    IfFalseGo(pSelectedItem->Active(), S_OK);

    // The result pane is going away. Give the snap-in a chance to clean up
    // and decide whether to keep the result view in ResultViews_Deactivate 

    pSelectedItem->SetActive(FALSE);

    m_pSnapIn->GetResultViews()->FireDeactivate(pResultView, &fKeep);

    if (!fKeep)
    {
        switch (pResultView->GetActualType())
        {
            case siListView:
            case siListpad:
                IfFailGo(CleanOutConsoleListView(RemoveHeaders, DontKeepListItems));
                break;
        }
        IfFailGo(pSelectedItem->DestroyResultView());
    }
    else
    {
        // Keeping the result view alive. If it is a list view we still
        // need to release the refs we added for presence in the MMC
        // list view but we want to keep the MMCListItems collection alive.

        switch (pResultView->GetActualType())
        {
            case siListView:
            case siListpad:
                IfFailGo(CleanOutConsoleListView(RemoveHeaders, KeepListItems));
                break;
        }
    }

Error:
    RRETURN(hr);
}



HRESULT CView::OnListpad
(
    IDataObject *piDataObject,
    BOOL         fAttaching
)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    IImageList     *piImageList = NULL;
    HSCOPEITEM      hsi = NULL;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    // Check that this is our scope item.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));
    IfFalseGo(CMMCDataObject::ScopeItem == pMMCDataObject->GetType(), SID_E_INTERNAL);

    // It should belong to our currently selected scope pane item.

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);

    hsi = pMMCDataObject->GetScopeItem()->GetScopeNode()->GetHSCOPEITEM();
    IfFalseGo(hsi == pSelectedItem->GetScopeItem()->GetScopeNode()->GetHSCOPEITEM(), SID_E_INTERNAL);

    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    // We've got the scope item. This notification is essentially MMCN_ADD_IMAGES
    // followed by MMCN_SHOW for listpads so let those routines handle it.

    // For images we need to call IConsole2::QueryResultImageList() because it is
    // not passed in as with MMCN_ADD_IMAGES.
    
    if (fAttaching)
    {
        IfFailGo(m_piConsole2->QueryResultImageList(&piImageList));
        IfFailGo(OnAddImages(piDataObject, piImageList, hsi));
        IfFailGo(ActivateResultView(pSelectedItem, pResultView));
    }
    else
    {
        IfFailGo(DeactivateResultView(pSelectedItem, pResultView));
    }

Error:
    QUICK_RELEASE(piImageList);
    RRETURN(hr);
}




HRESULT CView::OnRestoreView
(
    IDataObject      *piDataObject,
    MMC_RESTORE_VIEW *pMMCRestoreView,
    BOOL             *pfRestored
)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    CScopeItem     *pScopeItem = NULL;
    CScopePaneItem *pScopePaneItem = NULL;
    CResultViews   *pResultViews = NULL;
    CResultView    *pResultView = NULL;
    IResultView    *piResultView = NULL;
    long            cResultViews = 0;
    long            i = 0;
    BSTR            bstrResultViewDisplayString = NULL;
    BSTR            bstrDisplayString = NULL;
    BOOL            fFoundViewDef = FALSE;

    SnapInResultViewTypeConstants Type = siUnknown;

    // UNDONE: until MMC 1.2 is fixed if the display string is "" then change
    // it to NULL.

    if (NULL != pMMCRestoreView->pViewType)
    {
        if (L'\0' == pMMCRestoreView->pViewType[0])
        {
            pMMCRestoreView->pViewType = NULL;
        }
    }

    // Reset our virtual list view flag because we are transitioning to a new
    // result view.

    m_fVirtualListView = FALSE;

    // We always restore. If FALSE is returned here, for history navigation MMC
    // will generate a menu command MMCC_STANDARD_VIEW_SELECT which is
    // meaningless for us. For column persistence, (e.g. the user selected a
    // node that has persisted column configuration), if FALSE is returned
    // MMC will call IComponent::GetResultViewType(). While we could handle the
    // GetResultViewType() call, the logic is already here to handle the
    // MMCN_RESTORE_VIEW and we have no way to differentiate between these two
    // different circumstances.
    
    *pfRestored = TRUE;

    // The IDataObject should represent one of our scope items and it should
    // already have a ScopePaneItem as we are restoring a previously displayed
    // result view. If any of these checks fail we still return S_OK because
    // MMC ignores the return.

    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);
    IfFalseGo(SUCCEEDED(hr), S_OK);
    IfFalseGo(CMMCDataObject::ScopeItem == pMMCDataObject->GetType(), S_OK);

    IfFailGo(GetScopePaneItem(pMMCDataObject->GetScopeItem(), &pScopePaneItem));

    // Set the scope item as currently selected as we would in
    // GetResultViewType() and mark it as active.

    m_pScopePaneItems->SetSelectedItem(pScopePaneItem);
    pScopePaneItem->SetActive(TRUE);

    // This result view was already displayed for this scope item at some point.
    // If it was a predefined then we can scan its view definitions for one
    // that has a matching actual display string. If it is a listview then the
    // display string will be NULL and we will find the first defined listview
    // (if any).

    IfFailGo(FindMatchingViewDef(pMMCRestoreView, pScopePaneItem,
                                 &bstrDisplayString, &Type, &fFoundViewDef));

    if (!fFoundViewDef)
    {
        // No predefined view matched. We must assume it was defined in code.
        // We need to determine its type by examining the restored display string.

        IfFailGo(ParseRestoreInfo(pMMCRestoreView, &Type));
        bstrDisplayString = static_cast<BSTR>(pMMCRestoreView->pViewType);
    }

    // At this point we have display string & type. Set them in the ScopePaneItem.

    ASSERT(siUnknown != Type, "OnRestoreView does not have view type as expected");

    IfFailGo(pScopePaneItem->put_DisplayString(bstrDisplayString));
    IfFailGo(pScopePaneItem->put_ResultViewType(Type));

    // The snap-in may have kept the ResultView alive so we need to scan
    // ScopePaneItem.ResultViews for a matching view type and display string.
    // If found and it is code-defined then get its type so we don't make the
    // potential mixup between a URL view and a custom taskpad as they cannot
    // be discerned by examining the display string. If not found then the
    // snap-in must live with that mixup. We document this danger of using
    // code-defined views but it should not be significant because a custom
    // taskpad mistaken for a URL view can still generate TaskNotify events.

    // Check for NULL. That would be the case for a listview defined in VB code.

    if (NULL != bstrDisplayString)
    {
        pResultViews = pScopePaneItem->GetResultViews();
        cResultViews = pResultViews->GetCount();

        for (i = 0; i < cResultViews; i++)
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                                 pResultViews->GetItemByIndex(i),
                                                 &pResultView));
            bstrResultViewDisplayString = pResultView->GetDisplayString();
            if (NULL != bstrResultViewDisplayString)
            {
                if (0 == ::wcscmp(bstrResultViewDisplayString,
                                  bstrDisplayString))
                {
                    pScopePaneItem->SetResultView(pResultView);
                    break;
                }
            }
            pResultView = NULL;
        }
    }

    // If we didn't find a ResultView then create a new one using the
    // ScopePaneItem's last view type and display string settings

    if (NULL == pResultView)
    {
        IfFailGo(pScopePaneItem->CreateNewResultView(
                                                   pMMCRestoreView->lViewOptions,
                                                   &piResultView));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piResultView, &pResultView));
        pScopePaneItem->SetResultView(pResultView);
    }


    if ( (pMMCRestoreView->lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) != 0 )
    {
        m_fVirtualListView = TRUE;
    }

Error:
    if (fFoundViewDef)
    {
        FREESTRING(bstrDisplayString);
    }
    QUICK_RELEASE(piResultView);
    RRETURN(hr);
}





HRESULT CView::FindMatchingViewDef
(
    MMC_RESTORE_VIEW              *pMMCRestoreView,
    CScopePaneItem                *pScopePaneItem,
    BSTR                          *pbstrDisplayString,
    SnapInResultViewTypeConstants *pType,
    BOOL                          *pfFound
)
{
    HRESULT                     hr = S_OK;

    IViewDefs                  *piViewDefs = NULL;
    IScopeItemDef              *piScopeItemDef = NULL; // not AddRef()ed
    
    IListViewDefs              *piListViewDefs = NULL;
    IListViewDef               *piListViewDef = NULL;

    IOCXViewDefs               *piOCXViewDefs = NULL;
    COCXViewDefs               *pOCXViewDefs = NULL;
    COCXViewDef                *pOCXViewDef = NULL;
    CLSID                       clsidOCX = CLSID_NULL;

    IURLViewDefs               *piURLViewDefs = NULL;
    CURLViewDefs               *pURLViewDefs = NULL;
    CURLViewDef                *pURLViewDef = NULL;

    ITaskpadViewDefs           *piTaskpadViewDefs = NULL;
    CTaskpadViewDefs           *pTaskpadViewDefs = NULL;
    CTaskpadViewDef            *pTaskpadViewDef = NULL;

    long                        cViews = 0;
    long                        i = 0;

    OLECHAR                    *pwszActualDisplayString = NULL;
    OLECHAR                    *pwszFixedString = NULL;
    BOOL                        fUsingWrongNames = FALSE;
    BOOL                        fUsingListpad3 = FALSE;

    SnapInResultViewTypeConstants TaskpadType = siUnknown;

    VARIANT varKey;
    ::VariantInit(&varKey);

    // Initialize out parameters

    *pbstrDisplayString = NULL;
    *pType = siUnknown;
    *pfFound = FALSE;

    // Get the appropriate ViewDefs collection

    if (pScopePaneItem->IsStaticNode())
    {
        IfFailGo(m_pSnapIn->GetSnapInDef()->get_ViewDefs(&piViewDefs));
    }
    else
    {
        piScopeItemDef = pScopePaneItem->GetScopeItem()->GetScopeItemDef();
        if (NULL != piScopeItemDef)
        {
            IfFailGo(piScopeItemDef->get_ViewDefs(&piViewDefs));
        }
    }

    // If this is a code defined scope item then it won't have any predefined
    // views.

    IfFalseGo(NULL != piViewDefs, S_OK);

    // If the restored display string is NULL then look for the first listview.
    // If none is found then this is a code-defined listview.

    if (NULL == pMMCRestoreView->pViewType)
    {
        *pType = siListView;
        
        IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
        IfFailGo(piListViewDefs->get_Count(&cViews));
        IfFalseGo(0 != cViews, S_OK);

        // As we cannot discern between defined listviews, we need to take
        // the first one. This is why we do not recommend using multiple
        // listviews for a single scope item.

        varKey.vt = VT_I4;
        varKey.lVal = 1L;
        IfFailGo(piListViewDefs->get_Item(varKey, &piListViewDef));
        IfFailGo(piListViewDef->get_Name(pbstrDisplayString));
        *pType = siPreDefined;
        *pfFound = TRUE;
        goto Error;
    }

    // The restored display string is not NULL. Now just scan all the predefined
    // views for one that matches.

    // NOTE: we do not have to do real get_Item calls when scanning the
    // collections because if the view was previously displayed then the
    // collection has already been synced with its master and contains real
    // items. (See CSnapInCollection::get_Item() in collect.h).

    // Check for an OCX view

    IfFailGo(piViewDefs->get_OCXViews(&piOCXViewDefs));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piOCXViewDefs, &pOCXViewDefs));
    cViews = pOCXViewDefs->GetCount();

    for (i = 0; i < cViews; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                                 pOCXViewDefs->GetItemByIndex(i),
                                                 &pOCXViewDef));
        pwszActualDisplayString = pOCXViewDef->GetActualDisplayString();
        if (NULL != pwszActualDisplayString)
        {
            if (0 == ::wcscmp(pwszActualDisplayString, pMMCRestoreView->pViewType))
            {
                IfFailGo(pOCXViewDef->get_Name(pbstrDisplayString));
                *pType = siPreDefined;
                *pfFound = TRUE;
                goto Error;
            }
        }
    }

    // Check for a URL view

    IfFailGo(piViewDefs->get_URLViews(&piURLViewDefs));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piURLViewDefs, &pURLViewDefs));
    cViews = pURLViewDefs->GetCount();

    for (i = 0; i < cViews; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                                 pURLViewDefs->GetItemByIndex(i),
                                                 &pURLViewDef));
        pwszActualDisplayString = pURLViewDef->GetActualDisplayString();
        if (NULL != pwszActualDisplayString)
        {
            if (0 == ::wcscmp(pwszActualDisplayString, pMMCRestoreView->pViewType))
            {
                IfFailGo(pURLViewDef->get_Name(pbstrDisplayString));
                *pType = siPreDefined;
                *pfFound = TRUE;
                goto Error;
            }
        }
    }

    // Check for a taskpad. Due to an MMC bug there can be circumstances where
    // the restored display string for a taskpad might contain "reload.htm"
    // instead of "default.htm". Listpads also might have "reload2.htm" instead
    // of "listpad.htm". The view def will have stored the original correct
    // display string so if the string is a taskpad/listpad with the alternate
    // names then make a correct copy of it and use that for the comparison.

    // First check whether it is indeed a taskpad or a listpad by parsing the
    // string.

    IfFailGo(IsTaskpad(pMMCRestoreView->pViewType, &TaskpadType,
                       &fUsingWrongNames, &fUsingListpad3));
    IfFalseGo(siUnknown != TaskpadType, S_OK);

    // Now check for the "reload" names and fixup the string.

    if (fUsingWrongNames)
    {
        IfFailGo(FixupTaskpadDisplayString(TaskpadType, fUsingListpad3,
                                           pMMCRestoreView->pViewType,
                                           &pwszFixedString));
    }
    else
    {
        pwszFixedString = pMMCRestoreView->pViewType;
    }

    IfFailGo(piViewDefs->get_TaskpadViews(&piTaskpadViewDefs));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piTaskpadViewDefs, &pTaskpadViewDefs));
    cViews = pTaskpadViewDefs->GetCount();

    for (i = 0; i < cViews; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                             pTaskpadViewDefs->GetItemByIndex(i),
                                             &pTaskpadViewDef));
        pwszActualDisplayString = pTaskpadViewDef->GetActualDisplayString();
        if (NULL != pwszActualDisplayString)
        {
            if (0 == ::wcscmp(pwszActualDisplayString, pwszFixedString))
            {
                IfFailGo(pTaskpadViewDef->get_Name(pbstrDisplayString));
                *pType = siPreDefined;
                *pfFound = TRUE;
                goto Error;
            }
        }
    }

Error:
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    QUICK_RELEASE(piListViewDef);
    QUICK_RELEASE(piOCXViewDefs);
    QUICK_RELEASE(piURLViewDefs);
    QUICK_RELEASE(piTaskpadViewDefs);
    (void)::VariantClear(&varKey);

    if ( (fUsingWrongNames) && (NULL != pwszFixedString) )
    {
        ::CtlFree(pwszFixedString);
    }
    RRETURN(hr);

}

//=--------------------------------------------------------------------------=
// CView::FixupTaskpadDisplayString
//=--------------------------------------------------------------------------=
//
// Parameters:
//  SnapInResultViewTypeConstants TaskpadType [in] siTaskpad or siListpad
//  OLECHAR *pwszRestoreString  [in] display string from MMCN_RESTORE_VIEW
//  OLECHAR **ppwszFixedString  [out] string with reload/reload2 changed
//                                    to default/listpad
//
// Output:
//      HRESULT
//
// Notes:
//
// Examines a restored display string and checks for an MMC bug where default
// taskpads may use "reload.htm" instead of "default.htm". Also checks for
// listpads that may use "reload2.htm" instead of "listpad.htm". If found
// then replaces these names with their correct counterparts.
//
// This function assumes that the restore strings has been parsed and that it
// was found to contain either a default taskpad or listpad using the incorrect
// names.
//
// Caller must free string with CtlFree().
//


HRESULT CView::FixupTaskpadDisplayString
(
    SnapInResultViewTypeConstants   TaskpadType,
    BOOL                            fUsingListpad3,
    OLECHAR                        *pwszRestoreString,
    OLECHAR                       **ppwszFixedString
)
{
    HRESULT  hr = S_OK;
    OLECHAR *pwszFixedString = NULL;
    size_t   cchRestoreString = ::wcslen(pwszRestoreString);
    size_t   cchFixedString = 0;
    OLECHAR *pwszReplace = NULL;
    OLECHAR *pwszOldString = NULL;
    OLECHAR *pwszNewString = NULL;
    size_t   cchOldString = 0;
    size_t   cchNewString = 0;
    size_t   cchStart = 0;

    *ppwszFixedString = 0;

    ASSERT( ((siTaskpad == TaskpadType) || (siListpad == TaskpadType)), "CView::FixupTaskpadDisplayString received bad taskpad type");

    if (siTaskpad == TaskpadType)
    {
        cchFixedString = cchRestoreString - CCH_DEFAULT_TASKPAD2 +
                         CCH_DEFAULT_TASKPAD;

        pwszOldString = DEFAULT_TASKPAD2;
        cchOldString = CCH_DEFAULT_TASKPAD2;

        pwszNewString = DEFAULT_TASKPAD;
        cchNewString = CCH_DEFAULT_TASKPAD;
    }
    else if (!fUsingListpad3)
    {
        cchFixedString = cchRestoreString - CCH_LISTPAD2 + CCH_LISTPAD;

        pwszOldString = LISTPAD2;
        cchOldString = CCH_LISTPAD2;

        pwszNewString = LISTPAD;
        cchNewString = CCH_LISTPAD;
    }
    else
    {
        cchFixedString = cchRestoreString - CCH_LISTPAD3 + CCH_LISTPAD_HORIZ;

        pwszOldString = LISTPAD3;
        cchOldString = CCH_LISTPAD3;

        pwszNewString = LISTPAD_HORIZ;
        cchNewString = CCH_LISTPAD_HORIZ;
    }

    pwszFixedString = (OLECHAR *)::CtlAlloc((cchFixedString + 1) * sizeof(WCHAR));
    if (NULL == pwszFixedString)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    pwszReplace = ::wcsstr(pwszRestoreString, pwszOldString);

    cchStart = pwszReplace - pwszRestoreString;

    ::memcpy(pwszFixedString, pwszRestoreString,
             cchStart * sizeof(WCHAR));

    ::memcpy(pwszFixedString + cchStart,
             pwszNewString,
             cchNewString * sizeof(WCHAR));

    ::wcscpy(pwszFixedString + cchStart + cchNewString,
             pwszRestoreString + cchStart + cchOldString);

    *ppwszFixedString = pwszFixedString;

Error:
    if (FAILED(hr))
    {
        if (NULL != pwszFixedString)
        {
            ::CtlFree(pwszFixedString);
        }
    }
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CView::ParseRestoreInfo
//=--------------------------------------------------------------------------=
//
// Parameters:
//  MMC_RESTORE_VIEW              *pMMCRestoreView [in] from MMC
//  SnapInResultViewTypeConstants *pType           [out] type found
//
// Output:
//      HRESULT
//
// Notes:
//
// Examines a restored display string and determines the result view type.
// A listview has a NULL or empty display string
// An OCX view starts with '{'.
// A message view also starts with '{' but it contains CLSID_MessageView.
// A default taskpad starts with "res://" and ends with "default.htm"
// or "listpad.htm".
// Anything else is assumed to be a URL view. We could mistake a
// custom taskpad for a URL view but it won't really matter as any
// MMCCtrl.TaskNotify calls will still invoke our
// IExtendTaskpad::TaskNotify.
//

HRESULT CView::ParseRestoreInfo
(
    MMC_RESTORE_VIEW              *pMMCRestoreView,
    SnapInResultViewTypeConstants *pType
)
{
    HRESULT hr = S_OK;
    BOOL    fUsingWrongNames = FALSE;
    BOOL    fUsingListpad3 = FALSE;

    *pType = siUnknown;

    if (NULL == pMMCRestoreView->pViewType)
    {
        *pType = siListView;
    }
    else if (L'{' == *pMMCRestoreView->pViewType)
    {
        // Could be an OCX view or a message view. Check the CLSID to see
        // if it is MMC's CLSID_MessageView. If we haven't cached the string
        // yet then do so now.

        if (L'\0' == m_wszCLSID_MessageView[0])
        {
            if (0 == ::StringFromGUID2(CLSID_MessageView, m_wszCLSID_MessageView,
                                       sizeof(m_wszCLSID_MessageView) /
                                       sizeof(m_wszCLSID_MessageView[0])))
            {
                hr = SID_E_INTERNAL;
                EXCEPTION_CHECK_GO(hr);
            }
        }
        if (::wcscmp(m_wszCLSID_MessageView, pMMCRestoreView->pViewType) == 0)
        {
            *pType = siMessageView;
        }
        else
        {
            *pType = siOCXView;
        }
    }
    else 
    {
        IfFailGo(IsTaskpad(pMMCRestoreView->pViewType, pType,
                           &fUsingWrongNames, &fUsingListpad3));
        
        if (siUnknown == *pType) // not a taskpad
        {
            // assume URL view
            *pType = siURLView;
        }
    }

Error:
    RRETURN(hr);
}




HRESULT CView::IsTaskpad
(
    OLECHAR                       *pwszDisplayString, 
    SnapInResultViewTypeConstants *pType,
    BOOL                          *pfUsingWrongNames,
    BOOL                          *pfUsingListpad3
)
{
    HRESULT  hr = S_OK;
    OLECHAR *pwszMMCExePath = m_pSnapIn->GetMMCExePathW();
    size_t   cchMMCExePath = ::wcslen(pwszMMCExePath);
    OLECHAR *pwszTaskpadName = NULL;
    size_t   cchDisplayString = ::wcslen(pwszDisplayString);
    size_t   cchRemaining = 0;

    *pType = siUnknown;
    *pfUsingWrongNames = FALSE;
    *pfUsingListpad3 = FALSE;

    // Check if string starts with "res://"

    IfFalseGo(cchDisplayString > CCH_RESURL, S_OK);

    IfFalseGo( (0 == ::memcmp(pwszDisplayString, RESURL,
                              CCH_RESURL * sizeof(WCHAR))), S_OK);

    // Check res:// is followed by the MMC.EXE path

    IfFalseGo(cchDisplayString > CCH_RESURL + cchMMCExePath, S_OK);

    IfFalseGo( (0 == ::memcmp(&pwszDisplayString[CCH_RESURL], pwszMMCExePath,
                              cchMMCExePath * sizeof(WCHAR))), S_OK);

    // Check if MMC path is followed by "/default.htm" or "/reload.htm" meaning
    // it is a default taskpad

    pwszTaskpadName = &pwszDisplayString[CCH_RESURL + cchMMCExePath];
    cchRemaining = ::wcslen(pwszTaskpadName);

    if (cchRemaining >= CCH_DEFAULT_TASKPAD)
    {
        if ( 0 == ::memcmp(pwszTaskpadName, DEFAULT_TASKPAD,
                           CCH_DEFAULT_TASKPAD * sizeof(WCHAR)))
        {
            *pType = siTaskpad;
        }
    }

    IfFalseGo(siUnknown == *pType, S_OK);

    if  (cchRemaining >= CCH_DEFAULT_TASKPAD2)
    {
        if ( 0 == ::memcmp(pwszTaskpadName, DEFAULT_TASKPAD2,
                           CCH_DEFAULT_TASKPAD2 * sizeof(WCHAR)))
        {
            *pType = siTaskpad;
            *pfUsingWrongNames = TRUE;
        }
    }

    IfFalseGo(siUnknown == *pType, S_OK);

    // It isn't a taskpad so:
    // Check if MMC path is followed by "/listpad.htm" or "/reload2.htm" or "/reload3.htm"
    // meaning it is a listpad

    if (cchRemaining >= CCH_LISTPAD)

    {
        if ( 0 == ::memcmp(pwszTaskpadName, LISTPAD,
                           CCH_LISTPAD * sizeof(WCHAR)))
        {
            *pType = siListpad;
        }
    }

    IfFalseGo(siUnknown == *pType, S_OK);

    if (cchRemaining >= CCH_LISTPAD2)

    {
        if ( 0 == ::memcmp(pwszTaskpadName, LISTPAD2,
                           CCH_LISTPAD2 * sizeof(WCHAR)))
        {
            *pType = siListpad;
            *pfUsingWrongNames = TRUE;
        }
    }

    IfFalseGo(siUnknown == *pType, S_OK);

    if (cchRemaining >= CCH_LISTPAD_HORIZ)

    {
        if ( 0 == ::memcmp(pwszTaskpadName, LISTPAD_HORIZ,
                           CCH_LISTPAD_HORIZ * sizeof(WCHAR)))
        {
            *pType = siListpad;
        }
    }

    IfFalseGo(siUnknown == *pType, S_OK);

    if (cchRemaining >= CCH_LISTPAD3)

    {
        if ( 0 == ::memcmp(pwszTaskpadName, LISTPAD3,
                           CCH_LISTPAD3 * sizeof(WCHAR)))
        {
            *pType = siListpad;
            *pfUsingWrongNames = TRUE;
            *pfUsingListpad3 = TRUE;
        }
    }

Error:
    RRETURN(hr);
}




HRESULT CView::PopulateListView(CResultView *pResultView)
{
    HRESULT                hr = S_OK;
    CMMCListView          *pMMCListView = pResultView->GetListView();
    long                   MMCViewMode = MMCLV_VIEWSTYLE_ICON;
    MMC_RESULT_VIEW_STYLE  StyleToAdd = (MMC_RESULT_VIEW_STYLE)0;
    MMC_RESULT_VIEW_STYLE  StyleToRemove = (MMC_RESULT_VIEW_STYLE)0;
    DWORD                  dwSortOptions = 0;

    // Set flag so that column change events are not fired if we set a filter
    
    m_fPopulatingListView = TRUE;
    
    // Set up the column headers from ResultView.ListView.ColumnHeaders. If this
    // is not a virtual list view. For virtuals it was done prior to the
    // ResultViews_Activate event.

    // For non-virtuals, also add all the listitems currently in
    // ResultView.ListView.ListItems

    if (!pMMCListView->IsVirtual())
    {
        IfFailGo(SetColumnHeaders(pMMCListView));
        IfFailGo(InsertListItems(pMMCListView));
    }

    // Set the view mode. This must be done after setting up the column headers
    // because if using report view there must be column headers.
    // CONSIDER: log an error if there are no headers and in report view

    VBViewModeToMMCViewMode(pMMCListView->GetView(), &MMCViewMode);

    // If MMC < 1.2 and view mode is filtered then switch it to report

    if ( (NULL == m_piColumnData) && (MMCLV_VIEWSTYLE_FILTERED == MMCViewMode) )
    {
        MMCViewMode = MMCLV_VIEWSTYLE_REPORT;
    }

    hr = m_piResultData->SetViewMode(MMCViewMode);
    EXCEPTION_CHECK_GO(hr);

    // Get other view style attributes and set view styles in MMC

    if (pMMCListView->MultiSelect())
    {
        StyleToAdd = (MMC_RESULT_VIEW_STYLE)0;
        StyleToRemove = MMC_SINGLESEL;
    }
    else
    {
        StyleToAdd = MMC_SINGLESEL;
        StyleToRemove = (MMC_RESULT_VIEW_STYLE)0;
    }

    hr = m_piResultData->ModifyViewStyle(StyleToAdd, StyleToRemove);
    EXCEPTION_CHECK_GO(hr);

    if (pMMCListView->HideSelection())
    {
        StyleToAdd = (MMC_RESULT_VIEW_STYLE)0;
        StyleToRemove = MMC_SHOWSELALWAYS;
    }
    else
    {
        StyleToAdd = MMC_SHOWSELALWAYS;
        StyleToRemove = (MMC_RESULT_VIEW_STYLE)0;
    }

    hr = m_piResultData->ModifyViewStyle(StyleToAdd, StyleToRemove);
    EXCEPTION_CHECK_GO(hr);

    if (pMMCListView->SortHeader())
    {
        StyleToAdd = (MMC_RESULT_VIEW_STYLE)0;
        StyleToRemove = MMC_NOSORTHEADER;
    }
    else
    {
        StyleToAdd = MMC_NOSORTHEADER;
        StyleToRemove = (MMC_RESULT_VIEW_STYLE)0;
    }

    hr = m_piResultData->ModifyViewStyle(StyleToAdd, StyleToRemove);
    EXCEPTION_CHECK_GO(hr);

    // If listview is marked as sorted then ask MMC to sort it. Use the internal
    // routine rather than a real GET as that would call into IColumnData.

    if (pMMCListView->Sorted())
    {
        // Set the Sorted property (even though it is already set) as that
        // will call IResultData::Sort() and update it in IColumnData.
        IfFailGo(pMMCListView->put_Sorted(VARIANT_TRUE));
    }

    // If this is a filtered listview then set filter change timeout

    if (siFiltered == pMMCListView->GetView())
    {
        hr = pMMCListView->put_FilterChangeTimeOut(pMMCListView->GetFilterChangeTimeout());
        if (SID_E_MMC_FEATURE_NOT_AVAILABLE == hr)
        {
            hr = S_OK;
        }
        IfFailGo(hr);
    }

Error:
    m_fPopulatingListView = FALSE;
    RRETURN(hr);
}


HRESULT CView::SetColumnHeaders(IMMCListView *piMMCListView)
{
    HRESULT            hr = S_OK;
    IMMCColumnHeaders *piMMCColumnHeaders = NULL;
    CMMCColumnHeaders *pMMCColumnHeaders = NULL;
    CMMCColumnHeader  *pMMCColumnHeader = NULL;
    short              sWidth = 0;
    int                nFormat = 0;
    long               cHeaders = 0;
    long               i = 0;

    // Reset MMC's header control

    IfFailGo(m_piConsole2->SetHeader(m_piHeaderCtrl2));

    // Set up the headers

    IfFailGo(piMMCListView->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&piMMCColumnHeaders)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCColumnHeaders,
                                                   &pMMCColumnHeaders));
    cHeaders = pMMCColumnHeaders->GetCount();
    IfFalseGo(cHeaders > 0, S_OK);

    for (i = 0; i < cHeaders; i++)
    {
        // Don't do a real GET on any of the properties as they will use
        // IHeaderCtrl2 and IColumnData at runtime. Using these backdoor functions
        // also improves perf.

        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                            pMMCColumnHeaders->GetItemByIndex(i),
                                            &pMMCColumnHeader));

        switch (pMMCColumnHeader->GetAlignment())
        {
            case siColumnLeft:
                nFormat = LVCFMT_LEFT;
                break;

            case siColumnRight:
                nFormat = LVCFMT_RIGHT;
                break;

            case siColumnCenter:
                nFormat = LVCFMT_CENTER;
                break;

            default:
                nFormat = LVCFMT_LEFT;
                break;
        }

        sWidth = pMMCColumnHeader->GetWidth();
        if (siColumnAutoWidth == sWidth)
        {
            sWidth = MMCLV_AUTO;
        }

        // If the column is hidden then check that we are on MMC >= 1.2.
        // If not then ignore the hidden setting.
        if ( (pMMCColumnHeader->Hidden()) && (NULL != m_piColumnData) )
        {
            sWidth = static_cast<short>(HIDE_COLUMN);
        }

        hr = m_piHeaderCtrl2->InsertColumn(static_cast<int>(i),
                                           (LPCWSTR)pMMCColumnHeader->GetText(),
                                           nFormat,
                                           static_cast<int>(sWidth));
        EXCEPTION_CHECK_GO(hr);

        // If the column has a filter then set it. If this is MMC < 1.2 then
        // ignore filter properties.

        hr = pMMCColumnHeader->SetFilter();
        if (SID_E_MMC_FEATURE_NOT_AVAILABLE == hr) // MMC < 1.2
        {
            hr = S_OK;
        }
        IfFailGo(hr);
    }

Error:
    QUICK_RELEASE(piMMCColumnHeaders);
    RRETURN(hr);
}





HRESULT CView::InsertListItems(IMMCListView *piMMCListView)
{
    HRESULT           hr = S_OK;
    IMMCListItems    *piMMCListItems = NULL;
    CMMCListItems    *pMMCListItems = NULL;
    CMMCListItem     *pMMCListItem = NULL;
    long              cListItems = 0;
    long              i = 0;

    IfFailGo(piMMCListView->get_ListItems(reinterpret_cast<MMCListItems **>(&piMMCListItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItems, &pMMCListItems));
    cListItems = pMMCListItems->GetCount();

    for (i = 0; i < cListItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                               pMMCListItems->GetItemByIndex(i), &pMMCListItem));
        IfFailGo(InsertListItem(pMMCListItem));
    }

Error:
    QUICK_RELEASE(piMMCListItems);
    RRETURN(hr);
}


HRESULT CView::InsertListItem(CMMCListItem *pMMCListItem)
{
    HRESULT        hr = S_OK;
    CMMCListItems *pMMCListItems = pMMCListItem->GetListItems();
    CMMCListView  *pMMCListView = NULL;
    CResultView   *pResultView = NULL;

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    // Check whether the owning ResultView is in its Initialize event. If
    // so then don't add to MMC just yet. The listitems will be added to MMC
    // during MMCN_SHOW.

    IfFalseGo(NULL != pMMCListItems, S_OK);
    pMMCListView = pMMCListItems->GetListView();
    IfFalseGo(NULL != pMMCListView, S_OK);
    pResultView = pMMCListView->GetResultView();
    IfFalseGo(NULL != pResultView, S_OK);
    IfFalseGo(!pResultView->InInitialize(), S_OK);

    rdi.mask = RDI_STR | RDI_PARAM | RDI_INDEX;
    rdi.str = MMC_CALLBACK;
    rdi.lParam = reinterpret_cast<LPARAM>(pMMCListItem);
    rdi.nIndex = static_cast<int>(pMMCListItem->GetIndex() - 1L);

    hr = m_piResultData->InsertItem(&rdi);
    EXCEPTION_CHECK_GO(hr);

    pMMCListItem->SetHRESULTITEM(rdi.itemID);

    // Add a reference while the listitem is in the MMC listview.
    
    pMMCListItem->AddRef();

Error:
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
// CView::CleanOutConsoleListView
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// This function is called when the result pane is being destroyed. If the
// result pane contains a listview and it is not virtual then we have a bunch
// of AddRef()ed IMMCListItem pointers sitting in IResultData. We need to
// iterate through these and release them.
//
HRESULT CView::CleanOutConsoleListView
(
    HeaderOptions   HeaderOption,
    ListItemOptions ListItemOption
)
{
    HRESULT        hr = S_OK;
    CMMCListItem  *pMMCListItem = NULL; 

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    if (RemoveHeaders == HeaderOption)
    {
        if (NULL != m_piConsole2)
        {
            (void)m_piConsole2->SetHeader(NULL);
        }
    }

    // If there is a cached list item from a virtual result view then
    // get rid of it.
    if (NULL != m_pCachedMMCListItem)
    {
        m_pCachedMMCListItem->Release();
        m_pCachedMMCListItem = NULL;
    }

    IfFalseGo(NULL != m_piResultData, S_OK);
    IfFalseGo(!m_fVirtualListView, S_OK);

    // Even though we don't need RDI_STATE MMC requires it on GetNextItem.
    
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;

    hr = m_piResultData->GetNextItem(&rdi);
    EXCEPTION_CHECK_GO(hr);

    while (-1 != rdi.nIndex)
    {
        if (!rdi.bScopeItem)
        {
            pMMCListItem = reinterpret_cast<CMMCListItem *>(rdi.lParam);

            // Release the ref we held on the list item for its presence in MMC

            pMMCListItem->Release();
        }

        hr = m_piResultData->GetNextItem(&rdi);
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}



HRESULT CView::OnSelect
(
    IDataObject *piDataObject,
    BOOL         fScopeItem,
    BOOL         fSelected
)
{
    HRESULT        hr = S_OK;
    IMMCClipboard *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));
    // Fire Views_Select

    m_pSnapIn->GetViews()->FireSelect(
                           static_cast<IView *>(this),
                           piMMCClipboard,
                           BOOL_TO_VARIANTBOOL(fSelected),
                           static_cast<IMMCConsoleVerbs *>(m_pMMCConsoleVerbs));

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}





HRESULT CView::GetImage(CMMCListItem *pMMCListItem, int *pnImage)
{
    HRESULT       hr = S_OK;
    IMMCListView *piMMCListView = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFailGo(pMMCListItem->get_Icon(&varIndex));
    IfFalseGo(VT_EMPTY != varIndex.vt, S_OK);

    // The user specified an index in ListItem.Icon. Attempt to fetch that
    // image from the listview's image list and get its numerical index

    IfFailGo(m_pScopePaneItems->GetSelectedItem()->
             GetResultView()->get_ListView(reinterpret_cast<MMCListView **>(&piMMCListView)));

    IfFailGo(::GetImageIndex(piMMCListView, varIndex, pnImage));

Error:
    QUICK_RELEASE(piMMCListView);
    RRETURN(hr);
}





HRESULT CView::OnAddImages
(
    IDataObject *piDataObject,
    IImageList  *piImageList,
    HSCOPEITEM   hsi
)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    IMMCListView   *piMMCListView = NULL;
    IMMCImageList  *piMMCImageList = NULL;
    IMMCImageList  *piMMCImageListSmall = NULL;
    IMMCImages     *piMMCImages = NULL;
    IMMCImages     *piMMCImagesSmall = NULL;
    long            lCount = 0;
    long            lCountSmall = 0;
    HBITMAP         hBitmap = NULL;
    HBITMAP         hBitmapSmall = NULL;
    OLE_COLOR       OleColorMask = 0;
    COLORREF        ColorRef = RGB(0x00,0x00,0x00);
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection. It will always be a single item: a scope item owned
    // by the snap-in or a foreign scope item if this is a namespace extension.

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    if ( (siSingleScopeItem != SelectionType) &&
         (siSingleForeign != SelectionType) )
    {
        ASSERT(FALSE, "MMCN_ADDIMAGES receive data object that is not for a single scope item or a foreign data object");
        hr = SID_E_INTERNAL;
    }
    IfFailGo(hr);

    // Get large and small image lists. Make sure they are both present.
    // For an owned scope item these come from ResultView.ListView.LargeIcons
    // and ResultView.ListView.Icons. For a foreign scope item they come from
    // SnapIn.LargeFolders and SnapIn.SmallFolders.

    if (siSingleScopeItem == SelectionType)
    {
        IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
        pResultView = pSelectedItem->GetResultView();
        IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

        IfFailGo(pResultView->get_ListView(reinterpret_cast<MMCListView **>(&piMMCListView)));

        IfFailGo(piMMCListView->get_Icons(reinterpret_cast<MMCImageList **>(&piMMCImageList)));
        IfFalseGo(NULL != piMMCImageList, S_OK);

        IfFailGo(piMMCListView->get_SmallIcons(reinterpret_cast<MMCImageList **>(&piMMCImageListSmall)));
        IfFalseGo(NULL != piMMCImageListSmall, S_OK);
    }
    else // namespace extension's node appearing in its parent's listview
    {
        IfFalseGo(NULL != m_pSnapIn, SID_E_INTERNAL);

        IfFailGo(m_pSnapIn->get_LargeFolders(reinterpret_cast<MMCImageList **>(&piMMCImageList)));
        IfFalseGo(NULL != piMMCImageList, S_OK);

        IfFailGo(m_pSnapIn->get_SmallFolders(reinterpret_cast<MMCImageList **>(&piMMCImageListSmall)));
        IfFalseGo(NULL != piMMCImageListSmall, S_OK);
    }

    IfFailGo(piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(piMMCImageListSmall->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImagesSmall)));

    // Make sure they both have the same number of images

    IfFailGo(piMMCImages->get_Count(&lCount));
    IfFalseGo(0 != lCount, S_OK);

    IfFailGo(piMMCImagesSmall->get_Count(&lCountSmall));
    // UNDONE: log an error here if counts not equal
    IfFalseGo(lCountSmall == lCount, S_OK);

    // Get the mask color as a COLORREF

    IfFailGo(piMMCImageList->get_MaskColor(&OleColorMask));
    IfFailGo(::OleTranslateColor(OleColorMask, NULL, &ColorRef));

    // Now get each pair of small and large images and add them to the result
    // view's image list

    varIndex.vt = VT_I4;

    for (varIndex.lVal = 1L; varIndex.lVal <= lCount; varIndex.lVal++)
    {
        IfFailGo(GetPicture(piMMCImages, varIndex, PICTYPE_BITMAP,
                            reinterpret_cast<OLE_HANDLE *>(&hBitmap)));

        IfFailGo(GetPicture(piMMCImagesSmall, varIndex, PICTYPE_BITMAP,
                            reinterpret_cast<OLE_HANDLE *>(&hBitmapSmall)));

        IfFailGo(piImageList->ImageListSetStrip(reinterpret_cast<long*>(hBitmapSmall),
                                                reinterpret_cast<long*>(hBitmap),
                                                varIndex.lVal,
                                                ColorRef));
    }

Error:
    QUICK_RELEASE(piMMCListView);
    QUICK_RELEASE(piMMCImageList);
    QUICK_RELEASE(piMMCImageListSmall);
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piMMCImagesSmall);
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


HRESULT CView::OnButtonClick(IDataObject *piDataObject, MMC_CONSOLE_VERB verb)
{
    HRESULT hr = S_OK;

    switch (verb)
    {
        case MMC_VERB_OPEN:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_OPEN");
            break;
            
        case MMC_VERB_COPY:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_COPY");
            break;
            
        case MMC_VERB_PASTE:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_PASTE");
            break;

        case MMC_VERB_DELETE:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_DELETE");
            break;

        case MMC_VERB_PROPERTIES:
            hr = OnPropertiesVerb(piDataObject);
            break;

        case MMC_VERB_RENAME:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_RENAME");
            break;
            
        case MMC_VERB_REFRESH:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_REFRESH");
            break;

        case MMC_VERB_PRINT:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_PRINT");
            break;

        case MMC_VERB_CUT:
            ASSERT(FALSE, "IComponent::Notify(MMCN_BTN_CLICK, MMC_VERB_CUT");
            break;

        default:
            break;
    }
    RRETURN(hr);
}



HRESULT CView::OnColumnClick(long lColumn, long lSortOptions)
{
    HRESULT hr = S_OK;

    SnapInSortOrderConstants  siSortOption = siAscending;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    if (RSI_DESCENDING == lSortOptions)
    {
        siSortOption = siDescending;
    }

    // Fire the event and adjut the column number to one based
    
    m_pSnapIn->GetResultViews()->FireColumnClick(
                                         static_cast<IResultView *>(pResultView),
                                         lColumn + 1L,
                                         siSortOption);
Error:
    RRETURN(hr);
}




HRESULT CView::OnDoubleClick(IDataObject *piDataObject)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = NULL;
    BOOL            fDoDefault = TRUE;

    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);

    // If this is not our data object then ignore it and tell MMC to do default
    // action. (Should never happen).

    ASSERT(SUCCEEDED(hr), "CView::OnDoubleClick received foreign data object");

    IfFalseGo(SUCCEEDED(hr), S_FALSE);

    // There may or may not be a selected item and an existing result view.
    // In a primary snap-in there will not be a result view when double clicking
    // the static node in the result pane when the console root is selected.

    if (NULL != pSelectedItem)
    {
        pResultView = pSelectedItem->GetResultView();
    }

    if (CMMCDataObject::ListItem == pMMCDataObject->GetType())
    {
        m_pSnapIn->GetResultViews()->FireListItemDblClick(pResultView,
                                                          pMMCDataObject->GetListItem(),
                                                          &fDoDefault);
    }
    else if (CMMCDataObject::ScopeItem == pMMCDataObject->GetType())
    {
        m_pSnapIn->GetResultViews()->FireScopeItemDblClick(pResultView,
                                                           pMMCDataObject->GetScopeItem(),
                                                           &fDoDefault);
    }

    if (fDoDefault)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Error:
    RRETURN(hr);
}


void CView::OnActivate(BOOL fActivated)
{
    if (fActivated)
    {
        m_pSnapIn->GetViews()->FireActivate(static_cast<IView *>(this));
        m_pSnapIn->SetCurrentView(this);
        m_pSnapIn->GetViews()->SetCurrentView(this);
        m_pSnapIn->SetCurrentControlbar(m_pControlbar);
    }
    else
    {
        m_pSnapIn->GetViews()->FireDeactivate(static_cast<IView *>(this));
    }
}



void CView::OnMinimized(BOOL fMinimized)
{
    if (fMinimized)
    {
        m_pSnapIn->GetViews()->FireMinimize(static_cast<IView *>(this));
    }
    else
    {
        m_pSnapIn->GetViews()->FireMaximize(static_cast<IView *>(this));
    }
}



HRESULT CView::EnumExtensionTasks
(
    IMMCClipboard *piMMCClipboard,
    LPOLESTR       pwszTaskGroup,
    CEnumTask     *pEnumTask
)
{
    HRESULT          hr = S_OK;
    BSTR             bstrGroupName = NULL;
    IMMCDataObjects *piMMCDataObjects = NULL;
    IMMCDataObject  *piMMCDataObject = NULL;
    IUnknown        *punkTasks = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // This might be the first time we find out that the snap-in is running as
    // an extension so set the runtime mode.

    m_pSnapIn->SetRuntimeMode(siRTExtension);

    // If we haven't yet created the Tasks collection then create it now.
    // Otherwise just clear it out.

    if (NULL == m_piTasks)
    {
        punkTasks = CTasks::Create(NULL);
        if (NULL == punkTasks)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(punkTasks->QueryInterface(IID_ITasks,
                                           reinterpret_cast<void **>(&m_piTasks)));
    }
    else
    {
        IfFailGo(m_piTasks->Clear());
    }

    // If there is a group name then convert to a BSTR to pass to the snap-in

    if (NULL != pwszTaskGroup)
    {
        bstrGroupName = ::SysAllocString(pwszTaskGroup);
        if (NULL == bstrGroupName)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Get the 1st data object from the selection

    IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;
    IfFailGo(piMMCDataObjects->get_Item(varIndex, reinterpret_cast<MMCDataObject **>(&piMMCDataObject)));

    // Fire ExtensionSnapIn_AddTasks so the snap-in can add its tasks

    m_pSnapIn->GetExtensionSnapIn()->FireAddTasks(piMMCDataObject,
                                                  bstrGroupName, m_piTasks);

    // Give the enumerator its tasks collection

    pEnumTask->SetTasks(m_piTasks);

Error:
    FREESTRING(bstrGroupName);
    QUICK_RELEASE(piMMCDataObjects);
    QUICK_RELEASE(piMMCDataObject);
    QUICK_RELEASE(punkTasks);
    RRETURN(hr);
}



HRESULT CView::EnumPrimaryTasks(CEnumTask *pEnumTask)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    ITaskpad       *piTaskpad = NULL;
    ITasks         *piTasks = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    if (NULL == pResultView) // should always be valid, but double check
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    // Taskpads do not receive MMCN_SHOW so fire ResultViews_Activate here
    // to allow the snap-in to make any needed changes to ResultViews.Taskpad.
    // Note that the result view type could be siTaskpad or siListpad as listpads
    // are also allowed to display task buttons. We only fire the event for
    // siTaskpad as listpads will get it during MMCN_LISTPAD
    // (see CView::OnListpad()).

    if (siTaskpad == pResultView->GetActualType())
    {
        IfFailGo(ActivateResultView(pSelectedItem, pResultView));
    }

    // Give the enumerator its tasks collection

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks)));

    pEnumTask->SetTasks(piTasks);

Error:
    QUICK_RELEASE(piTaskpad);
    QUICK_RELEASE(piTasks);
    RRETURN(hr);
}




HRESULT CView::OnExtensionTaskNotify
(
    IMMCClipboard *piMMCClipboard,
    VARIANT       *arg,
    VARIANT       *param
)
{
    HRESULT          hr = S_OK;
    IMMCDataObjects *piMMCDataObjects = NULL;
    IMMCDataObject  *piMMCDataObject = NULL;
    ITask           *piTask = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // If a task was clicked then arg is a VT_I4 containing the one-based
    // index of the Task object in m_piTasks. Fire ExtensionSnapIn_TaskClick.

    if (VT_I4 != arg->vt)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;
    IfFailGo(piMMCDataObjects->get_Item(varIndex, reinterpret_cast<MMCDataObject **>(&piMMCDataObject)));

    IfFailGo(m_piTasks->get_Item(*arg, reinterpret_cast<Task **>(&piTask)));
    m_pSnapIn->GetExtensionSnapIn()->FireTaskClick(piMMCDataObject, piTask);

Error:
    QUICK_RELEASE(piMMCDataObjects);
    QUICK_RELEASE(piMMCDataObject);
    QUICK_RELEASE(piTask);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CView::OnPrimaryTaskNotify
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT *arg    [in] Passed from taskpad calling MMCCtrl.TaskNotify.
//                       For MMC taskpad templates this will be the task or
//                       listpad button ID. For custom taskpads this will be
//                       a value defined by the taskpad developer.
//
//  VARIANT *param  [in] passed from taskpad calling MMCCtrl.TaskNotify
//
// Output:
//      HRESULT
//
// Notes:
//
// This function is called in a primary snap-in when a user clicks either a task
// or a listpad button in an MMC-defined taskpad as well is when a custom taskpad
// calls MMCCtrl.TaskNotify.
//
// There is no foolproof method of determining the source of the notification.
// One opportunity for confusion is the case where a task on a default taskpad
// has a URL action that navigates to a custom taskpad. When the user hits the
// task MMC tells the web browser control to navigate to the URL without
// informing the snap-in. If the custom taskpad calls MMCCtrl.TaskNotify then
// this method will be called because the same scope node is still selected.
// Unfortunately, the runtime still thinks that the default taskpad is the active
// result view because MMC hasn't told us otherwise. 
//
// The bottom line is that the runtime needs to distinguish arg parameter values
// between task/listpad button IDs and user defined values sent from a custom
// taskpad. The only way is to reserve a set of values and our documentation
// states that users should not call MMCCtrl.TaskNotify with an arg param between
// 0 and the number of tasks defined for a taskpad used by the same scope node.
// The runtime identifies a listpad button with an ID of zero and tasks with IDs
// corresponding to their Tasks collection index (1 to n).
//
// Users can work around this by using other numbers or non-integer data types.
//

HRESULT CView::OnPrimaryTaskNotify
(
    VARIANT       *arg,
    VARIANT       *param
)
{
    HRESULT                     hr = S_OK;
    CScopePaneItem             *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView                *pResultView = NULL;
    ITaskpad                   *piTaskpad = NULL;
    ITasks                     *piTasks = NULL;
    ITask                      *piTask = NULL;
    long                        cTasks = 0;             
    SnapInTaskpadTypeConstants  TaskpadType = Default;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    // Get the taskpad and determine its type.

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_Type(&TaskpadType));

    // If it is a custom taskpad then just fire ResultViews_Notify. If we
    // displayed the custom taskpad through normal procedures then that will be
    // the current result view type. If not, (given the scenario described in
    // the header notes above), and arg is not a VT_I4, then it must be from a
    // a custom taskpad.

    if ( (Custom == TaskpadType) || (VT_I4 != arg->vt) )
    {
        m_pSnapIn->GetResultViews()->FireTaskNotify(
                          static_cast<IResultView *>(pResultView), *arg, *param);
        goto Cleanup;
    }

    // Now we can't be sure of the taskpad type so we need to interpret the
    // arg parameter.

    // It is potentially a default taskpad task/listpad button click.
    // Check if the value is between zero and Taskpad.Tasks.Count

    IfFailGo(piTaskpad->get_Tasks(reinterpret_cast<Tasks **>(&piTasks)));
    IfFailGo(piTasks->get_Count(&cTasks));

    if (0 == arg->lVal)
    {
        // Assume it is a listpad button click and fire
        // ResultViews_ListpadButtonClick

        m_pSnapIn->GetResultViews()->FireListpadButtonClick(
                                        static_cast<IResultView *>(pResultView));
    }
    else if ( (arg->lVal >= 1L) && (arg->lVal <= cTasks) )
    {
        // Assume it is a task and fire ResultViews_TaskClick using the value
        // as the index of the Task clicked in ResultView.Taskpad.Tasks
        
        IfFailGo(piTasks->get_Item(*arg, reinterpret_cast<Task **>(&piTask)));
        m_pSnapIn->GetResultViews()->FireTaskClick(
                                static_cast<IResultView *>(pResultView), piTask);
    }
    else
    {
        // Assume it is from a custom taskpad and fire ResultViews_TaskNotify

        m_pSnapIn->GetResultViews()->FireTaskNotify(
                          static_cast<IResultView *>(pResultView), *arg, *param);
    }

Cleanup:
Error:
    QUICK_RELEASE(piTaskpad);
    QUICK_RELEASE(piTasks);
    QUICK_RELEASE(piTask);
    RRETURN(hr);
}


HRESULT CView::OnPrint(IDataObject *piDataObject)
{
    HRESULT        hr = S_OK;
    IMMCClipboard *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // Fire Views_Print

    m_pSnapIn->GetViews()->FirePrint(this, piMMCClipboard);

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




HRESULT CView::OnRefresh(IDataObject *piDataObject)
{
    HRESULT        hr = S_OK;
    IMMCClipboard *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // Fire Views_Refresh
    
    m_pSnapIn->GetViews()->FireRefresh(this, piMMCClipboard);

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




HRESULT CView::OnRename(IDataObject *piDataObject, OLECHAR *pwszNewName)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = NULL;
    BSTR            bstrNewName = NULL;
    IMMCListItem   *piMMCListItem = NULL; // NotAddRef()ed
    CScopeItem     *pScopeItem = NULL;

    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);

    // If this is not our data object then ignore it
    IfFalseGo(SUCCEEDED(hr), S_OK);

    if (NULL != pSelectedItem)
    {
        pResultView = pSelectedItem->GetResultView();
    }

    bstrNewName = ::SysAllocString(pwszNewName);
    if (NULL == bstrNewName)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (CMMCDataObject::ListItem == pMMCDataObject->GetType())
    {
        piMMCListItem = static_cast<IMMCListItem *>(pMMCDataObject->GetListItem());
        m_pSnapIn->GetResultViews()->FireItemRename(pResultView, piMMCListItem,
                                                    bstrNewName);
    }
    else if (CMMCDataObject::ScopeItem == pMMCDataObject->GetType())
    {
        pScopeItem = pMMCDataObject->GetScopeItem();
        m_pSnapIn->GetScopeItems()->FireRename(
                                           static_cast<IScopeItem *>(pScopeItem),
                                           bstrNewName);
    }

Error:
    FREESTRING(bstrNewName);
    RRETURN(hr);
}


HRESULT CView::OnViewChange(IDataObject *piDataObject, long idxListItem)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = NULL;
    CMMCListItem   *pMMCListItem = NULL;

    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);

    // If this is not our data object then ignore it (should never happen)
    IfFalseGo(SUCCEEDED(hr), S_OK);

    if (NULL != pSelectedItem)
    {
        pResultView = pSelectedItem->GetResultView();
    }


    if (CMMCDataObject::ListItem == pMMCDataObject->GetType())
    {
        pMMCListItem = pMMCDataObject->GetListItem();
        m_pSnapIn->GetResultViews()->FireItemViewChange(pResultView,
                                       static_cast<IMMCListItem *>(pMMCListItem),
                                       pMMCListItem->GetHint());
    }

Error:
    RRETURN(hr);
}




HRESULT CView::OnQueryPaste
(
    IDataObject *piDataObjectTarget,
    IDataObject *piDataObjectSource
)
{
    HRESULT         hr = S_FALSE;
    CMMCDataObject *pMMCDataObject  = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;
    VARIANT_BOOL    fvarOKToPaste = VARIANT_FALSE;
    BOOL            fNotFromThisSnapIn = FALSE;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create an MMCClipboard object holding the source items

    IfFailGo(CreateSelection(piDataObjectSource, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // The target should be one of our data objects representing a single scope
    // item. If not then ignore it.
    
    ::IdentifyDataObject(piDataObjectTarget, m_pSnapIn,
                         &pMMCDataObject, &fNotFromThisSnapIn);

    IfFalseGo(!fNotFromThisSnapIn, S_FALSE);
    IfFalseGo(CMMCDataObject::ScopeItem == pMMCDataObject->GetType(),
              S_FALSE);

    // Fire Views_Select

    m_pSnapIn->GetViews()->FireQueryPaste(
                       static_cast<IView *>(this),
                       piMMCClipboard,
                       static_cast<IScopeItem *>(pMMCDataObject->GetScopeItem()),
                       &fvarOKToPaste);

    if (VARIANT_TRUE == fvarOKToPaste)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




HRESULT CView::OnPaste
(
    IDataObject  *piDataObjectTarget,
    IDataObject  *piDataObjectSource,
    IDataObject **ppiDataObjectRetToSource
)
{
    HRESULT         hr = S_FALSE;
    CMMCDataObject *pMMCDataObjectTarget  = NULL;
    CMMCDataObject *pMMCDataObjectRetToSource  = NULL;
    IUnknown       *punkDataObjectRetToSource = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;
    VARIANT_BOOL    fvarMove = VARIANT_FALSE;
    BOOL            fNotFromThisSnapIn = FALSE;

    SnapInSelectionTypeConstants SourceType = siEmpty;

    // Create an MMCClipboard object holding the source items

    IfFailGo(::CreateSelection(piDataObjectSource, &piMMCClipboard, m_pSnapIn,
                               &SourceType));

    // The target should be one of our data objects representing a single scope
    // item. If not then ignore it.

    ::IdentifyDataObject(piDataObjectTarget, m_pSnapIn,
                         &pMMCDataObjectTarget, &fNotFromThisSnapIn);

    IfFalseGo(!fNotFromThisSnapIn, SID_E_INTERNAL);
    IfFalseGo(CMMCDataObject::ScopeItem == pMMCDataObjectTarget->GetType(),
              SID_E_INTERNAL);

    // If this is a move then MMC requested a returned data object.

    if (NULL != ppiDataObjectRetToSource)
    {
        fvarMove = VARIANT_TRUE;

        // If the source is not from this snap-in then create an MMCDataObject
        // in which the snap-in may return information on the items successfully
        // pasted. The format is determined by the source snap-in.

        if (IsForeign(SourceType))
        {
            punkDataObjectRetToSource = CMMCDataObject::Create(NULL);
            if (NULL == punkDataObjectRetToSource)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
            IfFailGo(CSnapInAutomationObject::GetCxxObject(punkDataObjectRetToSource,
                                                           &pMMCDataObjectRetToSource));
            pMMCDataObjectRetToSource->SetSnapIn(m_pSnapIn);
            pMMCDataObjectRetToSource->SetType(CMMCDataObject::CutOrMove);
        }
    }

    // Fire Views_Paste

    m_pSnapIn->GetViews()->FirePaste(
                 static_cast<IView *>(this),
                 piMMCClipboard,
                 static_cast<IScopeItem *>(pMMCDataObjectTarget->GetScopeItem()),
                 static_cast<IMMCDataObject *>(pMMCDataObjectRetToSource),
                 fvarMove);

    if (VARIANT_TRUE == fvarMove)
    {
        // If the source is not from this snap-in then return the MMCDataObject
        // used by the snap-in to return its info on items successfully pasted.

        if (IsForeign(SourceType))
        {
            IfFailGo(pMMCDataObjectRetToSource->QueryInterface(IID_IDataObject,
                           reinterpret_cast<void **>(ppiDataObjectRetToSource)));
        }
        else
        {
            // The source is in the same snap-in. Return the source data object
            // as the CutOrMove data object. The snap-in should have set
            // ScopeItem.Pasted and MMCListItem.Pasted in the MMCClipboard's
            // collections.  These collections simply AddRef()ed the items
            // contained in the source data object's collections.
            // See CView::OnCutOrMove() below for how this is interpreted.

            piDataObjectSource->AddRef();
            *ppiDataObjectRetToSource = piDataObjectSource;
        }
    }


Error:
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(punkDataObjectRetToSource);
    RRETURN(hr);
}




HRESULT CView::OnCutOrMove(IDataObject *piDataObjectFromTarget)
{
    HRESULT         hr = S_FALSE;
    IMMCClipboard  *piMMCClipboard = NULL;
    CMMCDataObject *pMMCDataObjectFromTarget  = NULL;
    IUnknown       *punkDataObjectFromTarget = NULL;
    BOOL            fNotFromThisSnapIn = FALSE;
    BOOL            fReleaseTargetDataObj = FALSE;

    SnapInSelectionTypeConstants TargetType = siEmpty;

    // If the source items come from this snap-in then create an MMCClipboard
    // object holding them

    ::IdentifyDataObject(piDataObjectFromTarget, m_pSnapIn,
                         &pMMCDataObjectFromTarget, &fNotFromThisSnapIn);

    if (fNotFromThisSnapIn)
    {
        // The source items do not come from this snap-in. Create an
        // MMCDataObject to wrap the data object from the target.

        punkDataObjectFromTarget = CMMCDataObject::Create(NULL);
        if (NULL == punkDataObjectFromTarget)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(CSnapInAutomationObject::GetCxxObject(punkDataObjectFromTarget,
                                                     &pMMCDataObjectFromTarget));
        pMMCDataObjectFromTarget->SetSnapIn(m_pSnapIn);
        pMMCDataObjectFromTarget->SetType(CMMCDataObject::Foreign);
        pMMCDataObjectFromTarget->SetForeignData(piDataObjectFromTarget);
    }
    else
    {
        // The data object is from this snap-in. We can use its ScopeItems and
        // ListItems collections directly in an MMCClipboard.

        IfFailGo(::CreateSelection(piDataObjectFromTarget, &piMMCClipboard,
                                   m_pSnapIn, &TargetType));

        // See comment at end of function for why we set this flag here.
        
        if (IsSingle(TargetType))
        {
            fReleaseTargetDataObj = TRUE;
        }

        pMMCDataObjectFromTarget = NULL; // don't want to pass this to snap-in
                                         // because MMCClipboard has the info
    }

    // Fire Views_Cut

    m_pSnapIn->GetViews()->FireCut(
                       static_cast<IView *>(this),
                       piMMCClipboard,
                       static_cast<IMMCDataObject *>(pMMCDataObjectFromTarget));

Error:

    // There is a bug in MMC 1.1 and MMC 1.2 in nodemgr\scopndcb in
    // CNodeCallback::_Paste. It sends MMCN_PASTE, receives the data object
    // from the target IComponent, passes it to the source in MMCN_CUTORMOVE
    // and then it doesn't release it. If MMC is ever fixed this next line
    // of code must be removed. This is NTBUGS 408535 for MMC and
    // NTBUGS 408537 for the designer. Note that the bug only happens in the
    // single selection case. With multiple selection MMC correctly releases
    // the data object.

    if (fReleaseTargetDataObj)
    {
        piDataObjectFromTarget->Release();
    }
    
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(punkDataObjectFromTarget);
    RRETURN(hr);
}



void CView::OnDeselectAll()
{
    HRESULT hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);


    m_pSnapIn->GetResultViews()->FireDeselectAll(
                             static_cast<IResultView *>(pResultView),
                             static_cast<IMMCConsoleVerbs *>(m_pMMCConsoleVerbs),
                             static_cast<IMMCControlbar *>(m_pControlbar));

Error:
    // need empty statement here to avoid compiler error saying "missing ';'
    // before '}'

    ;
}

HRESULT CView::OnContextHelp(IDataObject *piDataObject)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CMMCDataObject *pMMCDataObject  = NULL;
    CResultView    *pResultView = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Get the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    if (siSingleScopeItem == SelectionType)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));
        IfFalseGo(CMMCDataObject::ScopeItem == pMMCDataObject->GetType(), SID_E_INTERNAL);

        m_pSnapIn->GetScopeItems()->FireHelp(pMMCDataObject->GetScopeItem());
    }
    else if (siSingleListItem == SelectionType)
    {
        IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
        pResultView = pSelectedItem->GetResultView();
        IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));
        IfFalseGo(CMMCDataObject::ListItem == pMMCDataObject->GetType(), SID_E_INTERNAL);

        m_pSnapIn->GetResultViews()->FireHelp(pResultView,
                                              pMMCDataObject->GetListItem());
    }
    else
    {
        ASSERT(FALSE, "Bad selection type in MMCN_CONTEXTHELP");
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


HRESULT CView::OnDelete(IDataObject *piDataObject)
{
    HRESULT        hr = S_OK;
    IMMCClipboard *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Get the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    m_pSnapIn->GetViews()->FireDelete(this, piMMCClipboard);

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


HRESULT CView::OnColumnsChanged
(
    IDataObject         *piDataObject,
    MMC_VISIBLE_COLUMNS *pVisibleColumns
)
{
    HRESULT         hr = S_OK;
    SAFEARRAY      *psaColumns = NULL;
    long HUGEP     *plCol = NULL;
    INT             i = 0;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;
    VARIANT_BOOL    fvarPersist = VARIANT_TRUE;

    VARIANT varColumns;
    ::VariantInit(&varColumns);

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    // Get the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // Create the SAFEARRAY of VT_I4 containing the column numbers

    psaColumns = ::SafeArrayCreateVector(VT_I4, 1,
                   static_cast<unsigned long>(pVisibleColumns->nVisibleColumns));
    if (NULL == psaColumns)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = ::SafeArrayAccessData(psaColumns,
                               reinterpret_cast<void HUGEP **>(&plCol));
    EXCEPTION_CHECK_GO(hr);

    // Copy in the column numbers. Adjust for one-based.

    for (i = 0; i < pVisibleColumns->nVisibleColumns; i++)
    {
        plCol[i] = pVisibleColumns->rgVisibleCols[i] + 1;
    }

    hr = ::SafeArrayUnaccessData(psaColumns);
    EXCEPTION_CHECK_GO(hr);

    plCol = NULL;

    varColumns.vt = VT_I4 | VT_ARRAY;
    varColumns.parray = psaColumns;

    m_pSnapIn->GetResultViews()->FireColumnsChanged(pResultView,
                                                    varColumns,
                                                    &fvarPersist);
    if (VARIANT_TRUE == fvarPersist)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

Error:
    if (NULL != plCol)
    {
        (void)::SafeArrayUnaccessData(psaColumns);
    }
    if (NULL != psaColumns)
    {
        (void)::SafeArrayDestroy(psaColumns);
    }
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CView::GetCurrentListViewSelection
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IMMCClipboard **ppiMMCClipboard [out] Selection returned here if non-NULL
//   CMMDataObject **ppMMCDataObject [out] DataObject returned here if non-NULL
//                                         Caller must call Release on DataObject
//
// Output:
//
// Notes:
//
// Iterates through the result pane using IResultData::GetNextItem and creates
// a multi-select data object containing the selection. If ppiMMCClipboard is
// non-NULL then creates an MMCCLipboard containing the selection as well. Both
// objects are returned to the caller only if their corresponding out-pointer
// params are non-NULL.
//

HRESULT CView::GetCurrentListViewSelection
(
    IMMCClipboard  **ppiMMCClipboard,
    CMMCDataObject **ppMMCDataObject
)
{
    HRESULT         hr = S_OK;
    IUnknown       *punkDataObject = CMMCDataObject::Create(NULL);
    CMMCDataObject *pMMCDataObject = NULL;
    IUnknown       *punkScopeItems = CScopeItems::Create(NULL);
    CScopeItems    *pScopeItems = NULL;
    CScopeItem     *pScopeItem = NULL;
    IUnknown       *punkListItems = CMMCListItems::Create(NULL);
    CMMCListItems  *pMMCListItems = NULL;
    CMMCListItem   *pMMCListItem = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;
    long            lIndex = 0;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    CMMCListView   *pMMCListView = NULL;
    BOOL            fVirtual = FALSE;

    SnapInSelectionTypeConstants  SelectionType = siEmpty;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);
    pMMCListView = pResultView->GetListView();
    IfFalseGo(NULL != pMMCListView, SID_E_INTERNAL);
    fVirtual = pMMCListView->IsVirtual();

    ASSERT(fVirtual == m_fVirtualListView, "m_fVirtualListView does not agree with the current ListView.Virtual");

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    VARIANT varKey;
    ::VariantInit(&varKey);
    varKey.vt = VT_BSTR;

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    if (NULL != ppMMCDataObject)
    {
        *ppMMCDataObject = NULL;
    }

    if (NULL != ppiMMCClipboard)
    {
        *ppiMMCClipboard = NULL;
    }

    // Check that we created an MMCDataObject and the scope and list item
    // collections

    if ( (NULL == punkDataObject) || (NULL == punkScopeItems) ||
         (NULL == punkListItems) )
         
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkDataObject,
                                                   &pMMCDataObject));
    pMMCDataObject->SetSnapIn(m_pSnapIn);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkScopeItems,
                                                   &pScopeItems));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkListItems,
                                                   &pMMCListItems));

    // Iterate through the items in the listview and build the scope item and
    // list item collections. When adding an item owned by another collection,
    // CSnapInCollection<IObject, ICollection>::AddExisting will set the index
    // to the position in the new collection. We need to revert to the original
    // value as this item still belongs to its original owning collection (either
    // SnapIn.ScopeItems or ResultView.ListView.ListItems)
    
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;

    rdi.nState = LVIS_SELECTED; // Request only items that are selected
    hr = m_piResultData->GetNextItem(&rdi);
    EXCEPTION_CHECK_GO(hr);

    while (-1 != rdi.nIndex)
    {
        // As we requested only selected items this check isn't really necessary
        // but we double check anyway.

        if ( (rdi.nState & LVIS_SELECTED) != 0 )
        {
            if (rdi.bScopeItem)
            {
                pScopeItem = reinterpret_cast<CScopeItem *>(rdi.lParam);
                if (NULL == pScopeItem)
                {
                    // Static node has zero cookie. Technically this should
                    // never happen as the static node cannot appear in
                    // a list view owned by its own snap-in but we put this
                    // here just in case.
                    pScopeItem = m_pSnapIn->GetStaticNodeScopeItem();
                }
                lIndex = pScopeItem->GetIndex();
                varKey.bstrVal = pScopeItem->GetKey();
                if (NULL != varKey.bstrVal)
                {
                    varKey.vt = VT_BSTR;
                }
                else
                {
                    UNSPECIFIED_PARAM(varKey);
                }
                IfFailGo(pScopeItems->AddExisting(varUnspecifiedIndex, varKey,
                                        static_cast<IScopeItem *>(pScopeItem)));
                pScopeItem->SetIndex(lIndex);
            }
            else
            {
                // If this is a virtual list then we need to create a virtual
                // list item and fire ResultViews_GetVirtualItemData.
                // rdi.nIndex contains the zero based index.
                
                if (fVirtual)
                {
                    IfFailGo(GetVirtualListItem(rdi.nIndex + 1L, pMMCListView,
                                                FireGetItemData, &pMMCListItem));
                }
                else
                {
                    pMMCListItem = reinterpret_cast<CMMCListItem *>(rdi.lParam);
                }

                lIndex = pMMCListItem->GetIndex();
                varKey.bstrVal = pMMCListItem->GetKey();
                if (NULL != varKey.bstrVal)
                {
                    varKey.vt = VT_BSTR;
                }
                else
                {
                    UNSPECIFIED_PARAM(varKey);
                }
                IfFailGo(pMMCListItems->AddExisting(varUnspecifiedIndex, varKey,
                                     static_cast<IMMCListItem *>(pMMCListItem)));
                pMMCListItem->SetIndex(lIndex);

                if (fVirtual)
                {
                    // We need to release the ref from creation because the
                    // collection now holds its own ref
                    pMMCListItem->Release();
                    pMMCListItem = NULL;
                }
            }
        }

        rdi.nState = LVIS_SELECTED;
        hr = m_piResultData->GetNextItem(&rdi);
        EXCEPTION_CHECK_GO(hr);

    }

    // Put the arrays of scopitems and listitems into the data object

    pMMCDataObject->SetScopeItems(pScopeItems);
    pMMCDataObject->SetListItems(pMMCListItems);

    // Set the dataobject type to multiselect because we populated its
    // collections rather than its individual scope or list item.

    pMMCDataObject->SetType(CMMCDataObject::MultiSelect);

    // If requested, get a clipboard object with the selection

    if (NULL != ppiMMCClipboard)
    {
        IfFailGo(::CreateSelection(static_cast<IDataObject *>(pMMCDataObject),
                                   ppiMMCClipboard, m_pSnapIn, &SelectionType));
    }

    // If requested, return the data object

    if (NULL != ppMMCDataObject)
    {
        pMMCDataObject->AddRef();
        *ppMMCDataObject = pMMCDataObject;
    }

Error:
    if ( fVirtual && (NULL != pMMCListItem) )
    {
        pMMCListItem->Release();
    }
    QUICK_RELEASE(punkDataObject);
    QUICK_RELEASE(punkScopeItems);
    QUICK_RELEASE(punkListItems);
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}



HRESULT CView::CreateMultiSelectDataObject(IDataObject **ppiDataObject)
{
    HRESULT         hr = S_OK;
    IMMCClipboard  *piMMCClipboard = NULL;
    CMMCDataObject *pMMCDataObject = NULL;

    *ppiDataObject = NULL;

    // Get the current selection in both an MMCClipboard and an MMCDataObject

    IfFailGo(GetCurrentListViewSelection(&piMMCClipboard, &pMMCDataObject));

    // Give the snap-in a chance to set its own custom multi-select formats

    m_pSnapIn->GetViews()->FireGetMultiSelectData(static_cast<IView *>(this),
                                  piMMCClipboard,
                                  static_cast<IMMCDataObject *>(pMMCDataObject));

    *ppiDataObject = static_cast<IDataObject *>(pMMCDataObject);

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CView::GetVirtualListItem
//=--------------------------------------------------------------------------=
//
// Parameters:
//  long                     lIndex        [in]  index of virtual list item
//  CMMCListView            *pMMCListView  [in]  owning virtual listview
//  VirtualListItemOptions   Option        [in]  which event to fire
//  CMMCListItem           **ppMMCListItem [out] listitem returned here, caller
//                                               must Release
//
// Output:
//      HRESULT
//
// Notes:
//
// This function is called during IComponent::QueryDataObject() when the
// data object must represent list items in a virtual list view.
//
// Calls MMCListView.ListItems(lIndex) which will create the virtual list item
// and tie it to the listview (so it can access the underlying IResultData.
//
// Fires either ResultViews_GetVirtualItemDisplayInfo or
// ResultViews_GetVirtualItemData depending on option.
//
// A snap-in using a virtual list must implement GetVirtualItemDisplayInfo so
// that virtual list items will display correctly. Implementing
// GetVirtualItemData is optional.
//

HRESULT CView::GetVirtualListItem
(
    long                     lIndex,
    CMMCListView            *pMMCListView,
    VirtualListItemOptions   Option,
    CMMCListItem           **ppMMCListItem
)
{
    HRESULT        hr = S_OK;
    IMMCListItems *piMMCListItems = NULL; // Not AddRef()ed
    IMMCListItem  *piMMCListItem = NULL;
    CMMCListItem  *pMMCListItem = NULL;
    CResultView   *pResultView = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    piMMCListItems = pMMCListView->GetListItems();
    IfFalseGo(NULL != piMMCListItems, SID_E_INTERNAL);

    pResultView = pMMCListView->GetResultView();
    IfFalseGo(NULL != piMMCListItems, SID_E_INTERNAL);

    // Getting a list item at the given index in virtual list creates the
    // virtual list item. It does not become a member of the collection
    // but it does use a back point to the collection to get back up to the
    // View for IResultData access.

    varIndex.vt = VT_I4;
    varIndex.lVal = lIndex;
    IfFailGo(piMMCListItems->get_Item(varIndex, reinterpret_cast<MMCListItem **>(&piMMCListItem)));

    // We hold a ref on the newly minted virtual list item that will be
    // released below. The list item's data object also holds a ref on
    // it so it will stay alive until MMC releases the IDataObject

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItem,
                                                   &pMMCListItem));

    // Fire desired event

    if (FireGetItemData == Option)
    {
        m_pSnapIn->GetResultViews()->FireGetVirtualItemData(
                                      static_cast<IResultView *>(pResultView),
                                      static_cast<IMMCListItem *>(pMMCListItem));
    }
    else if (FireGetItemDisplayInfo == Option)
    {
        m_pSnapIn->GetResultViews()->FireGetVirtualItemDisplayInfo(
                                      static_cast<IResultView *>(pResultView),
                                      static_cast<IMMCListItem *>(pMMCListItem));
    }

    *ppMMCListItem = pMMCListItem;

Error:
    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCListItem);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CView::ListItemUpdate
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CMMCListItem *pMMCListItem [in]  list item that was updated
//
// Output:
//      HRESULT
//
// Notes:
//
// This function is called from CMMCListItem::Update for a virtual listitem so
// that we can check whether it is the same as the one we are caching. If they
// are the same then release our cached item and store this one. This allows the
// snap-in to do stuff like this in a virtual listview:
//
// Set ListItem = ResultView.ListItems(27)
// ListItem.Text = "Some new text"
// ListITem.Icon = 4
// ListItem.Update
//
// The first line creates a new MMCListItem and returns it. The next two lines
// set properties on it. The last line stores it so that when
// IComponent::GetDisplayInfo is called we will not fire
// ResultViews_GetVirtualItemDisplayInfo because we already have it.
//

void CView::ListItemUpdate(CMMCListItem *pMMCListItem)
{
    if (NULL != m_pCachedMMCListItem)
    {
        m_pCachedMMCListItem->Release();
    }
    pMMCListItem->AddRef();
    m_pCachedMMCListItem = pMMCListItem;
}




HRESULT CView::InternalCreatePropertyPages
(
    IPropertySheetCallback  *piPropertySheetCallback,
    LONG_PTR                 handle,
    IDataObject             *piDataObject,
    WIRE_PROPERTYPAGES     **ppPages
)
{
    HRESULT         hr = S_OK;
    BSTR            bstrProjectName = NULL;
    CPropertySheet *pPropertySheet = NULL;
    IUnknown       *punkPropertySheet = CPropertySheet::Create(NULL);
    IMMCClipboard  *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // Check that we have a CPropertySheet and get is this pointer.

    if (NULL == punkPropertySheet)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkPropertySheet,
        &pPropertySheet));

    // Give the property sheet its callback, handle, the selection, and the
    // project name which is the left hand portion of the prog ID.

    IfFailGo(GetProjectName(&bstrProjectName));

    // If this is a remote call (will happen during source debugging) then tell
    // the CPropertySheet so it can accumulate the property page info rather
    // than calling IPropertySheetCallback::AddPage.

    if (NULL != ppPages)
    {
        pPropertySheet->YouAreRemote();
    }

    IfFailGo(pPropertySheet->SetCallback(piPropertySheetCallback, handle,
                                         static_cast<LPOLESTR>(bstrProjectName),
                                         piMMCClipboard,
                                         static_cast<ISnapIn *>(m_pSnapIn),
                                         FALSE)); // not a config wizard

    // Let the snap-in add its property pages

    m_pSnapIn->GetViews()->FireCreatePropertyPages(
                               static_cast<IView *>(this),
                               piMMCClipboard,
                               static_cast<IMMCPropertySheet *>(pPropertySheet));

    // If we are remote then we need to ask CPropertySheet for its accumulated
    // property page definitions to return to the stub.

    if (NULL != ppPages)
    {
        *ppPages = pPropertySheet->TakeWirePages();
    }

    // Tell the property sheet to release its refs on all that stuff we
    // gave it above.

    (void)pPropertySheet->SetCallback(NULL, NULL, NULL, NULL, NULL, FALSE);


Error:
    FREESTRING(bstrProjectName);

    // Release our ref on the property sheet as the individual pages will addref
    // it and then release it when they are destroyed. If the snap-in did not
    // add any pages then our release here will destroy the property sheet.

    QUICK_RELEASE(punkPropertySheet);

    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}


HRESULT CView::GetScopeItemDisplayString
(
    CScopeItem *pScopeItem,
    int         nCol,
    LPOLESTR   *ppwszString
)
{
    HRESULT            hr = S_OK;
    CScopePaneItem    *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView       *pResultView = NULL;
    CMMCListView      *pMMCListView = NULL;
    IMMCListSubItems  *piMMCListSubItems = NULL;
    IMMCListSubItem   *piMMCListSubItem = NULL;
    CMMCListSubItem   *pMMCListSubItem = NULL;
    IMMCColumnHeaders *piListViewColumnHeaders = NULL;
    IMMCColumnHeaders *piScopeItemColumnHeaders = NULL;
    IMMCColumnHeader  *piMMCColumnHeader = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    if (NULL != pSelectedItem)
    {
        pResultView = pSelectedItem->GetResultView();
    }
    if (NULL != pResultView)
    {
        pMMCListView = pResultView->GetListView();
    }

    // If there is no listview or the selected item is not active (meaning it was
    // deselected) then this is a scope item in a namespace
    // extension being displayed in a result pane owned by the extendee. In that
    // case just use the the column number as an index into
    // ScopeItem.ListSubItems

    if ( (NULL == pMMCListView) || (!pSelectedItem->Active()) )
    {
        varIndex.vt = VT_I4;
        varIndex.lVal = (long)nCol + 1L; // adjust for 1-based collection
    }
    else
    {
        // This is a scope item displayed in a result pane belong to its own
        // snapin. Get the key of listview column header at the column number
        // requested by MMC

        IfFailGo(pMMCListView->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&piListViewColumnHeaders)));

        varIndex.vt = VT_I4;
        varIndex.lVal = (long)nCol + 1L; // adjust for 1-based collection

        // UNDONE: perf improvement here by getting the key string from
        // CColumnHeader::GetKey() rather than BSTR alloc

        IfFailGo(piListViewColumnHeaders->get_Item(varIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader)));
        IfFailGo(piMMCColumnHeader->get_Key(&varIndex.bstrVal));
        RELEASE(piMMCColumnHeader);
        varIndex.vt = VT_BSTR;

        // Get the column header with the same key in the scope item headers
        // and then get its index

        IfFailGo(pScopeItem->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&piScopeItemColumnHeaders)));
        IfFailGo(piScopeItemColumnHeaders->get_Item(varIndex, reinterpret_cast<MMCColumnHeader **>(&piMMCColumnHeader)));
        IfFailGo(::VariantClear(&varIndex));
        IfFailGo(piMMCColumnHeader->get_Index(&varIndex.lVal));
        varIndex.vt = VT_I4;
    }

    // Get the string in the scope item's ListSubItems at the index determined
    // above.

    IfFailGo(pScopeItem->get_ListSubItems(reinterpret_cast<MMCListSubItems **>(&piMMCListSubItems)));
    IfFailGo(piMMCListSubItems->get_Item(varIndex, reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListSubItem,
                                                   &pMMCListSubItem));
    *ppwszString = pMMCListSubItem->GetTextPtr();

Error:
    QUICK_RELEASE(piMMCListSubItems);
    QUICK_RELEASE(piMMCListSubItem);
    QUICK_RELEASE(piListViewColumnHeaders);
    QUICK_RELEASE(piScopeItemColumnHeaders);
    QUICK_RELEASE(piMMCColumnHeader);
    (void)::VariantClear(&varIndex);
    RRETURN(hr);
}


HRESULT CView::OnFilterButtonClick(long lColIndex, RECT *pRect)
{
    HRESULT            hr = S_OK;
    CScopePaneItem    *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView       *pResultView = NULL;
    CMMCListView      *pMMCListView = NULL;
    CMMCColumnHeaders *pMMCColumnHeaders = NULL;
    IMMCColumnHeader  *piMMCColumnHeader = NULL; // Not AddRef()ed

    // Crawl down the hierarchy to get the column headers collection

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);

    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    pMMCListView = pResultView->GetListView();
    IfFalseGo(NULL != pMMCListView, SID_E_INTERNAL);

    pMMCColumnHeaders = pMMCListView->GetColumnHeaders();
    IfFalseGo(NULL != pMMCColumnHeaders, SID_E_INTERNAL);

    IfFalseGo(lColIndex < pMMCColumnHeaders->GetCount(), SID_E_INTERNAL);
    piMMCColumnHeader = pMMCColumnHeaders->GetItemByIndex(lColIndex);

    // Fire ResultViews_FilterButtonClick

    m_pSnapIn->GetResultViews()->FireFilterButtonClick(pResultView,
                                                       piMMCColumnHeader,
                                                       pRect->left,
                                                       pRect->top,
                                                       pRect->bottom - pRect->top,
                                                       pRect->right - pRect->left);
Error:
    RRETURN(hr);
}

HRESULT CView::OnFilterChange(MMC_FILTER_CHANGE_CODE ChangeCode, long lColIndex)
{
    HRESULT            hr = S_OK;
    CScopePaneItem    *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView       *pResultView = NULL;
    CMMCListView      *pMMCListView = NULL;
    CMMCColumnHeaders *pMMCColumnHeaders = NULL;
    IMMCColumnHeader  *piMMCColumnHeader = NULL; // Not AddRef()ed

    SnapInFilterChangeTypeConstants Type = siEnable;

    // If we are currently populating the listview then this event was generated
    // becasue we applied a filter so ignore it

    IfFalseGo(!m_fPopulatingListView, S_OK);

    // Crawl down the hierarchy to get the column headers collection
            
    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);

    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    pMMCListView = pResultView->GetListView();
    IfFalseGo(NULL != pMMCListView, SID_E_INTERNAL);

    pMMCColumnHeaders = pMMCListView->GetColumnHeaders();
    IfFalseGo(NULL != pMMCColumnHeaders, SID_E_INTERNAL);

    // Set the change type enum based on the change code received from MMC.
    // For a value change get an IMMCColumnHeader* on the column that changed

    switch (ChangeCode)
    {
        case MFCC_DISABLE:
            Type = siDisable;
            break;

        case MFCC_ENABLE:
            Type = siEnable;
            break;

        case MFCC_VALUE_CHANGE:
            Type = siValueChange;
            IfFalseGo(lColIndex < pMMCColumnHeaders->GetCount(), SID_E_INTERNAL);
            piMMCColumnHeader = pMMCColumnHeaders->GetItemByIndex(lColIndex);
            break;
    }

    // Fire ResultViews_FilterChange

    m_pSnapIn->GetResultViews()->FireFilterChange(pResultView, piMMCColumnHeader,
                                                  Type);

Error:
    RRETURN(hr);
}


HRESULT CView::OnPropertiesVerb(IDataObject *piDataObject)
{
    HRESULT        hr = S_OK;
    IMMCClipboard *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // Fire Views_SpecialPropertiesClick

    m_pSnapIn->GetViews()->FireSpecialPropertiesClick(this, SelectionType);

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}

HRESULT CView::GetScopePaneItem
(
    CScopeItem      *pScopeItem,
    CScopePaneItem **ppScopePaneItem
)
{
    HRESULT         hr = S_OK;
    IScopePaneItem *piScopePaneItem = NULL;

    // If ScopeItem is NULL then this is a request for the static node due
    // to an IComponent::GetResultViewType(cookie=0) call.
    
    if (NULL == pScopeItem)
    {
        *ppScopePaneItem = m_pScopePaneItems->GetStaticNodeItem();
        if (NULL == *ppScopePaneItem)
        {
            IfFailGo(m_pScopePaneItems->AddNode(m_pSnapIn->GetStaticNodeScopeItem(),
                                                ppScopePaneItem));
        }
    }
    else
    {
        hr = m_pScopePaneItems->GetItemByName(pScopeItem->GetNamePtr(),
                                              &piScopePaneItem);
        if (SUCCEEDED(hr))
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopePaneItem,
                                                           ppScopePaneItem));
        }
        else if (SID_E_ELEMENT_NOT_FOUND == hr)
        {
            IfFailGo(m_pScopePaneItems->AddNode(pScopeItem, ppScopePaneItem));
        }
        else
        {
            IfFailGo(hr);
        }
    }

Error:

    // Note that we release the ref on the ScopePaneItem as we are returning
    // the C++ pointer. The item is guaranteed to be in the collection until
    // the MMC notification processing completes so this is OK. Possible
    // notifications that would call this function are MMCN_RESTORE_VIEW
    // (CView::OnResotreView()) and IComponent::GetResultViewType()
    // (CView::GetResultViewType()).
    
    QUICK_RELEASE(piScopePaneItem);
    RRETURN(hr);
}


HRESULT CView::GetCompareObject
(
    RDITEMHDR     *pItemHdr,
    CScopeItem   **ppScopeItem,
    CMMCListItem **ppMMCListItem,
    IDispatch    **ppdispItem
)
{
    HRESULT hr = S_OK;

    *ppMMCListItem = NULL;
    *ppScopeItem = NULL;
    *ppdispItem = NULL;

    if ( (pItemHdr->dwFlags & RDCI_ScopeItem) != 0 )
    {
        *ppScopeItem = reinterpret_cast<CScopeItem *>(pItemHdr->cookie);
        IfFailGo((*ppScopeItem)->QueryInterface(IID_IDispatch,
                                       reinterpret_cast<void **>(ppdispItem)));
    }
    else
    {
        *ppMMCListItem = reinterpret_cast<CMMCListItem *>(pItemHdr->cookie);
        IfFailGo((*ppMMCListItem)->QueryInterface(IID_IDispatch,
                                       reinterpret_cast<void **>(ppdispItem)));
    }

Error:
    RRETURN(hr);
}
    

HRESULT CView::AddMenu(CMMCMenu *pMMCMenu, HMENU hMenu, CMMCMenus *pMMCMenus)
{
    HRESULT    hr = S_OK;
    IMMCMenus *piMenuItems = NULL;
    CMMCMenus *pMMCMenuItems = NULL;
    IMMCMenus *piSubMenuItems = NULL;
    CMMCMenu  *pMMCMenuItem = NULL;
    long       cMenuItems = 0;
    long       i = 0;
    BOOL       fSkip = FALSE;
    BOOL       fHasChildren = FALSE;
    UINT       uiFlags = 0;
    HMENU      hMenuChild = NULL;
    UINT_PTR   uIDNewItem = 0;
    char      *pszCaption = NULL;
    long       lIndexCmdID = 0;

    // Get the children of the MMCMenu. These represent the items that
    // are being added to MMC's menu at the specified insertion point.

    IfFailGo(pMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMenuItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMenuItems, &pMMCMenuItems));

    cMenuItems = pMMCMenuItems->GetCount();

    // Iterate through the menu items and add each one to the popup menu and
    // to the CMMCMenus collection.

    for (i = 0; i < cMenuItems; i++)
    {
        // Add the menu item to our MMCMenus collection and get its command ID
        IfFailGo(CContextMenu::AddItemToCollection(pMMCMenus, pMMCMenuItems, i,
                                                   &pMMCMenuItem, &lIndexCmdID,
                                                   &fHasChildren, &fSkip));
        if (fSkip)
        {
            // Menu item is not visible, skip it.
            continue;
        }

        uiFlags = 0;

        uiFlags |= pMMCMenuItem->GetChecked() ? MF_CHECKED : MF_UNCHECKED;
        uiFlags |= pMMCMenuItem->GetEnabled() ? MF_ENABLED : MF_DISABLED;

        if (pMMCMenuItem->GetGrayed())
        {
            uiFlags |= MF_GRAYED;
        }

        if (pMMCMenuItem->GetMenuBreak())
        {
            uiFlags |= MF_MENUBREAK;
        }

        if (pMMCMenuItem->GetMenuBarBreak())
        {
            uiFlags |= MF_MENUBARBREAK;
        }

        if (fHasChildren)
        {
            uiFlags |= MF_POPUP;
            hMenuChild = ::CreatePopupMenu();
            if (NULL == hMenuChild)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK_GO(hr);
            }
            uIDNewItem = reinterpret_cast<UINT_PTR>(hMenuChild);
        }
        else
        {
            uiFlags |= MF_STRING;
            uIDNewItem = (UINT_PTR)lIndexCmdID;
        }

        IfFailGo(::ANSIFromWideStr(pMMCMenuItem->GetCaption(), &pszCaption));

        // Add the item to the popup menu

        if (!::AppendMenu(hMenu, uiFlags, uIDNewItem, pszCaption))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        // If the item is a popup then call this function recursively to add its
        // items. Pass the command ID of this menu as the insertion point for
        // the submenu.

        if (fHasChildren)
        {
            IfFailGo(AddMenu(pMMCMenuItem, hMenuChild, pMMCMenus));
        }

        // Set this to NULL. When the top level hMenu is destroyed it will
        // destroy all sub-menus

        hMenuChild = NULL;

        CtlFree(pszCaption);
        pszCaption = NULL;
    }

Error:
    QUICK_RELEASE(piMenuItems);
    QUICK_RELEASE(piSubMenuItems);
    if (NULL != hMenuChild)
    {
        (void)::DestroyMenu(hMenuChild);
    }
    if (NULL != pszCaption)
    {
        CtlFree(pszCaption);
    }
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                         IView Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CView::SetStatusBarText(BSTR Text)
{
    HRESULT hr = S_OK;
    BOOL    fAllocatedEmptyString = FALSE;

    // If a snap-in passes an empty string VBA will pass it as NULL. MMC can
    // handle that but when running in a debugging session the generated proxy
    // will return an error. So, if the string is NULL then we allocate an
    // empty BSTR.

    if (NULL == Text)
    {
        Text = ::SysAllocString(L"");
        if (NULL == Text)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        fAllocatedEmptyString = TRUE;
    }

    hr = m_piConsole2->SetStatusText(static_cast<LPOLESTR>(Text));
    EXCEPTION_CHECK(hr);

Error:
    if (fAllocatedEmptyString)
    {
        FREESTRING(Text);
    }

    RRETURN(hr);
}


STDMETHODIMP CView::SelectScopeItem
(
    ScopeItem *ScopeItem,
    VARIANT    ViewType,
    VARIANT    DisplayString
)
{
    HRESULT                        hr = S_OK;
    CScopeItem                    *pScopeItem = NULL;
    CScopePaneItem                *pScopePaneItem = NULL;
    SnapInResultViewTypeConstants  siViewType = siUnknown;
    BSTR                           bstrDisplayString = NULL; // Don't free
    
    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    if (NULL == ScopeItem)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the CScopeItem

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                        reinterpret_cast<IScopeItem *>(ScopeItem), &pScopeItem));

    // If ViewType and DisplayString were passed then convert them to the
    // correct types
    
    if (ISPRESENT(ViewType))
    {
        hr = ::VariantChangeType(&varCoerced, &ViewType, 0, VT_I2);
        EXCEPTION_CHECK_GO(hr);
        siViewType = (SnapInResultViewTypeConstants)varCoerced.iVal;

        hr = ::VariantClear(&varCoerced);
        EXCEPTION_CHECK_GO(hr);

    }

    if (ISPRESENT(DisplayString))
    {
        hr = ::VariantChangeType(&varCoerced, &DisplayString, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        bstrDisplayString = varCoerced.bstrVal;
    }

    // Get the corresponding ScopePaneItem and call
    // ScopePaneItem.DisplayNewResultView to do the work

    IfFailGo(GetScopePaneItem(pScopeItem, &pScopePaneItem));
    IfFailGo(pScopePaneItem->DisplayNewResultView(bstrDisplayString, siViewType));
        
Error:
    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);
    RRETURN(hr);
}

STDMETHODIMP CView::ExpandInTreeView(ScopeNode *ScopeNode)
{
    HRESULT     hr = S_OK;
    CScopeNode *pScopeNode = NULL;

    // Check passed pointer and check that this is not a disconnected or
    // foreign ScopeNode

    if (NULL == ScopeNode)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    if ( (NULL == m_piConsole2) || (NULL == m_pSnapIn) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                       reinterpret_cast<IScopeNode *>(ScopeNode), &pScopeNode));

    if (!pScopeNode->HaveHsi())
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piConsole2->Expand(pScopeNode->GetHSCOPEITEM(), TRUE);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


STDMETHODIMP CView::CollapseInTreeView(ScopeNode *ScopeNode)
{
    HRESULT  hr = S_OK;
    CScopeNode *pScopeNode = NULL;

    // Check passed pointer and check that this is not a disconnected or
    // foreign ScopeNode

    if (NULL == ScopeNode)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    if ( (NULL == m_piConsole2) || (NULL == m_pSnapIn) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                       reinterpret_cast<IScopeNode *>(ScopeNode), &pScopeNode));

    if (!pScopeNode->HaveHsi())
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piConsole2->Expand(pScopeNode->GetHSCOPEITEM(), FALSE);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



STDMETHODIMP CView::NewWindow
(
    ScopeNode                      *ScopeNode,
    SnapInNewWindowOptionConstants  Options,
    VARIANT                         Caption
)
{
    HRESULT     hr = S_OK;
    CScopeNode *pScopeNode = NULL;
    long        lOptions = MMC_NW_OPTION_NONE;

    // Check passed pointer and check that this is not a disconnected or
    // foreign ScopeNode

    if (NULL == ScopeNode)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    if ( (NULL == m_piConsole2) || (NULL == m_pSnapIn) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                       reinterpret_cast<IScopeNode *>(ScopeNode), &pScopeNode));

    if (!pScopeNode->HaveHsi())
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    if ( (Options & siNoScopePane) != 0 )
    {
        lOptions |= MMC_NW_OPTION_NOSCOPEPANE;
    }

    if ( (Options & siNoToolbars) != 0 )
    {
        lOptions |= MMC_NW_OPTION_NOTOOLBARS;
    }

    if ( (Options & siShortTitle) != 0 )
    {
        lOptions |= MMC_NW_OPTION_SHORTTITLE;
    }

    if ( (Options & siCustomTitle) != 0 )
    {
        lOptions |= MMC_NW_OPTION_CUSTOMTITLE;
    }

    if ( (Options & siNoPersist) != 0 )
    {
        lOptions |= MMC_NW_OPTION_NOPERSIST;
    }

    if ( ISPRESENT(Caption) && (VT_BSTR == Caption.vt) )
    {
        IfFailGo(m_pSnapIn->GetViews()->SetNextViewCaption(Caption.bstrVal));
    }

    hr = m_piConsole2->NewWindow(pScopeNode->GetHSCOPEITEM(), lOptions);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



STDMETHODIMP CView::PopupMenu(MMCMenu *Menu, long Left, long Top)
{
    HRESULT    hr = S_OK;
    HMENU      hMenu = NULL;
    IUnknown  *punkMMCMenus = NULL;
    CMMCMenus *pMMCMenus = NULL;
    CMMCMenu  *pMMCMenu = NULL;
    long       i = 0;
    HWND       hwndDummyOwner = NULL;
    HWND       hwndOwner = NULL;

    if (NULL == Menu)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Create a popup menu

    hMenu = ::CreatePopupMenu();
    if (NULL == hMenu)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Create an MMCMenus collection

    punkMMCMenus = CMMCMenus::Create(NULL);
    if (NULL == punkMMCMenus)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCMenus, &pMMCMenus));

    // Build the popup menu from the MMCMenu. Add each menu item to the popup
    // menu and to the MMCMenus collection. The collection index will be used
    // as the popup menu ID. When the user makes a selection we will find the
    // corresponding MMCMenu object by index and fire the event on it.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                reinterpret_cast<IMMCMenu *>(Menu), &pMMCMenu));

    IfFailGo(AddMenu(pMMCMenu, hMenu, pMMCMenus));

    
    // If we are not remoted then get the console's main frame window handle as
    // the owner of the popup menu

    if (!m_pSnapIn->WeAreRemote())
    {
        if (NULL == m_piConsole2)
        {
            hr = SID_E_NOT_CONNECTED_TO_MMC;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = m_piConsole2->GetMainWindow(&hwndOwner);
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        // We are remoted so we can't use an HWND from another process. Need to
        // create a dummy invisible window because TrackPopupMenu() requires a
        // valid HWND. We create a STATIC control so that we don't have to
        // register a window class.

        hwndDummyOwner = ::CreateWindow("STATIC", // window class
                                        NULL,     // no title
                                        WS_POPUP, // no styles
                                        0,        // upper left corner x
                                        0,        // upper left corner y
                                        0,        // no width
                                        0,        // no height
                                        NULL,     // no owner window
                                        NULL,     // no menu
                                        GetResourceHandle(), // HINSTANCE
                                        NULL);    // no lParam for WM_CREATE
        if (NULL == hwndDummyOwner)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        hwndOwner = hwndDummyOwner;
    }

    i = (long)::TrackPopupMenu(hMenu,            // menu to display
                               TPM_LEFTALIGN |   // align left side of menu with Top
                               TPM_TOPALIGN  |   // align top of menu with Top
                               TPM_NONOTIFY  |   // don't send any messages during selection
                               TPM_RETURNCMD |   // make the ret val the selected item
                               TPM_LEFTBUTTON,   // allow selection with left button only
                               Left,             // left side coordinate
                               Top,              // top coordinate
                               0,                // reserved,
                               hwndOwner,        // owner window
                               NULL);            // not used

    // A zero return could indicate either an error or that the user hit
    // Escape or clicked off of the menu to cancel the operation. GetLastError()
    // determines whether there was an error.

    if (0 == i)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }
    IfFalseGo((0 != i), S_OK);

    // if i is non-zero then it contains the index of the selected item in the
    // MMCMenus collection.

   IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                 pMMCMenus->GetItemByIndex(i - 1L), &pMMCMenu));

   // Fire the menu click event. CContextMenu has a utility function that
   // does this.
   
   CContextMenu::FireMenuClick(pMMCMenu, NULL);

Error:
    if (NULL != hMenu)
    {
        (void)::DestroyMenu(hMenu);
    }
    if (NULL != hwndDummyOwner)
    {
        (void)::DestroyWindow(hwndDummyOwner);
    }
    QUICK_RELEASE(punkMMCMenus);
    RRETURN(hr);
}


STDMETHODIMP CView::get_MMCMajorVersion(long *plVersion)
{
    HRESULT hr = S_OK;

    *plVersion = 0;

    // If we don't have m_piConsole2 yet then IComponent::Initialize hasn't
    // been called so we can't yet discern the MMC version.

    IfFalseGo(NULL != m_piConsole2, SID_E_MMC_VERSION_NOT_AVAILABLE);

    // We only support MMC 1.1 and 1.2 so always return 1

    *plVersion = 1L;

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


STDMETHODIMP CView::get_MMCMinorVersion(long *plVersion)
{
    HRESULT hr = S_OK;

    // If we don't have m_piConsole2 yet then IComponent::Initialize hasn't
    // been called so we can't yet discern the MMC version.

    IfFalseGo(NULL != m_piConsole2, SID_E_MMC_VERSION_NOT_AVAILABLE);

    if (NULL == m_piColumnData)
    {
        // Must be MMC 1.1 as IColumnData is MMC 1.2 only
        *plVersion = 1L;
    }
    else
    {
        *plVersion = 2L;
    }

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}

STDMETHODIMP CView::get_ColumnSettings
(
    BSTR             ColumnSetID,
    ColumnSettings **ppColumnSettings
)
{
    HRESULT              hr = S_OK;
    IUnknown            *punkColumnSettings = NULL;
    SColumnSetID        *pSColumnSetID = NULL;
    MMC_COLUMN_SET_DATA *pColSetData = NULL;
    MMC_COLUMN_DATA     *pColData = NULL;
    IColumnSettings     *piColumnSettings = NULL;
    CColumnSettings     *pColumnSettings = NULL;
    IColumnSetting      *piColumnSetting = NULL;
    long                 i = 0;

    VARIANT varUnspecifiedParam;
    UNSPECIFIED_PARAM(varUnspecifiedParam);

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    if (NULL == m_piColumnData)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        EXCEPTION_CHECK_GO(hr);
    }

    punkColumnSettings = CColumnSettings::Create(NULL);
    if (NULL == punkColumnSettings)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(punkColumnSettings->QueryInterface(IID_IColumnSettings,
                                 reinterpret_cast<void **>(&piColumnSettings)));

    IfFailGo(::GetColumnSetID(ColumnSetID, &pSColumnSetID));

    // Get the current column configuration

    hr = m_piColumnData->GetColumnConfigData(pSColumnSetID, &pColSetData);
    EXCEPTION_CHECK_GO(hr);

    // The pointer will come back NULL if MMC has not yet persisted the column
    // config.

    if (NULL != pColSetData)
    {
        // Add an element to the collection for each persisted column. Adjust the
        // indexes and positions to be one-based. Start by adding the elements.

        for (i = 0; i < pColSetData->nNumCols; i++)
        {
            IfFailGo(piColumnSettings->Add(varUnspecifiedParam, // Index
                                           varUnspecifiedParam, // Key
                                           varUnspecifiedParam, // Width
                                           varUnspecifiedParam, // Hidden
                                           varUnspecifiedParam, // Position
                         reinterpret_cast<ColumnSetting **>(&piColumnSetting)));
            RELEASE(piColumnSetting);
        }

        // Now go through the columns and set their properties.

        varIndex.vt = VT_I4;
        pColData = pColSetData->pColData;

        for (i = 0; i < pColSetData->nNumCols; i++, pColData++)
        {
            varIndex.lVal = static_cast<long>(pColData->nColIndex) + 1L;
            IfFailGo(piColumnSettings->get_Item(varIndex,
                         reinterpret_cast<ColumnSetting **>(&piColumnSetting)));

            IfFailGo(piColumnSetting->put_Width(static_cast<long>(pColData->nWidth)));

            if ( (pColData->dwFlags & HDI_HIDDEN) != 0 )
            {
                IfFailGo(piColumnSetting->put_Hidden(VARIANT_TRUE));
            }
            else
            {
                IfFailGo(piColumnSetting->put_Hidden(VARIANT_FALSE));
            }

            // A columns position in the list view is based on where it appears in
            // the array returned from MMC

            IfFailGo(piColumnSetting->put_Position(i + 1L));

            RELEASE(piColumnSetting);
        }
    }

    // Set ColumnSettings.ColumnSetID

    IfFailGo(piColumnSettings->put_ColumnSetID(ColumnSetID));

    // Give ColumnSettings its back pointer to the owning View so it can get
    // the IColumnData to implement ColumnSettings.Perist

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piColumnSettings,
                                                   &pColumnSettings));
    pColumnSettings->SetView(this);

    *ppColumnSettings = reinterpret_cast<ColumnSettings *>(piColumnSettings);
    piColumnSettings->AddRef();

Error:
    QUICK_RELEASE(punkColumnSettings);
    QUICK_RELEASE(piColumnSettings);
    QUICK_RELEASE(piColumnSetting);

    if (NULL != pSColumnSetID)
    {
        CtlFree(pSColumnSetID);
    }

    if (NULL != pColSetData)
    {
        ::CoTaskMemFree(pColSetData);
    }
    RRETURN(hr);
}

STDMETHODIMP CView::get_SortSettings
(
    BSTR       ColumnSetID,
    SortKeys **ppSortKeys
)
{
    HRESULT            hr = S_OK;
    IUnknown          *punkSortKeys = NULL;
    SColumnSetID      *pSColumnSetID = NULL;
    MMC_SORT_SET_DATA *pSortSetData = NULL;
    MMC_SORT_DATA     *pSortData = NULL;
    ISortKeys         *piSortKeys = NULL;
    CSortKeys         *pSortKeys = NULL;
    ISortKey          *piSortKey = NULL;
    long               i = 0;

    VARIANT varUnspecifiedParam;
    UNSPECIFIED_PARAM(varUnspecifiedParam);

    VARIANT varSortColumn;
    ::VariantInit(&varSortColumn);

    VARIANT varSortOrder;
    ::VariantInit(&varSortOrder);

    VARIANT varSortIcon;
    ::VariantInit(&varSortIcon);

    if (NULL == m_piColumnData)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        EXCEPTION_CHECK_GO(hr);
    }

    punkSortKeys = CSortKeys::Create(NULL);
    if (NULL == punkSortKeys)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(punkSortKeys->QueryInterface(IID_ISortKeys,
                                          reinterpret_cast<void **>(&piSortKeys)));

    IfFailGo(::GetColumnSetID(ColumnSetID, &pSColumnSetID));

    // Get the current sort settings

    hr = m_piColumnData->GetColumnSortData(pSColumnSetID, &pSortSetData);
    EXCEPTION_CHECK_GO(hr);

    // The pointer will come back NULL if MMC has not yet persisted the sort
    // settings

    if (NULL != pSortSetData)
    {
        // Add an element to the collection for each persisted column. Adjust the
        // indexes and positions to be one-based. Start by adding the elements.

        varSortColumn.vt = VT_I4;
        varSortOrder.vt = VT_I4;
        varSortIcon.vt = VT_BOOL;

        for (i = 0, pSortData = pSortSetData->pSortData;
             i < pSortSetData->nNumItems;
             i++, pSortData++)
        {
            varSortColumn.lVal = static_cast<long>(pSortData->nColIndex + 1);

            if ( (pSortData->dwSortOptions & RSI_DESCENDING) != 0 )
            {
                varSortOrder.lVal = static_cast<long>(siDescending);
            }
            else
            {
                varSortOrder.lVal = static_cast<long>(siAscending);
            }

            if ( (pSortData->dwSortOptions & RSI_NOSORTICON) != 0 )
            {
                varSortIcon.boolVal = VARIANT_FALSE;
            }
            else
            {
                varSortIcon.boolVal = VARIANT_TRUE;
            }

            IfFailGo(piSortKeys->Add(varUnspecifiedParam, // Index
                                     varUnspecifiedParam, // Key
                                     varSortColumn,
                                     varSortOrder,
                                     varSortIcon,
                                     reinterpret_cast<SortKey **>(&piSortKey)));
            RELEASE(piSortKey);
        }
    }

    // Set SortKeys.ColumnSetID

    IfFailGo(piSortKeys->put_ColumnSetID(ColumnSetID));

    // Give SortKeys its back pointer to the owning View so it can get
    // the IColumnData to implement SortKeys.Perist

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piSortKeys, &pSortKeys));
    pSortKeys->SetView(this);

    *ppSortKeys = reinterpret_cast<SortKeys *>(piSortKeys);
    piSortKeys->AddRef();

Error:
    QUICK_RELEASE(punkSortKeys);
    QUICK_RELEASE(piSortKeys);
    QUICK_RELEASE(piSortKey);

    if (NULL != pSColumnSetID)
    {
        CtlFree(pSColumnSetID);
    }

    if (NULL != pSortSetData)
    {
        ::CoTaskMemFree(pSortSetData);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         IComponent Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::Initialize(IConsole *piConsole)
{
    DebugPrintf("IComponent::Initialize\r\n");
    
    HRESULT                 hr = S_OK;
    IContextMenuProvider   *piContextMenuProvider = NULL;
    IPropertySheetProvider *piPropertySheetProvider = NULL;

    // In theory, this method should never be called twice but as a precaution
    // we'll release any existing console interfaces.

    ReleaseConsoleInterfaces();

    // Acquire all the console interfaces needed for the life of the view

    IfFailGo(piConsole->QueryInterface(IID_IConsole2,
                                     reinterpret_cast<void **>(&m_piConsole2)));
    
    IfFailGo(m_piConsole2->QueryInterface(IID_IResultData,
                                   reinterpret_cast<void **>(&m_piResultData)));

    IfFailGo(m_piConsole2->QueryInterface(IID_IHeaderCtrl2,
                                  reinterpret_cast<void **>(&m_piHeaderCtrl2)));

    IfFailGo(m_piConsole2->SetHeader(m_piHeaderCtrl2));

    // Try to get IColumnData. If MMC version < 1.2 then this will fail.
    (void)m_piConsole2->QueryInterface(IID_IColumnData,
                                    reinterpret_cast<void **>(&m_piColumnData));

    IfFailGo(m_piConsole2->QueryResultImageList(&m_piImageList));

    IfFailGo(m_piConsole2->QueryConsoleVerb(&m_piConsoleVerb));

    IfFailGo(piConsole->QueryInterface(IID_IContextMenuProvider,
                            reinterpret_cast<void **>(&piContextMenuProvider)));

    IfFailGo(m_pMMCContextMenuProvider->SetProvider(piContextMenuProvider, this));

    IfFailGo(piConsole->QueryInterface(IID_IPropertySheetProvider,
                          reinterpret_cast<void **>(&piPropertySheetProvider)));

    IfFailGo(m_pMMCPropertySheetProvider->SetProvider(piPropertySheetProvider,
                                                      this));

    // Fire Views_Load to tell snap-in that MMC has initialized the view

    m_pSnapIn->GetViews()->FireLoad(static_cast<IView *>(this));
    
Error:
    QUICK_RELEASE(piContextMenuProvider);
    QUICK_RELEASE(piPropertySheetProvider);
    RRETURN(hr);
}


STDMETHODIMP CView::Notify
(
    IDataObject     *piDataObject,
    MMC_NOTIFY_TYPE  event,
    long             Arg,
    long             Param
)
{
    DebugPrintf("IComponent::Notify(event=0x%08.8X Arg=%ld (0x%08.8X) Param=%ld (0x%08.8X)\r\n",  event, Arg, Arg, Param, Param);
    HRESULT hr = S_OK;

    switch (event)
    {
        case MMCN_ACTIVATE:
            DebugPrintf("IComponent::Notify(MMCN_ACTIVATE)\r\n");
            OnActivate((BOOL)Arg);
            break;
            
        case MMCN_ADD_IMAGES:
            DebugPrintf("IComponent::Notify(MMCN_ADD_IMAGES)\r\n");
            hr = OnAddImages(piDataObject,
                             reinterpret_cast<IImageList *>(Arg),
                             (HSCOPEITEM)Param);
            break;

        case MMCN_BTN_CLICK:
            DebugPrintf("IComponent::Notify(MMCN_BTN_CLICK)\r\n");
            hr = OnButtonClick(piDataObject,
                               static_cast<MMC_CONSOLE_VERB>(Param));
            break;

        case MMCN_COLUMN_CLICK:
            DebugPrintf("IComponent::Notify(MMCN_COLUMN_CLICK)\r\n");
            hr = OnColumnClick(Arg, Param);
            break;

        case MMCN_COLUMNS_CHANGED:
            DebugPrintf("IComponent::Notify(MMCN_COLUMNS_CHANGED)\r\n");
            hr = OnColumnsChanged(piDataObject,
                                  reinterpret_cast<MMC_VISIBLE_COLUMNS *>(Param));
            break;

        case MMCN_CUTORMOVE:
            DebugPrintf("IComponent::Notify(MMCN_CUTORMOVE)\r\n");
            hr = OnCutOrMove((IDataObject *)Arg);
            break;

        case MMCN_DBLCLICK:
            DebugPrintf("IComponent::Notify(MMCN_DBLCLICK)\r\n");
            hr = OnDoubleClick(piDataObject);
            break;

        case MMCN_DELETE:
            DebugPrintf("IComponent::Notify(MMCN_DELETE)\r\n");
            hr = OnDelete(piDataObject);
            break;

        case MMCN_DESELECT_ALL:
            DebugPrintf("IComponent::Notify(MMCN_DESELECT_ALL)\r\n");
            OnDeselectAll();
            break;

        case MMCN_FILTER_CHANGE:
            DebugPrintf("IComponent::Notify(MMCN_FILTER_CHANGE)\r\n");
            hr = OnFilterChange((MMC_FILTER_CHANGE_CODE)Arg, (long)Param);
            break;

        case MMCN_FILTERBTN_CLICK:
            DebugPrintf("IComponent::Notify(MMCN_FILTERBTN_CLICK)\r\n");
            hr = OnFilterButtonClick((long)Arg, (RECT *)Param);
            break;

        case MMCN_INITOCX:
            DebugPrintf("IComponent::Notify(MMCN_INITOCX)\r\n");
            hr = OnInitOCX(reinterpret_cast<IUnknown *>(Param));
            break;

        case MMCN_LISTPAD:
            DebugPrintf("IComponent::Notify(MMCN_LISTPAD)\r\n");
            hr = OnListpad(piDataObject, (BOOL)Arg);
            break;

        case MMCN_CONTEXTHELP:
            DebugPrintf("IComponent::Notify(MMCN_CONTEXTHELP)\r\n");
            OnContextHelp(piDataObject);
            break;

        case MMCN_MINIMIZED:
            DebugPrintf("IComponent::Notify(MMCN_MINIMIZED)\r\n");
            OnMinimized((BOOL)Arg);
            break;

        case MMCN_PASTE:
            DebugPrintf("IComponent::Notify(MMCN_PASTE)\r\n");
            hr = OnPaste(piDataObject, (IDataObject *)Arg, (IDataObject **)Param);
            break;

        case MMCN_PRINT:
            DebugPrintf("IComponent::Notify(MMCN_PRINT)\r\n");
            hr = OnPrint(piDataObject);
            break;

        case MMCN_QUERY_PASTE:
            DebugPrintf("IComponent::Notify(MMCN_QUERY_PASTE)\r\n");
            hr = OnQueryPaste(piDataObject, (IDataObject *)Arg);
            break;

        case MMCN_REFRESH:
            DebugPrintf("IComponent::Notify(MMCN_REFRESH)\r\n");
            hr = OnRefresh(piDataObject);
            break;

        case MMCN_RENAME:
            DebugPrintf("IComponent::Notify(MMCN_RENAME)\r\n");
            hr = OnRename(piDataObject, (OLECHAR *)Param);
            break;

        case MMCN_RESTORE_VIEW:
            DebugPrintf("IComponent::Notify(MMCN_RESTORE_VIEW)\r\n");
            hr = OnRestoreView(piDataObject,
                               (MMC_RESTORE_VIEW *)Arg,
                               (BOOL *)Param);
            break;

        case MMCN_SELECT:
            DebugPrintf("IComponent::Notify(MMCN_SELECT)\r\n");
            hr = OnSelect(piDataObject, (BOOL)LOWORD(Arg), (BOOL)HIWORD(Arg));
            break;

        case MMCN_SHOW:
            DebugPrintf("IComponent::Notify(MMCN_SHOW)\r\n");
            hr = OnShow((BOOL)Arg, (HSCOPEITEM)Param);
            break;

        case MMCN_SNAPINHELP:
            DebugPrintf("IComponent::Notify(MMCN_SNAPINHELP)\r\n");
            m_pSnapIn->FireHelp();
            break;

        case MMCN_VIEW_CHANGE:
            DebugPrintf("IComponent::Notify(MMCN_VIEW_CHANGE)\r\n");
            hr = OnViewChange(piDataObject, Arg);
            break;

    }

    RRETURN(hr);
}


STDMETHODIMP CView::Destroy(long cookie)
{
    HRESULT         hr = S_OK;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    DebugPrintf("IComponent::Destroy\r\n");

    m_pSnapIn->GetViews()->FireTerminate(static_cast<IView *>(this));
    
    ReleaseConsoleInterfaces();

    // CSnapIn::CreateComponent caused an IObjectModel::SetHost() on this object
    // when it was created and this is the only opportunity remove our reference
    // on the host (which is CSnapIn)

    static_cast<IObjectModel *>(this)->SetHost(NULL);

    // Remove this view from SnapIn.Views

    varIndex.vt = VT_I4;
    varIndex.lVal = m_Index;

    IfFailGo(m_pSnapIn->GetViews()->Remove(varIndex));

    // Tell the ContextMenuProvider object to release its MMC interface and
    // to release its ref on us

    IfFailGo(m_pMMCContextMenuProvider->SetProvider(NULL, NULL));

    // Tell the PropertySheetProvider object to release its MMC interface and
    // to release its ref on us

    IfFailGo(m_pMMCPropertySheetProvider->SetProvider(NULL, NULL));

Error:    
    RRETURN(hr);
}



STDMETHODIMP CView::QueryDataObject
(
    long                cookie,
    DATA_OBJECT_TYPES   type,
    IDataObject       **ppiDataObject
)
{
    DebugPrintf("IComponent::QueryDataObject cookie=0x%08.8X type=0x%08.8X\r\n", cookie, type);

    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = NULL;
    IUnknown       *punkDataObject = NULL;
    CMMCListItem   *pMMCListItem = NULL;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    CMMCListView   *pMMCListView = NULL;
    BOOL            fReleaseListItem = FALSE;

    *ppiDataObject = NULL;

    if (IS_SPECIAL_COOKIE(cookie))
    {
        if ( (CCT_UNINITIALIZED == type) && (MMC_WINDOW_COOKIE == cookie) )
        {
            punkDataObject = CMMCDataObject::Create(NULL);
            if (NULL == punkDataObject)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }

            IfFailGo(CSnapInAutomationObject::GetCxxObject(punkDataObject,
                                                           &pMMCDataObject));
            pMMCDataObject->SetSnapIn(m_pSnapIn);

            pMMCDataObject->SetType(CMMCDataObject::WindowTitle);
            IfFailGo(pMMCDataObject->SetCaption(m_bstrCaption));
        }
        else if (MMC_MULTI_SELECT_COOKIE == cookie)
        {
            IfFailGo(CreateMultiSelectDataObject(ppiDataObject));
        }
    }
    else if (CCT_RESULT == type)
    {
        IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
        pResultView = pSelectedItem->GetResultView();
        IfFalseGo(NULL != pResultView, SID_E_INTERNAL);
        pMMCListView = pResultView->GetListView();
        IfFalseGo(NULL != pMMCListView, SID_E_INTERNAL);

        if (pMMCListView->IsVirtual())
        {
            // Create a virtual list item for use with the data object and fire
            // ResultViews_GetVirtualItemData

            IfFailGo(GetVirtualListItem(cookie + 1L, pMMCListView,
                                        FireGetItemData, &pMMCListItem));

            // We hold a ref on the newly minted virtual list item that will be
            // released below. The list item's data object also holds a ref on
            // it so it will stay alive until MMC releases the IDataObject
            fReleaseListItem = TRUE;
        }
        else
        {
            pMMCListItem = reinterpret_cast<CMMCListItem *>(cookie);
        }
        pMMCDataObject = pMMCListItem->GetData();
        pMMCDataObject->SetContext(CCT_RESULT);
    }

    if (NULL != pMMCDataObject)
    {
        IfFailGo(pMMCDataObject->QueryInterface(IID_IDataObject,
                                      reinterpret_cast<void **>(ppiDataObject)));
    }

Error:
    if (fReleaseListItem)
    {
        pMMCListItem->Release();
    }
    QUICK_RELEASE(punkDataObject);
    RRETURN(hr);
}


STDMETHODIMP CView::GetResultViewType
(
    long      cookie,
    LPOLESTR *ppViewType,
    long     *pViewOptions
)
{
    DebugPrintf("IComponent::GetResultViewType cookie=0x%08.8X\r\n", cookie);

    HRESULT         hr = S_OK;
    CScopePaneItem *pScopePaneItem = NULL;
    CScopeItem     *pScopeItem = NULL;
    CMMCListView   *pMMCListView = NULL;

    SnapInResultViewTypeConstants Type = siUnknown;

    *ppViewType = NULL;
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;

    // Reset our virtual list view flag because we are transitioning to a new
    // result view.

    m_fVirtualListView = FALSE;


    IfFailGo(GetScopePaneItem(reinterpret_cast<CScopeItem *>(cookie),
                              &pScopePaneItem));
    
    // This is now the selected scope pane item so remember it
    m_pScopePaneItems->SetSelectedItem(pScopePaneItem);

    // Determine the result view by examining defaults and firing
    // events into the snap-in
    IfFailGo(pScopePaneItem->DetermineResultView());

    Type = pScopePaneItem->GetActualResultViewType();

    if (siOCXView == Type)
    {
        if (pScopePaneItem->GetResultView()->AlwaysCreateNewOCX())
        {
            *pViewOptions |= MMC_VIEW_OPTIONS_CREATENEW;
        }
    }
    else if ( (siListView == Type) || (siListpad == Type) )
    {
        pMMCListView = pScopePaneItem->GetResultView()->GetListView();

        if (pMMCListView->IsVirtual())
        {
            *pViewOptions |= MMC_VIEW_OPTIONS_OWNERDATALIST;
            m_fVirtualListView = TRUE;
        }

        if (pMMCListView->MultiSelect())
        {
            *pViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;
        }

        if (pMMCListView->UseFontLinking())
        {
            *pViewOptions |= MMC_VIEW_OPTIONS_USEFONTLINKING;
        }

        // If MMC >= 1.2 then check 1.2-only options

        if (NULL != m_piColumnData)
        {
            if (pMMCListView->GetView() == siFiltered)
            {
                *pViewOptions |= MMC_VIEW_OPTIONS_FILTERED;
            }

            if (!pMMCListView->ShowChildScopeItems())
            {
                *pViewOptions |= MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST;
            }

            if (pMMCListView->LexicalSort())
            {
                *pViewOptions |= MMC_VIEW_OPTIONS_LEXICAL_SORT;
            }
        }
    }

    switch (Type)
    {
        case siURLView:
        case siOCXView:
        case siTaskpad:
        case siListpad:
        case siCustomTaskpad:
        case siMessageView:
            IfFailGo(::CoTaskMemAllocString(
                                        pScopePaneItem->GetActualDisplayString(),
                                        ppViewType));
            break;

        default:
            break;
    }

    // If not doing a listview check if there are any listviews for this
    // scope pane item.

    if (!pScopePaneItem->HasListViews())
    {
        *pViewOptions |= MMC_VIEW_OPTIONS_NOLISTVIEWS;
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CView::GetDisplayInfo
(
    RESULTDATAITEM *prdi
)
{
    DebugPrintf("IComponent::GetDisplayInfo %s %ls\r\n", prdi->bScopeItem ? "Scope item: " : "List item: ", prdi->bScopeItem ? (reinterpret_cast<CScopeItem *>(prdi->lParam))->GetDisplayNamePtr() : m_fVirtualListView ? L"<virtual list item>" : (reinterpret_cast<CMMCListItem *>(prdi->lParam))->GetTextPtr());

    HRESULT         hr = S_OK;
    CScopeItem     *pScopeItem = NULL;
    CMMCListItem   *pMMCListItem = NULL;
    long            lViewMode = MMCLV_VIEWSTYLE_ICON;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    CMMCListView   *pMMCListView = NULL;

    if (prdi->bScopeItem)
    {
        pScopeItem = reinterpret_cast<CScopeItem *>(prdi->lParam);
        if (NULL == pScopeItem)
        {
            // Static node has zero cookie. Technically this should
            // never happen as the static node cannot appear in
            // a list view owned by its own snap-in but we put this
            // here just in case.
            pScopeItem = m_pSnapIn->GetStaticNodeScopeItem();
        }

        if ( RDI_STR == (prdi->mask & RDI_STR) )
        {
            hr = m_piResultData->GetViewMode(&lViewMode);
            EXCEPTION_CHECK_GO(hr);

            if ( (0 == prdi->nCol) &&
                 (MMCLV_VIEWSTYLE_REPORT != lViewMode) &&
                 (MMCLV_VIEWSTYLE_FILTERED != lViewMode) )
            {
                // Not in detail modes, need the display name only
                prdi->str = pScopeItem->GetDisplayNamePtr();
            }
            else
            {
                // In report mode, need one of the columns
                IfFailGo(GetScopeItemDisplayString(pScopeItem, prdi->nCol,
                                                   &prdi->str));
            }
        }
        if ( RDI_IMAGE == (prdi->mask & RDI_IMAGE) )
        {
            IfFailGo(pScopeItem->GetImageIndex(&prdi->nImage));
        }
    }
    else 
    {
        // Display info is requested for a list item. There should definitely be
        // a currently selected scope pane item.

        IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
        pResultView = pSelectedItem->GetResultView();
        IfFalseGo(NULL != pResultView, SID_E_INTERNAL);
        pMMCListView = pResultView->GetListView();
        IfFalseGo(NULL != pMMCListView, SID_E_INTERNAL);

        // Get a CMMCListItem * pointing to the listitem in question
        
        if (!m_fVirtualListView)
        {
            pMMCListItem = reinterpret_cast<CMMCListItem *>(prdi->lParam);
        }
        else
        {
            // A virtual listitem may either be cached or we need to create it
            // and ask the snap-in to initialze its display properties
            
            // If we have a cached list item but its index doesn't match
            // the requested index then release it.

            if (NULL != m_pCachedMMCListItem)
            {
                if (m_pCachedMMCListItem->GetIndex() != prdi->nIndex + 1L)
                {
                    m_pCachedMMCListItem->Release();
                    m_pCachedMMCListItem = NULL;
                }
            }

            // If we don't have a cached list item then create one and
            // fire ResultViews_GetVirtualItemDisplayInfo

            if (NULL == m_pCachedMMCListItem)
            {
                IfFailGo(GetVirtualListItem(prdi->nIndex + 1L, pMMCListView,
                                            FireGetItemDisplayInfo,
                                            &m_pCachedMMCListItem));
            }
            pMMCListItem = m_pCachedMMCListItem;
        }

        if ( RDI_STR == (prdi->mask & RDI_STR) )
        {
            hr = m_piResultData->GetViewMode(&lViewMode);
            EXCEPTION_CHECK_GO(hr);


            if ( (0 == prdi->nCol) && (MMCLV_VIEWSTYLE_REPORT != lViewMode) )
            {
                // Not in report mode, need the item text
                prdi->str = pMMCListItem->GetTextPtr();
            }
            else
            {
                // In report mode, need one of the columns
                IfFailGo(pMMCListItem->GetColumnTextPtr((long)prdi->nCol + 1L,
                                                        &prdi->str));
            }
        }

        if ( RDI_IMAGE == (prdi->mask & RDI_IMAGE) )
        {
            IfFailGo(GetImage(pMMCListItem, &prdi->nImage));
        }
    }

Error:
    RRETURN(hr);
}



STDMETHODIMP CView::CompareObjects
(
    IDataObject *piDataObject1,
    IDataObject *piDataObject2
)
{
    DebugPrintf("IComponent::CompareObjects\r\n");
    RRETURN(m_pSnapIn->CompareObjects(piDataObject1, piDataObject2));
}



//=--------------------------------------------------------------------------=
//                      IExtendControlbar Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::SetControlbar(IControlbar *piControlbar)
{
    HRESULT      hr = S_OK;
    CControlbar *pPrevControlbar = m_pSnapIn->GetCurrentControlbar();
    
    m_pSnapIn->SetCurrentControlbar(m_pControlbar);

    hr = m_pControlbar->SetControlbar(piControlbar);

    m_pSnapIn->SetCurrentControlbar(pPrevControlbar);

    RRETURN(hr);
}


STDMETHODIMP CView::ControlbarNotify
(
    MMC_NOTIFY_TYPE event,
    LPARAM          arg,
    LPARAM          param
)
{
    HRESULT      hr = S_OK;
    CControlbar *pPrevControlbar = m_pSnapIn->GetCurrentControlbar();

    m_pSnapIn->SetCurrentControlbar(m_pControlbar);

    switch (event)
    {
        case MMCN_SELECT:
            hr = m_pControlbar->OnControlbarSelect(
                                         reinterpret_cast<IDataObject *>(param),
                                         (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
            break;

        case MMCN_BTN_CLICK:
            hr = m_pControlbar->OnButtonClick(
                                           reinterpret_cast<IDataObject *>(arg),
                                           static_cast<int>(param));
            break;

        case MMCN_MENU_BTNCLICK:
            hr = m_pControlbar->OnMenuButtonClick(
                                     reinterpret_cast<IDataObject *>(arg),
                                     reinterpret_cast<MENUBUTTONDATA *>(param));
            break;
    }

    m_pSnapIn->SetCurrentControlbar(pPrevControlbar);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                     IExtendControlbarRemote Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CView::MenuButtonClick                            [IExtendControlbarRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject    *piDataObject   [in]  from MMCN_MENU_BTNCLICK
//      int             idCommand      [in]  from MENUBUTTONDATA.idCommand passed
//                                           to the proxy with MMCN_MENU_BTNCLICK
//      POPUP_MENUDEF **ppPopupMenuDef [out] popup menu definition returned here
//                                           so proxy can display it
//
// Output:
//
// Notes:
//
// This function effectively handles MMCN_MENU_BTNCLICK when running
// under a debugging session.
//
// The proxy for IExtendControlbar::ControlbarNotify() will QI for
// IExtendControlbarRemote and call this method when it gets MMCN_MENU_BTNCLICK.
// We fire MMCToolbar_ButtonDropDown and the return an array of menu item
// definitions. The proxy will display the popup menu on the MMC side and then
// call IExtendControlbarRemote::PopupMenuClick() if the user makes a selection.
// (See implementation below in CView::PopupMenuClick()).
//

STDMETHODIMP CView::MenuButtonClick
(
    IDataObject    *piDataObject,
    int             idCommand,
    POPUP_MENUDEF **ppPopupMenuDef
)
{
    HRESULT hr = S_OK;

    m_pSnapIn->SetCurrentControlbar(m_pControlbar);

    hr = m_pControlbar->MenuButtonClick(piDataObject, idCommand, ppPopupMenuDef);

    m_pSnapIn->SetCurrentControlbar(NULL);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CView::PopupMenuClick                             [IExtendControlbarRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject *piDataObject [in] from MMCN_MENU_BTNCLICK
//      UINT         uIDItem      [in] ID of popup menu item selected
//      IUnknown    *punkParam    [in] punk we returned to stub in
//                                     CView::MenuButtonClick() (see above).
//                                     This is IUnknown on CMMCButton.
//
// Output:
//
// Notes:
//
// This function effectively handles a popup menu selection for a menu button
// when running under a debugging session.
//
// After the proxy for IExtendControlbar::ControlbarNotify() has displayed
// a popup menu on our behalf, if the user made a selection it will call this
// method. See CView::MenuButtonClick() above for more info.
//

STDMETHODIMP CView::PopupMenuClick
(
    IDataObject *piDataObject,
    UINT         uiIDItem,
    IUnknown    *punkParam
)
{
    HRESULT hr = S_OK;

    m_pSnapIn->SetCurrentControlbar(m_pControlbar);

    hr = m_pControlbar->PopupMenuClick(piDataObject, uiIDItem, punkParam);

    m_pSnapIn->SetCurrentControlbar(NULL);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      IExtendContextMenu Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::AddMenuItems
(
    IDataObject          *piDataObject,
    IContextMenuCallback *piContextMenuCallback,
    long                 *plInsertionAllowed
)
{
    RRETURN(m_pContextMenu->AddMenuItems(piDataObject,
                                         piContextMenuCallback,
                                         plInsertionAllowed,
                                         m_pScopePaneItems->GetSelectedItem()));
}


STDMETHODIMP CView::Command
(
    long         lCommandID,
    IDataObject *piDataObject
)
{
    RRETURN(m_pContextMenu->Command(lCommandID, piDataObject,
                                    m_pScopePaneItems->GetSelectedItem()));
}


//=--------------------------------------------------------------------------=
//                    IExtendPropertySheet2 Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::CreatePropertyPages
(
    IPropertySheetCallback *piPropertySheetCallback,
    LONG_PTR                handle,
    IDataObject            *piDataObject
)
{
    RRETURN(InternalCreatePropertyPages(piPropertySheetCallback, handle,
                                        piDataObject, NULL));
}



STDMETHODIMP CView::QueryPagesFor(IDataObject *piDataObject)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    VARIANT_BOOL    fvarHavePages = VARIANT_FALSE;
    IMMCClipboard  *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    m_pSnapIn->GetViews()->FireQueryPagesFor(static_cast<IView *>(this),
                                             piMMCClipboard,
                                             &fvarHavePages);

    if (VARIANT_TRUE == fvarHavePages)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




STDMETHODIMP CView::GetWatermarks
(
    IDataObject *piDataObject,
    HBITMAP     *phbmWatermark,
    HBITMAP     *phbmHeader,
    HPALETTE    *phPalette,
    BOOL        *bStretch
)
{
    *phbmWatermark = NULL;
    *phbmHeader = NULL;
    *phPalette = NULL;
    *bStretch = FALSE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
//                    IExtendPropertySheetRemote Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::CreatePropertyPageDefs
(
    IDataObject         *piDataObject,
    WIRE_PROPERTYPAGES **ppPages
)
{
    RRETURN(InternalCreatePropertyPages(NULL, NULL, piDataObject, ppPages));
}

//=--------------------------------------------------------------------------=
//                         IExtendTaskPad Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::TaskNotify
(
    IDataObject *piDataObject,
    VARIANT     *arg,
    VARIANT     *param
)
{
    HRESULT                       hr = S_OK;
    IMMCClipboard                *piMMCClipboard = NULL;
    SnapInSelectionTypeConstants  SelectionType = siEmpty;

    // Get a clipboard object with the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    if (IsForeign(SelectionType))
    {
        IfFailGo(OnExtensionTaskNotify(piMMCClipboard, arg, param));
    }
    else
    {
        IfFailGo(OnPrimaryTaskNotify(arg, param));
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




STDMETHODIMP CView::EnumTasks
(
    IDataObject  *piDataObject,
    LPOLESTR      pwszTaskGroup,
    IEnumTASK   **ppEnumTASK
)
{
    HRESULT         hr = S_OK;
    IUnknown       *punkEnumTask = CEnumTask::Create(NULL);
    CEnumTask      *pEnumTask = NULL;
    IMMCClipboard  *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    *ppEnumTASK = NULL;

    // Make sure we created the enumerator and get a C++ pointer for it

    if (NULL == punkEnumTask)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkEnumTask, &pEnumTask));

    // Get a clipboard object with the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    ASSERT(IsSingle(SelectionType), "IExtendTaskpad::EnumTasks received multiple selection. This should never happen");

    // If it is a foreign data object then this snap-in is running as a taskpad
    // extension. Taskpad extensions work differently than other extensions
    // because they are QIed for IComponentData and
    // IComponentData::CreateComponent is called. The component object is then
    // QIed for IExtendTaskpad.

    if (IsForeign(SelectionType))
    {
        IfFailGo(EnumExtensionTasks(piMMCClipboard, pwszTaskGroup, pEnumTask));
    }
    else
    {
        IfFailGo(EnumPrimaryTasks(pEnumTask));
    }

    pEnumTask->SetSnapIn(m_pSnapIn);

    IfFailGo(punkEnumTask->QueryInterface(IID_IEnumTASK,
                                        reinterpret_cast<void **>(ppEnumTASK)));

Error:
    QUICK_RELEASE(punkEnumTask);
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




STDMETHODIMP CView::GetTitle
(
    LPOLESTR pwszGroup,
    LPOLESTR *ppwszTitle
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    ITaskpad       *piTaskpad = NULL;
    BSTR            bstrTitle = NULL;

    *ppwszTitle = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_Title(&bstrTitle));
    IfFailGo(::CoTaskMemAllocString(bstrTitle, ppwszTitle));

Error:
    QUICK_RELEASE(piTaskpad);
    FREESTRING(bstrTitle);
    RRETURN(hr);
}



STDMETHODIMP CView::GetDescriptiveText
(
    LPOLESTR  pwszGroup,
    LPOLESTR *ppwszDescriptiveText
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    ITaskpad       *piTaskpad = NULL;
    BSTR            bstrText = NULL;

    *ppwszDescriptiveText = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_DescriptiveText(&bstrText));
    IfFailGo(::CoTaskMemAllocString(bstrText, ppwszDescriptiveText));

Error:
    QUICK_RELEASE(piTaskpad);
    FREESTRING(bstrText);
    RRETURN(hr);
}



STDMETHODIMP CView::GetBackground
(
    LPOLESTR                 pwszGroup,
    MMC_TASK_DISPLAY_OBJECT *pTDO
)
{
    HRESULT                          hr = S_OK;
    CScopePaneItem                  *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView                     *pResultView = NULL;
    ITaskpad                        *piTaskpad = NULL;
    SnapInTaskpadImageTypeConstants  Type = siNoImage;
    BSTR                             bstrURL = NULL;
    BSTR                             bstrFontFamily = NULL;
    BSTR                             bstrSymbolString = NULL;
    BOOL                             fNeedMouseImages = FALSE;

    ::ZeroMemory(pTDO, sizeof(*pTDO));
    pTDO->eDisplayType = MMC_TASK_DISPLAY_UNINITIALIZED;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_BackgroundType(&Type));

    switch (Type)
    {
        case siVanillaGIF:
            pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_VANILLA_GIF;
            fNeedMouseImages = TRUE;
            break;
            
        case siChocolateGIF:
            pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF;
            fNeedMouseImages = TRUE;
            break;

        case siBitmap:
            pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
            fNeedMouseImages = TRUE;
            break;

        case siSymbol:
            pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_SYMBOL;

            IfFailGo(piTaskpad->get_FontFamily(&bstrFontFamily));
            if (ValidBstr(bstrFontFamily))
            {
                IfFailGo(::CoTaskMemAllocString(bstrFontFamily,
                                              &pTDO->uSymbol.szFontFamilyName));
            }

            IfFailGo(piTaskpad->get_EOTFile(&bstrURL));
            if (ValidBstr(bstrURL))
            {
                IfFailGo(m_pSnapIn->ResolveResURL(bstrURL,
                                                  &pTDO->uSymbol.szURLtoEOT));
                FREESTRING(bstrURL);
            }

            IfFailGo(piTaskpad->get_SymbolString(&bstrSymbolString));
            if (ValidBstr(bstrSymbolString))
            {
                IfFailGo(::CoTaskMemAllocString(bstrSymbolString,
                                                &pTDO->uSymbol.szSymbolString));
            }
            break;

        case siNoImage:
            break;

        default:
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
    }

    if (fNeedMouseImages)
    {
        IfFailGo(piTaskpad->get_MouseOverImage(&bstrURL));
        if (ValidBstr(bstrURL))
        {
            IfFailGo(m_pSnapIn->ResolveResURL(bstrURL,
                                              &pTDO->uBitmap.szMouseOverBitmap));
        }
        FREESTRING(bstrURL);

        IfFailGo(piTaskpad->get_MouseOffImage(&bstrURL));
        if (ValidBstr(bstrURL))
        {
            IfFailGo(m_pSnapIn->ResolveResURL(bstrURL,
                                              &pTDO->uBitmap.szMouseOffBitmap));
        }
    }

Error:
    QUICK_RELEASE(piTaskpad);
    FREESTRING(bstrURL);
    FREESTRING(bstrFontFamily);
    FREESTRING(bstrSymbolString);
    RRETURN(hr);
}



STDMETHODIMP CView::GetListPadInfo
(
    LPOLESTR          pwszGroup,
    MMC_LISTPAD_INFO *pListPadInfo
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    ITaskpad       *piTaskpad = NULL;
    BSTR            bstr = NULL;
    VARIANT_BOOL    fvarListpadHasButton = VARIANT_FALSE;

    ::ZeroMemory(pListPadInfo, sizeof(*pListPadInfo));

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));

    // Get the listpad title

    IfFailGo(piTaskpad->get_ListpadTitle(&bstr));
    IfFailGo(::CoTaskMemAllocString(bstr, &pListPadInfo->szTitle));
    FREESTRING(bstr);

    // Check if the listpad has a button. If so then get the button text.

    IfFailGo(piTaskpad->get_ListpadHasButton(&fvarListpadHasButton));
    if (VARIANT_TRUE == fvarListpadHasButton)
    {
        IfFailGo(piTaskpad->get_ListpadButtonText(&bstr));
        IfFailGo(::CoTaskMemAllocString(bstr, &pListPadInfo->szButtonText));
    }
    else
    {
        pListPadInfo->szButtonText = NULL;
    }

    // Set the command ID to zero so it will not clash with any tasks. Tasks
    // will be added with command IDs matching their colleciton indexes which
    // begin at one.

    pListPadInfo->nCommandID = 0;

Error:
    QUICK_RELEASE(piTaskpad);
    FREESTRING(bstr);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                        IResultOwnerData Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CView::FindItem
(
    RESULTFINDINFO *pFindInfo,
    int            *pnFoundIndex
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    BSTR            bstrName = NULL;
    VARIANT_BOOL    fvarPartial = VARIANT_FALSE;
    VARIANT_BOOL    fvarWrap = VARIANT_FALSE;
    VARIANT_BOOL    fvarFound = VARIANT_FALSE;
    long            lIndex = 0;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    bstrName = ::SysAllocString(pFindInfo->psz);
    if (NULL == bstrName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    if ( (pFindInfo->dwOptions & RFI_PARTIAL) != 0 )
    {
        fvarPartial = VARIANT_TRUE;
    }

    if ( (pFindInfo->dwOptions & RFI_WRAP) != 0 )
    {
        fvarWrap = VARIANT_TRUE;
    }

    m_pSnapIn->GetResultViews()->FireFindItem(
                                       static_cast<IResultView *>(pResultView),
                                       bstrName,
                                       static_cast<long>(pFindInfo->nStart),
                                       fvarWrap,
                                       fvarPartial,
                                       &fvarFound,
                                       &lIndex);

    if ( (VARIANT_TRUE == fvarFound) && (0 != lIndex) )
    {
        // Item was found. Adjust the index from one-based to zero-based.
        hr = S_OK;
        *pnFoundIndex = static_cast<int>(lIndex - 1L);
    }
    else
    {
        hr = S_FALSE;
    }

Error:
    FREESTRING(bstrName);
    RRETURN(hr);
}


STDMETHODIMP CView::CacheHint
(
    int nStartIndex,
    int nEndIndex
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);


    m_pSnapIn->GetResultViews()->FireCacheHint(
                                         static_cast<IResultView *>(pResultView),
                                         static_cast<long>(nStartIndex + 1),
                                         static_cast<long>(nEndIndex + 1));

Error:
    RRETURN(hr);
}


STDMETHODIMP CView::SortItems
(
    int    nColumn,
    DWORD  dwSortOptions,
    LPARAM lUserParam
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;

    SnapInSortOrderConstants Order = siAscending;

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    if ( (dwSortOptions & RSI_DESCENDING) != 0 )
    {
        Order = siDescending;
    }

    m_pSnapIn->GetResultViews()->FireSortItems(
                                         static_cast<IResultView *>(pResultView),
                                         static_cast<long>(nColumn),
                                         Order);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                        IResultDataCompare Methods
//=--------------------------------------------------------------------------=



STDMETHODIMP CView::Compare
(
    LPARAM      lUserParam,
    MMC_COOKIE  cookieA,
    MMC_COOKIE  cookieB,
    int        *pnResult
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    CMMCListItem   *pMMCListItem1 = reinterpret_cast<CMMCListItem *>(cookieA);
    CMMCListItem   *pMMCListItem2 = reinterpret_cast<CMMCListItem *>(cookieB);
    IDispatch      *pdispListItem1 = NULL;
    IDispatch      *pdispListItem2 = NULL;
    OLECHAR        *pwszText1 = NULL;
    OLECHAR        *pwszText2 = NULL;
    long            lColumn = static_cast<long>(*pnResult) + 1L;
    long            lResult = 0;

    VARIANT varResult;
    ::VariantInit(&varResult);

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    IfFailGo(pMMCListItem1->QueryInterface(IID_IDispatch,
                                  reinterpret_cast<void **>(&pdispListItem1)));

    IfFailGo(pMMCListItem2->QueryInterface(IID_IDispatch,
                                  reinterpret_cast<void **>(&pdispListItem2)));

    // Fire ResultViews_CompareItems
            
    m_pSnapIn->GetResultViews()->FireCompareItems(
                                      static_cast<IResultView *>(pResultView),
                                      pdispListItem1,
                                      pdispListItem2,
                                      lColumn,
                                      &varResult);

    if (::ConvertToLong(varResult, &lResult) == S_OK)
    {
        *pnResult = static_cast<int>(lResult);
    }
    else
    {
        // The snap-in did not handle the event. We need to do a
        // case-insensitive string comparison on the specified column.

        IfFailGo(pMMCListItem1->GetColumnTextPtr(lColumn, &pwszText1));

        IfFailGo(pMMCListItem2->GetColumnTextPtr(lColumn, &pwszText2));

        *pnResult = ::_wcsicmp(pwszText1, pwszText2);
    }

Error:
    QUICK_RELEASE(pdispListItem1);
    QUICK_RELEASE(pdispListItem2);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                       IResultDataCompareEx Methods
//=--------------------------------------------------------------------------=



STDMETHODIMP CView::Compare
(
    RDCOMPARE *prdc,
    int       *pnResult
)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelectedItem = m_pScopePaneItems->GetSelectedItem();
    CResultView    *pResultView = NULL;
    long            lColumn = static_cast<long>(prdc->nColumn) + 1L;
    long            lResult = 0;

    CMMCListItem   *pMMCListItem1 = NULL;
    CMMCListItem   *pMMCListItem2 = NULL;

    CScopeItem     *pScopeItem1 = NULL;
    CScopeItem     *pScopeItem2 = NULL;

    IDispatch      *pdispItem1 = NULL;
    IDispatch      *pdispItem2 = NULL;

    OLECHAR        *pwszText1 = NULL;
    OLECHAR        *pwszText2 = NULL;

    VARIANT varResult;
    ::VariantInit(&varResult);

    IfFalseGo(NULL != pSelectedItem, SID_E_INTERNAL);
    pResultView = pSelectedItem->GetResultView();
    IfFalseGo(NULL != pResultView, SID_E_INTERNAL);

    // Get an IDispatch on each object being compared

    IfFailGo(GetCompareObject(prdc->prdch1, &pScopeItem1, &pMMCListItem1,
                              &pdispItem1));

    IfFailGo(GetCompareObject(prdc->prdch2, &pScopeItem2, &pMMCListItem2,
                              &pdispItem2));

    // Fire ResultViews_CompareItems

    m_pSnapIn->GetResultViews()->FireCompareItems(
                                      static_cast<IResultView *>(pResultView),
                                      pdispItem1,
                                      pdispItem2,
                                      lColumn,
                                      &varResult);

    // If the result can be converted to a long then the snap-in handled
    // the event.
    
    if (::ConvertToLong(varResult, &lResult) == S_OK)
    {
        *pnResult = static_cast<int>(lResult);
    }
    else
    {
        // The snap-in did not handle the event. We need to do a
        // case-insensitive string comparison on the specified column.

        if (NULL != pScopeItem1)
        {
            IfFailGo(GetScopeItemDisplayString(pScopeItem1,
                                               prdc->nColumn,
                                               &pwszText1));
        }
        else
        {
            IfFailGo(pMMCListItem1->GetColumnTextPtr(lColumn, &pwszText1));
        }

        if (NULL != pScopeItem2)
        {
            IfFailGo(GetScopeItemDisplayString(pScopeItem2,
                                               prdc->nColumn,
                                               &pwszText2));
        }
        else
        {
            IfFailGo(pMMCListItem2->GetColumnTextPtr(lColumn, &pwszText2));
        }

        *pnResult = ::_wcsicmp(pwszText1, pwszText2);
    }

Error:
    QUICK_RELEASE(pdispItem1);
    QUICK_RELEASE(pdispItem2);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                    IPersistStreamInit Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CView::GetClassID(CLSID *pClsid)
{
    return E_NOTIMPL;
}


STDMETHODIMP CView::InitNew()
{
    return S_OK;
}

STDMETHODIMP CView::Load(IStream *piStream)
{
    HRESULT       hr = S_OK;
    _PropertyBag *p_PropertyBag = NULL;

    IfFailGo(::PropertyBagFromStream(piStream, &p_PropertyBag));

    // Fire Views_ReadProperties

    m_pSnapIn->GetViews()->FireReadProperties(this, p_PropertyBag);

Error:
    QUICK_RELEASE(p_PropertyBag);
    RRETURN(hr);
}



STDMETHODIMP CView::Save(IStream *piStream, BOOL fClearDirty)
{
    HRESULT       hr = S_OK;
    _PropertyBag *p_PropertyBag = NULL;

    VARIANT var;
    ::VariantInit(&var);

    // Create a property bag, fire the event, and save it to the stream.

    // Create a VBPropertyBag object

    hr = ::CoCreateInstance(CLSID_PropertyBag,
                            NULL, // no aggregation
                            CLSCTX_INPROC_SERVER,
                            IID__PropertyBag,
                            reinterpret_cast<void **>(&p_PropertyBag));
    EXCEPTION_CHECK_GO(hr);

    // Fire Views_WriteProperties

    m_pSnapIn->GetViews()->FireWriteProperties(this, p_PropertyBag);

    // Get the stream contents in a SafeArray of Byte

    IfFailGo(p_PropertyBag->get_Contents(&var));

    // Write the SafeArray contents to the stream

    IfFailGo(::WriteSafeArrayToStream(var.parray, piStream, WriteLength));

Error:
    (void)::VariantClear(&var);
    QUICK_RELEASE(p_PropertyBag);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CView::IsDirty                         [IPersistStream, IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      None
//
// Output:
//      HRESULT
//
// Notes:
//
// The designer object model does not have any way for a snap-in to indicate
// that a view is dirty. This was an oversight discovered too late in the
// product cycle. There should have been a property View.Changed to control
// the return value from this function.
//
// To avoid a situation where a snap-in needs to save something we always return
// S_OK to indicate that the view is dirty and should be saved. The only
// problem this may cause is that when a console is opened in author mode and
// the user does not do anything that requires a save (e.g. selected a node
// in the scope pane) then they will be prompted to save unnecessarily.
//
STDMETHODIMP CView::IsDirty()
{
    return S_OK;
}


STDMETHODIMP CView::GetSizeMax(ULARGE_INTEGER* puliSize)
{
    return E_NOTIMPL;
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CView::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IView == riid)
    {
        *ppvObjOut = static_cast<IView *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IComponent == riid)
    {
        *ppvObjOut = static_cast<IComponent *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendControlbar == riid)
    {
        *ppvObjOut = static_cast<IExtendControlbar *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendControlbarRemote == riid)
    {
        *ppvObjOut = static_cast<IExtendControlbarRemote *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendContextMenu == riid)
    {
        *ppvObjOut = static_cast<IExtendContextMenu *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if ( (IID_IExtendPropertySheet  == riid) ||
              (IID_IExtendPropertySheet2 == riid) )
    {
        *ppvObjOut = static_cast<IExtendPropertySheet2 *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendPropertySheetRemote == riid)
    {
        *ppvObjOut = static_cast<IExtendPropertySheetRemote *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendTaskPad == riid)
    {
        *ppvObjOut = static_cast<IExtendTaskPad *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IResultOwnerData == riid)
    {
        *ppvObjOut = static_cast<IResultOwnerData *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IResultDataCompare == riid)
    {
        *ppvObjOut = static_cast<IResultDataCompare *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IResultDataCompareEx == riid)
    {
        *ppvObjOut = static_cast<IResultDataCompareEx *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IPersistStream == riid)
    {
        *ppvObjOut = static_cast<IPersistStream *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IPersistStreamInit == riid)
    {
        *ppvObjOut = static_cast<IPersistStreamInit *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}


//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CView::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piScopePaneItems));
    IfFailRet(SetObjectHost(static_cast<IContextMenu *>(m_pContextMenu)));
    IfFailRet(SetObjectHost(static_cast<IMMCControlbar *>(m_pControlbar)));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\views.h ===
//=--------------------------------------------------------------------------=
// views.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CViews class definition - implements Views collection
//
//=--------------------------------------------------------------------------=

#ifndef _VIEWS_DEFINED_
#define _VIEWS_DEFINED_

#include "collect.h"

class CViews : public CSnapInCollection<IView, View, IViews>
{
    protected:
        CViews(IUnknown *punkOuter);
        ~CViews();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IViews
        COCLASS_PROPERTY_RO(CViews, CurrentView, View, IView, DISPID_VIEWS_CURRENT_VIEW);

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    public:
        void SetCurrentView(IView *piView);

        HRESULT SetNextViewCaption(BSTR bstrCaption);
        BSTR GetNextViewCaptionPtr() { return m_bstrNextViewCaption; }

        void FireInitialize(IView *piView);
        void FireLoad(IView *piView);
        void FireTerminate(IView *piView);
        void FireActivate(IView *piView);
        void FireDeactivate(IView *piView);
        void FireMinimize(IView *piView);
        void FireMaximize(IView *piView);
        void FireSetControlbar(IView *piView, IMMCControlbar *piMMCControlbar);
        void FireUpdateControlbar(IView          *piView,
                                  IMMCClipboard  *piMMClipboard,
                                  VARIANT_BOOL    fvarSelected,
                                  IMMCControlbar *piMMCControlbar);
        void FireSelect(IView            *piView,
                        IMMCClipboard    *piSelection,
                        VARIANT_BOOL      fVarSelected,
                        IMMCConsoleVerbs *piMMCConsoleVerbs);
        void FireAddTopMenuItems(IView         *piView,
                                 IMMCClipboard *piSelection,
                                 IContextMenu  *piContextMenu,
                                 VARIANT_BOOL  *pfvarInsertionAllowed);
        void FireAddNewMenuItems(IView         *piView,
                                 IMMCClipboard *piSelection,
                                 IContextMenu  *piContextMenu,
                                 VARIANT_BOOL  *pfvarInsertionAllowed);
        void FireAddTaskMenuItems(IView         *piView,
                                  IMMCClipboard *piSelection,
                                  IContextMenu  *piContextMenu,
                                  VARIANT_BOOL  *pfvarInsertionAllowed);
        void FireAddViewMenuItems(IView         *piView,
                                  IMMCClipboard *piSelection,
                                  IContextMenu  *piContextMenu,
                                  VARIANT_BOOL  *pfvarInsertionAllowed,
                                  VARIANT_BOOL  *pfvarAddPredefinedViews);
        void FireGetMultiSelectData(IView          *piView,
                                    IMMCClipboard  *piSelection,
                                    IMMCDataObject *piMMCDataObject);
        void FireQueryPaste(IView         *piView,
                            IMMCClipboard *piSourceItems,
                            IScopeItem    *piScopeItemDest,
                            VARIANT_BOOL  *pfvarOKToPaste);
        void FirePaste(IView          *piView,
                       IMMCClipboard  *piSourceItems,
                       IScopeItem     *piScopeItemDest,
                       IMMCDataObject *piMMCDataObjectRetToSource,
                       VARIANT_BOOL    fvarMove);
        void FireCut(IView          *piView,
                     IMMCClipboard  *piItemsPasted,
                     IMMCDataObject *piMMCDataObjectFromTarget);
        void FireDelete(IView *piView, IMMCClipboard *piSelection);
        void FireQueryPagesFor(IView         *piView,
                               IMMCClipboard *piSelection,
                               VARIANT_BOOL  *pfvarHavePages);

        void FireCreatePropertyPages(IView             *piView,
                                     IMMCClipboard     *piSelection,
                                     IMMCPropertySheet *piMMCPropertySheet);
        void FireRefresh(IView *piView, IMMCClipboard *piSelection);
        void FirePrint(IView *piView, IMMCClipboard *piSelection);
        void FireSpecialPropertiesClick(IView                        *piView,
                                        SnapInSelectionTypeConstants  ResultViewType);

        void FireWriteProperties(IView *piView, _PropertyBag *p_PropertyBag);
        void FireReadProperties(IView *piView, _PropertyBag *p_PropertyBag);

    private:

        void InitMemberVariables();

        // When the snap calls View.NewWindow and specifies siCaption, then
        // the caption is stored here. When the new view is created, it can
        // respond to CCF_WINDOW_TITLE requests from this string.

        BSTR m_bstrNextViewCaption;

        // Event Parameter definitions

        static VARTYPE   m_rgvtInitialize[1];
        static EVENTINFO m_eiInitialize;

        static VARTYPE   m_rgvtLoad[1];
        static EVENTINFO m_eiLoad;

        static VARTYPE   m_rgvtTerminate[1];
        static EVENTINFO m_eiTerminate;

        static VARTYPE   m_rgvtActivate[1];
        static EVENTINFO m_eiActivate;

        static VARTYPE   m_rgvtDeactivate[1];
        static EVENTINFO m_eiDeactivate;

        static VARTYPE   m_rgvtMinimize[1];
        static EVENTINFO m_eiMinimize;

        static VARTYPE   m_rgvtMaximize[1];
        static EVENTINFO m_eiMaximize;

        static VARTYPE   m_rgvtSetControlbar[2];
        static EVENTINFO m_eiSetControlbar;

        static VARTYPE   m_rgvtUpdateControlbar[4];
        static EVENTINFO m_eiUpdateControlbar;

        static VARTYPE   m_rgvtSelect[4];
        static EVENTINFO m_eiSelect;

        static VARTYPE   m_rgvtAddTopMenuItems[4];
        static EVENTINFO m_eiAddTopMenuItems;

        static VARTYPE   m_rgvtAddNewMenuItems[4];
        static EVENTINFO m_eiAddNewMenuItems;

        static VARTYPE   m_rgvtAddTaskMenuItems[4];
        static EVENTINFO m_eiAddTaskMenuItems;

        static VARTYPE   m_rgvtAddViewMenuItems[5];
        static EVENTINFO m_eiAddViewMenuItems;

        static VARTYPE   m_rgvtGetMultiSelectData[3];
        static EVENTINFO m_eiGetMultiSelectData;

        static VARTYPE   m_rgvtQueryPaste[4];
        static EVENTINFO m_eiQueryPaste;

        static VARTYPE   m_rgvtPaste[5];
        static EVENTINFO m_eiPaste;

        static VARTYPE   m_rgvtCut[3];
        static EVENTINFO m_eiCut;

        static VARTYPE   m_rgvtDelete[2];
        static EVENTINFO m_eiDelete;

        static VARTYPE   m_rgvtQueryPagesFor[3];
        static EVENTINFO m_eiQueryPagesFor;

        static VARTYPE   m_rgvtCreatePropertyPages[3];
        static EVENTINFO m_eiCreatePropertyPages;

        static VARTYPE   m_rgvtRefresh[2];
        static EVENTINFO m_eiRefresh;

        static VARTYPE   m_rgvtPrint[2];
        static EVENTINFO m_eiPrint;

        static VARTYPE   m_rgvtSpecialPropertiesClick[2];
        static EVENTINFO m_eiSpecialPropertiesClick;

        static VARTYPE   m_rgvtWriteProperties[2];
        static EVENTINFO m_eiWriteProperties;

        static VARTYPE   m_rgvtReadProperties[2];
        static EVENTINFO m_eiReadProperties;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Views,                     // name
                                NULL,                      // clsid
                                "Views",                   // objname
                                "Views",                   // lblname
                                NULL,                      // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IViews,               // dispatch IID
                                &DIID_DViewsEvents,        // no events IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _VIEWS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\viewdefs.h ===
//=--------------------------------------------------------------------------=
// viewdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CViewDefs class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _VIEWDEFS_DEFINED_
#define _VIEWDEFS_DEFINED_


class CViewDefs : public CSnapInAutomationObject,
                  public CPersistence,
                  public IViewDefs
{
    private:
        CViewDefs(IUnknown *punkOuter);
        ~CViewDefs();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IViewDefs

        OBJECT_PROPERTY_RO(CViewDefs, ListViews, IListViewDefs, DISPID_VIEWDEFS_LIST_VIEWS);
        OBJECT_PROPERTY_RO(CViewDefs, OCXViews, IOCXViewDefs, DISPID_VIEWDEFS_OCX_VIEWS);
        OBJECT_PROPERTY_RO(CViewDefs, URLViews, IURLViewDefs, DISPID_VIEWDEFS_URL_VIEWS);
        OBJECT_PROPERTY_RO(CViewDefs, TaskpadViews, ITaskpadViewDefs, DISPID_VIEWDEFS_TASKPAD_VIEWS);
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();
        virtual HRESULT OnKeysOnly();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ViewDefs,              // name
                                &CLSID_ViewDefs,       // clsid
                                "ViewDefs",            // objname
                                "ViewDefs",            // lblname
                                &CViewDefs::Create,    // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IViewDefs,        // dispatch IID
                                NULL,                  // no events IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _VIEWDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\viewdefs.cpp ===
//=--------------------------------------------------------------------------=
// viewdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CViewDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "viewdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CViewDefs::CViewDefs(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_VIEWDEFS,
                            static_cast<IViewDefs *>(this),
                            static_cast<CViewDefs *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ViewDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CViewDefs::~CViewDefs()
{
    RELEASE(m_piListViews);
    RELEASE(m_piOCXViews);
    RELEASE(m_piURLViews);
    RELEASE(m_piTaskpadViews);
    InitMemberVariables();
}

void CViewDefs::InitMemberVariables()
{
    m_piListViews = NULL;
    m_piOCXViews = NULL;
    m_piURLViews = NULL;
    m_piTaskpadViews = NULL;
}

IUnknown *CViewDefs::Create(IUnknown * punkOuter)
{
    CViewDefs *pViewDefs = New CViewDefs(punkOuter);
    if (NULL == pViewDefs)
    {
        return NULL;
    }
    else
    {
        return pViewDefs->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CViewDefs::Persist()
{
    HRESULT hr = S_OK;

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistObject(&m_piListViews, CLSID_ListViewDefs,
                           OBJECT_TYPE_LISTVIEWDEFS, IID_IListViewDefs,
                           OLESTR("ListViews")));

    IfFailGo(PersistObject(&m_piOCXViews, CLSID_OCXViewDefs,
                           OBJECT_TYPE_OCXVIEWDEFS, IID_IOCXViewDefs,
                           OLESTR("OCXViews")));

    IfFailGo(PersistObject(&m_piURLViews, CLSID_URLViewDefs,
                           OBJECT_TYPE_URLVIEWDEFS, IID_IURLViewDefs,
                           OLESTR("URLViews")));

    IfFailGo(PersistObject(&m_piTaskpadViews, CLSID_TaskpadViewDefs,
                           OBJECT_TYPE_TASKPADVIEWDEFS, IID_ITaskpadViewDefs,
                           OLESTR("TaskpadViews")));
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CViewDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IViewDefs == riid)
    {
        *ppvObjOut = static_cast<IViewDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CViewDefs::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piListViews));
    IfFailRet(SetObjectHost(m_piOCXViews));
    IfFailRet(SetObjectHost(m_piURLViews));
    IfFailRet(SetObjectHost(m_piTaskpadViews));

    return S_OK;
}

HRESULT CViewDefs::OnKeysOnly()
{
    HRESULT hr = S_OK;

    IfFailRet(UseKeysOnly(m_piListViews));
    IfFailRet(UseKeysOnly(m_piOCXViews));
    IfFailRet(UseKeysOnly(m_piURLViews));
    IfFailRet(UseKeysOnly(m_piTaskpadViews));

    return S_OK;;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\views.cpp ===
//=--------------------------------------------------------------------------=
// views.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtendedSnapIns class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "views.h"
#include "scopitem.h"

// for ASSERT and FAIL
//
SZTHISFILE

VARTYPE CViews::m_rgvtInitialize[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiInitialize =
{
    DISPID_VIEWS_EVENT_INITIALIZE,
    sizeof(m_rgvtInitialize) / sizeof(m_rgvtInitialize[0]),
    m_rgvtInitialize
};

VARTYPE CViews::m_rgvtLoad[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiLoad =
{
    DISPID_VIEWS_EVENT_LOAD,
    sizeof(m_rgvtLoad) / sizeof(m_rgvtLoad[0]),
    m_rgvtLoad
};

VARTYPE CViews::m_rgvtTerminate[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiTerminate =
{
    DISPID_VIEWS_EVENT_TERMINATE,
    sizeof(m_rgvtTerminate) / sizeof(m_rgvtTerminate[0]),
    m_rgvtTerminate
};


VARTYPE CViews::m_rgvtActivate[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiActivate =
{
    DISPID_VIEWS_EVENT_ACTIVATE,
    sizeof(m_rgvtActivate) / sizeof(m_rgvtActivate[0]),
    m_rgvtActivate
};

VARTYPE CViews::m_rgvtDeactivate[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiDeactivate =
{
    DISPID_VIEWS_EVENT_DEACTIVATE,
    sizeof(m_rgvtDeactivate) / sizeof(m_rgvtDeactivate[0]),
    m_rgvtDeactivate
};


VARTYPE CViews::m_rgvtMinimize[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiMinimize =
{
    DISPID_VIEWS_EVENT_MINIMIZE,
    sizeof(m_rgvtMinimize) / sizeof(m_rgvtMinimize[0]),
    m_rgvtMinimize
};

VARTYPE CViews::m_rgvtMaximize[1] = { VT_UNKNOWN };

EVENTINFO CViews::m_eiMaximize =
{
    DISPID_VIEWS_EVENT_MAXIMIZE,
    sizeof(m_rgvtMaximize) / sizeof(m_rgvtMaximize[0]),
    m_rgvtMaximize
};


VARTYPE CViews::m_rgvtSetControlbar[2] = { VT_UNKNOWN, VT_UNKNOWN };

EVENTINFO CViews::m_eiSetControlbar =
{
    DISPID_VIEWS_EVENT_SET_CONTROL_BAR,
    sizeof(m_rgvtSetControlbar) / sizeof(m_rgvtSetControlbar[0]),
    m_rgvtSetControlbar
};


VARTYPE CViews::m_rgvtUpdateControlbar[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiUpdateControlbar =
{
    DISPID_VIEWS_EVENT_UPDATE_CONTROLBAR,
    sizeof(m_rgvtUpdateControlbar) / sizeof(m_rgvtUpdateControlbar[0]),
    m_rgvtUpdateControlbar
};


VARTYPE CViews::m_rgvtSelect[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiSelect =
{
    DISPID_VIEWS_EVENT_SELECT,
    sizeof(m_rgvtSelect) / sizeof(m_rgvtSelect[0]),
    m_rgvtSelect
};


VARTYPE CViews::m_rgvtAddTopMenuItems[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF
};

EVENTINFO CViews::m_eiAddTopMenuItems =
{
    DISPID_VIEWS_EVENT_ADD_TOP_MENU_ITEMS,
    sizeof(m_rgvtAddTopMenuItems) / sizeof(m_rgvtAddTopMenuItems[0]),
    m_rgvtAddTopMenuItems
};


VARTYPE CViews::m_rgvtAddNewMenuItems[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF
};

EVENTINFO CViews::m_eiAddNewMenuItems =
{
    DISPID_VIEWS_EVENT_ADD_NEW_MENU_ITEMS,
    sizeof(m_rgvtAddNewMenuItems) / sizeof(m_rgvtAddNewMenuItems[0]),
    m_rgvtAddNewMenuItems
};


VARTYPE CViews::m_rgvtAddTaskMenuItems[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF
};

EVENTINFO CViews::m_eiAddTaskMenuItems =
{
    DISPID_VIEWS_EVENT_ADD_TASK_MENU_ITEMS,
    sizeof(m_rgvtAddTaskMenuItems) / sizeof(m_rgvtAddTaskMenuItems[0]),
    m_rgvtAddTaskMenuItems
};

VARTYPE CViews::m_rgvtAddViewMenuItems[5] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF,
    VT_BOOL | VT_BYREF
};

EVENTINFO CViews::m_eiAddViewMenuItems =
{
    DISPID_VIEWS_EVENT_ADD_VIEW_MENU_ITEMS,
    sizeof(m_rgvtAddViewMenuItems) / sizeof(m_rgvtAddViewMenuItems[0]),
    m_rgvtAddViewMenuItems
};


VARTYPE CViews::m_rgvtGetMultiSelectData[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiGetMultiSelectData =
{
    DISPID_VIEWS_EVENT_GET_MULTISELECT_DATA,
    sizeof(m_rgvtGetMultiSelectData) / sizeof(m_rgvtGetMultiSelectData[0]),
    m_rgvtGetMultiSelectData
};



VARTYPE CViews::m_rgvtQueryPaste[4] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF
};

EVENTINFO CViews::m_eiQueryPaste =
{
    DISPID_VIEWS_EVENT_QUERY_PASTE,
    sizeof(m_rgvtQueryPaste) / sizeof(m_rgvtQueryPaste[0]),
    m_rgvtQueryPaste
};

VARTYPE CViews::m_rgvtPaste[5] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BOOL
};

EVENTINFO CViews::m_eiPaste =
{
    DISPID_VIEWS_EVENT_PASTE,
    sizeof(m_rgvtPaste) / sizeof(m_rgvtPaste[0]),
    m_rgvtPaste
};


VARTYPE CViews::m_rgvtCut[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiCut =
{
    DISPID_VIEWS_EVENT_CUT,
    sizeof(m_rgvtCut) / sizeof(m_rgvtCut[0]),
    m_rgvtCut
};


VARTYPE CViews::m_rgvtDelete[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiDelete =
{
    DISPID_VIEWS_EVENT_DELETE,
    sizeof(m_rgvtDelete) / sizeof(m_rgvtDelete[0]),
    m_rgvtDelete
};


VARTYPE CViews::m_rgvtQueryPagesFor[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BYREF | VT_BOOL
};

EVENTINFO CViews::m_eiQueryPagesFor =
{
    DISPID_VIEWS_EVENT_QUERY_PAGES_FOR,
    sizeof(m_rgvtQueryPagesFor) / sizeof(m_rgvtQueryPagesFor[0]),
    m_rgvtQueryPagesFor
};


VARTYPE CViews::m_rgvtCreatePropertyPages[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiCreatePropertyPages =
{
    DISPID_VIEWS_EVENT_CREATE_PROPERTY_PAGES,
    sizeof(m_rgvtCreatePropertyPages) / sizeof(m_rgvtCreatePropertyPages[0]),
    m_rgvtCreatePropertyPages
};


VARTYPE CViews::m_rgvtRefresh[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiRefresh =
{
    DISPID_VIEWS_EVENT_REFRESH,
    sizeof(m_rgvtRefresh) / sizeof(m_rgvtRefresh[0]),
    m_rgvtRefresh
};



VARTYPE CViews::m_rgvtPrint[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CViews::m_eiPrint =
{
    DISPID_VIEWS_EVENT_PRINT,
    sizeof(m_rgvtPrint) / sizeof(m_rgvtPrint[0]),
    m_rgvtPrint
};


VARTYPE CViews::m_rgvtSpecialPropertiesClick[2] =
{
    VT_UNKNOWN,
    VT_I4
};

EVENTINFO CViews::m_eiSpecialPropertiesClick =
{
    DISPID_VIEWS_EVENT_SPECIAL_PROPERTIES_CLICK,
    sizeof(m_rgvtSpecialPropertiesClick) / sizeof(m_rgvtSpecialPropertiesClick[0]),
    m_rgvtSpecialPropertiesClick
};


VARTYPE CViews::m_rgvtWriteProperties[2] =
{
    VT_UNKNOWN,
    VT_DISPATCH
};

EVENTINFO CViews::m_eiWriteProperties =
{
    DISPID_VIEWS_EVENT_WRITE_PROPERTIES,
    sizeof(m_rgvtWriteProperties) / sizeof(m_rgvtWriteProperties[0]),
    m_rgvtWriteProperties
};


VARTYPE CViews::m_rgvtReadProperties[2] =
{
    VT_UNKNOWN,
    VT_DISPATCH
};

EVENTINFO CViews::m_eiReadProperties =
{
    DISPID_VIEWS_EVENT_READ_PROPERTIES,
    sizeof(m_rgvtReadProperties) / sizeof(m_rgvtReadProperties[0]),
    m_rgvtReadProperties
};



   
#pragma warning(disable:4355)  // using 'this' in constructor

CViews::CViews(IUnknown *punkOuter) :
    CSnapInCollection<IView, View, IViews>(punkOuter,
                                           OBJECT_TYPE_VIEWS,
                                           static_cast<IViews *>(this),
                                           static_cast<CViews *>(this),
                                           CLSID_View,
                                           OBJECT_TYPE_VIEW,
                                           IID_IView,
                                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CViews::~CViews()
{
    RELEASE(m_piCurrentView);
    FREESTRING(m_bstrNextViewCaption);
    InitMemberVariables();
}


void CViews::InitMemberVariables()
{
    m_piCurrentView = NULL;
    m_bstrNextViewCaption = NULL;
}



IUnknown *CViews::Create(IUnknown * punkOuter)
{
    CViews *pViews = New CViews(punkOuter);
    if (NULL == pViews)
    {
        return NULL;
    }
    else
    {
        return pViews->PrivateUnknown();
    }
}


void CViews::SetCurrentView(IView *piView)
{
    RELEASE(m_piCurrentView);
    if (NULL != piView)
    {
        piView->AddRef();
    }
    m_piCurrentView = piView;
}

HRESULT CViews::SetNextViewCaption(BSTR bstrCaption)
{
    HRESULT hr = S_OK;

    FREESTRING(m_bstrNextViewCaption);
    if (NULL != bstrCaption)
    {
        m_bstrNextViewCaption = ::SysAllocString(bstrCaption);
        if (NULL == m_bstrNextViewCaption)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }
Error:
    RRETURN(hr);
}


void CViews::FireInitialize(IView *piView)
{
    DebugPrintf("Firing Views_Initialize\r\n");

    FireEvent(&m_eiInitialize, piView);
}

void CViews::FireLoad(IView *piView)
{
    DebugPrintf("Firing Views_Load\r\n");

    FireEvent(&m_eiLoad, piView);
}

void CViews::FireTerminate(IView *piView)
{
    DebugPrintf("Firing Views_Terminate\r\n");

    FireEvent(&m_eiTerminate, piView);
}


void CViews::FireActivate(IView *piView)
{
    DebugPrintf("Firing Views_Activate\r\n");

    FireEvent(&m_eiActivate, piView);
}

void CViews::FireDeactivate(IView *piView)
{
    DebugPrintf("Firing Views_Deactivate\r\n");

    FireEvent(&m_eiDeactivate, piView);
}

void CViews::FireMinimize(IView *piView)
{
    DebugPrintf("Firing Views_Minimize\r\n");

    FireEvent(&m_eiMinimize, piView);
}

void CViews::FireMaximize(IView *piView)
{
    DebugPrintf("Firing Views_Maximize\r\n");

    FireEvent(&m_eiMaximize, piView);
}

void CViews::FireSetControlbar(IView *piView, IMMCControlbar *piMMCControlbar)
{
    DebugPrintf("Firing Views_SetControlbar\r\n");

    FireEvent(&m_eiSetControlbar, piView, piMMCControlbar);
}


void CViews::FireSelect
(
    IView            *piView,
    IMMCClipboard    *piSelection,
    VARIANT_BOOL      fvarSelected,
    IMMCConsoleVerbs *piMMCConsoleVerbs
)
{
    DebugPrintf("Firing Views_Select(%s)\r\n", (VARIANT_TRUE == fvarSelected) ? "selected" : "deselected");

    FireEvent(&m_eiSelect, piView, piSelection, fvarSelected, piMMCConsoleVerbs);
}


void CViews::FireAddTopMenuItems
(
    IView         *piView,
    IMMCClipboard *piSelection,
    IContextMenu  *piContextMenu,
    VARIANT_BOOL  *pfvarInsertionAllowed
)
{
    DebugPrintf("Firing Views_AddTopMenuItems()\r\n");

    FireEvent(&m_eiAddTopMenuItems, piView, piSelection,
              piContextMenu, pfvarInsertionAllowed);
}

void CViews::FireAddNewMenuItems
(
    IView         *piView,
    IMMCClipboard *piSelection,
    IContextMenu  *piContextMenu,
    VARIANT_BOOL  *pfvarInsertionAllowed
)
{
    DebugPrintf("Firing Views_AddNewMenuItems()\r\n");

    FireEvent(&m_eiAddNewMenuItems, piView, piSelection,
              piContextMenu, pfvarInsertionAllowed);
}

void CViews::FireAddTaskMenuItems
(
    IView         *piView,
    IMMCClipboard *piSelection,
    IContextMenu  *piContextMenu,
    VARIANT_BOOL  *pfvarInsertionAllowed
)
{
    DebugPrintf("Firing Views_AddTaskMenuItems()\r\n");

    FireEvent(&m_eiAddTaskMenuItems, piView, piSelection,
              piContextMenu, pfvarInsertionAllowed);
}

void CViews::FireAddViewMenuItems
(
    IView         *piView,
    IMMCClipboard *piSelection,
    IContextMenu  *piContextMenu,
    VARIANT_BOOL  *pfvarInsertionAllowed,
    VARIANT_BOOL  *pfvarAddPredefinedViews)
{
    DebugPrintf("Firing Views_AddViewMenuItems()\r\n");

    FireEvent(&m_eiAddViewMenuItems, piView, piSelection,
              piContextMenu, pfvarInsertionAllowed, pfvarAddPredefinedViews);
}


void CViews::FireUpdateControlbar
(
    IView          *piView,
    IMMCClipboard  *piMMClipboard,
    VARIANT_BOOL    fvarSelected,
    IMMCControlbar *piMMCControlbar
)
{
    DebugPrintf("Firing Views_UpdateControlbar(%s)\r\n", (VARIANT_TRUE == fvarSelected) ? "selected" : "deselected");

    FireEvent(&m_eiUpdateControlbar, piView, piMMClipboard,
              fvarSelected, piMMCControlbar);
}



void CViews::FireGetMultiSelectData
(
    IView          *piView,
    IMMCClipboard  *piSelection,
    IMMCDataObject *piMMCDataObject
)
{
    DebugPrintf("Firing Views_GetMultiSelectData\r\n");

    FireEvent(&m_eiGetMultiSelectData, piView, piSelection, piMMCDataObject);
}


void CViews::FireQueryPaste
(
    IView         *piView,
    IMMCClipboard *piSourceItems,
    IScopeItem    *piScopeItemDest,
    VARIANT_BOOL  *pfvarOKToPaste
)
{
    DebugPrintf("Firing Views_QueryPaste()\r\n");

    FireEvent(&m_eiQueryPaste, piView, piSourceItems,
              piScopeItemDest, pfvarOKToPaste);
}


void CViews::FirePaste
(
    IView          *piView,
    IMMCClipboard  *piSourceItems,
    IScopeItem     *piScopeItemDest,
    IMMCDataObject *piMMCDataObjectRetToSource,
    VARIANT_BOOL    fvarMove
)
{
    DebugPrintf("Firing Views_Paste()\r\n");

    FireEvent(&m_eiPaste, piView, piSourceItems,
              piScopeItemDest, piMMCDataObjectRetToSource, fvarMove);
}


void CViews::FireCut
(
    IView          *piView,
    IMMCClipboard  *piItemsPasted,
    IMMCDataObject *piMMCDataObjectFromTarget
)
{
    DebugPrintf("Firing Views_Cut\r\n");

    FireEvent(&m_eiCut, piView, piItemsPasted, piMMCDataObjectFromTarget);
}

void CViews::FireDelete
(
    IView         *piView,
    IMMCClipboard *piSelection
)
{
    DebugPrintf("Firing Views_Delete\r\n");

    FireEvent(&m_eiDelete, piView, piSelection);
}


void CViews::FireQueryPagesFor
(
    IView         *piView,
    IMMCClipboard *piSelection,
    VARIANT_BOOL  *pfvarHavePages
)
{
    DebugPrintf("Firing Views_QueryPagesFor\r\n");

    FireEvent(&m_eiQueryPagesFor, piView, piSelection, pfvarHavePages);
}


void CViews::FireCreatePropertyPages
(
    IView             *piView,
    IMMCClipboard     *piSelection,
    IMMCPropertySheet *piMMCPropertySheet
)
{
    DebugPrintf("Firing Views_CreatePropertyPages\r\n");

    FireEvent(&m_eiCreatePropertyPages, piView, piSelection, piMMCPropertySheet);
}


void CViews::FireRefresh
(
    IView         *piView,
    IMMCClipboard *piSelection
)
{
    DebugPrintf("Firing Views_Refresh\r\n");

    FireEvent(&m_eiRefresh, piView, piSelection);
}



void CViews::FirePrint
(
    IView         *piView,
    IMMCClipboard *piSelection
)
{
    DebugPrintf("Firing Views_Print\r\n");

    FireEvent(&m_eiPrint, piView, piSelection);
}



void CViews::FireSpecialPropertiesClick
(
     IView                        *piView,
     SnapInSelectionTypeConstants  ResultViewType
)
{
    DebugPrintf("Firing Views_SpecialPropertiesClick\r\n");

    FireEvent(&m_eiSpecialPropertiesClick, piView, ResultViewType);
}


void CViews::FireWriteProperties
(
    IView        *piView,
    _PropertyBag *p_PropertyBag
)
{
    DebugPrintf("Firing Views_WriteProperties\r\n");

    FireEvent(&m_eiWriteProperties, piView, p_PropertyBag);
}


void CViews::FireReadProperties
(
    IView        *piView,
    _PropertyBag *p_PropertyBag
)
{
    DebugPrintf("Firing Views_ReadProperties\r\n");

    FireEvent(&m_eiReadProperties, piView, p_PropertyBag);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CViews::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IViews == riid)
    {
        *ppvObjOut = static_cast<IViews *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IView, View, IViews>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtdsnaps.cpp ===
//=--------------------------------------------------------------------------=
// xtdsnaps.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtendedSnapIns class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "xtdsnaps.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CExtendedSnapIns::CExtendedSnapIns(IUnknown *punkOuter) :
    CSnapInCollection<IExtendedSnapIn, ExtendedSnapIn, IExtendedSnapIns>(
                                          punkOuter,
                                          OBJECT_TYPE_EXTENDEDSNAPINS,
                                          static_cast<IExtendedSnapIns *>(this),
                                          static_cast<CExtendedSnapIns *>(this),
                                          CLSID_ExtendedSnapIn,
                                          OBJECT_TYPE_EXTENDEDSNAPIN,
                                          IID_IExtendedSnapIn,
                                          static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ExtendedSnapIns,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtendedSnapIns::~CExtendedSnapIns()
{
}

IUnknown *CExtendedSnapIns::Create(IUnknown * punkOuter)
{
    CExtendedSnapIns *pExtendedSnapIns = New CExtendedSnapIns(punkOuter);
    if (NULL == pExtendedSnapIns)
    {
        return NULL;
    }
    else
    {
        return pExtendedSnapIns->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CExtendedSnapIns::Persist()
{
    HRESULT           hr = S_OK;
    IExtendedSnapIn  *piExtendedSnapIn = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IExtendedSnapIn, ExtendedSnapIn, IExtendedSnapIns>::Persist(piExtendedSnapIn);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtendedSnapIns::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IExtendedSnapIns == riid)
    {
        *ppvObjOut = static_cast<IExtendedSnapIns *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IExtendedSnapIn, ExtendedSnapIn, IExtendedSnapIns>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtdsnap.cpp ===
//=--------------------------------------------------------------------------=
// xtdsnap.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtendedSnapIn class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "xtdsnap.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CExtendedSnapIn::CExtendedSnapIn(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_EXTENDEDSNAPIN,
                            static_cast<IExtendedSnapIn *>(this),
                            static_cast<CExtendedSnapIn *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ExtendedSnapIn,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtendedSnapIn::~CExtendedSnapIn()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrNodeTypeGUID);
    FREESTRING(m_bstrNodeTypeName);
    InitMemberVariables();
}

void CExtendedSnapIn::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrNodeTypeGUID = NULL;
    m_bstrNodeTypeName = NULL;
    m_Dynamic = VARIANT_FALSE;
    m_ExtendsNameSpace = VARIANT_FALSE;
    m_ExtendsNewMenu = VARIANT_FALSE;
    m_ExtendsTaskMenu = VARIANT_FALSE;
    m_ExtendsPropertyPages = VARIANT_FALSE;
    m_ExtendsToolbar = VARIANT_FALSE;
    m_ExtendsTaskpad = VARIANT_FALSE;
}

IUnknown *CExtendedSnapIn::Create(IUnknown * punkOuter)
{
    CExtendedSnapIn *pExtendedSnapIn = New CExtendedSnapIn(punkOuter);
    if (NULL == pExtendedSnapIn)
    {
        return NULL;
    }
    else
    {
        return pExtendedSnapIn->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CExtendedSnapIn::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistBstr(&m_bstrNodeTypeGUID, L"", OLESTR("CLSID")));

    IfFailRet(PersistBstr(&m_bstrNodeTypeName, L"", OLESTR("DisplayName")));

    IfFailRet(PersistSimpleType(&m_Dynamic, VARIANT_FALSE, OLESTR("Dynamic")));

    IfFailRet(PersistSimpleType(&m_ExtendsNameSpace, VARIANT_FALSE, OLESTR("ExtendsNameSpace")));

    IfFailRet(PersistSimpleType(&m_ExtendsNewMenu, VARIANT_FALSE, OLESTR("ExtendsNewMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsTaskMenu, VARIANT_FALSE, OLESTR("ExtendsTaskMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsPropertyPages, VARIANT_FALSE, OLESTR("ExtendsPropertyPages")));

    IfFailRet(PersistSimpleType(&m_ExtendsToolbar, VARIANT_FALSE, OLESTR("ExtendsToolbar")));

    IfFailRet(PersistSimpleType(&m_ExtendsTaskpad, VARIANT_FALSE, OLESTR("ExtendsTaskpad")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtendedSnapIn::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtendedSnapIn == riid)
    {
        *ppvObjOut = static_cast<IExtendedSnapIn *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtdsnaps.h ===
//=--------------------------------------------------------------------------=
// xtdsnaps.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtendedSnapIns class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _EXTENDEDSNAPINS_DEFINED_
#define _EXTENDEDSNAPINS_DEFINED_

#include "collect.h"

class CExtendedSnapIns : public CSnapInCollection<IExtendedSnapIn, ExtendedSnapIn, IExtendedSnapIns>,
                         public CPersistence
{
    protected:
        CExtendedSnapIns(IUnknown *punkOuter);
        ~CExtendedSnapIns();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ExtendedSnapIns,           // name
                                &CLSID_ExtendedSnapIns,    // clsid
                                "ExtendedSnapIns",         // objname
                                "ExtendedSnapIns",         // lblname
                                &CExtendedSnapIns::Create, // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IExtendedSnapIns,     // dispatch IID
                                NULL,                      // no events IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _EXTENDEDSNAPINS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtdsnap.h ===
//=--------------------------------------------------------------------------=
// xtdsnap.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtendedSnapIn class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _EXTENDEDSNAPIN_DEFINED_
#define _EXTENDEDSNAPIN_DEFINED_


class CExtendedSnapIn : public CSnapInAutomationObject,
                        public CPersistence,
                        public IExtendedSnapIn
{
    private:
        CExtendedSnapIn(IUnknown *punkOuter);
        ~CExtendedSnapIn();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IExtendedSnapIn

        BSTR_PROPERTY_RW  (CExtendedSnapIn, Name,                               DISPID_VALUE);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, Index,                long,         DISPID_EXTENDEDSNAPIN_INDEX);
        BSTR_PROPERTY_RW  (CExtendedSnapIn, Key,                                DISPID_EXTENDEDSNAPIN_KEY);
        BSTR_PROPERTY_RW  (CExtendedSnapIn, NodeTypeGUID,                       DISPID_EXTENDEDSNAPIN_NODE_TYPE_GUID);
        BSTR_PROPERTY_RW  (CExtendedSnapIn, NodeTypeName,                       DISPID_EXTENDEDSNAPIN_NODE_TYPE_NAME);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, Dynamic,              VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_DYNAMIC);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsNameSpace,     VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_NAMESPACE);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsNewMenu,       VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_NEW_MENU);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsTaskMenu,      VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_TASK_MENU);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsPropertyPages, VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_PROPERTYPAGES);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsToolbar,       VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_TOOLBAR);
        SIMPLE_PROPERTY_RW(CExtendedSnapIn, ExtendsTaskpad,       VARIANT_BOOL, DISPID_EXTENDEDSNAPIN_EXTENDS_TASKPAD);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ExtendedSnapIn,           // name
                                &CLSID_ExtendedSnapIn,    // clsid
                                "ExtendedSnapIn",         // objname
                                "ExtendedSnapIn",         // lblname
                                &CExtendedSnapIn::Create, // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IExtendedSnapIn,     // dispatch IID
                                NULL,                     // event IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _EXTENDEDSNAPIN_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtenson.cpp ===
//=--------------------------------------------------------------------------=
// xtenson.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtension class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "xtenson.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CExtension::CExtension(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_EXTENSION,
                            static_cast<IExtension *>(this),
                            static_cast<CExtension *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence

{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtension::~CExtension()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrCLSID);
    FREESTRING(m_bstrName);
    InitMemberVariables();
}

void CExtension::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrCLSID = NULL;
    m_bstrName = NULL;
    m_Type = siStatic;
    m_ExtendsContextMenu = VARIANT_FALSE;
    m_ExtendsNameSpace = VARIANT_FALSE;
    m_ExtendsToolbar = VARIANT_FALSE;
    m_ExtendsPropertySheet = VARIANT_FALSE;
    m_ExtendsTaskpad = VARIANT_FALSE;
    m_Enabled = VARIANT_FALSE;
    m_NameSpaceEnabled = VARIANT_FALSE;
    m_pSnapIn = NULL;
    m_hsi = NULL;
    m_fHaveHsi = FALSE;
}

IUnknown *CExtension::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkExtension = NULL;

    CExtension *pExtension = New CExtension(punkOuter);

    IfFalseGo(NULL != pExtension, SID_E_OUTOFMEMORY);
    punkExtension = pExtension->PrivateUnknown();

Error:
    return punkExtension;
}


//=--------------------------------------------------------------------------=
//                         IExtension Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CExtension::put_NameSpaceEnabled(VARIANT_BOOL fvarEnabled)
{
    HRESULT      hr = S_OK;
    CLSID        clsid = CLSID_NULL;
    VARIANT_BOOL fvarCurrentValue = m_NameSpaceEnabled;

    m_NameSpaceEnabled = fvarEnabled;

    // If we have access to the snap-in, and we have an HSCOPITEM, and the
    // current value has gone from  disabled to enabled, then call
    // IConsoleNameSpace2::AddExtension()

    IfFalseGo(NULL != m_pSnapIn, S_OK);
    IfFalseGo(m_fHaveHsi, S_OK);
    IfFalseGo(VARIANT_FALSE == fvarCurrentValue, S_OK);
    IfFalseGo(VARIANT_TRUE == m_NameSpaceEnabled, S_OK);

    hr = ::CLSIDFromString(m_bstrCLSID, &clsid);
    EXCEPTION_CHECK_GO(hr);

    hr = m_pSnapIn->GetIConsoleNameSpace2()->AddExtension(m_hsi, &clsid);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtension::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IExtension == riid)
    {
        *ppvObjOut = static_cast<IExtension *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtenson.h ===
//=--------------------------------------------------------------------------=
// xtenson.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtension class definition - implements Extension object
//
//=--------------------------------------------------------------------------=

#ifndef _EXTENSON_DEFINED_
#define _EXTENSON_DEFINED_

#include "snapin.h"

class CExtension : public CSnapInAutomationObject,
                   public IExtension
{
    private:
        CExtension(IUnknown *punkOuter);
        ~CExtension();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IExtension
        SIMPLE_PROPERTY_RW(CExtension, Index,               long,                           DISPID_EXTENSION_INDEX);
        BSTR_PROPERTY_RW(CExtension,   Key,                                                 DISPID_EXTENSION_KEY);
        BSTR_PROPERTY_RW(CExtension,   CLSID,                                               DISPID_EXTENSION_CLSID);
        BSTR_PROPERTY_RW(CExtension,   Name,                                                DISPID_EXTENSION_NAME);
        SIMPLE_PROPERTY_RW(CExtension, Type,                 SnapInExtensionTypeConstants,  DISPID_EXTENSION_EXTENDS_CONTEXT_MENU);
        SIMPLE_PROPERTY_RW(CExtension, ExtendsContextMenu,   VARIANT_BOOL,                  DISPID_EXTENSION_EXTENDS_CONTEXT_MENU);
        SIMPLE_PROPERTY_RW(CExtension, ExtendsNameSpace,     VARIANT_BOOL,                  DISPID_EXTENSION_EXTENDS_NAME_SPACE);
        SIMPLE_PROPERTY_RW(CExtension, ExtendsToolbar,       VARIANT_BOOL,                  DISPID_EXTENSION_EXTENDS_TOOLBAR);
        SIMPLE_PROPERTY_RW(CExtension, ExtendsPropertySheet, VARIANT_BOOL,                  DISPID_EXTENSION_EXTENDS_PROPERTY_SHEET);
        SIMPLE_PROPERTY_RW(CExtension, ExtendsTaskpad,       VARIANT_BOOL,                  DISPID_EXTENSION_EXTENDS_TASKPAD);
        SIMPLE_PROPERTY_RW(CExtension, Enabled,              VARIANT_BOOL,                  DISPID_EXTENSION_ENABLED);

        SIMPLE_PROPERTY_RO(CExtension, NameSpaceEnabled,     VARIANT_BOOL,                  DISPID_EXTENSION_NAMESPACE_ENABLED);
        STDMETHOD(put_NameSpaceEnabled)(VARIANT_BOOL fvarEnabled);
        
    // Public utility methods
    public:

        OLECHAR *GetCLSID() { return static_cast<OLECHAR *>(m_bstrCLSID); }
        BOOL Enabled() { return VARIANTBOOL_TO_BOOL(m_Enabled); }
        BOOL NameSpaceEnabled() { return VARIANTBOOL_TO_BOOL(m_NameSpaceEnabled); }
        BOOL ExtendsContextMenu() { return VARIANTBOOL_TO_BOOL(m_ExtendsContextMenu); }
        BOOL ExtendsToolbar() { return VARIANTBOOL_TO_BOOL(m_ExtendsToolbar); }
        BOOL ExtendsPropertySheet() { return VARIANTBOOL_TO_BOOL(m_ExtendsPropertySheet); }
        BOOL ExtendsTaskpad() { return VARIANTBOOL_TO_BOOL(m_ExtendsTaskpad); }
        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }
        void SetHSCOPEITEM(HSCOPEITEM hsi) { m_hsi = hsi; m_fHaveHsi = TRUE; }

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        CSnapIn     *m_pSnapIn;  // Back ptr to snap-in
        BOOL         m_fHaveHsi; // TRUE=m_hsi has valid HSCOPEITEM
        HSCOPEITEM   m_hsi;      // HSCOPEITEM used when Extension belongs to
                                 // ScopeItem.DynamicExtensions so that
                                 // when VB enables it for namespace this object
                                 // can call IConsoleNameSpace2->AddExtension

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Extension,                  // name
                                &CLSID_Extension,           // clsid
                                "Extension",                // objname
                                "Extension",                // lblname
                                &CExtension::Create,        // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IExtension,            // dispatch IID
                                NULL,                       // no event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _EXTENSON_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtensons.h ===
//=--------------------------------------------------------------------------=
// xtensons.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensions class definition - implements Extensions collection
//
//=--------------------------------------------------------------------------=

#ifndef _XTENSONS_DEFINED_
#define _XTENSONS_DEFINED_

#include "collect.h"

class CExtensions : public CSnapInCollection<IExtension, Extension, IExtensions>
{
    protected:
        CExtensions(IUnknown *punkOuter);
        ~CExtensions();

    public:
        static IUnknown *Create(IUnknown * punk);

        enum ExtensionSubset { All, Dynamic };
        
        HRESULT Populate(BSTR bstrNodeTypeGUID, ExtensionSubset Subset);
        HRESULT SetSnapIn(CSnapIn *pSnapIn);
        HRESULT SetHSCOPEITEM(HSCOPEITEM hsi);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IExtensions
        STDMETHOD(EnableAll)(VARIANT_BOOL Enabled);
        STDMETHOD(EnableAllStatic)(VARIANT_BOOL Enabled);
        

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        enum ExtensionFeatures { NameSpace, ContextMenu, Toolbar,
                                 PropertySheet, Task };

        HRESULT AddExtensions(ExtensionFeatures   Feature,
                              char               *pszExtensionTypeKey,
                              size_t              cbExtensionTypeKey,
                              BSTR                bstrNodeTypeGUID,
                              ExtensionSubset     Subset,
                              HKEY                hkeyDynExt);

        HRESULT AddExtension(ExtensionFeatures   Feature,
                             char               *pszCLSID,
                             char               *pszName,
                             ExtensionSubset     Subset,
                             HKEY                hkeyDynExt);

        HRESULT UpdateExtensionFeatures(IExtension        *piExtension,
                                        ExtensionFeatures  Feature);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Extensions,              // name
                                &CLSID_Extensions,       // clsid
                                "Extensions",            // objname
                                "Extensions",            // lblname
                                &CExtensions::Create,    // creation function
                                TLIB_VERSION_MAJOR,      // major version
                                TLIB_VERSION_MINOR,      // minor version
                                &IID_IExtensions,        // dispatch IID
                                NULL,                    // no events IID
                                HELP_FILENAME,           // help file
                                TRUE);                   // thread safe


#endif // _XTENSONS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\xtensons.cpp ===
//=--------------------------------------------------------------------------=
// xtensons.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensions class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "xtensons.h"
#include "xtenson.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CExtensions::CExtensions(IUnknown *punkOuter) :
    CSnapInCollection<IExtension, Extension, IExtensions>(
                                           punkOuter,
                                           OBJECT_TYPE_EXTENSIONS,
                                           static_cast<IExtensions *>(this),
                                           static_cast<CExtensions *>(this),
                                           CLSID_Extension,
                                           OBJECT_TYPE_EXTENSION,
                                           IID_IExtension,
                                           NULL)  // no persistence
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtensions::~CExtensions()
{
}

IUnknown *CExtensions::Create(IUnknown * punkOuter)
{
    CExtensions *pExtensions = New CExtensions(punkOuter);
    if (NULL == pExtensions)
    {
        return NULL;
    }
    else
    {
        return pExtensions->PrivateUnknown();
    }
}



//=--------------------------------------------------------------------------=
// CExtensions::Populate
//=--------------------------------------------------------------------------=
//
// Parameters:
//   BSTR bstrNodeTypeGUID  [in] node type whose extensions should populate the
//                               collection
//   ExtensionSubset Subset [in] All or dynamic only
//
// Output:
//      HRESULT
//
// Notes:
//
// This function populates the collection with either static or dynamic
// extensions for the specified node type GUID. It may be called multiple times
// for the same collection.
//

HRESULT CExtensions::Populate(BSTR bstrNodeTypeGUID, ExtensionSubset Subset)
{
    HRESULT  hr = S_OK;
    char    *pszDynExtKeyPrefix = NULL;
    char    *pszDynExtKeyName = NULL;
    long     lRc = 0;
    HKEY     hKeyDynExt = NULL;

    // Open DynamicExtensions key for the node type.
    // Build the key name
    // \Software\Microsoft\MMC\NodeTypes\<NodeType GUID>\DynamicExtensions

    IfFailGo(::CreateKeyNameW(MMCKEY_NODETYPES, MMCKEY_NODETYPES_LEN,
                            bstrNodeTypeGUID, &pszDynExtKeyPrefix));

    IfFailGo(::CreateKeyName(pszDynExtKeyPrefix, ::strlen(pszDynExtKeyPrefix),
                           MMCKEY_S_DYNAMIC_EXTENSIONS,
                           MMCKEY_S_DYNAMIC_EXTENSIONS_LEN,
                           &pszDynExtKeyName));

    lRc = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszDynExtKeyName, 0,
                         KEY_QUERY_VALUE, &hKeyDynExt);
    if (ERROR_SUCCESS != lRc)
    {
        if (ERROR_FILE_NOT_FOUND == lRc)
        {
            hKeyDynExt = NULL; // DynamicExtensions subkey is not present
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lRc);
            EXCEPTION_CHECK_GO(hr);
        }
    }

    IfFailGo(AddExtensions(NameSpace, MMCKEY_S_NAMESPACE, MMCKEY_S_NAMESPACE_LEN,
                           bstrNodeTypeGUID, Subset, hKeyDynExt));

    IfFailGo(AddExtensions(ContextMenu, MMCKEY_S_CONTEXTMENU,
                           MMCKEY_S_CONTEXTMENU_LEN, bstrNodeTypeGUID, Subset,
                           hKeyDynExt));

    IfFailGo(AddExtensions(Toolbar, MMCKEY_S_TOOLBAR, MMCKEY_S_TOOLBAR_LEN,
                           bstrNodeTypeGUID, Subset, hKeyDynExt));

    IfFailGo(AddExtensions(PropertySheet, MMCKEY_S_PROPERTYSHEET,
                           MMCKEY_S_PROPERTYSHEET_LEN, bstrNodeTypeGUID, Subset,
                           hKeyDynExt));

    IfFailGo(AddExtensions(Task, MMCKEY_S_TASK, MMCKEY_S_TASK_LEN, bstrNodeTypeGUID,
                           Subset, hKeyDynExt));

Error:
    if (NULL != pszDynExtKeyPrefix)
    {
        ::CtlFree(pszDynExtKeyPrefix);
    }
    if (NULL != pszDynExtKeyName)
    {
        ::CtlFree(pszDynExtKeyName);
    }
    if (NULL != hKeyDynExt)
    {
        ::RegCloseKey(hKeyDynExt);
    }
    RRETURN(hr);
}


HRESULT CExtensions::AddExtensions
(
    ExtensionFeatures   Feature,
    char               *pszExtensionTypeKey,
    size_t              cbExtensionTypeKey,
    BSTR                bstrNodeTypeGUID,
    ExtensionSubset     Subset,
    HKEY                hkeyDynExt
)
{
    HRESULT     hr = S_OK;
    long        lRc = ERROR_SUCCESS;
    char       *pszGUIDPrefix = NULL;
    char       *pszExtensionsPrefix = NULL;
    char       *pszKeyName = NULL;
    HKEY        hkeyExtension = NULL;
    DWORD       dwIndex = 0;
    char        szValueName[64] = "";
    DWORD       cbValueName = sizeof(szValueName);
    char        szValueData[256] = "";
    DWORD       cbValueData = sizeof(szValueData);
    DWORD       dwType = REG_SZ;

    // Build the key name and open the key
    // Software\Microsoft\MMC\NodeTypes\<NodeType GUID>\Extensions\<Extension Type>

    IfFailGo(CreateKeyNameW(MMCKEY_NODETYPES, MMCKEY_NODETYPES_LEN,
                            bstrNodeTypeGUID, &pszGUIDPrefix));

    IfFailGo(CreateKeyName(pszGUIDPrefix, ::strlen(pszGUIDPrefix),
                           MMCKEY_S_EXTENSIONS, MMCKEY_S_EXTENSIONS_LEN,
                           &pszExtensionsPrefix));

    IfFailGo(CreateKeyName(pszExtensionsPrefix, ::strlen(pszExtensionsPrefix),
                           pszExtensionTypeKey, cbExtensionTypeKey,
                           &pszKeyName));

    lRc = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKeyName, 0,
                         KEY_QUERY_VALUE, &hkeyExtension);

    if (ERROR_SUCCESS != lRc)
    {
        // If extension type subkey is not there then nothing else to do
        IfFalseGo(ERROR_FILE_NOT_FOUND != lRc, S_OK);
        hr = HRESULT_FROM_WIN32(lRc);
        EXCEPTION_CHECK_GO(hr);
    }

    // Extension type key is there. Enum the values to get the various extensions.

    for (dwIndex = 0; ERROR_SUCCESS == lRc; dwIndex++)
    {
        cbValueName = sizeof(szValueName);
        cbValueData = sizeof(szValueData);

        lRc = ::RegEnumValue(hkeyExtension, dwIndex,
                            szValueName, &cbValueName,
                            NULL, // reserved
                            &dwType,
                            reinterpret_cast<LPBYTE>(szValueData), &cbValueData);
        if (ERROR_SUCCESS != lRc)
        {
            // Check whether there are no more values or a real error occurred
            if (ERROR_NO_MORE_ITEMS == lRc)
            {
                continue;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lRc);
                EXCEPTION_CHECK_GO(hr);
            }
        }

        // If it is not a string type or the name is zero length then ignore it
        if ( (REG_SZ != dwType) || (0 == cbValueName) )
        {
            continue;
        }

        if (0 == cbValueData)
        {
            szValueData[0] = '\0';
        }
        IfFailGo(AddExtension(Feature, szValueName, szValueData, Subset,
                              hkeyDynExt));
    }
    
Error:
    if (NULL != pszGUIDPrefix)
    {
        ::CtlFree(pszGUIDPrefix);
    }
    if (NULL != pszExtensionsPrefix)
    {
        ::CtlFree(pszExtensionsPrefix);
    }
    if (NULL != pszKeyName)
    {
        ::CtlFree(pszKeyName);
    }
    if (NULL != hkeyExtension)
    {
        ::RegCloseKey(hkeyExtension);
    }
    RRETURN(hr);
}



HRESULT CExtensions::AddExtension
(
    ExtensionFeatures   Feature,
    char               *pszCLSID,
    char               *pszName,
    ExtensionSubset     Subset,
    HKEY                hkeyDynExt
)
{
    HRESULT     hr = S_OK;
    DWORD       cbDynValueData = 0;
    IExtension *piExtension = NULL;
    BSTR        bstrCLSID = NULL;
    BSTR        bstrName = NULL;
    long        lRc = 0;

    SnapInExtensionTypeConstants Type = siStatic;

    VARIANT varKey;
    ::VariantInit(&varKey);
    varKey.vt = VT_BSTR;

    VARIANT varIndex;
    UNSPECIFIED_PARAM(varIndex);

    // Check if the extension is already in there.

    IfFailGo(::BSTRFromANSI(pszCLSID, &bstrCLSID));

    hr = GetItemByName(bstrCLSID, &piExtension);

    // If it's there then just need to add the extension type (see below).
    IfFalseGo(FAILED(hr), S_OK);

    // If there was a real error then return
    
    if (SID_E_ELEMENT_NOT_FOUND != hr)
    {
        goto Error;
    }
   
    // Item is not there. Might need to add it. First determine whether the
    // extension is static or dynamic. Check if the value name is also present
    // under the dynamic extensions key.

    if (NULL != hkeyDynExt)
    {
        // Try to read the data length for the value named the same as the
        // clsid under the DynamicExtensions key. Note that we don't check
        // the actual type because it is only the presence of the value that
        // matters.

        cbDynValueData = 0;
        lRc = ::RegQueryValueEx(hkeyDynExt, pszCLSID,
                                NULL, // reserved
                                NULL, // don't return type
                                NULL, // don't return the data
                                &cbDynValueData);
        if (ERROR_SUCCESS != lRc)
        {
            // If the value is not there then don't add the extension
            IfFalseGo(ERROR_FILE_NOT_FOUND != lRc, S_OK);

            // A real error occurred
            hr = HRESULT_FROM_WIN32(lRc);
            EXCEPTION_CHECK_GO(hr);
        }

        // It is a dynamic extension.
        Type = siDynamic;
    }

    // If we are being asked for dynamic extensions only and this one is static
    // then don't add it

    if (Dynamic == Subset)
    {
        IfFalseGo(siDynamic == Type, S_OK);
    }

    // Add the new extension

    varKey.vt = VT_BSTR;
    varKey.bstrVal = bstrCLSID;
    IfFailGo(Add(varIndex, varKey, &piExtension));

    // Set its properties

    IfFailGo(piExtension->put_CLSID(bstrCLSID));

    if (*pszName != '\0')
    {
        IfFailGo(::BSTRFromANSI(pszName, &bstrName));
        IfFailGo(piExtension->put_Name(bstrName));
    }

    IfFailGo(piExtension->put_Type(Type));

Error:
    if ( SUCCEEDED(hr) && (NULL != piExtension) )
    {
        // Add the extension type.
        IfFailGo(UpdateExtensionFeatures(piExtension, Feature));
    }
    FREESTRING(bstrCLSID);
    FREESTRING(bstrName);
    QUICK_RELEASE(piExtension);
    RRETURN(hr);
}



HRESULT CExtensions::UpdateExtensionFeatures
(
    IExtension        *piExtension,
    ExtensionFeatures  Feature
)
{
    HRESULT hr = S_OK;

    switch (Feature)
    {
        case NameSpace:
            IfFailGo(piExtension->put_ExtendsNameSpace(VARIANT_TRUE));
            break;

        case ContextMenu:
            IfFailGo(piExtension->put_ExtendsContextMenu(VARIANT_TRUE));
            break;

        case Toolbar:
            IfFailGo(piExtension->put_ExtendsToolbar(VARIANT_TRUE));
            break;

        case PropertySheet:
            IfFailGo(piExtension->put_ExtendsPropertySheet(VARIANT_TRUE));
            break;

        case Task:
            IfFailGo(piExtension->put_ExtendsTaskpad(VARIANT_TRUE));
            break;
    }

Error:
    RRETURN(hr);
}


HRESULT CExtensions::SetSnapIn(CSnapIn *pSnapIn)
{
    HRESULT     hr = S_OK;
    long        i = 0;
    long        cObjects = GetCount();
    CExtension *pExtension = NULL;

    while (i < cObjects)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                       &pExtension));
        pExtension->SetSnapIn(pSnapIn);
        i++;
    }

Error:
    RRETURN(hr);
}


HRESULT CExtensions::SetHSCOPEITEM(HSCOPEITEM hsi)
{
    HRESULT     hr = S_OK;
    long        i = 0;
    long        cObjects = GetCount();
    CExtension *pExtension = NULL;

    while (i < cObjects)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                       &pExtension));
        pExtension->SetHSCOPEITEM(hsi);
        i++;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         IExtensions Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CExtensions::EnableAll(VARIANT_BOOL Enabled)
{
    HRESULT hr = S_OK;
    long    i = 0;
    long    cObjects = GetCount();

    while (i < cObjects)
    {
        IfFailGo(GetItemByIndex(i)->put_Enabled(Enabled));
        i++;
    }
    
Error:
    RRETURN(hr);
}




STDMETHODIMP CExtensions::EnableAllStatic(VARIANT_BOOL Enabled)
{
    HRESULT                       hr = S_OK;
    IExtension                   *piExtension = NULL; // Not AddRef()ed
    long                          i = 0;
    long                          cObjects = GetCount();
    SnapInExtensionTypeConstants  Type = siStatic;

    while (i < cObjects)
    {
        piExtension = GetItemByIndex(i);
        IfFailGo(piExtension->get_Type(&Type));
        if (siStatic == Type)
        {
            IfFailGo(piExtension->put_Enabled(Enabled));
        }
        i++;
    }

Error:
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtensions::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IExtensions == riid)
    {
        *ppvObjOut = static_cast<IExtensions *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IExtension, Extension, IExtensions>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\vblic\timebomb.cpp ===
//--------------------------------------------------------------------------
//   TimeBomb.CPP
//--------------------------------------------------------------------------

//#include "time.h"
#include "timebomb.h"
#include "winbase.h"
#include "IPServer.H"

// prototypes
BOOL After (SYSTEMTIME t1, SYSTEMTIME t2);

// Change this to the desired expiration date
// format {year, month, dayofweek, day, hour, minute, second, milliseconds}
const SYSTEMTIME beta_death = {1998, 3, 0, 1, 0, 0, 0, 0}; // 1 Mar 1998

//-------------------------------------------------------------------
// CheckExpired  - checks whether to the control has expired (beta)
//-------------------------------------------------------------------
BOOL CheckExpired (void)

{
#ifdef BETA_BOMB

  SYSTEMTIME now;  

  GetSystemTime(&now);

  if (After (now, beta_death))
      { // alert user of expiration
	MessageBox(NULL, SZEXPIRED1, SZEXPIRED2,
		   (MB_OK | MB_TASKMODAL));
	return FALSE;
      }

#endif  //BETA_BOMB

  return TRUE;
}

//-------------------------------------------------------------------
// After  - determines whether t1 is later than t2
//-------------------------------------------------------------------
BOOL After (SYSTEMTIME t1, SYSTEMTIME t2)

{
  // compare Years
  if (t1.wYear > t2.wYear) return TRUE;
  if (t1.wYear < t2.wYear) return FALSE;
  // else Years are equal; compare Months
  if (t1.wMonth > t2.wMonth) return TRUE;
  if (t1.wMonth < t2.wMonth) return FALSE;
  // else Months are equal; compare Days
  if (t1.wDay > t2.wDay) return TRUE;
  if (t1.wDay < t2.wDay) return FALSE;
  // else Days are equal; compare Hours
  if (t1.wHour > t2.wHour) return TRUE;
  if (t1.wHour < t2.wHour) return FALSE;
  // else Hours are equal; compare Minutes
  if (t1.wMinute > t2.wMinute) return TRUE;
  if (t1.wMinute < t2.wMinute) return FALSE;
  // else Minutes are equal; compare Seconds
  if (t1.wSecond > t2.wSecond) return TRUE;
  if (t1.wSecond < t2.wSecond) return FALSE;
  // else Seconds are equal; compare Milliseconds
  if (t1.wMilliseconds > t2.wMilliseconds) return TRUE;
  // else Milliseconds are equal or less
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\vblic\timebomb.h ===
//--------------------------------------------------------------------------
//   TimeBomb.H
//--------------------------------------------------------------------------

#ifndef _TIMEBOMB_H_

#include "IPServer.H"
#include "winbase.h"

#define SZEXPIRED1 "Sorry, this control has expired. Please obtain a newer version"
#define SZEXPIRED2 "Expired"

//prototypes
BOOL CheckExpired (void);
BOOL After (SYSTEMTIME t1, SYSTEMTIME t2);

#define _TIMEBOMB_H_
#endif // _TIMEBOMB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\vblic\vblic.cpp ===
#include <windows.h>
#include "vblic.h"

#ifdef BETA_BOMB
#include "timebomb.h"
#endif //BETA_BOMB

// NOTE: The following strings must match exactly the content of the registry as specified in
// vbprolic.reg.
#define LICENSES_KEY "Licenses"

void CalcValue(char * pszLicenseKey, char * pszKeyValue, LPTSTR pszTempBuff);
BOOL ValidateValue(HKEY hLicenseSubKey, char*  pszLicenseKey, char* pKeyValue);

#define MAX_KEY_LENGTH 200

//=-------------------------------------------------------------------------=
// CompareLicenseStringsW [Helper for comparing license keys]
//=-------------------------------------------------------------------------=
// Compares two null terminated wide strings and returns TRUE if the strings
// are equal.
//
BOOL CompareLicenseStringsW(LPWSTR pwszKey1, LPWSTR pwszKey2)
{
	int i = 0;
	
#ifdef BETA_BOMB
	// Check for expired control (BETA)
	if (!CheckExpired()) return FALSE;
#endif //BETA_BOMB

	// Check to see if the pointers are equal
	//
	if (pwszKey1 == pwszKey2)
		return TRUE;

	// Since pointer comparison failed, if either pointer is NULL, bail out
	//
	if (!pwszKey1 || !pwszKey2)
		return FALSE;
	
	// Compare each character.  Jump out when a character is not equal or the end of
	// either string is reached.
	//
	while (pwszKey1[i] && pwszKey2[i])
	{
		if (pwszKey1[i] != pwszKey2[i])
			break;
		i++;
	}

        return (pwszKey1[i] == pwszKey2[i]);
}

/////////////////////////////////////////////////////////////////////////////////
// VBValidateControlsLicense - This routine validates that the proper lincesing
// 	keys have been placed in the registery.  The list of potential keys are 
//	gathered from the resource file in the LICENSE_KEY_RESOURCE resource.
/////////////////////////////////////////////////////////////////////////////////

BOOL VBValidateControlsLicense(char *pszLicenseKey)
{
	HKEY hPrimaryLicenseKey, hLicenseSubKey;	
	LONG lSize = MAX_KEY_LENGTH;
	BOOL bFoundKey = FALSE;
	char szKeyValue[MAX_KEY_LENGTH];

#ifdef BETA_BOMB
	// Check for expired control (BETA)
	if (!CheckExpired()) return FALSE;
#endif //BETA_BOMB
	
	// Continue only if we were passed a non-NULL license string
	// We return FALSE, if the string is NULL
	//
	if (pszLicenseKey)
	{
		DWORD dwFoundKey = RegOpenKey(HKEY_CLASSES_ROOT, LICENSES_KEY, &hPrimaryLicenseKey);
		if (dwFoundKey == ERROR_SUCCESS)
		{
			// Now, loop through all the keys in the resource file trying to find
			// a match in the registry.
			if (!bFoundKey && *pszLicenseKey)
			{
				if (RegOpenKey(hPrimaryLicenseKey, pszLicenseKey, &hLicenseSubKey) == ERROR_SUCCESS)
				{
					if (ValidateValue(hLicenseSubKey, pszLicenseKey, szKeyValue))
						bFoundKey = TRUE;
					
					RegCloseKey(hLicenseSubKey);
				}
			}	// END if(...)

	 		RegCloseKey(hPrimaryLicenseKey);
		}	// END successfull RegOpenKey(HKEY_CLASSES_ROOT...)
	}
	

	return bFoundKey;
}

/////////////////////////////////////////////////////////////////////////////////
// ValidateValue - 	Calls CalcValue to get the corresponding value for a 
//					key and compares it to the value in the registry.
/////////////////////////////////////////////////////////////////////////////////
BOOL ValidateValue(HKEY hLicenseSubKey, char * pszLicenseKey, char * pszResultValue)
{
	BOOL bValidValue;
	TCHAR szTempBuff[MAX_KEY_LENGTH];
	
	// Reject a key that is too short.  (Short keys could lead to easier decoding.)
	long lSize = lstrlen(pszLicenseKey) + 1;
	if (lSize < 9)
		return FALSE;
	
	// Calculate the expected value from the key.	
	CalcValue(pszLicenseKey, pszResultValue, szTempBuff);
	
	// Now, get the value from the registry and compare.
	if (RegQueryValue(hLicenseSubKey, NULL, szTempBuff, &lSize) == ERROR_SUCCESS)
	{
		if (!lstrcmp(szTempBuff, pszResultValue))
			bValidValue = TRUE;
		else
			bValidValue = FALSE;
	}
	return bValidValue;
}

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
// THIS SOURCE IS REPLICATED IN THE "DECODE.EXE" OR LICGEN SOURCE.  (THIS PROGRAM WILL
// GENERATE VALUES FROM KEYS.) ANY CHANGES TO EITHER SOURCE MUST BE REPLICATED
// IN THE OTHER.  DO NOT CHANGE THIS SOURCE OR YOU RISK BREAKING CONTROLS UNDER 
// VB4.
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// CalcValue - This routine checks the value of the key with the key to
//	ensure it is a valid value.
// The plan:	First, XOR the string with itself in reverse.
//				Convert the result to ascii by adding each nibble to
//				'a' + (checksum of the key result mod 26).
/////////////////////////////////////////////////////////////////////////////////
void CalcValue(char * pszLicenseKey, char * pszResultKey, LPTSTR pszTempResult)
{
	BOOL bValid = FALSE;
	TCHAR *pKey, *pEndKey, *pEndResult, *pResult;
	unsigned int nCheckSum = 0;
	
	// Make a reverse copy of the key.
	
	// Find the end of the string
	for (pKey = pszLicenseKey; *pKey; pKey++);
	pKey--;
	
	for (pResult = pszTempResult; pKey >= pszLicenseKey; pKey--, pResult++)
		*pResult = *pKey;

	*pResult = '\0';

	// Find the end of the result string.
	for (pEndResult = pszTempResult; *pEndResult; pEndResult++);
	pEndResult--;
	
	// Find the end of the source string.
	for (pEndKey = (char *) pszLicenseKey; *pEndKey; pEndKey++);
	pEndKey--;
	
	// XOR each character with its corresponding character at the other
	// end of the string.
	for (pKey = (char *) pszLicenseKey, pResult = pszTempResult; pKey < pEndKey; pKey++, pResult++)
	{
		*pResult ^= *pKey;
		nCheckSum += *pResult;	// Calculate the checksum.
	}
	
	// Now find the middle (or about the middle).
	for (pKey = pszTempResult, pResult = pEndResult; pKey < pResult; pKey++, pResult--);
	pKey--;
	pEndResult = pKey;	// Save our new end.
	
	// Set our base character to mod 10 of the checksum of our XOR.
	TCHAR cBaseChar;
	cBaseChar = 'a' + (nCheckSum % 10);

	//Now convert to some ascii representation by adding each nibble to our base char.
	for (pKey = pszResultKey, pResult = pszTempResult; pResult <= pEndResult; pKey++, pResult++)
	{
		*pKey = cBaseChar + (*pResult & 0x0F);
		++pKey;
		*pKey = cBaseChar + (*pResult >> 4);
	}
	*pKey = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\vblic\vblic.h ===
//=--------------------------------------------------------------------------=
// VBLIC.H
//=--------------------------------------------------------------------------=
// Header file for licensing support
//
#ifndef _VBLIC_H_
#define _VBLIC_H_

// VB (Standard and Professional) Licensing
#define MSCONTROLS MSCONTROLS
#define LICENSE_KEY_RESOURCE 2

BOOL VBValidateControlsLicense(char *pszLicenseKey);
BOOL CompareLicenseStringsW(LPWSTR pwszKey1, LPWSTR pwszKey2);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\amcmsgid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcmsgid.h
//
//--------------------------------------------------------------------------

#ifndef _AMCMSGID_H
#define _AMCMSGID_H


//***************************IMPORTANT*****************************************
// The following enum group defines custom window messages used by MMC.
// MMC_MSG_SHOW_SNAPIN_HELP_TOPIC should be the first message and it's value
// can't be changed because it is referenced by mmc.lib, which is statically
// linked by snap-ins. Changing this message number would break existing snap-in
// DLLs.
//
// Because the message ID was mistakenly changed from the original (ver 1.1) value
// of 2166 to 2165, the message MMC_MSG_SHOW_SNAP_IN_HELP_TOPIC_ALT is being added
// so that MMC will respond properly to both message codes. This eliminates the
// need to synchronize this check-in with snap-in re-linking.
//******************************************************************************

enum MMC_MSG
{
    // Base message starting
    MMC_MSG_START    = 2165,    // DO NOT CHANGE!!

    // Message sent by nodemgr to conui
    //
    // wParam - <unused>
    // lParam - LPOLESTR help topic
    MMC_MSG_SHOW_SNAPIN_HELP_TOPIC_ALT = MMC_MSG_START, // This must be the first message!
    MMC_MSG_SHOW_SNAPIN_HELP_TOPIC,

    MMC_MSG_PROP_SHEET_NOTIFY,


    // Messages sent by CIC
    //
    // wParam - VARIANTARG
    // lParam - VARIANTARG
    MMC_MSG_CONNECT_TO_CIC,


    // Message sent by TPLV (TaskPadListView or ListPad)
    //
    // wParam - HWND of TPLV
    // lParam - HWND* to receive ListView window if connecting, NULL if deconnecting
    MMC_MSG_CONNECT_TO_TPLV,

    // Message sent from CFavTreeObserver to parent window
    //
    // wparam - ptr to Memento if favorite selected, NULL if folder selected
    // lparam - <unused>
    MMC_MSG_FAVORITE_SELECTION,

    // Message sent from CIconControl to parent window
    //
    // wparam - out param, ptr to HICON.
    // lparam - unused
    MMC_MSG_GET_ICON_INFO,

    // must be last!!
    MMC_MSG_MAX,
    MMC_MSG_FIRST = MMC_MSG_START,
    MMC_MSG_LAST  = MMC_MSG_MAX - 1
};

#endif // _AMCMSGID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\admindbg.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       AdminDbg.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              29-Apr-92   BartoszM    Moved from win4p.h
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//
//   "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug"
//
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------



#ifdef DBG

class CDbg
{
public:
    CDbg(LPTSTR str);
    ~CDbg(void);

    void DebugOut(unsigned long fDebugMask, LPWSTR pszfmt, ...);
    void DebugOut(unsigned long fDebugMask, LPSTR pszfmt, ...);
    void DebugMsg(LPSTR file, unsigned long line, LPWSTR  msg);
    void DebugMsg(LPSTR file, unsigned long line, LPSTR  msg);
    void DebugErrorL(LPSTR file, ULONG line, LONG err);
    void DebugErrorX(LPSTR file, ULONG line, LONG err);

    static void AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg);

private:
    unsigned long   m_InfoLevel; // must be the first data member
    LPTSTR          m_InfoLevelString;

public:
    static long s_cCDbgObjCount;         // Number of CDbg instances.

};  // class CDbg


#define DECLARE_DEBUG(comp)     extern "C" CDbg comp##InfoLevel;
#define DECLARE_INFOLEVEL(comp) CDbg comp##InfoLevel(_T(#comp));
#define Win4Assert(x) (void)((x) || (CDbg::AssertEx(THIS_FILE,__LINE__, _T(#x)),0))

#else  // ! DBG

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)
#define Win4Assert(x)      NULL

#endif // ! DBG





////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//
//  Debug info levels
//
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#define DEB_ERROR           0x00000001      // exported error paths
#define DEB_WARN            0x00000002      // exported warnings
#define DEB_TRACE           0x00000004      // exported trace messages

#define DEB_DBGOUT          0x00000010      // Output to debugger
#define DEB_STDOUT          0x00000020      // Output to stdout

#define DEB_IERROR          0x00000100      // internal error paths
#define DEB_IWARN           0x00000200      // internal warnings
#define DEB_ITRACE          0x00000400      // internal trace messages

#define DEB_USER1           0x00010000      // User defined
#define DEB_USER2           0x00020000      // User defined
#define DEB_USER3           0x00040000      // User defined
#define DEB_USER4           0x00080000      // User defined
#define DEB_USER5           0x00100000      // User defined
#define DEB_USER6           0x00200000      // User defined
#define DEB_USER7           0x00400000      // User defined
#define DEB_USER8           0x00800000      // User defined
#define DEB_USER9           0x01000000      // User defined
#define DEB_USER10          0x02000000      // User defined
#define DEB_USER11          0x04000000      // User defined
#define DEB_USER12          0x08000000      // User defined
#define DEB_USER13          0x10000000      // User defined
#define DEB_USER14          0x20000000      // User defined
#define DEB_USER15          0x40000000      // User defined

#define DEB_NOCOMPNAME      0x80000000      // suppress component name

#define DEB_FORCE           0x7fffffff      // force message

#define ASSRT_MESSAGE       0x00000001      // Output a message
#define ASSRT_BREAK         0x00000002      // Int 3 on assertion
#define ASSRT_POPUP         0x00000004      // And popup message

#ifndef DEF_INFOLEVEL
#define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\amcpriv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       amcpriv.h
//
//--------------------------------------------------------------------------

#ifndef __AMC_PRIV_H__
#define __AMC_PRIV_H__
#pragma once


#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


#include "ndmgr.h"

//
//  TVOWNED_MAGICWORD
//

const COMPONENTID TVOWNED_MAGICWORD = (long)(0x03951589);

#define MMCNODE_NO_CHANGE          0
#define MMCNODE_NAME_CHANGE        1
#define MMCNODE_TARGET_CHANGE      2


//////////////////////////////////////////////////////////////////////////////
//
// SViewUpdateInfo and related defines.
//

typedef CList<HMTNODE, HMTNODE> CHMTNODEList;

struct SViewUpdateInfo
{
    SViewUpdateInfo() : newNode(0), insertAfter(0), flag(0) {}

    CHMTNODEList    path;
    HMTNODE         newNode;
    HMTNODE         insertAfter;
    DWORD           flag;
};


// The following are values of params sent to the views OnUpdate(lHint, pHint)
// lHint will be one of the VIEW_UPDATE_xxx's defined below.
// pHint will be a ptr to SViewUpdateInfo struct.

// VIEW_UPDATE_ADD is sent when a new node needs to be added.
// SViewUpdateInfo.flag         - unused
// SViewUpdateInfo.newNode      - the new node to be added
// SViewUpdateInfo.path         _ the path to the new node's parent node.
//
#define VIEW_UPDATE_ADD             786


// VIEW_UPDATE_SELFORDELETE is sent when a node needs to ABOUT to be deleted.
// SViewUpdateInfo.flag         - 0 => delete only child items.
//                              - DELETE_THIS => delete this item.
// SViewUpdateInfo.newNode      - unused
// SViewUpdateInfo.path         _ the path to node that is being deleted.
//
#define VIEW_UPDATE_SELFORDELETE    787

// VIEW_UPDATE_DELETE is sent when a node needs to be deleted.
// SViewUpdateInfo.flag         - 0 => delete only child items.
//                              - DELETE_THIS => delete this item.
// SViewUpdateInfo.newNode      - unused
// SViewUpdateInfo.path         _ the path to the new node's parent node.
//
#define VIEW_UPDATE_DELETE          788
#define VUI_DELETE_THIS             1
#define VUI_DELETE_SETAS_EXPANDABLE 2


// VIEW_UPDATE_DELETE_EMPTY_VIEW is sent after the VIEW_UPDATE_DELETE is sent.
// No parameters.
#define VIEW_UPDATE_DELETE_EMPTY_VIEW   789


// VIEW_UPDATE_MODIFY is sent when a node needs to be modified.
// SViewUpdateInfo.flag         - REFRESH_NODE => Only node needs to be refreshed
//                                REFRESH_RESULTVIEW => Both node and result view need refresh. 
// SViewUpdateInfo.newNode      - unused
// SViewUpdateInfo.path         _ the path to the new node's parent node.
//
#define VIEW_UPDATE_MODIFY          790
#define VUI_REFRESH_NODE            1


#define VIEW_RESELECT               791

// VIEW_UPDATE_TASKPAD_NAVIGATION is sent to refresh the navigation controls of
// all console taskpad views.
// SViewUpdateInfo.flag         - unused
// SviewUpdateInfo.newNode      - node that needs refreshing (always a taskpad group node)
// SViewUpdateInfo.path         - unused
#define VIEW_UPDATE_TASKPAD_NAVIGATION 792

class CSafeGlobalUnlock
{
public:
    CSafeGlobalUnlock(HGLOBAL h) : m_h(h)
    {
    }
    ~CSafeGlobalUnlock()
    {
        ::GlobalUnlock(m_h);
    }

private:
    HGLOBAL m_h;
};



enum EVerb
{
    evNone,
    evOpen,      
    evCut,       
    evCopy,      
    evPaste,     
    evDelete,    
    evPrint,     
    evRename,    
    evRefresh,   
    evProperties,

    // must be last
    evMax
};


#define INVALID_COOKIE  ((long)-10)


#endif // __AMC_PRIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\autoptr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       autoptr.h
//
//--------------------------------------------------------------------------

#ifndef AUTOPTR_H_INCLUDED
#define AUTOPTR_H_INCLUDED

#ifndef ASSERT
#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif // _INC_CRTDBG
#define ASSERT(x) _ASSERT(x)
#endif // ASSERT

#include "cpputil.h"

/*+-------------------------------------------------------------------------*
 * CAutoResourceManagementBase
 *
 * This is a base class that implements common functionality for the class
 * of smart resource handlers which release resource when it's destroyed.  All
 * classes based on this class will behave identically, except the manner
 * in which they release their resources.
 *
 * DeleterClass is typically the class that derives from CAutoResourceManagementBase,
 * and must implement
 *
 *      static void _Delete(ResourceType h);
 *
 * See CAutoPtr below for an example.
 *--------------------------------------------------------------------------*/

template<typename ResourceType, typename DeleterClass>
class CAutoResourceManagementBase
{
    typedef CAutoResourceManagementBase<ResourceType, DeleterClass> ThisClass;
    typedef ThisClass Releaser;

    DECLARE_NOT_COPIABLE   (ThisClass)
    DECLARE_NOT_ASSIGNABLE (ThisClass)

// protected ctor so only derived classes can intantiate
protected:
    explicit CAutoResourceManagementBase(ResourceType h = 0) throw() : m_hResource(h) {}

public:
    ~CAutoResourceManagementBase() throw()
    {
        Delete();
    }

    void Attach(ResourceType p) throw()
    {
        ASSERT(m_hResource == NULL);
        m_hResource = p;
    }

    ResourceType Detach() throw()
    {
        ResourceType const p = m_hResource;
        m_hResource = NULL;
        return p;
    }

    /*
     * Returns the address of the pointer contained in this class.
     * This is useful when using the COM/OLE interfaces to create
     * allocate the object that this class manages.
     */
    ResourceType* operator&() throw()
    {
        /*
         * This object must be empty now, or the data pointed to will be leaked.
         */
        ASSERT (m_hResource == NULL);
        return &m_hResource;
    }

    operator ResourceType() const throw()
    {
        return m_hResource;
    }

    bool operator==(int p) const throw()
    {
        ASSERT(p == NULL);
        return m_hResource == NULL;
    }

    bool operator!=(int p) const throw()
    {
        ASSERT(p == NULL);
        return m_hResource != NULL;
    }

    bool operator!() const throw()
    {
        return m_hResource == NULL;
    }

    void Delete() throw()
    {
        if (m_hResource != NULL)
        {
            DeleterClass::_Delete (m_hResource);
            m_hResource = NULL;
        }
    }

private:
    ResourceType m_hResource;
}; // class CAutoResourceManagementBase


/*+-------------------------------------------------------------------------*
 * CAutoPtrBase
 *
 * This is a base class that implements common functionality for the class
 * of smart pointers which delete its pointee when it's destroyed.  All
 * classes based on this class will behave identically, except the manner
 * in which they destroy their pointees.
 *
 * DeleterClass is typically the class that derives from CAutoPtrBase, and
 * must implement
 *
 *      static void _Delete(T* p);
 *
 * This template reuses CAutoResourceManagementBase to manage the pointer
 *
 * See CAutoPtr below for an example.
 *--------------------------------------------------------------------------*/

template<typename T, typename DeleterClass>
class CAutoPtrBase : public CAutoResourceManagementBase<T*, DeleterClass>
{
    typedef CAutoPtrBase<T, DeleterClass>                 ThisClass;
    typedef CAutoResourceManagementBase<T*, DeleterClass> BaseClass;
    typedef BaseClass Releaser;

    DECLARE_NOT_COPIABLE   (ThisClass)
    DECLARE_NOT_ASSIGNABLE (ThisClass)

// protected ctor so only derived classes can intantiate
protected:
    explicit CAutoPtrBase(T* p = 0) throw() : BaseClass(p) {}

public:

    T& operator*() const throw()
    {
        T* ptr = *this; // use operator defined by the BaseClass for conversion
        ASSERT(ptr != NULL);
        return *ptr;
    }

    T* operator->() const throw()
    {
        T* ptr = *this; // use operator defined by the BaseClass for conversion
        ASSERT(ptr != NULL);
        return ptr;
    }

}; // class CAutoPtrBase


/*+-------------------------------------------------------------------------*
 * CAutoPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated with
 * operator new.
 *--------------------------------------------------------------------------*/

template<class T>
class CAutoPtr : public CAutoPtrBase<T, CAutoPtr<T> >
{
    typedef CAutoPtrBase<T, CAutoPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CAutoPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        delete p;
    }
};


/*+-------------------------------------------------------------------------*
 * CAutoArrayPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated with
 * operator new[].
 *--------------------------------------------------------------------------*/

template<class T>
class CAutoArrayPtr : public CAutoPtrBase<T, CAutoArrayPtr<T> >
{
    typedef CAutoPtrBase<T, CAutoArrayPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CAutoArrayPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        delete[] p;
    }
};


/*+-------------------------------------------------------------------------*
 * CCoTaskMemPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated with
 * CoTaskMemAlloc.
 *--------------------------------------------------------------------------*/

template<class T>
class CCoTaskMemPtr : public CAutoPtrBase<T, CCoTaskMemPtr<T> >
{
    typedef CAutoPtrBase<T, CCoTaskMemPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CCoTaskMemPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        if (p != NULL)
            CoTaskMemFree (p);
    }
};


/*+-------------------------------------------------------------------------*
 * CAutoGlobalPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated with GlobalAlloc.
 *--------------------------------------------------------------------------*/

template<class T>
class CAutoGlobalPtr : public CAutoPtrBase<T, CAutoGlobalPtr<T> >
{
    typedef CAutoPtrBase<T, CAutoGlobalPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CAutoGlobalPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        if (p != NULL)
            GlobalFree (p);
    }
};


/*+-------------------------------------------------------------------------*
 * CAutoLocalPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated with LocalAlloc.
 *--------------------------------------------------------------------------*/

template<class T>
class CAutoLocalPtr : public CAutoPtrBase<T, CAutoLocalPtr<T> >
{
    typedef CAutoPtrBase<T, CAutoLocalPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CAutoLocalPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        if (p != NULL)
            LocalFree (p);
    }
};


/*+-------------------------------------------------------------------------*
 * CHeapAllocMemPtr
 *
 * CAutoPtrBase-based class that deletes pointers allocated from the process
 * default heap with HeapAlloc.
 *--------------------------------------------------------------------------*/

template<class T>
class CHeapAllocMemPtr : public CAutoPtrBase<T, CHeapAllocMemPtr<T> >
{
    typedef CAutoPtrBase<T, CHeapAllocMemPtr<T> > BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CHeapAllocMemPtr(T* p = 0) throw() : BaseClass(p)
    {}

private:
    // only CAutoPtrBase should call this
    static void _Delete (T* p)
    {
        if (p != NULL)
            HeapFree(::GetProcessHeap(), 0, p);
    }
};


/*+-------------------------------------------------------------------------*
 * CAutoWin32Handle
 *
 * CAutoPtrBase-based class that closes HANDLE on destruction
 *--------------------------------------------------------------------------*/
class CAutoWin32Handle : public CAutoResourceManagementBase<HANDLE, CAutoWin32Handle>
{
    typedef CAutoResourceManagementBase<HANDLE, CAutoWin32Handle> BaseClass;
    friend BaseClass::Releaser;

public:
    explicit CAutoWin32Handle(HANDLE p = NULL) throw() : BaseClass(p) {}

    bool IsValid()
    {
        return IsValid(*this); // use base class operator to convet to HANDLE
    }
private:
    static bool IsValid (HANDLE p)
    {
        return (p != NULL && p != INVALID_HANDLE_VALUE);
    }
    // only CAutoResourceManagementBase should call this
    static void _Delete (HANDLE p)
    {
        if (IsValid(p))
            CloseHandle(p);
    }
};

/*+-------------------------------------------------------------------------*
 * CAutoAssignOnExit
 *
 * instances of this template class assign the value in destructor.
 *
 * USAGE: Say you have variable "int g_status" which must be set to S_OK before
 *        you leave the function. To do so declare following in the function:
 *
 *        CAutoAssignOnExit<int,S_OK>  any_object_name(g_status);
 *--------------------------------------------------------------------------*/
template<typename T, T value>
class CAutoAssignOnExit
{
    T& m_rVariable; // variable, which needs to be modified in destructor
public:
    // constructor
    CAutoAssignOnExit( T& rVariable ) : m_rVariable(rVariable) {}
    // destructor
    ~CAutoAssignOnExit()
    {
        // assign designated final value
        m_rVariable = value;
    }
};

#endif // AUTOPTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\axhostwindow2.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File:      AxHostWindow2.h
 *
 *  Contents:  Header file for CAxHostWindow2T. Refer to MSJ, December 1999.
 *
 *  History:   30-Nov-99 VivekJ     Created
 *
 *--------------------------------------------------------------------------*/

#pragma once
#ifndef __AXHOSTWINDOW2_H_
#define __AXHOSTWINDOW2_H_


template <typename TFrameWindow> class CSimpleFrameSite;
//------------------------------------------------------------------------------------------------------------------
//
//
//------------------------------------------------------------------------------------------------------------------

template<typename TFrameWindow>
class ATL_NO_VTABLE CAxHostWindow2T :       public CAxHostWindow/*, 
                                            public IPersistPropertyBagImpl<CAxHostWindow2T>, 
                                            public IPersistStreamInitImpl<CAxHostWindow2T>*/
{
public:
    CAxHostWindow2T()
    {
        m_bUserMode = false;
        m_bMessageReflect = false;
        m_ContainerPages.cElems = 0;
        m_ContainerPages.pElems = 0;
    }
    
    ~CAxHostWindow2T()
    {
        if(m_ContainerPages.cElems >=1)
            CoTaskMemFree(m_ContainerPages.pElems);
    }

    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    
    typedef CAxHostWindow2T<TFrameWindow> thisClass;
    typedef CSimpleFrameSite<TFrameWindow> simpleFrameClass;
    BEGIN_COM_MAP(thisClass)
       //COM_INTERFACE_ENTRY(IPersistPropertyBag)
       //COM_INTERFACE_ENTRY(IPersistStreamInit)
       COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(IID_ISimpleFrameSite,simpleFrameClass, m_spUnkSimpleFrameSite.p)
       COM_INTERFACE_ENTRY_NOINTERFACE(IOleContainer) //yes!!
       COM_INTERFACE_ENTRY_CHAIN(CAxHostWindow)
    END_COM_MAP()
    
public:


BEGIN_PROP_MAP(thisClass)
    PROP_ENTRY("AllowWindowlessActivation"  ,   0x60020000, CLSID_NULL)
    PROP_ENTRY("BackColor"                  ,   DISPID_AMBIENT_BACKCOLOR, CLSID_NULL)
    PROP_ENTRY("ForeColor"                  ,   DISPID_AMBIENT_FORECOLOR, CLSID_NULL)
    PROP_ENTRY("LocaleID"                   ,   DISPID_AMBIENT_LOCALEID, CLSID_NULL)
    PROP_ENTRY("UserMode"                   ,   DISPID_AMBIENT_USERMODE, CLSID_NULL)
    
    PROP_ENTRY("DisplayAsDefault"           ,   DISPID_AMBIENT_DISPLAYASDEFAULT, CLSID_NULL)
    PROP_ENTRY("Font"                       ,   DISPID_AMBIENT_FONT, CLSID_NULL)
    PROP_ENTRY("MessageReflect"             ,   DISPID_AMBIENT_MESSAGEREFLECT, CLSID_NULL)
    PROP_ENTRY("ShowGrabHandles"            ,   DISPID_AMBIENT_SHOWGRABHANDLES, CLSID_NULL)
    PROP_ENTRY("ShowHatching"               ,   DISPID_AMBIENT_SHOWHATCHING, CLSID_NULL)

    PROP_ENTRY("DocHostFlags"               ,   0x60020012, CLSID_NULL)
    PROP_ENTRY("DocHostDoubleClickFlags"    ,   0x60020014, CLSID_NULL)
    PROP_ENTRY("AllowContextMenu"           ,   0x60020016, CLSID_NULL)
    PROP_ENTRY("AllowShowUI"                ,   0x60020018, CLSID_NULL)
    PROP_ENTRY("OptionKeyPath"              ,   0x6002001a, CLSID_NULL)
END_PROP_MAP()
public:

    STDMETHOD(CreateControlEx)(LPCOLESTR lpszTricsData, HWND hWnd, IStream* pStream, IUnknown** ppUnk, REFIID iidAdvise, IUnknown* punkSink)
    {
        HRESULT hr = S_FALSE;

        ReleaseAll();

        if (m_hWnd != NULL)
        {
            RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
            ReleaseWindow();
        }

        if (::IsWindow(hWnd))
        {
            USES_CONVERSION;
            SubclassWindow(hWnd);
            if (m_clrBackground == NULL)
            {
                if (IsParentDialog())
                    m_clrBackground = GetSysColor(COLOR_BTNFACE);
                else
                    m_clrBackground = GetSysColor(COLOR_WINDOW);
            }

            bool bWasHTML;
            hr = CreateNormalizedObjectEx(lpszTricsData, IID_IUnknown, (void**)ppUnk, bWasHTML);
            bool bInited = hr == S_FALSE;

            if (SUCCEEDED(hr))
                hr = ActivateAx(*ppUnk, bInited, pStream);

            
            //Try to hook up any sink the user might have given us.
            m_iidSink = iidAdvise;
            if(SUCCEEDED(hr) && *ppUnk && punkSink)
                AtlAdvise(*ppUnk, punkSink, m_iidSink, &m_dwAdviseSink);

            if (SUCCEEDED(hr) && bWasHTML && *ppUnk != NULL)
            {
                if ((GetStyle() & (WS_VSCROLL | WS_HSCROLL)) == 0)
                    m_dwDocHostFlags |= DOCHOSTUIFLAG_SCROLL_NO;
                else
                {
                    DWORD dwStyle = GetStyle();
                    SetWindowLong(GWL_STYLE, dwStyle & ~(WS_VSCROLL | WS_HSCROLL));
                    SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSIZE | SWP_FRAMECHANGED | SWP_DRAWFRAME);
                }

                CComPtr<IUnknown> spUnk(*ppUnk);
                // Is it just plain HTML?
                USES_CONVERSION;
                if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
                    (lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
                    (lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
                    (lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
                    (lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
                    (lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
                    (lpszTricsData[6] == OLECHAR(':')))
                {
                    // Just HTML, eh?
                    CComPtr<IPersistStreamInit> spPSI;
                    hr = spUnk->QueryInterface(IID_IPersistStreamInit, (void**)&spPSI);
                    spPSI->InitNew();
                    bInited = TRUE;
                    CComPtr<IHTMLDocument2> spHTMLDoc2;
                    hr = spUnk->QueryInterface(IID_IHTMLDocument2, (void**)&spHTMLDoc2);
                    if (SUCCEEDED(hr))
                    {
                        CComPtr<IHTMLElement> spHTMLBody;
                        hr = spHTMLDoc2->get_body(&spHTMLBody);
                        if (SUCCEEDED(hr))
                            hr = spHTMLBody->put_innerHTML(CComBSTR(lpszTricsData + 7));
                    }
                }
                else
                {
                    CComPtr<IWebBrowser2> spBrowser;
                    spUnk->QueryInterface(IID_IWebBrowser2, (void**)&spBrowser);
                    if (spBrowser)
                    {
                        CComVariant ve;
                        CComVariant vurl(lpszTricsData);
    #pragma warning(disable: 4310) // cast truncates constant value
                        spBrowser->put_Visible(VARIANT_TRUE);
    #pragma warning(default: 4310) // cast truncates constant value
                        spBrowser->Navigate2(&vurl, &ve, &ve, &ve, &ve);
                    }
                }

            }
            if (FAILED(hr) || m_spUnknown == NULL)
            {
                // We don't have a control or something failed so release
                ReleaseAll();

                if (m_hWnd != NULL)
                {
                    RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
                    if (FAILED(hr))
                        ReleaseWindow();
                }
            }
        }
        return hr;
    }
    //We support licensing
    virtual HRESULT CreateLicensedControl(REFCLSID clsid,REFIID riid, void** ppvObj,bool& bIsItLicensed)
    {
        CComPtr<IClassFactory2> spCF2;
        bIsItLicensed = false;
        HRESULT hr = CoGetClassObject(clsid,CLSCTX_SERVER,0,IID_IClassFactory2,(void**)&spCF2);
        if(FAILED(hr)) return hr;
                
        bIsItLicensed = true;
        LICINFO licInfo;
        licInfo.cbLicInfo = sizeof(LICINFO);
        hr = spCF2->GetLicInfo(&licInfo);

        if(FAILED(hr)) 
        {
            ::MessageBox(NULL,_T("License Key for this component not found. You do not have the appropriate license to use this component in the design environment"),_T("Licensing Error"),MB_OK);
            return hr;
        }
        BSTR strKey = 0;
        if(licInfo.fRuntimeKeyAvail) 
        {
            hr = spCF2->RequestLicKey(0,&strKey);
        }
        
        if(SUCCEEDED(hr) || licInfo.fLicVerified)
        {
            hr = spCF2->CreateInstanceLic(NULL,NULL,riid,strKey,ppvObj);
            if(strKey) { ::SysFreeString(strKey); }
            return hr;
        }

        ::MessageBox(NULL,_T("License Key for this component not found. You do not have the appropriate license to use this component in the design environment"),_T("Licensing Error"),MB_OK);
        return hr;
    }

    virtual HRESULT CreateNormalizedObjectEx(LPCOLESTR lpszTricsData, REFIID riid, void** ppvObj, bool& bWasHTML)
    {
        ATLASSERT(ppvObj);

        CLSID clsid;
        HRESULT hr = E_FAIL;
        bWasHTML = false;
        *ppvObj = NULL;

        if (lpszTricsData == NULL || lpszTricsData[0] == 0){ return S_OK; }

        // Is it HTML ?
        USES_CONVERSION;
        if ((lpszTricsData[0] == OLECHAR('M') || lpszTricsData[0] == OLECHAR('m')) &&
            (lpszTricsData[1] == OLECHAR('S') || lpszTricsData[1] == OLECHAR('s')) &&
            (lpszTricsData[2] == OLECHAR('H') || lpszTricsData[2] == OLECHAR('h')) &&
            (lpszTricsData[3] == OLECHAR('T') || lpszTricsData[3] == OLECHAR('t')) &&
            (lpszTricsData[4] == OLECHAR('M') || lpszTricsData[4] == OLECHAR('m')) &&
            (lpszTricsData[5] == OLECHAR('L') || lpszTricsData[5] == OLECHAR('l')) &&
            (lpszTricsData[6] == OLECHAR(':')))
        {
            // It's HTML, so let's create mshtml
            hr = CoCreateInstance(CLSID_HTMLDocument, NULL, CLSCTX_SERVER, riid, ppvObj);
            bWasHTML = true;
        }
        if (FAILED(hr))
        {
            // Can't be clsid, or progid if length is grater than 255
            if (ocslen(lpszTricsData) < 255)
            {
                if (lpszTricsData[0] == '{') // Is it a CLSID?
                    hr = CLSIDFromString((LPOLESTR)lpszTricsData, &clsid);
                else
                    hr = CLSIDFromProgID((LPOLESTR)lpszTricsData, &clsid); // How about a ProgID?
                
                if (SUCCEEDED(hr))  // Aha, it was one of those two
                {
                    //check if its a licensed control
                    //TODO: The usermode and binary persistence needs to act here
                    bool bLicensed = false;
                    hr = CreateLicensedControl(clsid,riid,ppvObj,bLicensed);
                    if(SUCCEEDED(hr) || ( bLicensed && FAILED(hr) ) )
                        return hr;

                    //create the control in a normal way - it does not support licensing
                    hr = CoCreateInstance(clsid, NULL, CLSCTX_SERVER, riid, ppvObj);
                }
            }
            if (FAILED(hr))
            {
                // Last guess - it must be either a URL so let's create shdocvw
                hr = CoCreateInstance(CLSID_WebBrowser, NULL, CLSCTX_SERVER, riid, ppvObj);
                bWasHTML = true;
            }
        }

        return hr;
    }
public:
    virtual void OnFinalMessage(HWND hWnd)
    {
        FinalRelease();
        GetControllingUnknown()->Release();
    }

public: //modified methods
    STDMETHOD(GetContainer)(IOleContainer** ppContainer)
    {
        if(!ppContainer) return E_POINTER;
        if(m_spOleContainer)
            return (*ppContainer = m_spOleContainer)->AddRef(), S_OK;
        *ppContainer = 0;
        return E_NOINTERFACE;
    }
    STDMETHOD(GetExtendedControl)(IDispatch** ppDisp)
    {
        if(!ppDisp) return E_POINTER;
        if(m_spExtendedDispatch)
            return (*ppDisp = m_spExtendedDispatch)->AddRef(), S_OK;
        *ppDisp = 0;
        return E_NOTIMPL;
    }

    STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo)
    {
        if (ppFrame == NULL || ppDoc == NULL || lprcPosRect == NULL || lprcClipRect == NULL || !m_spInPlaceFrame || !m_spInPlaceUIWindow || !m_pContainerFrame)
        {
            return E_POINTER;
        }
                
        m_spInPlaceFrame.CopyTo(ppFrame);
        m_spInPlaceUIWindow.CopyTo(ppDoc);
        GetClientRect(lprcPosRect);
        GetClientRect(lprcClipRect);
        
        pFrameInfo = m_pContainerFrame->GetInPlaceFrameInfo();
        return S_OK;
    }
    STDMETHOD(ShowPropertyFrame)()
    {
        HRESULT hr = E_FAIL;
        if(m_ContainerPages.cElems <= 0) return hr;
        
        CComPtr<ISpecifyPropertyPages> spSpecifyPages;
        hr = QueryControl(IID_ISpecifyPropertyPages,(void**)&spSpecifyPages);
        if(FAILED(hr)) return hr;
        
        CAUUID pages;
        hr = spSpecifyPages->GetPages(&pages);
        if(FAILED(hr)) return hr;

        CComQIPtr<IOleObject> spObj(spSpecifyPages);
        CComPtr<IUnknown> spUnk = spSpecifyPages;
        if(!spObj || !spUnk)  return E_NOINTERFACE; 
    
        
        UINT nOldElems = pages.cElems;
        pages.cElems += m_ContainerPages.cElems;        
        pages.pElems = (GUID *)::CoTaskMemRealloc(pages.pElems, pages.cElems * sizeof(CLSID));
        
        for(UINT n = 0; n < m_ContainerPages.cElems; n++)
        {
            pages.pElems[nOldElems + n] = m_ContainerPages.pElems[n];   
        }
        LPOLESTR szTitle = NULL;

        spObj->GetUserType(USERCLASSTYPE_SHORT, &szTitle);

        RECT rcPos;
        ::GetClientRect(m_hWnd,&rcPos);
        
        m_pContainerFrame->SetDirty(true);
                    
        hr = OleCreatePropertyFrame(m_pContainerFrame->m_hWnd, rcPos.top, rcPos.left, szTitle,
            1, &spUnk.p, pages.cElems, pages.pElems, LOCALE_USER_DEFAULT, 0, 0);

        CoTaskMemFree(szTitle);
        CoTaskMemFree(pages.pElems);
        
        return hr;
    }
    
    void ReleaseAll()
    {
        if (m_bReleaseAll)
            return;
        m_bReleaseAll = TRUE;

        if (m_spViewObject != NULL)
            m_spViewObject->SetAdvise(DVASPECT_CONTENT, 0, NULL);

        if(m_dwAdviseSink != 0xCDCDCDCD)
        {
            AtlUnadvise(m_spUnknown, m_iidSink, m_dwAdviseSink);
            m_dwAdviseSink = 0xCDCDCDCD;
        }

        if (m_spOleObject)
        {
            m_spOleObject->Unadvise(m_dwOleObject);
            m_spOleObject->Close(OLECLOSE_NOSAVE);
            m_spOleObject->SetClientSite(NULL);
        }

        if (m_spUnknown != NULL)
        {
            CComPtr<IObjectWithSite> spSite;
            m_spUnknown->QueryInterface(IID_IObjectWithSite, (void**)&spSite);
            if (spSite != NULL)
                spSite->SetSite(NULL);
        }

        m_spViewObject.Release();
        m_dwViewObjectType = 0;

        m_spInPlaceObjectWindowless.Release();
        m_spOleObject.Release();
        m_spUnknown.Release();

        m_bInPlaceActive = FALSE;
        m_bWindowless = FALSE;
        m_bInPlaceActive = FALSE;
        m_bUIActive = FALSE;
        m_bCapture = FALSE;
        m_bReleaseAll = FALSE;
    }

    STDMETHOD(AttachControl)(IUnknown* pUnkControl, HWND hWnd)
    {
        HRESULT hr = S_FALSE;

        ReleaseAll();

        if (m_hWnd != NULL)
        {
            RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
            ReleaseWindow();
        }

        if (::IsWindow(hWnd))
        {
            SubclassWindow(hWnd);

            hr = ActivateAx(pUnkControl, TRUE, NULL);

            if (FAILED(hr))
            {
                ReleaseAll();

                if (m_hWnd != NULL)
                {
                    RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE | RDW_INTERNALPAINT | RDW_FRAME);
                    ReleaseWindow();
                }
            }
        }
        return hr;
    }

    void FinalRelease()
    {
        CAxHostWindow::FinalRelease();
    }

public:
    unsigned                                                                m_bRequiresSave:1;
    CComPtr<IUnknown>                                                       m_spUnkSimpleFrameSite;
    CComPtr<IOleContainer>                                                  m_spOleContainer;   
    CComPtr<IDispatch>                                                      m_spExtendedDispatch;
    CAUUID                                                                  m_ContainerPages;
    TFrameWindow                                                            *m_pContainerFrame;
};

//--------------------------------------------------------------------------------------------------------------------
//*Very Very* Simple SimpleFrameSite impl
//SimpleFrameSite tear-off atop the Site - very basic message routing 
//one Known control that implements it for our test cases is(sad we cant use VB's intrinsic ones) - MS tabbed Dialog(Sheridan's)
//(not to be confused with MS tabstrip control)
//------------------------------------------------------------------------------------------------------------------
template <typename TFrameWindow>
class ATL_NO_VTABLE CSimpleFrameSite:   public ISimpleFrameSite,
                                        public CComTearOffObjectBase<CAxHostWindow2T<TFrameWindow> >
{
public:
    CSimpleFrameSite(){}
    ~CSimpleFrameSite(){}

    typedef CSimpleFrameSite<TFrameWindow> thisClass;
    
    BEGIN_COM_MAP(thisClass)
        COM_INTERFACE_ENTRY(ISimpleFrameSite)
    END_COM_MAP()
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()

public:
    //ISimpleFrameSite
    STDMETHODIMP PreMessageFilter(/* [in] */ HWND hWnd,/* [in] */ UINT msg,/* [in] */ WPARAM wp,
                                /* [in] */ LPARAM lp,/* [out] */ LRESULT *plResult,
                                /* [out] */ DWORD *pdwCookie)
    {
        if(!plResult || !pdwCookie) { return E_POINTER; }
        HWND hWndChild = GetAxWindow(hWnd);
            
        if(hWndChild && ((msg == WM_PAINT)||(msg == WM_KEYDOWN)) )
        {
            ATLTRACE("\nPreMessageFilter called !!\n");
            *plResult = 0;
            ::SendMessage(hWndChild,msg,wp,lp);
        }
        
        return S_OK;
    }

    
    STDMETHODIMP PostMessageFilter(/* [in] */ HWND hWnd,/* [in] */ UINT msg,/* [in] */ WPARAM wp,
                                /* [in] */  LPARAM lp,/* [out] */ LRESULT *plResult,/* [in] */ DWORD dwCookie)
    {
        if(!plResult) { return E_POINTER; }
                
        HWND hWndChild = GetAxWindow(hWnd);
        if(hWndChild && ((msg == WM_PAINT)||(msg == WM_KEYDOWN))  )
        {
            ATLTRACE("\nPostMessageFilter called !!\n");
            *plResult = 0;
        }
        
        return S_OK;
    }

protected:
    HWND GetAxWindow(HWND& hWnd)
    {
        HWND hWndChild = GetWindow(hWnd,GW_CHILD);
            
        TCHAR pszClassName[100];
        if(hWndChild)
        {
            for(;;)
            {
                GetClassName(hWndChild,pszClassName,100);
                if(lstrcmp(pszClassName, _T("AtlAxWinEx") ) ==0 )
                {
                    return ::GetWindow(hWndChild,GW_CHILD);
                }
                else
                {
                    return hWndChild;
                }
            }
        }
        return 0;
    }

};

#endif
//--------------------------------------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\axwin2.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File:      AxHostWindow2.h
 *
 *  Contents:  Header file for CAxWindowT2. Refer to MSJ, December 1999.
 *
 *  History:   30-Nov-99 VivekJ     Created
 *
 *--------------------------------------------------------------------------*/
#pragma once
#ifndef __AXWIN2_H__
#define __AXWIN2_H__

template <typename TBase = CWindow>
class CAxWindowT2 : public CAxWindowT<TBase>
{
public:
    CAxWindowT2(HWND hwnd = 0) : CAxWindowT<TBase>(hwnd) {}

    HRESULT CreateControl(LPCOLESTR lpszName, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
    {
        return CreateControlEx(lpszName, pStream, ppUnkContainer);
    }
    
    HRESULT CreateControl(DWORD dwResID, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
    {
        return CreateControlEx(dwResID, pStream, ppUnkContainer);
    }
    
    HRESULT CreateControlEx(DWORD dwResID,  IStream* pStream = NULL, 
                            IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
                            REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
    {
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
        
        CComBSTR bstrURL(OLESTR("res://"));
        bstrURL.Append(szModule);
        bstrURL.Append(OLESTR("/"));
        TCHAR szResID[11];
        wsprintf(szResID, _T("%0d"), dwResID);
        bstrURL.Append(szResID);
        
        return CreateControlEx(bstrURL, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
    }
    
    HRESULT CreateControlEx(LPCOLESTR lpszName, IStream* pStream = NULL, 
                            IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
                            REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        
        HRESULT hr = E_FAIL;
        CComPtr<IAxWinHostWindow> spAxWindow;
        
        // Reuse existing CAxHostWindow
        hr = QueryHost(&spAxWindow);
        if( SUCCEEDED(hr) )
        {
            CComPtr<IUnknown> spunkControl;
            hr = spAxWindow->CreateControlEx(lpszName, m_hWnd, pStream, &spunkControl, iidSink, punkSink);
            if( FAILED(hr) ) return hr;
        
            if( ppUnkControl ) (*ppUnkControl = spunkControl)->AddRef();
            if( ppUnkContainer ) (*ppUnkContainer = spAxWindow)->AddRef();
        }
        // Create a new CAxHostWindow
        else
        {
            return AtlAxCreateControlEx(lpszName, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
        }

        return S_OK;
    }
    
    HRESULT AttachControl(IUnknown* pControl, IUnknown** ppUnkContainer = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        
        HRESULT hr = E_FAIL;
        CComPtr<IAxWinHostWindow> spAxWindow;
        
        // Reuse existing CAxHostWindow
        hr = QueryHost(&spAxWindow);
        if( SUCCEEDED(hr) )
        {
            hr = spAxWindow->AttachControl(pControl, m_hWnd);
            if( FAILED(hr) ) return hr;
        
            if( ppUnkContainer ) (*ppUnkContainer = spAxWindow)->AddRef();
        }
        // Create a new CAxHostWindow
        else
        {
            return AtlAxAttachControl(pControl, m_hWnd, ppUnkContainer);
        }

        return S_OK;
    }
};

typedef CAxWindowT2<CWindow> CAxWindow2;

#endif  // __AXWIN2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\bitmap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       bitmap.h
//
//--------------------------------------------------------------------------

// bitmap.h : definition file
//


#ifndef __BITMAP__H__
#define __BITMAP__H__

    HBITMAP CopyBitmap(HBITMAP hbm);

#endif //__BITMAP__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\baseapi.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      baseapi.h
 *
 *  Contents:  Definition for MMCBASE_API
 *
 *  History:   13-Apr-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

// The following ifdef block is the standard way of creating macros which make exporting
// from a DLL simpler. All files within this DLL are compiled with the MMCBASE_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see
// MMCBASE_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef MMCBASE_EXPORTS
	#define MMCBASE_API __declspec(dllexport)
#else
	#define MMCBASE_API __declspec(dllimport)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\base64.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      base64.h
 *
 *  Contents:  Implements encoding / decoding table for base64 format
 *
 *  History:   17-Dec-99 audriusz   Created
 *
 *--------------------------------------------------------------------------*/


/*+-------------------------------------------------------------------------*
 * class base64_table
 *
 * PURPOSE: Class maintains Base64 conversion templates. It exposes static methods 
 *          to both encode and decode Base64 data
 *
 * USAGE:   call static methods to encode/decode one piece of data (24 bites or less)
 *
 *+-------------------------------------------------------------------------*/
class base64_table
{
protected:
    static BYTE _six2pr64[64];
    static BYTE _pr2six[256]; 
public:
    base64_table();
    int decode4(BYTE * src, int nChars, BYTE * dest);
    BYTE map2six(BYTE bt);
    // static functions used for zero terminated LPOLESTR format data only
    static void encode(const BYTE * &src, DWORD &cbInput, LPOLESTR &dest);
    static bool decode(LPCOLESTR &src, BYTE * &dest);
};


/*+-------------------------------------------------------------------------*
 *
 * METHOD: base64_table::map2six
 *
 * PURPOSE: maps symbols to 6bit value if smb is valid, 0xff else
 *
 *+-------------------------------------------------------------------------*/
inline BYTE base64_table::map2six(BYTE bt)
{
    return (bt > 255 ? 0xff : _pr2six[bt]);
}

/*+-------------------------------------------------------------------------*
 *
 * METHOD: base64_table::decode4
 *
 * PURPOSE: glues 3 bytes from stored 6bit values
 *
 * NOTE: gluing is done in place - data pointed by src is destroyed
 *
 *+-------------------------------------------------------------------------*/
inline int base64_table::decode4(BYTE * src, int nChars, BYTE * dest)
{
    // glue to form 3 full bytes
    src[0] <<= 2; src[0] |= (src[1] >> 4);
    src[1] <<= 4; src[1] |= (src[2] >> 2);
    src[2] <<= 6; src[2] |= (src[3] );

    // now store as many bytes as have complete set of bites;
    // int nFull = nChars*6/8; // it actually boils to 0 or nChars - 1, whichever is bigger
    for (int i=0; i< nChars-1; i++)
        *dest++ = src[i];

    return nChars ? nChars - 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\bookmark.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      bookmark.h
 *
 *  Contents:  Interface file for CBookmark
 *
 *  History:   05-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef BOOKMARK_H
#define BOOKMARK_H
#pragma once

#include <windows.h>
#include <vector>
#include <objbase.h>
#include "ndmgr.h"
#include "ndmgrpriv.h"
#include "stddbg.h"
#include "stgio.h"
#include "xmlbase.h"

typedef std::vector<BYTE>               ByteVector;
#define BOOKMARK_CUSTOMSTREAMSIGNATURE  "MMCCustomStream"

/*+-------------------------------------------------------------------------*
 * class CDynamicPathEntry
 * 
 *
 * PURPOSE: Encapsulates a single entry in the dynamic path of a bookmark.
 *
 *+-------------------------------------------------------------------------*/
class CDynamicPathEntry : public CXMLObject
{
protected:
    enum PathEntryType
    {
        NDTYP_STRING = 0x01,
        NDTYP_CUSTOM = 0x02
    };

public:
    // comparison
    bool    operator ==(const CDynamicPathEntry &rhs) const;
    bool    operator < (const CDynamicPathEntry &rhs) const;

    SC      ScInitialize(bool bIs10Path, /*[IN,OUT]*/ByteVector::iterator &iter);
    void    Write (ByteVector& v) const;  // write the contents to a byte vector

    virtual void Persist(CPersistor &persistor);
    DEFINE_XML_TYPE(XML_TAG_DYNAMIC_PATH_ENTRY);
protected:
    BYTE        m_type;         // string or custom ID?
    // compiler error C2621 prevents making the next two fields a union.
    ByteVector   m_byteVector;   // the actual data if it is a custom ID
    std::wstring m_strEntry;     // the actual data if it is a string.
};

/*+-------------------------------------------------------------------------*
 * class CBookmark
 * 
 *
 * PURPOSE: Maintains a persistent representation of a scope node.
 *
 *+-------------------------------------------------------------------------*/
class CBookmark : public CXMLObject
{
    friend class CScopeTree;
    typedef std::list<CDynamicPathEntry> CDynamicPath;

public:
    enum { ID_Unknown = -1 };

    CBookmark(MTNODEID idStatic = ID_Unknown) : m_idStatic (idStatic) , m_bIsFastBookmark(true) {}
    CBookmark(bool bIsFastBookmark)           : m_idStatic (0),         m_bIsFastBookmark(bIsFastBookmark) {}

    virtual ~CBookmark ()           {}
    bool    IsValid  ()      const  { return (m_idStatic != ID_Unknown); }
    bool    IsStatic ()      const  { ASSERT (IsValid());  return (m_dynamicPath.empty()); }
    bool    IsDynamic ()     const  { return (!IsStatic());}
    void    Reset()                 {m_idStatic = ID_Unknown; m_dynamicPath.clear();}

    IStream & Load(IStream &stm);
    IStream & Save(IStream &stm) const;

    // Casts
    operator HBOOKMARK()    const;
    static CBookmark * GetBookmark(HBOOKMARK hbm);

    // XML
    DEFINE_XML_TYPE(XML_TAG_BOOKMARK);
    virtual void Persist(CPersistor &persistor);

public:
    bool operator ==(const CBookmark& other) const;
    bool operator !=(const CBookmark& other) const;
    bool operator < (const CBookmark& other) const;

    void SetFastBookmark(bool b) {m_bIsFastBookmark = b;}

protected:
    MTNODEID        m_idStatic;
    CDynamicPath    m_dynamicPath;

protected:
     bool   m_bIsFastBookmark;
     bool   IsFastBookmark() {return m_bIsFastBookmark;}
};


inline IStream& operator>> (IStream& stm, CBookmark& bm)
{
    return bm.Load(stm);
}

inline IStream& operator<< (IStream& stm, const CBookmark& bm)
{
    return bm.Save(stm);
}

#include "bookmark.inl"

#endif // BOOKMARK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\comdbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       comdbg.h
//
//--------------------------------------------------------------------------

#ifndef COMDBG_H
#define COMDBG_H

#include <objidl.h>
#include <comdef.h>
#include <atlbase.h>
#include <atlcom.h>
#include "dbg.h"

#ifdef DBG
//#define COMDBG
#endif

#ifdef COMDBG
inline void DumpStorage(IStorage* pStorage)
{
    ASSERT(pStorage != NULL);
    if (pStorage == NULL)
        return;

    STATSTG s;
    HRESULT hr = pStorage->Stat(&s, STATFLAG_DEFAULT);
    ASSERT(hr == S_OK);
    if (hr != S_OK)
        return;
    TRACE(L"%s->\n", s.pwcsName);
    CoTaskMemFree(s.pwcsName);

    IEnumSTATSTGPtr spElements;
    hr = pStorage->EnumElements(0, NULL, 0, &spElements);
    ASSERT(hr == S_OK || hr == STG_E_ACCESSDENIED);

    if (hr == STG_E_ACCESSDENIED)
        TRACE(L"    (not enumerating contents of write-only storage)\n", s.pwcsName);
    if (hr != S_OK)
        return;

    do
    {
        ULONG numberReturned;
        hr = spElements->Next(1, &s, &numberReturned);
        if (hr != S_OK || numberReturned != 1)
            return;
        if (s.type == STGTY_STORAGE)
            TRACE(L"    [%s]\n", s.pwcsName);
        else 
            TRACE(L"    %s (%u bytes)\n", s.pwcsName, s.cbSize.LowPart);
        CoTaskMemFree(s.pwcsName);
    } while (true);
}

class ProxyReporter
{
public:
    ProxyReporter()
        : m_LastName(L"Unnamed"), m_LastInterface(L"Unknown"), m_LastThis(UINT_PTR(this))
    {
        TRACE(L"<PR>(%s(%s:%X)) is crowning.\n", GetLastInterface(), GetLastName(), GetLastThis());
    }

    virtual ~ProxyReporter()
    {
        TRACE(L"<PR>(%s(%s:%X)) is dead.\n", GetLastInterface(), GetLastName(), m_LastThis);
    }

protected:
    void Born() const
    {
        TRACE(L"<PR>(%s(%s:%X)) is alive.\n", GetLastInterface(), GetLastName(), GetLastThis());
    }

    void Dying() const
    {
        TRACE(L"<PR>(%s(%s:%X)) is dying.\n", GetLastInterface(), GetLastName(), GetLastThis());
    }

    void CallHome(const wchar_t* from) const
    {
        TRACE(L"<PR>(%s(%s:%X)#%u) calling home from: %s\n", GetLastInterface(), GetLastName(), GetLastThis(), GetRefCount(), from);
    }

    virtual const void* GetThis() const
    {
        return this;
    }

    virtual const wchar_t* GetInstanceName() const
    {
        return m_LastName;
    }

    virtual const wchar_t* GetInterfaceName() const
    {
        return m_LastInterface;
    }

    virtual unsigned GetRefCount() const
    {
        return 0;
    }

private:
    mutable const wchar_t* m_LastName;
    mutable const wchar_t* m_LastInterface;
    mutable UINT_PTR m_LastThis;

    const const wchar_t* GetLastName() const
    {
        return m_LastName = GetInstanceName();
    }

    const const wchar_t* GetLastInterface() const
    {
        return m_LastInterface = GetInterfaceName();
    }

    unsigned GetLastThis() const
    {
        return m_LastThis = UINT_PTR(GetThis());
    }

}; // class ProxyReporter

template<typename Base> 
    class ATLProxyReporter : public Base
{
public:
    ATLProxyReporter()
        : m_InstanceName(L"Unnamed")
    {
        Born();
    }

    virtual ~ATLProxyReporter()
    {
        Dying();
    }

    void InitATLProxyReporter(const wchar_t* instanceName)
    {
        ASSERT(instanceName != NULL);
        m_InstanceName = instanceName;
        CallHome(L"InitATLProxyReporter");
    }

protected:
    ULONG InternalAddRef()
    {
        const ULONG r = Base::InternalAddRef();
        CallHome(L"InternalAddRef(after)");
        return r;
    }

    ULONG InternalRelease()
    {
        CallHome(L"InternalRelease(before)");
        return Base::InternalRelease();
    }

    virtual const void* GetThis() const
    {
        return this;
    }

    virtual const wchar_t* GetInstanceName() const
    {
        ASSERT(m_InstanceName != NULL);
        return m_InstanceName;
    }

    virtual unsigned GetRefCount() const
    {
        return unsigned(m_dwRef);
    }

private:
    const wchar_t* m_InstanceName;

}; // class ATLProxyReporter

class __declspec(uuid("B425E0EC-A086-11d0-8F59-00A0C91ED3C8")) DebugStream : 
    public IStream, public CComObjectRoot, public ProxyReporter
{
public:
    DebugStream()
    {
    }

    virtual ~DebugStream()
    {
    }

    void InitDebugStream(IStream* pStream)
    {
        ASSERT(m_spStream == NULL);
        ASSERT(pStream != NULL);
        m_spStream = pStream;
    }

    BEGIN_COM_MAP(DebugStream)
        COM_INTERFACE_ENTRY_IID(__uuidof(DebugStream), DebugStream)
        COM_INTERFACE_ENTRY_IID(__uuidof(IStream), IStream)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(DebugStream)

// IStream
public:
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Read(pv, cb, pcbRead);
        CallHome(SUCCEEDED(hr) ? L"Read" : L"Read(failed!)");
        return hr;
    }
    
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Write(pv, cb, pcbWritten);
        CallHome(SUCCEEDED(hr) ? L"Write" : L"Write(failed!)");
        return hr;
    }

    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Seek(dlibMove, dwOrigin, plibNewPosition);
        CallHome(SUCCEEDED(hr) ? L"Seek" : L"Seek(failed!)");
        return hr;
    }
        
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->SetSize(libNewSize);
        CallHome(SUCCEEDED(hr) ? L"SetSize" : L"SetSize(failed!)");
        return hr;
    }
        
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
        CallHome(SUCCEEDED(hr) ? L"CopyTo" : L"CopyTo(failed!)");
        return hr;
    }
        
    STDMETHOD(Commit)(DWORD grfCommitFlags)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Commit(grfCommitFlags);
        CallHome(SUCCEEDED(hr) ? L"Commit" : L"Commit(failed!)");
        return hr;
    }
        
    STDMETHOD(Revert)()
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Revert();
        CallHome(SUCCEEDED(hr) ? L"Revert" : L"Revert(failed!)");
        return hr;
    }
        
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->LockRegion(libOffset, cb, dwLockType);
        CallHome(SUCCEEDED(hr) ? L"LockRegion" : L"LockRegion(failed!)");
        return hr;
    }
        
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->UnlockRegion(libOffset, cb, dwLockType);
        CallHome(SUCCEEDED(hr) ? L"UnlockRegion" : L"UnlockRegion(failed!)");
        return hr;
    }
        
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Stat(pstatstg, grfStatFlag);
        CallHome(SUCCEEDED(hr) ? L"Stat" : L"Stat(failed!)");
        return hr;
    }
        
    STDMETHOD(Clone)(IStream** ppstm)
    {
        ASSERT(m_spStream != NULL);
        HRESULT const hr = m_spStream->Clone(ppstm);
        CallHome(SUCCEEDED(hr) ? L"Clone" : L"Clone(failed!)");
        return hr;
    }

protected:
    virtual const wchar_t* GetInterfaceName() const
    {
        return L"DebugStream";
    }

private:
    IStreamPtr m_spStream;
}; // class DebugStream


class __declspec(uuid("B6E77CAC-A0AC-11d0-8F59-00A0C91ED3C8")) DebugStorage : 
    public IStorage, public CComObjectRoot, public ProxyReporter
{
public:
    DebugStorage()
    {
    }

    virtual ~DebugStorage()
    {
        ASSERT(m_spStorage != NULL);
        CallHome(L"~DebugStorage, elements:");
        DumpStorage(m_spStorage);
    }

    void InitDebugStorage(IStorage* pStorage)
    {
        ASSERT(m_spStorage == NULL);
        ASSERT(pStorage != NULL);
        m_spStorage = pStorage;
    }

    BEGIN_COM_MAP(DebugStorage)
        COM_INTERFACE_ENTRY_IID(__uuidof(DebugStorage), DebugStorage)
        COM_INTERFACE_ENTRY_IID(__uuidof(IStorage), IStorage)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(DebugStorage)

// IStorage
public:
    STDMETHOD(CreateStream)(const OLECHAR *pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream** ppstm)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->CreateStream(pwcsName, grfMode, reserved1, reserved2, ppstm);
        CallHomeAndDump(SUCCEEDED(hr) ? L"CreateStream" : L"CreateStream(failed!)");
        return hr;
    }
        
    STDMETHOD(OpenStream)(const OLECHAR *pwcsName, void *reserved1, DWORD grfMode, DWORD reserved2, IStream** ppstm)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->OpenStream(pwcsName, reserved1, grfMode, reserved2, ppstm);
        CallHomeAndDump(SUCCEEDED(hr) ? L"OpenStream" : L"OpenStream(failed!)");
        return hr;
    }
    
    STDMETHOD(CreateStorage)(const OLECHAR *pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStorage** ppstg)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->CreateStorage(pwcsName, grfMode, reserved1, reserved2, ppstg);
        CallHomeAndDump(SUCCEEDED(hr) ? L"CreateStorage" : L"CreateStorage(failed!)");
        return hr;
    }
    
    STDMETHOD(OpenStorage)(const OLECHAR *pwcsName, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage** ppstg)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->OpenStorage(pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstg);
        CallHomeAndDump(SUCCEEDED(hr) ? L"OpenStorage, elements:" : L"OpenStorage(failed!)");
        return hr;
    }
    
    STDMETHOD(CopyTo)(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->CopyTo(ciidExclude, rgiidExclude, snbExclude, pstgDest);
        CallHomeAndDump(SUCCEEDED(hr) ? L"CopyTo" : L"CopyTo(failed!)");
        return hr;
    }
    
    STDMETHOD(MoveElementTo)(const OLECHAR *pwcsName, IStorage *pstgDest, const OLECHAR *pwcsNewName, DWORD grfFlags)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->MoveElementTo(pwcsName, pstgDest, pwcsNewName, grfFlags);
        CallHomeAndDump(SUCCEEDED(hr) ? L"MoveElementTo" : L"MoveElementTo(failed!)");
        return hr;
    }
    
    STDMETHOD(Commit)(DWORD grfCommitFlags)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->Commit(grfCommitFlags);
        CallHomeAndDump(SUCCEEDED(hr) ? L"Commit" : L"Commit(failed!)");
        return hr;
    }
    
    STDMETHOD(Revert)()
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->Revert();
        CallHomeAndDump(SUCCEEDED(hr) ? L"Revert" : L"Revert(failed!)");
        return hr;
    }
    
    STDMETHOD(EnumElements)(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG** ppenum)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->EnumElements(reserved1, reserved2, reserved3, ppenum);
        CallHomeAndDump(SUCCEEDED(hr) ? L"EnumElements" : L"EnumElements(failed!)");
        return hr;
    }
    
    STDMETHOD(DestroyElement)(const OLECHAR* pwcsName)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->DestroyElement(pwcsName);
        CallHomeAndDump(SUCCEEDED(hr) ? L"DestroyElement" : L"DestroyElement(failed!)");
        return hr;
    }
    
    STDMETHOD(RenameElement)(const OLECHAR *pwcsOldName, const OLECHAR *pwcsNewName)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->RenameElement(pwcsOldName, pwcsNewName);
        CallHomeAndDump(SUCCEEDED(hr) ? L"RenameElement" : L"RenameElement(failed!)");
        return hr;
    }
    
    STDMETHOD(SetElementTimes)(const OLECHAR *pwcsName, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->SetElementTimes(pwcsName, pctime, patime, pmtime);
        CallHomeAndDump(SUCCEEDED(hr) ? L"SetElementTimes" : L"SetElementTimes(failed!)");
        return hr;
    }
    
    STDMETHOD(SetClass)(REFCLSID clsid)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->SetClass(clsid);
        CallHomeAndDump(SUCCEEDED(hr) ? L"SetClass" : L"SetClass(failed!)");
        return hr;
    }
    
    STDMETHOD(SetStateBits)(DWORD grfStateBits, DWORD grfMask)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->SetStateBits(grfStateBits, grfMask);
        CallHomeAndDump(SUCCEEDED(hr) ? L"SetStateBits" : L"SetStateBits(failed!)");
        return hr;
    }
    
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag)
    {
        ASSERT(m_spStorage != NULL);
        HRESULT const hr = m_spStorage->Stat(pstatstg, grfStatFlag);
        CallHomeAndDump(SUCCEEDED(hr) ? L"Stat" : L"Stat(failed!)");
        return hr;
    }

// ProxyReporter
protected:
    virtual const wchar_t* GetInterfaceName() const
    {
        return L"DebugStorage";
    }

private:
    IStoragePtr m_spStorage;

    void CallHomeAndDump(const wchar_t* from) const
    {
        CallHome(from);
        DumpStorage(m_spStorage);
    }

}; // class DebugStorage

#endif // COMDBG


/*+-------------------------------------------------------------------------*
 * CreateDebugStream
 *
 * Wrapper on IStorage::CreateStream
 *--------------------------------------------------------------------------*/

inline HRESULT CreateDebugStream(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStream** ppStream)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStream != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->CreateStream(name, grfMode, NULL, NULL, ppStream);
    return hr;

    #else // COMDBG
    IStreamPtr spStream;
    HRESULT hr = pStorage->CreateStream(name, grfMode, NULL, NULL, &spStream);
    ASSERT(SUCCEEDED(hr) && spStream != NULL);

    if (FAILED(hr))
        return (hr);
    typedef CComObject<ATLProxyReporter<DebugStream> > ProxyStreamObject;
    ProxyStreamObject* pObject;
    hr = ProxyStreamObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStream(spStream);
    hr = pObject->QueryInterface(IID_IStream, reinterpret_cast<void**>(ppStream));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT CreateDebugStream(IStorage* pStorage, const wchar_t* name, DWORD grfMode, IStream** ppStream)
{
    return (CreateDebugStream (pStorage, name, grfMode, name, ppStream));
}


/*+-------------------------------------------------------------------------*
 * OpenDebugStream
 *
 * Wrapper on IStorage::OpenStream
 *--------------------------------------------------------------------------*/

inline HRESULT OpenDebugStream(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStream** ppStream)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStream != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->OpenStream(name, NULL, grfMode, NULL, ppStream);
    return hr;

    #else // COMDBG
    IStreamPtr spStream;
    HRESULT hr = pStorage->OpenStream(name, NULL, grfMode, NULL, &spStream);
    if (FAILED(hr))
        return (hr);

    typedef CComObject<ATLProxyReporter<DebugStream> > ProxyStreamObject;
    ProxyStreamObject* pObject;
    hr = ProxyStreamObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStream(spStream);
    hr = pObject->QueryInterface(IID_IStream, reinterpret_cast<void**>(ppStream));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT OpenDebugStream(IStorage* pStorage, const wchar_t* name, DWORD grfMode, IStream** ppStream)
{
    return (OpenDebugStream (pStorage, name, grfMode, name, ppStream));
}


/*+-------------------------------------------------------------------------*
 * CreateDebugStorage
 *
 * Wrapper on IStorage::CreateStorage
 *--------------------------------------------------------------------------*/

inline HRESULT CreateDebugStorage(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStorage** ppStorage)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStorage != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->CreateStorage(name, grfMode, NULL, NULL, ppStorage);
    return hr;

    #else // COMDBG
    IStoragePtr spStorage;
    HRESULT hr = pStorage->CreateStorage(name, grfMode, NULL, NULL, &spStorage);
    ASSERT(SUCCEEDED(hr) && spStorage != NULL);

    if (FAILED(hr))
        return (hr);
    typedef CComObject<ATLProxyReporter<DebugStorage> > ProxyStorageObject;
    ProxyStorageObject* pObject;
    hr = ProxyStorageObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStorage(spStorage);
    hr = pObject->QueryInterface(IID_IStorage, reinterpret_cast<void**>(ppStorage));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT CreateDebugStorage(IStorage* pStorage, const wchar_t* name, DWORD grfMode, IStorage** ppStorage)
{
    return (CreateDebugStorage (pStorage, name, grfMode, name, ppStorage));
}


/*+-------------------------------------------------------------------------*
 * CreateDebugDocfile
 *
 * Wrapper on StgCreateDocfile
 *--------------------------------------------------------------------------*/

inline HRESULT CreateDebugDocfile(const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStorage** ppStorage)
{
    ASSERT(ppStorage != NULL);
    #ifndef COMDBG
    HRESULT hr = StgCreateDocfile(name, grfMode, NULL, ppStorage);
    return hr;

    #else // COMDBG
    IStoragePtr spStorage;
    HRESULT hr = StgCreateDocfile(name, grfMode, NULL, &spStorage);
    ASSERT(SUCCEEDED(hr) && spStorage != NULL);

    if (FAILED(hr))
        return (hr);
    typedef CComObject<ATLProxyReporter<DebugStorage> > ProxyStorageObject;
    ProxyStorageObject* pObject;
    hr = ProxyStorageObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter((instanceName) ? instanceName : L"<temporary>");
    pObject->InitDebugStorage(spStorage);
    hr = pObject->QueryInterface(IID_IStorage, reinterpret_cast<void**>(ppStorage));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT CreateDebugDocfile(const wchar_t* name, DWORD grfMode, IStorage** ppStorage)
{
    return (CreateDebugDocfile (name, grfMode, name, ppStorage));
}


/*+-------------------------------------------------------------------------*
 * OpenDebugStorage
 *
 * Wrapper on IStorage::OpenStorage
 *--------------------------------------------------------------------------*/

inline HRESULT OpenDebugStorage(IStorage* pStorage, const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStorage** ppStorage)
{
    ASSERT(pStorage != NULL);
    ASSERT(name != NULL);
    ASSERT(ppStorage != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = pStorage->OpenStorage(name, NULL, grfMode, NULL, NULL, ppStorage);
    return hr;

    #else // COMDBG
    IStoragePtr spStorage;
    HRESULT hr = pStorage->OpenStorage(name, NULL, grfMode, NULL, NULL, &spStorage);
    if (FAILED(hr))
        return (hr);

    typedef CComObject<ATLProxyReporter<DebugStorage> > ProxyStorageObject;
    ProxyStorageObject* pObject;
    hr = ProxyStorageObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStorage(spStorage);
    hr = pObject->QueryInterface(IID_IStorage, reinterpret_cast<void**>(ppStorage));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT OpenDebugStorage(IStorage* pStorage, const wchar_t* name, DWORD grfMode, IStorage** ppStorage)
{
    return (OpenDebugStorage (pStorage, name, grfMode, name, ppStorage));
}


/*+-------------------------------------------------------------------------*
 * OpenDebugStorage
 *
 * Wrapper on StgOpenStorage
 *--------------------------------------------------------------------------*/

inline HRESULT OpenDebugStorage(const wchar_t* name, DWORD grfMode, const wchar_t* instanceName, IStorage** ppStorage)
{
    ASSERT(name != NULL);
    ASSERT(ppStorage != NULL);
    ASSERT(instanceName != NULL);
    #ifndef COMDBG
    HRESULT hr = StgOpenStorage(name, NULL, grfMode, NULL, NULL, ppStorage);
    return hr;

    #else // COMDBG
    IStoragePtr spStorage;
    HRESULT hr = StgOpenStorage(name, NULL, grfMode, NULL, NULL, &spStorage);
    if (FAILED(hr))
        return (hr);

    typedef CComObject<ATLProxyReporter<DebugStorage> > ProxyStorageObject;
    ProxyStorageObject* pObject;
    hr = ProxyStorageObject::CreateInstance(&pObject);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return E_FAIL;
    pObject->InitATLProxyReporter(instanceName);
    pObject->InitDebugStorage(spStorage);
    hr = pObject->QueryInterface(IID_IStorage, reinterpret_cast<void**>(ppStorage));
    ASSERT(SUCCEEDED(hr));
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
    #endif // COMDBG
}

inline HRESULT OpenDebugStorage(const wchar_t* name, DWORD grfMode, IStorage** ppStorage)
{
    return (OpenDebugStorage (name, grfMode, name, ppStorage));
}

#endif // COMDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\combstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       combstr.h
//
//--------------------------------------------------------------------------

#ifndef COMBSTR_H
#define COMBSTR_H

#ifndef BOOL_H
#include <bool.h>
#endif
#ifndef STRCONV_H
#include <strconv.h>
#endif

namespace microsoft	{
namespace com {

class bstr
	//REVIEW: need to add support for copy-on-write iterators.
	{
	public: bstr() throw()
		: m_Data(NULL)
		{
		}

	public: bstr(const bstr& s) throw()
		: m_Data(s.m_Data)
		{
		_AddRef();
		}

	public: bstr(const char* s) throw()
		: m_Data(new Data(s))
		{
		ASSERT(m_Data);
		}

	public: bstr(const wchar_t* s) throw()
		: m_Data(new Data(s))
		{
		}

	public: ~bstr() throw()
		{
		_Free();
		}

	public: bstr& operator=(const bstr& s) throw()
		{
		_Free();
		m_Data = s.m_Data;
		_AddRef();
		return *this;
		}

	public: bstr& operator=(const char* s) throw()
		{
		_Free();
		m_Data = new Data(s);
		return *this;
		}

	public: bstr& operator=(const wchar_t* s) throw()
		{
		_Free();
		m_Data = new Data(s);
		return *this;
		}

	public: bstr& operator+=(const bstr& s) throw()
		{
		Data* newData = new Data(*this, s);
		ASSERT(newData);
		_Free();
		m_Data = newData;
		return *this;
		}

	public: bstr operator+(const bstr& s) const throw()
		{
		bstr b = *this;
		b += s;
		return b;
		}

	public: operator const wchar_t*() const throw()
		{
		return m_Data ? m_Data->GetWString() : NULL;
		}

	public: operator const char*() const throw()
		{
		return m_Data ? m_Data->GetString() : NULL;
		}

	public: bool operator!() const throw()
		{
		return m_Data ? !m_Data->GetWString() : true;
		}

	public: bool operator==(const bstr& str) const throw()
		{
		return _Compare(str) == 0;
		}

	public: bool operator!=(const bstr& str) const throw()
		{
		return _Compare(str) != 0;
		}

	public: bool operator<(const bstr& str) const throw()
		{
		return _Compare(str) < 0;
		}

	public: bool operator>(const bstr& str) const throw()
		{
		return _Compare(str) > 0;
		}

	public: bool operator<=(const bstr& str) const throw()
		{
		return _Compare(str) <= 0;
		}

	public: bool operator>=(const bstr& str) const throw()
		{
		return _Compare(str) >= 0;
		}

	public: BSTR copy() const throw()
		{
		return m_Data ? m_Data->Copy() : NULL;
		}

	public: unsigned int length() const throw()
		{
		return m_Data ? m_Data->length() : 0;
		}

	//REVIEW: create size(of)()

	private: class Data
		{
		public: Data(const char* s) throw()
			: m_str(NULL), m_RefCount(1)
			{
			if (s)
				{
				m_wstr = str2BSTR(s);
				ASSERT(m_wstr);
				}
			else m_wstr = NULL;
			}

		public: Data(const wchar_t* s) throw()
			: m_str(NULL), m_RefCount(1)
			{
			if (s)
				{
				m_wstr = wcs2BSTR(s);
				ASSERT(m_wstr);
				}
			else m_wstr = NULL;
			}

		public: Data(const bstr& s1, const bstr& s2)
			: m_str(NULL), m_RefCount(1)
			{
			const unsigned int l1 = s1.length();
			const unsigned int l2 = s2.length();
			m_wstr=SysAllocStringLen(s1, l1+l2);
			ASSERT(m_wstr);
			memcpy(m_wstr+l1, static_cast<const wchar_t*>(s2), l2+1);
			}

		public: unsigned long AddRef() throw()
			{
			ASSERT(m_RefCount);
			InterlockedIncrement(reinterpret_cast<long*>(&m_RefCount));
			return m_RefCount;
			}

		public: unsigned long Release() throw()
			{
			ASSERT(m_RefCount);
			//REVIEW: may not want InterlockedDecrement for simple speed cases?
			if (!InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount)))
				delete this;
			return m_RefCount;
			}

		public: operator const wchar_t*() const throw()
			{
			return m_wstr;
			}

		public: operator const char*() const throw()
			{
			return GetString();
			}
				
		public: const wchar_t* GetWString() const throw()
			{
			return m_wstr;
			}

		public: const char* GetString() const throw()
			{
			if (!m_str && m_wstr)
				{
				USES_STRCONV;
				const unsigned int len=SysStringLen(m_wstr)+1;
				#if _MSC_VER >= 1100
				m_str = new char[len];
				ASSERT(m_str);
				memcpy(m_str, WCS2STR(m_wstr), len);
				#else //REVIEW: Strip after v5 ships
				const_cast<Data*>(this)->m_str = new char[len];
				ASSERT(m_str);
				memcpy(const_cast<Data*>(this)->m_str, WCS2STR(m_wstr), len);
				#endif // _MSC_VER >= 1100
				}
			return m_str;
			}

		public: BSTR Copy() const throw()
			{
			return m_wstr ? SysAllocStringLen(m_wstr, SysStringLen(m_wstr)) : NULL;
			}

		public: unsigned int length()
			{
			return m_wstr ? SysStringLen(m_wstr) : 0;
			}

		private: wchar_t* m_wstr;
		private: mutable char* m_str;
		private: unsigned long m_RefCount;

		private: Data()
			// Never allow default construction
			{
			}

		private: Data(const Data& s) throw()
			// Never allow copy
			: m_str(NULL), m_RefCount(1)
			{
			if (s.m_wstr)
				{
				m_wstr = SysAllocStringLen(s.m_wstr, SysStringLen(s.m_wstr));
				ASSERT(m_wstr);
				}
			else m_wstr = NULL;
			}

		private: ~Data()
			// Prevent deletes from outside.  Release() must be used.
			// ASSERT if the count is not 0
			{
			ASSERT(!m_RefCount);
			_Free();
			}

		private: void _Free()
			{
			if (m_wstr)
				SysFreeString(m_wstr);
			if (m_str)
				delete m_str;
			}
		}; // class Data

	private: Data* m_Data;

	private: void _AddRef()
		{
		if (m_Data)
			m_Data->AddRef();
		}

	private: void _Free() throw()
		{
		if (m_Data)
			{
			m_Data->Release();
			m_Data = NULL;
			}
		}

	private: int _Compare(const bstr& str) const throw()
		{
		if (m_Data == str.m_Data)
			return 0;
		if (!m_Data && str.m_Data)
			return -1;
		if (m_Data && !str.m_Data)
			return 1;
		#ifndef OLE2ANSI
		return wcscmp(*m_Data, str);
		#else
		return strcmp(*m_Data, str);
		#endif
		}
	}; // class bstr

} // namespace com
} // namespace microsoft

#ifndef MICROSOFT_NAMESPACE_ON
using namespace microsoft;
#ifndef COM_NAMESPACE_ON
using namespace com;
#endif // COM_NAMESPACE_ON
#endif // MICROSOFT_NAMESPACE_ON

#endif // COMBSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\comerror.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      comerror.h
//
//  Contents:  Support for Rich COM errors
//
//  History:   14-Oct-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#ifndef COMERROR_H
#define COMERROR_H
#pragma once

#include "tiedobj.h"



//############################################################################
//############################################################################
//
//  COM Rich Error support
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 *
 * MMCReportError
 *
 * PURPOSE: Calls AtlReportError and sets the last error condition based
 *          on an SC.
 *
 * PARAMETERS:
 *    SC &   sc :
 *    const  IID :
 *    const  CLSID :
 *
 * RETURNS:
 *    inline HRESULT
 *
 *+-------------------------------------------------------------------------*/
inline
HRESULT MMCReportError(SC &sc, const IID &iid, const CLSID & clsid)
{
    // only report the error if there was one.
    if(sc)
    {
        USES_CONVERSION;

        const  int length = 256;
        TCHAR sz[length];

        sc.GetErrorMessage(length, sz);

        // set everything we know about the error - the description, the help file,
        // the help ID, and the CLSID and IID of the source.
        return AtlReportError(clsid, sz, sc.GetHelpID(), sc.GetHelpFile(), iid, sc.ToHr());
    }
    else
        return S_OK;
}

// see "WHY NAMESPACES ?" comment at the top of mmcerror.h file
namespace comerror {
/*+-------------------------------------------------------------------------*
 * class _SC
 *
 *
 * PURPOSE: a local version of the SC class that automatically sets the error
 *          information when deleted.
 *
 * NOTE: Because of a compiler bug, this class cannot directly be internal
 *       to IMMCSupportErrorInfoImpl<>
 *
 *+-------------------------------------------------------------------------*/
template<const IID *piid, const CLSID *pclsid>
class SC : public mmcerror::SC
{
    typedef mmcerror::SC BaseClass;
public:
    SC (HRESULT hr = S_OK) : BaseClass(hr)
    {
    }

    ~SC()
    {
        MMCReportError(*this, *piid, *pclsid);
    }

    // copy constructor
    SC(const BaseClass &rhs) : BaseClass(rhs)
    {
    }

    // assignment
    SC&  operator= (HRESULT hr)             { BaseClass::operator =(hr);  return *this; }
    SC&  operator= (const BaseClass &rhs)   { BaseClass::operator =(rhs); return *this; }
    SC&  operator= (const SC &rhs)          { BaseClass::operator =(rhs); return *this; }
};

} // namespace comerror

/*+-------------------------------------------------------------------------*
 * class IMMCSupportErrorInfoImpl
 *
 *
 * PURPOSE: Inherits from ISupportErrorInfoImpl. local definition of the
 *          status code class SC, which makes it easy to return error information
 *          via the COM rich error handling system, without any extra effort
 *          on the part of the programmer.
 *
 *+-------------------------------------------------------------------------*/
template<const IID *piid, const CLSID *pclsid>
class IMMCSupportErrorInfoImpl : public ISupportErrorInfoImpl<piid>
{
    // this makes sure that AtlReportError is called in the destructor
    public:
        typedef comerror::SC<piid, pclsid> SC;
};

#define NYI_COM_METHOD()  {SC sc = E_NOTIMPL; return sc.ToHr();}


/************************************************************************
 * The following macros make it easy to implement a lightweight
 * COM object that "connects" to a non-COM tied object and delegates
 * all its methods to the non-COM object. The tied object pointer
 * is checked as well.
 ************************************************************************/
#define MMC_METHOD_PROLOG()                                         \
    SC  sc;                                                         \
                                                                    \
    CMyTiedObject *pTiedObj = NULL;                                 \
                                                                    \
    sc = ScGetTiedObject(pTiedObj);                                 \
    if(sc)                                                          \
        return (sc.ToHr())

#define MMC_METHOD_CALL(_fn)                                        \
    sc = pTiedObj->Sc##_fn

#define MMC_METHOD_EPILOG()                                         \
    return sc.ToHr()

#define MMC_METHOD0(_fn)                                            \
STDMETHOD(_fn)()                                                    \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)();                                         \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD0_PARAM(_fn, param)                               \
STDMETHOD(_fn)()                                                    \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(param);                                    \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD1(_fn, T1)                                        \
STDMETHOD(_fn)(T1 p1)                                               \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1);                                       \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD1_PARAM(_fn, T1, param)                           \
STDMETHOD(_fn)(T1 p1)                                               \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, param);                                \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD2(_fn, T1, T2)                                    \
STDMETHOD(_fn)(T1 p1, T2 p2)                                        \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2);                                   \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD2_PARAM(_fn, T1, T2, param)                       \
STDMETHOD(_fn)(T1 p1, T2 p2)                                        \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, param);                            \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD3(_fn, T1, T2, T3)                                \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3)                                 \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3);                               \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD3_PARAM(_fn, T1, T2, T3, param)                   \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3)                                 \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3, param);                        \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD4(_fn, T1, T2, T3, T4)                            \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3, T4 p4)                          \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3, p4);                           \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD4_PARAM(_fn, T1, T2, T3, T4, param)               \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3, T4 p4)                          \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3, p4, param);                    \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD5(_fn, T1, T2, T3, T4, T5)                        \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)                   \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3, p4, p5);                       \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD5_PARAM(_fn, T1, T2, T3, T4, T5, param)           \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3, T4 p4, T5 p5)                   \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_fn)(p1, p2, p3, p4, p5, param);                \
    MMC_METHOD_EPILOG();                                            \
}

/************************************************************************
 * A version of the above macros that adds a prefix to the Sc methods.
 * This is useful for disambiguating method names if the same object serves
 * as the tied object for more than one COM object with identical methods.
 ************************************************************************/
#define MMC_METHOD0_EX(_prefix, _fn)                                \
STDMETHOD(_fn)()                                                    \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_prefix##_fn)();                                \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD1_EX(_prefix, _fn, T1)                            \
STDMETHOD(_fn)(T1 p1)                                               \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_prefix##_fn)(p1);                              \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD2_EX(_prefix, _fn, T1, T2)                        \
STDMETHOD(_fn)(T1 p1, T2 p2)                                        \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_prefix##_fn)(p1, p2);                          \
    MMC_METHOD_EPILOG();                                            \
}

#define MMC_METHOD3_EX(_prefix, _fn, T1, T2, T3)                    \
STDMETHOD(_fn)(T1 p1, T2 p2, T3 p3)                                 \
{                                                                   \
    MMC_METHOD_PROLOG();                                            \
    MMC_METHOD_CALL(_prefix##_fn)(p1, p2, p3, param);               \
    MMC_METHOD_EPILOG();                                            \
}

#endif  // COMERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\bookmark.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      bookmark.inl
 *
 *  Contents:  Implementation file for CBookmark
 *
 *  History:   25-Oct-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#include "uastrfnc.h"	// from $(SHELL_INC_PATH), for unaligned string functions


/*+-------------------------------------------------------------------------*
 * UnalignedValueAt
 *
 * Returns the value at a potentially unaligned address.
 *--------------------------------------------------------------------------*/

template<typename T>
T UnalignedValueAt (UNALIGNED T* pT)
{
	return (*pT);
}


//############################################################################
//############################################################################
//
//  Implementation of class CDynamicPathEntry
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * CDynamicPathEntry::ScInitialize
 *
 * PURPOSE: Initializes the entry from a byte array read in from a console file.
 *
 * PARAMETERS:
 *    bool  bIs10Path : true if the path entry format is that of MMC1.0.
 *    I     iter:    The byte array.
 *
 * RETURNS:
 *    inline SC
 *
 *+-------------------------------------------------------------------------*/
inline SC
CDynamicPathEntry::ScInitialize(bool bIs10Path, /*[IN,OUT]*/ByteVector::iterator &iter)
{
    DECLARE_SC(sc, TEXT("CDynamicPathEntry::ScInitialize"));

    if(bIs10Path) // an MMC1.0 path entry. Just the display name
    {
        m_type = NDTYP_STRING;
        m_strEntry =  reinterpret_cast<LPCWSTR>(iter);
        iter += (m_strEntry.length() + 1) *sizeof(WCHAR); // bump up the iterator.
    }
    else // a 1.1 or 1.2 path. The first byte contains the type.
    {
        m_type = *iter++; // either NDTYP_STRING or NDTYP_CUSTOM
        switch(m_type)
        {
        default:
            sc = E_UNEXPECTED;
            break;

		case NDTYP_STRING:
		{
			LPCWSTR pszEntry = reinterpret_cast<LPCWSTR>(iter);
#ifdef ALIGNMENT_MACHINE
			/*
			 * Bug 128010: if our target machine requires data alignment and
			 * the source is unaligned, make an aligned copy that we can
			 * pass to std::wstring::operator=, which calls wcs* functions
			 * expect aligned data
			 */
			if (!IS_ALIGNED (pszEntry))
			{
				LPWSTR pszNew = (LPWSTR) alloca ((ualstrlenW(pszEntry) + 1) * sizeof(WCHAR));
				ualstrcpyW (pszNew, pszEntry);
				pszEntry = pszNew;
			}
#endif
            m_strEntry = pszEntry;
            // bump the input pointer to the next element
            iter += (m_strEntry.length() + 1) * sizeof (WCHAR);
            break;
		}

        case NDTYP_CUSTOM:
            const SNodeID*  pNodeID = reinterpret_cast<const SNodeID*>(iter); // same binary layout as a SNodeID.
            if(!pNodeID)
                return (sc = E_UNEXPECTED);

			/*
			 * Bug 177492: pNodeID->cBytes may be unaligned, so make an aligned copy of it
			 */
			const DWORD cBytes = UnalignedValueAt (&pNodeID->cBytes);

            m_byteVector.insert(m_byteVector.end(), pNodeID->id, pNodeID->id + cBytes);
            /*if(pNodeID->cBytes==0)
                m_dwFlags = MMC_NODEID_SLOW_RETRIEVAL; */ // shouldn't need this; should not be able to save such a bookmark.

            iter += sizeof (pNodeID->cBytes) + cBytes; // bump up the pointer.
            break;
        }

    }

    return sc;
}

inline bool
CDynamicPathEntry::operator ==(const CDynamicPathEntry &rhs) const
{
    // check the types
    if(m_type != rhs.m_type)
        return false;

    if(m_type == NDTYP_CUSTOM)
        return (m_byteVector == rhs.m_byteVector);
    else
        return (m_strEntry   == rhs.m_strEntry);
}

inline bool
CDynamicPathEntry::operator < (const CDynamicPathEntry &rhs) const
{
    // first order on basis of type - this is arbitrary, but establishes some
    // needed separation.
    if(m_type != rhs.m_type)
        return (m_type < rhs.m_type);

    if(m_type == NDTYP_CUSTOM)
        return  std::lexicographical_compare(m_byteVector.begin(),
                                             m_byteVector.end(),
                                             rhs.m_byteVector.begin(),
                                             rhs.m_byteVector.end());
    else
        return m_strEntry < rhs.m_strEntry;
}

/*--------------------------------------------------------------------------*
 * InsertScalar
 *
 * Inserts a scalar value of type T into an output stream as a series of
 * the output stream's value_type.
 *--------------------------------------------------------------------------*/

template<typename Container, typename T>
void InsertScalar (Container& c, const T& t)
{
    Container::const_iterator itFrom = reinterpret_cast<Container::const_iterator>(&t);
    std::copy (itFrom, itFrom + sizeof (t), std::back_inserter(c));
}


/*+-------------------------------------------------------------------------*
 *
 * CDynamicPathEntry::Write
 *
 * PURPOSE: Writes the contents of the object to a byte vector.
 *
 * PARAMETERS:
 *    ByteVector& v :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
inline void
CDynamicPathEntry::Write (ByteVector& v) const
{
    // insert the type of the entry.
    v.push_back(m_type);

    if(m_type == NDTYP_STRING)
    {
        typedef const BYTE * LPCBYTE;
        // use byte pointers as parameters to copy so the WCHARs don't
        // get truncated to BYTEs as they're inserted into v
        LPCBYTE pbFirst = reinterpret_cast<LPCBYTE>(m_strEntry.begin());
        LPCBYTE pbLast  = reinterpret_cast<LPCBYTE>(m_strEntry.end());

        // copy the text of the string (no NULL terminator)
        std::copy (pbFirst, pbLast, std::back_inserter (v));

        // append the (Unicode) terminator
        v.push_back (0);
        v.push_back (0);
    }
    else
    {
        // write the size of the byte vector
        SNodeID id;
        id.cBytes = m_byteVector.size();
        InsertScalar (v, id.cBytes);

        // write the bytes
        std::copy (m_byteVector.begin(), m_byteVector.end(), std::back_inserter (v));
    }

}


//############################################################################
//############################################################################
//
//  Implementation of class CBookmark
//
//############################################################################
//############################################################################

inline bool
CBookmark::operator ==(const CBookmark& other) const
{
    return ((m_idStatic     == other.m_idStatic) &&
            (m_dynamicPath == other.m_dynamicPath));
}

inline bool
CBookmark::operator!=(const CBookmark& other) const
{
    return (!(*this == other));
}

inline bool
CBookmark::operator<(const CBookmark& other) const
{
    if (m_idStatic < other.m_idStatic)
        return true;

    if (m_idStatic == other.m_idStatic)
    {
        return std::lexicographical_compare( m_dynamicPath.begin(),
                                             m_dynamicPath.end(),
                                             other.m_dynamicPath.begin(),
                                             other.m_dynamicPath.end() );
    }

    return false;
}


/*+-------------------------------------------------------------------------*
 *
 * CBookmark::HBOOKMARK
 *
 * PURPOSE: Casts a bookmark into an HBOOKMARK
 *
 * RETURNS:
 *    operator
 *
 *+-------------------------------------------------------------------------*/
inline
CBookmark:: operator HBOOKMARK()    const
{
    return reinterpret_cast<HBOOKMARK>(this);
}

/*+-------------------------------------------------------------------------*
 *
 * CBookmark::GetBookmark
 *
 * PURPOSE:  Converts an HBOOKMARK to a CBookmark.
 *
 * PARAMETERS:
 *    HBOOKMARK  hbm :
 *
 * RETURNS:
 *    CBookmark *
 *
 *+-------------------------------------------------------------------------*/
inline CBookmark *
CBookmark::GetBookmark(HBOOKMARK hbm)
{
    return reinterpret_cast<CBookmark *>(hbm);
}


/*+-------------------------------------------------------------------------*
 *
 * CBookmark::Load
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    IStream& stm :
 *
 * RETURNS:
 *    inline IStream&
 *
 *+-------------------------------------------------------------------------*/
inline IStream&
CBookmark::Load(IStream& stm)
{
    // loading from a stream. Convert from one of the legacy formats.

    // 1. Read the static node ID
    stm >> m_idStatic;
    m_dynamicPath.clear();

    // 2. Read the dynamic path
    ByteVector  vDynamicPath;
    ByteVector::iterator iter;
    stm >> vDynamicPath;

    // 2a. If the dynamic path is empty, we're done.
    if(vDynamicPath.empty())
        return (stm);

    // 3. Strip out the unnecessary details like the signature, etc.

    // 3a. Check for a signature
    iter = vDynamicPath.begin();
    bool bIs10Path = true;
    if(memcmp (iter,  BOOKMARK_CUSTOMSTREAMSIGNATURE,
               sizeof(BOOKMARK_CUSTOMSTREAMSIGNATURE)) == 0)
    {
        // throw away the signature and the following version bytes
        iter += (sizeof(BOOKMARK_CUSTOMSTREAMSIGNATURE) + sizeof(DWORD));
        bIs10Path = false; //is a post-MMC1.0 path.
    }

    // create new entries for each piece.
    while(iter != vDynamicPath.end())
    {
        CDynamicPathEntry entry;
        entry.ScInitialize(bIs10Path, iter); //NOTE: iter is an in/out parameter.
        m_dynamicPath.push_back(entry);
    }

    return (stm);
}

/*+-------------------------------------------------------------------------*
 *
 * CBookmark::Save
 *
 * PURPOSE: This function will be obsolete once XML takes over.
 *
 * PARAMETERS:
 *    IStream& stm :
 *
 * RETURNS:
 *    inline IStream&
 *
 *+-------------------------------------------------------------------------*/
inline IStream&
CBookmark::Save(IStream& stm) const
{
    // 1. Save the static node ID
    stm << m_idStatic;

    ByteVector vDynamicPath; // used to build up the old-style bookmark structure.
    vDynamicPath.clear(); // initialize - probably not needed, but defensive.

    // Build up the dynamic path if there is one.
    if(!m_dynamicPath.empty())
    {
        // 2. Save the signature
        InsertScalar(vDynamicPath, BOOKMARK_CUSTOMSTREAMSIGNATURE);

        // high word = major version number, low word = minor version number
        const WORD  wMajorVersion                = 1;
        const WORD  wMinorVersion                = 0;
        const DWORD dwCurrentCustomStreamVersion = MAKELONG (wMinorVersion, wMajorVersion);

        // 3. copy the version number out.
        InsertScalar(vDynamicPath, dwCurrentCustomStreamVersion);

        // 4. Write out all the path entries into the byte vector
        CDynamicPath::iterator iter;
        for(iter = m_dynamicPath.begin(); iter != m_dynamicPath.end(); iter++)
        {
            iter->Write(vDynamicPath);
        }
    }

    // 5. Finally, write out the byte vector.
    stm << vDynamicPath;

    return (stm);
}

/*+-------------------------------------------------------------------------*
 *
 * CBookmark::Persist
 *
 * PURPOSE: Persists the bookmark
 *
 * PARAMETERS:
 *    CPersistor & persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
inline void
CBookmark::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CBookmark::Persist"));

    // check and persist only valid node ids
    if (persistor.IsStoring() && (m_idStatic == ID_Unknown))
        sc.Throw(E_UNEXPECTED);

    persistor.PersistAttribute(XML_ATTR_BOOKMARK_STATIC, m_idStatic);

    bool bPersistList = persistor.IsLoading() ? (persistor.HasElement(XML_ATTR_BOOKMARK_DYNAMIC_PATH, NULL)) :
                                                (m_dynamicPath.size() > 0);

    if (bPersistList)
        persistor.PersistList(XML_ATTR_BOOKMARK_DYNAMIC_PATH, NULL, m_dynamicPath);
}

/*+-------------------------------------------------------------------------*
 *
 * CDynamicPathEntry::Persist
 *
 * PURPOSE: Persists the dynamic path entry of the bookmark
 *
 * PARAMETERS:
 *    CPersistor & persistor :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
inline void
CDynamicPathEntry::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CDynamicPathEntry::Persist"));

    if (m_type == NDTYP_STRING || persistor.IsLoading())
        persistor.PersistAttribute(XML_ATTR_BOOKMARK_DYN_STRING, m_strEntry, attr_optional);

    if (m_type == NDTYP_CUSTOM || persistor.IsLoading())
    {
        CXMLAutoBinary binData;
        if (persistor.IsStoring())
        {
            if (m_byteVector.size())
            {
                sc = binData.ScAlloc(m_byteVector.size());
                if (sc)
                    sc.Throw();

                CXMLBinaryLock sLock(binData); // unlocks on destructor

                LPBYTE pData = NULL;
                sc = sLock.ScLock(&pData);
                if (sc)
                    sc.Throw();

                std::copy(m_byteVector.begin(), m_byteVector.end(), pData);
            }
        }
        persistor.PersistAttribute(XML_ATTR_BOOKMARK_DYN_CUSTOM, binData, attr_optional);
        if (persistor.IsLoading())
        {
            m_byteVector.clear();
            if (binData.GetSize()) // if there is nothing to read it won't be allocated
            {
                CXMLBinaryLock sLock(binData); // unlocks on destructor

                LPBYTE pData = NULL;
                sc = sLock.ScLock(&pData);
                if (sc)
                    sc.Throw();

                m_byteVector.assign( pData, pData + binData.GetSize() );
            }
        }
    }
    if (persistor.IsLoading())
        m_type = (m_strEntry.size() > 0) ? NDTYP_STRING : NDTYP_CUSTOM;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\cmenuinfo.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      tstring.h
 *
 *  Contents:  Interface/implementation file for CContextMenuInfo
 *
 *  History:   12-Sep-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CMENUINFO_H
#define CMENUINFO_H
#pragma once

class CConsoleView;
class CConsoleTree;

//
// This structure is used to pass UI information to/from the mmc.exe and
// the node manager.  It has information about the state of the UI "bits"
// and returns the selected menu item.  Note: if the node manager processes
// the menu command, the m_lSelected will be returned with a value of 0
//


enum
{
    CMINFO_USE_TEMP_VERB         = 0x00000001, // Need for r-click of non-selected scope node and by TaskPads.
    CMINFO_SHOW_VIEW_ITEMS       = 0x00000002,
    CMINFO_SHOW_SAVE_LIST        = 0x00000004,
    CMINFO_DO_SCOPEPANE_MENU     = 0x00000008, // Set when menu invoked from scope pane
    CMINFO_SCOPEITEM_IN_RES_PANE = 0x00000010, // set when the item is a scope item in the result pane
    CMINFO_SHOW_SCOPEITEM_OPEN   = 0x00000020, // Show Open verb for scope item regardless of enable state
    CMINFO_FAVORITES_MENU        = 0x00000040, // Show items for favorites menu
    CMINFO_SHOW_VIEWOWNER_ITEMS  = 0x00000080, // Show items for scope item that owns result view
    CMINFO_SHOW_SCOPETREE_ITEM   = 0x00000100, // Show item for showing/hiding scope tree
};


class CContextMenuInfo
{
public:
    POINT                   m_displayPoint;

    // flag to indicate the snap-in manager is allowed to be displayed
    bool                    m_bScopeAllowed;        // Display scope pane menu item
    bool                    m_bBackground;          // Background on control or item
    bool                    m_bMultiSelect;         // TRUE if multi select in the result pane.
	bool					m_bAllowDefaultItem;	// permit a default item on the menu (true for context menus, false for menu bar popups)
    MMC_CONTEXT_MENU_TYPES  m_eContextMenuType;     // Context menu type
    DATA_OBJECT_TYPES       m_eDataObjectType;      // Data object type
    HWND                    m_hWnd;                 // View HWND
    CConsoleView*           m_pConsoleView;         // console view interface (not a COM interface)
    CConsoleTree*           m_pConsoleTree;         // console tree interface (not a COM interface)
    IMMCListViewPtr         m_spListView;           // Pointer to listview interface (NULL if custom result view)
    LPARAM                  m_resultItemParam;      // Our wrapped lparam for the result item
    HNODE                   m_hSelectedScopeNode;
    HTREEITEM               m_htiRClicked;
    int                     m_iListItemIndex;       // The index of the list item in the result pane

    DWORD                   m_dwFlags;              // One of the CMINFO_xxx flags
	RECT					m_rectExclude;			// portion of screen to avoid obscuring

public:
    CContextMenuInfo ()
    {
        Initialize();
    }

    void Initialize ()
    {
        m_displayPoint.x          = 0;
        m_displayPoint.y          = 0;
        m_bScopeAllowed           = false;
        m_bBackground             = false;
        m_bMultiSelect            = false;
        m_bAllowDefaultItem       = true;
        m_eContextMenuType        = MMC_CONTEXT_MENU_DEFAULT;
        m_eDataObjectType         = CCT_UNINITIALIZED;
        m_hWnd                    = NULL;
        m_pConsoleView            = NULL;
        m_pConsoleTree            = NULL;
        m_spListView              = NULL;
        m_resultItemParam         = 0;
        m_hSelectedScopeNode      = 0;
        m_htiRClicked             = 0;
        m_iListItemIndex          = 0;
        m_dwFlags                 = 0;

		SetRectEmpty (&m_rectExclude);
    }
};

#endif /* CMENUINFO_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\comobjects.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       comobjects.h
//
//  Contents:   Base code for com objects exported by Object Model.
//
//  Classes:    CMMCStrongReferences, CMMCIDispatchImpl
//
//  History:    16-May-2000 AudriusZ     Created
//
//--------------------------------------------------------------------


#pragma once
#ifndef COMOBJECTS_H_INCLUDED
#define COMOBJECTS_H_INCLUDED

/*+-------------------------------------------------------------------------*
 * class CComObjectObserver
 *
 * PURPOSE: The general interface for a class that observes com object events
 *
 * USAGE:   Used by CMMCIDispatchImpl, so all ObjectModel objects inherit from it
 *
 *+-------------------------------------------------------------------------*/
class CComObjectObserver : public CObserverBase
{
public:
    // request to break external references
    virtual SC ScOnDisconnectObjects()  {DEFAULT_OBSERVER_METHOD;}
};

/*+-------------------------------------------------------------------------*
 * function GetComObjectEventSource
 *
 * PURPOSE: returns singleton for emmiting Com Object Events
 *          Since ObjectModel com objects are implemented in EXE and DLL's
 *          There is a need to have 'global' object per process to
 *          be able to bradcast events to every object.
 *
 * USAGE:   Used by
 *          1) CMMCIDispatchImpl    to register objects
 *          2) CAMCMultiDocTemplate to bradcast 'cut off extenal references'
 *+-------------------------------------------------------------------------*/
MMCBASE_API CEventSource<CComObjectObserver>& GetComObjectEventSource();

/***************************************************************************\
 *
 * CLASS:  CMMCStrongReferences
 *
 * PURPOSE: Implements static interface to count strong references put on MMC
 *          Also implements the method to detect when the last stron reference was
 *          released in order to start MMC exit procedure.
 *
 *          Class is implemented as singleton object in mmcbase.dll
 *
 * USAGE:   use CMMCStrongReferences::AddRef() and CMMCStrongReferences::Release()
 *              to put/remove strong references on MMC.EXE
 *          use CMMCStrongReferences::LastRefReleased() to inspect if the
 *              last ref was released
 *
\***************************************************************************/
class MMCBASE_API CMMCStrongReferences
{
public:
    // public (static) interface
    static DWORD AddRef();
    static DWORD Release();
    static bool  LastRefReleased();

private:
    // implementation helpers

    CMMCStrongReferences();

    static CMMCStrongReferences& GetSingletonObject();
    DWORD InternalAddRef();
    DWORD InternalRelease();
    bool  InternalLastRefReleased();

    // data members
    DWORD  m_dwStrongRefs;      // strong reference count
    bool   m_bLastRefReleased;  // have strong reference count ever go from one to zero
};


/***************************************************************************\
 *
 * CLASS:  CMMCIDispatchImpl<typename _ComInterface, const GUID * _pguidClass = &GUID_NULL, const GUID* _pLibID = &LIBID_MMC20>
 *                  _ComInterface - Object Model interface implemented by the class
 *                  _pguidClass [optional] - pointer to CLSID for cocreatable objects
 *                  _pLibID     [optional] - pointer to LIBID with _ComInterface's type info
 *
 * PURPOSE: Base for every com object defined by the MMC Object Model
 *          implements common functionality, like:
 *              - IDispatch
 *              - ISupportErrorInfo
 *              - IExternalConnection
 *
 * USAGE:   Derive your object from CMMCIDispatchImpl<interface>
 *          Define: BEGIN_MMC_COM_MAP(_Class) ... END_MMC_COM_MAP() in the class
 *          Define COM_INTERFACE_ENTRY for each additional interface
 *          ( DO NOT need to add IDispatch, ISupportErrorInfo, IExternalConnection
 *          or implemented ObjecModel interface - these are added by the base class )
 *
\***************************************************************************/
template<
	typename _ComInterface,
	const GUID * _pguidClass = &GUID_NULL,
	const GUID * _pLibID = &LIBID_MMC20>
class CMMCIDispatchImpl :
    public IDispatchImpl<_ComInterface, &__uuidof(_ComInterface), _pLibID>,
    // we can use the IMMCSupportErrorInfoImpl object because exactly one dispinterface is exposed from this object.
    public IMMCSupportErrorInfoImpl<&__uuidof(_ComInterface), _pguidClass>,
    public IExternalConnection,
    public CComObjectRoot,
    public CComObjectObserver
{
public:
    // typedef interface and this class [used by macros defined in the derived class]
    typedef _ComInterface MMCInterface;
    typedef CMMCIDispatchImpl<_ComInterface, _pguidClass, _pLibID> CMMCIDispatchImplClass;

// interfaces implemented by this base class
BEGIN_COM_MAP(CMMCIDispatchImplClass)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IExternalConnection)
END_COM_MAP()

    CMMCIDispatchImpl()
    {
        // add itself as an observer for com object events
        GetComObjectEventSource().AddObserver(*static_cast<CComObjectObserver*>(this));

#ifdef _MMC_NODE_MANAGER_ONLY_
    // Every object implemented by node manager should also register for typeinfo clenup
        static CMMCTypeInfoHolderWrapper wrapper(GetInfoHolder());
#endif // _MMC_NODE_MANAGER_ONLY_
    }

#ifdef _MMC_NODE_MANAGER_ONLY_
    // Every object implemented by node manager should also register for typeinfo clenup

    // the porpose of this static function is to ensure _tih is a static variable,
    // since static wrapper will hold on its address - it must be always valid
    static CComTypeInfoHolder& GetInfoHolder() { return _tih; }

#endif // _MMC_NODE_MANAGER_ONLY_

    // implementation for IExternalConnection methods

    STDMETHOD_(DWORD, AddConnection)(DWORD extconn, DWORD dwreserved)
    {
        DWORD dwRefs = AddRef();    // addref itself

        // put a strong reference on MMC - this will prevent mmc from exiting
        if (extconn & EXTCONN_STRONG)
            dwRefs = CMMCStrongReferences::AddRef();

        return dwRefs;
    }
    STDMETHOD_(DWORD, ReleaseConnection)(DWORD extconn, DWORD dwreserved, BOOL fLastReleaseCloses)
    {
        DWORD dwStrongRefs = 0;
        DWORD dwRefs = 0;

        // release a strong reference on MMC
        if (extconn & EXTCONN_STRONG)
        {
            dwStrongRefs = CMMCStrongReferences::Release();
        }

        //release a ref on itself
        dwRefs = Release();

        // return a proper ref count
        return (extconn & EXTCONN_STRONG) ? dwStrongRefs : dwRefs;
    }

    /***************************************************************************\
     *
     * METHOD:  ScOnDisconnectObjects
     *
     * PURPOSE: invoked when observed event (request to disconnect) occures
     *          Disconnects from external connections
     *
     * PARAMETERS:
     *
     * RETURNS:
     *    SC    - result code
     *
    \***************************************************************************/
    virtual ::SC ScOnDisconnectObjects()
    {
        DECLARE_SC(sc, TEXT("CMMCIDispatchImpl<_ComInterface>::ScOnDisconnectObjects"));

        // QI for IUnknown
        IUnknownPtr spUnknown = this;

        // sanity check
        sc = ScCheckPointers( spUnknown, E_UNEXPECTED );
        if (sc)
            return sc;

        // cutt own references
        sc = CoDisconnectObject( spUnknown, 0/*dwReserved*/ );
        if (sc)
            return sc;

        return sc;
    }

#ifdef DBG
    // this block is to catch mistakes when the Derived class does not use
    // BEGIN_MMC_COM_MAP() or END_MMC_COM_MAP() in its body
    virtual void _BEGIN_MMC_COM_MAP() = 0;
    virtual void _END_MMC_COM_MAP() = 0;
#endif
};

/***************************************************************************\
 *
 * MACRO:  BEGIN_MMC_COM_MAP
 *
 * PURPOSE: To be used in place of BEGIN_MMC_COM_MAP for com objects used in MMC Object Model
 *
\***************************************************************************/

#ifndef DBG

// standard version
#define BEGIN_MMC_COM_MAP(_Class)                       \
        BEGIN_COM_MAP(_Class)                           \
        COM_INTERFACE_ENTRY(MMCInterface)

#else // DBG

// same as above, but shuts off the trap placed in CMMCIDispatchImpl in debug mode
#define BEGIN_MMC_COM_MAP(_Class)                       \
        virtual void _BEGIN_MMC_COM_MAP() {}            \
        BEGIN_COM_MAP(_Class)                           \
        COM_INTERFACE_ENTRY(MMCInterface)
#endif // DBG

/***************************************************************************\
 *
 * MACRO:  END_MMC_COM_MAP
 *
 * PURPOSE: To be used in place of END_COM_MAP for com objects used in MMC Object Model
 *
\***************************************************************************/

#ifndef DBG

// standard version
#define END_MMC_COM_MAP()                               \
        COM_INTERFACE_ENTRY_CHAIN(CMMCIDispatchImplClass)   \
        END_COM_MAP()

#else // DBG

// same as above, but shuts off the trap placed in CMMCIDispatchImpl in debug mode
#define END_MMC_COM_MAP()                               \
        COM_INTERFACE_ENTRY_CHAIN(CMMCIDispatchImplClass)   \
        END_COM_MAP()                                   \
        virtual void _END_MMC_COM_MAP() {}

#endif // DBG

/*+-------------------------------------------------------------------------*
 * class CConsoleEventDispatcher
 *
 *
 * PURPOSE: Interface for emitting com events from node manager side
 *          implemented by CMMCApplication
 *
 *+-------------------------------------------------------------------------*/
class CConsoleEventDispatcher
{
public:
    virtual SC ScOnContextMenuExecuted( PMENUITEM pMenuItem ) = 0;
};

/***************************************************************************\
 *
 * METHOD:  CConsoleEventDispatcherProvider
 *
 * PURPOSE: this class is to wrap and maintain a pointer to CConsoleEventDispatcher
 *          interface. Pointer is set by conui side and used from node manager side.
 *          Pointer is discarded when when cleanup event is observed.
 *
\***************************************************************************/
class CConsoleEventDispatcherProvider
{
public:

    // public class members (static) to get/set interface pointer
    static SC MMCBASE_API ScSetConsoleEventDispatcher( CConsoleEventDispatcher *pDispatcher )
    {
        s_pDispatcher = pDispatcher;
        return SC(S_OK);
    }
    static SC MMCBASE_API ScGetConsoleEventDispatcher( CConsoleEventDispatcher *&pDispatcher )
    {
        pDispatcher = s_pDispatcher;
        return SC(S_OK);
    }

private:
    // pointer to interface
    static MMCBASE_API CConsoleEventDispatcher *s_pDispatcher;
};

#endif // COMOBJECTS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\classreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       classreg.h
//
//  History: 02-02-2000 Vivekj Added
//--------------------------------------------------------------------------

#pragma once
#ifndef _CLASSREG_H_
#define _CLASSREG_H_

#include "tstring.h"
#include "modulepath.h"


/*+-------------------------------------------------------------------------*
 * AddReplacementTrace
 *
 * Trace helper function.
 *--------------------------------------------------------------------------*/

#ifdef DBG

inline void AddReplacementTrace (std::wstring& str, LPCWSTR pszKey, LPCWSTR pszData)
{
	if (!str.empty())
		str	+= L"\n";

	str	+= pszKey;
	str	+= L" -> ";
	str	+= pszData;
}

#else
#define AddReplacementTrace(str, pszKey, pszData)
#endif	// DBG


/*+-------------------------------------------------------------------------*
 * InlineT2W
 *
 * Helper function to aid in converting tstrings during initialization
 * of constant members.
 *--------------------------------------------------------------------------*/

inline std::wstring InlineT2W (const tstring& str)
{
#if defined(_UNICODE)
    return str;
#else
    USES_CONVERSION;
    return A2CW(str.c_str());
#endif
}


/*+-------------------------------------------------------------------------*
 * CObjectRegParams
 *
 * Parameters register all objects.
 *--------------------------------------------------------------------------*/

class CObjectRegParams
{
public:
	CObjectRegParams (
		const CLSID&	clsid,                          // CLSID of object
		LPCTSTR			pszModuleName,                  // name of implementing DLL
		LPCTSTR			pszClassName,                   // class name of object
		LPCTSTR			pszProgID,                      // ProgID of object
		LPCTSTR			pszVersionIndependentProgID,    // version-independent ProgID of object
		LPCTSTR			pszServerType = _T("InprocServer32")) // server type
		:
		m_clsid                       (clsid),
		m_strModuleName               (InlineT2W (pszModuleName) ),
		m_strModulePath               (InlineT2W ((LPCTSTR)CModulePath::MakeAbsoluteModulePath(pszModuleName))),
		m_strClassName                (InlineT2W (pszClassName)),
		m_strProgID                   (InlineT2W (pszProgID)),
		m_strVersionIndependentProgID (InlineT2W (pszVersionIndependentProgID)),
		m_strServerType				  (InlineT2W (pszServerType))
	{
	}

    const CLSID     	m_clsid;						// CLSID of object
	const std::wstring	m_strModuleName;				// name of implementing DLL
	const std::wstring	m_strModulePath;				// absolute module path
	const std::wstring	m_strClassName;					// class name of object
	const std::wstring	m_strProgID;					// ProgID of object
	const std::wstring	m_strVersionIndependentProgID;	// version-independent ProgID of object
	const std::wstring	m_strServerType;				// server type local/in-proc, etc.
};


/*+-------------------------------------------------------------------------*
 * CControlRegParams
 *
 * Parameters required to register all controls, in addition to
 * CObjectRegParams.
 *--------------------------------------------------------------------------*/

class CControlRegParams
{
public:
	CControlRegParams (
		const GUID&		libid,					// LIBID of control's typelib
		LPCTSTR			pszToolboxBitmapID,     // index of control's bitmap
		LPCTSTR			pszVersion)             // control's version
		:
		m_libid              (libid),
		m_strToolboxBitmapID (InlineT2W (pszToolboxBitmapID)),
		m_strVersion         (InlineT2W (pszVersion))
	{
	}

    const GUID			m_libid;				// LIBID of control's typelib
    const std::wstring	m_strToolboxBitmapID;	// index of control's bitmap
    const std::wstring	m_strVersion;			// control's version
};


/*+-------------------------------------------------------------------------*
 * MMCUpdateRegistry
 *
 * Registers a COM object or control.  This function typically isn't used
 * directly, but indirectly via DECLARE_MMC_OBJECT_REGISTRATION or
 * DECLARE_MMC_CONTROL_REGISTRATION.
 *--------------------------------------------------------------------------*/

MMCBASE_API HRESULT WINAPI MMCUpdateRegistry (
    BOOL                        bRegister,      // I:register or unregister?
    const CObjectRegParams*     pObjParams,     // I:object registration parameters
    const CControlRegParams*    pCtlParams);    // I:control registration parameters (optional)


/*+-------------------------------------------------------------------------*
 * DECLARE_MMC_OBJECT_REGISTRATION
 *
 * Declares a registration function for a COM object.
 *--------------------------------------------------------------------------*/

#define DECLARE_MMC_OBJECT_REGISTRATION(                            \
	szModule,														\
    clsid,                                                          \
    szClassName,                                                    \
    szProgID,                                                       \
    szVersionIndependentProgID)                                     \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister)                \
{                                                                   \
    CObjectRegParams op (											\
		clsid,														\
		szModule,													\
		szClassName,												\
		szProgID,													\
		szVersionIndependentProgID);								\
                                                                    \
    return (MMCUpdateRegistry (bRegister, &op, NULL));              \
}


/*+-------------------------------------------------------------------------*
 * DECLARE_MMC_CONTROL_REGISTRATION
 *
 * Declares a registration function for a COM control.
 *--------------------------------------------------------------------------*/

#define DECLARE_MMC_CONTROL_REGISTRATION(                           \
	szModule,														\
    clsid,                                                          \
    szClassName,                                                    \
    szProgID,                                                       \
    szVersionIndependentProgID,                                     \
    libid,                                                          \
    szBitmapID,                                                     \
    szVersion)                                                      \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister)                \
{                                                                   \
    CObjectRegParams op (											\
		clsid,														\
		szModule,													\
		szClassName,												\
		szProgID,													\
		szVersionIndependentProgID);								\
                                                                    \
    CControlRegParams cp (											\
		libid,														\
		szBitmapID,													\
		szVersion);													\
                                                                    \
    return (MMCUpdateRegistry (bRegister, &op, &cp));               \
}

#endif // _CLASSREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\columninfo.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       columninfo.h
//
//  Contents:   Classes related to column persistence.
//
//
//  Note:       The classes in this file (CColumnInfo, CColumnInfoList)
//              were in nodemgr/colwidth.h. They are moved here so that
//              if columns change conui can ask nodemgr to persist data
//              or conui can set headers by asking nodemgr for data.
//
//  History:    04-Apr-00 AnandhaG     Created
//
//--------------------------------------------------------------------

#ifndef COLUMNINFO_H_
#define COLUMNINFO_H_
#pragma once

using namespace std;

//+-------------------------------------------------------------------
//
//  Class:      CColumnInfo
//
//  Purpose:    The minimum information about a column that will be
//              persisted. (Width, order, format which can be hidden status)
//
//  History:    10-27-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnInfo : public CSerialObject, public CXMLObject
{
public:
    CColumnInfo () : m_nCol(-1), m_nWidth(-1), m_nFormat(0)
    {}

    CColumnInfo (INT nCol, INT nWidth, INT nFormat)
                : m_nCol(nCol), m_nWidth(nWidth), m_nFormat(nFormat)
    {}

    CColumnInfo(const CColumnInfo& colInfo)
    {
        m_nFormat = colInfo.m_nFormat;
        m_nWidth = colInfo.m_nWidth;
        m_nCol = colInfo.m_nCol;
    }

    CColumnInfo& operator=(const CColumnInfo& colInfo)
    {
        if (this != &colInfo)
        {
            m_nCol = colInfo.m_nCol;
            m_nFormat = colInfo.m_nFormat;
            m_nWidth = colInfo.m_nWidth;
        }

        return (*this);
    }

    bool operator ==(const CColumnInfo &colinfo) const
    {
        return ( (m_nCol      == colinfo.m_nCol)  &&
                 (m_nFormat == colinfo.m_nFormat) &&
                 (m_nWidth  == colinfo.m_nWidth) );
    }

    // Temp members so that CNode can access & modify data. Should be removed soon.
public:
    INT GetColIndex  ()   const    {return m_nCol;}
    INT GetColWidth  ()   const    {return m_nWidth;}
    bool IsColHidden ()   const    {return (m_nFormat & HDI_HIDDEN);}

    void SetColIndex (INT nCol)    {m_nCol = nCol;}
    void SetColWidth (INT nWidth)  {m_nWidth = nWidth;}
    void SetColHidden(bool bHidden = true)
    {
        if (bHidden)
            m_nFormat |= HDI_HIDDEN;
        else
            m_nFormat &= ~HDI_HIDDEN;
    }

protected:
    INT           m_nCol;       // The index supplied when snapin inserted the column.
                                // This is not the index viewed by the user.
    INT           m_nWidth;
    INT           m_nFormat;

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);

protected:
    DEFINE_XML_TYPE(XML_TAG_COLUMN_INFO);
    virtual void Persist(CPersistor &persistor);
};

//+-------------------------------------------------------------------
//
//  Class:      ColPosCompare
//
//  Purpose:    Compare the column position in CColumnInfo and the given position.
//              This is used to reorder/search the columns.
//
//  History:    10-27-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
struct ColPosCompare : public std::binary_function<const CColumnInfo, INT, bool>
{
    bool operator() (const CColumnInfo colinfo, INT nCol) const
    {
        return (nCol == colinfo.GetColIndex());
    }
};


//+-------------------------------------------------------------------
//
//  Class:      CColumnInfoList
//
//  Purpose:    linked list with CColumnInfo's.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
typedef list<CColumnInfo> CIL_base;
class CColumnInfoList : public XMLListCollectionImp<CIL_base>, public CSerialObject
{
public:
    friend class  CColumnSetData;

public:
    CColumnInfoList ()
    {
    }

    ~CColumnInfoList()
    {
    }

protected:
    DEFINE_XML_TYPE(XML_TAG_COLUMN_INFO_LIST);
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);
};

#endif // COLUMNINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\comptr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       comptr.h
//
//--------------------------------------------------------------------------

#ifndef COMPTR_H
#define COMPTR_H

#pragma warning(disable:4800)
#include <comdef.h>
#define CIP_RETYPEDEF(I) typedef I##Ptr I##CIP;
#define CIP_TYPEDEF(I) _COM_SMARTPTR_TYPEDEF(I, IID_##I); CIP_RETYPEDEF(I);
#define DEFINE_CIP(x)\
	CIP_TYPEDEF(x)

#define DECLARE_CIP(x) DEFINE_CIP(x) x##CIP

CIP_RETYPEDEF(IUnknown);
CIP_RETYPEDEF(IDataObject);
CIP_RETYPEDEF(IStorage);
CIP_RETYPEDEF(IStream);
CIP_RETYPEDEF(IPersistStorage);
CIP_RETYPEDEF(IPersistStream);
CIP_RETYPEDEF(IPersistStreamInit);
CIP_RETYPEDEF(IDispatch);

#endif // COMPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\constatbar.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      constatbar.h
 *
 *  Contents:  Interface file for CConsoleStatusBar
 *
 *  History:   24-Aug-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CONSTATBAR_H
#define CONSTATBAR_H
#pragma once


class CConsoleStatusBar
{
public:
    virtual SC ScSetStatusText (LPCTSTR pszText) = 0;
};


#endif /* CONSTATBAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\contree.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      contree.h
 *
 *  Contents:  Interface file for CConsoleTree
 *
 *  History:   24-Aug-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CONTREE_H
#define CONTREE_H
#pragma once


class CConsoleTree
{
public:
    virtual SC ScSetTempSelection    (HTREEITEM htiSelected) = 0;
    virtual SC ScRemoveTempSelection ()                      = 0;
    virtual SC ScReselect            ()                      = 0;
};


#endif /* CONTREE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\conview.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      conview.h
 *
 *  Contents:  Interface file for CConsoleView
 *
 *  History:   24-Aug-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CONVIEW_H
#define CONVIEW_H
#pragma once


// declarations
class CMemento;
class CContextMenuInfo;
class CConsoleStatusBar;

class CConsoleView
{
public:
    enum WebCommand
    {
        eWeb_Back = 1,
        eWeb_Forward,
        eWeb_Home,
        eWeb_Refresh,
        eWeb_Stop,
    };

    //
    // NOTE: ePane_Tasks is being added to have a pane identifier for
    // the task view pane. Currently no task view information is stored
    // in the pane info array, so the use of ePane_Tasks as an index is
    // of limited value.
    //
    enum ViewPane
    {
        ePane_None = -1,
        ePane_ScopeTree,
        ePane_Results,
        ePane_Tasks,

        // must be last
        ePane_Count,
        ePane_First = ePane_ScopeTree,
        ePane_Last  = ePane_Tasks,
    };

    static bool IsValidPane (ViewPane ePane)
        { return ((ePane >= ePane_First) && (ePane <= ePane_Last)); }

public:
    virtual SC ScCut                        (HTREEITEM htiCut)    = 0;
    virtual SC ScPaste                      ()                    = 0;
    virtual SC ScToggleStatusBar            ()                    = 0;
    virtual SC ScToggleDescriptionBar       ()                    = 0;
    virtual SC ScToggleScopePane            ()                    = 0;
    virtual SC ScToggleTaskpadTabs          ()                    = 0;
    virtual SC ScContextHelp                ()                    = 0;
    virtual SC ScHelpTopics                 ()                    = 0;
    virtual SC ScShowSnapinHelpTopic        (LPCTSTR pszTopic)    = 0;
    virtual SC ScSaveList                   ()                    = 0;
    virtual SC ScGetFocusedItem             (HNODE& hNode, LPARAM& lCookie, bool& fScope) = 0;
    virtual SC ScSetFocusToPane             (ViewPane ePane)      = 0;
    virtual SC ScSelectNode                 (MTNODEID id, bool bSelectExactNode = false) = 0;
    virtual SC ScExpandNode                 (MTNODEID id, bool fExpand, bool fExpandVisually) = 0;
    virtual SC ScShowWebContextMenu         ()                    = 0;
    virtual SC ScSetDescriptionBarText      (LPCTSTR pszDescriptionText) = 0;
    virtual SC ScViewMemento                (CMemento* pMemento)  = 0;
    virtual SC ScChangeViewMode             (int nNewMode)        = 0;
    virtual SC ScJiggleListViewFocus        ()                    = 0;
    virtual SC ScRenameListPadItem          ()                    = 0;
    virtual SC ScOrganizeFavorites          ()                    = 0; // bring up the "Organize Favorites" dialog.
    virtual SC ScLineUpIcons                ()                    = 0; // line up the icons in the list
    virtual SC ScAutoArrangeIcons           ()                    = 0; // auto arrange the icons in the list
    virtual SC ScOnRefresh                  (HNODE hNode, bool bScope, LPARAM lResultItemParam) = 0; // refresh the result pane.
    virtual SC ScOnRename                   (CContextMenuInfo *pContextInfo) = 0; // allows the user to rename the specified item
    virtual SC ScRenameScopeNode            (HMTNODE hMTNode)     = 0; // put the specified scope node into rename mode.

    virtual SC ScGetStatusBar               (CConsoleStatusBar **ppStatusBar) = 0;

    virtual ViewPane GetFocusedPane         ()                    = 0;
    virtual int      GetListSize            ()                    = 0;
    virtual HNODE    GetSelectedNode        ()                    = 0;
    virtual HWND     CreateFavoriteObserver (HWND hwndParent, int nID) = 0;
};



#endif /* CONVIEW_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\comptrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       comptrs.h
//
//--------------------------------------------------------------------------

#ifndef COMPTRS_H
#define COMPTRS_H

#ifndef COMPTR_H
#include <comptr.h>
#endif

#endif // COMPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\condoc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       condoc.h
//
//  This file defines interface to access document from node manager side
//--------------------------------------------------------------------------

#pragma once

#if !defined(CONDOC_H_INCLUDED)
#define CONDOC_H_INCLUDED


/***************************************************************************\
 *
 * CLASS:  CConsoleDocument
 *
 * PURPOSE: Defines interface to access document from node manager side
 *
\***************************************************************************/
class CConsoleDocument
{
public:
    virtual SC ScOnSnapinAdded       (PSNAPIN pSnapIn)   = 0;
    virtual SC ScOnSnapinRemoved     (PSNAPIN pSnapIn)   = 0;
    virtual SC ScSetHelpCollectionInvalid()              = 0;
};

#endif // !defined(CONDOC_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\comstrm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       comstrm.h
//
//--------------------------------------------------------------------------

#ifndef COMSTRM_H
#define COMSTRM_H

#ifndef COMPTRS_H
#include <comptrs.h>
#endif
#ifndef COMBSTR_H
#include <combstr.h>
#endif

namespace microsoft	{
namespace com {

class stream_ptr
	{
	// Construction
	public: stream_ptr() throw()
		// Sets the stream to NULL
		: m_pStream()
		{
		}

	public: stream_ptr(const stream_ptr& pStream) explicit throw()
		: m_pStream()
		{
		Initialize(pStream.m_pStream);
		}

	public: stream_ptr(IStream* pStream) explicit throw()
		// Saves the stream
		: m_pStream()
		{
		Initialize(pStream);
		}

	//REVIEW: add template constructors

	public: stream_ptr(HGLOBAL global) explicit throw()
		// Creates a stream on top of the global
		: m_pStream()
		{
		Initialize(global);
		}

	public: stream_ptr(LPCOLESTR filename) explicit throw()
		// Creates a stream on top of the specified file
		: m_pStream()
		{
		Initialize(filename);
		}

	public: stream_ptr(STGMEDIUM& stgMedium) explicit throw()
		// Saves the provided stream.
		: m_pStream()
		{
		Initialize(stgMedium);
		}

	public: stream_ptr(STGMEDIUM* pStgMedium) explicit throw()
		// Saves the provided stream.
		: m_pStream()
		{
		if (pStgMedium)
			Initialize(*pStgMedium);
		}
	
	//REVIEW: Add Create and Open functions
	//REVIEW: Add all of the assignment operators, cast operators, attach, detach, ->, *, etc.
	
	public: operator IStream*() const throw()
		{
		//REVIEW: trace on null would be helpful
		return m_pStream;
		}

	public: IStream* operator->() const throw()
		{
		//REVIEW: trace on null would be helpful
		return m_pStream;
		}

	public: IStream& operator*() const throw()
		{
		//REVIEW: trace on null would be helpful
		return *m_pStream;
		}

	// Write interfaces
	public: HRESULT Write(
		const void* pBuffer, unsigned long writeCount, unsigned long& written) throw()
		// Write the data contained in the buffer
		{
		if (m_pStream == NULL)
			return E_FAIL; //REVIEW: correct failure code?
		return m_pStream->Write(pBuffer, writeCount, &written);
		}

	public: HRESULT Write(const void* pBuffer, unsigned long writeCount) throw()
		{
		unsigned long written;
		return Write(pBuffer, writeCount, written);
		}

	public: HRESULT Write(const wchar_t* string) throw()
		{
		unsigned long len=wcslen(string)+1;
		return Write(string, len*sizeof(wchar_t), len);
		}

	public: HRESULT Write(const char* string) throw()
		{
		unsigned long len=strlen(string)+1;
		return Write(string, len, len);
		}
	
	public: HRESULT Write(const bstr& bstr) throw()
		{
		return Write(static_cast<const wchar_t*>(bstr));
		}

	//REVIEW: Read interfaces
	//REVIEW: Seek
	//REVIEW: Stat - broken out
	
	// Initialization.  May be used by derived classes to setup the stream for
	// different types of storage mediums.  These functions are all re-entrant,
	// and may be called at any time.  They perform all of the appropriate
	// clean up and releasing of any resources in previous use.
	protected: void Initialize(HGLOBAL hg) throw()
		{
		//REVIEW: make re-entrant and bullet proof
		HRESULT const hr = CreateStreamOnHGlobal(hg, FALSE, &m_pStream);
		ASSERT(SUCCEEDED(hr));
		}

	protected: void Initialize(IStream* pStream) throw()
		{
		//REVIEW: make re-entrant and bullet proof
		m_pStream = pStream;
		}

	protected: void Initialize(LPCOLESTR filename) throw()
		{
		//REVIEW: make re-entrant and bullet proof
		#if 0 //REVIEW:  need to create FileStream before this can be enabled
		if (!filename || !*filename)
			return false;

		cip<FileStream> fs = new CComObject<FileStream>;
		if (!fs)
			return false;

		HRESULT hr = fs->Open(filename);
		if (FAILED(hr))
			return false;

		m_pStream = fs;
		return true;
		#endif // 0
		}

	protected: void Initialize(STGMEDIUM& storage) throw()
		// Initializes the read/write functions based on the type of storage
		// medium.  If there is a problem, the reader/writer is not set.
		{
		//REVIEW: make re-entrant and bullet proof
		switch (storage.tymed)
			{
			case TYMED_HGLOBAL:
				Initialize(storage.hGlobal);
				return;

			case TYMED_FILE:
				Initialize(storage.lpszFileName);
				return;

			case TYMED_ISTREAM:
				Initialize(storage.pstm);
				return;
			}
		}

	// Implementation
	private: IStreamCIP m_pStream;
		// This stream is created and used when the TYMED type is HGLOBAL.

	}; // class streamptr

} // namespace com
} // namespace microsoft

#ifndef MICROSOFT_NAMESPACE_ON
using namespace microsoft;
#ifndef COM_NAMESPACE_ON
using namespace com;
#endif // COM_NAMESPACE_ON
#endif // MICROSOFT_NAMESPACE_ON

#endif // COMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\conframe.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      conframe.h
 *
 *  Contents:  Interface file for CConsoleFrame.
 *
 *  History:   24-Aug-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef CONFRAME_H
#define CONFRAME_H
#pragma once


struct CreateNewViewStruct;
class CConsoleStatusBar;
class CConsoleView;

class CConsoleFrame
{
public:
    virtual SC ScGetActiveStatusBar   (CConsoleStatusBar*& pStatusBar) = 0;
    virtual SC ScGetActiveConsoleView (CConsoleView*& pConsoleView)    = 0;
    virtual SC ScCreateNewView        (CreateNewViewStruct* pcnvs, 
                                       bool bEmitScriptEvents = true)  = 0;
    virtual SC ScUpdateAllScopes      (LONG lHint, LPARAM lParam)      = 0;
    virtual SC ScGetMenuAccelerators  (LPTSTR pBuffer, int cchBuffer)  = 0;

    virtual SC ScShowMMCMenus         (bool bShow)                     = 0;
};


#endif /* CONFRAME_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\countof.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      countof.h  
 *
 *  Contents:           
 *
 *  History:   12-May-98 JeffRo     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef __COUNTOF_H__
#define __COUNTOF_H__
#pragma once

/*-------------------------------------------------------------------*/
/* Define a safe function that will return the count of elements     */
/* in an array.  It is safe because it won't compile if the argument */
/* is not an array, whereas the classic macro to do this:            */
/*                                                                   */
/*     #define countof(a)  (sizeof(a) / sizeof(a[0]))                */
/*                                                                   */
/* will compile if given a pointer, but will almost certainly not    */
/* give the expected result.                                         */
/*                                                                   */
/* Unfortunately, the compiler won't compile this yet.               */
/*-------------------------------------------------------------------*/
#if _MSC_VER > 1400
#error See if the compiler can handle the countof<T> template now.
#endif

#ifdef COMPILER_WONT_COMPILE_THIS
    template <typename T, size_t N>
    inline size_t countof(T (&a)[N]) 
        { return N; }
#else
    #define countof(x) (sizeof(x) / sizeof((x)[0]))
#endif


#endif  // __COUNTOF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\cpputil.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      cpputil.h
 *
 *  Contents:  Miscellaneous C++ utilities
 *
 *  History:   29-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


/*
 * add these to a class declaration if you don't want it to be copied
 * and/or assigned
 */
#define DECLARE_NOT_COPIABLE(  ClassName)    private: ClassName           (const ClassName&);    // not implemented
#define DECLARE_NOT_ASSIGNABLE(ClassName)    private: ClassName& operator=(const ClassName&);    // not implemented
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\events.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       events.h
//
//  History:    09-24-1999 VivekJ created
//--------------------------------------------------------------------------

/************************************************************************
 * This file contains classes that provide support for the Observer pattern,
 * or publish-subscribe.
 *
 * Event sources send notifications to event observers. The parameterized type
 * is the event observer class, or (C++) interface.
 *
 * To use this mechanism, derive your event source class from CEventSource
 * parameterized by the observer class(es) or interface(es). Add a specific observer object
 * to the list of observers by calling the AddObserver function. The observer object class
 * should derive from CObserverBase.
 *
 * When the source wishes to call a particular notification method in the
 * observer class, use ScFireEvent template method.
 * specify observer's method as a 1st parameter. for instance: CMyObserver::MyEvent
 * [optionaly] specify parameters to event as 2nd and following parameters to ScFireEvent
 *
 * All event observer notification methods MUST return SC's.
 *
 * You can not have other method with the same name as event on observer - it won't compile.
 *
 * When sources/observers are deleted, the connection between them is broken automatically.
 * There is no support as yet to manually break a connection, although such a method can
 * be easily added to either the source or observer (make sure both sides of the connection
 * are broken.
 *
 * See the test code at the end of the file as an example.
 ************************************************************************/

// a #define to make it easy to implement only some observer methods.
#define DEFAULT_OBSERVER_METHOD SC sc; return sc;

#include "cpputil.h"
/*+-------------------------------------------------------------------------*
 * class CObserverBase
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class CObserverBase;

/*+-------------------------------------------------------------------------*
 * class CEventSourceBase
 *
 *
 * PURPOSE: provides general Event Source interface
 *
 *+-------------------------------------------------------------------------*/
class CEventSourceBase
{
public:
    virtual ~CEventSourceBase() {}
    virtual void UnadviseSource(CObserverBase &observer) =0;

};

/*+-------------------------------------------------------------------------*
 * class _CEventSource
 *
 *
 * PURPOSE: implements connection between event source and observer
 *
 * NOTE:    This class IS NOT intended for external use - use CEventSource instead
 *
 *+-------------------------------------------------------------------------*/
template<class CObserver>
class _CEventSource : public CEventSourceBase
{
private:
    typedef CObserver *                 POBSERVER;
    typedef _CEventSource<CObserver>    ThisClass;

    // no std::set, or std::map please
    // those cannot be shared by several DLL's
    // see KB article Q172/3/96

    // since some items may be gone and some new added during the operation,
    // std::list is the best choice, since it does not reallocate on insert
    // but that is not enough - see CListIntegrityProtector class below
    struct ObserverData
    {
        POBSERVER pObject;  // pointer to the object
        bool      bDeleted; // true means entry remove pending, pObject not valid
    };

    typedef std::list< ObserverData > CObserverList;

    CObserverList m_observerList;

    // count of active locks.
    // when value is 0, it is safe to remove deleted items from the list.
    int m_nStackDepth;

    // removes deleted items from the list
    void CleanupDeleted();

protected:
    typedef CObserverList::iterator   iterator;

    /***************************************************************************\
     *
     * CLASS:  CListIntegrityProtector
     *
     * PURPOSE: locks the list in the owning class from item deletion.
     *          thus assures the list is safe to iterate, the client just
     *          needs to skip deleted entries.
     *          Destructor will release the lock, an in case this is the last
     *          lock - will perforn the cleanup.
     *
     *          this technique is needed, since objects get deleted and created
     *          during the events, so the observer list is changed, which
     *          invalidated the iterators. Using the std::list and postponing
     *          cleanup allowed to deal with 'live' list safelly.
     *
     * USAGE:   Create the object of this class in scope where you need to
     *          make sure the items does not get deleted from the list.
     *
    \***************************************************************************/
    friend class CListIntegrityProtector;
    class CListIntegrityProtector
    {
        DECLARE_NOT_COPIABLE(CListIntegrityProtector)
        DECLARE_NOT_ASSIGNABLE(CListIntegrityProtector)

        ThisClass *m_pOwner;
    public:
        // constructor (increments iterator count)
        CListIntegrityProtector(ThisClass *pOwner) : m_pOwner(pOwner)
        {
            ASSERT(pOwner);
            if (pOwner)
                ++(pOwner->m_nStackDepth);
        }

        // destructor (decrements iterator count - cleans up if not iterators left)
        ~CListIntegrityProtector()
        {
            ASSERT(m_pOwner);
            if ( m_pOwner && ( 0 == --(m_pOwner->m_nStackDepth) ) )
                m_pOwner->CleanupDeleted();
        }
    };

protected:
    CObserverList & GetObserverList() { return m_observerList;}

public:
    _CEventSource() : m_nStackDepth(0) {};
    virtual ~_CEventSource();    // disconnects all listeners

    void _AddObserver(CObserver &observer);
    virtual void  UnadviseSource(CObserverBase &observer); // to disconnect a particular observer. (only disconnects this side)
};

/***************************************************************************\
 *
 * CLASSES:  _CEventSource1 - _CEventSource5
 *
 * PURPOSE: these classes do not add anything to _CEventSource
 *          defining them is just required for using them as base classes
 *          of CEventSource_ [ same class cannot appear twice in base class list]
 *
 * NOTE:    These classes ARE NOT intended for external use
 *
\***************************************************************************/
template<class CObserver> class _CEventSource1 : public _CEventSource<CObserver> {};
template<class CObserver> class _CEventSource2 : public _CEventSource<CObserver> {};
template<class CObserver> class _CEventSource3 : public _CEventSource<CObserver> {};
template<class CObserver> class _CEventSource4 : public _CEventSource<CObserver> {};
template<class CObserver> class _CEventSource5 : public _CEventSource<CObserver> {};


/*+-------------------------------------------------------------------------*
 * CVoid
 *
 * This is a do-nothing class that is used for the _CEventSourceX
 * specializations below.  _CEventSourceX used specializations of "void"
 * and the default types for the Es2-Es5 template parameters of CEventSource
 * used to be "void".  Newer (i.e. Win64) compilers, however, will issue
 * C2182 ("illegal use of type 'void'") and won't allow void to be the
 * default type.
 *--------------------------------------------------------------------------*/
class CVoid {};

/***************************************************************************\
 *
 * SPECIALIZATIONS: _CEventSource1 - _CEventSource5 for void parameters
 *
 * PURPOSE: This allows to have single template for different count of observers.
 *          The specialization defines empty and harmless base clases
 *          for default template parameters
 *
 * NOTE:    These classes ARE NOT intended for external use
 *
\***************************************************************************/
template<> class _CEventSource2<CVoid> {}; // specializes _CEventSource2<CVoid> as empty class
template<> class _CEventSource3<CVoid> {}; // specializes _CEventSource3<CVoid> as empty class
template<> class _CEventSource4<CVoid> {}; // specializes _CEventSource4<CVoid> as empty class
template<> class _CEventSource5<CVoid> {}; // specializes _CEventSource5<CVoid> as empty class

/***************************************************************************\
 *
 * CLASS:   CEventSource
 *
 * PURPOSE: This class implements Event emitting capability to be used by
 *          event-emitter classes derived from it.
 *          Implements ScFireEvent methods and AddObserver method
 *
 * USAGE:   use spacialization of this class as base class for your event-emitter class
 *          See the list of possible usage paterns below:
 *          class CMyClassWithEvents : public CEventSource<CMyObserver> ...
 *          class CMyClassWithEvents : public CEventSource<CMyObserver1, CMyObserver2> ...
 *          ...
 *          class CMyClassWithEvents : public CEventSource<CMyObserver1, CMyObserver2, CMyObserver3, CMyObserver4, CMyObserver5> ...
 *
 * NOTE:    Do not derive from this class more than once - add template parameters instead
 *
\***************************************************************************/
template<class Es1, class Es2 = CVoid, class Es3 = CVoid, class Es4 = CVoid, class Es5 = CVoid>
class CEventSource : public _CEventSource1<Es1>,
                     public _CEventSource2<Es2>, // NOTE: this will be empty class if Es2 == CVoid
                     public _CEventSource3<Es3>, // NOTE: this will be empty class if Es3 == CVoid
                     public _CEventSource4<Es4>, // NOTE: this will be empty class if Es4 == CVoid
                     public _CEventSource5<Es5>  // NOTE: this will be empty class if Es5 == CVoid
{
public:

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer>
     *
     * PURPOSE: implements ScFireEvent for parameter-less events
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass>
    SC ScFireEvent(SC (observerclass::*_EventName)())
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - no parameters"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)();
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer, P1>
     *
     * PURPOSE: implements ScFireEvent for events with one parameter
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *    _P1 p1                       - parameter to be passed
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass, class _P1>
    SC ScFireEvent(SC (observerclass::*_EventName)(_P1 p1), _P1 p1)
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - one parameter"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)(p1);
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer, P1, P2>
     *
     * PURPOSE: implements ScFireEvent for events with two parameters
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *    _P1 p1                       - parameter to be passed
     *    _P2 p2                       - parameter to be passed
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass, class _P1, class _P2>
    SC ScFireEvent(SC (observerclass::*_EventName)(_P1 p1, _P2 p2), _P1 p1, _P2 p2)
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - two parameters"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)(p1, p2);
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer, P1, P2, P3>
     *
     * PURPOSE: implements ScFireEvent for events with three parameters
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *    _P1 p1                       - parameter to be passed
     *    _P2 p2                       - parameter to be passed
     *    _P3 p3                       - parameter to be passed
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass, class _P1, class _P2, class _P3>
    SC ScFireEvent(SC (observerclass::*_EventName)(_P1 p1, _P2 p2, _P3 p3), _P1 p1, _P2 p2, _P3 p3)
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - three parameters"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)(p1, p2, p3);
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer, P1, P2, P3, P4>
     *
     * PURPOSE: implements ScFireEvent for events with four parameters
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *    _P1 p1                       - parameter to be passed
     *    _P2 p2                       - parameter to be passed
     *    _P3 p3                       - parameter to be passed
     *    _P4 p4                       - parameter to be passed
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass, class _P1, class _P2, class _P3, class _P4>
    SC ScFireEvent(SC (observerclass::*_EventName)(_P1 p1, _P2 p2, _P3 p3, _P4 p4), _P1 p1, _P2 p2, _P3 p3, _P4 p4)
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - three parameters"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)(p1, p2, p3, p4);
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::ScFireEvent<Observer, P1, P2, P3, P4, P5>
     *
     * PURPOSE: implements ScFireEvent for events with four parameters
     *
     * PARAMETERS:
     *    SC (Observer::*_EventName)() - pointer to Observer's method
     *    _P1 p1                       - parameter to be passed
     *    _P2 p2                       - parameter to be passed
     *    _P3 p3                       - parameter to be passed
     *    _P4 p4                       - parameter to be passed
     *    _P5 p5                       - parameter to be passed
     *
     * RETURNS:
     *    SC    - result code
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass, class _P1, class _P2, class _P3, class _P4, class _P5>
    SC ScFireEvent(SC (observerclass::*_EventName)(_P1 p1, _P2 p2, _P3 p3, _P4 p4, _P5 p5), _P1 p1, _P2 p2, _P3 p3, _P4 p4, _P5 p5)
    {
        DECLARE_SC(sc, TEXT("CEventSource::ScFireEvent - three parameters"));

        typedef _CEventSource<observerclass> BC;
        BC::CListIntegrityProtector(this); // protect the list while iterating

        for(BC::iterator iter = BC::GetObserverList().begin(); iter != BC::GetObserverList().end(); ++iter)
        {
            // skip deleted objects
            if (iter->bDeleted)
                continue;

            // sanity check
            sc = ScCheckPointers( iter->pObject, E_UNEXPECTED);
            if (sc)
                return sc;

            // invoke method "_EventName" on object pointed by *iter
            sc = ((iter->pObject)->*_EventName)(p1, p2, p3, p4, p5);
            if(sc)
                return sc;
        }
        return sc;
    }

    /***************************************************************************\
     *
     * METHOD:  CEventSource::AddObserver<Observer>
     *
     * PURPOSE: adds observer to the list
     *
     * PARAMETERS:
     *    Observer &observer - observer to add to the list
     *
     * RETURNS:
     *
     * NOTE:  It must be both declared and defined here - will not compile else
     *
    \***************************************************************************/
    template<class observerclass>
    void AddObserver(observerclass &observer)
    {
        typedef _CEventSource<observerclass> BC;
        // NOTE: if you are getting the error here, probably you are passing a type
        // derived from actual Observer class to AddObserver(). Please cast it to appr. type
        BC::_AddObserver(observer);
    }
};


/*+-------------------------------------------------------------------------*
 * class CObserverBase
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class CObserverBase
{
    typedef CEventSourceBase *      PEVENTSOURCE;

    // no std::set, or std::map please
    // those cannot be shared by several DLL's
    // see KB article Q172/3/96 (Q172396)
    typedef std::list<PEVENTSOURCE> CSourceList;    // list of all event sources that this object is connected to.
    typedef CSourceList::iterator   iterator;

    CSourceList m_sourceList;
    CSourceList & GetSourceList() { return m_sourceList;}

public:
    CObserverBase() {};
    virtual ~CObserverBase();

    void    UnadviseObserver(CEventSourceBase &source); // to disconnect a particular source (this side only)
    void    _AddSource(CEventSourceBase &source);

    void    UnadviseAll();       // disconnects all connections - both sides
};

//############################################################################
//############################################################################
//
//  Implementation of class CObserverBase
//
//############################################################################
//############################################################################


/*+-------------------------------------------------------------------------*
 *
 * CObserverBase::UnadviseObserver
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CEventSourceBase & source :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
inline void
CObserverBase::UnadviseObserver(CEventSourceBase &source)
{
    DECLARE_SC(sc, TEXT("CObserverBase::UnadviseObserver"));

    iterator it = std::find( GetSourceList().begin(), GetSourceList().end(), &source );

    // check if found
    if ( it == GetSourceList().end() )
    {
        sc = E_UNEXPECTED;
        return;
    }

    GetSourceList().erase(it);
}


inline void
CObserverBase::_AddSource(CEventSourceBase &source)
{
    GetSourceList().push_back(&source);
}

/*+-------------------------------------------------------------------------*
 *
 * CObserverBase::~CObserverBase
 *
 * PURPOSE: Destructor
 *
 *+-------------------------------------------------------------------------*/
inline CObserverBase::~CObserverBase()
{
    // disconnect all sources connected to this observer.
    iterator iter;
    for(iter = GetSourceList().begin(); iter != GetSourceList().end(); iter++)
    {
        (*iter)->UnadviseSource(*this);
    }
}

//############################################################################
//############################################################################
//
//  Implementation of class CEventSource
//
//############################################################################
//############################################################################

/*+-------------------------------------------------------------------------*
 *
 * _CEventSource::_AddObserver
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CObserver & observer :
 *
 *+-------------------------------------------------------------------------*/
template<class CObserver>
void
_CEventSource<CObserver>::_AddObserver(CObserver &observer)
{
    ObserverData observerData = { &observer, false /*bDeleted*/ };

    GetObserverList().push_back( observerData );
    observer._AddSource(*this);
}


/*+-------------------------------------------------------------------------*
 *
 * _CEventSource::~_CEventSource
 *
 * PURPOSE: Destructor
 *
 *+-------------------------------------------------------------------------*/
template<class CObserver>
_CEventSource<CObserver>::~_CEventSource()
{
    //disconnect all observers connected to this source

    {
        CListIntegrityProtector(this); // protect the list while iterating

        iterator iter;
        for(iter = GetObserverList().begin(); iter != GetObserverList().end(); ++iter)
        {
            if (!iter->bDeleted && iter->pObject)
                iter->pObject->UnadviseObserver(*this);
        }
    }

    ASSERT( m_nStackDepth == 0 );

    GetObserverList().clear();
}

/*+-------------------------------------------------------------------------*
 *
 * _CEventSource<CObserver>::CleanupDeleted()
 *
 * PURPOSE: removes entries marked as deleted
 *
 *+-------------------------------------------------------------------------*/
template<class CObserver>
void _CEventSource<CObserver>::CleanupDeleted()
{
    ASSERT ( m_nStackDepth == 0 );

    for(iterator iter = GetObserverList().begin(); iter != GetObserverList().end();)
    {
        if (iter->bDeleted)
            iter = GetObserverList().erase( iter );
        else
            ++iter; // valid - skip
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CEventSource::UnadviseSource
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CObserver & observer :
 *
 *+-------------------------------------------------------------------------*/
template<class CObserver>
void
_CEventSource<CObserver>::UnadviseSource(CObserverBase &observer)
{
    // we cannot dynamic cast the observer pointer to a CObserver pointer,
    // becuase UnadviseSource is called from ~CObserverBase(), by which time
    // the CObserver sub-object has already been deleted. Instead, we search for
    // the CObserverBase pointer in the Observer List.
    iterator iter, iterNext;
    bool    bFound = false;

    CListIntegrityProtector(this); // protect the list while iterating

    for(iter = GetObserverList().begin(); iter != GetObserverList().end(); iter++)
    {
        if(!iter->bDeleted && static_cast<CObserverBase *>(iter->pObject) == &observer)
        {
            // do not alter the list directly, let the cleanup do the work
            // just mark the entry as invalid
            iter->bDeleted = true;
            iter->pObject = NULL;
            bFound = true;
            break;
        }
    }

    ASSERT(bFound);
}


//############################################################################
//############################################################################
//
//  stoopid test code
//
//############################################################################
//############################################################################
#ifdef TEST_EVENTS

class CTestObserver : public CObserverBase
{
public:
    SC  ScMyEvent(int a)
    {
        ASSERT(0 && "Reached here!");
        return S_OK;
    }
};

class CTestObserver2 : public CObserverBase
{
public:
    SC  ScMyEvent(int a)
    {
        ASSERT(0 && "Reached here!");
        return S_OK;
    }

    SC  ScMyEvent2(int a,int d)
    {
        ASSERT(0 && "Reached here!");
        return S_OK;
    }
};

class CTestObserver3 : public CObserverBase
{
public:
    SC  ScMyOtherEvent()
    {
        ASSERT(0 && "Reached here!");
        return S_OK;
    }
};

class CTestEventSource : public CEventSource<CTestObserver,CTestObserver2, CTestObserver3>
{
public:
    void FireEvent()
    {
        DECLARE_SC(sc, TEXT("FireEvent"));

        sc = ScFireEvent(CTestObserver::ScMyEvent, 42 /*arg1*/);
        sc = ScFireEvent(CTestObserver2::ScMyEvent2, 42 /*arg1*/, 24 /*arg1*/);
        sc = ScFireEvent(CTestObserver3::ScMyOtherEvent);
    }
};


static void DoEventTest()
{
    CTestEventSource source;
    CTestObserver    observer_1;
    CTestObserver2   observer_2;
    CTestObserver3   observer_3;


    source.AddObserver(observer_2);
    source.AddObserver(observer_3);
    source.AddObserver(observer_1);
    source.FireEvent();     // should fire to observer1 only.

    {
        // new scope
        CTestObserver   observer2;
        source.AddObserver(observer2);
        source.FireEvent();     // should fire to observer1 and observer2.
        // observer2 is deleted here.
    }

    source.FireEvent();     // should fire to observer1 only.

}

class CTestObject
{
public:
    CTestObject()
    {
        DoEventTest();
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\eventlock.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000 - 2000
//
//  File:       eventlock.h
//
//  This file contains code needed to fire script event in a safer way
//  Locks made on stack will postpone firing the event on particular interface
//  as long as the last lock is released.
//--------------------------------------------------------------------------

#pragma once

#if !defined(EVENTLOCK_H_INCLUDED)
#define EVENTLOCK_H_INCLUDED


/***************************************************************************\
 *
 * CLASS:  CEventBuffer
 *
 * PURPOSE: objects this class maintains the interface locks by exposing 
 *          methods Lock(), Unlock() and IsLocked(); It also implements queue
 *          of script events accessible thru ScEmitOrPostpone(); Events in the queue
 *          will be automatically emited when the last lock is removed by
 *          calling Unlock() method.
 *
 * USAGE:   Object of this class are constucted as global or static variables
 *          per each monitored interface. 
 *          Currently it is used (as static variable) by GetEventBuffer template 
 *          function and is accessed by CEventLock object put on the stack by
 *          LockComEventInterface macro
 *
\***************************************************************************/
class MMCBASE_API CEventBuffer
{
    // structure containing postponed script event
    // since it is a dipinterface call, data consists of pointer to
    // IDispatch interface , disp_id and the array of parameters
    struct DispCallStr
    {
        IDispatchPtr                spDispatch; 
        DISPID                      dispid;
        std::vector<CComVariant>    vars;
    };

    // queue of postponed events
    std::queue<DispCallStr> m_postponed;
    // lock count
    int                     m_locks;

public:
    // constructor. No locks initially
    CEventBuffer() : m_locks(0) {}

    // locking methods
    void Lock()     { m_locks++; }
    void Unlock()   { ASSERT(m_locks > 0); if (--m_locks == 0) ScFlushPostponed(); }
    bool IsLocked() { return m_locks != 0; }

    // event emitting / postponing
    SC ScEmitOrPostpone(IDispatch *pDispatch, DISPID dispid, CComVariant *pVar, int count);
private:
    // helper emiting postponed events
    SC ScFlushPostponed();
};

/***************************************************************************\
 *
 * FUNCTION:  GetEventBuffer
 *
 * PURPOSE: This function provides access to static object created in it's body
 *          Having it as template allows us to define as many static objects as
 *          interfaces we have.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CEventBuffer&  - reference to the static object created inside
 *
\***************************************************************************/
MMCBASE_API CEventBuffer& GetEventBuffer();

/***************************************************************************\
 *
 * CLASS:  CEventLock
 *
 * PURPOSE: Template class to allow simple Lock()/Unlock() functionality
 *          by placing instances of this class on the stack.
 *          Constructor will put a lock on the event interface, destructor
 *          will release it.
 *
 * USAGE:   You can place the lock on stack by constructing object directly 
 *          or by using LockComEventInterface macro (which does the same)
 *
\***************************************************************************/
template <typename _dispinterface>
class MMCBASE_API CEventLock
{
public:

    CEventLock()    {  GetEventBuffer().Lock();    }
    ~CEventLock()   {  GetEventBuffer().Unlock();  }
};

/***************************************************************************\
 *
 * MACRO:  LockComEventInterface
 *
 * PURPOSE: Constructs the object on stack which holds a lock on event interface
 *
\***************************************************************************/
#define LockComEventInterface(_dispinterface) \
    CEventLock<_dispinterface> _LocalEventInterfaceLock;


#endif // !defined(EVENTLOCK_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\enumerator.inl ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      enumerator.inl
//
//  Contents:  Supports enumeration for collections of com objects
//
//  History:   08-Mar-2000 AudriusZ    Created
//
//--------------------------------------------------------------------------

#ifndef ENUMERATOR_INL_INCLUDED
#define ENUMERATOR_INL_INCLUDED
#pragma once

/*+-------------------------------------------------------------------------*
 *
 * CMMCNewEnumImpl<BaseClass, _Position, EnumImplementor>::get__NewEnum
 *
 * PURPOSE: Returns new enumerator for collection
 *          in the array rgvar
 *
 * PARAMETERS: 
 *    IUnknown** ppUnk : [out] - new enumerator
 *
 * RETURNS: 
 *    HRESULT
 *
 *+-------------------------------------------------------------------------*/
template <class BaseClass, class _Position, class EnumImplementor>
STDMETHODIMP CMMCNewEnumImpl<BaseClass, _Position, EnumImplementor>::get__NewEnum(IUnknown** ppUnk)
{
    SC  sc;
    EnumImplementor *pEnumImpl = NULL;     //get enum implementor

    // validate the parameter
    sc = ScCheckPointers (ppUnk);
    if (sc)
        return (sc.ToHr());

    *ppUnk = NULL;

    sc = ScGetEnumImplementor(pEnumImpl);
    if(sc)
        return (sc.ToHr());

    // typedef the enumerator
    typedef CComObject<CMMCEnumerator<EnumImplementor, _Position> > CEnumerator;

    // create an instance of the enumerator
    CEnumerator *pEnum = NULL;
    sc = CEnumerator::CreateInstance(&pEnum);
    if (sc)
        return (sc.ToHr());

    if(!pEnum)
        return ((sc = E_UNEXPECTED).ToHr());

    // create a connection between the enumerator and the tied object.
    sc = ScCreateConnection(*pEnum, *pEnumImpl); 
    if(sc)
        return (sc.ToHr());

    // initialize the position using the Reset function
    sc = pEnumImpl->ScEnumReset(pEnum->m_position); 
    if(sc)
        return (sc.ToHr());

    // get the IUnknown from which IEnumVARIANT can be queried
    sc = pEnum->QueryInterface (IID_IUnknown, (void**) ppUnk);
    if (sc)
        return (sc.ToHr());

    return (sc.ToHr());
}       

/*+-------------------------------------------------------------------------*
 *
 * CMMCEnumerator<TiedObj,_Position>::Next
 *
 * PURPOSE: Returns the next celt items starting from the current position
 *          in the array rgvar
 *
 * PARAMETERS: 
 *    unsigned  long :
 *    PVARIANT  rgvar :
 *    unsigned  long :  The number of elements actually fetched
 *
 * RETURNS: 
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
template<class TiedObj, class _Position>
STDMETHODIMP CMMCEnumerator<TiedObj,_Position>::Next(unsigned long celt, PVARIANT rgvar, 
                                                     unsigned long * pceltFetched)
{
    DECLARE_SC(sc, TEXT("CMMCEnumerator::Next"));

    CMyTiedObject *pTiedObj = NULL;
    PVARIANT       pVar = rgvar;
    unsigned long  celtFetched = 0;
    _Position      posTemp = m_position;
    int            i       = 0;
                                   
    sc = ScGetTiedObject(pTiedObj);
    if(sc)                 
        goto Error;

    // initialize the variables.
    if(pceltFetched != NULL)
        *pceltFetched = 0;

    // initialize the array
    for(i = 0; i<celt; i++)
        VariantInit(&rgvar[i]);

    for(celtFetched = 0; celtFetched < celt; celtFetched++, pVar++)
    {
        // at this point, we have a valid position.
        IDispatchPtr spDispatch;

        // Get the next element from the tied object.      
        // The returned IDispatch* _must_ have been AddRef'd for us!
        sc = pTiedObj->ScEnumNext(m_position, *(&spDispatch));
        if(sc)
            goto Error;

        if(sc == SC(S_FALSE) )
            goto Cleanup; // return just the elements so far.

        if(spDispatch == NULL)
        {
            sc = E_UNEXPECTED;
            goto Error;
        }

        // set the dispatch member of the input array to the interface returned
        V_VT       (pVar) = VT_DISPATCH;
        V_DISPATCH (pVar) = spDispatch.Detach();
    }

Cleanup:
    // return the count fetched, if the caller wants it
    if (pceltFetched != NULL)
        *pceltFetched = celtFetched;

    return sc.ToHr();

Error:
    // clear the array.
    for (i=0; i<celt; i++)
        VariantClear(&rgvar[i]);

    //restore the position and set the count to zero.
    m_position = posTemp;
    celtFetched = 0;
    goto Cleanup;

}

/*+-------------------------------------------------------------------------*
 *
 * CMMCEnumerator<TiedObj,_Position>::Skip
 *
 * PURPOSE: Skips over the next celt elements in the enumeration sequence.
 *
 * PARAMETERS: 
 *    unsigned  long :
 *
 * RETURNS: 
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
template<class TiedObj, class _Position>
STDMETHODIMP CMMCEnumerator<TiedObj,_Position>::Skip(unsigned long celt)
{
    DECLARE_SC(sc, TEXT("CMMCEnumerator::Skip"));
    
    CMyTiedObject *pTiedObj = NULL;
                                   
    sc = ScGetTiedObject(pTiedObj);
    if(sc)                         
        return (sc.ToHr());

    /*
     * It's too easy for implementers of ScEnumSkip to forget to
     * return S_FALSE if the count fetched is less than the count
     * requested.  We'll take care of that here.
     */
    unsigned long celtSkipped = celt + 1;

    /*
     * It's also easy for implementers of ScEnumNext to forget 
     * that if the enumeration fails, the position needs to 
     * remain unaffected.
     */
    _Position posT = m_position;

    // call the tied object with the position.
    sc = pTiedObj->ScEnumSkip(celt, celtSkipped, posT);
    if (sc)
        return (sc.ToHr());

    /*
     * success, so update the enumeration position
     */
    m_position = posT;

    /*
     * if this assert fails, the implementation of ScEnumSkip either
     * didn't initialize or didn't update celtSkipped
     */
    ASSERT (celtSkipped <= celt);

    if (celtSkipped < celt)
        sc = S_FALSE;
    if (celtSkipped > celt)
        celtSkipped = celt;     // sanity

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCEnumerator<TiedObj,_Position>::Reset
 *
 * PURPOSE: Resets the enumeration sequence to the beginning
 *
 * RETURNS: 
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
template<class TiedObj, class _Position>
STDMETHODIMP CMMCEnumerator<TiedObj,_Position>::Reset()
{
    DECLARE_SC(sc, TEXT("CMMCEnumerator::Reset"));
    
    CMyTiedObject *pTiedObj = NULL;
                                   
    sc = ScGetTiedObject(pTiedObj);
    if(sc)                         
        return (sc.ToHr());

    // call the tied object with the position.
    sc = pTiedObj->ScEnumReset(m_position);

    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * CMMCEnumerator<TiedObj,_Position>::Clone
 *
 * PURPOSE: Creates a copy of the current state of enumeration
 *
 * PARAMETERS: 
 *    PPENUMVARIANT  ppenum :
 *
 * RETURNS: 
 *    STDMETHODIMP
 *
 *+-------------------------------------------------------------------------*/
template<class TiedObj, class _Position>
STDMETHODIMP CMMCEnumerator<TiedObj,_Position>::Clone(PPENUMVARIANT ppenum)
{
    DECLARE_SC(sc, TEXT("CMMCEnumerator::Clone"));

    if(!ppenum)
    {
        sc = E_INVALIDARG;
        return sc.ToHr();
    }

    CMyTiedObject *pTiedObj = NULL;
                                   
    sc = ScGetTiedObject(pTiedObj);
    if(sc)                         
        return (sc.ToHr());

    typedef CComObject<ThisClass> CNewComObject;
    CNewComObject *pNewComObj = NULL;

    // create an instance of the new enumerator.
    sc = CNewComObject::CreateInstance(&pNewComObj);
    if (sc)
        return (sc.ToHr());

    if(!pNewComObj)
        return ((sc = E_UNEXPECTED).ToHr());

    // at this point the new object has been created.
    // Set the position directly from the present state.
    pNewComObj->m_position = m_position;

    // connect the COM object to the tied object
    sc = ScCreateConnection(*pNewComObj, *pTiedObj);
    if(sc)
        return sc.ToHr();

    // addref the new object for the client.
    *ppenum = pNewComObj;
    (*ppenum)->AddRef();

    return sc.ToHr();
}

/***************************************************************************\
*
* CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::get_Count
*
* PURPOSE: Returns count of items in the collection
*
* RETURNS: 
*    HRESULT
*
\***************************************************************************/
template <class _CollectionInterface, class _ItemInterface>
STDMETHODIMP CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::get_Count( PLONG pCount )
{
    DECLARE_SC(sc, TEXT("CMMCArrayEnumBase::get_Count"));

    // parameter check
    sc = ScCheckPointers(pCount);
    if (sc)
        return sc.ToHr();

    // return the count
    *pCount = m_array.size();

    return sc.ToHr();
}

/***************************************************************************\
*
* CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::Item
*
* PURPOSE: Returns specified item from collection
*
* RETURNS: 
*    HRESULT
*
\***************************************************************************/
template <class _CollectionInterface, class _ItemInterface>
STDMETHODIMP CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::Item( long Index, _ItemInterface ** ppItem )
{
    DECLARE_SC(sc, TEXT("CMMCArrayEnumBase::Item"));

    // parameter check
    sc = ScCheckPointers(ppItem);
    if (sc)
        return sc.ToHr();

    // initialization
    *ppItem = NULL;

    // remember - we are 1 based!
    if (Index < 1 || Index > m_array.size())
        return (sc = E_INVALIDARG).ToHr();

    *ppItem = m_array[Index - 1];

    // recheck the pointer
    sc = ScCheckPointers(*ppItem, E_NOINTERFACE);
    if (sc)
        return sc.ToHr();

   (*ppItem)->AddRef();

    return sc.ToHr();
}

/***************************************************************************\
*
* CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumReset
*
* PURPOSE: Resets position to the first item in the collection
*
* RETURNS: 
*    HRESULT
*
\***************************************************************************/
template <class _CollectionInterface, class _ItemInterface>
::SC CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumReset (unsigned &pos) 
{ 
    DECLARE_SC(sc, TEXT("CMMCArrayEnumBase::ScEnumReset"));

    pos = 0; 
    return sc; 
}

/***************************************************************************\
*
* CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumNext
*
* PURPOSE: Returns item from the collection, advances position
*
* RETURNS: 
*    HRESULT
*
\***************************************************************************/
template <class _CollectionInterface, class _ItemInterface>
::SC CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumNext(unsigned &pos, PDISPATCH & pDispatch)
{
    DECLARE_SC(sc, TEXT("CMMCArrayEnumBase::ScEnumNext"));

    // initialize;
    pDispatch = NULL;
    // check the ranges
    if (pos >= m_array.size())
        return sc = S_FALSE;

    // get element
    pDispatch = m_array[pos];

    // recheck the pointer
    sc = ScCheckPointers(pDispatch, E_NOINTERFACE);
    if (sc)
        return sc;

    pDispatch->AddRef();
    ++pos;

    return sc;
}

/***************************************************************************\
*
* CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumSkip
*
* PURPOSE: Skips the amount of items in enumeration
*
* RETURNS: 
*    HRESULT
*
\***************************************************************************/
template <class _CollectionInterface, class _ItemInterface>
::SC CMMCArrayEnumBase<_CollectionInterface, _ItemInterface>::ScEnumSkip  (unsigned long celt, unsigned long& celtSkipped, unsigned &pos)
{
    DECLARE_SC(sc, TEXT("CMMCArrayEnumBase::ScEnumSkip"));

    // no skipped at start
    celtSkipped = 0;

    // check if it's a void task
    if (!celt)
        return sc;

    // are we behind the last item?
    if (pos >= m_array.size())
        return sc = S_FALSE;

    // how far can we go?
    celtSkipped = m_array.size() - pos;
    
    // but go no more than requested
    if (celtSkipped > celt)
        celtSkipped = celt;

    // advance
    pos += celtSkipped;

    // check if we could do as much as requested
    if (celtSkipped < celt)
        return sc = S_FALSE;

    return sc;
}


#endif  // ENUMERATOR_INL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\cstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cstr.h
//
//--------------------------------------------------------------------------

#ifndef __STR_H__
#define __STR_H__

#include <tchar.h>

#define STRAPI __stdcall
struct _STR_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

BOOL STRAPI IsValidString(LPCSTR lpsz, int nLength);
BOOL STRAPI IsValidString(LPCWSTR lpsz, int nLength);

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite=TRUE);

int  STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf); 

class CStr
{
public:

// Constructors
    CStr();
    CStr(const CStr& stringSrc);
    CStr(TCHAR ch, int nRepeat = 1);
    CStr(LPCSTR lpsz);
    CStr(LPCWSTR lpsz);
    CStr(LPCTSTR lpch, int nLength);
    CStr(const unsigned char* psz);

// Attributes & Operations
    // as an array of characters
    int GetLength() const;
    BOOL IsEmpty() const;
    void Empty();                       // free up the data

    TCHAR GetAt(int nIndex) const;      // 0 based
    TCHAR operator[](int nIndex) const; // same as GetAt
    void SetAt(int nIndex, TCHAR ch);
    operator LPCTSTR() const;           // as a C string

    // overloaded assignment
    const CStr& operator=(const CStr& stringSrc);
    const CStr& operator=(TCHAR ch);
#ifdef UNICODE
    const CStr& operator=(char ch);
#endif
    const CStr& operator=(LPCSTR lpsz);
    const CStr& operator=(LPCWSTR lpsz);
    const CStr& operator=(const unsigned char* psz);

    // string concatenation
    const CStr& operator+=(const CStr& string);
    const CStr& operator+=(TCHAR ch);
#ifdef UNICODE
    const CStr& operator+=(char ch);
#endif
    const CStr& operator+=(LPCTSTR lpsz);

    friend CStr STRAPI operator+(const CStr& string1,
            const CStr& string2);
    friend CStr STRAPI operator+(const CStr& string, TCHAR ch);
    friend CStr STRAPI operator+(TCHAR ch, const CStr& string);
#ifdef UNICODE
    friend CStr STRAPI operator+(const CStr& string, char ch);
    friend CStr STRAPI operator+(char ch, const CStr& string);
#endif
    friend CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz);
    friend CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string);

    // string comparison
    int Compare(LPCTSTR lpsz) const;         // straight character
    int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
    int Collate(LPCTSTR lpsz) const;         // NLS aware

    // simple sub-string extraction
    CStr Mid(int nFirst, int nCount) const;
    CStr Mid(int nFirst) const;
    CStr Left(int nCount) const;
    CStr Right(int nCount) const;

    CStr SpanIncluding(LPCTSTR lpszCharSet) const;
    CStr SpanExcluding(LPCTSTR lpszCharSet) const;

    // upper/lower/reverse conversion
    void MakeUpper();
    void MakeLower();
    void MakeReverse();

    // trimming whitespace (either side)
    void TrimRight();
    void TrimLeft();

    // searching (return starting index, or -1 if not found)
    // look for a single character match
    int Find(TCHAR ch) const;               // like "C" strchr
    int ReverseFind(TCHAR ch) const;
    int FindOneOf(LPCTSTR lpszCharSet) const;

    // look for a specific sub-string
    int Find(LPCTSTR lpszSub) const;        // like "C" strstr

    // simple formatting
    void FormatV(LPCTSTR lpszFormat, va_list argList);
    void Format(LPCTSTR lpszFormat, ...);

#ifndef _MAC
    // formatting for localization (uses FormatMessage API)
    void __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
    void __cdecl FormatMessage(UINT nFormatID, ...);
#endif

    // Windows support
    BOOL LoadString(HINSTANCE hInst, UINT nID);          // load from string resource
                                        // 255 chars max
#ifndef UNICODE
    // ANSI <-> OEM support (convert string in place)
    void AnsiToOem();
    void OemToAnsi();
#endif
    BSTR AllocSysString();
    BSTR SetSysString(BSTR* pbstr);

    // Access to string implementation buffer as "C" character array
    LPTSTR GetBuffer(int nMinBufLength);
    void ReleaseBuffer(int nNewLength = -1);
    LPTSTR GetBufferSetLength(int nNewLength);
    void FreeExtra();

// Implementation
public:
    ~CStr();
    int GetAllocLength() const;

protected:
    // lengths/sizes in characters
    //  (note: an extra character is always allocated)
    LPTSTR m_pchData;           // actual string (zero terminated)
    int m_nDataLength;          // does not include terminating 0
    int m_nAllocLength;         // does not include terminating 0

    // implementation helpers
    void Init();
    void AllocCopy(CStr& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
    void AllocBuffer(int nLen);
    void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
    void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
    void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
    static void SafeDelete(LPTSTR lpch);
    static int SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
BOOL STRAPI operator==(const CStr& s1, const CStr& s2);
BOOL STRAPI operator==(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator==(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator!=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator!=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator!=(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator<(const CStr& s1, const CStr& s2);
BOOL STRAPI operator<(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator<(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator>(const CStr& s1, const CStr& s2);
BOOL STRAPI operator>(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator>(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator<=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator<=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator<=(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator>=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator>=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator>=(LPCTSTR s1, const CStr& s2);

// conversion helpers
int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern const CStr strEmptyString;
extern TCHAR strChNil;

// Compiler doesn't inline for DBG
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline int CStr::SafeStrlen(LPCTSTR lpsz)
    { return (lpsz == NULL) ? NULL : _tcslen(lpsz); }
inline CStr::CStr(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
inline const CStr& CStr::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }

#ifdef _UNICODE
inline const CStr& CStr::operator+=(char ch)
    { *this += (TCHAR)ch; return *this; }
inline const CStr& CStr::operator=(char ch)
    { *this = (TCHAR)ch; return *this; }
inline CStr STRAPI operator+(const CStr& string, char ch)
    { return string + (TCHAR)ch; }
inline CStr STRAPI operator+(char ch, const CStr& string)
    { return (TCHAR)ch + string; }
#endif

inline int CStr::GetLength() const
    { return m_nDataLength; }
inline int CStr::GetAllocLength() const
    { return m_nAllocLength; }
inline BOOL CStr::IsEmpty() const
    { return m_nDataLength == 0; }
inline CStr::operator LPCTSTR() const
    { return (LPCTSTR)m_pchData; }

// String support (windows specific)
inline int CStr::Compare(LPCTSTR lpsz) const
    { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CStr::CompareNoCase(LPCTSTR lpsz) const
    { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStr::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CStr::Collate(LPCTSTR lpsz) const
    { return _tcscoll(m_pchData, lpsz); }   // locale sensitive
inline void CStr::MakeUpper()
    { ::CharUpper(m_pchData); }
inline void CStr::MakeLower()
    { ::CharLower(m_pchData); }

inline void CStr::MakeReverse()
    { _tcsrev(m_pchData); }
inline TCHAR CStr::GetAt(int nIndex) const
    {
        ASSERT(nIndex >= 0);
        ASSERT(nIndex < m_nDataLength);

        return m_pchData[nIndex];
    }
inline TCHAR CStr::operator[](int nIndex) const
    {
        // same as GetAt

        ASSERT(nIndex >= 0);
        ASSERT(nIndex < m_nDataLength);

        return m_pchData[nIndex];
    }
inline void CStr::SetAt(int nIndex, TCHAR ch)
    {
        ASSERT(nIndex >= 0);
        ASSERT(nIndex < m_nDataLength);
        ASSERT(ch != 0);

        m_pchData[nIndex] = ch;
    }
inline BOOL STRAPI operator==(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) == 0; }
inline BOOL STRAPI operator==(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) == 0; }
inline BOOL STRAPI operator==(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) == 0; }
inline BOOL STRAPI operator!=(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) != 0; }
inline BOOL STRAPI operator!=(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) != 0; }
inline BOOL STRAPI operator!=(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) != 0; }
inline BOOL STRAPI operator<(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) < 0; }
inline BOOL STRAPI operator<(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) < 0; }
inline BOOL STRAPI operator<(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) > 0; }
inline BOOL STRAPI operator>(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) > 0; }
inline BOOL STRAPI operator>(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) > 0; }
inline BOOL STRAPI operator>(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) < 0; }
inline BOOL STRAPI operator<=(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) <= 0; }
inline BOOL STRAPI operator<=(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) <= 0; }
inline BOOL STRAPI operator<=(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) >= 0; }
inline BOOL STRAPI operator>=(const CStr& s1, const CStr& s2)
    { return s1.Compare(s2) >= 0; }
inline BOOL STRAPI operator>=(const CStr& s1, LPCTSTR s2)
    { return s1.Compare(s2) >= 0; }
inline BOOL STRAPI operator>=(LPCTSTR s1, const CStr& s2)
    { return s2.Compare(s1) <= 0; }

#ifndef UNICODE
inline void CStr::AnsiToOem()
    { ::AnsiToOem(m_pchData, m_pchData); }
inline void CStr::OemToAnsi()
    { ::OemToAnsi(m_pchData, m_pchData); }

#endif // UNICODE

// General Exception for memory
class MemoryException
{
public:
    MemoryException(){}
    void DisplayMessage()
    {
    ::MessageBox(NULL, _T("Memory Exception"), _T("System Out of Memory"), MB_OK|MB_ICONSTOP);
    }
};

// General Exception for memory
class ResourceException
{
public:
    ResourceException()
    {
    ::MessageBox(NULL, _T("Resource Exception"), _T("Unable to Load Resource"), MB_OK|MB_ICONSTOP);
    }
};

#endif // __STR_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\enumerator.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      enumerator.h
//
//  Contents:  Supports enumeration for collections of com objects
//
//  History:   14-Oct-99 VivekJ    Created (as comerror.h)
//             08-Mar-2000 AudriusZ separated some code into enumerator.h file
//
//--------------------------------------------------------------------------

#ifndef ENUMERATOR_H_INCLUDED
#define ENUMERATOR_H_INCLUDED
#pragma once

/***************************************************************************\
 *
 * CLASS:  CMMCNewEnumImpl<BaseClass, _Position, EnumImplementor>
 *
 * PURPOSE: Implements enumeration for collection class
 *          EnumImplementor class is responsible for implementing these methods:
 *          SC  ScEnumNext(_Position &pos, PDISPATCH & pDispatch); 
 *          SC  ScEnumSkip(unsigned long celt, unsigned long& celtSkipped, _Position &pos);
 *          SC  ScEnumReset(_Position &pos);
 *
\***************************************************************************/
/****** usage tips *******************************************************
 *   Generally you will provide just 2 params to template - this means
 *   the tied object of your base class needs to implement following methods:
 *           ScEnumNext, ScEnumSkip, ScEnumReset;
 *
 *   If you pass same class as the first and the third template parameter, your base class is
 *   required to implement mentioned methods (not the tied object).
 *   It's usefull when you want to have collection and enueration in one class.
 *
 *   You also may specify any other class implementing the methods as the 3rd parameter, 
 *   but then the BaseClass needs to implement method 'ScGetEnumImplementor' returning 
 *   the instance of that class
 *
 *   NOTE1: since it's template class, the BaseClass is not required to define/implement
 *          ScGetTiedObject, when it implements enum methods itself.
 *   NOTE2: But it always IS REQUIRED to define CMyTiedObject type to compile.
 *          (this template class needs it to be anything different than the BaseClass)
 *          It is suggested to typedef it as void : "typedef void CMyTiedObject;"
 *   NOTE3: Make sure CMyTiedObject type is public or protected
 ************************************************************************/
template <class BaseClass, class _Position, class EnumImplementor = BaseClass::CMyTiedObject>
class CMMCNewEnumImpl : public BaseClass
{
    // Methods to get proper implementor for Enum methods
    // simple one when implemented by the base class
    SC ScGetEnumImplementor(BaseClass * &pObj)                { pObj = this; return SC(S_OK); }
    // when implemented by the tied object (default) - also simple
    SC ScGetEnumImplementor(BaseClass::CMyTiedObject * &pObj) { return ScGetTiedObject(pObj); }
public:
    STDMETHOD(get__NewEnum)(IUnknown** ppUnk);
};




/*+-------------------------------------------------------------------------*
 * class CMMCEnumerator
 *
 *
 * PURPOSE: General purpose enumerator class. Keyed to a position object,
 *          which is templated.
 *
 *          The following three methods need to be implemented by the tied object:
 *
 *          SC  ScEnumNext(_Position &pos, PDISPATCH & pDispatch); // should return the next element.
 *          SC  ScEnumSkip(unsigned long celt, unsigned long& celtSkipped,
                            * _Position &pos);
 *          SC  ScEnumReset(_Position &pos);
 *
 *          Cloning the enumerator is taken care of automatically.
 *
 * NOTE:    The Position object must have a copy constructor and assignment
 *          operator.
 *+-------------------------------------------------------------------------*/

typedef IEnumVARIANT ** PPENUMVARIANT;
typedef VARIANT *       PVARIANT;

template<class TiedObj, class _Position>
class CMMCEnumerator : 
    public IEnumVARIANT,
    public IMMCSupportErrorInfoImpl<&IID_IEnumVARIANT,     &GUID_NULL>,    // rich error handling
    public CComObjectRoot,
    public CTiedComObject<TiedObj>
{
    typedef CMMCEnumerator<TiedObj, _Position> ThisClass;

    typedef TiedObj CMyTiedObject;

    friend  TiedObj;

public:
    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

    // Returns the next celt items starting from the current position
    // in the array rgvar
    STDMETHODIMP Next(unsigned long celt, PVARIANT rgvar, unsigned long * pceltFetched);

    // Skips over the next celt elements in the enumeration sequence.
    STDMETHODIMP Skip(unsigned long celt);

    // Resets the enumeration sequence to the beginning
    STDMETHODIMP Reset();

    // Creates a copy of the current state of enumeration
    STDMETHODIMP Clone(PPENUMVARIANT ppenum);

public:
    // the position object that keeps track of the present location.
    _Position m_position;
};


/*+-------------------------------------------------------------------------*
 * class CMMCArrayEnumBase
 *
 * PURPOSE: General purpose array enumeration base class.
 *          Particularly useful when array of items to be enumerated is initially
 *          available, or when com object creation is not a big penalty and there 
 *          is no need to postpone item creation to when they are requested.
 *
 * USAGE:   typedef your enumerator as CMMCNewEnumImpl parameterized by this class
 *          - or even better - create the instance of CMMCArrayEnum class.
 *          Use Init method passing an array of pointers to items [first, last)
 *+-------------------------------------------------------------------------*/
template <class _CollectionInterface, class _ItemInterface>
class CMMCArrayEnumBase :
    public CMMCIDispatchImpl<_CollectionInterface>,
    public CTiedObject                     // enumerators are tied to it
{
protected:
    typedef void CMyTiedObject; // not tied

public:
    BEGIN_MMC_COM_MAP(CMMCArrayEnumBase)
    END_MMC_COM_MAP()

public:

    // Returns count of items in the collection
    STDMETHODIMP get_Count( PLONG pCount );

    // Returns specified item from collection
    STDMETHODIMP Item( long Index, _ItemInterface ** ppItem );

    // Resets position to the first item in the collection
    ::SC ScEnumReset (unsigned &pos);

    // Returns item from the collection, advances position
    ::SC ScEnumNext  (unsigned &pos, PDISPATCH & pDispatch);

    // Skips the amount of items in enumeration
    ::SC ScEnumSkip  (unsigned long celt, unsigned long& celtSkipped, unsigned &pos);

    // Initializes the array with given iterators
    template<typename InIt> 
    void Init(InIt first, InIt last)
    { 
        m_array.clear();
        m_array.reserve(last - first);
        while(first != last)
            m_array.push_back(*first), ++first;
    }

private:

    // data members
    std::vector< CComPtr<_ItemInterface> > m_array;
};

/*+-------------------------------------------------------------------------*
 * class CMMCArrayEnumBase
 *
 * PURPOSE: General purpose array enumeration class.
 *          Particularly useful when array of items to be enumerated is initially
 *          available, or when com object creation is not a big penalty and there 
 *          is no need to postpone item creation to when they are requested.
 *
 * USAGE:   create the instance of CMMCArrayEnum class whenever you need an 
 *          enumerator for the array of objects you have.
 *          Parameterized by collection type and element type;
 *          For instance CMMCArrayEnum< Nodes, Node >
 *          Use Init method passing an array of pointers to items [first, last)
 *
 * EXAMPLE: << skipping error checking for clarity >>
 *          void GetNodes(std::vector<PNODE>& InNodes, PPNODES ppOutNodes)
 *          {
 *              typedef CComObject< CMMCArrayEnum<Nodes, Node> > EnumNodes;
 *              EnumNodes *pNodes = NULL;
 *              EnumNodes::CreateInstance(&pNodes);             // create
 *              pNodes->Init(InNodes.begin(), InNodes.end());   // initialize with array
 *              pNodes->AddRef();                               // addref for caller
 *              *ppOutNodes = pNodes;                           // return
 *          }
 *
 *+-------------------------------------------------------------------------*/
template <class _CollT, class _ItemT>
class CMMCArrayEnum : 
public CMMCNewEnumImpl<CMMCArrayEnumBase<_CollT, _ItemT>, unsigned, CMMCArrayEnumBase<_CollT, _ItemT> >
{
};


// include inline definitions
#include "enumerator.inl"

#endif  // ENUMERATOR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\findview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       findview.h
//
//--------------------------------------------------------------------------

/*+-------------------------------------------------------------------------*
 *
 * FindMMCView
 *
 * PURPOSE: Locates the amcview window that is an ancestor of the specified window.
 *
 * PARAMETERS: 
 *    HWND  hwnd : [in] The window whose ancestor amcview needs to be located
 *
 * RETURNS: 
 *    inline HWND : The ancestor AmcView window, or NULL if not found
 *
 *+-------------------------------------------------------------------------*/
inline HWND FindMMCView(HWND hwnd)
{
    // Get the childframe handle.
    do
    {
        TCHAR buffer[MAX_PATH];
        if (::GetClassName (hwnd, buffer, MAX_PATH))
        {
            if (!_tcscmp (buffer, g_szChildFrameClassName))
                break;
        }
    } while (hwnd = ::GetParent (hwnd));

    // Get the AMCView handle from Childframe handle.
    if (hwnd)
        hwnd = ::GetDlgItem(hwnd, 0xE900 /*AFX_IDW_PANE_FIRST*/);

    return hwnd;
}



/*+-------------------------------------------------------------------------*
 *
 * FindMMCView
 *
 * PURPOSE: Same as above, but allows a takes a CComControlBase reference as the input parameters
 *
 * PARAMETERS: 
 *    CComControlBase& rCtrl :
 *
 * RETURNS: 
 *    HWND WINAPI
 *
 *+-------------------------------------------------------------------------*/
HWND inline FindMMCView(CComControlBase& rCtrl)
{
    HWND hwnd = NULL;

    // Try to get client window from client site or in-place site interfaces
    if (rCtrl.m_spInPlaceSite)
    {
        rCtrl.m_spInPlaceSite->GetWindow(&hwnd);
    }
    else if (rCtrl.m_spClientSite)
    {
        CComPtr<IOleWindow> spWindow;
        if ( SUCCEEDED(rCtrl.m_spClientSite->QueryInterface(IID_IOleWindow, (void **)&spWindow)) )
        {
            spWindow->GetWindow(&hwnd);
        }
    }
   
    return FindMMCView(hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\guidhelp.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      guidhelp.inl
 *
 *  Contents:
 *
 *  History:   13-Apr-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include "xmlbase.h"	// for CXMLBinary


/*+-------------------------------------------------------------------------*
 * ExtractString
 *
 * Gets string data representing the given clipboard format from the data
 * object.  StringType must be a type that can accept assignment from
 * LPCTSTR (WTL::CString, CStr, tstring, etc.)
 *
 * Many (many!) implementations of IDataObject::GetDataHere incorrectly call
 * CreateStreamOnHGlobal using the HGLOBAL we get them (calling it is
 * incorrect because GetDataHere is specifically forbidden from reallocating
 * the medium that is given to it, which the IStream implementation returned
 * from CreateStreamOnHGlobal will do if it needs more room).
 *
 * We would be more robust if we used TYMED_STREAM in preference to
 * TYMED_HGLOBAL, if the snap-in supported it.
 *--------------------------------------------------------------------------*/

template<class StringType>
HRESULT ExtractString (
	IDataObject*	piDataObject,
	CLIPFORMAT		cfClipFormat,
	StringType&		str)
{
	DECLARE_SC (sc, _T("ExtractString"));

	sc = ScCheckPointers (piDataObject);
	if (sc)
		return (sc.ToHr());

	/*
	 * clear out the output
	 */
	str	= _T("");

    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
	CXMLBinary	xmlBin;

	/*
	 * 1024 isn't a random number.  It must be (at least) this large to
	 * maintain compatibility with buggy snap-ins.
	 */
	const int	cchGrow   = 1024;
	int			cchBuffer = 0;

	/*
	 * to enter the loop the first time
	 */
	sc = STG_E_MEDIUMFULL;

	while (sc == STG_E_MEDIUMFULL)
	{
		/*
		 * increase the buffer size
		 */
		cchBuffer += cchGrow;
		const int cbBuffer = cchBuffer * sizeof(WCHAR);

		/*
		 * Allocate a buffer for the string.  In the reallocation case,
		 * it is safe to store the return value from GlobalReAlloc in
		 * stgmedium.hGlobal because the original handle is also held
		 * in autoGlobal
		 */
		if (cchBuffer == cchGrow)
			sc = xmlBin.ScAlloc   (cbBuffer, true /* fZeroInit */);
		else
			sc = xmlBin.ScRealloc (cbBuffer, true /* fZeroInit */);

		if (sc)
			return (sc.ToHr());

		/*
		 * get the HGLOBAL out of the CXMLBinary
		 */
		stgmedium.hGlobal = xmlBin.GetHandle();
		sc = ScCheckPointers (stgmedium.hGlobal, E_UNEXPECTED);
		if (sc)
			return (sc.ToHr());

		/*
		 * get the string from the data object
		 */
        sc = piDataObject->GetDataHere (&formatetc, &stgmedium);
		// don't check for error here, it'll be checked at the top of the loop
	}

	/*
	 * this will handle all non-STG_E_MEDIUMFULL errors from
	 * IDataObject::GetDataHere
	 */
	if (sc)
    {
        // don't trace these errors
        SC scTemp = sc;
        sc.Clear();
        return scTemp.ToHr();
    }

	/*
	 * lock down the returned data in preparation for copying
	 */
	CXMLBinaryLock lock (xmlBin);

	LPWSTR pchBuffer = NULL;
	sc = lock.ScLock (&pchBuffer);
	if (sc)
		return (sc.ToHr());

	/*
	 * Copy the string.  The termination isn't unjustified paranoia.
	 * Many implementations of IDataObject::GetDataHere don't terminate
	 * their strings.
	 */
	USES_CONVERSION;
	pchBuffer[cchBuffer-1] = 0;
	str = W2CT (pchBuffer);

	return (sc.ToHr());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\imageid.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      imageid.h
 *
 *  Contents:  IDs for stock scope/result item images
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef IMAGEID_H
#define IMAGEID_H
#pragma once


/*
 * these IDs correspond to the images in nodemgr\res\nodes[16|32].bmp
 */
enum StockImageIndex
{
    eStockImage_Folder     = 0,
    eStockImage_File       = 1,
    eStockImage_OCX        = 2,
    eStockImage_HTML       = 3,
    eStockImage_Monitor    = 4,
    eStockImage_Shortcut   = 5,
    eStockImage_OpenFolder = 6,
    eStockImage_Taskpad    = 7,
    eStockImage_Favorite   = 8,

    // must be last
    eStockImage_Count,
    eStockImage_Max = eStockImage_Count - 1
};


#endif /* IMAGEID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\memento.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       memento.h
//
//--------------------------------------------------------------------------

#pragma once
#ifndef _MEMENTO_H_
#define _MEMENTO_H_

// forward declarations
class CMemento;
                                     

/*+-------------------------------------------------------------------------*
 * class CMemento
 *
 * PURPOSE: Encapsulates the settings needed to restore a node/view combination.
 *
 *+-------------------------------------------------------------------------*/
class CMemento : public CSerialObject, public CXMLObject
{
public:
    CBookmark       &GetBookmark()         {return m_bmTargetNode;}
    CViewSettings   &GetViewSettings()     {return m_viewSettings;}

    bool            operator==(const CMemento& memento);
    bool            operator!=(const CMemento& memento);

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion);  

    virtual void    Persist(CPersistor& persistor);
    DEFINE_XML_TYPE(XML_TAG_MEMENTO);
private:
    CViewSettings   m_viewSettings;
	CBookmark       m_bmTargetNode;
};

#endif // _MEMENTO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\macros.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       macros.h
//
//  Contents:   Useful macros
//
//  Macros:     ARRAYLEN
//
//              BREAK_ON_FAIL(hresult)
//              BREAK_ON_FAIL(hresult)
//
//              DECLARE_IUNKNOWN_METHODS
//              DECLARE_STANDARD_IUNKNOWN
//              IMPLEMENT_STANDARD_IUNKNOWN
//
//              SAFE_RELEASE
//
//              DECLARE_SAFE_INTERFACE_PTR_MEMBERS
//
//  History:    6/3/1996   RaviR   Created
//              7/23/1996  JonN    Added exception handling macros
//
//____________________________________________________________________________

#ifndef _MACROS_H_
#define _MACROS_H_


//____________________________________________________________________________
//
//  Macro:      ARRAYLEN
//
//  Purpose:    To determine the length of an array.
//____________________________________________________________________________
//

#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))


//____________________________________________________________________________
//
//  Macros:     BREAK_ON_FAIL(hresult), BREAK_ON_ERROR(lastError)
//
//  Purpose:    To break out of a loop on error.
//____________________________________________________________________________
//

#define BREAK_ON_FAIL(hr)   if (FAILED(hr)) { break; } else 1;

#define BREAK_ON_ERROR(lr)  if (lr != ERROR_SUCCESS) { break; } else 1;

#define RETURN_ON_FAIL(hr)  if (FAILED(hr)) { return(hr); } else 1;

#define THROW_ON_FAIL(hr)   if (FAILED(hr)) { _com_issue_error(hr); } else 1;


//____________________________________________________________________________
//
//  Macros:     DwordAlign(n)
//____________________________________________________________________________
//

#define DwordAlign(n)  (((n) + 3) & ~3)


//____________________________________________________________________________
//
//  Macros:     IF_NULL_RETURN_INVALIDARG
//____________________________________________________________________________
//

#define IF_NULL_RETURN_INVALIDARG(x) \
    { \
        ASSERT((x) != NULL); \
        if ((x) == NULL) \
            return E_INVALIDARG; \
    }

#define IF_NULL_RETURN_INVALIDARG2(x, y) \
    IF_NULL_RETURN_INVALIDARG(x) \
    IF_NULL_RETURN_INVALIDARG(y)

#define IF_NULL_RETURN_INVALIDARG3(x, y, z) \
    IF_NULL_RETURN_INVALIDARG(x) \
    IF_NULL_RETURN_INVALIDARG(y) \
    IF_NULL_RETURN_INVALIDARG(z)

#define RELEASE_DATAOBJECT(pDataObj) \
    {\
        if ( (pDataObj) && (!IS_SPECIAL_DATAOBJECT(pDataObj))) \
            pDataObj->Release();\
    }

#endif // _MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\mmcdata.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       MMCData.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2/27/1997   RaviR   Created
//____________________________________________________________________________
//


#ifndef __MMCDATA__H__
#define __MMCDATA__H__

#include "ndmgr.h"
#include "mmcptrs.h"

class CToolBarCtrlEx;
class CMultiSelection;
class CConsoleFrame;
class CConsoleView;
class CConsoleStatusBar;
class CMenuButtonsMgr;
class CAMCViewToolbarsMgr;
class CNode;
class CXMLObject;
class CStdVerbButtons;
class CConsoleDocument;

//////////////////////////////////////////////////////////////////////////////
//
// SConsoleData structure.
//


enum ProgramMode
{
    eMode_Author,
    eMode_User,
    eMode_User_MDI,
    eMode_User_SDI,

    eMode_Count,
    eMode_First = eMode_Author,
    eMode_Last  = eMode_User_SDI,
    eMode_Error = -1
};


enum ConsoleFlags
{
    eFlag_ShowStatusBar                  = 0x00000001,
    eFlag_HelpDocInvalid                 = 0x00000002,
    eFlag_LogicalReadOnly                = 0x00000004,
    eFlag_PreventViewCustomization       = 0x00000008,
                             // DO NOT USE 0x00000010 - an obsolete flag that was used in MMC1.2 to disallow context menus on taskpads.

    eFlag_Default                        = eFlag_ShowStatusBar,
    eFlag_All                            = 0x0000000f,
};

// The current MMC version: 2.0
#define MMC_VERSION_MAJOR 2
#define MMC_VERSION_MINOR 0

#define MakeConsoleFileVer(major_ver,minor_ver) \
        MakeConsoleFileVer_(major_ver, minor_ver, 0)

#define MakeConsoleFileVer_(major_ver,minor_ver,minor_subver) \
        ((DWORD)(((DWORD)(BYTE)(major_ver)<<16)|((WORD)(BYTE)(minor_ver)<<8)|(BYTE)(minor_subver)))


#define GetConsoleFileMajorVersion(eFileVer)    ((BYTE)((eFileVer)>>16))
#define GetConsoleFileMinorVersion(eFileVer)    ((BYTE)(((WORD)(eFileVer)) >> 8))
#define GetConsoleFileMinorSubversion(eFileVer) ((BYTE)(eFileVer))


enum ConsoleFileVersion
{
    FileVer_0100 = MakeConsoleFileVer (1, 0),       // MMC v1.0
    FileVer_0110 = MakeConsoleFileVer (1, 1),       // MMC v1.1
    FileVer_0120 = MakeConsoleFileVer (1, 2),       // MMC v1.2
    FileVer_0200 = MakeConsoleFileVer (2, 0),       // MMC v2.0

    FileVer_Current = FileVer_0200,
    FileVer_Invalid = -1,
};


inline bool IsValidProgramMode (ProgramMode eMode)
{
    return ((eMode >= eMode_First) && (eMode <= eMode_Last));
}

inline bool IsValidFileVersion (ConsoleFileVersion eFileVer)
{
    return ((eFileVer == FileVer_0100) ||
            (eFileVer == FileVer_0110) ||
            (eFileVer == FileVer_0120) ||
            (eFileVer == FileVer_0200));
}

inline bool IsCurrentFileVersion (ConsoleFileVersion eFileVer)
{
    return (eFileVer == FileVer_Current);
}


#define NAVLIST_LEVELS  2

struct SConsoleData
{
    SConsoleData()
        :
        m_hwndMainFrame (NULL),
        m_pConsoleFrame (NULL),
        m_eAppMode      (eMode_Author),
        m_eConsoleMode  (eMode_Author),
        m_dwFlags       (eFlag_Default),
        m_eFileVer      (FileVer_Invalid),
        m_pXMLPersistColumnData(NULL),
        m_pConsoleDocument(NULL)
    {
    }

    ProgramMode GetMode() const
    {
        return (m_eAppMode);
    }

    ProgramMode GetConsoleMode() const
    {
        return (m_eConsoleMode);
    }

    ConsoleFileVersion GetFileVersion() const
    {
        return (m_eFileVer);
    }

    CConsoleFrame* GetConsoleFrame() const
    {
        return (m_pConsoleFrame);
    }

    void SetScopeTree (IScopeTree* pScopeTree)
    {
        // hook this console data to the scope tree
        m_spScopeTree = pScopeTree;

        // hook the scope tree to this console data
        m_spScopeTree->SetConsoleData (reinterpret_cast<LPARAM>(this));
    }

    IScopeTreePtr       m_spScopeTree;

    HWND                m_hwndMainFrame;
    CConsoleFrame*      m_pConsoleFrame;
    ProgramMode         m_eAppMode;
    ProgramMode         m_eConsoleMode;
    ConsoleFileVersion  m_eFileVer;
    DWORD               m_dwFlags;

    // Console's column data
    IPersistStreamPtr   m_spPersistStreamColumnData;
    CXMLObject*         m_pXMLPersistColumnData;

    // access to document from node manager side
    CConsoleDocument*   m_pConsoleDocument;
}; // struct SConsoleData


//////////////////////////////////////////////////////////////////////////////
//
// SViewData structure.
//

const DWORD STD_MENUS       = 0x00000001;
const DWORD STD_BUTTONS     = 0x00000002;
const DWORD SNAPIN_MENUS    = 0x00000004;
const DWORD SNAPIN_BUTTONS  = 0x00000008;
const DWORD STATUS_BAR      = 0x80000000;

// The status bar isn't really a "toolbar" per se, but it's visibility
// status is stored with the rest of these bits so we don't have to change
// the view data stream format to accomodate it.
const DWORD ALL_TOOLBARS    = 0x0000000f;

inline DWORD ToolbarsOf (DWORD dwToolbars)
    { return (dwToolbars & ALL_TOOLBARS); }

inline DWORD StatusBarOf (DWORD dwToolbars)
    { return (dwToolbars & STATUS_BAR); }


struct SViewData
{
    friend class CAMCView;

private:
    enum eFlag
    {
        eFlag_ScopePaneVisible    = 0x00000001, // Scope pane visible
        eFlag_DescBarVisible      = 0x00000008,
        eFlag_VirtualList         = 0x00000010,
        eFlag_TaskpadTabsAllowed  = 0x00000040,

        // default for new views
        eFlag_Default             = eFlag_ScopePaneVisible   |
                                    eFlag_TaskpadTabsAllowed
    };

public:
    SViewData() :
        m_dwFlags                   (eFlag_Default),
        m_pStatusBar                (NULL),
        m_pConsoleView              (NULL),
        m_pConsoleData              (NULL),
        m_nViewID                   (0),
        m_hwndView                  (NULL),
        m_hwndChildFrame            (NULL),
        m_hwndListCtrl              (NULL),
        m_lWindowOptions            (0),
        m_pMultiSelection           (NULL),
        m_dwToolbarsDisplayed       (ALL_TOOLBARS | STATUS_BAR),    // enable all
        m_bSnapinChangingView       (FALSE),
        m_pMenuButtonsMgr           (NULL),
        m_pAMCViewToolbarsMgr       (NULL),
        m_pStdVerbButtons           (NULL)
    {
    }

private:
    DWORD   m_dwFlags;          // manipulate with accessors

    void SetFlag (eFlag flag, bool fSet)
    {
        if (fSet)
            m_dwFlags |= flag;
        else
            m_dwFlags &= ~flag;
    }

    bool TestFlag (eFlag flag) const
    {
        return ((m_dwFlags & flag) ? true : false);
    }

public:
    void SetScopePaneVisible    (bool b = true)   { SetFlag (eFlag_ScopePaneVisible,    b); }
    void SetDescBarVisible      (bool b = true)   { SetFlag (eFlag_DescBarVisible,      b); }
    void SetVirtualList         (bool b = true)   { SetFlag (eFlag_VirtualList,         b); }
    void SetTaskpadTabsAllowed  (bool b = true)   { SetFlag (eFlag_TaskpadTabsAllowed,  b); }

public:
    bool IsScopePaneVisible     () const          { return (TestFlag (eFlag_ScopePaneVisible));    }
    bool IsDescBarVisible       () const          { return (TestFlag (eFlag_DescBarVisible));      }
    bool IsVirtualList          () const          { return (TestFlag (eFlag_VirtualList) & HasList()); }
    bool HasList                () const          { return m_rvt.HasList();             }
    bool HasOCX                 () const          { return m_rvt.HasOCX();              }
    bool HasWebBrowser          () const          { return m_rvt.HasWebBrowser();       }
    bool HasListPad             () const          { return (HasWebBrowser() && (NULL != m_hwndListCtrl)); }
    bool AreTaskpadTabsAllowed  () const          { return (TestFlag (eFlag_TaskpadTabsAllowed));  }

    DWORD GetListOptions()         const          { return m_rvt.GetListOptions();}
    DWORD GetHTMLOptions()         const          { return m_rvt.GetHTMLOptions();}
    DWORD GetOCXOptions()          const          { return m_rvt.GetOCXOptions();}
    DWORD GetMiscOptions()         const          { return m_rvt.GetMiscOptions();}

    LPCOLESTR   GetURL()           const          { return m_rvt.GetURL();}
    LPCOLESTR   GetOCX()           const          { return m_rvt.GetOCX();}

    void SetResultViewType(CResultViewType &rvt)  { m_rvt = rvt;}

    CConsoleStatusBar* GetStatusBar()   const     { return (m_pStatusBar); }
    CConsoleView*      GetConsoleView() const     { return (m_pConsoleView); }

    void SetStatusBar (CConsoleStatusBar* pStatusBar)
        { m_pStatusBar = pStatusBar; }

    void SetConsoleView (CConsoleView* pConsoleView)
        { m_pConsoleView = pConsoleView; }

    CMenuButtonsMgr* GetMenuButtonsMgr() const    { return (m_pMenuButtonsMgr); }
    void SetMenuButtonsMgr (CMenuButtonsMgr* pMenuButtonsMgr) { m_pMenuButtonsMgr = pMenuButtonsMgr; }

    CAMCViewToolbarsMgr* GetAMCViewToolbarsMgr() const    { return (m_pAMCViewToolbarsMgr); }
    void SetAMCViewToolbarsMgr (CAMCViewToolbarsMgr* pAMCViewToolbarsMgr) { m_pAMCViewToolbarsMgr = pAMCViewToolbarsMgr; }

    CStdVerbButtons* GetStdVerbButtons() const    { return (m_pStdVerbButtons); }
    void SetStdVerbButtons (CStdVerbButtons* pStdVerbButtons) { m_pStdVerbButtons = pStdVerbButtons; }

private:
    CConsoleStatusBar*      m_pStatusBar;
    CConsoleView*           m_pConsoleView;
    CMenuButtonsMgr*        m_pMenuButtonsMgr;
    CAMCViewToolbarsMgr*    m_pAMCViewToolbarsMgr;
    CStdVerbButtons*        m_pStdVerbButtons;

public:
    SConsoleData*           m_pConsoleData;
    int                     m_nViewID;

    HWND                    m_hwndView;
    HWND                    m_hwndChildFrame;
    HWND                    m_hwndListCtrl;

    long                    m_lWindowOptions;

    IFramePrivatePtr        m_spNodeManager;
    IResultDataPrivatePtr   m_spResultData;
    IImageListPrivatePtr    m_spRsltImageList;
    IConsoleVerbPtr         m_spVerbSet;
    INodeCallbackPtr        m_spNodeCallback;
    IControlbarsCachePtr    m_spControlbarsCache;
    ITaskCallbackPtr        m_spTaskCallback;
    CMultiSelection*        m_pMultiSelection;

    DWORD                   m_dwToolbarsDisplayed;

    // Is snapin changing the view now.
    BOOL                    m_bSnapinChangingView;

    bool IsStandardMenusAllowed()
    {
        return (m_dwToolbarsDisplayed & STD_MENUS);
    }

    bool IsSnapinMenusAllowed()
    {
        return (m_dwToolbarsDisplayed & SNAPIN_MENUS);
    }

protected:
    CResultViewType         m_rvt;
};


#include <pshpack8.h>   // for Win64

struct CreateNewViewStruct
{
    MTNODEID    idRootNode;         // in:  ID of the root node of the view
    long        lWindowOptions;     // in:  window creation options, MMC_NW_OPTION_*
    bool        fVisible;           // in:  is the window visible?
    SViewData*  pViewData;          // out: view data for the new view
    HNODE       hRootNode;          // out: root node of the new view
};

#include <poppack.h>


#endif // __MMCDATA__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\mmcdebug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      mmctrace.h
//
//  Contents:  Declaration of the debug trace code
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------

#ifndef MMCDEBUG_H
#define MMCDEBUG_H
#pragma once

#include "baseapi.h"	// for MMCBASE_API

//--------------------------------------------------------------------------
#ifdef DBG
//--------------------------------------------------------------------------

/*
 * Define a macro to break into the debugger.
 *
 * On Intel, do an inline break.  That'll keep us from breaking
 * inside NTDLL and switching from source mode to disassembly mode.
 */
#ifdef _M_IX86
#define MMCDebugBreak()     _asm { int 3 }
#else
#define MMCDebugBreak()     DebugBreak()
#endif

// forward class declarations
class MMCBASE_API CTraceTag;

typedef CTraceTag * PTRACETAG;
typedef std::vector<PTRACETAG> CTraceTags;

MMCBASE_API CTraceTags * GetTraceTags();     // singleton.

class CStr;
CStr & GetFilename();

extern LPCTSTR const szTraceIniFile;

enum
{
    TRACE_COM2              = 0x0001,
    TRACE_OUTPUTDEBUGSTRING = 0x0002,
    TRACE_FILE              = 0x0004,
    TRACE_DEBUG_BREAK       = 0x0008,
    TRACE_DUMP_STACK        = 0x0010,

    TRACE_ALL               = ( TRACE_COM2 | TRACE_OUTPUTDEBUGSTRING | TRACE_FILE | TRACE_DEBUG_BREAK | TRACE_DUMP_STACK )
};

/*+-------------------------------------------------------------------------*
 * class CTraceTag
 *
 * PURPOSE: Encapsulates a particular trace type.
 *
 * USAGE: Instantiate it with
 *
 *  #ifdef DBG
 *  CTraceTag tagTest( TEXT("TestCategory"), TEXT("TestName"))
 *  #endif
 *
 * Make sure to use STRING LITERALS for the category and name; the tag
 * stores the pointer to the string only.
 *
 * You can also specify which outputs to enable by default. Or, from the
 * traces dialog, each output can be individually enabled/disabled.
 *
 * Add code to use the trace just like a printf statement as follows:
 *
 * example: Trace(tagTest, "Error: %d", hr);
 *
 * The complete Trace statement must be on a single line. If not, use continuation
 * characters (\).
 *+-------------------------------------------------------------------------*/
class MMCBASE_API CTraceTag
{
public:
    CTraceTag(LPCTSTR szCategory, LPCTSTR szName, DWORD dwDefaultFlags = 0);
    ~CTraceTag();
    const LPCTSTR GetCategory()  const   {return m_szCategory;}
    const LPCTSTR GetName()      const   {return m_szName;}

    void    SetTempState()          {m_dwFlagsTemp = m_dwFlags;}
    void    Commit();

    void    SetFlag(DWORD dwMask)   {m_dwFlagsTemp |= dwMask;}
    void    ClearFlag(DWORD dwMask) {m_dwFlagsTemp &= ~dwMask;}

    void    RestoreDefaults()     {m_dwFlags = m_dwDefaultFlags; m_dwFlagsTemp = m_dwDefaultFlags;}

    DWORD   GetFlag(DWORD dwMask) const {return m_dwFlagsTemp & dwMask;}

    void    TraceFn( LPCTSTR szFormat, va_list ) const;

    BOOL    FIsDefault()  const   {return (m_dwFlags == m_dwDefaultFlags);}
    BOOL    FAny()        const   {return (m_dwFlags != 0);}
    BOOL    FCom2()       const   {return (m_dwFlags & TRACE_COM2);}
    BOOL    FDebug()      const   {return (m_dwFlags & TRACE_OUTPUTDEBUGSTRING);}
    BOOL    FFile()       const   {return (m_dwFlags & TRACE_FILE);}
    BOOL    FBreak()      const   {return (m_dwFlags & TRACE_DEBUG_BREAK);}
    BOOL    FDumpStack()  const   {return (m_dwFlags & TRACE_DUMP_STACK);}

    // temp flag functions
    BOOL    FAnyTemp()    const   {return (m_dwFlagsTemp != 0);}

    DWORD   GetAll()              {return m_dwFlags;}

    static CStr& GetFilename();
    static unsigned int& GetStackLevels();


protected:
    // these are designed to be overloaded by a derived class to instrument certain
    // pieces of code as appropriate.
    virtual void    OnEnable()      {}
    virtual void    OnDisable()     {}

private:
    void    OutputString(const CStr &str) const; // sends the specified string to all appropriate outputs.
    void    DumpStack()                   const; // sends the stack trace to all appropriate outputs.

private:
    LPCTSTR         m_szCategory;
    LPCTSTR         m_szName;
    DWORD           m_dwDefaultFlags;
    DWORD           m_dwFlags;
    DWORD           m_dwFlagsTemp;    // thrown away if Cancel is hit in the dialog.
    static HANDLE   s_hfileCom2;
    static HANDLE   s_hfile;
};

MMCBASE_API void Trace(const CTraceTag &, LPCTSTR szFormat, ... );
MMCBASE_API void TraceDirtyFlag    (LPCTSTR szComponent, bool bDirty );   // trace for the dirty flag for persistent objects.
MMCBASE_API void TraceSnapinPersistenceError(LPCTSTR szError);
MMCBASE_API void TraceBaseLegacy   (LPCTSTR szFormat, ... );
MMCBASE_API void TraceConuiLegacy  (LPCTSTR szFormat, ... );
MMCBASE_API void TraceNodeMgrLegacy(LPCTSTR szFormat, ... );

MMCBASE_API void DoDebugTraceDialog();

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TraceBaseLegacy(_T("Release called on NULL interface ptr\n"));
    }
}

#define BEGIN_TRACETAG(_class)                   \
    class _class : public CTraceTag              \
    {                                            \
    public:                                      \
        _class(LPCTSTR szCategory, LPCTSTR szName, DWORD dwDefaultFlags = 0)    \
        : CTraceTag(szCategory, szName, dwDefaultFlags) {}

#define END_TRACETAG(_class, _Category, _Name)   \
    } _tag##_class(_Category, _Name);




//--------------------------------------------------------------------------
#else // DBG
//--------------------------------------------------------------------------

// these macros evaluate to blanks.

#define CTraceTag()
#define MMCDebugBreak()

//          Expand to ";", <tab>, one "/" followed by another "/"
//          (which is //).
//          NOTE: This means the Trace statements have to be on ONE line.
//          If you need multiple line Trace statements, enclose them in
//          a #ifdef DBG block.
#define Trace               ;/##/
#define TraceDirtyFlag      ;/##/
#define TraceCore           ;/##/
#define TraceConuiLegacy    ;/##/
#define TraceNodeMgrLegacy  ;/##/


template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
}

//--------------------------------------------------------------------------
#endif // DBG
//--------------------------------------------------------------------------

#endif  // MMCDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\guidhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       guidhelp.h
//
//--------------------------------------------------------------------------

#pragma once

// GUID support functions

class CStr;
class CString;

struct IContextMenuCallback;
struct IComponent;

HRESULT ExtractData(   IDataObject* piDataObject,
                       CLIPFORMAT   cfClipFormat,
                       BYTE*        pbData,
                       DWORD        cbData );


/*+-------------------------------------------------------------------------*
 * ExtractString
 *
 * Gets string data representing the given clipboard format from the data
 * object.  StringType must be a type that can accept assignment from
 * LPCTSTR (WTL::CString, CStr, tstring, etc.)
 *--------------------------------------------------------------------------*/

template<class StringType>
HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT   cfClipFormat,
                       StringType&  str);

HRESULT GuidToCStr( CStr* pstr, const GUID& guid );
HRESULT GuidToCString(CString* pstr, const GUID& guid );

HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );

HRESULT ExtractObjectTypeCStr( IDataObject* piDataObject, CStr* pstr );
HRESULT ExtractObjectTypeCString( IDataObject* piDataObject, CString* pstr );

HRESULT LoadRootDisplayName(IComponentData* pIComponentData, CStr& strDisplayName);
HRESULT LoadRootDisplayName(IComponentData* pIComponentData, CString& strDisplayName);

HRESULT LoadAndAddMenuItem(
    IContextMenuCallback* pIContextMenuCallback,
    UINT nResourceID, // contains text and status text seperated by '\n'
    long lCommandID,
    long lInsertionPointID,
    long fFlags,
    HINSTANCE hInst);

HRESULT AddMenuItem(
    IContextMenuCallback* pIContextMenuCallback,
    LPOLESTR pszText,
    LPOLESTR pszStatusBarText,
    long lCommandID,
    long lInsertionPointID,
    long fFlags,
    HINSTANCE hInst);

HRESULT AddSpecialSeparator(
    IContextMenuCallback* pIContextMenuCallback,
    long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU );
HRESULT AddSpecialInsertionPoint(
    IContextMenuCallback* pIContextMenuCallback,
    long lCommandID,
    long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU );


/*------------------------------------------------*/
/* declare various relational operators for GUIDs */
/*------------------------------------------------*/

#include <functional>

// template helper CLSID comparison function
// NOTE: extra parameter is added to have different decorated function name for each operator
// or else in debug version (expanded) functions will be linked as one function
template <typename comparator>
inline bool CompareCLSID (const CLSID& x, const CLSID& y, const comparator * unused = NULL )
{
    return  x.Data1 != y.Data1 ? comparator<unsigned long> ()(x.Data1 , y.Data1) :
            x.Data2 != y.Data2 ? comparator<unsigned short>()(x.Data2 , y.Data2) :
            x.Data3 != y.Data3 ? comparator<unsigned short>()(x.Data3 , y.Data3) :
            comparator<int>()(memcmp(x.Data4 , y.Data4, sizeof(x.Data4)) , 0);
}

inline bool operator < (const CLSID& x, const CLSID& y)
{
    return CompareCLSID<std::less>( x , y );
}

inline bool operator > (const CLSID& x, const CLSID& y)
{
    return CompareCLSID<std::greater>( x , y );
}

inline bool operator <= (const CLSID& x, const CLSID& y)
{
    return CompareCLSID<std::less_equal>( x , y );
}

inline bool operator >= (const CLSID& x, const CLSID& y)
{
    return CompareCLSID<std::greater_equal>( x , y );
}

/*--------------------------------------------------------------*/
/* operator== and operator!= for GUIDs are defined in objbase.h */
/*--------------------------------------------------------------*/


#include "guidhelp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\mmcplex_.h ===
// This was a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __MMCPLEX_H__
#define __MMCPLEX_H__


struct CPlex     // warning variable length structure
{
	CPlex* pNext;
#if (_AFX_PACKING >= 8)
	DWORD dwReserved[1];    // align on 8 byte boundary
#endif
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CPlex* PASCAL Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};


#endif //__MMCPLEX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\mmcerror.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      mmcerror.cpp
//
//  Contents:  Class definitions for mmc error support code.
//
//  History:   15-Jul-99 VivekJ    Created
//
//--------------------------------------------------------------------------
#pragma once

#ifndef _MMCERROR_H
#define _MMCERROR_H

#include "baseapi.h"	// for MMCBASE_API
#include "stddbg.h"		// for ASSERT, COMPILETIME_ASSERT


/*+-------------------------------------------------------------------------*
 * WHY NAMESPACES ?
 * We had problems trying to use "modified" SC when implementing
 * com classes supporting ISupportErrorInfo.
 * we had:
 * [global version] - class CS
 * [local version ] - a template class _SC, derived from SC and typedef'ed to SC.
 * That was not only confusing to us - IDE debugger was also confused and crashing.
 *
 * The solution for that was to separate real types used for implementing.
 * Thus to have typedef'ed definitions both in global and local scope.
 * Plus (to avoid dealing with _SC and __SC and have better IDE support)
 * we have used namespaces mmcerror and comerror, so we endup with this:
 * - mmcerror::SC defining main functionality
 * - comerror::SC (derived from mmcerror::SC) defining modified functionality
 * - global SC - typedef of mmcerror::SC
 * - local  SC - typedef of comerror::SC
 *+-------------------------------------------------------------------------*/
namespace mmcerror {
/*+-------------------------------------------------------------------------*
 * class SC
 *
 * PURPOSE: The definition of a status code. Contains two members, a facility
 *          and an error code. This is a class rather
 *          than a typedef to avoid accidental casts to and from HRESULTS.
 *
 *          SC's hold information about an error: The source of the error,
 *          and the error code itself. These are stored in
 *          different bit fields within the SC.
 *
 * NOTE:    Do not add any virtual functions or member variables to this class.
 *          This could potentially wreak havoc on MMC performance.
 *
 *+-------------------------------------------------------------------------*/
class MMCBASE_API SC
{
public:
    typedef long value_type;

private:
    enum facility_type
    {
        FACILITY_WIN     = 1,     // Defined by the system
        FACILITY_MMC     = 2,     // these map directly to an UINT.
        FACILITY_HRESULT = 3,     // these map directly to an HRESULT
    };


public:
    /*
     * Constructor.  Default copy construction and assignment are sufficient.
     * If they are ever insufficient, that is a clear indication that this
     * class has become heavier than is acceptable for its pervasive pass-by-
     * value usage.
     */
    SC (HRESULT hr = S_OK);

    // equality operators
    bool operator==(const SC &rhs)      const;
    bool operator==(HRESULT hr)  		const;
    bool operator!=(const SC &rhs)      const;
    bool operator!=(HRESULT hr)  		const;

    SC&                 operator= (HRESULT hr)        {MakeSc(FACILITY_HRESULT, hr);	return (*this);}
    SC&                 FromWin32(value_type value)   {MakeSc(FACILITY_WIN,     value);	return (*this);}
    SC&                 FromMMC(value_type value)     {MakeSc(FACILITY_MMC,     value);	return (*this);}
    void                Clear()                       {MakeSc(FACILITY_HRESULT, S_OK); }
    HRESULT             ToHr()          const;
    value_type          GetCode()       const         {return m_value;}

    // get the error message in a preallocated buffer
    void                GetErrorMessage(UINT maxLength, /*[OUT]*/ LPTSTR szMessage) const;
    static void         SetHinst(HINSTANCE hInst);
    static void         SetHWnd(HWND hWnd);

    static DWORD        GetMainThreadID()             {return s_dwMainThreadID;}
    static void         SetMainThreadID(DWORD dwThreadID);

    operator            bool()          const;
    operator            !   ()          const;
    bool                IsError()       const         {return operator bool();}
    static HINSTANCE    GetHinst()                    {ASSERT(s_hInst); return s_hInst;}
    static HWND         GetHWnd()                     {return s_hWnd;}
    DWORD               GetHelpID();
    static LPCTSTR      GetHelpFile();
    void                Throw() throw(SC);
    void                Throw(HRESULT hr) throw();
    void                FatalError()    const;        // ends the application.
    SC&                 FromLastError();
    // does the same trace like in ~SC(); does not change contents.
    void                Trace_() const;
    void                TraceAndClear()               { Trace_();  Clear(); }

private:
    void                MakeSc(facility_type facility, value_type value){m_facility = facility, m_value = value;}

    // accessor functions
    facility_type       GetFacility()   const          {return m_facility;}

private:
    operator HRESULT()                  const; // this is to prevent automatic conversions to HRESULTs by way of bool's.

private:
    facility_type       m_facility;
    value_type          m_value; // the error code.
    static HINSTANCE    s_hInst; // the module that contains all error messages.
    static HWND         s_hWnd;  // the parent HWnd for the error boxes.
    static DWORD        s_dwMainThreadID; // The main thread ID of MMC.

    // debug specific behavior
#ifdef DBG   // Debug SC's hold a pointer to the name of the function they are declared in.
public:
    void          SetFunctionName(LPCTSTR szFunctionName);
    LPCTSTR       GetFunctionName() const;
    void          SetSnapinName  (LPCTSTR szSnapinName) { m_szSnapinName = szSnapinName;}
    LPCTSTR       GetSnapinName() const { return m_szSnapinName;}
    void          CheckCallingThreadID();

    ~SC();
    // SC shouldn't pass the function name around - it's something personal.
    // These will prevent doing so:
    SC& operator = (const SC& other);
    SC(const SC& other);
private:
    LPCTSTR              m_szFunctionName;
    LPCTSTR              m_szSnapinName;

    static UINT          s_CallDepth;
#endif // DBG
};

} // namespace mmcerror

// see "WHY NAMESPACES ?" comment at the top of file
typedef mmcerror::SC SC;

//############################################################################
//############################################################################
//
// the module that contains all the localized strings
//
//############################################################################
//############################################################################
MMCBASE_API HINSTANCE GetStringModule();

//############################################################################
//############################################################################
//
// Functions to format and display an error
//
//############################################################################
//############################################################################
//
// Functions to get an error string from a given SC
//
void    MMCBASE_API FormatErrorIds(   UINT   idsOperation, SC sc, UINT maxLength, /*[OUT]*/ LPTSTR szMessage);
void    MMCBASE_API FormatErrorString(LPCTSTR szOperation, SC sc, UINT maxLength, /*[OUT]*/ LPTSTR szMessage, BOOL fShort = FALSE);
void    MMCBASE_API FormatErrorShort(SC sc, UINT maxLength, /*[OUT]*/ LPTSTR szMessage);

//
//  Error Boxes - These will eventually allow to user to suppress more error messages
//
int     MMCBASE_API MMCErrorBox(UINT idsOperation,          UINT fuStyle = MB_ICONSTOP | MB_OK);
int     MMCBASE_API MMCErrorBox(UINT idsOperation,   SC sc, UINT fuStyle = MB_ICONSTOP | MB_OK);
int     MMCBASE_API MMCErrorBox(LPCTSTR szOperation, SC sc, UINT fuStyle = MB_ICONSTOP | MB_OK);
int     MMCBASE_API MMCErrorBox(                     SC sc, UINT fuStyle = MB_ICONSTOP | MB_OK);
int     MMCBASE_API MMCErrorBox(LPCTSTR szMessage,          UINT fuStyle = MB_ICONSTOP | MB_OK);

//
//  Message Boxes - These cannot be suppressed
//
// This #define eventually will change so that MessageBox's are different and cannot be suppressed
#define MMCMessageBox MMCErrorBox



//############################################################################
//############################################################################
//
//  Debug macros
//
//############################################################################
//############################################################################
#ifdef DBG

MMCBASE_API void TraceError(LPCTSTR sz, const SC& sc);
MMCBASE_API void TraceErrorMsg(LPCTSTR szFormat, ...);

MMCBASE_API void TraceSnapinError(LPCTSTR szError, const SC& sc);

#define DECLARE_SC(_sc, _func)  SC  _sc; sc.SetFunctionName(_func);

// This define is used only within the SC class
#define INCREMENT_CALL_DEPTH() ++s_CallDepth

#define DECREMENT_CALL_DEPTH() --s_CallDepth

///////////////////////////////////////////////////////////////////////
// MMC public interfaces (for snapins) should use this macro as this //
// does some initial error checks and more can be added later.       //
///////////////////////////////////////////////////////////////////////
#define DECLARE_SC_FOR_PUBLIC_INTERFACE(_sc, _func)  SC  _sc;\
                                                     sc.SetFunctionName(_func);\
                                                     sc.SetSnapinName(GetSnapinName());\
                                                     sc.CheckCallingThreadID();

#define IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()           tstring _szSnapinNameForDebug;\
                                                     LPCTSTR GetSnapinName()\
                                                     {\
                                                         return _szSnapinNameForDebug.data();\
                                                     };\
                                                     void SetSnapinName(LPCTSTR sz)\
                                                     {\
                                                         _szSnapinNameForDebug = sz;\
                                                     };
#else

#define TraceError          ;/##/

#define TraceSnapinError    ;/##/

#define DECLARE_SC(_sc, _func)  SC  _sc;

// This define is used only within the SC class
#define INCREMENT_CALL_DEPTH()

#define DECREMENT_CALL_DEPTH()

#define DECLARE_SC_FOR_PUBLIC_INTERFACE(_sc, _func)  SC  _sc;

#define IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()

#endif

//############################################################################
//############################################################################
//
//  Parameter validation
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 *
 * ScCheckPointers
 *
 * PURPOSE: Checks to make sure that all specified parameters are non-NULL
 *
 * PARAMETERS:
 *    const void * pv1 :
 *
 * RETURNS:
 *    inline SC: S_OK if no error, E_INVALIDARG if any of the pointers are NULL
 *
 *
 * NOTE: Do not replace with a single function and optional parameters; that
 *       is inefficient.
 *+-------------------------------------------------------------------------*/
inline SC  ScCheckPointers(const void * pv1, HRESULT err = E_INVALIDARG)
{
    return (NULL == pv1) ? err : S_OK;
}

inline SC  ScCheckPointers(const void * pv1, const void *pv2, HRESULT err = E_INVALIDARG)
{
    return ( (NULL == pv1) || (NULL == pv2) ) ? err : S_OK;
}

inline SC  ScCheckPointers(const void * pv1, const void * pv2, const void * pv3, HRESULT err = E_INVALIDARG)
{
    return ( (NULL == pv1) || (NULL == pv2) || (NULL == pv3) ) ? err : S_OK;
}

inline SC  ScCheckPointers(const void * pv1, const void * pv2, const void * pv3, const void * pv4, HRESULT err = E_INVALIDARG)
{
    return ( (NULL == pv1) || (NULL == pv2) || (NULL == pv3) || (NULL == pv4) ) ? err : S_OK;
}

inline SC  ScCheckPointers(const void * pv1, const void * pv2, const void * pv3, const void * pv4, const void * pv5, HRESULT err = E_INVALIDARG)
{
    return ( (NULL == pv1) || (NULL == pv2) || (NULL == pv3) || (NULL == pv4) || (NULL == pv5) ) ? err : S_OK;
}

inline SC  ScCheckPointers(const void * pv1, const void * pv2, const void * pv3, const void * pv4, const void * pv5, const void* pv6, HRESULT err = E_INVALIDARG)
{
    return ( (NULL == pv1) || (NULL == pv2) || (NULL == pv3) || (NULL == pv4) || (NULL == pv5) || (NULL == pv6)) ? err : S_OK;
}

// see "WHY NAMESPACES ?" comment at the top of file
namespace mmcerror {

/*+-------------------------------------------------------------------------*
 * SC::SC
 *
 * Constructor for SC.
 *
 * Default copy construction and assignment are sufficient.  If they are
 * ever insufficient, that is a clear indication that this class has become
 * heavier than is acceptable for its pervasive pass-by-value usage.
 *--------------------------------------------------------------------------*/

inline SC::SC (HRESULT hr /* =S_OK */)
#ifdef DBG
: m_szFunctionName(NULL), m_szSnapinName(NULL)
#endif // DBG
{
    /*
     * This assert will fail if SC's ever derive from a non-trivial base
     * class (i.e. one that has members or virtual functions), or defines
     * virtual functions of its own.  Don't do that!  SC's must remain
     * extremely lightweight.
     */
    COMPILETIME_ASSERT (offsetof (SC, m_facility) == 0);
    INCREMENT_CALL_DEPTH();

    MakeSc (FACILITY_HRESULT, hr);
}


/*+-------------------------------------------------------------------------*
 * SC::operator==
 *
 *
 * PURPOSE: Determines whether two SC's are equivalent.
 *
 *+-------------------------------------------------------------------------*/
inline bool
SC::operator==(const SC &rhs)   const
{
    return ( (m_facility == rhs.m_facility) &&
             (m_value    == rhs.m_value) );
}

inline bool
SC::operator==(HRESULT hr) const
{
    return ( (m_facility == FACILITY_HRESULT) &&
             (m_value    == hr) );
}

inline bool
SC::operator!=(const SC &rhs)   const
{
    return !operator==( rhs );
}

inline bool
SC::operator!=(HRESULT hr) const
{
    return !operator==( hr );
}


// this version compares an hr to an SC.
inline
operator == (HRESULT hr, const SC & sc)
{
    return (sc == hr);
}

#ifdef DBG

/*+-------------------------------------------------------------------------*
 *
 * SC::GetFunctionName
 *
 * PURPOSE: Sets the debug function name to the supplied string.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    LPCTSTR  The function name.
 *
 *+-------------------------------------------------------------------------*/
inline LPCTSTR SC::GetFunctionName() const
{
    return m_szFunctionName;
}


/*+-------------------------------------------------------------------------*
 *
 * SC::CheckCallingThreadID
 *
 * PURPOSE: Check if the method was called on main thread.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    inline void
 *
 *+-------------------------------------------------------------------------*/
inline void SC::CheckCallingThreadID()
{
    ASSERT(-1 != GetMainThreadID());

    if (GetMainThreadID() == ::GetCurrentThreadId())
        return;

    TraceSnapinError(_T(", method called from wrong thread"), (*this));
    return;
}



/*+-------------------------------------------------------------------------*
 *
 * SC::~SC
 *
 * PURPOSE: Destructor - Debug mode only. Does a trace if an error occurred.
 *
 *+-------------------------------------------------------------------------*/
inline SC::~SC()
{
    DECREMENT_CALL_DEPTH();

    Trace_();
}

#endif // DBG

/*+-------------------------------------------------------------------------*
 *
 * SC::Trace_()
 *
 * PURPOSE: Does a trace if an error occurred. Does nothing in release mode
 *          It is very convenient when we want to register, but ignore the error -
 *          Simply doing sc.Trace_(); sc.Clear(); does all we need.
 *
 *+-------------------------------------------------------------------------*/
inline void SC::Trace_() const
{

#ifdef DBG

    if (IsError())
    {
        // Distinguish between snapin error & MMC error using the
        // snapin name variable.
        if (m_szSnapinName != NULL)
        {
            TraceSnapinError(_T(""), *this);
        }
        else if (m_szFunctionName != NULL)
        {
            TraceError(m_szFunctionName, *this);
        }
    }

#endif // DBG

}

/*+-------------------------------------------------------------------------*
 *
 * SC::operator bool
 *
 * PURPOSE: Returns a value indicating whether the SC holds an error code
 *
 * PARAMETERS: None
 *
 * RETURNS:
 *    bool : true if error, else false
 *
 *+-------------------------------------------------------------------------*/
inline SC::operator bool() const
{
   if(GetCode()==0)
       return false;   // quick exit if no error

   return (GetFacility()==FACILITY_HRESULT) ? FAILED(GetCode()) : true;
}

inline SC::operator !() const
{
    return (!operator bool());
}


} // namespace mmcerror

/*+-------------------------------------------------------------------------*
 *
 * ScFromWin32
 *
 * PURPOSE: Creates an SC with the facility set to Win32.
 *
 * PARAMETERS:
 *    SC::value_type  code :
 *
 * RETURNS:
 *    inline SC
 *
 *+-------------------------------------------------------------------------*/
inline SC  ScFromWin32(SC::value_type code)
{
    SC sc;
    sc.FromWin32(code);
    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * ScFromMMC
 *
 * PURPOSE: Creates an SC with the facility set to MMC.
 *
 * PARAMETERS:
 *    SC::value_type  code :
 *
 * RETURNS:
 *    inline SC
 *
 *+-------------------------------------------------------------------------*/
MMCBASE_API inline SC  ScFromMMC(SC::value_type code)
{
    SC sc;
    sc.FromMMC(code);
    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * HrFromSc
 *
 * PURPOSE: Converts a status code (SC) to an HRESULT. Use sparingly, as this
 *          loses information in the conversion.
 *
 * PARAMETERS:
 *    SC &sc: The SC to convert
 *
 * RETURNS:
 *    inline HRESULT: The converted value.
 *
 *+-------------------------------------------------------------------------*/
MMCBASE_API inline HRESULT HrFromSc(const SC &sc)
{
    return sc.ToHr();
}

/*+-------------------------------------------------------------------------*
 *
 * SCODEFromSc
 *
 * PURPOSE: Converts a status code (SC) to an SCODE. Use sparingly, as this
 *          loses information in the conversion.
 *          On 32bit machine SCODE is same as HRESULT.
 *
 * PARAMETERS:
 *    SC &sc: The SC to convert
 *
 * RETURNS:
 *    inline SCODE: The converted value.
 *
 *+-------------------------------------------------------------------------*/
MMCBASE_API inline SCODE SCODEFromSc(const SC &sc)
{
    return (SCODE)sc.ToHr();
}


#endif //_MMCERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\mmcptrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcptrs.h
//
//--------------------------------------------------------------------------

#ifndef MMCPTRS_H
#define MMCPTRS_H
#pragma once

#pragma warning(disable:4800)
#include <comdef.h>     // for _COM_SMARTPTR_TYPEDEF

#define DEFINE_COM_SMARTPTR(I) _COM_SMARTPTR_TYPEDEF(I, IID_##I)


// version 1.0
DEFINE_COM_SMARTPTR(IComponent);                    // IComponentPtr
DEFINE_COM_SMARTPTR(IComponentData);                // IComponentDataPtr
DEFINE_COM_SMARTPTR(IConsole);                      // IConsolePtr
DEFINE_COM_SMARTPTR(IConsole2);                     // IConsole2Ptr
DEFINE_COM_SMARTPTR(IConsoleNameSpace);             // IConsoleNameSpacePtr
DEFINE_COM_SMARTPTR(IConsoleNameSpace2);            // IConsoleNameSpace2Ptr
DEFINE_COM_SMARTPTR(IConsoleVerb);                  // IConsoleVerbPtr
DEFINE_COM_SMARTPTR(IContextMenuCallback);          // IContextMenuCallbackPtr
DEFINE_COM_SMARTPTR(IContextMenuProvider);          // IContextMenuProviderPtr
DEFINE_COM_SMARTPTR(IControlbar);                   // IControlbarPtr
DEFINE_COM_SMARTPTR(IControlbarsCache);             // IControlbarsCachePtr
DEFINE_COM_SMARTPTR(IDocConfig);                    // IDocConfigPtr
DEFINE_COM_SMARTPTR(IExtendContextMenu);            // IExtendContextMenuPtr
DEFINE_COM_SMARTPTR(IExtendControlbar);             // IExtendControlbarPtr
DEFINE_COM_SMARTPTR(IExtendPropertySheet);          // IExtendPropertySheetPtr
DEFINE_COM_SMARTPTR(IExtendPropertySheet2);         // IExtendPropertySheet2Ptr
DEFINE_COM_SMARTPTR(IFramePrivate);                 // IFramePrivatePtr
DEFINE_COM_SMARTPTR(IHeaderCtrl);                   // IHeaderCtrlPtr
DEFINE_COM_SMARTPTR(IHeaderCtrlPrivate);            // IHeaderCtrlPrivatePtr
DEFINE_COM_SMARTPTR(IImageList);                    // IImageListPtr
DEFINE_COM_SMARTPTR(IImageListPrivate);             // IImageListPrivatePtr
DEFINE_COM_SMARTPTR(IMMCListView);                  // IMMCListViewPtr
DEFINE_COM_SMARTPTR(IMenuButton);                   // IMenuButtonPtr
DEFINE_COM_SMARTPTR(INodeCallback);                 // INodeCallbackPtr
DEFINE_COM_SMARTPTR(IPropertySheetCallback);        // IPropertySheetCallbackPtr
DEFINE_COM_SMARTPTR(IPropertySheetProvider);        // IPropertySheetProviderPtr
DEFINE_COM_SMARTPTR(IPropertySheetProviderPrivate); // IPropertySheetProviderPrivatePtr
DEFINE_COM_SMARTPTR(IResultDataCompare);            // IResultDataComparePtr
DEFINE_COM_SMARTPTR(IResultDataPrivate);            // IResultDataPrivatePtr
DEFINE_COM_SMARTPTR(IResultOwnerData);              // IResultOwnerDataPtr
DEFINE_COM_SMARTPTR(IScopeDataPrivate);             // IScopeDataPrivatePtr
DEFINE_COM_SMARTPTR(IScopeTree);                    // IScopeTreePtr
DEFINE_COM_SMARTPTR(IScopeTreeIter);                // IScopeTreeIterPtr
DEFINE_COM_SMARTPTR(ISnapinAbout);                  // ISnapinAboutPtr
DEFINE_COM_SMARTPTR(ISnapinHelp);                   // ISnapinHelpPtr
DEFINE_COM_SMARTPTR(ISnapinHelp2);                  // ISnapinHelp2Ptr
DEFINE_COM_SMARTPTR(IToolbar);                      // IToolbarPtr

// version 1.1
DEFINE_COM_SMARTPTR(IDisplayHelp);                  // IDisplayHelpPtr
DEFINE_COM_SMARTPTR(IEnumTASK);                     // IEnumTASKPtr
DEFINE_COM_SMARTPTR(IExtendTaskPad);                // IExtendTaskPadPtr
DEFINE_COM_SMARTPTR(IRequiredExtensions);           // IRequiredExtensionsPtr
DEFINE_COM_SMARTPTR(IStringTablePrivate);           // IStringTablePrivatePtr
DEFINE_COM_SMARTPTR(ITaskPadHost);                  // ITaskPadHostPtr

// version 1.2
DEFINE_COM_SMARTPTR(IColumnData);                   // IColumnDataPtr
DEFINE_COM_SMARTPTR(IDumpSnapins);                  // IDumpSnapinsPtr
DEFINE_COM_SMARTPTR(IMessageView);                  // IMessageViewPtr
DEFINE_COM_SMARTPTR(IResultDataCompareEx);          // IResultDataCompareExPtr
DEFINE_COM_SMARTPTR(ITaskCallback);                 // ITaskCallbackPtr

// version 2.0
DEFINE_COM_SMARTPTR(IComponent2);                   // IComponent2Ptr
DEFINE_COM_SMARTPTR(IComponentData2);               // IComponentData2Ptr
DEFINE_COM_SMARTPTR(IConsolePower);                 // IConsolePowerPtr
DEFINE_COM_SMARTPTR(IConsolePowerSink);             // IConsolePowerSinkPtr
DEFINE_COM_SMARTPTR(IContextMenuCallback2);         // IContextMenuCallback2Ptr
DEFINE_COM_SMARTPTR(IExtendView);                   // IExtendViewPtr
DEFINE_COM_SMARTPTR(IViewExtensionCallback);        // IViewExtensionCallbackPtr
DEFINE_COM_SMARTPTR(ISnapinProperties);             // ISnapinPropertiesPtr
DEFINE_COM_SMARTPTR(ISnapinPropertiesCallback);     // ISnapinPropertiesCallbackPtr
DEFINE_COM_SMARTPTR(IConsole3);                     // IConsole3
DEFINE_COM_SMARTPTR(INodeProperties);               // INodePropertiesPtr
DEFINE_COM_SMARTPTR(IResultData2);                  // IResultData2Ptr
DEFINE_COM_SMARTPTR(IMMCClipboardDataObject);       // IMMCClipboardDataObjectPtr



#endif // MMCPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\mmcutil.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       MMCUtil.h
//
//  Contents:
//
//  Classes:
//
//  Functions:  ListView_GetItemData
//
//  History:    12/4/1996   RaviR   Created
//____________________________________________________________________________
//

#ifndef _MMCUTIL_H_
#define _MMCUTIL_H_

#define MMC_CLSCTX_INPROC (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)


inline LPARAM ListView_GetItemData(HWND hwnd, int iItem)
{
    LV_ITEM lvi; 
    ZeroMemory(&lvi, sizeof(lvi));

    if (iItem >= 0)
    {
        lvi.iItem  = iItem;
        lvi.mask = LVIF_PARAM;

#include "pushwarn.h"
#pragma warning(disable: 4553)      // "==" operator has no effect
        VERIFY(::SendMessage(hwnd, LVM_GETITEM, 0, (LPARAM)&lvi) == TRUE);
#include "popwarn.h"
    }

    return lvi.lParam;
}

#endif // _MMCUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\mmctempl.h ===
// This was a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __MMCTEMPL_H__
#define __MMCTEMPL_H__

#ifndef __MMCPLEX_H__
    #include <mmcplex_.h>
#endif

#ifdef ASSERT_VALID
#undef ASSERT_VALID
#endif

#define ASSERT_VALID(pOb)  


#ifndef ALL_WARNINGS
#pragma warning(disable: 4114)
#endif

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)


#ifndef _INC_NEW
    #include <new.h>
#endif


#ifndef __AFX_H__
struct __POSITION {};
typedef __POSITION *POSITION;
#endif

#define BEFORE_START_POSITION ((POSITION)-1L)


inline              
BOOL IsValidAddress( const void* lp, UINT nBytes, BOOL bReadWrite = TRUE )
{
    return TRUE;
}


template<class TYPE>
inline void ConstructElements(TYPE* pElements, int nCount)
{
    ASSERT(nCount == 0 ||
        IsValidAddress(pElements, nCount * sizeof(TYPE)));

    // first do bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));

    // then call the constructor(s)
    for (; nCount--; pElements++)
        ::new((void*)pElements) TYPE;
}

template<class TYPE>
inline void DestructElements(TYPE* pElements, int nCount)
{
    ASSERT(nCount == 0 ||
        IsValidAddress(pElements, nCount * sizeof(TYPE)));

    // call the destructor(s)
    for (; nCount--; pElements++)
        pElements->~TYPE();
}

template<class TYPE>
inline void CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    ASSERT(nCount == 0 ||
        IsValidAddress(pDest, nCount * sizeof(TYPE)));
    ASSERT(nCount == 0 ||
        IsValidAddress(pSrc, nCount * sizeof(TYPE)));

    // default is element-copy using assignment
    while (nCount--)
        *pDest++ = *pSrc++;
}


template<class TYPE, class ARG_TYPE>
BOOL CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    ASSERT(IsValidAddress(pElement1, sizeof(TYPE), FALSE));
    ASSERT(IsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));

    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT HashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(DWORD_PTR)key) >> 4;
}



/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray
{
public:
// Construction
    CArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    void SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CArray& src);
    void Copy(const CArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void RemoveAt(int nIndex, int nCount = 1);
    void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CArray();
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { ASSERT(nIndex >= 0 && nIndex < m_nSize);
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
    ASSERT_VALID(this);

    if (m_pData != NULL)
    {
        DestructElements<TYPE>(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            DestructElements<TYPE>(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        ConstructElements<TYPE>(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = m_nSize / 8;
            nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
        ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);
        ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
    ASSERT_VALID(this);
    ASSERT(this != &src);   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);
    CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
    return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
    ASSERT_VALID(this);
    ASSERT(this != &src);   // cannot append to itself

    SetSize(src.m_nSize);
    CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
    ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
        SetSize(nIndex+1, -1);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount, -1);  // grow it to new size
        // destroy intial data before copying over it
        DestructElements<TYPE>(&m_pData[nOldSize], nCount);
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(TYPE));

        // re-init slots we copied from
        ConstructElements<TYPE>(&m_pData[nIndex], nCount);
    }

    // insert new value in the gap
    ASSERT(nIndex + nCount <= m_nSize);
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);
    ASSERT(nCount >= 0);
    ASSERT(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    DestructElements<TYPE>(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
    ASSERT_VALID(this);
    ASSERT(pNewArray != NULL);
    ASSERT_VALID(pNewArray);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}



/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:
// Construction
    CList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    POSITION AddHead(ARG_TYPE newElement);
    POSITION AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CList* pNewList);
    void AddTail(CList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    POSITION GetHeadPosition() const;
    POSITION GetTailPosition() const;
    TYPE& GetNext(POSITION& rPosition); // return *Position++
    TYPE GetNext(POSITION& rPosition) const; // return *Position++
    TYPE& GetPrev(POSITION& rPosition); // return *Position--
    TYPE GetPrev(POSITION& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(POSITION position);
    TYPE GetAt(POSITION position) const;
    void SetAt(POSITION pos, ARG_TYPE newElement);
    void RemoveAt(POSITION position);

    // inserting before or after a given position
    POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
    POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    POSITION FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CList();
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
    { ASSERT(m_pNodeHead != NULL);
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
    { ASSERT(m_pNodeTail != NULL);
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
    { CNode* pNode = (CNode*) pos;
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
    ASSERT(nBlockSize > 0);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
    ASSERT_VALID(this);

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        DestructElements<TYPE>(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
    RemoveAll();
    ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CList::CNode* pPrev, CList::CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    ASSERT(m_pNodeFree != NULL);  // we must have something

    CList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    ASSERT(m_nCount > 0);  // make sure we don't overflow

    ConstructElements<TYPE>(&pNode->data, 1);
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CList::CNode* pNode)
{
    DestructElements<TYPE>(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    ASSERT(m_nCount >= 0);  // make sure we don't underflow

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    ASSERT_VALID(this);

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    ASSERT_VALID(this);

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
    ASSERT_VALID(this);

    ASSERT(pNewList != NULL);
    ASSERT_VALID(pNewList);

    // add a list of same elements to head (maintain order)
    POSITION pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
    ASSERT_VALID(this);
    ASSERT(pNewList != NULL);
    ASSERT_VALID(pNewList);

    // add a list of same elements
    POSITION pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
    ASSERT_VALID(this);
    ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
    ASSERT(IsValidAddress(m_pNodeHead, sizeof(CNode)));

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
    ASSERT_VALID(this);
    ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
    ASSERT(IsValidAddress(m_pNodeTail, sizeof(CNode)));

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
    ASSERT_VALID(this);

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        ASSERT(IsValidAddress(pOldNode->pPrev, sizeof(CNode)));
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        ASSERT(pOldNode == m_pNodeHead);
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
    ASSERT_VALID(this);

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    ASSERT(IsValidAddress(pOldNode, sizeof(CNode)));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        ASSERT(IsValidAddress(pOldNode->pNext, sizeof(CNode)));
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        ASSERT(pOldNode == m_pNodeTail);
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
    ASSERT_VALID(this);

    CNode* pOldNode = (CNode*) position;
    ASSERT(IsValidAddress(pOldNode, sizeof(CNode)));

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        ASSERT(IsValidAddress(pOldNode->pPrev, sizeof(CNode)));
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        ASSERT(IsValidAddress(pOldNode->pNext, sizeof(CNode)));
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        pNode = pNode->pNext;
    }
    return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
    ASSERT_VALID(this);

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        ASSERT(IsValidAddress(pNode, sizeof(CNode)));
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (CompareElements<TYPE>(&pNode->data, &searchValue))
            return (POSITION)pNode;
    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CMap(int nBlockSize = 10);

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    POSITION GetStartPosition() const;
    void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const;
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CMap();
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
    ASSERT(nBlockSize > 0);

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    ASSERT_VALID(this);
    ASSERT(m_nCount == 0);
    ASSERT(nHashSize > 0);

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];
        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }
    m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    ASSERT_VALID(this);

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
              pAssoc = pAssoc->pNext)
            {
                DestructElements<VALUE>(&pAssoc->value, 1);
                DestructElements<KEY>(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
    RemoveAll();
    ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
        // chain them into free list
        CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    ASSERT(m_pFreeList != NULL);  // we must have something

    CMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    ASSERT(m_nCount > 0);  // make sure we don't overflow
    ConstructElements<KEY>(&pAssoc->key, 1);
    ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CMap::CAssoc* pAssoc)
{
    DestructElements<VALUE>(&pAssoc->value, 1);
    DestructElements<KEY>(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    ASSERT(m_nCount >= 0);  // make sure we don't underflow

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (CompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    ASSERT_VALID(this);

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    ASSERT_VALID(this);

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    ASSERT_VALID(this);

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (CompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    ASSERT_VALID(this);
    ASSERT(m_pHashTable != NULL);  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    ASSERT(pAssocRet != NULL);

    if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        ASSERT(pAssocRet != NULL);  // must find something
    }

    // find next association
    ASSERT(IsValidAddress(pAssocRet, sizeof(CAssoc)));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (POSITION) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}


/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
    // Accessing elements
    TYPE GetAt(int nIndex) const
        { return (TYPE)BASE_CLASS::GetAt(nIndex); }
    TYPE& ElementAt(int nIndex)
        { return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
    void SetAt(int nIndex, TYPE ptr)
        { BASE_CLASS::SetAt(nIndex, ptr); }

    // Potentially growing the array
    void SetAtGrow(int nIndex, TYPE newElement)
       { BASE_CLASS::SetAtGrow(nIndex, newElement); }
    int Add(TYPE newElement)
       { return BASE_CLASS::Add(newElement); }
    int Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
       { return BASE_CLASS::Append(src); }
    void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
        { BASE_CLASS::Copy(src); }

    // Operations that move elements around
    void InsertAt(int nIndex, TYPE newElement, int nCount = 1)
        { BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
    void InsertAt(int nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
       { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

    // overloaded operator helpers
    TYPE operator[](int nIndex) const
        { return (TYPE)BASE_CLASS::operator[](nIndex); }
    TYPE& operator[](int nIndex)
        { return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
// Construction
    CTypedPtrList(int nBlockSize = 10)
        : BASE_CLASS(nBlockSize) { }

    // peek at head or tail
    TYPE& GetHead()
        { return (TYPE&)BASE_CLASS::GetHead(); }
    TYPE GetHead() const
        { return (TYPE)BASE_CLASS::GetHead(); }
    TYPE& GetTail()
        { return (TYPE&)BASE_CLASS::GetTail(); }
    TYPE GetTail() const
        { return (TYPE)BASE_CLASS::GetTail(); }

    // get head or tail (and remove it) - don't call on empty list!
    TYPE RemoveHead()
        { return (TYPE)BASE_CLASS::RemoveHead(); }
    TYPE RemoveTail()
        { return (TYPE)BASE_CLASS::RemoveTail(); }

    // add before head or after tail
    POSITION AddHead(TYPE newElement)
        { return BASE_CLASS::AddHead(newElement); }
    POSITION AddTail(TYPE newElement)
        { return BASE_CLASS::AddTail(newElement); }

    // add another list of elements before head or after tail
    void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
        { BASE_CLASS::AddHead(pNewList); }
    void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
        { BASE_CLASS::AddTail(pNewList); }

    // iteration
    TYPE& GetNext(POSITION& rPosition)
        { return (TYPE&)BASE_CLASS::GetNext(rPosition); }
    TYPE GetNext(POSITION& rPosition) const
        { return (TYPE)BASE_CLASS::GetNext(rPosition); }
    TYPE& GetPrev(POSITION& rPosition)
        { return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
    TYPE GetPrev(POSITION& rPosition) const
        { return (TYPE)BASE_CLASS::GetPrev(rPosition); }

    // getting/modifying an element at a given position
    TYPE& GetAt(POSITION position)
        { return (TYPE&)BASE_CLASS::GetAt(position); }
    TYPE GetAt(POSITION position) const
        { return (TYPE)BASE_CLASS::GetAt(position); }
    void SetAt(POSITION pos, TYPE newElement)
        { BASE_CLASS::SetAt(pos, newElement); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
    CTypedPtrMap(int nBlockSize = 10)
        : BASE_CLASS(nBlockSize) { }

    // Lookup
    BOOL Lookup(BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
        { return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

    // Lookup and add if not there
    VALUE& operator[](BASE_CLASS::BASE_ARG_KEY key)
        { return (VALUE&)BASE_CLASS::operator[](key); }

    // add a new key (key, value) pair
    void SetAt(KEY key, VALUE newValue)
        { BASE_CLASS::SetAt(key, newValue); }

    // removing existing (key, ?) pair
    BOOL RemoveKey(KEY key)
        { return BASE_CLASS::RemoveKey(key); }

    // iteration
    void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
        { BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
            (BASE_CLASS::BASE_VALUE&)rValue); }
};


#endif //__MCTEMPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\mnemonic.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      mnemonic.h
 *
 *  Contents:  Mnemonic helpers
 *
 *  History:   31-Aug-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef MNEMONIC_H
#define MNEMONIC_H
#pragma once


/*+-------------------------------------------------------------------------*
 * GetMnemonicChar 
 *
 * Returns the mnemonic character for the input string, 0 if none.
 *--------------------------------------------------------------------------*/

template<class T>
T GetMnemonicChar (const T* pszText, const T** pchMnemonic = NULL)
{
    const T* pchT             = pszText;
    const T  chMnemonicMarker = '&';
    T        chMnemonic       = 0;

    // find the mnemonic character
    for (bool fContinue = true; fContinue; )
    {
        // find the next mnemonic marker
        while ((*pchT != 0) && (*pchT != chMnemonicMarker))
            pchT++;

        // no mnemonic marker?
        if (*pchT != chMnemonicMarker)
            break;

        switch (*++pchT)
        {
            // double mnemonic marker, keep going
            case chMnemonicMarker:
                pchT++;
                break;

            // end of string, no mnemonic
            case 0:
                fContinue = false;
                break;

            // found a mnemonic
            default:
                if (pchMnemonic != NULL)
                    *pchMnemonic = pchT;

                chMnemonic = *pchT;
                fContinue  = false;
                break;
        }
    }

    return (chMnemonic);
}


#endif /* MNEMONIC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\ndmgrp.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      ndmgrp.h
 *
 *  Contents:  Private header to go along with ndmgr.h
 *
 *  History:   03-Mar-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef NDMGRP_H
#define NDMGRP_H
#pragma once

#include "ndmgr.h"

struct DataWindowData
{
    MMC_COOKIE          cookie;
    LONG_PTR            lpMasterNode;
    IDataObjectPtr      spDataObject;
    IComponentDataPtr   spComponentData;
    IComponentPtr       spComponent;
    HWND                hDlg;
};

inline DataWindowData* GetDataWindowData (HWND hwndData)
{
    LONG_PTR nData = GetWindowLongPtr (hwndData, WINDOW_DATA_PTR_SLOT);
    return (reinterpret_cast<DataWindowData *>(nData));
}


#endif /* NDMGRP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\mmcx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcx.h
//
//--------------------------------------------------------------------------

#ifndef MMCX_H
#define MMCX_H
#include <bool.h>

// This avoids "warning C4290: C++ Exception Specification ignored"
// JonN 12/16/96
#pragma warning(4:4290)

class MMCX
	{
	public: enum Code
		{
		InvalidInstanceData,
		InvalidParameter,
		InvalidPointer,
		InvalidVersion,
		UnableToCreateStorage,
		UnableToCreateStream,
		UnableToDestroyElement,
		UnableToSave,
		UnableToLoad,
		UnableToLoadSomePortionOfTheTree,
		UnableToOpenStorage,
		UnableToOpenStream,
		UnableToWriteToStream,
		Unknown,
		};

	public: MMCX() throw()
		: m_Code(Unknown)
			#ifdef _DEBUG
			, m_File(_T(__FILE__)), m_Line(__LINE__)
			#endif
		{
		}

	public: MMCX(Code c, const TCHAR* file, int line) throw()
		: m_Code(c)
			#ifdef _DEBUG
			, m_File(file), m_Line(line)
			#endif
		{
		}

	public: MMCX(Code c) throw()
		: m_Code(c)
			#ifdef _DEBUG
			, m_File(_T(__FILE__)), m_Line(__LINE__)
			#endif
		{
		}

	public: MMCX(const MMCX& e) throw()
		: m_Code(e.m_Code)
			#ifdef _DEBUG
			, m_File(e.m_File), m_Line(e.m_Line)
			#endif
		{
		}

	public: ~MMCX() throw()
		{
		}

	public: MMCX& operator=(const MMCX& e) throw()
		{
		m_Code = e.m_Code;
		#ifdef _DEBUG
		m_File = e.m_File;
		m_Line = e.m_Line;
		#endif
		return *this;
		}

	public: bool operator==(Code c) const throw()
		{
		return m_Code == c;
		}

	public: bool operator==(const MMCX& m) const throw()
		{
		return operator==(m.m_Code);
		}

	public: bool operator!=(Code c) const throw()
		{
		return m_Code != c;
		}

	public: bool operator!=(const MMCX& m) const throw()
		{
		return operator!=(m.m_Code);
		}

	public: Code GetCode() const throw()
		// Returns the error code.
		{
		return m_Code;
		}

	public: const _TCHAR* GetDescription() const throw()
		{
		// This may be less efficeint than a lookup table, but is
		// only used in debug builds, and is much more maintainable (the
		// table doesn't have to be kept in exact sync with the code
		// enumerations).
		switch (m_Code)
			{
			case InvalidInstanceData:
				return _T("Invalid instance data");
			case InvalidParameter:
				return _T("Invalid parameters passed to a function");
			case InvalidPointer:
				return _T("Pointer found in invalid state");
			case InvalidVersion:
				return _T("This version of MMC is not compatible with the ")
														_T("file opened");
			case UnableToCreateStorage:
				return _T("Unable to create storage");
			case UnableToCreateStream:
				return _T("Unable to create stream in storage");
			case UnableToDestroyElement:
				return _T("Unable to destroy an element in a docfile");
			case UnableToSave:
				return _T("Unable to save");
			case UnableToLoad:
				return _T("Unable to load from storage");
			case UnableToLoadSomePortionOfTheTree:
				return _T("Unable to load some of the tree");
			case UnableToOpenStorage:
				return _T("Unable to open a storage");
			case UnableToOpenStream:
				return _T("Unable to open a stream");
			case UnableToWriteToStream:
				return _T("Unable to write to stream");
			case Unknown:
				return _T("Unknown");
			}
		return _T("Unknown");
		}

	private: Code m_Code;
	#ifdef _DEBUG
	private: const TCHAR* m_File;
	private: int m_Line;
	#endif

	}; // class MMCException

template<typename MoreInfoT> class MMCXPlus : public MMCX
	{
	public: MMCXPlus() throw()
		{
		}

	public: MMCXPlus(const MoreInfoT& m, Code c, const TCHAR* file, int line) throw()
		: MMCX(c, file, line), m_MoreInfo(m)
		{
		}

	public: MMCXPlus(const MoreInfoT& m, Code c) throw()
		: MMCX(c), m_MoreInfo(m)
		{
		}

	public: MMCXPlus(const MMCXPlus& e) throw()
		: MMCX(e), m_MoreInfo(e.m_MoreInfo)
		{
		}

	public: ~MMCXPlus() throw()
		{
		}

	public: MMCXPlus& operator=(const MMCXPlus& e) throw()
		{
		MMCX::operator=(e);
		m_MoreInfo = e.m_MoreInfo;
		return *this;
		}

	public: const MoreInfoT& GetMoreInfo() const throw()
		{
		return m_MoreInfo;
		}

	private: MoreInfoT m_MoreInfo;
	}; // class MMCXPlus

typedef MMCXPlus<HRESULT> COMX;

#ifdef _DEBUG
#define XCODE(x) MMCX::Code::x, _T(__FILE__), __LINE__
#else
#define XCODE(x) MMCX::Code::x
#endif

// Assert 'n throw macros
#define ANT(test, exception) \
	if (!static_cast<bool>(test)) { ASSERT(static_cast<bool>(test)); throw exception; }

#define AssertThenThrow(test, exception) ANT(test, exception)

#define ANTIfNot(exception, acceptableException) \
	if (exception != acceptableException) \
		{ ASSERT(exception != acceptableException); throw exception; }

#define AssertThenThrowIfNot(exception, acceptableException) \
	ANTIfNot(exception, acceptableException)

#define MMCEX(x) MMCX(XCODE(x))
#define COMEX(hr, x) COMX(hr, XCODE(x))
#endif // MMCX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\modulepath.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       modulepath.h
//
//--------------------------------------------------------------------------

#pragma once

#if !defined(__MODULEPATH_H_INCLUDED__)
#define __MODULEPATH_H_INCLUDED__

#include "cstr.h"

/***************************************************************************\
 *
 * Class:  CModulePath
 *
 * PURPOSE: groups static methods needed to set correct module paths in the registry
 *          Having a class here (not functions) allows to link only one instance
 *			of the methods per module.
 * NOTE:    it uses global _Module, which is different for each DLL.
 *
\***************************************************************************/
class CModulePath
{
public:
	/***************************************************************************\
	 *
	 * METHOD:  MakeAbsoluteModulePath
	 *
	 * PURPOSE: makes absolute path by prepending the directory of current module.
	 *			If file is in system directory and platform supports that,
	 *			method replaces path with "%SystemRoot%\system32" or similar.
	 *
	 * PARAMETERS:
	 *    const CStr& str - module name.
	 *
	 * RETURNS:
	 *    CStr    - result path (empty if cannot be calculated)
	 *
	\***************************************************************************/
	static CStr MakeAbsoluteModulePath(const CStr& str)
	{
		// if the string contains path - do not change it
		CStr strModulePath;
		if ( ( str.Find(_T('\\')) != -1 ) || ( str.Find(_T('/')) != -1 ) )
		{
			strModulePath = str;
		}
		else
		{
            /*
             * get a buffer for the module filename; if it failed,
             * return empty string
             */
            LPTSTR pszModulePath = strModulePath.GetBuffer(_MAX_PATH);
            if (pszModulePath == NULL)
				return _T("");

			// else append the module directory
			DWORD dwPathLen = ::GetModuleFileName(_Module.GetModuleInstance(),
												  pszModulePath,
												  _MAX_PATH );
			strModulePath.ReleaseBuffer();

			// if encountered problems with a path - return empty string
			if ( dwPathLen == 0 )
				return _T("");

			int iLastSlashPos = strModulePath.ReverseFind(_T('\\'));
			// if we cannot separate the filename - cannot append it to the file
			if (iLastSlashPos == -1)
				return _T("");

			//not subtract the file name
			strModulePath = strModulePath.Left(iLastSlashPos + 1) + str;
		}

		// now see it it matches system directory ...

		// get system dir
		CStr strSystemPath;
        LPTSTR pszSystemPath = strSystemPath.GetBuffer(_MAX_PATH);
        if (pszSystemPath == NULL)
            return strModulePath;

		DWORD dwPathLen = ::GetSystemDirectory( pszSystemPath, _MAX_PATH);
		strSystemPath.ReleaseBuffer();

		// if encountered problems with system path - return what we have
		if ( dwPathLen == 0 )
			return strModulePath;

		// now compare the path and substitute with the environment variable
		// [ if path is not in the system dir - use the value we already have ]
		if ( PlatformSupports_REG_EXPAND_SZ_Values() &&
			(_tcsnicmp( strSystemPath, strModulePath, strSystemPath.GetLength() ) == 0) )
		{
			CStr strSystemVariable = (IsNTPlatform() ? _T("%SystemRoot%\\System32") :
													   _T("%WinDir%\\System"));

			// path is in the system dir - replace it with environment var
			strModulePath = strSystemVariable + strModulePath.Mid(strSystemPath.GetLength());
		}

		return strModulePath;
	}

	/***************************************************************************\
	 *
	 * METHOD:  IsNTPlatform
	 *
	 * PURPOSE: checks current platform
	 *
	 * RETURNS:
	 *    bool    - true if application is running on NT platform
	 *
	\***************************************************************************/
	static bool IsNTPlatform()
	{
		// Find out OS version.
		OSVERSIONINFO versInfo;
		versInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		BOOL bStat = ::GetVersionEx(&versInfo);
		ASSERT(bStat);
		return (versInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
	}

	/***************************************************************************\
	 *
	 * METHOD:  PlatformSupports_REG_EXPAND_SZ_Values
	 *
	 * PURPOSE: checks current platform capabilities
	 *
	 * RETURNS:
	 *    bool   - true if platform supports REG_EXPAND_SZ values in registry
	 *
	\***************************************************************************/
	static bool PlatformSupports_REG_EXPAND_SZ_Values()
	{
		// Find out OS version.
		OSVERSIONINFO versInfo;
		versInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		BOOL bStat = ::GetVersionEx(&versInfo);
		ASSERT(bStat);

		// NT supports it...
		if (versInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
			return true;

		// for 9x to support REG_EXPAND_SZ it should be Win98 at least
		// But even on winME OLE does not support REG_EXPAND_SZ (despite the OS does)
		// so we put the absolute path anyway
		return false;
	}
};

#endif // !defined(__MODULEPATH_H_INCLUDED__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\npd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       npd.h
//
//--------------------------------------------------------------------------

#ifndef NPD_H
#define NPD_H

#ifndef COMDBG_H
#include <comdbg.h>
#endif

// {118B559C-6D8C-11d0-B503-00C04FD9080A}
extern const GUID IID_PersistData;

#if _MSC_VER < 1100
class PersistData : public IUnknown, public CComObjectRoot
#else
class __declspec(uuid("118B559C-6D8C-11d0-B503-00C04FD9080A")) PersistData : 
                                      public IUnknown, public CComObjectRoot
#endif
{
public:
    BEGIN_COM_MAP(PersistData)
        COM_INTERFACE_ENTRY(PersistData)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(PersistData)

    HRESULT Initialize(IStorage* pRoot, BOOL bSameAsLoad)
    {
        m_spRoot = pRoot;
        ASSERT(m_spRoot != NULL);
        if (m_spRoot == NULL)
            return E_INVALIDARG;

        m_bSameAsLoad = bSameAsLoad;

        if (bSameAsLoad)
            return Open();
        return Create();
    }

    HRESULT Create(IStorage* pRoot)
    {
        m_spRoot = pRoot;
        ASSERT(m_spRoot != NULL);
        if (m_spRoot == NULL)
            return E_INVALIDARG;

        m_bSameAsLoad = TRUE;

        return Create();
    }

    HRESULT Open(IStorage* pRoot)
    {
        m_spRoot = pRoot;
        ASSERT(m_spRoot != NULL);
        if (m_spRoot == NULL)
            return E_INVALIDARG;

        m_bSameAsLoad = TRUE;

        return Open();
    }

    IStorage* GetRoot()
    {
        return m_spRoot;
    }

    BOOL SameAsLoad()
    {
        return m_bSameAsLoad;
    }

    void SetSameAsLoad(BOOL bSame = TRUE)
    {
        m_bSameAsLoad = bSame;
    }

    void ClearSameAsLoad()
    {
        m_bSameAsLoad = FALSE;
    }
                                     
    IStream* GetTreeStream()
    {
        return m_spTreeStream;
    }

    IStorage* GetNodeStorage()
    {
        return m_spNodeStorage;
    }

protected:
    explicit PersistData()
        : m_bSameAsLoad(TRUE)
    {
    }

    virtual ~PersistData()
    {
    }

private:
    IStoragePtr m_spRoot;
    BOOL m_bSameAsLoad;
    IStreamPtr m_spTreeStream;
    IStoragePtr m_spNodeStorage;

    explicit PersistData(const PersistData&);
        // No copy.

    PersistData& operator=(const PersistData&);
        // No copy.

    HRESULT Create()
    {
        ASSERT(m_bSameAsLoad || (!m_bSameAsLoad && m_spRoot != NULL));
        if (!m_bSameAsLoad && m_spRoot == NULL)
            return E_INVALIDARG;

        // Create the stream for the tree
        HRESULT hr = CreateDebugStream(m_spRoot, L"tree",
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\tree",
                                                            &m_spTreeStream);
        ASSERT(SUCCEEDED(hr) && m_spTreeStream != NULL);
        if (FAILED(hr))
            return hr;

        // Create the storage for the nodes
        hr = CreateDebugStorage(m_spRoot, L"nodes",
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\nodes",
                                                            &m_spNodeStorage);
        ASSERT(SUCCEEDED(hr) && m_spNodeStorage != NULL);
        if (FAILED(hr))
            return hr;
        return S_OK;
    }

    HRESULT Open()
    {
        ASSERT(m_bSameAsLoad || (!m_bSameAsLoad && m_spRoot != NULL));
        if (!m_bSameAsLoad && m_spRoot == NULL)
            return E_INVALIDARG;

        // Open the stream for the trees persistent data.
        HRESULT hr = OpenDebugStream(m_spRoot, L"tree",
                STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\tree", &m_spTreeStream);
        ASSERT(SUCCEEDED(hr) && m_spTreeStream != NULL);
        if (FAILED(hr))
            return hr;

        // Open the storage for the nodes
        hr = OpenDebugStorage(m_spRoot, L"nodes",
                        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"\\nodes", 
                                                            &m_spNodeStorage);
        ASSERT(SUCCEEDED(hr) && m_spNodeStorage != NULL);
        if (FAILED(hr))
            return hr;
        return S_OK;
    }
}; // class PersistData

DEFINE_COM_SMARTPTR(PersistData);   // PersistDataPtr

#endif // NPD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\ndmgrpriv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ndmgrpriv.h (originally ndmgr.idl)
//
//--------------------------------------------------------------------------

#include "mmcobj.h"
#include <string>
#include <vector>
#include <iterator>

#ifndef __ndmgrpriv_h__
#define __ndmgrpriv_h__

#define MMC_INTERFACE(Interface, x)    \
    extern "C" const IID IID_##Interface;   \
    struct DECLSPEC_UUID(#x) __declspec(novtable) Interface

// forward class declarations
class CContextMenuInfo;
class CResultViewType;
class tstring;
class CColumnInfoList;
class CConsoleView;
class CXMLObject;

// interfaces
interface INodeType;
interface INodeTypesCache;
interface IEnumNodeTypes;
interface IFramePrivate;
interface IScopeDataPrivate;
interface IResultDataPrivate;
interface IImageListPrivate;
interface IPropertySheetNotify;
interface INodeCallback;
interface IScopeTreeIter;
interface IScopeTree;
interface IPropertySheetProviderPrivate;
interface IDumpSnapins;
interface IMMCListView;
interface ITaskPadHost;
interface IStringTablePrivate;
interface ITaskCallback;
interface IComCacheCleanup;
interface IHeaderCtrlPrivate;
interface IMMCClipboardDataObject;
interface IMMCClipboardSnapinObject;

typedef IFramePrivate*          LPFRAMEPRIVATE;
typedef IScopeDataPrivate*      LPSCOPEDATAPRIVATE;
typedef IResultDataPrivate*     LPRESULTDATAPRIVATE;
typedef IImageListPrivate*      LPIMAGELISTPRIVATE;
typedef IPropertySheetNotify*   LPPROPERTYSHEETNOTIFY;
typedef INodeCallback*          LPNODECALLBACK;
typedef IScopeTreeIter*         LPSCOPETREEITER;
typedef IScopeTree*             LPSCOPETREE;
typedef INodeType*              LPNODETYPE;
typedef INodeTypesCache*        LPNODETYPESCACHE;
typedef IEnumNodeTypes*         LPENUMNODETYPES;
typedef IDumpSnapins*           LPDUMPSNAPINS;
typedef IMMCListView*           LPMMCLISTVIEW;
typedef ITaskCallback*          LPTASKCALLBACK;
typedef IComCacheCleanup*       LPCOMCACHECLEANUP;
typedef IMMCClipboardDataObject*    LPCLIPBOARDDATAOBJECT;
typedef IMMCClipboardSnapinObject*  LPCLIPBOARDSNAPINOBJECT;

typedef LONG_PTR                HBOOKMARK;
typedef LONG_PTR                HVIEWSETTINGS;
typedef LONG_PTR                HPERSISTOR;

typedef IPropertySheetProviderPrivate*  LPPROPERTYSHEETPROVIDERPRIVATE;

typedef struct _TREEITEM * HTREEITEM;

// Implements the list save feature (t-dmarm)
#define IMPLEMENT_LIST_SAVE

// Use to see if the MT Node is valid before referencing the saved pointer in
// a property sheet.
STDAPI MMCIsMTNodeValid(void* pMTNode, BOOL bReset);

// Window class used to store data for property sheets
#define MAINFRAME_CLASS_NAME   L"MMCMainFrame"

// Window class used to store data for property sheets
#define DATAWINDOW_CLASS_NAME  L"MMCDataWindow"
#define WINDOW_DATA_SIZE       (sizeof (DataWindowData *))

// Slots for data stored in the data windows
#define WINDOW_DATA_PTR_SLOT   0

// Max length of item text in list/tree controls
// (including the terminating zero)
#define MAX_ITEM_TEXT_LEN      1024

// MID(Menu Identifications) for context menus
enum MID_LIST
{
    MID_VIEW = 1,
    MID_VIEW_LARGE,
    MID_VIEW_SMALL,
    MID_VIEW_LIST,
    MID_VIEW_DETAIL,
    MID_VIEW_FILTERED,
    MID_VIEW_HTML,
    MID_ARRANGE_ICONS,
    MID_LINE_UP_ICONS,
    MID_PROPERTIES,
    MID_CREATE_NEW,
    MID_TASK,
    MID_EXPLORE,
    MID_NEW_TASKPAD_FROM_HERE,
    MID_OPEN,
    MID_CUT,
    MID_COPY,
    MID_PASTE,
    MID_DELETE,
    MID_PRINT,
    MID_REFRESH,
    MID_RENAME,
    MID_CONTEXTHELP,
    MID_ARRANGE_AUTO,
    MID_STD_MENUS,
    MID_STD_BUTTONS,
    MID_SNAPIN_MENUS,
    MID_SNAPIN_BUTTONS,
    MID_LISTSAVE,
    MID_COLUMNS,
    MID_CUSTOMIZE,
    MID_ORGANIZE_FAVORITES,
    MID_EDIT_TASKPAD,
    MID_DELETE_TASKPAD,

    MID_LAST,   // this must be last

};

class CResultItem;

typedef struct _CCLVSortParams
{
    BOOL                    bAscending;         // sort direction
    int                     nCol;               // Which column to sort on.
    LPRESULTDATACOMPARE     lpResultCompare;    // Snap-in component interface
    LPRESULTDATACOMPAREEX   lpResultCompareEx;  //          "
    LPARAM                  lpUserParam;        // parameter user passes in
    BOOL                    bSetSortIcon;       // Sort icon /*[not]*/ needed

    /*
     * Bug 414256:  We need to save the sort data only if
     * it is user initiated sort. Is this user initiated?
     */
    BOOL                    bUserInitiatedSort;
} CCLVSortParams;

//
// This structure is used by MMCPropertyChangeNotify to pass
// information from a property sheet to the console.  It has routing
// information to notify the correct snap-in of a property changed notify.
//

const DWORD MMC_E_INVALID_FILE = 0x80FF0002;
const DWORD MMC_E_SNAPIN_LOAD_FAIL = 0x80FF0003;

typedef struct _PROPERTYNOTIFYINFO
{
    LPCOMPONENTDATA pComponentData; // Valid if (fScopePane == TRUE)
    LPCOMPONENT     pComponent;     // Valid if (fScopePane == FALSE)
    BOOL            fScopePane;     // True if it is for a scope pane item.
    HWND            hwnd;           // HWND to console handling the message
} PROPERTYNOTIFYINFO;


// Context menu types
typedef enum  _MMC_CONTEXT_MENU_TYPES
{
    MMC_CONTEXT_MENU_DEFAULT   = 0,      // Normal context menu
    MMC_CONTEXT_MENU_ACTION    = 1,      // Action menu button
    MMC_CONTEXT_MENU_VIEW      = 2,      // View menu button
    MMC_CONTEXT_MENU_FAVORITES = 3,      // Favorites menu button
    MMC_CONTEXT_MENU_LAST      = 4,

}   MMC_CONTEXT_MENU_TYPES;

DECLARE_HANDLE (HMTNODE);
DECLARE_HANDLE (HNODE);     // A scope pane handle(lParam) within a view

typedef unsigned long MTNODEID;

const MTNODEID ROOTNODEID      = 1;


typedef PROPERTYNOTIFYINFO*     LPPROPERTYNOTIFYINFO;

// Special cookies (Note: Can't use -1)
const LONG_PTR LVDATA_BACKGROUND  =  -2;
const LONG_PTR LVDATA_CUSTOMOCX   =  -3;
const LONG_PTR LVDATA_CUSTOMWEB   =  -4;
const LONG_PTR LVDATA_MULTISELECT =  -5;
const LONG_PTR LVDATA_ERROR       = -10;
const LONG_PTR SPECIAL_LVDATA_MIN = -10;
const LONG_PTR SPECIAL_LVDATA_MAX =  -2;
#define IS_SPECIAL_LVDATA(d) (((d) >= SPECIAL_LVDATA_MIN) && ((d) <= SPECIAL_LVDATA_MAX))


typedef struct _SELECTIONINFO
{
    BOOL                m_bScope;
    BOOL                m_bBackground;
    IUnknown*           m_pView;    // valid for scope seln (CDN_SELECT)
    MMC_COOKIE          m_lCookie;   // valid for result item (CCN_SELECT)
    MMC_CONSOLE_VERB    m_eCmdID;
    BOOL                m_bDueToFocusChange;
    BOOL                m_bResultPaneIsOCX;
    BOOL                m_bResultPaneIsWeb;
} SELECTIONINFO;


typedef struct _HELPDOCINFO
{
    LPCOLESTR     m_pszFileName;    // File name (same as .msc file)
    FILETIME      m_ftimeCreate;    // .msc file creation time
    FILETIME      m_ftimeModify;    // .msc file modification time
} HELPDOCINFO;

// MMC_ILISTPAD_INFO struct: internal form has additional field for clsid
typedef struct _MMC_ILISTPAD_INFO
{
    MMC_LISTPAD_INFO info;
    LPOLESTR szClsid;
} MMC_ILISTPAD_INFO;

// *****************************************
// CLASS: CTaskPadData
// this class represents data set representing one TaskPad
// used to request taskpad information from CNode
// *****************************************
class CTaskPadData
{
public:
    std::wstring strName;
    CLSID        clsidTaskPad;
};
typedef std::vector<CTaskPadData>                CTaskPadCollection;
typedef std::insert_iterator<CTaskPadCollection> CTaskPadInsertIterator;

// *****************************************
// CLASS:CViewExtensionData
// this class represents data set representing one ViewExtension
// used to request extension information from CNode
// *****************************************
class CViewExtensionData
{
public:
    std::wstring strURL;
    std::wstring strName;
    std::wstring strTooltip;
    GUID         viewID;  // unique identifier for the view
    bool         bReplacesDefaultView;
};
typedef std::vector<CViewExtensionData>          CViewExtCollection;
typedef std::insert_iterator<CViewExtCollection> CViewExtInsertIterator;


// The following internal flag corresponding to public view style MMC_ENSUREFOCUSVISIBLE.
// The flag is placed in the upper half of a long so it won't conflict with the LVS_*
// flags that are passed in the same long to our list control's SetViewStyle method.

#define MMC_LVS_ENSUREFOCUSVISIBLE 0x00010000


/*
NOTIFICATIONS
=============

Notify(dataobject, event, arg, param);
    For all the MMC_NOTIFY_TYPE events,
    dataobject = dataobject for cookie, can be NULL when dataobject is not required
    event = one of the CD_NOTIFY_TYPEs
    arg and param depend on type, see below.


NCLBK_ACTIVATE
    arg = TRUE if gaining focus

NCLBK_BTN_CLICK
    ....

NCLBK_CLICK

NCLBK_CONTEXTMENU
    param = CContextMenuInfo*

NCLBK_DBLCLICK

NCLBK_DELETE
    arg = TRUE if scope item FALSE if result item.
    param = If scope item is being deleted param is unused.
            If result item is being deleted param is the result items cookie.
    return = unused.

NCLBK_EXPAND
    arg = TRUE => expand, FALSE => contract

NCLBK_EXPANDED
    arg = TRUE => expanded, FALSE => contracted

NCLBK_FOLDER
    arg = <>0 if expanding, 0 if contracting
    param = HSCOPEITEM of expanding/contracting item

NCLBK_MINIMIZED
    arg = TRUE if minimized

NCLBK_MULTI_SELECT
    arg = TRUE if due to focus change.
    param unused


NCLBK_PROPERTIES
    pLParam = (CResultItem*)arg;
    param unused

NCLBK_PROPERTY_CHANGE
    lpDataObject = NULL
    lParam = user object

NCLBK_NEW_NODE_UPDATE
    arg = 1 => folder needs to be refreshed
    arg = 2 => result view needs to be refreshed
    arg = 3 => both needs to be refreshed

NCLBK_RENAME
    This gets called the first time to query for rename and a
    second time to do the rename.  For the query S_OK or S_FALSE for the
    return type.  After the rename, we will send the new name with a LPOLESTR.
    MMC_COOKIE lResultItemCookie = (MMC_COOKIE)arg;
    pszNewName = (LPOLESTR)param; // the new name
    return = S_OK to allow rename and S_FALSE to disallow rename.

NCLBK_SELECT
    arg = TRUE if the item is selected, FALSE otherwise.
    param = ptr to SELECTIONINFO.

NCLBK_SHOW
    arg = <>0 if selecting, 0 if deselecting
    param = HSCOPEITEM of selected/deselected item

NCLBK_COLUMN_CLICK
    param = nCol, the column that was clicked.

NCLBK_FINDITEM
    This message is sent when a result item list with owner data wants to find
    an item who's name matches a string

    arg = ptr to RESULTFINDINFO
    param = ptr to returned item index

NCLBK_CACHEHINT
    This message is sent when the result item list with owner data is about to
    ask for display info for a range of items.

    arg = index of start item
    param = index of end item

NCLBK_GETHELPDOC
    This message is sent to get the path of the combined help topics document.
    The node manager may update the help doc info.
    arg = pointer to HELPDOCINFO struct
    param = pointer to returned path string (LPOLESTR*)

NCLBK_LISTPAD
    This message is sent to tell the snapin that the TaskPad ListView is ready
    to receive items (if attaching).
    arg = TRUE if attaching, FALSE if detaching


NCLBK_WEBCONTEXTMENU
    send when the user right clicks on a web page.
    arg   = unused
    param = unused

NCLBK_UPDATEHELPDOC
    send when console doc is saved to update help file name and file times
    arg = ptr to current help doc info (HELPDOCINFO*)
    param = ptr to new help doc info  (HELPDOCINFO*)

NCLBK_DELETEHELPDOC
    send when console doc is closed to delete the temp help collection file
    associated with the document
    arg - ptr to help doc info (HELPDOCINFO*)
    param - unused
*/

typedef enum _NCLBK_NOTIFY_TYPE
{
    NCLBK_NONE              = 0x9000,
    NCLBK_ACTIVATE          = 0x9001,
    NCLBK_CACHEHINT         = 0x9002,
    NCLBK_CLICK             = 0x9003,
    NCLBK_CONTEXTMENU       = 0x9004,
    NCLBK_COPY              = 0x9005,
    NCLBK_CUT               = 0x9006,
    NCLBK_DBLCLICK          = 0x9007,
    NCLBK_DELETE            = 0x9008,
    NCLBK_EXPAND            = 0x9009,
    NCLBK_EXPANDED          = 0x900A,
    NCLBK_FINDITEM          = 0x900B,
    NCLBK_FOLDER            = 0x900C,
    NCLBK_MINIMIZED         = 0x900D,
    NCLBK_MULTI_SELECT      = 0x900E,
    NCLBK_NEW_NODE_UPDATE   = 0x900F,
    NCLBK_PRINT             = 0x9011,
    NCLBK_PROPERTIES        = 0x9012,
    NCLBK_PROPERTY_CHANGE   = 0x9013,
    NCLBK_REFRESH           = 0x9015,
    NCLBK_RENAME            = 0x9016,
    NCLBK_SELECT            = 0x9017,
    NCLBK_SHOW              = 0x9018,
    NCLBK_COLUMN_CLICKED    = 0x9019,
    NCLBK_SNAPINHELP        = 0x901D,
    NCLBK_CONTEXTHELP       = 0x901E,
    NCLBK_INITOCX           = 0x9020,
    NCLBK_FILTER_CHANGE     = 0x9021,
    NCLBK_FILTERBTN_CLICK   = 0x9022,
    NCLBK_TASKNOTIFY        = 0x9024,
    NCLBK_GETPRIMARYTASK    = 0x9025,
    NCLBK_GETHELPDOC        = 0x9027,
    NCLBK_LISTPAD           = 0x9029,
    NCLBK_GETEXPANDEDVISUALLY   = 0x902B,
    NCLBK_SETEXPANDEDVISUALLY   = 0x902C,
    NCLBK_NEW_TASKPAD_FROM_HERE = 0x902D,
    NCLBK_WEBCONTEXTMENU    = 0x902E,
    NCLBK_UPDATEHELPDOC     = 0x902F,
    NCLBK_EDIT_TASKPAD      = 0x9030,
    NCLBK_DELETE_TASKPAD    = 0x9031,
    NCLBK_DELETEHELPDOC     = 0x9032
} NCLBK_NOTIFY_TYPE;



///////////////////////////////////////////////////////////////////////////////
// Common Console clipboard formats
//

// Clipboard format for the multi selected static nodes.
// If there are N static nodes are selected in the result pane, the MTNodes
// for these N nodes will be passed in a GloballAlloced memory. The first DWORD
// contains the number of MTNodes, this will be followed by N ptrs to the MTNodes.
//
#define CCF_MULTI_SELECT_STATIC_DATA    ( L"CCF_MULTI_SELECT_STATIC_DATA" )

#define CCF_NEWNODE ( L"CCF_NEWNODE" )

//const CLSID CLSID_NDMGR_SNAPIN = {0x2640211a, 0x06d0, 0x11d1, {0xa7, 0xc9, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0x65}};
extern const CLSID CLSID_NDMGR_SNAPIN;

//const GUID GUID_MMC_NEWNODETYPE = {0xfd17e9cc, 0x06ce, 0x11d1, {0xa7, 0xc9, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0x65}};
extern const GUID GUID_MMC_NEWNODETYPE;


///////////////////////////////////////////////////////////////////////////
///



    // helpstring("Notify that the properties of an object changed"),
    MMC_INTERFACE(IPropertySheetNotify, d700dd8e-2646-11d0-a2a7-00c04fd909dd) : IUnknown
    {
        STDMETHOD(Notify)(/*[in]*/ LPPROPERTYNOTIFYINFO pNotify, /*[in]*/ LPARAM lParam)  = 0;
    };



    // helpstring("IFramePrivate Interface"),
    MMC_INTERFACE(IFramePrivate, d71d1f2a-1ba2-11d0-a29b-00c04fd909dd): IConsole3
    {
        /*[helpstring("Sets IFrame Result pane")]*/
        STDMETHOD(SetResultView)(/*[in]*/ LPUNKNOWN pUnknown)  = 0;

        /*[helpstring("Is the ListView set as result view")]*/
        STDMETHOD(IsResultViewSet)(BOOL* pbIsLVSet) = 0;

        /*[helpstring("Sets Task Pads list view")]*/
        STDMETHOD(SetTaskPadList)(/*[in]*/ LPUNKNOWN pUnknown)  = 0;

        /*[helpstring("IComponent's component ID")]*/
        STDMETHOD(GetComponentID)(/*[out]*/ COMPONENTID* lpComponentID)  = 0;

        /*[helpstring("IComponent's component ID")]*/
        STDMETHOD(SetComponentID)(/*[in]*/ COMPONENTID id)  = 0;

        /*[helpstring("Node for the view.")]*/
        STDMETHOD(SetNode)(/*[in]*/ HMTNODE hMTNode, /*[in]*/ HNODE hNode)  = 0;

        /*[helpstring("Cache the IComponent interface for the snapin.")]*/
        STDMETHOD(SetComponent)(/*[in]*/ LPCOMPONENT lpComponent)  = 0;

        /*[helpstring("Console name space.")]*/
        STDMETHOD(QueryScopeTree)(/*[out]*/ IScopeTree** ppScopeTree)  = 0;

        /*[helpstring("Set the console name space.")]*/
        STDMETHOD(SetScopeTree)(/*[in]*/ IScopeTree* pScopeTree)  = 0;

        /*[helpstring("Creates image list for the scope pane.")]*/
        STDMETHOD(CreateScopeImageList)(/*[in]*/ REFCLSID refClsidSnapIn)  = 0;

        /*[helpstring("bExtension is TRUE if this IFrame is used by an extension.")]*/
        STDMETHOD(SetUsedByExtension)(/*[in]*/ BOOL bExtension)  = 0;

        /*[helpstring("Init view data.")]*/
        STDMETHOD(InitViewData)(/*[in]*/ LONG_PTR lViewData)  = 0;

        /*[helpstring("Clean up view data.")]*/
        STDMETHOD(CleanupViewData)(/*[in]*/ LONG_PTR lViewData)  = 0;

        /*[helpstring("Reset the sort parameters after a selection change.")]*/
        STDMETHOD(ResetSortParameters)()  = 0;
   };




   // helpstring("IScopeDataPrivate Interface"),
    MMC_INTERFACE(IScopeDataPrivate, 60BD2FE0-F7C5-11cf-8AFD-00AA003CA9F6) : IConsoleNameSpace2
    {
    };




    // helpstring("IImageListPrivate Interface"),
    MMC_INTERFACE(IImageListPrivate, 7538C620-0083-11d0-8B00-00AA003CA9F6) : IImageList
    {
        /*[helpstring("Private tree control method used to map images on callbacks")]*/
        STDMETHOD(MapRsltImage)(COMPONENTID id, /*[in]*/ int nSnapinIndex, /*[out]*/ int* pnConsoleIndex)  = 0;

        /*[helpstring("Private tree control method used to map images on callbacks")]*/
        STDMETHOD(UnmapRsltImage)(COMPONENTID id, /*[in]*/ int nConsoleIndex, /*[out]*/ int* pnSnapinIndex)  = 0;
    };



    // helpstring("IResultDataPrivate Interface"),
    MMC_INTERFACE(IResultDataPrivate, 1EBA2300-0854-11d0-8B03-00AA003CA9F6) : IResultData2
    {
        /*[helpstring("Get the list view style.")]*/
        STDMETHOD(GetListStyle)(/*[out]*/ long * pStyle)  = 0;

        /*[helpstring("Set the list view style.")]*/
        STDMETHOD(SetListStyle)(/*[in]*/ long Style)  = 0;

        /*[helpstring("Set loading mode of list")]*/
        STDMETHOD(SetLoadMode)(/*[in]*/ BOOL bState)  = 0;

        /*[helpstring("Arrange the icons in the result pane")]*/
        STDMETHOD(Arrange)(long style)  = 0;

        /*[helpstring("Sort from the Listview header control")]*/
        STDMETHOD(InternalSort)(INT nCol, DWORD dwSortOptions, LPARAM lUserParam, BOOL bColumnClicked)  = 0;

        /*[helpstring("Private tree control method used to reset the result view")]*/
        STDMETHOD(ResetResultData)()  = 0;

        /*[helpstring("Private listview method to retrieve sort column")]*/
        STDMETHOD(GetSortColumn)(INT* pnCol) = 0;

        /*[helpstring("Private listview method to retrieve sort column")]*/
        STDMETHOD(GetSortDirection)(BOOL* pbAscending) = 0;
    };


    // helpstring("IHeaderCtrlPrivate Interface that adds to IHeaderCtrl methods"),
    MMC_INTERFACE(IHeaderCtrlPrivate, 0B384311-701B-4e8a-AEC2-DA6321E27AD2) : IHeaderCtrl2
    {
        /*[helpstring("Get the number of columns in list view.")]*/
        STDMETHOD(GetColumnCount)(/*[in]*/INT* pnCol) = 0;

        /*[helpstring("Get the current column settings from list view header.")]*/
        STDMETHOD(GetColumnInfoList)(/*[out]*/ CColumnInfoList *pColumnsList) = 0;

        /*[helpstring("Modify the columns in list view with given data.")]*/
        STDMETHOD(ModifyColumns)(/*[in]*/ const CColumnInfoList& columnsList) = 0;

        /*[helpstring("Get the column settings that snapin supplied originally")]*/
        STDMETHOD(GetDefaultColumnInfoList)(/*[out]*/ CColumnInfoList& columnsList) = 0;
    };


    // helpstring("Minimum master tree control methods required by node manager."),
    MMC_INTERFACE(IScopeTree, d8dbf067-5fb2-11d0-a986-00c04fd8d565) : IUnknown
    {
        /*[helpstring("Initialize scope tree with the document.")]*/
        STDMETHOD(Initialize)(/*[in]*/ HWND hFrameWindow, /*[in]*/ IStringTablePrivate* pStringTable)  = 0;

        /*[helpstring("Query for an iterator to the master tree items.")]*/
        STDMETHOD(QueryIterator)(/*[out]*/IScopeTreeIter** lpIter)  = 0;

        /*[helpstring("Query for an node callback interface to access HNODE items.")]*/
        STDMETHOD(QueryNodeCallback)(/*[out]*/ INodeCallback** ppNodeCallback)  = 0;

        /*[helpstring("Create a node from the master tree node.")]*/
        STDMETHOD(CreateNode)(/*[in]*/ HMTNODE hMTNode, /*[in]*/ LONG_PTR lViewData,
                           /*[in]*/ BOOL fRootNode, /*[out]*/ HNODE* phNode)  = 0;

        /*[helpstring("Do cleanup needed prior to deleting/shutting down view.")]*/
        STDMETHOD(CloseView)(/*[in]*/ int nView)  = 0;

        /*[helpstring("Delete all view data for the specified view id.")]*/
        STDMETHOD(DeleteView)(/*[in]*/ int nView)  = 0;

        /*[helpstring("Create a node from the master tree node.")]*/
        STDMETHOD(DestroyNode)(/*[in]*/ HNODE hNode)  = 0;

        /*[helpstring("Finds the node that matches the ID")]*/
        STDMETHOD(Find)(/*[in]*/ MTNODEID mID, /*[out]*/ HMTNODE* phMTNode)  = 0;

        /*[helpstring("Create a node from the master tree node.")]*/
        STDMETHOD(GetImageList)(/*[out]*/ PLONG_PTR plImageList)  = 0;

        /*[helpstring("Run snap-in manager")]*/
        STDMETHOD(RunSnapIn)(/*[in]*/ HWND hwndParent)  = 0;

        /*[helpstring("Returns the version for the file rooted at the given storage.")]*/
        STDMETHOD(GetFileVersion)(/*[in]*/ IStorage* pstgRoot, /*[out]*/ int* pnVersion)  = 0;

        /*[helpstring("Returns the MTNODEID for the node represented by a bookmark")]*/
        STDMETHOD(GetNodeIDFromBookmark)(/*[in]*/ HBOOKMARK hbm, /*[out]*/ MTNODEID* pID, /*[out]*/ bool& bExactMatchFound)  = 0;

        /*[helpstring("Loads a bookmark from a stream and returns the MTNODEID for the node.")]*/
        STDMETHOD(GetNodeIDFromStream)(/*[in]*/ IStream *pStm, /*[out]*/ MTNODEID* pID)  = 0;

        /*[helpstring("Loads a bookmark from a stream and returns the MTNODEID for the node.")]*/
        STDMETHOD(GetNodeFromBookmark)(/*[in]*/ HBOOKMARK hbm, /*[in]*/CConsoleView *pConsoleView, /*[out]*/ PPNODE ppNode, /*[out]*/ bool& bExactMatchFound)  = 0;

        /*[helpstring("Returns the ID path for the given ID")]*/
        STDMETHOD(GetIDPath)(/*[in]*/ MTNODEID id, /*[out]*/ MTNODEID** ppIDs, /*[out]*/ long* pLength)  = 0;

        /*[helpstring("Check to see if synchronous node expansion is required")]*/
        STDMETHOD(IsSynchronousExpansionRequired)()  = 0;

        /*[helpstring("Sets whether synchronous node expansion is required")]*/
        STDMETHOD(RequireSynchronousExpansion)(/*[in]*/ BOOL fRequireSyncExpand)  = 0;

        /*[helpstring("Sets the SConsoleData to use for this scope tree")]*/
        STDMETHOD(SetConsoleData)(/*[in]*/ LPARAM lConsoleData)  = 0;

        /*[helpstring("Persists the tree to/from an XML document")]*/
        STDMETHOD(Persist)(/*[in]*/ HPERSISTOR hPersistor)  = 0;

        /*[helpstring("Get path between two nodes as a string")]*/
        STDMETHOD(GetPathString)(/*[in]*/ HMTNODE hmtnRoot, /*[in]*/ HMTNODE hmtnLeaf, /*[out]*/ LPOLESTR* pPath)  = 0;

        /*[helpstring("Get the SnapIns object")]*/
        STDMETHOD(QuerySnapIns)(/*[out]*/ SnapIns **ppSnapIns)  = 0;

        /*[helpstring("Get the ScopeNamespace object")]*/
        STDMETHOD(QueryScopeNamespace)(/*[out]*/ ScopeNamespace **ppScopeNamespace)  = 0;

        /*[helpstring("Create an empty Properties object")]*/
        STDMETHOD(CreateProperties)(/*[out]*/ Properties **ppProperties)  = 0;

        /*[helpstring("Get scope node id for Node object")]*/
        STDMETHOD(GetNodeID)(/*[in]*/ PNODE pNode, /*[out]*/ MTNODEID *pID)  = 0;

        /*[helpstring("Get HMTNODE for Node object")]*/
        STDMETHOD(GetHMTNode)(/*[in]*/ PNODE pNode, /*[out]*/ HMTNODE *phMTNode)  = 0;

        /*[helpstring("Get Node object ptr for scope node")]*/
        STDMETHOD(GetMMCNode)(/*[in]*/ HMTNODE hMTNode, /*[out]*/ PPNODE ppNode)  = 0;

        /*[helpstring("Get NODE object for Root Node")]*/
        STDMETHOD(QueryRootNode)(/*[out]*/ PPNODE ppNode)  = 0;

        /*[helpstring("Check if snapin is used by MMC")]*/
        STDMETHOD(IsSnapinInUse)(/*[in]*/ REFCLSID refClsidSnapIn, /*[out]*/ PBOOL pbInUse)  = 0;
    };



    // helpstring("Master tree item iterator."),
    MMC_INTERFACE(IScopeTreeIter, d779f8d1-6057-11d0-a986-00c04fd8d565) : IUnknown
    {
        /*[helpstring("Sets the current master tree node.")]*/
        STDMETHOD(SetCurrent)(/*[in]*/ HMTNODE hStartMTNode)  = 0;

        /*[helpstring("Returns the next nRequested master node siblings.")]*/
        STDMETHOD(Next)(/*[in]*/ UINT nRequested, /*[out]*/ HMTNODE* rghScopeItems, /*[out]*/ UINT* pnFetched)  = 0;

        /*[helpstring("Returns the child master node.")]*/
        STDMETHOD(Child)(/*[out]*/ HMTNODE* phsiChild)  = 0;

        /*[helpstring("Returns the parent master node.")]*/
        STDMETHOD(Parent)(/*[out]*/ HMTNODE* phsiParent)  = 0;
    };



    // helpstring("Node callback methods."),
    MMC_INTERFACE(INodeCallback, b241fced-5fb3-11d0-a986-00c04fd8d565) : IUnknown
    {
        /*[helpstring("Initialize with the scope tree.")]*/
        STDMETHOD(Initialize)(/*[in]*/ IScopeTree* pIScopeTree)  = 0;

        /*[helpstring("Returns the images for this node.")]*/
        STDMETHOD(GetImages)(/*[in]*/ HNODE hNode, /*[out]*/ int* iImage, int* iSelectedImage)  = 0;

        /*[helpstring("Returns the display name for node.")]*/
        STDMETHOD(GetDisplayName)(/*[in]*/ HNODE hNode, /*[out]*/ tstring& strName)  = 0;

        /*[helpstring("Returns the custom window title for this node")]*/
        STDMETHOD(GetWindowTitle)(/*[in]*/ HNODE hNode, /*[out]*/ tstring& strTitle)  = 0;

        /*[helpstring("Handles callback for result items")]*/
        STDMETHOD(GetDispInfo)(/*[in]*/ HNODE hNode, /*[in,out]*/ LVITEMW* plvi)  = 0;

        /*[helpstring("Returns the UI state of master node.")]*/
        STDMETHOD(GetState)(/*[in]*/ HNODE hNode, /*[out]*/ UINT* pnState)  = 0;

        /*[helpstring("Returns the result pane for the node.")]*/
        STDMETHOD(GetResultPane)(/*[in]*/ HNODE hNode, /*[in, out]*/ CResultViewType& rvt,
                                /*[out]*/ GUID *pGuidTaskpadID)  = 0;

        /*[helpstring("Asks the snapin to restore its result pane with given data")]*/
        STDMETHOD(RestoreResultView)(/*[in]*/HNODE hNode, /*[in]*/const CResultViewType& rvt) = 0;

        /*[helpstring("Returns the result pane OCX control for the node.")]*/
        STDMETHOD(GetControl)(/*[in]*/ HNODE hNode, /*[in]*/ CLSID clsid, /*[out]*/IUnknown **ppUnkControl)  = 0;

        /*[helpstring("Sets the result pane OCX control for the node.")]*/
        STDMETHOD(SetControl)(/*[in]*/ HNODE hNode, /*[in]*/ CLSID clsid, /*[in]*/IUnknown* pUnknown)  = 0;

        /*[helpstring("Returns the result pane OCX control for the node.")]*/
        STDMETHOD(GetControl)(/*[in]*/ HNODE hNode, /*[in]*/LPUNKNOWN pUnkOCX, /*[out]*/IUnknown **ppUnkControl)  = 0;

        /*[helpstring("Sets the result pane OCX control for the node.")]*/
        STDMETHOD(SetControl)(/*[in]*/ HNODE hNode, /*[in]*/LPUNKNOWN pUnkOCX, /*[in]*/IUnknown* pUnknown)  = 0;

        /*[helpstring("Sends the MMCN_INITOCX notification to the appropriate snapin")]*/
        STDMETHOD(InitOCX)(/*[in]*/ HNODE hNode, /*[in]*/ IUnknown* pUnknown)  = 0;

        /*[helpstring("Set the Result Item ID")]*/
        //RENAME// STDMETHOD(SetItemID)(/*[in]*/ HNODE hNode, /*[in]*/ HRESULTITEM riID)  = 0;
        STDMETHOD(SetResultItem)(/*[in]*/ HNODE hNode, /*[in]*/ HRESULTITEM hri)  = 0;

        /*[helpstring("Get the Result Item ID")]*/
        //RENAME// STDMETHOD(GetItemID)(/*[in]*/ HNODE hNode, /*[out]*/ HRESULTITEM* priID)  = 0;
        STDMETHOD(GetResultItem)(/*[in]*/ HNODE hNode, /*[out]*/ HRESULTITEM* phri)  = 0;

        /*[helpstring("Returns the nodes unique ID")]*/
        //RENAME// STDMETHOD(GetID)(/*[in]*/ HNODE hNode, /*[out]*/ MTNODEID* pnID)  = 0;
        STDMETHOD(GetMTNodeID)(/*[in]*/ HNODE hNode, /*[out]*/ MTNODEID* pnID)  = 0;

        /*[helpstring("Determine if node is the target of another")]*/
        STDMETHOD(IsTargetNodeOf)(/*[in]*/ HNODE hNode, /*[in]*/ HNODE hTestNode)  = 0;

        /*[helpstring("Returns the nodes static parents MTNODEID and the subsequent path")]*/
        STDMETHOD(GetPath)(/*[in]*/ HNODE hNode, /*[in]*/ HNODE hRootNode, /*[out]*/ BYTE* pbm_)  = 0;

        /*[helpstring("Returns the static parent nodes unique ID")]*/
        STDMETHOD(GetStaticParentID)(/*[in]*/ HNODE hNode, /*[out]*/ MTNODEID* pnID)  = 0;

        /*[helpstring("Notify")]*/
        STDMETHOD(Notify)(/*[in]*/ HNODE hNode, /*[in]*/ NCLBK_NOTIFY_TYPE event,
                       /*[in]*/ LPARAM arg, /*[in]*/ LPARAM param)  = 0;

        /*[helpstring("Returns the parent master node.")]*/
        STDMETHOD(GetMTNode)(/*[in]*/ HNODE hNode, /*[out]*/ HMTNODE* phMTNode)  = 0;

        /*[helpstring("The HMTNODE path to the node is returned in pphMTNode")]*/
        STDMETHOD(GetMTNodePath)(/*[in]*/ HNODE hNode, /*[out]*/ HMTNODE** pphMTNode,
                              /*[out]*/ long* plLength)  = 0;

        /*[helpstring("Get node's owner ID")]*/
        STDMETHOD(GetNodeOwnerID)(/*[in]*/ HNODE hNode, /*[out]*/ COMPONENTID* pID)  = 0;

        /*[helpstring("Get node's cookie")]*/
        STDMETHOD(GetNodeCookie)(/*[in]*/ HNODE hNode, /*[out]*/ MMC_COOKIE* lpCookie)  = 0;

        /*[helpstring("Returns S_OK if the node can possibly be expanded, and S_FALSE otherwise.")]*/
        STDMETHOD(IsExpandable)(/*[in]*/ HNODE hNode)  = 0;

        /*[helpstring("Return the dataobject for the selected item")]*/
        // cookie valid if bScope & bMultiSel are both FALSE.
        // cookie is the index\lParam for virtual\regular LV
        STDMETHOD(GetDragDropDataObject)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ BOOL bMultiSel,
                                  /*[in]*/ LONG_PTR lvData, /*[out]*/ LPDATAOBJECT* ppDataObject,
                                  /*[out]*/ bool& bCopyAllowed, /*[out]*/ bool& bMoveAllowed)  = 0;

        /*[helpstring("Returns the task enumerator.")]*/
        STDMETHOD(GetTaskEnumerator)(/*[in]*/ HNODE hNode, /*[in]*/ LPCOLESTR pszTaskGroup,
                                  /*[out]*/ IEnumTASK** ppEnumTask)  = 0;

        /*[helpstring("UpdateWindowLayout.")]*/
        STDMETHOD(UpdateWindowLayout)(/*[in]*/ LONG_PTR lViewData, /*[in]*/ long lToolbarsDisplayed)  = 0;

        /*[helpstring("AddCustomFolderImage")]*/
        STDMETHOD(AddCustomFolderImage)(/*[in]*/ HNODE hNode,
                                      /*[in]*/ IImageListPrivate* pImageList)  = 0;

        /*[helpstring("preloads the node if necessary")]*/
        STDMETHOD(PreLoad)(/*[in]*/ HNODE hNode)  = 0;

        /*[helpstring("Get the TaskPad ListView information")]*/
        STDMETHOD(GetListPadInfo)(/*[in]*/ HNODE hNode,
                                /*[in]*/ IExtendTaskPad* pExtendTaskPad,
                                /*[in,string]*/ LPCOLESTR szTaskGroup,
                                /*[out]*/ MMC_ILISTPAD_INFO* pIListPadInfo)  = 0;

        /*[helpstring("Sets Task Pads list view")]*/
        STDMETHOD(SetTaskPadList)(/*[in]*/ HNODE hNode, /*[in]*/ LPUNKNOWN pUnknown)  = 0;

        /*[helpstring("Sets up a specific taskpad, given the GUID identifier.")]*/
        STDMETHOD(SetTaskpad)(/*[in]*/ HNODE hNodeSelected, /*[in]*/ GUID *pGuidTaskpad)  = 0;

        /*[helpstring("Invokes the Customize View dialog")]*/
        STDMETHOD(OnCustomizeView)(/*[in]*/ LONG_PTR lViewData)  = 0;

        /*[helpstring("Set the view settings for a particular node.")]*/
        STDMETHOD(SetViewSettings)(/*[in]*/ int nViewID, /*[in]*/ HBOOKMARK hbm, /*[in]*/ HVIEWSETTINGS hvs)  = 0;

        /*[helpstring("Execute given verb for given scope item")]*/
        STDMETHOD(ExecuteScopeItemVerb)(/*[in]*/ MMC_CONSOLE_VERB verb, /*[in]*/ HNODE hNode, /*[in]*/LPOLESTR lpszNewName)  = 0;

        /*[helpstring("Execute given verb for selected result item(s)")]*/
        STDMETHOD(ExecuteResultItemVerb)(/*[in]*/ MMC_CONSOLE_VERB verb, /*[in]*/ HNODE hNode, /*[in]*/LPARAM lvData, /*[in]*/LPOLESTR lpszNewName)  = 0;

        /*[helpstring("Get the disp interface for given scope node object")]*/
        STDMETHOD(QueryCompDataDispatch)(/*[in]*/ PNODE pNode, /*[out]*/ PPDISPATCH ScopeNodeObject)  = 0;

        /*[helpstring("Get the disp interface for selected resultpane objects")]*/
        STDMETHOD(QueryComponentDispatch)(/*[in]*/ HNODE hNode, /*[in]*/LPARAM lvData, /*[out]*/ PPDISPATCH SelectedObject)  = 0;

        /*[helpstring("Creates a context menu for the specified node.")]*/
        STDMETHOD(CreateContextMenu)( PNODE pNode, HNODE hNode, PPCONTEXTMENU ppContextMenu)  = 0;

        /*[helpstring("Creates a context menu for the current selection node.")]*/
        STDMETHOD(CreateSelectionContextMenu)( HNODE hNodeScope, CContextMenuInfo *pContextInfo, PPCONTEXTMENU ppContextMenu)  = 0;

        /*[helpstring("show/hide column")]*/
        STDMETHOD(ShowColumn)(HNODE hNodeSelected, int iColIndex, bool bShow) = 0;

        /*[helpstring("to get the sort column")]*/
        STDMETHOD(GetSortColumn)(HNODE hNodeSelected, int *piSortCol) = 0;

        /*[helpstring("to set the sort column")]*/
        STDMETHOD(SetSortColumn)(HNODE hNodeSelected, int iSortCol, bool bAscending) = 0;

        /*[helpstring("Returns the data for the specified clipboard format of the specified list item")*/
        STDMETHOD(GetProperty)(/*[in]*/ HNODE hNodeScope, /*[in]*/ BOOL bForScopeItem, /*[in]*/ LPARAM resultItemParam, /*[in]*/ BSTR bstrPropertyName,
                                                     /*[out]*/ PBSTR  pbstrPropertyValue) =0;

        /*[helpstring("Returns the nodetype GUID identifier of the specified list item")*/
        STDMETHOD(GetNodetypeForListItem)(/*[in]*/ HNODE hNodeScope, /*[in]*/ BOOL bForScopeItem, /*[in]*/ LPARAM resultItemParam, /*[in]*/ PBSTR pbstrNodetype) =0;

        /* returns view extension by inserting them to provided iterator */
        STDMETHOD(GetNodeViewExtensions)(/*[in]*/ HNODE hNodeScope, /*[out]*/ CViewExtInsertIterator it) = 0;

        /* Inform nodemgr that the column data for given node has changed & to save the data */
        STDMETHOD(SaveColumnInfoList) (/*[in]*/HNODE hNode, /*[in]*/const CColumnInfoList& columnsList) = 0;

        /* Ask nodemgr for column-data (no sort data) to setup the headers. */
        STDMETHOD(GetPersistedColumnInfoList) (/*[in]*/HNODE hNode, /*[out]*/CColumnInfoList *pColumnsList) = 0;

        /* Inform nodemgr that the column data for given node is invalid. */
        STDMETHOD(DeletePersistedColumnData) (/*[in]*/HNODE hNode) = 0;

        /* Does about object exists for the snapin whose node is provided. */
        STDMETHOD(DoesAboutExist) (/*[in]*/HNODE hNode, /*[out]*/ bool *pbAboutExists) = 0;

        /* Show about box for given context. */
        STDMETHOD(ShowAboutInformation) (/*[in]*/HNODE hNode) = 0;

        /*Executes a shell command with the specified parameters in the specified directory with the correct window size*/
        STDMETHOD(ExecuteShellCommand)(/*[in]*/ HNODE hNode, /*[in]*/ BSTR Command, /*[in]*/ BSTR Directory, /*[in]*/ BSTR Parameters, /*[in]*/ BSTR WindowState) = 0;

        /*Given the context update the paste button.*/
        STDMETHOD(UpdatePasteButton)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie) = 0;

        /*Findout if current selection context can allow given dataobject to be pasted.*/
        STDMETHOD(QueryPaste)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie, /*[in]*/ IDataObject *pDataObject, /*[out]*/bool& bPasteAllowed, /*[out]*/ bool& bCopyOperatationIsDefault) = 0;

        /*Findout if current selection context can allow given dataobject to be pasted.*/
        STDMETHOD(QueryPasteFromClipboard)(/*[in]*/ HNODE hNode, /*[in]*/ BOOL bScope, /*[in]*/ LPARAM lCookie, /*[out]*/bool& bPasteAllowed) = 0;

        /*Given the current drop target (or paste target) context paste the given data object or the one from clipboard*/
        STDMETHOD(Drop) (/*[in]*/HNODE hNode, /*[in]*/BOOL bScope, /*[in]*/LPARAM lCookie, /*[in]*/IDataObject *pDataObjectToPaste, /*[in]*/BOOL bIsDragOperationMove) = 0;

        /*Given the current drop target (or paste target) context paste the given data object or the one from clipboard*/
        STDMETHOD(Paste) (/*[in]*/HNODE hNode, /*[in]*/BOOL bScope, /*[in]*/LPARAM lCookie) = 0;

        /*Get the IPersistStream of the CViewSettingsPersistor object for loading the settings.*/
        STDMETHOD(QueryViewSettingsPersistor) (/*[out]*/IPersistStream** ppStream) = 0;

        /*Get the IXMLObject of the CViewSettingsPersistor object for storing/loading the settings.*/
        STDMETHOD(QueryViewSettingsPersistor) (/*[out]*/CXMLObject** ppXMLObject) = 0;

        /*Inform nodemgr that the document is closing, do any cleanups.*/
        STDMETHOD(DocumentClosing) () = 0;

        // Given the node get the snapin name
        STDMETHOD(GetSnapinName)(/*[in]*/HNODE hNode, /*[out]*/LPOLESTR* ppszName,  /*[out]*/ bool& bValidName) = 0;

        // Given the node see if it is dummy snapin
        STDMETHOD(IsDummySnapin)(/*[in]*/HNODE hNode, /*[out]*/bool& bDummySnapin) = 0;

        // See if the snapin supports MMC1.0 version of help (MMCN_SNAPINHELP)
        STDMETHOD(DoesStandardSnapinHelpExist)(/*[in]*/HNODE hNode, /*[out]*/bool& bStandardHelpExists) = 0;
    };




    // helpstring("IControlbarsCache Interface"),
    MMC_INTERFACE(IControlbarsCache, 2e9fcd38-b9a0-11d0-a79d-00c04fd8d565) : IUnknown
    {
        /*[helpstring("Detaches all the controlbars.")]*/
        STDMETHOD(DetachControlbars)()  = 0;

    };


typedef enum _EXTESION_TYPE
{
    EXTESION_NAMESPACE       = 0x1,
    EXTESION_CONTEXTMENU     = 0x2,
    EXTESION_TOOLBAR         = 0x3,
    EXTESION_PROPERTYSHEET   = 0x4,

} EXTESION_TYPE;




// helpstring("INodeType Interface"),
MMC_INTERFACE(INodeType, B08A8368-967F-11D0-A799-00C04FD8D565) : IUnknown
{
    STDMETHOD(GetNodeTypeID)(/*[out]*/ GUID* pGUID)  = 0;

    STDMETHOD(AddExtension)(/*[in]*/ GUID guidSnapIn,
                         /*[in]*/ EXTESION_TYPE extnType)  = 0;

    STDMETHOD(RemoveExtension)(/*[in]*/ GUID guidSnapIn,
                            /*[in]*/ EXTESION_TYPE extnType)  = 0;

    STDMETHOD(EnumExtensions)(/*[in]*/ EXTESION_TYPE extnType,
                           /*[out]*/ IEnumGUID** ppEnumGUID)  = 0;
};




// helpstring("INodeTypesCache Interface"),
MMC_INTERFACE(INodeTypesCache, DE40436E-9671-11D0-A799-00C04FD8D565) : IUnknown
{
    STDMETHOD(CreateNodeType)(/*[in]*/ GUID guidNodeType,
                           /*[out]*/ INodeType** ppNodeType)  = 0;

    STDMETHOD(DeleteNodeType)(/*[in]*/ GUID guidNodeType)  = 0;

    STDMETHOD(EnumNodeTypes)(/*[out]*/ IEnumNodeTypes** ppEnumNodeTypes)  = 0;
};




MMC_INTERFACE(IEnumNodeTypes, ABBD61E6-9686-11D0-A799-00C04FD8D565) : IUnknown
{
    STDMETHOD(Next)(/*[in]*/ ULONG celt,
                 /*[out, size_is(celt), length_is(*pceltFetched)]*/ INodeType*** rgelt,
                 /*[out]*/ ULONG *pceltFetched)  = 0;

    STDMETHOD(Skip)(/*[in]*/ ULONG celt)  = 0;

    STDMETHOD(Reset)()  = 0;

    STDMETHOD(Clone)(/*[out]*/ IEnumNodeTypes **ppenum)  = 0;
};


class CBasicSnapinInfo
{
public:
	CBasicSnapinInfo() : m_clsid(GUID_NULL), m_nImageIndex(-1) {}

public:
	CLSID			m_clsid;
	std::wstring	m_strName;
	int				m_nImageIndex;
};

class CAvailableSnapinInfo
{
public:
	CAvailableSnapinInfo (bool f32Bit) : m_cTotalSnapins(0), m_himl(NULL), m_f32Bit(f32Bit) {}

   ~CAvailableSnapinInfo()
	{
		if (m_himl != NULL)
			ImageList_Destroy (m_himl);
	}

public:
	std::vector<CBasicSnapinInfo>	m_vAvailableSnapins;	// snap-ins that are available in the requested memory model
	UINT							m_cTotalSnapins;		// total number of snap-ins referenced in the console file
	HIMAGELIST						m_himl;					// images for snap-ins in m_vAvailableSnapins
	const bool						m_f32Bit;				// check 32-bit (vs. 64-bit) snap-ins?
};

// helpstring("IDumpSnapins Interface"),
MMC_INTERFACE(IDumpSnapins, A16496D0-1D2F-11d3-AEB8-00C04F8ECD78) : IUnknown
{
	STDMETHOD(Dump)(/*[in]*/ LPCTSTR pszDumpFilePath)  = 0;

	STDMETHOD(CheckSnapinAvailability)(/*[in/out]*/ CAvailableSnapinInfo& asi) = 0;
};


MMC_INTERFACE(IPropertySheetProviderPrivate, FEF554F8-A55A-11D0-A7D7-00C04FD909DD) : IPropertySheetProvider
{
    STDMETHOD(ShowEx)(/*[in]*/ HWND hwnd, /*[in]*/ int page, /*[in]*/ BOOL bModalPage)  = 0;

    STDMETHOD(CreatePropertySheetEx)(
        /*[in]*/ LPCWSTR title,
        /*[in]*/ boolean type,
        /*[in]*/ MMC_COOKIE cookie,
        /*[in]*/ LPDATAOBJECT pIDataObject,
        /*[in]*/ LONG_PTR lpMasterTreeNode,
        /*[in]*/ DWORD dwOptions)  = 0;

    /*[helpstring("Collects the pages from the extension snap-in(s)")]*/
    STDMETHOD(AddMultiSelectionExtensionPages)(LONG_PTR lMultiSelection)  = 0;

    /*[helpstring("Determine if the property sheet exist")]*/
    STDMETHOD(FindPropertySheetEx)(/*[in]*/ MMC_COOKIE cookie, /*[in]*/ LPCOMPONENT lpComponent,
                              /*[in]*/ LPCOMPONENTDATA lpComponentData, /*[in]*/ LPDATAOBJECT lpDataObject)  = 0;

    /*[helpstring("Set data required for property sheet tooltips")]*/
    STDMETHOD(SetPropertySheetData)(/*[in]*/ INT nPropSheetType, /*[in]*/ HMTNODE hMTNode)  = 0;
};


const long CCLV_HEADERPAD = 25;



// helpstring("MMC Default listview interface"),
MMC_INTERFACE(IMMCListView, 1B3C1392-D68B-11CF-8C2B-00AA003CA9F6) : IUnknown
{
    STDMETHOD(GetListStyle)( void )  = 0;

    STDMETHOD(SetListStyle)(
        /*[in]*/    long        nNewValue )  = 0;

    STDMETHOD(GetViewMode)( void )  = 0;

    STDMETHOD(SetViewMode)(
        /*[in]*/    long        nViewMode )  = 0;

    STDMETHOD(InsertItem)(
        /*[in]*/    LPOLESTR    str,
        /*[in]*/    long        iconNdx,
        /*[in]*/    LPARAM      lParam,
        /*[in]*/    long        state,
        /*[in]*/    long        ownerID,
        /*[in]*/    long        itemIndex,
        /*[out]*/   CResultItem*& pri) = 0;

    /* parameter changed to HRESULTITEM, not to use the CResultItem*
       pointer until we know it is not a virtual list  */
    STDMETHOD(DeleteItem)(
        /*[in]*/    HRESULTITEM  itemID,
        /*[in]*/    long        nCol)  = 0;

    STDMETHOD(FindItemByLParam)(
        /*[in]*/    long        owner,
        /*[in]*/    LPARAM      lParam,
        /*[out]*/   CResultItem*& pri)  = 0;

    STDMETHOD(InsertColumn)(
        /*[in]*/    int         nCol,
        /*[in]*/    LPCOLESTR   str,
        /*[in]*/    long        nFormat,
        /*[in]*/    long        width)  = 0;

    STDMETHOD(DeleteColumn)(
        /*[in]*/    int         nCol)  = 0;

    STDMETHOD(DeleteAllItems)(
        /*[in]*/    long        ownerID)  = 0;

    STDMETHOD(SetColumn)(
        /*[in]*/    long        nCol,
        /*[in]*/    LPCOLESTR   str,
        /*[in]*/    long        nFormat,
        /*[in]*/    long        width)  = 0;

    STDMETHOD(GetColumn)(
        /*[in]*/    long        nCol,
        /*[out]*/   LPOLESTR*   str,
        /*[out]*/   long*       nFormat,
        /*[out]*/   int*        width)  = 0;

    STDMETHOD(GetColumnCount)(
        /*[out]*/   int*        nColCnt)  = 0;

    STDMETHOD(SetItem)(
        /*[in]*/    int         nIndex,
        /*[in]*/    CResultItem*  pri,
        /*[in]*/    long        nCol,
        /*[in]*/    LPOLESTR    str,
        /*[in]*/    long        nImage,
        /*[in]*/    LPARAM      lParam,
        /*[in]*/    long        nState,
        /*[in]*/    long        ownerID)  = 0;

    STDMETHOD(GetItem)(
        /*[in]*/    int         nIndex,
        /*[in]*/    CResultItem*& pri,
        /*[in]*/    long        nCol,
        /*[out]*/   LPOLESTR*   str,
        /*[out]*/   int*        nImage,
        /*[in]*/    LPARAM*     lParam,
        /*[out]*/   unsigned int* nState,
        /*[out]*/   BOOL*       pbScopeItem)  = 0;

    STDMETHOD(GetNextItem)(
        /*[in]*/    COMPONENTID ownerID,
        /*[in]*/    long        nIndex,
        /*[in]*/    UINT        nState,
        /*[out]*/   CResultItem*& ppListItem,
        /*[out]*/   long&       nIndexNextItem)  = 0;

    STDMETHOD(GetLParam)(
        /*[in]*/    long        nItem,
        /*[out]*/   CResultItem*& pri)  = 0;

    STDMETHOD(ModifyItemState)(
        /*[in]*/    long        nItem,
        /*[in]*/    CResultItem*  pri,
        /*[in]*/    UINT        add,
        /*[in]*/    UINT        remove)  = 0;

    STDMETHOD(SetIcon)(
        /*[in]*/    long        nID,
        /*[in]*/    HICON       hIcon,
        /*[in]*/    long        nLoc)  = 0;

    STDMETHOD(SetImageStrip)(
        /*[in]*/    long        nID,
        /*[in]*/    HBITMAP     hbmSmall,
        /*[in]*/    HBITMAP     hbmLarge,
        /*[in]*/    long        nStartLoc,
        /*[in]*/    long        cMask) = 0;

    STDMETHOD(MapImage)(
        /*[in]*/    long        nID,
        /*[in]*/    long        nLoc,
        /*[out]*/   int*        pResult)  = 0;

    STDMETHOD(Reset)()  = 0;

    STDMETHOD(Arrange)(/*[in]*/ long style)  = 0;

    STDMETHOD(UpdateItem)(/*[in]*/HRESULTITEM itemID)  = 0;

    STDMETHOD(Sort)(
        /*[in]*/    LPARAM      lUserParam,
        /*[in]*/    long*       pParams)  = 0;


    STDMETHOD(SetItemCount)(
        /*[in]*/    int         nItemCount,
        /*[in]*/    DWORD       dwOptions)  = 0;

    STDMETHOD(SetVirtualMode)(
        /*[in]*/    BOOL        bVirtual)  = 0;

    STDMETHOD(Repaint)(
        /*[in]*/    BOOL        bErase)  = 0;

    STDMETHOD(SetChangeTimeOut)(
        /*[in]*/    ULONG        lTimeout)  = 0;

    STDMETHOD(SetColumnFilter)(
        /*[in]*/    int             nCol,
        /*[in]*/    DWORD           dwType,
        /*[in]*/    MMC_FILTERDATA* pFilterData)  = 0;

    STDMETHOD(GetColumnFilter)(
        /*[in]*/     int             nCol,
        /*[in,out]*/ DWORD*          dwType,
        /*[in,out]*/ MMC_FILTERDATA* pFilterData)  = 0;

    STDMETHOD(SetColumnSortIcon)(
        /*[in]*/     int             nNewCol,
        /*[in]*/     int             nOldCol,
        /*[in]*/     BOOL            bAscending,
        /*[in]*/     BOOL            bSetSortIcon)  = 0;

    STDMETHOD(SetLoadMode)(
        /*[in]*/    BOOL        bState)  = 0;

    /*[helpstring("Get the current list view header settings.")]*/
    STDMETHOD(GetColumnInfoList) (/*[out]*/CColumnInfoList *pColumnsList) = 0;

    /*[helpstring("Modify the list-view headers with given data.")]*/
    STDMETHOD(ModifyColumns) (/*[in]*/const CColumnInfoList& columnsList) = 0;

    /* Put the specified list item into rename mode */
    STDMETHOD(RenameItem) ( /*[in]*/HRESULTITEM itemID)  =0;

    /*[helpstring("Get the column settings that snapin supplied originally")]*/
    STDMETHOD(GetDefaultColumnInfoList)(/*[out]*/ CColumnInfoList& columnsList) = 0;
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////            MMC 1.1 changes
////

// MMC_ITASK, internal form of MMC_TASK has additional field for classid.
struct MMC_ITASK
{
    MMC_TASK task;
    LPOLESTR szClsid;
};



    // helpstring("Console <=> CIC communication conduit"),
    MMC_INTERFACE(ITaskPadHost, 4f7606d0-5568-11d1-9fea-00600832db4a) : IUnknown
    {
        /*[helpstring("CIC calls this when snapin's script wants to notify the snapin of something")]*/
        STDMETHOD(TaskNotify)(/*[in,string]*/ BSTR szClsid, /*[in]*/ VARIANT * pvArg, /*[in]*/ VARIANT * pvParam)  = 0;

        /*[helpstring("CIC calls this when the script asks for tasks")]*/
        STDMETHOD(GetTaskEnumerator)(/*[in]*/ BSTR szTaskGroup, /*[out]*/ IEnumTASK** ppEnumTASK)  = 0;

        /*[helpstring("Returns the primary snapins IExtendTaskPad")]*/
        STDMETHOD(GetPrimaryTask)(/*[out]*/ IExtendTaskPad** ppExtendTaskPad)  = 0;

        /*[helpstring("Returns the primary snapin's taskpad title")]*/
        STDMETHOD(GetTitle)(/*[in]*/ BSTR szTaskGroup, /*[out]*/ BSTR * szTitle)  = 0;

        /*[helpstring("Descriptive Text for the default task pad.")]*/
        STDMETHOD(GetDescriptiveText)(/*[in,string]*/ BSTR pszGroup, /*[out]*/ BSTR * pszDescriptiveText)  = 0;

        /*[helpstring("Returns the primary snapin's taskpad background image.")]*/
        STDMETHOD(GetBackground)(/*[in]*/ BSTR szTaskGroup, /*[out]*/ MMC_TASK_DISPLAY_OBJECT * pTDO)  = 0;

//      /*[helpstring("Returns the primary snapin's taskpad branding info.")]*/
//      STDMETHOD(GetBranding)(/*[in,string]*/ BSTR szGroup, /*[out]*/ MMC_TASK_DISPLAY_OBJECT * pTDO)  = 0;

        /*[helpstring("Returns the primary snapin's listpad info")]*/
        STDMETHOD(GetListPadInfo)(/*[in]*/ BSTR szTaskGroup, /*[out]*/ MMC_ILISTPAD_INFO * pIListPadInfo)  = 0;
    };



    // helpstring("Interface for accessing strings in a console file"),
    MMC_INTERFACE(IStringTablePrivate, 461A6010-0F9E-11d2-A6A1-0000F875A9CE) : IUnknown
    {
        /*[helpstring("Add a string to the snap-in's string table")]*/
        STDMETHOD(AddString)(
            /*[in]*/  LPCOLESTR      pszAdd,    // string to add to the string table
            /*[out]*/ MMC_STRING_ID* pStringID, // ID of added string
            /*[in]*/  const CLSID *  pCLSID     // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Retrieves a string from the snap-in's string table")]*/
        STDMETHOD(GetString)(
            /*[in]*/  MMC_STRING_ID StringID,   // ID of string
            /*[in]*/  ULONG         cchBuffer,  // number of characters in lpBuffer
            /*[out, size_is(cchBuffer)]*/
                  LPOLESTR      lpBuffer,   // string corresponding to wStringID
            /*[out]*/ ULONG*        pcchOut,    // number of characters written to lpBuffer
            /*[in]*/  const CLSID * pCLSID      // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Retrieves the length of a string in the snap-in's string table")]*/
        STDMETHOD(GetStringLength)(
            /*[in]*/  MMC_STRING_ID StringID,   // ID of string
            /*[out]*/ ULONG*        pcchString, // number of characters in string, not including terminator
            /*[in]*/  const CLSID * pCLSID      // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Delete a string from the snap-in's string table")]*/
        STDMETHOD(DeleteString)(
            /*[in]*/  MMC_STRING_ID StringID,   // ID of string to delete
            /*[in]*/  const CLSID * pCLSID      // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Delete all strings from the snap-in's string table")]*/
        STDMETHOD(DeleteAllStrings)(
            /*[in]*/  const CLSID * pCLSID      // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Find a string in the snap-in's string table")]*/
        STDMETHOD(FindString)(
            /*[in]*/  LPCOLESTR      pszFind,   // string to find in the string table
            /*[out]*/ MMC_STRING_ID* pStringID, // ID of string, if found
            /*[in]*/  const CLSID *  pCLSID     // CLSID of owner (NULL for MMC)
        )  = 0;

        /*[helpstring("Returns an enumerator into a snap-in's string table")]*/
        STDMETHOD(Enumerate)(
            /*[out]*/ IEnumString** ppEnum,     // string enumerator
            /*[in]*/  const CLSID * pCLSID      // CLSID of owner (NULL for MMC)
        )  = 0;
    };



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////            MMC 1.2 changes
////

// ITaskCallback

// helpstring("Task callback. Handles the drawing and selection notifications of tasks"),
MMC_INTERFACE(ITaskCallback, 4b2293ba-e7ba-11d2-883c-00c04f72c717) : IUnknown
{
    /*[helpstring("Determines whether to display "Edit" and "Delete" items for this taskpad.")]*/
    STDMETHOD(IsEditable)()  = 0;

    /*[helpstring("Modifies the underlying taskpad.")]*/
    STDMETHOD(OnModifyTaskpad)()  = 0;

    /*[helpstring("Deletes the underlying taskpad.")]*/
    STDMETHOD(OnDeleteTaskpad)()  = 0;

    /*[helpstring("Gets the GUID identifier of the underlying taskpad.")]*/
    STDMETHOD(GetTaskpadID)(/*[out]*/ GUID *pGuid)  = 0;
};

// helpstring("Interface for releasing Node Manager's cached com objects"),
MMC_INTERFACE(IComCacheCleanup, 35FEB982-55E9-483b-BD15-149F3F9E6C63) : IUnknown
{
    /* gives a chance to release cached OLE objects prior to calling OleUninitialize */
    STDMETHOD(ReleaseCachedOleObjects)()  = 0;
};

#endif // __ndmgrpriv_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\pickicon.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      pickicon.h
 *
 *  Contents:  Interface file for PickIconDlg (copied from shell)
 *
 *  History:   13-Jun-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

MMCBASE_API INT_PTR PASCAL
PickIconDlg(HWND hwnd, LPTSTR pszIconPath, UINT cbIconPath, int *piIconIndex);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\observer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       observer.h
//
//--------------------------------------------------------------------------

#ifndef _OBSERVER_H_
#define _OBSERVER_H_

#include <vector>

// Event source interface template
// Defines event source class for specific observer class 
template <class Observer>
    class EventSource
    {
    public:
        STDMETHOD(Advise)(Observer* pObserver, LONG_PTR* pCookie) = 0;
        STDMETHOD(Unadvise)(LONG_PTR Cookie) = 0;
    };

// Event source implementation template
// Defines implementation of event source for a specific observer class
// maintains a vector of the active observers of this event source       
template <class Observer>
class ATL_NO_VTABLE EventSourceImpl : EventSource<Observer>
{
    typedef std::list<Observer*> ObserverList;
    typedef std::list<Observer*>::iterator ObserverIter;
     
    public:
        STDMETHOD(Advise)(Observer* pObserver, LONG_PTR* plCookie);
        STDMETHOD(Unadvise)(LONG_PTR lCookie);
            
    protected:
        ~EventSourceImpl() 
        {
            // verify there are no obervers when going away
            ASSERT(m_Observers.empty()); 
        }

        ObserverList  m_Observers;
};

template <class Observer>
    STDMETHODIMP EventSourceImpl<Observer>::Advise(Observer* pObserver, LONG_PTR* plCookie)
    {
        ASSERT(pObserver != NULL);
        ASSERT(plCookie != NULL);

        ObserverIter iter = m_Observers.insert(m_Observers.end(), pObserver);

	    // can't cast iterator to LONG_PTR so check size before cheating
	    ASSERT(sizeof(ObserverIter) == sizeof(LONG_PTR));
		*(ObserverIter*)plCookie = iter;

        return S_OK;
    }

template <class Observer>
    STDMETHODIMP EventSourceImpl<Observer>::Unadvise(LONG_PTR lCookie)
    {
		// Can't cast LONG_PTR to iterator, so have to cheat 
		// see Advise method for size check
	    ObserverIter iter;
		*(LONG_PTR*)&iter = lCookie;

        m_Observers.erase(iter);
        return S_OK;
    }

// Observer enumerator helper
// Provides for-loop header for iterating over observers of a specified observer class  
#define FOR_EACH_OBSERVER(ObserverClass, ObserverIter) \
for ( \
    std::list<ObserverClass*>::iterator ObserverIter = EventSourceImpl<ObserverClass>::m_Observers.begin(); \
    ObserverIter != EventSourceImpl<ObserverClass>::m_Observers.end(); \
    ++ObserverIter \
    )
     
#endif // _OBSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\objmodelptrs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       objmodelptrs.h
//
//--------------------------------------------------------------------------

#pragma once

#ifndef OBJMODELPTRS_H
#define OBJMODELPTRS_H

DEFINE_COM_SMARTPTR(_Application);      // _ApplicationPtr
DEFINE_COM_SMARTPTR(Document);          // DocumentPtr
DEFINE_COM_SMARTPTR(Column);            // Column
DEFINE_COM_SMARTPTR(Columns);           // Columns
DEFINE_COM_SMARTPTR(ContextMenu);       // ContextMenuPtr
DEFINE_COM_SMARTPTR(Frame);             // FramePtr
DEFINE_COM_SMARTPTR(MenuItem);          // MenuItemPtr
DEFINE_COM_SMARTPTR(Node);              // NodePtr
DEFINE_COM_SMARTPTR(Nodes);             // NodesPtr
DEFINE_COM_SMARTPTR(Properties);        // PropertiesPtr
DEFINE_COM_SMARTPTR(Property);          // PropertyPtr
DEFINE_COM_SMARTPTR(ScopeNamespace);    // ScopeNamespacePtr
DEFINE_COM_SMARTPTR(SnapIn);            // SnapInPtr
DEFINE_COM_SMARTPTR(SnapIns);           // SnapInsPtr
DEFINE_COM_SMARTPTR(View);              // ViewPtr
DEFINE_COM_SMARTPTR(Views);             // ViewsPtr
DEFINE_COM_SMARTPTR(Extension);         // ExtensionPtr
DEFINE_COM_SMARTPTR(Extensions);        // ExtensionsPtr


#endif // OBJMODELPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\pushwarn.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       pushwarn.h
 *
 *  Contents:   This file pushes the current compiler's warning state on
 *              the stack, if the compiler supports it.
 * 
 *              popwarn.h is the complement to this file.
 *
 *  History:    17-Nov-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#if (_MSC_VER >= 1200)
#pragma warning (push)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\popwarn.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:       popwarn.h
 *
 *  Contents:   This file pops the current compiler's warning state from
 *              the stack, if the compiler supports it.
 * 
 *              pushwarn.h is the complement to this file.
 *
 *  History:    17-Nov-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#if (_MSC_VER >= 1200)
#pragma warning (pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\refcount.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      refcount.h
 *
 *  Contents:  Interface file for reference counting templates
 *
 *  History:   05-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef REFCOUNT_H
#define REFCOUNT_H
#pragma once

#include "stddbg.h"


template<class T> class CRefCountedObject;
template<class T> class CRefCountedPtr;


/*+-------------------------------------------------------------------------*
 * CRefCountedObject
 *
 * Template reference-counted object class, intended to be used in
 * conjuction with CRefCountedPtr<T>.
 *
 * Typically, you'd use this like so:
 *
 *      class CClassWithoutRefCounting;
 *      typedef CRefCountedObject<CClassWithoutRefCounting> CClassWithRefCounting;
 *
 *      CClassWithRefCounting::SmartPtr m_spClass;
 *      m_spClass.CreateInstance ();
 *--------------------------------------------------------------------------*/

template<class BaseClass>
class CRefCountedObject : public BaseClass
{
public:
    typedef CRefCountedObject<BaseClass>    ThisClass;
    typedef CRefCountedPtr<ThisClass>       SmartPtr;

    CRefCountedObject () : m_cRefs (0) {}

private:
    /*
     * CRefCountedObject's should only be created on the heap,
     * so we'll protect the dtor so it can only be deleted from
     * Release, not by automatic object unwinding
     */
    ~CRefCountedObject () {}

public:
    static ThisClass* CreateInstance ()
    {
        return (new ThisClass);
    }

    LONG AddRef()
    {
        return (InterlockedIncrement (&m_cRefs));
    }

    LONG Release()
    {
        /*
         * if this assert fails, we have mismatched AddRef/Release's
         */
        ASSERT (m_cRefs > 0);

        LONG rc = InterlockedDecrement (&m_cRefs);

        if (rc == 0)
            delete this;

        return (rc);
    }

    LONG m_cRefs;

private:
    /*
     * CRefCountedObject's are not meant to be copied or assigned
     */
    CRefCountedObject (const CRefCountedObject& other);             // no impl
    CRefCountedObject& operator= (const CRefCountedObject& other);  // no impl
};


/*+-------------------------------------------------------------------------*
 * CRefCountedPtr
 *
 * Template reference-counted smart pointer class, intended to be used in
 * conjuction with CRefCountedObject<T>.
 *
 * T must implement CreateInstance, AddRef and Release.  It can do this
 * intrisically, or use the implementation in CRefCountedObject like this:
 *
 *      class CClassWithoutRefCounting;
 *      typedef CRefCountedObject<CClassWithoutRefCounting> CClassWithRefCounting;
 *--------------------------------------------------------------------------*/

template<class T>
class CRefCountedPtr
{
public:
    CRefCountedPtr (T* pRealObject = NULL) :
        m_pRealObject (pRealObject)
    {
        SafeAddRef();
    }

    CRefCountedPtr (const CRefCountedPtr<T>& other) :
        m_pRealObject (other.m_pRealObject)
    {
        SafeAddRef();
    }

    ~CRefCountedPtr ()
    {
        SafeRelease();
    }

    T* operator->() const
    {
        return (m_pRealObject);
    }

    operator T*() const
    {
        return (m_pRealObject);
    }

    T& operator*() const
    {
        return (*m_pRealObject);
    }

    T** operator&()
    {
        ASSERT (m_pRealObject == NULL);
        return (&m_pRealObject);
    }

    CRefCountedPtr<T>& operator= (const CRefCountedPtr<T>& other)
    {
        return (operator= (other.m_pRealObject));
    }

    CRefCountedPtr<T>& operator= (T* pOtherObject)
    {
        if (pOtherObject != m_pRealObject)
        {
            T* pOldObject = m_pRealObject;
            m_pRealObject = pOtherObject;
            SafeAddRef();

            if (pOldObject != NULL)
                pOldObject->Release();
        }

        return (*this);
    }

    bool CreateInstance()
    {
        SafeRelease();
        m_pRealObject = T::CreateInstance();
        if (m_pRealObject == NULL)
            return (false);

        m_pRealObject->AddRef();
        return (true);
    }

    LONG AddRef()
    {
        return (SafeAddRef());
    }

    LONG Release()
    {
        LONG cRefs = SafeRelease();
        m_pRealObject = NULL;
        return (cRefs);
    }

    void Attach(T* pNewObject)
    {
        if (pNewObject != m_pRealObject)
        {
            SafeRelease();
            m_pRealObject = pNewObject;
        }
    }

    T* Detach()
    {
        T* pOldObject = m_pRealObject;
        m_pRealObject = NULL;
        return (pOldObject);
    }

    bool operator!() const
    {
        return (m_pRealObject == NULL);
    }

    bool operator==(const CRefCountedPtr<T>& other)
    {
        return (m_pRealObject == other.m_pRealObject);
    }

    bool operator!=(const CRefCountedPtr<T>& other)
    {
        return (m_pRealObject != other.m_pRealObject);
    }

    /*
     * for comparison to NULL
     */
    bool operator==(int null) const
    {
        ASSERT (null == 0);
        return (m_pRealObject == NULL);
    }

    bool operator!=(int null) const
    {
        ASSERT (null == 0);
        return (m_pRealObject != NULL);
    }


protected:
    LONG SafeAddRef ()
    {
        return ((m_pRealObject) ? m_pRealObject->AddRef() : 0);
    }

    LONG SafeRelease ()
    {
        return ((m_pRealObject) ? m_pRealObject->Release() : -1);
    }


protected:
    T*  m_pRealObject;

};


#endif /* REFCOUNT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\rsltitem.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      rsltitem.h
 *
 *  Contents:  Interface file for CResultItem
 *
 *  History:   13-Dec-1999 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once
#ifndef RSLTITEM_H_INCLUDED
#define RSLTITEM_H_INCLUDED


/*+-------------------------------------------------------------------------*
 * CResultItem
 *
 * This is the class behind the HRESULTITEM.  A pointer to this class is
 * stored as the item data for each item in a non-virtual list.
 *--------------------------------------------------------------------------*/

class CResultItem
{
public:
    CResultItem (COMPONENTID id, LPARAM lSnapinData, int nImage);

    bool        IsScopeItem   () const;
    COMPONENTID GetOwnerID    () const;
    LPARAM      GetSnapinData () const;
    int         GetImageIndex () const;
    HNODE       GetScopeNode  () const;

    void SetSnapinData (LPARAM lSnapinData);
    void SetImageIndex (int nImage);

    static HRESULTITEM  ToHandle (const CResultItem* pri);
    static CResultItem* FromHandle (HRESULTITEM hri);

private:
    const COMPONENTID   m_id;
    int                 m_nImage;

    union
    {
        HNODE           m_hNode;        // if IsScopeItem() == true
        LPARAM          m_lSnapinData;  // if IsScopeItem() == false
    };

#ifdef DBG
    enum { Signature = 0x746c7372 /* "rslt" */ };
    const DWORD         m_dwSignature;
#endif
};


/*+-------------------------------------------------------------------------*
 * CResultItem::CResultItem
 *
 * Constructs a CResultItem.
 *--------------------------------------------------------------------------*/

inline CResultItem::CResultItem (
    COMPONENTID id,
    LPARAM      lSnapinData,
    int         nImage) :
#ifdef DBG
        m_dwSignature (Signature),
#endif
        m_id          (id),
        m_lSnapinData (lSnapinData),
        m_nImage      (nImage)
{}


/*+-------------------------------------------------------------------------*
 * CResultItem::IsScopeItem
 *
 * Returns true if this CResultItem represents a scope item, false otherwise.
 *--------------------------------------------------------------------------*/

inline bool CResultItem::IsScopeItem () const
{
    return (m_id == TVOWNED_MAGICWORD);
}


/*+-------------------------------------------------------------------------*
 * CResultItem::GetOwnerID
 *
 * Returns the COMPONENTID for the componenet that owns this CResultItem.
 *--------------------------------------------------------------------------*/

inline COMPONENTID CResultItem::GetOwnerID () const
{
    return (m_id);
}


/*+-------------------------------------------------------------------------*
 * CResultItem::GetSnapinData
 *
 * Returns the snap-in's LPARAM for this CResultItem.
 *--------------------------------------------------------------------------*/

inline LPARAM CResultItem::GetSnapinData () const
{
    return (m_lSnapinData);
}


/*+-------------------------------------------------------------------------*
 * CResultItem::GetScopeNode
 *
 * Returns the HNODE for a CResultItem that represents a scope node.  If the
 * CResultItem does not represent a scope node, NULL is returned.
 *--------------------------------------------------------------------------*/

inline HNODE CResultItem::GetScopeNode () const
{
    return (IsScopeItem() ? m_hNode : NULL);
}


/*+-------------------------------------------------------------------------*
 * CResultItem::GetImageIndex
 *
 * Returns the image index for a CResultItem.
 *--------------------------------------------------------------------------*/

inline int CResultItem::GetImageIndex () const
{
    return (m_nImage);
}


/*+-------------------------------------------------------------------------*
 * CResultItem::SetSnapinData
 *
 * Sets the snap-in's LPARAM for the CResultItem.
 *--------------------------------------------------------------------------*/

inline void CResultItem::SetSnapinData (LPARAM lSnapinData)
{
    m_lSnapinData = lSnapinData;
}


/*+-------------------------------------------------------------------------*
 * CResultItem::SetImageIndex
 *
 * Sets the image index for a CResultItem.
 *--------------------------------------------------------------------------*/

inline void CResultItem::SetImageIndex (int nImage)
{
    m_nImage = nImage;
}


/*+-------------------------------------------------------------------------*
 * CResultItem::ToHandle
 *
 * Converts a CResultItem to a HRESULTITEM.
 *--------------------------------------------------------------------------*/

inline HRESULTITEM CResultItem::ToHandle (const CResultItem* pri)
{
    return (reinterpret_cast<HRESULTITEM>(const_cast<CResultItem*>(pri)));
}


/*+-------------------------------------------------------------------------*
 * CResultItem::FromHandle
 *
 * Converts a HRESULTITEM to a CResultItem*.  This function cannot use
 * dynamic_cast because there are no virtual functions and therefore no
 * place to store RTTI.
 *--------------------------------------------------------------------------*/

inline CResultItem* CResultItem::FromHandle (HRESULTITEM hri)
{
    if ((hri == NULL) || IS_SPECIAL_LVDATA (hri))
        return (NULL);

    CResultItem* pri = reinterpret_cast<CResultItem*>(hri);

    ASSERT (pri->m_dwSignature == Signature);
    return (pri);
}


#endif /* RSLTITEM_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\resultview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       ResultViewInfo.h
//
//  History:    Jan-18-2000 VivekJ Added
//--------------------------------------------------------------------------
#ifndef _RESULTVIEW_H
#define _RESULTVIEW_H

/*+-------------------------------------------------------------------------*
 * class CResultViewType
 *
 *
 * PURPOSE: Provides a wrapper for the RESULT_VIEW_TYPE_INFO structure, and
 *          is used for communication between conui and nodemgr.
 *
 *+-------------------------------------------------------------------------*/
class CResultViewType : public CXMLObject
{
    typedef std::wstring wstring; // only wide strings are needed here.

protected:
    virtual void Persist(CPersistor &persistor);

    DEFINE_XML_TYPE(XML_TAG_RESULTVIEWTYPE);

public:
    CResultViewType();
    CResultViewType &   operator =(RESULT_VIEW_TYPE_INFO &rvti); // conversion from a RESULT_VIEW_TYPE_INFO structure

    bool operator != (const CResultViewType& rvt) const;

    // the default copy constructor and assignment operators are sufficient

    MMC_VIEW_TYPE   GetType()        const  {return m_viewType;}
    DWORD           GetListOptions() const  {return m_dwListOptions;}
    DWORD           GetHTMLOptions() const  {return m_dwHTMLOptions;}
    DWORD           GetOCXOptions()  const  {return m_dwOCXOptions;}
    DWORD           GetMiscOptions() const  {return m_dwMiscOptions;}

    BOOL            HasList()        const  {return (m_viewType==MMC_VIEW_TYPE_LIST);}
    BOOL            HasWebBrowser()  const  {return (m_viewType==MMC_VIEW_TYPE_HTML);}
    BOOL            HasOCX()         const  {return (m_viewType==MMC_VIEW_TYPE_OCX);}

    LPCOLESTR       GetURL()         const  {return m_strURL.data();}
    LPCOLESTR       GetOCX()         const  {return m_strOCX.data();}

    LPUNKNOWN       GetOCXUnknown()  const  {return m_spUnkControl;} // returns the IUnknown of the OCX.

    bool            IsPersistableViewDescriptionValid() const {return m_bPersistableViewDescriptionValid;}
    bool            IsMMC12LegacyData()                 const {return !IsPersistableViewDescriptionValid();}

    SC              ScInitialize(LPOLESTR & pszView, long lMiscOptions); // the legacy case.
    SC              ScGetOldTypeViewOptions(long* plViewOptions) const;
    SC              ScReset();

// functions specific to nodemgr. Do NOT add any member variables in this section.
#ifdef _NODEMGR_DLL_
    SC              ScInitialize(RESULT_VIEW_TYPE_INFO &rvti);

    SC              ScGetResultViewTypeInfo(RESULT_VIEW_TYPE_INFO& rvti) const;
#endif _NODEMGR_DLL_


private:
    bool            m_bPersistableViewDescriptionValid;
    bool            m_bInitialized;

    MMC_VIEW_TYPE   m_viewType;

    wstring         m_strURL;
    wstring         m_strOCX;           // for snapins that implement IComponent only.
    wstring         m_strPersistableViewDescription;

    DWORD           m_dwMiscOptions;
    DWORD           m_dwListOptions;
    DWORD           m_dwHTMLOptions;
    DWORD           m_dwOCXOptions;

    CComPtr<IUnknown>   m_spUnkControl;     // a smart pointer for the control created by the snapin.

};

inline CResultViewType::CResultViewType()
:
  m_viewType(MMC_VIEW_TYPE_LIST), // the default view type
  m_dwMiscOptions(0),
  m_dwListOptions(0),
  m_dwHTMLOptions(0),
  m_dwOCXOptions(0),
  m_bPersistableViewDescriptionValid(false),
  m_bInitialized(false)
{
}

//+-------------------------------------------------------------------
//
//  Member:      CResultViewType::ScReset
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC CResultViewType::ScReset ()
{
    DECLARE_SC(sc, _T("CResultViewType::ScReset"));

    m_viewType         = MMC_VIEW_TYPE_LIST; // the default view type
    m_dwMiscOptions    = 0;
    m_dwListOptions    = 0;
    m_dwHTMLOptions    = 0;
    m_dwOCXOptions     = 0;

    m_bPersistableViewDescriptionValid = false;
    m_bInitialized     = false;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * CResultViewType::operator!=
 *
 * PURPOSE: Operator != (Used by CViewSettings which is used by CMemento).
 *
 * NOTE:    For MMC2 compare only persistable view desc for MMC1.2 compare all
 *          parameters.
 *
 *+-------------------------------------------------------------------------*/
inline
bool CResultViewType::operator != (const CResultViewType& rvt) const
{
    if (m_bInitialized != rvt.m_bInitialized)
        return true;

    if (m_bPersistableViewDescriptionValid)
    {
        if (m_strPersistableViewDescription != rvt.m_strPersistableViewDescription)
            return true;

        return false;
    }

    // Legacy case MMC1.2, should compare other parameters.
    switch(m_viewType)
    {
    default:
        ASSERT(FALSE && _T("Unknown view type"));
        break;

    case MMC_VIEW_TYPE_LIST:
        if ( (m_viewType != rvt.m_viewType) ||
             (m_dwMiscOptions != rvt.m_dwMiscOptions) ||
             (m_dwListOptions != rvt.m_dwListOptions) )
        {
            return true;
        }
        break;

    case MMC_VIEW_TYPE_HTML:
        if ( (m_viewType != rvt.m_viewType) ||
             (m_dwMiscOptions != rvt.m_dwMiscOptions) ||
             (m_dwHTMLOptions != rvt.m_dwHTMLOptions) ||
             (m_strURL != rvt.m_strURL) )
        {
            return true;
        }

        break;

    case MMC_VIEW_TYPE_OCX:
        if ( (m_viewType != rvt.m_viewType) ||
             (m_dwMiscOptions != rvt.m_dwMiscOptions) ||
             (m_dwOCXOptions  != rvt.m_dwOCXOptions) ||
             (m_strOCX != rvt.m_strOCX) )
        {
            return true;
        }
        break;
    }

    return false;
}

/*+-------------------------------------------------------------------------*
 *
 * CResultViewType::ScInitialize
 *
 * PURPOSE: Initializes the class from parameters returned by IComponent::
 *          GetResultViewType
 *
 * PARAMETERS:
 *    LPOLESTR  ppViewType :
 *    long      lViewOptions :
 *
 * RETURNS:
 *    SC
 *
 * NOTE:     This is for MMC1.2 compatible GetResultViewType.
 *
 *+-------------------------------------------------------------------------*/
inline
SC CResultViewType::ScInitialize(LPOLESTR & pszView, long lViewOptions)
{
    DECLARE_SC(sc, TEXT("CResultViewType::ScInitialize"));

    m_bInitialized = true;

    m_bPersistableViewDescriptionValid = false; // the legacy case - we don't have a persistable view description.

    // MMC_VIEW_OPTIONS_NOLISTVIEWS is a special case - it goes to the dwMiscOptions
    if(lViewOptions & MMC_VIEW_OPTIONS_NOLISTVIEWS)
        m_dwMiscOptions |= RVTI_MISC_OPTIONS_NOLISTVIEWS;

    // check whether the type of view is a web page or OCX.
    if ( (NULL == pszView) || (_T('\0') == pszView[0]) )
    {
        // the result pane is a standard list
        m_viewType = MMC_VIEW_TYPE_LIST;

        m_dwListOptions = 0;

        // convert the view options from the old bits to the new ones
        if(lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST)                   m_dwListOptions |= RVTI_LIST_OPTIONS_OWNERDATALIST;
        if(lViewOptions & MMC_VIEW_OPTIONS_MULTISELECT)                     m_dwListOptions |= RVTI_LIST_OPTIONS_MULTISELECT;
        if(lViewOptions & MMC_VIEW_OPTIONS_FILTERED)                        m_dwListOptions |= RVTI_LIST_OPTIONS_FILTERED;
        if(lViewOptions & MMC_VIEW_OPTIONS_USEFONTLINKING)                  m_dwListOptions |= RVTI_LIST_OPTIONS_USEFONTLINKING;
        if(lViewOptions & MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST)   m_dwListOptions |= RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST;
        if(lViewOptions & MMC_VIEW_OPTIONS_LEXICAL_SORT)                    m_dwListOptions |= RVTI_LIST_OPTIONS_LEXICAL_SORT;

    }
    else
    {
        // the result pane is a web page or an OCX.

        if (L'{' == pszView[0]) // the hacky way of ensuring that the result view is an OCX
        {
            m_viewType = MMC_VIEW_TYPE_OCX;
            m_strOCX   = pszView;

            // If the snapin says "create new" then do not "cache the ocx"
            if(!(lViewOptions & MMC_VIEW_OPTIONS_CREATENEW))   m_dwOCXOptions |= RVTI_OCX_OPTIONS_CACHE_OCX;

            if(lViewOptions & MMC_VIEW_OPTIONS_NOLISTVIEWS)    m_dwOCXOptions |= RVTI_OCX_OPTIONS_NOLISTVIEW;
        }
        else
        {
            m_viewType = MMC_VIEW_TYPE_HTML;
            m_strURL   = pszView;

            if(lViewOptions & MMC_VIEW_OPTIONS_NOLISTVIEWS)    m_dwHTMLOptions |= RVTI_HTML_OPTIONS_NOLISTVIEW;
        }
    }

    // make sure we free the allocated memory.
    if(pszView != NULL)
    {
        ::CoTaskMemFree(pszView);
        pszView = NULL; // NOTE: pszView is a reference, so this changes the in parameter.
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     CResultViewType::Persist
//
//  Synopsis:   persist to / from XML document.
//
//  Arguments:  [persistor]  - target or source.
//
//--------------------------------------------------------------------
inline
void CResultViewType::Persist(CPersistor& persistor)
{
    if ( (! m_bInitialized) &&
         (persistor.IsStoring()) )
    {
        SC sc;
        (sc = E_UNEXPECTED).Throw();
    }
    else
        m_bInitialized = true;

    if (persistor.IsLoading())
        m_bPersistableViewDescriptionValid = persistor.HasElement(XML_TAG_RESULTVIEW_DESCRIPTION, NULL);

    if (m_bPersistableViewDescriptionValid)
    {
        CPersistor persistorDesc(persistor, XML_TAG_RESULTVIEW_DESCRIPTION);
        persistorDesc.PersistContents(m_strPersistableViewDescription);
        return;
    }

    // Legacy code for MMC1.2
    {
        int &viewType = (int&) m_viewType;

        // define the table to map enumeration values to strings
        static const EnumLiteral mappedViewTypes[] =
        {
            { MMC_VIEW_TYPE_LIST,   XML_ENUM_MMC_VIEW_TYPE_LIST },
            { MMC_VIEW_TYPE_HTML,   XML_ENUM_MMC_VIEW_TYPE_HTML },
            { MMC_VIEW_TYPE_OCX,    XML_ENUM_MMC_VIEW_TYPE_OCX },
        };

        const size_t countof_types = sizeof(mappedViewTypes)/sizeof(mappedViewTypes[0]);
        // create wrapper to persist flag values as strings
        CXMLEnumeration viewTypePersistor(viewType, mappedViewTypes, countof_types );
        // persist the wrapper
        persistor.PersistAttribute(XML_ATTR_VIEW_SETTINGS_TYPE, viewTypePersistor);

        switch(m_viewType)
        {
        case MMC_VIEW_TYPE_LIST:
            {
                // define the table to map enumeration flags to strings
                static const EnumLiteral mappedLVOptions[] =
                {
                    { RVTI_LIST_OPTIONS_OWNERDATALIST,      XML_BITFLAG_LIST_OPTIONS_OWNERDATALIST },
                    { RVTI_LIST_OPTIONS_MULTISELECT,        XML_BITFLAG_LIST_OPTIONS_MULTISELECT },
                    { RVTI_LIST_OPTIONS_FILTERED,           XML_BITFLAG_LIST_OPTIONS_FILTERED },
                    { RVTI_LIST_OPTIONS_USEFONTLINKING,     XML_BITFLAG_LIST_OPTIONS_USEFONTLINKING },
                    { RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST,  XML_BITFLAG_LIST_OPTIONS_NO_SCOPE_ITEMS },
                    { RVTI_LIST_OPTIONS_LEXICAL_SORT,       XML_BITFLAG_LIST_OPTIONS_LEXICAL_SORT },
                };

                const size_t countof_options = sizeof(mappedLVOptions)/sizeof(mappedLVOptions[0]);

                // create wrapper to persist flag values as strings
                CXMLBitFlags optPersistor(m_dwListOptions, mappedLVOptions, countof_options);
                persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_OPTIONS, optPersistor);
            }
            break;

        case MMC_VIEW_TYPE_HTML:
            {
                // NOT USED - persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_OPTIONS, m_dwHTMLOptions);
                m_dwHTMLOptions = 0;
                persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_URL_STRING, m_strURL);
            }
            break;

        case MMC_VIEW_TYPE_OCX:
            {
                // define the table to map enumeration flags to strings
                static const EnumLiteral mappedOCXOptions[] =
                {
                    { RVTI_OCX_OPTIONS_CACHE_OCX,      XML_BITFLAG_OCX_OPTIONS_CACHE_OCX },
                };

                const size_t countof_options = sizeof(mappedOCXOptions)/sizeof(mappedOCXOptions[0]);

                // create wrapper to persist flag values as strings
                CXMLBitFlags optPersistor(m_dwOCXOptions, mappedOCXOptions, countof_options);
                // persist the wrapper
                persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_OPTIONS, optPersistor);
                persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_OCX_STRING, m_strOCX);
            }
            break;

        default:
            ASSERT(FALSE && _T("Unknown MMC_VIEW_TYPE"));
            break;
        }

        // define the table to map enumeration flags to strings
        static const EnumLiteral mappedMiscOptions[] =
        {
            { RVTI_MISC_OPTIONS_NOLISTVIEWS,  _T("Misc_NoListViews") },
        };

        const size_t countof_miscoptions = sizeof(mappedMiscOptions)/sizeof(mappedMiscOptions[0]);

        // create wrapper to persist flag values as strings
        CXMLBitFlags miscPersistor(m_dwMiscOptions, mappedMiscOptions, countof_miscoptions);
        // persist the wrapper
        persistor.PersistAttribute(XML_ATTR_RESULTVIEWTYPE_MISC_OPTIONS, miscPersistor);
    }
}


/*+-------------------------------------------------------------------------*
 *
 * CResultViewType::ScGetOldTypeViewOptions
 *
 * PURPOSE: This method is for compatibility with MMC1.2. It makes MMC1.2 compatible
 *          view option for MMCN_RESTORE_VIEW.
 *
 * PARAMETERS:
 *    [out] long*      plViewOptions :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
inline SC
CResultViewType::ScGetOldTypeViewOptions(long* plViewOptions) const
{
    DECLARE_SC(sc, TEXT("CResultViewType::ScInitialize"));
    sc = ScCheckPointers(plViewOptions);
    if (sc)
        return sc;

    *plViewOptions = 0;

    if(! m_bInitialized)
        return (sc = E_UNEXPECTED); // should be initialized.

    if (m_bPersistableViewDescriptionValid)
        return (sc = E_UNEXPECTED); // Not MMC1.2 type data.

    if (HasWebBrowser())
    {
        if (m_dwMiscOptions & RVTI_MISC_OPTIONS_NOLISTVIEWS)
            *plViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

        return sc;
    }

    if (HasList())
    {
        if(m_dwListOptions & RVTI_LIST_OPTIONS_OWNERDATALIST)  *plViewOptions |= MMC_VIEW_OPTIONS_OWNERDATALIST;
        if(m_dwListOptions & RVTI_LIST_OPTIONS_MULTISELECT)    *plViewOptions |= MMC_VIEW_OPTIONS_MULTISELECT;
        if(m_dwListOptions & RVTI_LIST_OPTIONS_FILTERED)       *plViewOptions |= MMC_VIEW_OPTIONS_FILTERED;
        if(m_dwListOptions & RVTI_LIST_OPTIONS_USEFONTLINKING) *plViewOptions |= MMC_VIEW_OPTIONS_USEFONTLINKING;
        if(m_dwListOptions & RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST) *plViewOptions |= MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST;
        if(m_dwListOptions & RVTI_LIST_OPTIONS_LEXICAL_SORT)   *plViewOptions |= MMC_VIEW_OPTIONS_LEXICAL_SORT;

        return sc;
    }
    else if(HasOCX())
    {
        // NOTE: The CREATENEW flag has the opposite sense of the CACHE_OCX flag.
        if(!(m_dwOCXOptions  & RVTI_OCX_OPTIONS_CACHE_OCX))    *plViewOptions |= MMC_VIEW_OPTIONS_CREATENEW;
        if (m_dwMiscOptions & RVTI_MISC_OPTIONS_NOLISTVIEWS)    *plViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

        return sc;
    }

    return (sc = E_UNEXPECTED);
}


#ifdef _NODEMGR_DLL_
/*+-------------------------------------------------------------------------*
 *
 * CResultViewType::ScInitialize
 *
 * PURPOSE: Initializes the class from a RESULT_VIEW_TYPE_INFO structure.
 *
 * PARAMETERS:
 *    RESULT_VIEW_TYPE_INFO & rvti :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
inline SC
CResultViewType::ScInitialize(RESULT_VIEW_TYPE_INFO &rvti)
{
    DECLARE_SC(sc, TEXT("CResultViewType::ScInitialize"));

    if(m_bInitialized)
        return (sc = E_UNEXPECTED); // should not try to initialize twice

    m_bInitialized = true;

    // make sure we have a persistable view description.
    if(!rvti.pstrPersistableViewDescription)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(TEXT("Parameter 'pstrPersistableViewDescription' in structure 'RESULT_VIEW_TYPE_INFO' is NULL"), sc);
        return sc;
    }

    // copy the description
    m_strPersistableViewDescription     = rvti.pstrPersistableViewDescription;
    ::CoTaskMemFree(rvti.pstrPersistableViewDescription);
    rvti.pstrPersistableViewDescription = NULL; // just to make sure we don't try to use it
    m_bPersistableViewDescriptionValid  = true;

    // validate the view type
    m_viewType = rvti.eViewType;
    if( (m_viewType != MMC_VIEW_TYPE_LIST) &&
        (m_viewType != MMC_VIEW_TYPE_OCX)  &&
        (m_viewType != MMC_VIEW_TYPE_HTML) )
    {
        sc = E_INVALIDARG;
        TraceSnapinError(TEXT("Parameter 'eViewType' in structure 'RESULT_VIEW_TYPE_INFO' is invalid"), sc);
        return sc;
    }

    // validate the various view options
    switch(m_viewType)
    {
    default:
        ASSERT(0 && "Should not come here");
        return (sc = E_INVALIDARG);
        break;

    case MMC_VIEW_TYPE_LIST:
        if(rvti.dwListOptions & ~( RVTI_LIST_OPTIONS_NONE                          |
                                   RVTI_LIST_OPTIONS_OWNERDATALIST                 | RVTI_LIST_OPTIONS_MULTISELECT    |
                                   RVTI_LIST_OPTIONS_FILTERED                      | RVTI_LIST_OPTIONS_USEFONTLINKING |
                                   RVTI_LIST_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST | RVTI_LIST_OPTIONS_LEXICAL_SORT   |
								   RVTI_LIST_OPTIONS_ALLOWPASTE )
                                   )
        {
            sc = E_INVALIDARG;
            TraceSnapinError(TEXT("Parameter 'dwListOptions' in structure 'RESULT_VIEW_TYPE_INFO' is invalid"), sc);
            return sc;
        }

        m_dwListOptions = rvti.dwListOptions;

        break;

    case MMC_VIEW_TYPE_HTML:
        // if the view type is HTML, make sure that no flags are set. If snapins wrongly set this flag, it could break our well
        // intentioned effort to add future expansion
        if(rvti.dwHTMLOptions & ~( RVTI_HTML_OPTIONS_NONE |
                                   RVTI_HTML_OPTIONS_NOLISTVIEW) )
        {
            sc = E_INVALIDARG;
            TraceSnapinError(TEXT("Parameter 'dwHTMLOptions' in structure 'RESULT_VIEW_TYPE_INFO' must be zero"), sc);
            return sc;
        }

        // make sure we have a valid URL
        if(NULL == rvti.pstrURL)
        {
            sc = E_INVALIDARG;
            TraceSnapinError(TEXT("Parameter 'pstrURL' in structure 'RESULT_VIEW_TYPE_INFO' cannot be NULL"), sc);
            return sc;
        }

        m_dwHTMLOptions = 0;

        // copy the URL
        m_strURL     = rvti.pstrURL;
        ::CoTaskMemFree(rvti.pstrURL);
        rvti.pstrURL = NULL; // just to make sure we don't try to use it

        break;

    case MMC_VIEW_TYPE_OCX:
        if(rvti.dwOCXOptions & ~( RVTI_OCX_OPTIONS_NONE |
                                  RVTI_OCX_OPTIONS_NOLISTVIEW |
                                  RVTI_OCX_OPTIONS_CACHE_OCX) )
        {
            sc = E_INVALIDARG;
            TraceSnapinError(TEXT("Parameter 'dwOCXOptions' in structure 'RESULT_VIEW_TYPE_INFO' is invalid"), sc);
            return sc;
        }

        // if an OCX was specified, must have a valid OCX control IUnknown
        if(rvti.pUnkControl == NULL)
        {
            sc = E_INVALIDARG;
            TraceSnapinError(TEXT("No OCX specified in parameter 'pUnkControl' of structure 'RESULT_VIEW_TYPE_INFO'"), sc);
            return sc;
        }

        m_dwOCXOptions = rvti.dwOCXOptions;
        m_spUnkControl = rvti.pUnkControl; // does an addref, but rvti.ppUnkControl already had an addref set by the snapin. So need to release it once.
		rvti.pUnkControl->Release();
        break;
    }


    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CResultViewType::ScGetResultViewTypeInfo
//
//  Synopsis:    Fill the RESULT_VIEW_TYPE_INFO struct and return.
//
//  Arguments:   [rvti] - Fill the struct and return.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
inline SC
CResultViewType::ScGetResultViewTypeInfo (RESULT_VIEW_TYPE_INFO& rvti) const
{
    DECLARE_SC(sc, _T("CResultViewType::ScGetResultViewTypeInfo"));

    if(! m_bInitialized)
        return (sc = E_UNEXPECTED);

    ZeroMemory(&rvti, sizeof(rvti));
    rvti.pstrPersistableViewDescription = NULL;

    // must have a persistable description
    if (!IsPersistableViewDescriptionValid())
        return (sc = E_UNEXPECTED);

    rvti.pstrPersistableViewDescription = (LPOLESTR)
         CoTaskMemAlloc( (1 + wcslen(m_strPersistableViewDescription.data())) * sizeof(OLECHAR));
    sc = ScCheckPointers(rvti.pstrPersistableViewDescription, E_OUTOFMEMORY);
    if (sc)
        return sc;

    // copy over the description string.
    wcscpy(rvti.pstrPersistableViewDescription, m_strPersistableViewDescription.data());


    return (sc);
}
#endif _NODEMGR_DLL_

#endif //_RESULTVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\picon.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      picon.h
 *
 *  Contents:  Interface file for CPersistableIcon
 *
 *  History:   19-Nov-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef PICON_H
#define PICON_H
#pragma once

#include <objidl.h>     // for IStorage
#include "tstring.h"
#include "smarticon.h"
#include "cpputil.h"

class CPersistableIconData
{
public:
    CPersistableIconData() :
        m_nIndex (-1)
    {}

    CPersistableIconData(LPCTSTR pszIconFile, int nIndex) :
        m_strIconFile (pszIconFile), m_nIndex (nIndex)
    {}

    // default copy construction and assignment are fine
//  CPersistableIconData (const CPersistableIconData& other)
//  CPersistableIconData& operator= (const CPersistableIconData& other)

    void Clear ()
    {
        m_strIconFile.erase();
        m_nIndex = -1;

        ASSERT (m_strIconFile.empty());
    }

    bool operator== (const CPersistableIconData& other) const
        { return ((m_nIndex == other.m_nIndex) && (m_strIconFile == other.m_strIconFile)); }

    bool operator!= (const CPersistableIconData& other) const
        { return (!operator== (other)); }


public:
    tstring m_strIconFile;
    int     m_nIndex;

};

class CXMLPersistableIcon;

class CPersistableIcon
{
	DECLARE_NOT_COPIABLE   (CPersistableIcon);
	DECLARE_NOT_ASSIGNABLE (CPersistableIcon);

    // these guys need to assign new icons to the object
    friend class CXMLPersistableIcon;
    friend HRESULT LoadIconFromXMLData(LPCSTR pFileData, DWORD dwLen, CPersistableIcon &persistableIcon);

public:
	CPersistableIcon () {}
   ~CPersistableIcon ();

    operator bool () const
        { return (!m_Data.m_strIconFile.empty()); }

    bool operator== (const CPersistableIconData& data) const
        { return (m_Data == data); }

    bool operator!= (const CPersistableIconData& data) const
        { return (m_Data != data); }

    CPersistableIcon& operator= (const CPersistableIconData& data);

	HRESULT GetIcon (int nIconSize, CSmartIcon& icon) const;

    void GetData (CPersistableIconData& data) const
        { data = m_Data; }

    HRESULT Load (LPCWSTR pszFilename);
    HRESULT Load (IStorage* pstg);

private:
    void Cleanup();
    bool ExtractIcons();


private:
    CPersistableIconData    m_Data;
	CSmartIcon				m_icon16;
	CSmartIcon				m_icon32;

    static const LPCWSTR s_pszDefaultStorage;
    static const LPCWSTR s_pszIconFileStream;
    static const LPCWSTR s_pszIconBitsStream;

};


IStream& operator>> (IStream& stm,       CPersistableIconData& data);

extern const LPCWSTR g_pszCustomDataStorage;


#endif /* PICON_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\serial.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      serial.h
 *
 *  Contents:  Object serialization class definitions
 *
 *  History:   11-Feb-99 vivekj     Created
 *
 *--------------------------------------------------------------------------*/

#pragma once
#ifndef SERIAL_H
#define SERIAL_H
                                                         
/*+-------------------------------------------------------------------------*
 * class CSerialObject
 * 
 *
 * PURPOSE: Base class for objects that can be serialized.
 *
 *+-------------------------------------------------------------------------*/
class CSerialObject
{
public:
    HRESULT Read (IStream &stm);

protected: // implemented by the derived class
    // virtual CStr GetName()      =0;
    virtual UINT    GetVersion()   =0;

    // return values for ReadSerialObject: S_OK: succeeded, S_FALSE: unknown version
    // E_UNEXPECTED: catastrophic error.
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/) = 0;  
};

/*+-------------------------------------------------------------------------*
 * class CSerialObjectRW
 * 
 *
 * PURPOSE: Provided to separate from CSerialObject the "Write" functionality 
 *          which is much less frequently used
 *
 *+-------------------------------------------------------------------------*/
class CSerialObjectRW : public CSerialObject
{
public:
    HRESULT Write(IStream &stm);

protected: // implemented by the derived class

    virtual HRESULT WriteSerialObject(IStream &stm) = 0;
};

//############################################################################
//############################################################################
//
//  template functions - std::list class
//
//############################################################################
//############################################################################
template<class T, class Al> 
HRESULT Read(IStream& stm, std::list<T, Al>& l)
{   
    HRESULT hr = S_OK;

    try
    {
        int cSize;
        stm >> cSize;

        for(int i=0 ; i<cSize; i++)
        {
            T t;
            hr = t.Read(stm);   // read the underlying object
            BREAK_ON_FAIL (hr);

            l.push_back(t);     // add it to the list
        }
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
    }

    return (hr);
}

template<class T, class Al> 
HRESULT Write(IStream& stm, std::list<T, Al>& l)
{   
    HRESULT hr = S_OK;

    try
    {
        int cSize = l.size();

        // write out the length
        stm << cSize;

        // write out the members
        for(std::list<T, Al>::iterator it = l.begin(); it != l.end(); ++it)
        {
            hr = it->Write (stm);
            BREAK_ON_FAIL (hr);
        }
        
    }
    catch (_com_error& err)
    {
        hr = err.Error();
        ASSERT (false && "Caught _com_error");
    }

    return (hr);
}



#endif // SERIAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\safetemp.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       SafeTemp.h
//
//  Contents:   A template for safe pointers.
//
//  Classes:    XSafeInterfacePtr<ISome>
//
//  History:    6/3/1996   RaviR   Created
//____________________________________________________________________________
//


//____________________________________________________________________________
//
//  Template:   XSafeInterfacePtr
//
//  Purpose:    Safe pointer to any interface that supports AddRef/Release
//
//  Notes:      This works for classes that define AddRef/Release, or for
//              OLE interfaces. It is not necessary that the class
//              be a derivative of IUnknown, so long as it supports
//              AddRef and Release methods which have the same semantics as
//              those in IUnknown.
//
//              The constructor takes a parameter which specifies whether
//              the captured pointer should be AddRef'd, defaulting to TRUE.
//
//              The Copy function creates a valid additional copy of
//              the captured pointer (following the AddRef/Release protocol)
//              so can be used to hand out copies from a safe pointer declared
//              as a member of some other class.
//
//              The 'Transfer' function transfers the interface pointer, and
//              invalidates its member value (by setting it to NULL).
//
//              To release the existing interface ptr and set it to a new
//              instance use the 'Set' member fuction. This method takes a
//              parameter which specifies whether the new pointer should be
//              AddRef'd, defaulting to TRUE.
//
//              The following methods manipulate the interface pointer with
//              out following the AddRef/Release protocol: Transfer, Attach
//              and Detach.
//
//  History:    6/3/1996   RaviR   Created
//____________________________________________________________________________
//


template<class ISome>
class XSafeInterfacePtr
{
public:

    inline XSafeInterfacePtr(ISome * pinter=NULL, BOOL fInc=TRUE)
        : _p ( pinter )
    {
        if (fInc && (_p != NULL))
        {
            _p->AddRef();
        }
    }

    inline ~XSafeInterfacePtr()
    {
        if (_p != NULL)
        {
            _p->Release();
            _p = NULL;
        }
    }

    inline BOOL IsNull(void)
    {
        return (_p == NULL);
    }

    inline void Copy(ISome **pxtmp)
    {
        *pxtmp = _p;
        if (_p != NULL)
            _p->AddRef();
    }

    inline void Transfer(ISome **pxtmp)
    {
        *pxtmp = _p;
        _p = NULL;
    }

    inline void Set(ISome* p, BOOL fInc = TRUE)
    {
        if (_p)
        {
            _p->Release();
        }
        _p = p;
        if (fInc && _p)
        {
            _p->AddRef();
        }
    }

    inline void SafeRelease(void)
    {
        if (_p)
        {
            _p->Release();
            _p = NULL;
        }
    }

    inline void SimpleRelease(void)
    {
        ASSERT(_p != NULL);
        _p->Release();
        _p = NULL;
    }

    inline void Attach(ISome* p)
    {
        ASSERT(_p == NULL);
        _p = p;
    }

    inline void Detach(void)
    {
        _p = NULL;
    }

    inline ISome * operator-> () { return _p; }

    inline ISome& operator * () { return *_p; }

    inline operator ISome *() { return _p; }

    inline ISome ** operator &()
    {
        ASSERT( _p == NULL );
        return &_p;
    }

    inline ISome *Self(void) { return _p; }

private:

    ISome * _p;

    inline  void operator= (const XSafeInterfacePtr &) {;}

    inline  XSafeInterfacePtr(const XSafeInterfacePtr &){;}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\smarticon.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      smarticon.h
 *
 *  Contents:  Interface file for CSmartIcon
 *
 *  History:   25-Jul-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include <windows.h>	// for HICON  when building uicore.lib, which has no PCH
#include "stddbg.h"		// for ASSERT when building uicore.lib, which has no PCH


/*+-------------------------------------------------------------------------*
 * class CSmartIcon
 *
 *
 * PURPOSE: A smart wrapper for icons. Destroys the icon when all references
 *          to the icon are released.
 *
 *
 * USAGE:   1) Create the icon and assign to a smart icon:
 *              smarticon.Attach(::CreateIcon(...));
 *
 *          NOTE: The Attach method will destroy the icon if the underlying
 *          CSmartIconData object cannot be created because of insufficient memory.
 *
 *          2) Smart icons can be treated as icons:
 *              DrawIcon(..., smarticon, ...)
 *
 *          3) Smart icons can be assigned to one another just like handles:
 *              smarticon1 = smarticon2;
 *
 *+-------------------------------------------------------------------------*/
class CSmartIcon
{
public:
    CSmartIcon () : m_pData(NULL) {}
   ~CSmartIcon ();
	CSmartIcon (const CSmartIcon& other);
	CSmartIcon& operator= (const CSmartIcon& rhs);

    void  Attach  (HICON hIcon);
    HICON Detach  ();				// let go without decrementing ref count
    void  Release ();				// let go, decrementing ref count

    operator HICON() const
    {
        return m_pData
            ? m_pData->operator HICON()
            : NULL;
    }

    /*
     * for comparison to NULL (only)
     */
    bool operator==(int null) const
    {
        ASSERT (null == 0);
        return (operator HICON() == NULL);
    }

    bool operator!=(int null) const
    {
        ASSERT (null == 0);
        return (operator HICON() != NULL);
    }

private:
    class CSmartIconData
    {
        HICON	m_hIcon;
        DWORD	m_dwRefs;

        CSmartIconData(HICON hIcon) : m_hIcon(hIcon), m_dwRefs(1) {}

       ~CSmartIconData()
		{
			if (m_hIcon != NULL)
				::DestroyIcon (m_hIcon);
		}

	public:
		static CSmartIconData* CreateInstance(HICON hIcon)	{ return new CSmartIconData(hIcon);	}
        operator HICON() const								{ return m_hIcon; }

		HICON Detach();
        void AddRef()           {++m_dwRefs;}
        void Release()
        {
            if((--m_dwRefs)==0)
				delete this;
        }
    };

private:
    CSmartIconData* m_pData;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\stgutil.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       StgUtil.h
//
//  Contents:   Classes to simplify dealing with storage objects.
//
//  Classes:    CDocFile,
//              CIStorage
//              CIStream
//
//  History:    6/3/1996   RaviR   Created
//
//
//  Sample:     Code sample using the above three classes & their safe ptrs.
//
//              Objective: Create a doc file this will be the root storage.
//                         Create a sub storage under this root storage.
//
//              Code:
//                  HRESULT
//                  CerateADocFileWithSubStorage(
//                      WCHAR      wszDocFileName[],
//                      WCHAR      wszSubStgName[],
//                      LPSTORAGE *ppstg)
//                  {
//                      try
//                      {
//                          CDocFile docFile;
//                          docFile.Create(wszDocFileName);
//
//                          CIStorage stgRoot;
//                          docFile.Transfer(&stgRoot);
//
//                          CIStorage stgSub;
//                          stgRoot.CreateStorage(&stgSub, wszSubStgName);
//
//                          stgRoot.Transfer(ppstg);
//                      }
//                      CATCH_FILE_ERROR(hr,cfe)
//							delete cfe;
//                          return hr;
//                      END_CATCH_FILE_ERROR;
//
//                      return S_OK;
//                  }
//
//____________________________________________________________________________
//


#ifndef __STGUTIL__H__
#define __STGUTIL__H__

#include "macros.h"

//
// CDocFile, CIStorage and CIStream throw errors of type CFileException.
// Note, however, that m_cause is always CFileException::generic and
// m_lOsError is an HRESULT rather than a Windows error code.
//

#define THROW_FILE_ERROR2(hr,psz) AfxThrowFileException( CFileException::generic, hr, psz );
#define THROW_FILE_ERROR(hr) THROW_FILE_ERROR2( hr, NULL )

#define CATCH_FILE_ERROR(hr)							\
	catch(CFileException* cfe)							\
	{													\
		if (cfe.m_cause != CFileException::generic)		\
			throw;										\
		HRESULT hr = cfe.m_IOsError;

#define END_CATCH_FILE_ERROR }
		
//____________________________________________________________________________
//
//  Class:      CDocFile
//
//  Synopsis:   CDocFile can be used to create, open & close a docfile.
//              It has one data member, a pointer to the root IStorage
//              interface of the document. Safe interface pointer member
//              functions are created for this data member. (Please see
//              macros.h for description of Safe interface pointer member
//              functions)
//
//  Members:    Create:
//                  Creates/opens a docfile with the given name. The default
//                  mode is to create a docfile with read-write and share
//                  exclusive flags. Throws CFileException on error.
//
//              CreateTemporary:
//                  Creates a temporary docfile, which will be deleted on
//                  release. Throws CFileException on error.
//
//              Open:
//                  Opens an existing docfile. The default mode is read-write
//                  and share exclusive. Throws CFileException on error.
//
//              Safe Interface Pointer Member functions:
//                  Used to access the IStorage interface ptr. (see macros.h)
//
//
//  History:    5/31/1996   RaviR   Created
//
//____________________________________________________________________________
//


class CDocFile
{
public:

    void Create(LPWSTR pwszName,
            DWORD grfMode = STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE);

    void CreateTemporary(void) { this->Create(NULL, STGM_DELETEONRELEASE); }

    void Open(LPWSTR pwszName,
            DWORD grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE);

    DECLARE_SAFE_INTERFACE_PTR_MEMBERS(CDocFile, IStorage, m_pstg)

private:
    LPSTORAGE       m_pstg;

}; // class CDocFile



inline
void
CDocFile::Create(
    LPWSTR pswzName,
    DWORD  grfMode)
{
    ASSERT(m_pstg == NULL);

    HRESULT hr = StgCreateDocfile(pswzName, grfMode, 0, &m_pstg);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        m_pstg = NULL;
		USES_CONVERSION;
        THROW_FILE_ERROR2( hr, W2T(pswzName) );
    }
}


inline
void
CDocFile::Open(
    LPWSTR pwszName,
    DWORD  grfMode)
{
    ASSERT(m_pstg == NULL);

    HRESULT hr = StgOpenStorage(pwszName, NULL, grfMode, NULL, NULL, &m_pstg);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        m_pstg = NULL;
		USES_CONVERSION;
        THROW_FILE_ERROR2( hr, W2T(pwszName) );
    }
}


//____________________________________________________________________________
//
//  Class:      CIStorage
//
//  Synopsis:   Represents an IStorage instance - top level or embedded.
//
//  History:    5/29/1996   RaviR   Created
//
//  Notes:      1) This is a simple wrapper around the Docfile implementaion
//                 of IStorage.
//
//              2) Instead of returning errors we use the C++ exception
//                 handling mechanism and throw CFileException.
//
//              3) Most of the methods have default values for arguments.
//
//              4) Safe Interface Pointer methods have been added for
//                 the IStorage interface ptr.
//
//
//              CIStorage
//                  |
//                  |
//              IStorage
//
//____________________________________________________________________________
//

class CIStorage
{
public:

    void CreateStream(LPSTREAM *ppstm, LPCOLESTR pszName,
                      DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstm != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_TRANSACTED) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->CreateStream(pszName, grfMode, NULL, NULL, ppstm);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void OpenStream(LPSTREAM *ppstm, LPCOLESTR pszName,
                       DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstm != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_TRANSACTED) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->OpenStream(pszName, NULL, grfMode, 0, ppstm);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void CreateStorage(LPSTORAGE *ppstg, LPCOLESTR pszName,
                          DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstg != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);

        HRESULT hr = m_pstg->CreateStorage(pszName, grfMode, NULL, NULL, ppstg);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void OpenStorage(LPSTORAGE *ppstg, LPCOLESTR pszName,
                        DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstg != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_PRIORITY) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->OpenStorage(pszName, NULL, grfMode, NULL, 0, ppstg);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void OpenStorage(LPSTORAGE *ppstg, LPSTORAGE pstgPriority,
                        DWORD grfMode = STGM_READWRITE|STGM_SHARE_EXCLUSIVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppstg != NULL);
        ASSERT((grfMode & STGM_DELETEONRELEASE) == 0);
        ASSERT((grfMode & STGM_PRIORITY) == 0);
        ASSERT((grfMode & STGM_SHARE_EXCLUSIVE) != 0);

        HRESULT hr = m_pstg->OpenStorage(NULL, pstgPriority, grfMode, NULL, 0, ppstg);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void CopyTo(LPSTORAGE pstgDest)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(pstgDest != NULL);

        HRESULT hr = m_pstg->CopyTo(0, NULL, NULL, pstgDest);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void MoveElementTo(LPCOLESTR pszName, LPSTORAGE pstgDest,
                          LPCOLESTR pszNewName, DWORD grfFlags = STGMOVE_MOVE)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(pstgDest != NULL);
        ASSERT(m_pstg != pstgDest);

        HRESULT hr = m_pstg->MoveElementTo(pszName, pstgDest, pszNewName, grfFlags);

		USES_CONVERSION;
        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR2(hr, OLE2T((LPOLESTR)pszName)); }
    }

    void Commit(DWORD grfCommitFlags = STGC_ONLYIFCURRENT)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->Commit(grfCommitFlags);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void Revert(void)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->Revert();

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void EnumElements(IEnumSTATSTG ** ppenum)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(ppenum != NULL);

        HRESULT hr = m_pstg->EnumElements(0, NULL, 0, ppenum);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void DestroyElement(LPCOLESTR pszName)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->DestroyElement(pszName);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void RenameElement(LPCOLESTR pszOldName, LPCOLESTR pszNewName)
    {
        ASSERT(m_pstg != NULL);
        ASSERT(pszOldName != NULL);
        ASSERT(pszNewName != NULL);

        HRESULT hr = m_pstg->RenameElement(pszOldName, pszNewName);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void SetElementTimes(LPCOLESTR pszName, LPFILETIME pctime,
                        LPFILETIME patime = NULL, LPFILETIME pmtime = NULL)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->SetElementTimes(pszName, pctime, patime, pmtime);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void SetClass(REFCLSID clsid)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->SetClass(clsid);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void SetStateBits(DWORD grfStateBits, DWORD grfMask)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->SetStateBits(grfStateBits, grfMask);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    void Stat(STATSTG * pstatstg, DWORD grfStatFlag = STATFLAG_NONAME)
    {
        ASSERT(m_pstg != NULL);

        HRESULT hr = m_pstg->Stat(pstatstg, grfStatFlag);

        if (FAILED(hr)) { CHECK_HRESULT(hr); THROW_FILE_ERROR(hr); }
    }

    DECLARE_SAFE_INTERFACE_PTR_MEMBERS(CIStorage, IStorage, m_pstg)

private:
    IStorage * m_pstg;

}; // class CIStorage




//____________________________________________________________________________
//
//  Class:      CIStream
//
//  Synopsis:   Represents an IStream instance
//
//  History:    5/31/1996   RaviR   Created
//
//  Notes:      1) This is a simple wrapper around the Docfile implementaion
//                 of IStream.
//
//              2) Instead of returning errors we use the C++ exception
//                 handling mechanism and throw the error(hresult).
//
//              4) Safe Interface Pointer methods have been added for
//                 the IStream interface ptr.
//
//
//              CIStream
//                 |
//                 |
//              IStream
//
//____________________________________________________________________________
//

class CIStream
{
public:

    void Commit(DWORD grfCommitFlags = STGC_ONLYIFCURRENT);
    void Clone(IStream ** ppstm);
    void Read(PVOID pv, ULONG cb);
    void Write(const VOID * pv, ULONG cb);
    void CopyTo(IStream * pstm, ULARGE_INTEGER cb);
    void GetCurrentSeekPosition(ULARGE_INTEGER * plibCurPosition);
    void Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin = STREAM_SEEK_CUR,
                                ULARGE_INTEGER * plibNewPosition = NULL);
    void SetSize(ULARGE_INTEGER libNewSize);
    void Stat(STATSTG * pstatstg, DWORD grfStatFlag = STATFLAG_NONAME);

    DECLARE_SAFE_INTERFACE_PTR_MEMBERS(CIStream, IStream, m_pstm);

private:
    LPSTREAM    m_pstm;

}; // class CIStream


inline
void
CIStream::Clone(
    IStream ** ppstm)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->Clone(ppstm);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}


inline
void
CIStream::Commit(
    DWORD grfCommitFlags)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->Commit(grfCommitFlags);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}


inline
void
CIStream::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER * plibNewPosition)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->Seek(dlibMove, dwOrigin, plibNewPosition);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}



//____________________________________________________________________________
//
//  Member:     CIStream::GetCurrentSeekPosition
//
//  Synopsis:   Returns the current seek position.
//
//  Arguments:  [plibCurPosition] -- IN
//
//  Returns:    void
//____________________________________________________________________________
//

inline
void
CIStream::GetCurrentSeekPosition(
    ULARGE_INTEGER * plibCurPosition)
{
    ASSERT(m_pstm != NULL);
    ASSERT(plibCurPosition != NULL);

    LARGE_INTEGER li = {0};

    HRESULT hr = m_pstm->Seek(li, STREAM_SEEK_CUR, plibCurPosition);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}


inline
void
CIStream::SetSize(
    ULARGE_INTEGER libNewSize)
{
    ASSERT(m_pstm != NULL);

    HRESULT hr = m_pstm->SetSize(libNewSize);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}



inline
void
CIStream::Stat(
    STATSTG   * pstatstg,
    DWORD       grfStatFlag)
{
    ASSERT(m_pstm != NULL);
    ASSERT(pstatstg != NULL);

    HRESULT hr = m_pstm->Stat(pstatstg, grfStatFlag);

    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        THROW_FILE_ERROR(hr);
    }
}



#endif // __STGUTIL__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\stgio.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1998.
 *
 *  File:      stgio.inl
 *
 *  Contents:  Inlines file structured storage I/O utilities
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STGIO_INL
#define STGIO_INL
#pragma once

#include <functional>   
#include <algorithm>


/*+-------------------------------------------------------------------------*
 * stream_insert
 *
 * Functor to insert an object in an IStream.
 *--------------------------------------------------------------------------*/

template<class T>
struct stream_insert : 
    public std::binary_function<IStream*, T, IStream&>
{
    IStream& operator() (IStream* pstm, const T& t) const
        { return (*pstm << t); }
};


/*+-------------------------------------------------------------------------*
 * stream_extract
 *
 * Functor to extract an object from an IStream.
 *--------------------------------------------------------------------------*/

template<class T>
struct stream_extract :
    public std::binary_function<IStream*, T, IStream&>
{
    IStream& operator() (IStream* pstm, T& t) const
        { return (*pstm >> t); }
};


/*+-------------------------------------------------------------------------*
 * insert_each
 *
 * Inserts each item in a collection in an IStream.
 *--------------------------------------------------------------------------*/

template<class Collection>
void insert_each (IStream* pstm, const Collection& c)
{
    std::for_each (c.begin(), c.end(), 
                   std::bind1st (stream_insert<Collection::value_type>(), pstm));
}


/*+-------------------------------------------------------------------------*
 * insert_collection
 *
 * Inserts an entire collection into an IStream.
 *--------------------------------------------------------------------------*/

template<class Collection>
void insert_collection (IStream* pstm, const Collection& c)
{
    /*
     * write the size
     */
    *pstm << (DWORD) c.size();

    /*
     * write the elements
     */
    insert_each (pstm, c);
}


/*+-------------------------------------------------------------------------*
 * extract_collection
 *
 * Extracts an entire collection (written by insert_collection) from an IStream.
 *--------------------------------------------------------------------------*/

template<class Collection>
void extract_collection (IStream* pstm, Collection& c)
{
    /*
     * clear out the current container
     */
    c.clear();
    ASSERT (c.empty());

    /*
     * read the number of items
     */
    DWORD cItems;
    *pstm >> cItems;

    /*
     * read each item
     */
    while (cItems-- > 0)
    {
        /*
         * read the item
         */
        Collection::value_type t;
        *pstm >> t;

        /*
         * put it in the container
         */
        c.push_back (t);
    }
}


/*+-------------------------------------------------------------------------*
 * extract_vector 
 *
 * Extracts an entire vector (written by insert_collection) from an IStream.
 *--------------------------------------------------------------------------*/

template<class T>
void extract_vector (IStream* pstm, std::vector<T>& v)
{
    /*
     * clear out the current container
     */
    v.clear();

    /*
     * read the number of items
     */
    DWORD cItems;
    *pstm >> cItems;

    /*
     * pre-allocate the appropriate number of items (specialization for vector)
     */
    v.reserve (cItems);
    ASSERT (v.empty());
    ASSERT (v.capacity() >= cItems);

    /*
     * read each item
     */
    while (cItems-- > 0)
    {
        /*
         * read the item
         */
        T t;
        *pstm >> t;

        /*
         * put it in the container
         */
        v.push_back (t);
    }
}

// specialized scalar vector prototypes (stgio.cpp)
#define DeclareScalarVectorStreamFunctions(scalar_type)                        \
    void extract_vector    (IStream* pstm,       std::vector<scalar_type>& v); \
    void insert_collection (IStream* pstm, const std::vector<scalar_type>& v);
                                                    
DeclareScalarVectorStreamFunctions (bool);
DeclareScalarVectorStreamFunctions (         char);
DeclareScalarVectorStreamFunctions (unsigned char);
DeclareScalarVectorStreamFunctions (         short);
DeclareScalarVectorStreamFunctions (unsigned short);
DeclareScalarVectorStreamFunctions (         int);
DeclareScalarVectorStreamFunctions (unsigned int);
DeclareScalarVectorStreamFunctions (         long);
DeclareScalarVectorStreamFunctions (unsigned long);
DeclareScalarVectorStreamFunctions (         __int64);
DeclareScalarVectorStreamFunctions (unsigned __int64);
DeclareScalarVectorStreamFunctions (float);
DeclareScalarVectorStreamFunctions (double);
DeclareScalarVectorStreamFunctions (long double);


/*+-------------------------------------------------------------------------*
 * extract_set_or_map
 *
 * Extracts an entire set or map (written by insert_collection) from an IStream.
 *--------------------------------------------------------------------------*/

template<class Collection>
void extract_set_or_map (IStream* pstm, Collection& c)
{
    /*
     * clear out the current container
     */
    c.clear();
    ASSERT (c.empty());

    /*
     * read the number of items
     */
    DWORD cItems;
    *pstm >> cItems;

    /*
     * read each item
     */
    while (cItems-- > 0)
    {
        /*
         * read the item
         */
        Collection::value_type t;
        *pstm >> t;

        /*
         * put it in the container
         */
        c.insert (t);
    }
}



/*+-------------------------------------------------------------------------*
 * operator<<, operator>>
 *
 * Stream insertion and extraction operators for various types
 *--------------------------------------------------------------------------*/

// std::pair<>
template<class T1, class T2> 
IStream& operator>> (IStream& stm, std::pair<T1, T2>& p)
{
    return (stm >> p.first >> p.second);
}

template<class T1, class T2> 
IStream& operator<< (IStream& stm, const std::pair<T1, T2>& p)
{
    return (stm << p.first << p.second);
}


// std::list<>
template<class T, class Al> 
IStream& operator>> (IStream& stm, std::list<T, Al>& l)
{
    extract_collection (&stm, l);
    return (stm);
}

template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::list<T, Al>& l)
{
    insert_collection (&stm, l);
    return (stm);
}


// std::deque<>
template<class T, class Al> 
IStream& operator>> (IStream& stm, std::deque<T, Al>& l)
{
    extract_collection (&stm, l);
    return (stm);
}

template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::deque<T, Al>& l)
{
    insert_collection (&stm, l);
    return (stm);
}


// std::vector<>
template<class T, class Al> 
IStream& operator>> (IStream& stm, std::vector<T, Al>& v)
{
    extract_vector (&stm, v);
    return (stm);
}

template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::vector<T, Al>& v)
{
    insert_collection (&stm, v);
    return (stm);
}


// std::set<>
template<class T, class Pr, class Al> 
IStream& operator>> (IStream& stm, std::set<T, Pr, Al>& s)
{
    extract_set_or_map (&stm, s);
    return (stm);
}

template<class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::set<T, Pr, Al>& s)
{
    insert_collection (&stm, s);
    return (stm);
}


// std::multiset<>
template<class T, class Pr, class Al> 
IStream& operator>> (IStream& stm, std::multiset<T, Pr, Al>& s)
{
    extract_set_or_map (&stm, s);
    return (stm);
}

template<class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::multiset<T, Pr, Al>& s)
{
    insert_collection (&stm, s);
    return (stm);
}


// std::map<>
template<class K, class T, class Pr, class Al> 
IStream& operator>> (IStream& stm, std::map<K, T, Pr, Al>& m)
{
    extract_set_or_map (&stm, m);
    return (stm);
}

template<class K, class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::map<K, T, Pr, Al>& m)
{
    insert_collection (&stm, m);
    return (stm);
}


// std::multimap<>
template<class K, class T, class Pr, class Al> 
IStream& operator>> (IStream& stm, std::multimap<K, T, Pr, Al>& m)
{
    extract_set_or_map (&stm, m);
    return (stm);
}

template<class K, class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::multimap<K, T, Pr, Al>& m)
{
    insert_collection (&stm, m);
    return (stm);
}


#endif /* STGIO_INL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\sitebase.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File:      SiteBase.h
 *
 *  Contents:  Header file for CAxWindowImplT. Refer to MSJ, December 1999.
 *
 *  History:   30-Nov-99 VivekJ     Created
 *
 *--------------------------------------------------------------------------*/
#pragma once
#ifndef __SITEBASE_H_
#define __SITEBASE_H_

//------------------------------------------------------------------------------------------------------------------
//
//
//
#include "AxWin2.H"

template <typename TDerived, typename TWindow = CAxWindow2>
class CAxWindowImplT : public CWindowImplBaseT< TWindow >     
{
public:
    typedef CAxWindowImplT<TWindow> thisClass;
    
public:
    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_CREATE,OnCreate)
        MESSAGE_HANDLER(WM_NCDESTROY,OnNCDestroy)
    END_MSG_MAP()

    //
    DECLARE_WND_SUPERCLASS(_T("AtlAxWinEx"),CAxWindow::GetWndClassName()) 
    

    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
            DWORD dwStyle = 0, DWORD dwExStyle = 0,
            UINT nID = 0, LPVOID lpCreateParam = NULL)
    {
        if (GetWndClassInfo().m_lpszOrigName == NULL)
            GetWndClassInfo().m_lpszOrigName = GetWndClassName();
        ATOM atom = GetWndClassInfo().Register(&m_pfnSuperWindowProc);

        dwStyle = GetWndStyle(dwStyle);
        dwExStyle = GetWndExStyle(dwExStyle);

        return CWindowImplBaseT<TWindow>::Create(hWndParent, rcPos, szWindowName,dwStyle, dwExStyle, nID,atom, lpCreateParam);

    }   
    
    HRESULT AxCreateControl2(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer, IUnknown** ppUnkControl = 0, REFIID iidSink = IID_NULL, IUnknown* punkSink = 0)
    {
        return AtlAxCreateControlEx(lpszName, hWnd, pStream,ppUnkContainer,ppUnkControl,iidSink,punkSink);
    }

public:
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        ::OleInitialize(NULL);

        CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
        int nLen = ::GetWindowTextLength(m_hWnd);
        LPTSTR lpstrName = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));
        ::GetWindowText(m_hWnd, lpstrName, nLen + 1);
        ::SetWindowText(m_hWnd, _T(""));
        IAxWinHostWindow* pAxWindow = NULL;
        int nCreateSize = 0;
        if (lpCreate && lpCreate->lpCreateParams)
            nCreateSize = *((WORD*)lpCreate->lpCreateParams);
        HGLOBAL h = GlobalAlloc(GHND, nCreateSize);
        CComPtr<IStream> spStream;
        if (h && nCreateSize)
        {
            BYTE* pBytes = (BYTE*) GlobalLock(h);
            BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD); 
            //Align to DWORD
            //pSource += (((~((DWORD)pSource)) + 1) & 3);
            memcpy(pBytes, pSource, nCreateSize);
            GlobalUnlock(h);
            CreateStreamOnHGlobal(h, TRUE, &spStream);
        }
        USES_CONVERSION;
        CComPtr<IUnknown> spUnk;
        TDerived* pT = static_cast<TDerived*>(this);
        HRESULT hRet = pT->AxCreateControl2(T2COLE(lpstrName), m_hWnd, spStream, &spUnk);
        if(FAILED(hRet))
            return -1;  // abort window creation
        hRet = spUnk->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
        if(FAILED(hRet))
            return -1;  // abort window creation
        ::SetWindowLongPtr(m_hWnd, GWLP_USERDATA, (DWORD_PTR)pAxWindow);
        // check for control parent style if control has a window
        HWND hWndChild = ::GetWindow(m_hWnd, GW_CHILD);
        if(hWndChild != NULL)
        {
            if(::GetWindowLong(hWndChild, GWL_EXSTYLE) & WS_EX_CONTROLPARENT)
            {
                DWORD dwExStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
                dwExStyle |= WS_EX_CONTROLPARENT;
                ::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwExStyle);
            }
        }
        
        bHandled = TRUE;
        return 0L;
    }
    LRESULT OnNCDestroy(UINT , WPARAM , LPARAM , BOOL& bHandled)
    {
        IAxWinHostWindow* pAxWindow = (IAxWinHostWindow*)::GetWindowLongPtr(m_hWnd, GWLP_USERDATA);
        if(pAxWindow != NULL)
            pAxWindow->Release();
        OleUninitialize();
        m_hWnd = 0;
        bHandled = TRUE;
        return 0L;
    }

};

//-----------------------------------------------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\stgio.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      stgio.h
 *
 *  Contents:  Interface file structured storage I/O utilities
 *
 *  History:   25-Jun-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STGIO_H
#define STGIO_H
#pragma once

#include <objidl.h>     // for IStream
#include <string>       // for std::string, std::wstring
#include <list>         // for std::list
#include <vector>       // for std::vector
#include <deque>        // for std::deque
#include <map>          // for std::map, std::multimap
#include <set>          // for std::set, std::multiset


#define DeclareStreamOperators(type)                    \
    IStream& operator>> (IStream& stm,       type& t);  \
    IStream& operator<< (IStream& stm,       type  t);      
                                                        
#define DeclareStreamOperatorsByRef(type)               \
    IStream& operator>> (IStream& stm,       type& t);  \
    IStream& operator<< (IStream& stm, const type& t);


/*
 * Writing these small types by value allows convenient usage with 
 * literals and constants like:
 *
 *      str << (char) 'a';
 *
 * instead of the bulkier and less convenient:
 *
 *      char ch = 'a';
 *      str << ch;
 */
DeclareStreamOperators (bool);
DeclareStreamOperators (         char);
DeclareStreamOperators (unsigned char);
DeclareStreamOperators (         short);
DeclareStreamOperators (unsigned short);
DeclareStreamOperators (         int);
DeclareStreamOperators (unsigned int);
DeclareStreamOperators (         long);
DeclareStreamOperators (unsigned long);
DeclareStreamOperators (         __int64);
DeclareStreamOperators (unsigned __int64);
DeclareStreamOperators (float);
DeclareStreamOperators (double);
DeclareStreamOperators (long double);


/*
 * These are relatively large and unlikely to be used with literals,
 * so write by const reference
 */
DeclareStreamOperatorsByRef (CLSID);
DeclareStreamOperatorsByRef (std::string);
DeclareStreamOperatorsByRef (std::wstring);

template<class T1, class T2>
IStream& operator>> (IStream& stm,       std::pair<T1, T2>& p);
template<class T1, class T2>
IStream& operator<< (IStream& stm, const std::pair<T1, T2>& p);

template<class T, class Al> 
IStream& operator>> (IStream& stm,       std::list<T, Al>& l);
template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::list<T, Al>& l);

template<class T, class Al> 
IStream& operator>> (IStream& stm,       std::deque<T, Al>& d);
template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::deque<T, Al>& d);

template<class T, class Al> 
IStream& operator>> (IStream& stm,       std::vector<T, Al>& v);
template<class T, class Al> 
IStream& operator<< (IStream& stm, const std::vector<T, Al>& v);

template<class T, class Pr, class Al>
IStream& operator>> (IStream& stm,       std::set<T, Pr, Al>& s);
template<class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::set<T, Pr, Al>& s);

template<class T, class Pr, class Al>
IStream& operator>> (IStream& stm,       std::multiset<T, Pr, Al>& s);
template<class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::multimap<T, Pr, Al>& s);

template<class K, class T, class Pr, class Al>
IStream& operator>> (IStream& stm,       std::map<K, T, Pr, Al>& m);
template<class K, class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::map<K, T, Pr, Al>& m);

template<class K, class T, class Pr, class Al>
IStream& operator>> (IStream& stm,       std::multimap<K, T, Pr, Al>& m);
template<class K, class T, class Pr, class Al> 
IStream& operator<< (IStream& stm, const std::multimap<K, T, Pr, Al>& m);


#include "stgio.inl"

#endif /* STGIO_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\stlstuff.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      stlstuff.h
 *
 *  Contents:  Interface file for STL helpers
 *
 *  History:   26-Apr-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef STLSTUFF_H
#define STLSTUFF_H
#pragma once



/*+-------------------------------------------------------------------------*
 * const member function adapters
 *
 * These member function adapters are used to adapt const member functions
 * in the same way that 
 * 
 *      std::mem_fun
 *      std::mem_fun1
 *      std::mem_fun_ref
 *      std::mem_fun_ref1
 * 
 * adapt non-const member functions.
 *--------------------------------------------------------------------------*/

        // TEMPLATE CLASS const_mem_fun_t
template<class _R, class _Ty>
    class const_mem_fun_t : public std::unary_function<_Ty *, _R> {
public:
    explicit const_mem_fun_t(_R (_Ty::*_Pm)() const)
        : _Ptr(_Pm) {}
    _R operator()(_Ty *_P)
        {return ((_P->*_Ptr)()); }
private:
    _R (_Ty::*_Ptr)() const;
    };
        // TEMPLATE FUNCTION const_mem_fun
template<class _R, class _Ty> inline
    const_mem_fun_t<_R, _Ty> const_mem_fun(_R (_Ty::*_Pm)() const)
    {return (const_mem_fun_t<_R, _Ty>(_Pm)); }


        // TEMPLATE CLASS const_mem_fun1_t
template<class _R, class _Ty, class _A>
    class const_mem_fun1_t : public std::binary_function<_Ty *, _A, _R> {
public:
    explicit const_mem_fun1_t(_R (_Ty::*_Pm)(_A) const)
        : _Ptr(_Pm) {}
    _R operator()(_Ty *_P, _A _Arg)
        {return ((_P->*_Ptr)(_Arg)); }
private:
    _R (_Ty::*_Ptr)(_A) const;
    };
        // TEMPLATE FUNCTION const_mem_fun1
template<class _R, class _Ty, class _A> inline
    const_mem_fun1_t<_R, _Ty, _A> const_mem_fun1(_R (_Ty::*_Pm)(_A) const)
    {return (const_mem_fun1_t<_R, _Ty, _A>(_Pm)); }


        // TEMPLATE CLASS const_mem_fun_ref_t
template<class _R, class _Ty>
    class const_mem_fun_ref_t : public std::unary_function<_Ty *, _R> {
public:
    explicit const_mem_fun_ref_t(_R (_Ty::*_Pm)() const)
        : _Ptr(_Pm) {}
    _R operator()(_Ty& _X)
        {return ((_X.*_Ptr)()); }
private:
    _R (_Ty::*_Ptr)() const;
    };
        // TEMPLATE FUNCTION const_mem_fun_ref
template<class _R, class _Ty> inline
    const_mem_fun_ref_t<_R, _Ty> const_mem_fun_ref(_R (_Ty::*_Pm)() const)
    {return (const_mem_fun_ref_t<_R, _Ty>(_Pm)); }


        // TEMPLATE CLASS const_mem_fun1_ref_t
template<class _R, class _Ty, class _A>
    class const_mem_fun1_ref_t : public std::binary_function<_Ty *, _A, _R> {
public:
    explicit const_mem_fun1_ref_t(_R (_Ty::*_Pm)(_A) const)
        : _Ptr(_Pm) {}
    _R operator()(_Ty& _X, _A _Arg)
        {return ((_X.*_Ptr)(_Arg)); }
private:
    _R (_Ty::*_Ptr)(_A) const;
    };
        // TEMPLATE FUNCTION const_mem_fun1_ref
template<class _R, class _Ty, class _A> inline
    const_mem_fun1_ref_t<_R, _Ty, _A> const_mem_fun1_ref(_R (_Ty::*_Pm)(_A) const)
    {return (const_mem_fun1_ref_t<_R, _Ty, _A>(_Pm)); }



#endif /* STLSTUFF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\stddbg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       StdDbg.h
//
//  Contents:   Common debug definitions.
//
//  History:    5/20/1996   RaviR   Created
//
//____________________________________________________________________________

#include "admindbg.h"
#include <tchar.h>      // for _T
#include <string>


//
//  EXAMPLE: A debug file for component SAMPLE, with the debugging tag
//  name "Samp" is defined as shown below:
//
//
//      //
//      //  File:   SampDbg.h
//      //
//
//      #ifndef _SAMPDBG_H_
//      #define _SAMPDBG_H_
//
//      #include "stddbg.h"
//
//      #ifdef DBG
//          DECLARE_DEBUG(Samp)
//          #define DBG_COMP    SampInfoLevel
//      #endif // DBG
//
//      #endif // _SAMPDBG_H_
//


//
//  A corresponding DECLARE_INFOLEVEL(Samp) should be implemented in a .cpp
//  file. This creates a global instance of an CDbg -> SampInfoLevel.
//  SampInfoLevel can be initialized by setting the "Samp" value under reg key
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug
//
//  By defalut it is set to (DEB_ERROR | DEB_WARN)
//


//
//  ------------------------------------------------------------------------
//  Method:     CDbg::DebugOut(debug_level, lpstrfmt, ...);
//
//      Where debug_level is a combination of one or more of the DEB_XXX
//      values defined in admindbg.h. If ((SampInfoLevel & debug_level) != 0)
//      The string lpstrfmt will be printed out to the debugger.
//
//  ------------------------------------------------------------------------
//  Method:     DebugMsg(file, line, message)
//
//      Force output the <file, line, message>.
//
//  ------------------------------------------------------------------------
//


#ifndef __STDDBG_HXX__
#define __STDDBG_HXX__

//
//  C++ files redefine THIS_FILE by adding the following two lines:
//
//      #undef THIS_FILE
//      static char THIS_FILE[] = __FILE__;
//

#define THIS_FILE       __FILE__

#define DEB_RESOURCE    DEB_USER10      // Constructor/Destructor
#define DEB_METHOD      DEB_USER11
#define DEB_FUNCTION    DEB_USER12

#undef  ASSERT
#undef  VERIFY


#ifdef DBG

    #define Dbg                         DBG_COMP.DebugOut

    // Heap checking
    extern  DWORD dwHeapChecking;
    #define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

    #define DEBUGCHECK \
        if ( (dwHeapChecking & 0x1) == 0x1 ) \
        { \
            HeapValidate(GetProcessHeap(),0,NULL); \
        } else 1

    
    // Debug messages
    #define TRACE_CONSTRUCTOR(cls) \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this);

    #define TRACE_DESTRUCTOR(cls) \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this);

    #define TRACE_METHOD(Class, Method) \
        DEBUGCHECK; \
        Dbg(DEB_METHOD, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this);

    #define TRACE_FUNCTION(Function) \
        DEBUGCHECK; \
        Dbg(DEB_FUNCTION, _T(#Function) _T("\n"));

    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            DBG_COMP.DebugErrorX(THIS_FILE, __LINE__, hr); \
        } else 1

    #define CHECK_LASTERROR(lr) \
        if ( lr != ERROR_SUCCESS ) \
        { \
            DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, lr); \
        } else 1

    #define DBG_OUT_LASTERROR \
        DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, GetLastError());

    #define ASSERTMSG(x)   \
        (void)((x) || (DBG_COMP.DebugMsg(THIS_FILE, __LINE__, _T(#x)),0))

    #define VERIFYMSG(e)   ASSERTMSG(e)

    #define ASSERT(x)   Win4Assert(x)
    #define VERIFY(x)   Win4Assert(x)

    /*
     * COMPILETIME_ASSERT(f)
     *
     * Generates a build break at compile time if the constant expression
     * is not true.  Unlike the "#if" compile-time directive, the expression
     * in COMPILETIME_ASSERT() is allowed to use "sizeof".
     *
     * Compiler magic!  If the expression "f" is FALSE, then you get 
     * 
     *      error C2196: case value '0' already used
     */
    #define COMPILETIME_ASSERT(f) switch (0) case 0: case f: break;


#else

    inline void __DummyDbg(ULONG, LPCWSTR, ...) { }
    inline void __DummyDbg(ULONG, LPCSTR, ...) { }
    #define Dbg             1 ? (void)0 : ::__DummyDbg

    inline void __DummyTrace(LPCWSTR, ...) { }
    inline void __DummyTrace(LPCSTR, ...) { }

    #define TRACE_SCOPE(x)

    #define DECLARE_HEAPCHECKING
    #define DEBUGCHECK

    #define TRACE_CONSTRUCTOR(cls)
    #define TRACE_DESTRUCTOR(cls)
    #define TRACE_METHOD(ClassName,MethodName)
    #define TRACE_FUNCTION(FunctionName)

    #define CHECK_HRESULT(hr)
    #define CHECK_LASTERROR(lr)

    #define DBG_OUT_LASTERROR

    #define ASSERTMSG(e)
    #define VERIFYMSG(e)   (e)

    #define ASSERT(e)
    #define VERIFY(e)   (e)
    #define COMPILETIME_ASSERT(f)

#endif // DBG


#ifdef DBG

    /*
     * this is a roundabout way of getting this accomplished (real impl is
     * in stddbg.cpp), but it gets around a compiler bug that won't allow
     * us to ignore C4786.
     */
    struct CDebugLeakDetectorBase
    {
        virtual ~CDebugLeakDetectorBase() = 0 {};

        virtual void DumpLeaks() = 0;
        virtual int AddRef(const std::string& strClass) = 0;
        virtual int Release(const std::string& strClass) = 0;
    };

    extern CDebugLeakDetectorBase& GetLeakDetector();

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    GetLeakDetector().AddRef(#cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    GetLeakDetector().Release(#cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)

#else

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    

#endif 





#ifdef UNICODE
#define DBGSTRING %ls
#else
#define DBGSTRING %s
#endif


#define SAFEDBGBSTR(x) ((x==NULL)?L"<NULL>":x)
#define SAFEDBGTCHAR(x) ((x==NULL)?_T("<NULL>"):x)


#define ASSERT_OBJECTPTR(x) ASSERT( NULL == (x) || !::IsBadWritePtr(x,sizeof(x)) );
#define ASSERT_STRINGPTR(x) ASSERT( NULL == (x) || AfxIsValidStringPtr(x) );
#define FREE_OBJECTPTR(x) { ASSERT_OBJECTPTR(x); delete x; x = NULL; }

#ifdef DBG

class CTraceTag;
class tstring;

struct DBG_PersistTraceData
{
    DBG_PersistTraceData();
  
    void TraceErr(LPCTSTR strInterface, LPCTSTR msg);
    typedef void (*PTraceErrorFn)(LPCTSTR szError);

    void SetTraceInfo(PTraceErrorFn pFN, bool bComponent, const tstring& owner);

    PTraceErrorFn pTraceFN;
    bool       bIComponent;
    bool       bIComponentData;
    // cannot use tstring - it cannot be defined here
    // since this file is included at the top of tstring.h
#ifdef UNICODE
    std::wstring    strSnapin;
#else
    std::string     strSnapin;
#endif
};

#endif // DBG

#endif // __STDDBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------

#ifndef STRINGS_H_INCLUDED
#define STRINGS_H_INCLUDED
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef INIT_MMC_BASE_STRINGS
#define MMC_BASE_STRING_EX(var,t_lit) EXTERN_C LPCTSTR const var = t_lit;
#else
#define MMC_BASE_STRING_EX(var,t_lit) EXTERN_C LPCTSTR const var;
#endif

#define MMC_BASE_STRING(var,lit) MMC_BASE_STRING_EX(var, _T(lit));

MMC_BASE_STRING (  g_szMmcndmgrDll,                 "mmcndmgr.dll" );
MMC_BASE_STRING (  g_szCicDll,                      "cic.dll" );
MMC_BASE_STRING (  g_szCLSID ,                      "CLSID" );
MMC_BASE_STRING (  g_szContextMenu ,                "ContextMenu" );
MMC_BASE_STRING (  g_szImage ,                      "Image" );
MMC_BASE_STRING (  g_szImageOpen ,                  "ImageOpen" );
MMC_BASE_STRING (  g_szImageClosed ,                "ImageClosed" );
MMC_BASE_STRING (  g_szName ,                       "Name" );
MMC_BASE_STRING (  g_szNameString ,                 "NameString" );
MMC_BASE_STRING (  g_szNameStringIndirect ,         "NameStringIndirect" );
MMC_BASE_STRING (  g_szObject ,                     "Object" );
MMC_BASE_STRING (  g_szObjects ,                    "Objects" );
MMC_BASE_STRING (  g_szObjectType ,                 "ObjectType" );
MMC_BASE_STRING (  g_szObjectTypes ,                "ObjectTypes" );
MMC_BASE_STRING (  g_szObjectTypeGUID ,             "ObjectTypeGUID" );
MMC_BASE_STRING (  g_szObjectContext ,              "ObjectContext" );
MMC_BASE_STRING (  g_szPackage ,                    "Package" );
MMC_BASE_STRING (  g_szResultPane ,                 "ResultPane" );
MMC_BASE_STRING (  g_szStatus ,                     "Status" );
MMC_BASE_STRING (  g_szStatusString ,               "StatusString" );
MMC_BASE_STRING (  g_szTree ,                       "Tree" );
MMC_BASE_STRING (  g_szNameSpace ,                  "NameSpace" );
MMC_BASE_STRING (  g_szNodeType ,                   "NodeType" );
MMC_BASE_STRING (  g_szNodeTypes ,                  "NodeTypes" );
MMC_BASE_STRING (  g_szPropertySheet ,              "PropertySheet" );
MMC_BASE_STRING (  g_szStandAlone ,                 "StandAlone" );
MMC_BASE_STRING (  g_szToolbar ,                    "Toolbar" );
MMC_BASE_STRING (  g_szExtensions ,                 "Extensions" );
MMC_BASE_STRING (  g_szTask ,                       "Task" );
MMC_BASE_STRING (  g_szAbout ,                      "About" );
MMC_BASE_STRING (  g_szView ,                       "View" );     // registry key for view extension snapins
MMC_BASE_STRING (  g_szDynamicExtensions ,          "Dynamic Extensions" );
MMC_BASE_STRING (  g_szRestrictAuthorMode ,         "RestrictAuthorMode" );
MMC_BASE_STRING (  g_szRestrictToPermittedList ,    "RestrictToPermittedSnapins" );
MMC_BASE_STRING (  g_szRestrictRun ,                "Restrict_Run" );
MMC_BASE_STRING (  g_szRestrictScriptsFromEnteringAuthorMode ,  "RestrictScriptsEnteringAuthorMode" );
MMC_BASE_STRING (  g_szMaxColumnDataPersisted ,     "MaxColDataPersisted" );
MMC_BASE_STRING (  g_szMaxViewItemsPersisted ,      "MaxViewItemsPersisted" );
MMC_BASE_STRING (  g_szDEFAULT_CONSOLE_EXTENSION ,  ".msc" );

// window class name for the MDI child frame
MMC_BASE_STRING (  g_szChildFrameClassName ,        "MMCChildFrm" );
MMC_BASE_STRING (  g_szAMCViewWndClassName ,        "MMCViewWindow" );
MMC_BASE_STRING (  g_szOCXViewWndClassName ,        "MMCOCXViewWindow" );

MMC_BASE_STRING (  CURRENT_VER_KEY ,                "Software\\Microsoft\\Windows NT\\CurrentVersion" );
MMC_BASE_STRING (  NODE_TYPES_KEY ,                 "Software\\Microsoft\\MMC\\NodeTypes" );
MMC_BASE_STRING (  SNAPINS_KEY ,                    "Software\\Microsoft\\MMC\\SnapIns" );
MMC_BASE_STRING (  SETTINGS_KEY ,                   "Software\\Microsoft\\MMC\\Settings" );
MMC_BASE_STRING (  POLICY_KEY ,                     "Software\\Policies\\Microsoft\\MMC" );

// user data subfolder
MMC_BASE_STRING (  g_szUserDataSubFolder,           "Microsoft\\MMC" );

// XML tags and attribute names used

/*-----------------------------------------------------------------------------------*\
|   Following strings used as element tags in XML document
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( XML_TAG_BOOKMARK ,                "BookMark" );
MMC_BASE_STRING ( XML_TAG_BINARY ,                  "Binary" );
MMC_BASE_STRING ( XML_TAG_BINARY_STORAGE ,          "BinaryStorage" );
MMC_BASE_STRING ( XML_TAG_BITMAP ,                  "Bitmap" );
MMC_BASE_STRING ( XML_TAG_COLUMN_INFO ,             "Column" );
MMC_BASE_STRING ( XML_TAG_COLUMN_INFO_LIST ,        "ColumnSettings" );
MMC_BASE_STRING ( XML_TAG_COLUMN_PERIST_INFO ,      "ColumnSettingsCache" );
MMC_BASE_STRING ( XML_TAG_COLUMN_PERIST_ENTRY ,     "SnapinColumnSettings" );
MMC_BASE_STRING ( XML_TAG_COLUMN_SET ,              "ColumnSet" );
MMC_BASE_STRING ( XML_TAG_COLUMN_SET_DATA ,         "ListViewColumns" );
MMC_BASE_STRING ( XML_TAG_COLUMN_SORT_INFO ,        "SortSettings" );
MMC_BASE_STRING ( XML_TAG_CONSOLE_ICON ,            "Image" );
MMC_BASE_STRING ( XML_TAG_CONSOLE_FILE_UID ,        "ConsoleFileID" );
MMC_BASE_STRING ( XML_TAG_CONSOLE_TASKPAD ,         "ConsoleTaskpad" );
MMC_BASE_STRING ( XML_TAG_CONSOLE_TASKPADS ,        "ConsoleTaskpads" );
MMC_BASE_STRING ( XML_TAG_CUSTOM_DATA ,             "VisualAttributes" );
MMC_BASE_STRING ( XML_TAG_DYNAMIC_PATH_ENTRY ,      "Segment" );
MMC_BASE_STRING ( XML_TAG_EOT_SYMBOL_INFO ,         "Symbol" );
MMC_BASE_STRING ( XML_TAG_LARGE_TASK_ICON ,         "LargeIcon" );
MMC_BASE_STRING ( XML_TAG_SMALL_TASK_ICON ,         "SmallIcon" );
MMC_BASE_STRING ( XML_TAG_FAVORITES_ENTRY ,         "Favorite" );
MMC_BASE_STRING ( XML_TAG_FAVORITES_LIST ,          "Favorites" );
MMC_BASE_STRING ( XML_TAG_FRAME_STATE ,             "FrameState" );
MMC_BASE_STRING ( XML_TAG_HASH_VALUE ,              "HashValue" );
MMC_BASE_STRING ( XML_TAG_ICOMPONENT ,              "Component" );
MMC_BASE_STRING ( XML_TAG_ICOMPONENT_LIST ,         "Components" );
MMC_BASE_STRING ( XML_TAG_ICOMPONENT_DATA ,         "ComponentData" );
MMC_BASE_STRING ( XML_TAG_ICOMPONENT_DATA_LIST ,    "ComponentDatas" );
MMC_BASE_STRING ( XML_TAG_ICON ,                    "Icon" );
MMC_BASE_STRING ( XML_TAG_IDENTIFIER_POOL ,         "IdentifierPool" );
MMC_BASE_STRING ( XML_TAG_ISTORAGE ,                "Storage" );
MMC_BASE_STRING ( XML_TAG_ISTREAM ,                 "Stream" );
MMC_BASE_STRING ( XML_TAG_MEMENTO ,                 "ViewMemento" );
MMC_BASE_STRING ( XML_TAG_MMC_CONSOLE_FILE ,        "MMC_ConsoleFile" );
MMC_BASE_STRING ( XML_TAG_MMC_STRING_TABLE ,        "StringTables" );
MMC_BASE_STRING ( XML_TAG_MT_NODE ,                 "Node" );
MMC_BASE_STRING ( XML_TAG_NODE_BITMAPS ,            "Bitmaps" );
MMC_BASE_STRING ( XML_TAG_ORIGINAL_CONSOLE_CRC ,    "SourceChecksum" );
MMC_BASE_STRING ( XML_TAG_POINT ,                   "Point" );
MMC_BASE_STRING ( XML_TAG_RECTANGLE ,               "Rectangle" );
MMC_BASE_STRING ( XML_TAG_RESULTVIEW_DESCRIPTION,   "Description" );
MMC_BASE_STRING ( XML_TAG_SCOPE_TREE ,              "ScopeTree" );
MMC_BASE_STRING ( XML_TAG_SCOPE_TREE_NODES ,        "Nodes" );
MMC_BASE_STRING ( XML_TAG_SNAPIN ,                  "Snapin" );
MMC_BASE_STRING ( XML_TAG_SNAPIN_CACHE ,            "SnapinCache" );
MMC_BASE_STRING ( XML_TAG_SNAPIN_EXTENSION ,        "Extension" );
MMC_BASE_STRING ( XML_TAG_SNAPIN_EXTENSIONS ,       "Extensions" );
MMC_BASE_STRING ( XML_TAG_SNAPIN_PROPERTIES ,       "SnapinProperties" );
MMC_BASE_STRING ( XML_TAG_SNAPIN_PROPERTY ,         "SnapinProperty" );
MMC_BASE_STRING ( XML_TAG_STRING_TABLE ,            "Strings" );
MMC_BASE_STRING ( XML_TAG_STRING_TABLE_MAP ,        "StringTable" );
MMC_BASE_STRING ( XML_TAG_STRING_TABLE_STRING ,     "String" );
MMC_BASE_STRING ( XML_TAG_TASK ,                    "Task" );
MMC_BASE_STRING ( XML_TAG_TASK_CMD_LINE ,           "CommandLine" );
MMC_BASE_STRING ( XML_TAG_TASK_LIST ,               "Tasks" );
MMC_BASE_STRING ( XML_TAG_VALUE_BIN_DATA ,          "BinaryData" );
MMC_BASE_STRING ( XML_TAG_VALUE_BOOL ,              "Boolean" );
MMC_BASE_STRING ( XML_TAG_VALUE_BYTE ,              "Byte" );
MMC_BASE_STRING ( XML_TAG_VALUE_CSTR ,              "String" );
MMC_BASE_STRING ( XML_TAG_VALUE_DWORD ,             "DoubleWord" );
MMC_BASE_STRING ( XML_TAG_VALUE_GUID ,              "GUID" );
MMC_BASE_STRING ( XML_TAG_VALUE_INT ,               "Integer" );
MMC_BASE_STRING ( XML_TAG_VALUE_LONG ,              "Long" );
MMC_BASE_STRING ( XML_TAG_VALUE_SHORT ,             "Short" );
MMC_BASE_STRING ( XML_TAG_VALUE_UINT ,              "UnsignedInteger" );
MMC_BASE_STRING ( XML_TAG_VALUE_ULONG ,             "UsignedLong" );
MMC_BASE_STRING ( XML_TAG_VALUE_UNKNOWN ,           "Unknown" );
MMC_BASE_STRING ( XML_TAG_VALUE_WSTRING ,           "WideString" );
MMC_BASE_STRING ( XML_TAG_VARIANT ,                 "VARIANT" );
MMC_BASE_STRING ( XML_TAG_VIEW ,                    "View" );
MMC_BASE_STRING ( XML_TAG_VIEW_LIST ,               "Views" );
MMC_BASE_STRING ( XML_TAG_VIEW_PERSIST_INFO ,       "ViewSettingsCache" );
MMC_BASE_STRING ( XML_TAG_VIEW_SETTINGS ,           "ViewSettings" );
MMC_BASE_STRING ( XML_TAG_VIEW_SETTINGS_2 ,         "ViewOptions" );
MMC_BASE_STRING ( XML_TAG_VIEW_SETTINGS_ID ,        "TargetView" );
MMC_BASE_STRING ( XML_TAG_WINDOW_PLACEMENT ,        "WindowPlacement" );
MMC_BASE_STRING ( XML_TAG_RESULTVIEWTYPE ,          "ResultView" );

/*-----------------------------------------------------------------------------------*\
|   Following strings used as element names in XML ( put as value of attribute 'NAME')
|   This helps in cases we need differentiate between elements of the same type
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( XML_NAME_CLSID_SNAPIN ,           "Snapin" );
MMC_BASE_STRING ( XML_NAME_ICON_LARGE ,             "Large" );
MMC_BASE_STRING ( XML_NAME_ICON_SMALL ,             "Small" );
MMC_BASE_STRING ( XML_NAME_MAX_POSITION ,           "MaxPosition" );
MMC_BASE_STRING ( XML_NAME_MIN_POSITION ,           "MinPosition" );
MMC_BASE_STRING ( XML_NAME_NODE_BITMAP_LARGE ,      "Large" );
MMC_BASE_STRING ( XML_NAME_NODE_BITMAP_SMALL ,      "Small" );
MMC_BASE_STRING ( XML_NAME_NODE_BITMAP_SMALL_OPEN , "SmallOpen" );
MMC_BASE_STRING ( XML_NAME_NORMAL_POSITION ,        "NormalPosition" );
MMC_BASE_STRING ( XML_NAME_ROOT_NODE ,              "RootNode" );
MMC_BASE_STRING ( XML_NAME_SELECTED_NODE ,          "SelectedNode" );
MMC_BASE_STRING ( XML_NAME_TARGET_NODE ,            "TargetNode" );

/*-----------------------------------------------------------------------------------*\
|   Following strings used as attribute names in XML document
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( XML_ATTR_CONSOLE_VERSION ,        "ConsoleVersion" );
MMC_BASE_STRING ( XML_ATTR_APPLICATION_MODE ,       "ProgramMode" );
MMC_BASE_STRING ( XML_ATTR_BINARY_REF_INDEX ,       "BinaryRefIndex" );
MMC_BASE_STRING ( XML_ATTR_BOOKMARK_DYN_CUSTOM ,    "Custom" );
MMC_BASE_STRING ( XML_ATTR_BOOKMARK_DYN_STRING ,    "String" );
MMC_BASE_STRING ( XML_ATTR_BOOKMARK_DYNAMIC_PATH ,  "DynamicPath" );
MMC_BASE_STRING ( XML_ATTR_BOOKMARK_STATIC ,        "NodeID" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_INFO_COLUMN ,     "Index" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_INFO_FORMAT ,     "Format" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_INFO_WIDTH ,      "Width" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_INFO_SNAPIN ,     "Snapin" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SET_RANK ,        "Age" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SET_ID ,          "ID" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SET_ID_VIEW ,     "ViewID" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SET_ID_FLAGS ,    "Flags" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SET_ID_PATH ,     "ID" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SORT_INFO_COLMN , "ColumnIndex" );
MMC_BASE_STRING ( XML_ATTR_COLUMN_SORT_INFO_OPTNS , "SortOptions" );
MMC_BASE_STRING ( XML_ATTR_CONSOLE_ICON_LARGE ,     "CONSOLE_FILE_ICON_LARGE" );
MMC_BASE_STRING ( XML_ATTR_CONSOLE_ICON_SMALL ,     "CONSOLE_FILE_ICON_SMALL" );
MMC_BASE_STRING ( XML_ATTR_CUSTOM_TITLE ,           "ApplicationTitle" );
MMC_BASE_STRING ( XML_ATTR_EOT_SYMBOL_DW_SYMBOL ,   "ID" );
MMC_BASE_STRING ( XML_ATTR_FAVORITE_TYPE ,          "TYPE" );
MMC_BASE_STRING ( XML_ATTR_FRAME_STATE_FLAGS ,      "Flags" );
MMC_BASE_STRING ( XML_ATTR_ICOMPONENT_VIEW_ID ,     "ViewID" );
MMC_BASE_STRING ( XML_ATTR_ICON_FILE ,              "File" );
MMC_BASE_STRING ( XML_ATTR_ICON_INDEX ,             "Index" );
MMC_BASE_STRING ( XML_ATTR_ID_POOL_ABSOLUTE_MAX ,   "AbsoluteMax" );
MMC_BASE_STRING ( XML_ATTR_ID_POOL_ABSOLUTE_MIN ,   "AbsoluteMin" );
MMC_BASE_STRING ( XML_ATTR_ID_POOL_NEXT_AVAILABLE , "NextAvailable" );
MMC_BASE_STRING ( XML_ATTR_MT_NODE_ID ,             "ID" );
MMC_BASE_STRING ( XML_ATTR_MT_NODE_IMAGE ,          "ImageIdx" );
MMC_BASE_STRING ( XML_ATTR_MT_NODE_NAME ,           "Name" );
MMC_BASE_STRING ( XML_ATTR_MT_NODE_PRELOAD ,        "Preload" );
MMC_BASE_STRING ( XML_ATTR_MT_NODE_SNAPIN_CLSID ,   "CLSID" );
MMC_BASE_STRING ( XML_ATTR_NAME ,                   "Name" );
MMC_BASE_STRING ( XML_ATTR_NODE_BITMAPS_MASK ,      "MaskColor" );
MMC_BASE_STRING ( XML_ATTR_POINT_X ,                "X" );
MMC_BASE_STRING ( XML_ATTR_POINT_Y ,                "Y" );
MMC_BASE_STRING ( XML_ATTR_RECT_BOTTOM ,            "Bottom" );
MMC_BASE_STRING ( XML_ATTR_RECT_LEFT ,              "Left" );
MMC_BASE_STRING ( XML_ATTR_RECT_RIGHT ,             "Right" );
MMC_BASE_STRING ( XML_ATTR_RECT_TOP ,               "Top" );
MMC_BASE_STRING ( XML_ATTR_SHOW_COMMAND ,           "ShowCommand" );
MMC_BASE_STRING ( XML_ATTR_SNAPIN_CLSID ,           "CLSID" );
MMC_BASE_STRING ( XML_ATTR_SNAPIN_EXTN_ENABLED ,    "AllExtensionsEnabled" );
MMC_BASE_STRING ( XML_ATTR_SNAPIN_EXTN_TYPES ,      "ExtensionTypes" );
MMC_BASE_STRING ( XML_ATTR_SNAPIN_PROP_FLAGS ,      "Flags" );
MMC_BASE_STRING ( XML_ATTR_SNAPIN_PROP_NAME ,       "Name" );
MMC_BASE_STRING ( XML_ATTR_STRING_TABLE_STR_ID ,    "ID" );
MMC_BASE_STRING ( XML_ATTR_STRING_TABLE_STR_VALUE,  "Value" );
MMC_BASE_STRING ( XML_ATTR_STRING_TABLE_STR_REFS ,  "Refs" );
MMC_BASE_STRING ( XML_ATTR_TASK_CMD_LINE_DIR ,      "Directory" );
MMC_BASE_STRING ( XML_ATTR_TASK_CMD_LINE_PARAMS ,   "Params" );
MMC_BASE_STRING ( XML_ATTR_TASK_CMD_LINE_WIN_ST ,   "WindowState" );
MMC_BASE_STRING ( XML_ATTR_TASK_COMMAND ,           "Command" );
MMC_BASE_STRING ( XML_ATTR_TASK_DESCRIPTION ,       "Description" );
MMC_BASE_STRING ( XML_ATTR_TASK_FLAGS ,             "Flags" );
MMC_BASE_STRING ( XML_ATTR_TASK_NAME ,              "Name" );
MMC_BASE_STRING ( XML_ATTR_TASK_TYPE ,              "Type" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_DESCRIPTION ,    "Description" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_ID ,             "ID" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_NAME ,           "Name" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_NODE_SPECIFIC ,  "IsNodeSpecific" );
MMC_BASE_STRING ( XML_ATTR_REPLACES_DEFAULT_VIEW ,  "ReplacesDefaultView" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_NODE_TYPE ,      "NodeType" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_ORIENTATION ,    "Orientation" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_TOOLTIP ,        "Tooltip" );
MMC_BASE_STRING ( XML_ATTR_TASKPAD_LIST_SIZE,       "ListSize");
MMC_BASE_STRING ( XML_ENUM_LIST_SIZE_LARGE ,        "Large" );
MMC_BASE_STRING ( XML_ENUM_LIST_SIZE_MEDIUM ,       "Medium" );
MMC_BASE_STRING ( XML_ENUM_LIST_SIZE_NONE ,         "None" );
MMC_BASE_STRING ( XML_ENUM_LIST_SIZE_SMALL ,        "Small" );
MMC_BASE_STRING ( XML_ATTR_VARIANT_TYPE ,           "Type" );
MMC_BASE_STRING ( XML_ATTR_VARIANT_VALUE ,          "Value" );
MMC_BASE_STRING ( XML_ATTR_VIEW_ID ,                "ID" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SCOPE_WIDTH ,       "ScopePaneWidth" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_DB_VISIBLE , "DescriptionBarVisible" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_DEF_COL_W0 , "DefaultColumn0Width" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_DEF_COL_W1 , "DefaultColumn1Width" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_FLAG ,       "Flags" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_LIST_STYLE , "ListStyle" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETNGS_VIEW_MODE ,  "ViewMode" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETTINGS_ID_VIEW ,  "ViewID" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETTINGS_MASK ,     "Contents" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETTINGS_OPTIONS ,  "Options" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETTINGS_RANK ,     "Age" );
MMC_BASE_STRING ( XML_ATTR_VIEW_SETTINGS_TYPE ,     "Type" );
MMC_BASE_STRING ( XML_ATTR_WIN_PLACEMENT_FLAGS ,    "Flags" );
MMC_BASE_STRING ( XML_ATTR_RESULTVIEWTYPE_OPTIONS ,      "Options" );
MMC_BASE_STRING ( XML_ATTR_RESULTVIEWTYPE_MISC_OPTIONS , "MiscOptions" );
MMC_BASE_STRING ( XML_ATTR_RESULTVIEWTYPE_OCX_STRING ,   "OCX" );
MMC_BASE_STRING ( XML_ATTR_RESULTVIEWTYPE_URL_STRING ,   "URL" );
MMC_BASE_STRING ( XML_ATTR_SOURCE_INDEX,                 "SourceIndex");           // used to compress user state files
MMC_BASE_STRING ( XML_ATTR_NODETYPE_GUID,            "NodeTypeGUID");



/*-----------------------------------------------------------------------------------*\
|   Following strings used as enumerations
\*-----------------------------------------------------------------------------------*/


MMC_BASE_STRING ( XML_ENUM_FSTATE_SHOWSTATUSBAR,                "ShowStatusBar" );
MMC_BASE_STRING ( XML_ENUM_FSTATE_HELPDOCINVALID,               "HelpDocInvalid" );
MMC_BASE_STRING ( XML_ENUM_FSTATE_LOGICALREADONLY,              "LogicalReadOnly" );
MMC_BASE_STRING ( XML_ENUM_FSTATE_PREVENTVIEWCUSTOMIZATION,     "PreventViewCustomization" );

MMC_BASE_STRING ( XML_ENUM_PROGRAM_MODE_AUTHOR,                 "Author" );
MMC_BASE_STRING ( XML_ENUM_PROGRAM_MODE_USER,                   "User" );
MMC_BASE_STRING ( XML_ENUM_PROGRAM_MODE_USER_MDI,               "UserMDI" );
MMC_BASE_STRING ( XML_ENUM_PROGRAM_MODE_USER_SDI,               "UserSDI" );

MMC_BASE_STRING ( XML_ENUM_LV_STYLE_ICON,                       "Icon" );
MMC_BASE_STRING ( XML_ENUM_LV_STYLE_SMALLICON,                  "SmallIcon" );
MMC_BASE_STRING ( XML_ENUM_LV_STYLE_LIST,                       "List" );
MMC_BASE_STRING ( XML_ENUM_LV_STYLE_REPORT,                     "Report" );
MMC_BASE_STRING ( XML_ENUM_LV_STYLE_FILTERED,                   "Filtered");

MMC_BASE_STRING ( XML_ENUM_TASK_TYPE_SCOPE,                     "Scope" );
MMC_BASE_STRING ( XML_ENUM_TASK_TYPE_RESULT,                    "Result" );
MMC_BASE_STRING ( XML_ENUM_TASK_TYPE_COMMANDLINE,               "CommandLine" );
MMC_BASE_STRING ( XML_ENUM_TASK_TYPE_TARGET,                    "Target" );
MMC_BASE_STRING ( XML_ENUM_TASK_TYPE_FAVORITE,                  "Favorite" ) ;

MMC_BASE_STRING ( XML_ENUM_WINDOW_STATE_RESTORED,               "Restored" ) ;
MMC_BASE_STRING ( XML_ENUM_WINDOW_STATE_MINIMIZED,              "Minimized" ) ;
MMC_BASE_STRING ( XML_ENUM_WINDOW_STATE_MAXIMIZED,              "Maximized" ) ;

MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_HIDE,                       "SW_HIDE" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWNORMAL,                 "SW_SHOWNORMAL" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWMINIMIZED,              "SW_SHOWMINIMIZED" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWMAXIMIZED,              "SW_SHOWMAXIMIZED" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWNOACTIVATE,             "SW_SHOWNOACTIVATE" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOW,                       "SW_SHOW" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_MINIMIZE,                   "SW_MINIMIZE" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWMINNOACTIVE,            "SW_SHOWMINNOACTIVE" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWNA,                     "SW_SHOWNA" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_RESTORE,                    "SW_RESTORE" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_SHOWDEFAULT,                "SW_SHOWDEFAULT" );
MMC_BASE_STRING ( XML_ENUM_SHOW_CMD_FORCEMINIMIZE,              "SW_FORCEMINIMIZE" );

MMC_BASE_STRING ( XML_ENUM_WIN_PLACE_SETMINPOSITION,            "WPF_SETMINPOSITION" );
MMC_BASE_STRING ( XML_ENUM_WIN_PLACE_RESTORETOMAXIMIZED,        "WPF_RESTORETOMAXIMIZED" );
MMC_BASE_STRING ( XML_ENUM_WIN_PLACE_ASYNCWINDOWPLACEMENT,      "WPF_ASYNCWINDOWPLACEMENT" );

MMC_BASE_STRING ( XML_ENUM_MMC_VIEW_TYPE_LIST,                  "List" );
MMC_BASE_STRING ( XML_ENUM_MMC_VIEW_TYPE_HTML,                  "HTML" );
MMC_BASE_STRING ( XML_ENUM_MMC_VIEW_TYPE_OCX,                   "OCX" );

MMC_BASE_STRING ( XML_ENUM_COL_INFO_LVCFMT_LEFT,                "Left" );
MMC_BASE_STRING ( XML_ENUM_COL_INFO_LVCFMT_RIGHT,               "Right" );
MMC_BASE_STRING ( XML_ENUM_COL_INFO_LVCFMT_CENTER,              "Center" );

/*-----------------------------------------------------------------------------------*\
|   Following strings used as bitflags
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_SINGLESEL,           "LVS_SINGLESEL" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_SHOWSELALWAYS,       "LVS_SHOWSELALWAYS" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_SORTASCENDING,       "LVS_SORTASCENDING" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_SORTDESCENDING,      "LVS_SORTDESCENDING" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_SHAREIMAGELISTS,     "LVS_SHAREIMAGELISTS" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_NOLABELWRAP,         "LVS_NOLABELWRAP" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_AUTOARRANGE,         "LVS_AUTOARRANGE" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_EDITLABELS,          "LVS_EDITLABELS" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_OWNERDATA,           "LVS_OWNERDATA" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_NOSCROLL,            "LVS_NOSCROLL" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_ALIGNLEFT,           "LVS_ALIGNLEFT" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_OWNERDRAWFIXED,      "LVS_OWNERDRAWFIXED" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_NOCOLUMNHEADER,      "LVS_NOCOLUMNHEADER" );
MMC_BASE_STRING ( XML_BITFLAG_LV_STYLE_NOSORTHEADER,        "LVS_NOSORTHEADER" );

MMC_BASE_STRING ( XML_BITFLAG_VIEW_SCOPE_PANE_VISIBLE,      "ScopePaneVisible" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_STD_MENUS,            "NoStdMenus" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_STD_BUTTONS,          "NoStdButtons" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_SNAPIN_MENUS,         "NoSnapinMenus" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_SNAPIN_BUTTONS,       "NoSnapinButtons" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_DISABLE_SCOPEPANE,       "DisableScopePane" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_DISABLE_STD_TOOLBARS,    "DisableStdToolbars" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_CUSTOM_TITLE,            "CustomTitle" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_STATUS_BAR,           "NoStatusBar" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_CREATED_IN_USER_MODE,    "CreatedInUserMode" );
MMC_BASE_STRING ( XML_BITFLAG_VIEW_NO_TASKPAD_TABS,         "NoTaskpadTabs" );

MMC_BASE_STRING ( XML_BITFLAG_VIEWSET_MASK_VIEWMODE,        "Flag_ViewMode" );
MMC_BASE_STRING ( XML_BITFLAG_VIEWSET_MASK_RVTYPE,          "Flag_ResultView" );
MMC_BASE_STRING ( XML_BITFLAG_VIEWSET_MASK_TASKPADID,       "Flag_TaskPadID" );

MMC_BASE_STRING ( XML_BITFLAG_TASK_DISABLED,                "eFlag_Disabled" );

MMC_BASE_STRING ( XML_BITFLAG_TASK_ORIENT_HORIZONTAL,       "Horizontal" );
MMC_BASE_STRING ( XML_BITFLAG_TASK_ORIENT_VERTICAL,         "Vertical" );
MMC_BASE_STRING ( XML_BITFLAG_TASK_ORIENT_NO_RESULTS,       "NoResults" );
MMC_BASE_STRING ( XML_BITFLAG_TASK_ORIENT_DESCRIPTIONS_AS_TEXT, "DescriptionsAsText" );

MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_OWNERDATALIST,   "ListView_OwnerDrawList" );
MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_MULTISELECT,     "ListView_MultiSelect" );
MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_FILTERED,        "ListView_Filtered" );
MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_USEFONTLINKING,  "ListView_UseFontLinking" );
MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_NO_SCOPE_ITEMS,  "ListView_NoScopeItems" );
MMC_BASE_STRING ( XML_BITFLAG_LIST_OPTIONS_LEXICAL_SORT,    "ListView_LexicalSort" );

MMC_BASE_STRING ( XML_BITFLAG_OCX_OPTIONS_CACHE_OCX,        "OCX_CacheControl" );

MMC_BASE_STRING ( XML_BITFLAG_MISC_OPTIONS_NOLISTVIEWS,     "Misc_NoListViews" );

MMC_BASE_STRING ( XML_BITFLAG_COL_SORT_DESCENDING,          "RSI_DESCENDING" );
MMC_BASE_STRING ( XML_BITFLAG_COL_SORT_NOSORTICON,          "RSI_NOSORTICON" );

/*-----------------------------------------------------------------------------------*\
|   Following strings used as fixed attribute values ( such as enumerations)
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( XML_VAL_FAVORITE_GROUP ,  "Group" );
MMC_BASE_STRING ( XML_VAL_FAVORITE_SINGLE , "Single" );
MMC_BASE_STRING ( XML_VAL_BOOL_TRUE ,       "true" );
MMC_BASE_STRING ( XML_VAL_BOOL_FALSE,       "false" );

/*-----------------------------------------------------------------------------------*\
|   END - XML
\*-----------------------------------------------------------------------------------*/

MMC_BASE_STRING ( CHARSET_RAW_UNICODE ,        "ISO-10646-UCS-2" );
MMC_BASE_STRING ( CHARSET_COMPRESSED_UNICODE , "UTF-8" );

#define MMC_PROTOCOL_SCHEMA_NAME "--mmc"
#define MMC_PAGEBREAK_RELATIVE_URL "pagebreak."

MMC_BASE_STRING_EX ( PAGEBREAK_URL, _T(MMC_PROTOCOL_SCHEMA_NAME) _T(":") _T(MMC_PAGEBREAK_RELATIVE_URL) );

// define macros to declare a wide literal (need two levels - won't work with defines else)
#define __W(x)      L ## x
#define _W(x)      __W(x)

#endif // STRINGS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\tiedobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tiedobj.h
//
//  History:    08/28/1999 VivekJ Created
//--------------------------------------------------------------------------

#ifndef TIEDOBJ_H
#define TIEDOBJ_H
#pragma once

#include "conuistr.h" // for MMC_E_OBJECT_IS_GONE

/************************************************************************
 * This file provides base and template class support to encapsulate the
 * relationship between an object and a COM tearoff object that holds a pointer
 * to that object.
 *    The object is referred to as the Tied object, since the COM object is
 * "tied" to it, and cannot do anything useful apart from it.
 *    The COM object disables itself when the tied object is deleted. This
 * allows for automatic detection of dead states. An object can also "orphan"
 * all COM objects tied to it by calling the UnadviseAll method.
 *
 * An example of a tied object relationship is that of CAMCDoc and CMMCDocument.
 * CMMCDocument is derived from CTiedComObject<CAMCDoc>, and CAMCDoc derives
 * from CTiedObject. CAMCDoc thus keeps a list of all COM object that are tied
 * to it, and notifies them when it is destroyed. Similarly, the COM objects notify
 * the tied object when they are destroyed, so that they are removed from the list.
 *
 * NOTE: the tied object does NOT addref the COM objects, it just keeps a list of them.
 * If it was to addref them, there would be all sorts of circular lifetime problems.
 * By ensuring that the tied object and the COM objects notify each other of their
 * own destruction, lifetime management is correctly handled.
 *
 * Use CTiedComObjectCreator::ScCreateAndConnect to create an instance of the 
 * COM object and tie it to the tied object.
 *
 ************************************************************************/

class CTiedObject;
class CTiedComObjectRoot;


/*+-------------------------------------------------------------------------*
 * class CTiedComObjectRoot
 * 
 *
 * PURPOSE: Base class for CTiedComObject
 *
 *+-------------------------------------------------------------------------*/
class CTiedComObjectRoot
{
public:
    virtual void Unadvise()  = 0; // so that the tied object can inform that it is being deleted.
};


/*+-------------------------------------------------------------------------*
 * class CTiedObject
 * 
 *
 * PURPOSE: The base class that any object which has COM objects tied to 
 *          it should derive from. Provides methods to add a new COM object
 *          to its list of tied objects, to remove a COM object from its
 *          list, and to 
 *
 *+-------------------------------------------------------------------------*/
class CTiedObject
{
    typedef CTiedComObjectRoot * PTIEDCOMOBJECTROOT;
    typedef std::list<PTIEDCOMOBJECTROOT> CTiedComObjects;

    CTiedComObjects m_TiedComObjects;

public:
    SC      ScAddToList(CTiedComObjectRoot *p);
    void    RemoveFromList(CTiedComObjectRoot *p);

    virtual ~CTiedObject();

protected:
    void    UnadviseAll();
};

/*+-------------------------------------------------------------------------*
 *
 * CTiedObject::ScAddToList
 *
 * PURPOSE: Adds the COM object to the list of objects. Usually called soon
 *          after constructing the COM object.
 *
 * PARAMETERS: 
 *    CTiedComObjectRoot * p :
 *
 * RETURNS: 
 *    inline SC
 *
 *+-------------------------------------------------------------------------*/
inline
SC  CTiedObject::ScAddToList(CTiedComObjectRoot *p)
{
    DECLARE_SC (sc, _T("CTiedObject::ScAddToList"));

    if(!p)
        return (sc = E_INVALIDARG);

    m_TiedComObjects.push_back(p);

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CTiedObject::RemoveFromList
 *
 * PURPOSE: Removes the specfied COM object from the list of COM objects.
 *          Usually called from the destructor of the COM object.
 *
 * PARAMETERS: 
 *    CTiedComObjectRoot * p : The COM object.
 *
 * RETURNS: 
 *    inline void
 *
 *+-------------------------------------------------------------------------*/
inline
void CTiedObject::RemoveFromList(CTiedComObjectRoot *p)
{
    CTiedComObjects::iterator iter;
    
    iter = std::find (m_TiedComObjects.begin(), m_TiedComObjects.end(), p);
    ASSERT(iter != m_TiedComObjects.end());

    if(iter != m_TiedComObjects.end())
        m_TiedComObjects.erase(iter);

}

inline
void CTiedObject::UnadviseAll()
{
    CTiedComObjects::iterator iter;
    for(iter = m_TiedComObjects.begin(); iter != m_TiedComObjects.end(); iter++)
    {
        (*iter)->Unadvise();
    }
}

inline
CTiedObject::~CTiedObject()
{
    UnadviseAll();
}

/*+-------------------------------------------------------------------------*
 * template class CTiedComObject
 * 
 *
 * PURPOSE:  The base class for COM objects that are tied to non-COM objects
 *           for instance, CMMCDocument is tied to CAMCDoc - it delegates
 *           all its methods to the tied object.
 *
 *+-------------------------------------------------------------------------*/
template <class TiedObjectClass>
class CTiedComObject : public CTiedComObjectRoot
{
    friend class TiedObjectClass;

public:
            CTiedComObject() : m_pT(NULL) {}
    virtual ~CTiedComObject();
    void    SetTiedObject(TiedObjectClass *pT);

protected:
    // called by the COM methods to make sure that the tied object exists.
    SC      ScGetTiedObject(TiedObjectClass*&pT);
    bool    IsTied()     { return m_pT != NULL; }
    void    Unadvise();

private:
    TiedObjectClass *m_pT;
};


/*+-------------------------------------------------------------------------*
 *
 * ~CTiedComObject
 *
 * PURPOSE:  Destructor. Tells the tied object to remove this one from
 *           its list of tied COM objects.
 *
 *+-------------------------------------------------------------------------*/
template<class TiedObjectClass>
CTiedComObject<TiedObjectClass>::~CTiedComObject()
{
    if(m_pT != NULL)
    {
        m_pT->RemoveFromList(this);
    }
}

template<class TiedObjectClass>
void
CTiedComObject<TiedObjectClass>::SetTiedObject(TiedObjectClass *pT)
{
    ASSERT(pT != NULL);
    m_pT = pT;
}

template<class TiedObjectClass>
inline void
CTiedComObject<TiedObjectClass>::Unadvise()
{
    m_pT = NULL;
}


/*+-------------------------------------------------------------------------*
 *
 * CTiedComObject::ScGetTiedObject
 *
 * PURPOSE: Checks that a valid tied object pointer exists, and returns it.
 *
 * PARAMETERS: 
 *    TiedObjectClass** ppT : [OUT]: The object pointer
 *
 * RETURNS: 
 *      SC:     MMC_E_OBJECT_IS_GONE if no valid pointer exists.
 *+-------------------------------------------------------------------------*/
template<class TiedObjectClass>
inline SC 
CTiedComObject<TiedObjectClass>::ScGetTiedObject(TiedObjectClass*&pT)
{
    DECLARE_SC (sc, _T("CTiedComObject::ScGetTiedObject"));

    pT =  m_pT;
    if(NULL == m_pT)
        return (sc = ScFromMMC(MMC_E_OBJECT_IS_GONE));

    return (sc);
}


/*+-------------------------------------------------------------------------*
 *
 * ScCreateConnection
 *
 * PURPOSE: Creates a two-way connection between a COM object and its tied
 *          object.
 *
 * PARAMETERS: 
 *    TiedComObjClass  comObj :
 *    TiedObjClass     obj :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
template<class TiedComObjClass, class TiedObjClass>
SC ScCreateConnection(TiedComObjClass &comObj, TiedObjClass &obj)
{
    DECLARE_SC (sc, _T("ScCreateConnection"));
    
    sc = obj.ScAddToList(&comObj);
    if(sc)
        return (sc);
    
    comObj.SetTiedObject(&obj);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CTiedComObjectCreator
 * 
 *
 * PURPOSE: has a single static function, ScCreateAndConnect, which creates
 *          an instance of the COM object (if the smart pointer supplied is
 *          NULL) and connects it to the Tied object supplied.
 *
 *+-------------------------------------------------------------------------*/
template <class TiedComObjectClass>
class CTiedComObjectCreator
{
public:
    template<class TiedObjClass, class SmartPointerClass>
    static SC ScCreateAndConnect(TiedObjClass &obj, SmartPointerClass &smartPointer)
    {
        DECLARE_SC(sc, TEXT("CTiedComObjectCreator::ScCreateAndConnect") );

        // if the object has not yet been created, create it.
        if(smartPointer == NULL)
        {
            CComObject<TiedComObjectClass> *pTiedComObject = NULL;
            
            sc = CComObject<TiedComObjectClass>::CreateInstance(&pTiedComObject);
            if (sc)
                return (sc);

            if(!pTiedComObject)
                return (sc = E_UNEXPECTED);

            sc = ScCreateConnection(*pTiedComObject, obj); // create a link between the tied obj and tied com obj.
            if(sc)
                return sc;

            smartPointer = pTiedComObject; // This AddRef's it once. need to addref it for the client as well.
        }

        return sc;
    }

};

#endif  // TIEDOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\treesink.h ===
/*+-------------------------------------------------------------------------*
 * class CTreeCtrlEventSink
 * 
 *
 * PURPOSE: The notification handler class for tree notifications.
 *
 *+-------------------------------------------------------------------------*/
class CTreeCtrlEventSink : public CEventSinkBase
{
    virtual SC  ScOnSelectNode()    {return S_OK;}
    virtual SC  ScOnDeleteNode()    {return S_OK;}
    virtual SC  ScOnInsertNode()    {return S_OK;}
    virtual SC  ScOnModifyNode()    {return S_OK;}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\toolbars.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      toolbars.h
 *
 *  Contents:  Defines the (non-COM) interface classes that are used for
 *             communication between conui and nodemgr
 *
 *  History:   30-Aug-99 AnandhaG     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TOOLBARS_H
#define TOOLBARS_H
#pragma once

//+-------------------------------------------------------------------
//
//  class:     CMenuButtonNotify
//
//  Purpose:   Menubutton click notification hanlder interface.
//             When the user clicks a menubutton, MMC calls the
//             method ScNotifyMenuBtnClick of this interface.
//             This is implemented by whoever adds a menubutton.
//             (ie: snapins & MMC menus).
//
//  History:   30-Aug-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CMenuButtonNotify
{
public:
    virtual SC ScNotifyMenuBtnClick(HNODE hNode, bool bScope, LPARAM lParam,
                                    MENUBUTTONDATA& menuButtonData) = 0;
};

//+-------------------------------------------------------------------
//
//  class:     CMenuButtonsMgr
//
//  Purpose:   An interface to manipulate MenuButton UI.
//
//  History:   30-Aug-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CMenuButtonsMgr
{
public:
    virtual SC ScAddMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk,
                               INT idCommand, LPCOLESTR lpButtonText,
                               LPCOLESTR lpStatusText) = 0;
    virtual SC ScModifyMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk,
                                  INT idCommand, LPCOLESTR lpButtonText,
                                  LPCOLESTR lpStatusText) = 0;
    virtual SC ScModifyMenuButtonState(CMenuButtonNotify* pMenuBtnNotifyClbk,
                                       INT idCommand, MMC_BUTTON_STATE nState,
                                       BOOL bState) = 0;
    virtual SC ScAttachMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk) = 0;
    virtual SC ScDetachMenuButton(CMenuButtonNotify* pMenuBtnNotifyClbk) = 0;

    virtual SC ScDisableMenuButtons() = 0;

    // The following members will be part of CMenuButtonsMgrImpl
    // after "Customize View" dialog is moved to Conui
    virtual SC ScToggleMenuButton(BOOL bShow) = 0;
};

//+-------------------------------------------------------------------
//
//  class:     CToolbarNotify
//
//  Purpose:   Toolbutton click notification hanlder interface.
//             When the user clicks a toolbutton, MMC calls the
//             method ScNotifyToolBarClick of this interface.
//             This is implemented by whoever adds a toolbar.
//             (ie: snapins & MMC stdbar).
//
//  History:   12-Oct-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CToolbarNotify
{
public:
    virtual SC ScNotifyToolBarClick(HNODE hNode, bool bScope, LPARAM lParam,
                                    UINT nID) = 0;
    virtual SC ScAMCViewToolbarsBeingDestroyed() = 0;
};

//+-------------------------------------------------------------------
//
//  class:     CStdVerbButtons
//
//  Purpose:   An interface used by nodemgr to manipulate std-verb buttons.
//
//  History:   26-Oct-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CStdVerbButtons
{
public:
    virtual SC ScUpdateStdbarVerbs(IConsoleVerb* pCV) = 0;
    virtual SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, IConsoleVerb* pCV = NULL) = 0;
    virtual SC ScUpdateStdbarVerb (MMC_CONSOLE_VERB cVerb, BYTE byState, BOOL bFlag) = 0;
    virtual SC ScShow(BOOL bShow) = 0;
};

//+-------------------------------------------------------------------
//
//  class:     CMMCToolbarIntf
//
//  Purpose:   An interface to manipulate Toolbar UI.
//
//  History:   05-Dec-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CMMCToolbarIntf
{
public:
    virtual SC ScAddButtons(CToolbarNotify* pNotifyCallbk, int nButtons, LPMMCBUTTON lpButtons) = 0;
    virtual SC ScAddBitmap (CToolbarNotify* pNotifyCallbk, INT nImages, HBITMAP hbmp, COLORREF crMask) = 0;
    virtual SC ScInsertButton(CToolbarNotify* pNotifyCallbk, int nIndex, LPMMCBUTTON lpButton) = 0;
    virtual SC ScDeleteButton(CToolbarNotify* pNotifyCallbk, int nIndex) = 0;
    virtual SC ScGetButtonState(CToolbarNotify* pNotifyCallbk, int idCommand, BYTE nState, BOOL* pbState) = 0;
    virtual SC ScSetButtonState(CToolbarNotify* pNotifyCallbk, int idCommand, BYTE nState, BOOL bState) = 0;
    virtual SC ScAttach(CToolbarNotify* pNotifyCallbk) = 0;
    virtual SC ScDetach(CToolbarNotify* pNotifyCallbk) = 0;
    virtual SC ScDelete(CToolbarNotify* pNotifyCallbk) = 0;
    virtual SC ScShow(CToolbarNotify* pNotifyCallbk, BOOL bShow) = 0;
};

//+-------------------------------------------------------------------
//
//  class:     CAMCViewToolbarsMgr
//
//  Purpose:   An interface to create/disable Toolbar. (Rename this
//             to CToolbarsMgr once old one is removed).
//
//  History:   05-Dec-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CAMCViewToolbarsMgr
{
public:
    virtual SC ScCreateToolBar(CMMCToolbarIntf** ppToolbarIntf) = 0;
    virtual SC ScDisableToolbars() = 0;
};

#endif /* TOOLBARS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\strconv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       strconv.h
//
//--------------------------------------------------------------------------

// This header contains macros and functions for performing various types of
// string conversions, in most cases, these functions are duplicate of others
// found in both MFC, and ATL.  Unfortunately, when both MFC and ATL are
// included within the same translation unit, all of the conversion functions
// available in ATL are made unavailable.  This file should work in all settings!
// The functions, though, in many cases to functions elsewhere have been renamed
// to avoid name colisions.  The naming convention is similar to the naming
// convention used in the C++ standard library.  ANSI strings are abbreviated to
// str, while wide character strings are abbreviated to wcs.

#ifndef STRCONV_H
#define STRCONV_H

#ifndef __wtypes_h__
#include <wtypes.h>
#endif
#ifndef _INC_MALLOC
#include <malloc.h>
#endif

namespace microsoft	{
namespace string_conversion {

inline BSTR wcs2BSTR(const wchar_t* ws) throw()
	// Converts a wide character string to a BSTR.  The callee is responsible
	// for releasing the returned BSTR.  A BSTR is always returned, even if ws
	// is NULL.  When ws is NULL, an empty BSTR is returned.  This is done so
	// that the behaviour of this function is similar to those found below.
	{
	return ws ? SysAllocString(ws) : SysAllocString(L"");
	}

inline BSTR str2BSTR(const char* s) throw()
	// Converts the provided narrow string to a BSTR.  The BSTR must be released
	// by the callee.
	{
	if (!s)
		return wcs2BSTR(NULL);
	const int len = lstrlenA(s)+1;
	wchar_t* ws = reinterpret_cast<wchar_t*>(alloca((len)*2));
	*ws=0;
	MultiByteToWideChar(CP_ACP, 0, s, -1, ws, len);
	return wcs2BSTR(ws);
	}

inline char* wcs2str(char* s, const wchar_t* ws) throw()
	// Converts the provided wcs to a narrrow string, which will be stored in
	// the provided space.  No overrun checking is done!  The narrow string
	// is returned.
	{
	*s=0;
	WideCharToMultiByte(CP_ACP, 0, ws, -1, s, lstrlenW(ws)+1, NULL, NULL);
	return s;
	}

inline char* wcs2str(char* s, const wchar_t* ws, int wslen) throw()
	// Converts the provided wcs to a narrow string, which will be stored
	// in the provided space.  Overrun checking is performed.
	{
	*s=0;
	WideCharToMultiByte(CP_ACP, 0, ws, -1, s, wslen, NULL, NULL);
	return s;
	}

#define USES_STRCONV int _strconv_length;

#define WCS2STR(ws) \
	(ws ? (_strconv_length = lstrlenW(ws)+1,\
	wcs2str(reinterpret_cast<char*>(alloca(_strconv_length)),\
	ws, _strconv_length)) : NULL)

} // namespace string_conversion
} // namespace microsoft

#ifndef MICROSOFT_NAMESPACE_ON
using namespace microsoft;
#ifndef STRING_CONVERSION_NAMESPACE_ON
using namespace string_conversion;
#endif // STRING_CONVERSION_NAMESPACE_ON
#endif // MICROSOFT_NAMESPACE_ON

#endif // STRCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\treeobsv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       treeobsv.h
//
//--------------------------------------------------------------------------

#ifndef _TREEOBSV_H_
#define _TREEOBSV_H_

#include "observer.h"

typedef LONG_PTR TREEITEMID;

// Tree item attributes
const DWORD TIA_NAME   = 0x00000001;
const DWORD TIA_IMAGE  = 0x00000002;

// observer styles
const DWORD TOBSRV_HIDEROOT     = 0x00000001;    // Don't display root item
const DWORD TOBSRV_FOLDERSONLY  = 0x00000002;    // Show only folder items

const TREEITEMID TREEID_ROOT = static_cast<TREEITEMID>(-1);
const TREEITEMID TREEID_LAST = static_cast<TREEITEMID>(-2);

class CTreeObserver
{
public:
    STDMETHOD (SetStyle) (DWORD dwStyle) = 0;
    STDMETHOD_(void, ItemAdded)   (TREEITEMID tid) = 0;
    STDMETHOD_(void, ItemRemoved) (TREEITEMID tidParent, TREEITEMID tidRemoved) = 0;
    STDMETHOD_(void, ItemChanged) (TREEITEMID tid, DWORD dwAttrib) = 0;
};


class CTreeSource 
{
public:
    STDMETHOD_(TREEITEMID, GetRootItem)        () = 0;
    STDMETHOD_(TREEITEMID, GetParentItem)      (TREEITEMID tid) = 0;
    STDMETHOD_(TREEITEMID, GetChildItem)       (TREEITEMID tid) = 0;
    STDMETHOD_(TREEITEMID, GetNextSiblingItem) (TREEITEMID tid) = 0;

    STDMETHOD_(LPARAM,     GetItemParam)    (TREEITEMID tid) = 0;
    STDMETHOD_(void,       GetItemName)     (TREEITEMID tid, LPTSTR pszName, int cchMaxName) = 0;
    STDMETHOD_(int,        GetItemImage)    (TREEITEMID tid) = 0;
    STDMETHOD_(int,        GetItemOpenImage)(TREEITEMID tid) = 0;
    STDMETHOD_(BOOL,       IsFolderItem)    (TREEITEMID tid) = 0;
};


#endif // _TREEOBSV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\tstring.inl ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      tstring.inl
 *
 *  Contents:  Inline implementation file for tstring
 *
 *  History:   04-Oct-99 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TSTRING_INL
#define TSTRING_INL
#pragma once


/*+-------------------------------------------------------------------------*
 * tstring::tstring
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring::tstring (const allocator_type& al) :
    BaseClass (al)
{}

inline tstring::tstring (const tstring& other) :
    BaseClass (other)
{}

inline tstring::tstring (const BaseClass& other) :
    BaseClass (other)
{}

inline tstring::tstring (const tstring& other, size_type pos, size_type n) :
    BaseClass (other, pos, n)
{}

inline tstring::tstring (const BaseClass& other, size_type pos, size_type n) :
    BaseClass (other, pos, n)
{}

inline tstring::tstring (const TCHAR* psz) :
    BaseClass (psz)
{}

inline tstring::tstring (const TCHAR* psz, size_type n) :
    BaseClass (psz, n)
{}

inline tstring::tstring (size_type n, TCHAR ch) :
    BaseClass (n, ch)
{}

inline tstring::tstring (const_iterator first, const_iterator last) :
    BaseClass (first, last)
{}


/*+-------------------------------------------------------------------------*
 * tstring::operator= 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::operator= (const tstring& other)
{
    if (this != &other)
        erase();    // see KB Q172398

    BaseClass::operator= (other);
    return (*this);
}

inline tstring& tstring::operator= (const BaseClass& other)
{
    if (data() != other.data())
        erase();    // see KB Q172398

    BaseClass::operator= (other);
    return (*this);
}

inline tstring& tstring::operator= (TCHAR ch)
{
    erase();    // see KB Q172398
    BaseClass::operator= (ch);
    return (*this);
}

inline tstring& tstring::operator= (const TCHAR* psz)
{
    if (!IsPartOfString (*this, psz))
        erase();    // see KB Q172398

    BaseClass::operator= (psz);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * tstring::operator+= 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::operator+= (const tstring& strToAppend)
{
    BaseClass::operator+= (strToAppend);
    return (*this);
}

inline tstring& tstring::operator+= (const BaseClass& strToAppend)
{
    BaseClass::operator+= (strToAppend);
    return (*this);
}

inline tstring& tstring::operator+= (TCHAR chToAppend)
{
    BaseClass::operator+= (chToAppend);
    return (*this);
}

inline tstring& tstring::operator+= (const TCHAR* pszToAppend)
{
    BaseClass::operator+= (pszToAppend);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * tstring::append 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::append (const tstring& str)
{
    BaseClass::append (str);
    return (*this);
}

inline tstring& tstring::append (const BaseClass& str)
{
    BaseClass::append (str);
    return (*this);
}

inline tstring& tstring::append (const tstring& str, size_type pos, size_type n)
{
    BaseClass::append (str, pos, n);
    return (*this);
}

inline tstring& tstring::append (const BaseClass& str, size_type pos, size_type n)
{
    BaseClass::append (str, pos, n);
    return (*this);
}

inline tstring& tstring::append (const TCHAR* psz)
{
    BaseClass::append (psz);
    return (*this);
}

inline tstring& tstring::append (const TCHAR* psz, size_type n)
{
    BaseClass::append (psz, n);
    return (*this);
}

inline tstring& tstring::append (size_type n, TCHAR ch)
{
    BaseClass::append (n, ch);
    return (*this);
}

inline tstring& tstring::append (const_iterator first, const_iterator last)
{
    BaseClass::append (first, last);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * tstring::assign 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::assign (const tstring& str)
{
    if (this != &str)
        erase();    // see KB Q172398

    BaseClass::assign (str);
    return (*this);
}

inline tstring& tstring::assign (const BaseClass& str)
{
    if (data() != str.data())
        erase();    // see KB Q172398

    BaseClass::assign (str);
    return (*this);
}

inline tstring& tstring::assign (const tstring& str, size_type pos, size_type n)
{
    if (this != &str)
        erase();    // see KB Q172398

    BaseClass::assign (str, pos, n);
    return (*this);
}

inline tstring& tstring::assign (const BaseClass& str, size_type pos, size_type n)
{
    if (data() != str.data())
        erase();    // see KB Q172398

    BaseClass::assign (str, pos, n);
    return (*this);
}

inline tstring& tstring::assign (const TCHAR* psz)
{
    if (!IsPartOfString (*this, psz))
        erase();    // see KB Q172398

    BaseClass::assign (psz);
    return (*this);
}

inline tstring& tstring::assign (const TCHAR* psz, size_type n)
{
    if (!IsPartOfString (*this, psz))
        erase();    // see KB Q172398

    BaseClass::assign (psz, n);
    return (*this);
}

inline tstring& tstring::assign (size_type n, TCHAR ch)
{
    erase();    // see KB Q172398
    BaseClass::assign (n, ch);
    return (*this);
}

inline tstring& tstring::assign (const_iterator first, const_iterator last)
{
    if (!IsPartOfString (*this, first))
        erase();    // see KB Q172398

    BaseClass::assign (first, last);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * tstring::insert 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::insert (size_type p0, const tstring& str)
{
    BaseClass::insert (p0, str);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, const BaseClass& str)
{
    BaseClass::insert (p0, str);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, const tstring& str, size_type pos, size_type n)
{
    BaseClass::insert (p0, str, pos, n);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, const BaseClass& str, size_type pos, size_type n)
{
    BaseClass::insert (p0, str, pos, n);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, const TCHAR* psz, size_type n)
{
    BaseClass::insert (p0, psz, n);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, const TCHAR* psz)
{
    BaseClass::insert (p0, psz);
    return (*this);
}

inline tstring& tstring::insert (size_type p0, size_type n, TCHAR ch)
{
    BaseClass::insert (p0, n, ch);
    return (*this);
}

inline void tstring::insert (iterator it, size_type n, TCHAR ch)
{
    BaseClass::insert (it, n, ch);
}

inline void tstring::insert (iterator it, const_iterator first, const_iterator last)
{
    BaseClass::insert (it, first, last);
}


/*+-------------------------------------------------------------------------*
 * tstring::erase 
 *
 * Simple wrapper that forwards the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::erase (size_type p0, size_type n)
{
    BaseClass::erase (p0, n);
    return (*this);
}

inline tstring::iterator tstring::erase (iterator it)
{
    return (BaseClass::erase (it));
}

inline tstring::iterator tstring::erase (iterator first, iterator last)
{
    return (BaseClass::erase (first, last));
}


/*+-------------------------------------------------------------------------*
 * tstring::replace 
 *
 * Simple wrappers that forward the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring& tstring::replace (size_type p0, size_type n0, const tstring& str)
{
    BaseClass::replace (p0, n0, str);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, const BaseClass& str)
{
    BaseClass::replace (p0, n0, str);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, const tstring& str, size_type pos, size_type n)
{
    BaseClass::replace (p0, n0, str, pos, n);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, const BaseClass& str, size_type pos, size_type n)
{
    BaseClass::replace (p0, n0, str, pos, n);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, const TCHAR* psz, size_type n)
{
    BaseClass::replace (p0, n0, psz, n);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, const TCHAR* psz)
{
    BaseClass::replace (p0, n0, psz);
    return (*this);
}

inline tstring& tstring::replace (size_type p0, size_type n0, size_type n, TCHAR ch)
{
    BaseClass::replace (p0, n0, n, ch);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, const tstring& str)
{
    BaseClass::replace (first0, last0, str);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, const BaseClass& str)
{
    BaseClass::replace (first0, last0, str);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, const TCHAR* psz, size_type n)
{
    BaseClass::replace (first0, last0, psz, n);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, const TCHAR* psz)
{
    BaseClass::replace (first0, last0, psz);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, size_type n, TCHAR ch)
{
    BaseClass::replace (first0, last0, n, ch);
    return (*this);
}

inline tstring& tstring::replace (iterator first0, iterator last0, const_iterator first, const_iterator last)
{
    BaseClass::replace (first0, last0, first, last);
    return (*this);
}


/*+-------------------------------------------------------------------------*
 * tstring::substr 
 *
 * Simple wrapper that forwards the heavy lifting to the base class.
 *--------------------------------------------------------------------------*/

inline tstring tstring::substr (size_type pos, size_type n) const
{
    return (tstring (BaseClass::substr (pos, n)));
}


#endif /* TSTRING_INL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\tstring.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      tstring.h
 *
 *  Contents:  Interface file for tstring
 *
 *  History:   28-Oct-98 jeffro     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef TSTRING_H
#define TSTRING_H
#pragma once

#include <string>       // for std::wstring, std::string
#include <objidl.h>     // for IStream
#include <commctrl.h>
#include "mmc.h"
#include "ndmgr.h"      // for MMC_STRING_ID
#include "ndmgrpriv.h"
#include "stddbg.h"     // for ASSERT
#include "mmcptrs.h"    // for IStringTablePrivatePtr


/*+-------------------------------------------------------------------------*
 * tstring
 *
 * A tstring is a native-format (ANSI/Unicode) Standard C++ string that:
 * 
 *      1. always persists itself in Unicode format, and
 *      2. supports LoadString, like MFC CStrings
 * 
 * For ANSI, we provide IStream insertion and extraction operators that 
 * will automatically convert to Unicode on stream insertion and from
 * Unicode on stream extraction.
 * 
 * All base class member functions that return a base class instance (and
 * overloads), like substr:
 * 
 *      std::string std::string::substr (size_type pos, size_type n) const;
 * 
 * must have forwarder functions here, so tstring supports such constructs
 * as:
 * 
 *      tstring strStuff;
 *      *pStream << strStuff.substr(4, 6);
 * 
 * If we didn't have forwarder functions in tstring, then an instance of 
 * the base class type would be inserted in the stream instead of a tstring.
 * For Unicode, that wouldn't be a problem; but for ANSI, we'd end up 
 * inserting a std::string into the stream in non-Unicode format.  That
 * would defeat the purpose of having this class.
 *--------------------------------------------------------------------------*/

#ifdef UNICODE
    typedef std::wstring    tstring_BaseClass;
#else
    typedef std::string     tstring_BaseClass;
#endif

class tstring : public tstring_BaseClass
{
    typedef tstring_BaseClass   BaseClass;
    
public:
    explicit tstring (const allocator_type& al = allocator_type());

    tstring (const tstring&   other);
    tstring (const BaseClass& other);
    tstring (const tstring&   other, size_type pos, size_type n);
    tstring (const BaseClass& other, size_type pos, size_type n);
    tstring (const TCHAR* psz);
    tstring (const TCHAR* psz, size_type n);
    tstring (size_type n, TCHAR ch);
    tstring (const_iterator first, const_iterator last);
    
    tstring& operator= (const tstring&   other);
    tstring& operator= (const BaseClass& other);
    tstring& operator= (TCHAR ch);
    tstring& operator= (const TCHAR* psz);

    tstring& operator+= (const tstring&   strToAppend);
    tstring& operator+= (const BaseClass& strToAppend);
    tstring& operator+= (TCHAR chToAppend);
    tstring& operator+= (const TCHAR* pszToAppend);

    tstring& append (const tstring&   str);
    tstring& append (const BaseClass& str);
    tstring& append (const tstring&   str, size_type pos, size_type n);
    tstring& append (const BaseClass& str, size_type pos, size_type n);
    tstring& append (const TCHAR* psz);
    tstring& append (const TCHAR* psz, size_type n);
    tstring& append (size_type n, TCHAR ch);
    tstring& append (const_iterator first, const_iterator last);
    
    tstring& assign (const tstring&   str);
    tstring& assign (const BaseClass& str);
    tstring& assign (const tstring&   str, size_type pos, size_type n);
    tstring& assign (const BaseClass& str, size_type pos, size_type n);
    tstring& assign (const TCHAR* psz);
    tstring& assign (const TCHAR* psz, size_type n);
    tstring& assign (size_type n, TCHAR ch);
    tstring& assign (const_iterator first, const_iterator last);

    tstring& insert (size_type p0, const tstring&   str);
    tstring& insert (size_type p0, const BaseClass& str);
    tstring& insert (size_type p0, const tstring&   str, size_type pos, size_type n);
    tstring& insert (size_type p0, const BaseClass& str, size_type pos, size_type n);
    tstring& insert (size_type p0, const TCHAR* psz, size_type n);
    tstring& insert (size_type p0, const TCHAR* psz);
    tstring& insert (size_type p0, size_type n, TCHAR ch);
    iterator insert (iterator it, TCHAR ch);
    void     insert (iterator it, size_type n, TCHAR ch);
    void     insert (iterator it, const_iterator first, const_iterator last);

    tstring& erase (size_type p0 = 0, size_type n = npos);
    iterator erase (iterator it);
    iterator erase (iterator first, iterator last);

    tstring& replace (size_type p0, size_type n0, const tstring&   str);
    tstring& replace (size_type p0, size_type n0, const BaseClass& str);
    tstring& replace (size_type p0, size_type n0, const tstring&   str, size_type pos, size_type n);
    tstring& replace (size_type p0, size_type n0, const BaseClass& str, size_type pos, size_type n);
    tstring& replace (size_type p0, size_type n0, const TCHAR* psz, size_type n);
    tstring& replace (size_type p0, size_type n0, const TCHAR* psz);
    tstring& replace (size_type p0, size_type n0, size_type n, TCHAR ch);
    tstring& replace (iterator first0, iterator last0, const tstring&   str);
    tstring& replace (iterator first0, iterator last0, const BaseClass& str);
    tstring& replace (iterator first0, iterator last0, const TCHAR* psz, size_type n);
    tstring& replace (iterator first0, iterator last0, const TCHAR* psz);
    tstring& replace (iterator first0, iterator last0, size_type n, TCHAR ch);
    tstring& replace (iterator first0, iterator last0, const_iterator first, const_iterator last);

    tstring substr (size_type pos = 0, size_type n = npos) const;
    
    bool LoadString (HINSTANCE hInst, UINT nID);
};

#ifndef UNICODE
IStream& operator>> (IStream& stm,       tstring& task);
IStream& operator<< (IStream& stm, const tstring& task);
#endif  // UNICODE



/*+-------------------------------------------------------------------------*
 * CStringTableStringBase
 *
 *
 *--------------------------------------------------------------------------*/
class CPersistor;

class CStringTableStringBase
{
public:
    enum
    {
        eNoValue = -1,
    };

    CStringTableStringBase (IStringTablePrivate* pstp);
    CStringTableStringBase (const CStringTableStringBase& other);
    CStringTableStringBase (IStringTablePrivate* pstp, const tstring& str);
    CStringTableStringBase& operator= (const CStringTableStringBase& other);
    CStringTableStringBase& operator= (const tstring& str);
    CStringTableStringBase& operator= (LPCTSTR psz);

    virtual ~CStringTableStringBase ();

    MMC_STRING_ID CommitToStringTable () const;
    void RemoveFromStringTable () const;

    /* Call Detach if your string is deleted before the string table is.
     * Failing to do so will *remove* your string from the string table.*/     
    void Detach()
    {
        m_id = eNoValue;
    }

    bool operator== (const CStringTableStringBase& other) const
    {
        ASSERT ((m_str == other.m_str) == (m_id == other.m_id));
        return (m_id == other.m_id);
    }

    bool operator!= (const CStringTableStringBase& other) const
    {
        return (!(*this == other));
    }

    bool operator== (const tstring& str) const
    {
        return (m_str == str);
    }

    bool operator!= (const tstring& str) const 
    {
        return (m_str != str);
    }

    bool operator== (LPCTSTR psz) const
    {
        return (m_str == psz);
    }

    bool operator!= (LPCTSTR psz) const 
    {
        return (m_str != psz);
    }

    LPCTSTR data() const
        { return (m_str.data()); }

    tstring str() const
        { return (m_str); }

    MMC_STRING_ID id() const
        { return (m_id); }

private:
    void Assign (const CStringTableStringBase& other);

    mutable IStringTablePrivatePtr  m_spStringTable;
    mutable MMC_STRING_ID           m_id;
    tstring                         m_str;

    friend IStream& operator>> (IStream& stm,       CStringTableStringBase& task);
    friend IStream& operator<< (IStream& stm, const CStringTableStringBase& task);
    friend class CPersistor;
};


template<class _E, class _Tr, class _Al>
bool IsPartOfString (const std::basic_string<_E, _Tr, _Al>& str, const _E* psz)
{
    return ((psz >= str.begin()) && (psz <= str.end()));
}


#include "tstring.inl"


#endif /* TSTRING_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       util.h
//
//--------------------------------------------------------------------------
#pragma once

class tstring;

class CStr;

ULONG   _ttoul(LPTSTR psz);
WORD    I_SplitModuleAndResourceID(LPCTSTR szBuf);
BOOL    I_GetStrFromModule(LPCTSTR pszModule, ULONG ulMsgNo, CStr &strBuf);
HICON   I_GetHicon(LPCTSTR pszModule, ULONG ulId);
LPSTR   CoTaskDupString(LPCSTR lpszIn);
LPWSTR  CoTaskDupString(LPCWSTR lpszIn);
LPTSTR  NewDupString(LPCTSTR lpszIn);
LPTSTR  StripTrailingWhitespace (LPTSTR pszStart);
HRESULT GUIDToCStr(CStr& str, const GUID& guid);
HRESULT GUIDFromCStr(const CStr& str, GUID* pguid);
bool    IsWhistler ();
HRESULT WriteCompatibleImageList (HIMAGELIST himl, IStream* pstm);
HRESULT ReadCompatibleImageList (IStream* pstm, HIMAGELIST& himl);

bool InflateFont (LOGFONT* plf, int nPointsToGrowBy);

inline bool DeflateFont (LOGFONT* plf, int nPointsToShrinkBy)
    { return (InflateFont (plf, -nPointsToShrinkBy)); }

bool GetTBBtnTextAndStatus(HINSTANCE hInst, int nID, std::wstring& szButton, std::wstring& szToolTip);

#ifdef DBG
void DrawOnDesktop (HBITMAP hbm, int x, int y);
void DrawOnDesktop (HICON hIcon, int x, int y);
void DrawOnDesktop (HIMAGELIST himl, int x, int y, int iImage = -1);
#endif

/*---------------------------------------------------------*\
| copied from winuser.h since we currently compile
| with _WIN32_WINNT == 0x0400
\*---------------------------------------------------------*/
#if (_WIN32_WINNT < 0x0500)

#if !defined(WS_EX_LAYOUTRTL)
	#define WS_EX_LAYOUTRTL                    0x00400000L
#endif

#if !defined(LAYOUT_BITMAPORIENTATIONPRESERVED)
	#define LAYOUT_BITMAPORIENTATIONPRESERVED  0x00000008
#endif

#if !defined(LAYOUT_RTL)
	#define LAYOUT_RTL                         0x00000001 // Right to left
#endif

// implement locally Gdi32 functions for layout
DWORD PrivateSetLayout( HDC hdc, DWORD dwLayout );

inline DWORD SetLayout( HDC hdc, DWORD dwLayout )
{
	return PrivateSetLayout( hdc, dwLayout );
}

// implement locally Gdi32 functions for layout
DWORD PrivateGetLayout( HDC hdc );

inline DWORD GetLayout( HDC hdc )
{
	return PrivateGetLayout( hdc );
}

// To deactivate UI theming before calling snapins & restore original context
// use below apis. (See util.cpp for more details).
BOOL WINAPI MmcDownlevelActivateActCtx(HANDLE hActCtx, ULONG_PTR* pulCookie); 
VOID WINAPI MmcDownlevelDeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\variant.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      variant.h
 *
 *  Contents:  Interface file for various VARIANT helper functions
 *
 *  History:   19-Nov-1999 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once
#ifndef VARIANT_H_INCLUDED
#define VARIANT_H_INCLUDED


/*+-------------------------------------------------------------------------*
 * ConvertByRefVariantToByValue 
 *
 * VBScript will has two syntaxes for calling dispinterfaces:
 * 
 * 1.   obj.Method (arg)
 * 2.   obj.Method arg
 * 
 * The first syntax will pass arg by value, which out dispinterfaces will
 * be able to handle.  If Method takes a BSTR argument, the VARIANT that
 * arrives at Method will be of type VT_BSTR.
 * 
 * The second syntax will pass arg by reference.  In this case Method will
 * receive a VARIANT of type (VT_VARIANT | VT_BYREF).  The VARIANT that is
 * referenced will be of type VT_BSTR.
 * 
 * This function will dereference the VARIANT and return the direct pointer 
 * in pVar.  Calling this function on a VARIANT that is not VT_BYREF is
 * harmless.
 *--------------------------------------------------------------------------*/

inline VARIANT* ConvertByRefVariantToByValue (VARIANT* pVar)
{
    while ((pVar != NULL) && (V_VT(pVar) == (VT_VARIANT | VT_BYREF)))
    {
        pVar = V_VARIANTREF(pVar);
    }

    return (pVar);
}


/*+-------------------------------------------------------------------------*
 * IsOptionalParamMissing 
 *
 * Returns true if an optional argument to an Automation method is left
 * blank.  This is indicated by a type of VT_ERROR with a value of
 * DISP_E_PARAMNOTFOUND.
 * 
 * This should be moved to a header.
 *--------------------------------------------------------------------------*/

inline bool IsOptionalParamMissing (const VARIANT& var)
{
    return ((V_VT(&var) == VT_ERROR) && (V_ERROR(&var) == DISP_E_PARAMNOTFOUND));
}


#endif /* VARIANT_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\viewset.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      viewset.h
 *
 *  Contents:  Declares a class that holds the settings needed to re-create a view.
 *
 *  History:   21-April-99 vivekj     Created
 *             03-Feb-2000 AnandhaG   Added CResultViewType member
 *
 *--------------------------------------------------------------------------*/
#ifndef _VIEWSET_H_
#define _VIEWSET_H_

//+-------------------------------------------------------------------
//
//  Class:      CViewSettings
//
//  Purpose:    The view information for a node (bookmark).
//              Stores result-view-type, taskpad-id and view mode.
//
//  History:    01-27-1999   AnandhaG   Created
//              02-08-2000   AnandhaG   Modified to include new result-view-type
//
//--------------------------------------------------------------------
class CViewSettings : public CSerialObject, public CXMLObject
{
private:
    typedef std::wstring wstring;

///////////////////////////////////////////////////////////////////////////////////////////
// View Types (These are meant for decoding MMC1.2 consoles, do not use them for MMC2.0. //
///////////////////////////////////////////////////////////////////////////////////////////
typedef enum  _VIEW_TYPE
{
    VIEW_TYPE_OCX        = MMCLV_VIEWSTYLE_ICON - 3,  // -3 custom ocx view
    VIEW_TYPE_WEB        = MMCLV_VIEWSTYLE_ICON - 2,  // -2 custom web view
    VIEW_TYPE_DEFAULT    = MMCLV_VIEWSTYLE_ICON - 1,  // -1

    VIEW_TYPE_LARGE_ICON = MMCLV_VIEWSTYLE_ICON,
    VIEW_TYPE_REPORT     = MMCLV_VIEWSTYLE_REPORT,
    VIEW_TYPE_SMALL_ICON = MMCLV_VIEWSTYLE_SMALLICON,
    VIEW_TYPE_LIST       = MMCLV_VIEWSTYLE_LIST,
    VIEW_TYPE_FILTERED   = MMCLV_VIEWSTYLE_FILTERED,

} VIEW_TYPE;

///////////////////////////////////////////////////////////////////////////////////////////
// CViewSetting Mask tells which members are valid.                                      //
///////////////////////////////////////////////////////////////////////////////////////////
static const DWORD VIEWSET_MASK_NONE        = 0x0000;
static const DWORD VIEWSET_MASK_VIEWMODE    = 0x0001;         // The ViewMode member is valid.
static const DWORD VIEWSET_MASK_RVTYPE      = 0x0002;         // The CResultViewType is valid.
static const DWORD VIEWSET_MASK_TASKPADID   = 0x0004;         // The taskpad id is valid.


protected:
    virtual UINT GetVersion() { return 4;}
    virtual HRESULT ReadSerialObject(IStream &stm, UINT nVersion);

public:
    virtual void Persist(CPersistor &persistor);

    DEFINE_XML_TYPE(XML_TAG_VIEW_SETTINGS);

public:
    CViewSettings();

    bool operator == (const CViewSettings& viewSettings);
    bool operator != (const CViewSettings& viewSettings)
    {
        return (!operator==(viewSettings));
    }

    SC              ScGetViewMode(ULONG& ulViewMode);
    SC              ScSetViewMode(const ULONG ulViewMode);

    SC              ScGetTaskpadID(GUID& guidTaskpad);
    SC              ScSetTaskpadID(const GUID& guidTaskpad);

    SC              ScGetResultViewType(CResultViewType& rvt);
    SC              ScSetResultViewType(const CResultViewType& rvt);

    bool            IsViewModeValid()    const;
    bool            IsTaskpadIDValid()   const  { return (m_dwMask & VIEWSET_MASK_TASKPADID);}
    bool            IsResultViewTypeValid()const  { return (m_dwMask & VIEWSET_MASK_RVTYPE);}

    void            SetResultViewTypeValid(bool bSet = true)  { SetMask(VIEWSET_MASK_RVTYPE, bSet);}
    void            SetTaskpadIDValid(bool bSet = true)  { SetMask(VIEWSET_MASK_TASKPADID, bSet);}
    void            SetViewModeValid(bool bSet = true)  { SetMask(VIEWSET_MASK_VIEWMODE, bSet);}

    bool            operator<(const CViewSettings& viewSettings){ return (m_dwRank < viewSettings.m_dwRank);}

    SC              ScInitialize(bool  bViewTypeValid,
								 const VIEW_TYPE& viewType,
                                 const long lViewOptions,
                                 const wstring& wstrViewName);

private:
    void            SetMask(DWORD dwMask, bool bSet = true)
                    {
                        if (bSet)
                            m_dwMask |= dwMask;
                        else
                            m_dwMask &=(~dwMask);
                    }

private:
    CResultViewType m_RVType;
    ULONG           m_ulViewMode;

    GUID            m_guidTaskpad;  // the guid of the taskpad, if any.

    DWORD           m_dwMask;       // VIEWSET_MASK

    // Book keeping members.
public:
    DWORD         GetUsageRank()     const  { return m_dwRank;}
    void          SetUsageRank(DWORD dw)    { m_dwRank = dw;}

    BOOL          IsObjInvalid()     const  { return m_bInvalid;}
    void          SetObjInvalid(BOOL b = TRUE) { m_bInvalid = b;}

private:
    // Needed for book keeping.
    DWORD           m_dwRank;       // Usage rank.
    BOOL            m_bInvalid;     // For garbage collection.
};

#endif _VIEWSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\xmlbase.h ===
#ifndef XMLBASE_H
#define XMLBASE_H
#pragma once

#include <atlbase.h>
#include <list>
#include <map>
#include "mmcerror.h"
#include "macros.h"
#include "tstring.h"
#include "strings.h"
#include "cstr.h"


/*+-------------------------------------------------------------------------*
    This file contains code required to persist data using XML format.
    The classes defined here fall into following categories:

    Main persistence process engine
        CPersistor
         | this class is the working horse for XML persistence
         | every class supporting persistence gets the reference to
         | CPersistor to it's Persist method, where it implements
         | persisting ot their own code. Class' own code is persisted
         | by calling Persist* methods on persistor and passing internal
         | variables to them. The tree of CPersist objects is created during
         | persist operation (load or save) and lives only during this operation.

    MSXML interface wrappers:
        CXMLElement             (wraps IXMLDOMNode interface)
        CXMLElementCollection   (wraps IXMLDOMNodeList interface)
        CXMLDocument            (wraps IXMLDOMDocument interface)
         | these wrappers add very little to the interfaces wrapped
         | - the throw SC type of exception instead of returning the error code
         | - maintain internal smart pointer to wrapped interfaces
         | - return error from methods if the interface has not be set

    base classes for classes supporting XML persistence
        CXMLObject              - generic persistence support
        XMLListCollectionBase   - persistence support for std::list
        XMLListCollectionImp    - persistence support for std::list
        XMLMapCollectionBase    - persistence support for std::map
        XMLMapCollection        - persistence support for std::map
        XMLMapCollectionImp     - persistence support for std::map
         | for object to support persistence it needs to derive from any of listed
         | classes (at least from CXMLObject). Other classes add some more functionality
         | to the derived class.

    Generic value persistece support
        CXMLValue   - support for set of generic types (like int, string, etc)
        CXMLBoolean - support for BOOL and bool types
         | CXMLValue mostly used by implicit cast of the object given to
         | CPersistor::PersistAttribute or CPersistor::PersistContents

    Wrappers, adding persistence to regular types
        XMLPoint                - persistence for POINT type
        XMLRect                 - persistence for RECT type
        XMLListCollectionWrap   - persistence for std::list type
        XMLMapCollectionWrap    - persistence for std::map type
        CXML_IStorage           - persistence thru IStorage
        CXML_IStream            - persistence thru IStream
        CXMLPersistableIcon     - persistence for console icon
        CXMLVariant             - persistence for CComVariant
        CXMLEnumeration         - persistence for enumerations by literals
        CXMLBitFlags            - persistence for bit-flags by literals
         | these classes usually take the reference to object they persist as
         | a parameter to the constructor and usually are constructed
         | on stack solely to persist the object and die afterwards

  SEE THE SAMPLE BELOW
  ----------------------------------------------------------------------------
  SAMPLE:
         say we have classes A, B what need to be persisted (access specifiers ommited)

            class A { int i; };
            class B { int j; A  a; };

         and we would want to persist them in format (assume A::i = 1, B::j = 2) :
            <BT INDEX = "2"><AT>1</AT></BT>

         we need to change the classes to support persistence:

            class A : public CXMLObject      // to inherit persistence capability
            { int i;

              DEFINE_XML_TYPE("AT")          // to define the tag name

              virtual void
              Persist(CPersistor &persistor) // to implement persistence for own staff
              {
                persistor.PersistContents(i);  // persist i as  AT element contents
              }
            };
            class B  : public CXMLObject     // to inherit persistence capability
            { int j; A  a;

              DEFINE_XML_TYPE("BT")          // to define the tag name

              virtual void
              Persist(CPersistor &persistor) // to implement persistence for own staff
              {
                persistor.PersistAttribute(_T("INDEX"), j); // persist j
                persistor.Persist(a);                       // persist a
              }
            };

         to have it in the string we may use:

            B b; std::wstring xml_text;
            b.ScSaveToString(&xml_text);

  ---------------------------------------------------------------------------- */

// forward declarations

class CPersistor;
class CXMLObject;
class CXMLElement;
class CXMLDocument;
class CXMLValueExtension;

enum XMLAttributeType
{
    attr_required,
    attr_optional
};

// special modes for certain persistors. These can be used to pass in information about
// how to persist. Not as scalable as a class hierarchy, but useful nonetheless.
enum PersistorMode
{
    persistorModeNone                    =  0x0000,

    persistorModeValueSplitEnabled       =  0x0001,   // used for StringTableStrings, indicates that all strings should be persisted by value

    persistorModeDefault = persistorModeValueSplitEnabled // the default setting
};

/*+-------------------------------------------------------------------------*
 * CONCEPT OF BINARY STORAGE
 *
 * To make xml documents more readable, a part of it (containing base64 - encoded
 * binary data) is stored at separate element located at the end of document.
 * the following sample illustrates this
 *
 *   NOT_USING_BINARY_STROAGE                   USING_BINARY_STROAGE
 *
 *  <ROOT>                                      <ROOT>
 *      <ELEMENT1>                                  <ELEMENT1 BINARY_REF_INDEX="0" />
 *          very_long_bin_data                      <ELEMENT2 BINARY_REF_INDEX="1" />
 *      </ELEMENT1>                                 .....
 *      <ELEMENT2>                                  <BINARY_STORAGE>
 *          other_long_bin_data                         <BINARY>
 *      </ELEMENT2>                                         very_long_bin_data
 *  </ROOT>                                             </BINARY>
 *                                                      <BINARY>
 *                                                          very_long_bin_data
 *                                                      </BINARY>
 *                                                  </BINARY_STORAGE>
 *                                              </ROOT>
 *
 * The decision to be saved at binary storage is made by the CXMLObject.
 * It informs the persistor by returning "true" from UsesBinaryStorage() method;
 *
 * In addition ( to make it locatable ) <BINARY> elements may have 'Name' attribute.
 * CXMLObject may supply it by returning non-NULL pointer to 'Name' attribute value
 * from virtual method GetBinaryEntryName().
 *
 * Storage is created / commited by methods provided in CXMLDocument
 *
 * NOTE: all mentioned methods, as well as GetXMLType() MUST return 'static' values.
 * To make XML document consistent, values need to be fixed [hardcoded].
 *+-------------------------------------------------------------------------*/

/*+-------------------------------------------------------------------------*
 * class CXMLObject
 *
 *
 * PURPOSE: The basic XML persistent object. has a name and a Persist function.
 *          When the object is persisted, an element with the name of the
 *          object is created. The Persist function is then called with
 *          a persistor created on the element.
 *
 *+-------------------------------------------------------------------------*/
class CXMLObject
{
    // this is overridden
public:

    virtual LPCTSTR GetXMLType() = 0;
    virtual void    Persist(CPersistor &persistor) = 0;

    // following methods are implemented by binary elements only.
    // leave it to this base class for most CXMLObject-derived classes.
    // see comment "CONCEPT OF BINARY STORAGE" above

    virtual bool    UsesBinaryStorage() { return false; }

    // this is optional. Overwrite only if you REALLY NEED the name
    virtual LPCTSTR GetBinaryEntryName() { return NULL; }

public: // implemented by CXMLObject. Do not override

    SC ScSaveToString(std::wstring *pString, bool bPutHeader = false); // set bPutHeader = true to write out the "?xml" tag
    SC ScSaveToDocument( CXMLDocument& xmlDocument );
    SC ScLoadFromString(LPCWSTR lpcwstrSource, PersistorMode mode = persistorModeNone);
    SC ScLoadFromDocument( CXMLDocument& xmlDocument );
};

/*+-------------------------------------------------------------------------*
 * MACRO  DEFINE_XML_TYPE
 *
 *
 * PURPOSE:  puts must-to-define methods to XCMLObject derived class implementation
 *           Since xml tag is rather class attribute than object, static method
 *           is provided to retrieve the type when object is not available
 *           Virtual method is provided for tag to be available from gen. purpose
 *           functions using the pointer to the base class.
 *
 * USAGE:    add DEFINE_XML_TYPE(pointer_to_string)
 *
 * NOTE:     'public' access qualifier will be applied for lines following the macro
 *+-------------------------------------------------------------------------*/

#define DEFINE_XML_TYPE(name) \
    public: \
    virtual LPCTSTR GetXMLType()  { return name; } \
    static  LPCTSTR _GetXMLType() { return name; }

/*+-------------------------------------------------------------------------*
 * class  CXMLElementCollection
 *
 *
 * PURPOSE:  Wrapper around IXMLDOMNodeList.
 *
 * NOTE: Throws exceptions!
 *+-------------------------------------------------------------------------*/
class CXMLElementCollection
{
    CComQIPtr<IXMLDOMNodeList, &IID_IXMLDOMNodeList> m_sp;

public:
    CXMLElementCollection(const CXMLElementCollection &other) { m_sp = other.m_sp; }
    CXMLElementCollection(IXMLDOMNodeList *ptr = NULL)  { m_sp = ptr; }

    bool IsNull()  { return m_sp == NULL; }

    void  get_count(long *plCount);
    void  item(LONG lIndex, CXMLElement *pElem);
};

/*+-------------------------------------------------------------------------*
 * class CXMLElement
 *
 *
 * PURPOSE: Wrapper around IXMLDOMNode
 *+-------------------------------------------------------------------------*/
class CXMLElement
{
    CComQIPtr<IXMLDOMNode, &IID_IXMLDOMNode> m_sp;

public:
    CXMLElement(LPUNKNOWN pElem = NULL)  { m_sp = pElem; }
    CXMLElement(const CXMLElement& elem) { m_sp = elem.m_sp;  }

    bool IsNull()                        { return m_sp == NULL; }

    // returns indentation to ad to child element or closing tag
    // to have nice-looking document. indentation depends on element depth
    bool GetTextIndent(CComBSTR& bstrIndent, bool bForAChild);

    void get_tagName(CStr &strTagName);
    void get_parent(CXMLElement * pParent);
    void setAttribute(const CStr &strPropertyName, const CComBSTR &bstrPropertyValue);
    bool getAttribute(const CStr &strPropertyName,       CComBSTR &bstrPropertyValue);
    void removeAttribute(const CStr &strPropertyName);
    void get_children(CXMLElementCollection *pChildren);
    void get_type(DOMNodeType *pType);
    void get_text(CComBSTR &bstrContent);
    void addChild(CXMLElement& rChildElem);
    void removeChild(CXMLElement& rChildElem);
    void replaceChild(CXMLElement& rNewChildElem, CXMLElement& rOldChildElem);
    void getNextSibling(CXMLElement * pNext);
    void getChildrenByName(LPCTSTR strTagName, CXMLElementCollection *pChildren);
    void put_text(BSTR bstrValue);
};

/*+-------------------------------------------------------------------------*
 * class CXMLDocument
 *
 *
 * PURPOSE: Wrapper class for IXMLDOMDocument
 *
 *+-------------------------------------------------------------------------*/
class CXMLDocument
{
    CComQIPtr<IXMLDOMDocument, &IID_IXMLDOMDocument> m_sp;

public:
    CXMLDocument& operator = (IXMLDOMDocument *pDoc) { m_sp = pDoc; return *this; }

    bool IsNull()                        { return m_sp == NULL; }

    operator CXMLElement()               { return CXMLElement(m_sp); }

    void get_root(CXMLElement *pElem);
    void createElement(DOMNodeType type, BSTR bstrTag, CXMLElement *pElem);

    // members to maintain the binary storage
    // see comment "CONCEPT OF BINARY STORAGE" above

    // used on storing (at top level, prior to persisting)
    // - creates an element for storing binary stuff
    void CreateBinaryStorage();
    // used on loading (at top level, prior to persisting)
    // - locates an element to be used for loading binary stuff
    void LocateBinaryStorage();
    // used on storing (at top level, after persisting the main staff)
    // - attaches the binary strage as the last child element of elemParent
    void CommitBinaryStorage();
    // returns element representing binary storage. Used from CPersistor
    CXMLElement GetBinaryStorage() { return m_XMLElemBinaryStorage; }

    SC ScCoCreate(bool bPutHeader);

    SC ScLoad(LPCWSTR strSource);
    SC ScLoad(IStream *pStream, bool bSilentOnErrors = false );
    SC ScSaveToFile(LPCTSTR lpcstrFileName);
    SC ScSave(CComBSTR &bstrResult);

private:
    // element representing binary storage
    CXMLElement m_XMLElemBinaryStorage;
};


/*+-------------------------------------------------------------------------*
 * class CXMLBinary
 *
 *
 * PURPOSE: GetGlobalSize() is alway rounded to allocation units,
 *          so to know the actual size of the memory blob, we need to
 *          carry the size information with HGLOBAL.
 *          This struct is solely to bind these guys
 *+-------------------------------------------------------------------------*/
class CXMLBinary
{
public:
    CXMLBinary();
    CXMLBinary(HGLOBAL handle, size_t size);
    ~CXMLBinary()   { Detach(); }

    void    Attach(HGLOBAL handle, size_t size);
    HGLOBAL Detach();
    size_t  GetSize() const;
    HGLOBAL GetHandle() const;
    SC      ScAlloc(size_t size, bool fZeroInit = false);
    SC      ScRealloc(size_t new_size, bool fZeroInit = false);
    SC      ScFree();

    SC      ScLockData(const void **ppData) const;
    SC      ScLockData(void **ppData) { return ScLockData(const_cast<const void **>(ppData)); }
    SC      ScUnlockData() const;

protected:
    // implementation helpers

private: // not implemented

    CXMLBinary(const CXMLBinary&);  // not implemented; not allowed;
    operator = (CXMLBinary&);       // not implemented; not allowed;

private:
    HGLOBAL             m_Handle;
    size_t              m_Size;
    mutable unsigned    m_Locks;
};


/*+-------------------------------------------------------------------------*
 * class CXMLAutoBinary
 *
 *
 * PURPOSE: same as CXMLAutoBinary, but frees the memory on destruction
 *+-------------------------------------------------------------------------*/
class CXMLAutoBinary : public CXMLBinary
{
public:
    CXMLAutoBinary() : CXMLBinary() {}
    CXMLAutoBinary(HGLOBAL handle, size_t size) : CXMLBinary(handle, size) {}
    ~CXMLAutoBinary()   { ScFree(); }
};

/*+-------------------------------------------------------------------------*
 * class CXMLBinaryLock
 *
 *
 * PURPOSE: provides data locking functionality which is automatically removed
 *          in destructor
 *+-------------------------------------------------------------------------*/
class CXMLBinaryLock
{
public:

    CXMLBinaryLock(CXMLBinary& binary);
    ~CXMLBinaryLock();

    template<typename T>
    SC ScLock(T **ppData)
    {
        return ScLockWorker(reinterpret_cast<void**>(ppData));
    }

    SC ScUnlock();

private: // not implemented

    CXMLBinaryLock(const CXMLBinaryLock&);  // not implemented; not allowed;
    operator = (CXMLBinaryLock&);           // not implemented; not allowed;

private:

    SC ScLockWorker(void **ppData);

    bool        m_bLocked;
    CXMLBinary& m_rBinary;
};

/*+-------------------------------------------------------------------------*
 * class CXMLValue
 *
 *
 * PURPOSE: Holds any type of value, in the spirit of a variant, except
 *          that a pointer to the original object is kept. This allows
 *          reading as well as writing to occur on the original object.
 *
 *+-------------------------------------------------------------------------*/
class CXMLValue
{
    friend class CXMLBoolean;
    enum XMLType
    {
        XT_I4,  //LONG
        XT_UI4, //ULONG
        XT_UI1, //BYTE
        XT_I2,  //SHORT
        XT_DW,  //DWORD
        XT_BOOL,//BOOL
        XT_CPP_BOOL,//bool
        XT_UINT,//UINT
        XT_INT, //INT
        XT_STR, //CStr
        XT_WSTR, // std::wstr
        XT_TSTR, // tstring
        XT_GUID, // GUID
        XT_BINARY, //HGLOBAL - unparsable data
        XT_EXTENSION
    };

    const XMLType m_type;
    union
    {
        LONG        *  pL;
        ULONG       *  pUl;
        BYTE        *  pByte;
        SHORT       *  pS;
        DWORD       *  pDw;
        UINT        *  pUint;
        INT         *  pInt;
        CStr        *  pStr;
        std::wstring * pWStr;
        tstring     * pTStr;
        GUID        * pGuid;
        CXMLBinary  * pXmlBinary;
        bool        *   pbool;
        BOOL        *   pBOOL;
        CXMLValueExtension     * pExtension;
    } m_val;

    // private constructor. used by friend class CXMLBoolean
    CXMLValue(XMLType type)         : m_type(type) { }
public:
    CXMLValue(const CXMLValue   &v) : m_type(v.m_type), m_val(v.m_val) { }
    CXMLValue(LONG &l)              : m_type(XT_I4)     { m_val.pL=&l; }
    CXMLValue(ULONG &ul)            : m_type(XT_UI4)    { m_val.pUl=&ul; }
    CXMLValue(BYTE &b)              : m_type(XT_UI1)    { m_val.pByte=&b; }
    CXMLValue(SHORT &s)             : m_type(XT_I2)     { m_val.pS=&s; }
    CXMLValue(UINT &u)              : m_type(XT_UINT)   { m_val.pUint=&u; }
    CXMLValue(INT &i)               : m_type(XT_INT)    { m_val.pInt=&i; }
    CXMLValue(CStr &str)            : m_type(XT_STR)    { m_val.pStr=&str; }
    CXMLValue(std::wstring &str)    : m_type(XT_WSTR)   { m_val.pWStr=&str; }
    CXMLValue(GUID &guid)           : m_type(XT_GUID)   { m_val.pGuid = &guid; }
    CXMLValue(CXMLBinary &binary)   : m_type(XT_BINARY) { m_val.pXmlBinary = &binary; }
    CXMLValue(tstring &tstr)        : m_type(XT_TSTR)   { m_val.pTStr = &tstr; }
    CXMLValue(CXMLValueExtension& ext) : m_type(XT_EXTENSION) { m_val.pExtension = &ext; }
    SC ScReadFromBSTR(const BSTR bstr);     // read input into the underlying variable.
    SC ScWriteToBSTR (BSTR * pbstr ) const; // writes the value into provided string
    LPCTSTR GetTypeName() const;
    // The following method is called when value is persisted as stand-alone element.
    // Depending on the result returned the contents may go to Binary Storage
    // see comment "CONCEPT OF BINARY STORAGE" above
    bool UsesBinaryStorage() const { return m_type == XT_BINARY; }
};

/*+-------------------------------------------------------------------------*
 * CXMLBoolean
 *
 *
 * PURPOSE: special case: booleans. Need to be printed as true/false, NOT as integer.
 *
 *+-------------------------------------------------------------------------*/
class CXMLBoolean : public CXMLValue
{
public:
    CXMLBoolean(BOOL &b) : CXMLValue(XT_BOOL)       { m_val.pBOOL = &b;}
    CXMLBoolean(bool &b) : CXMLValue(XT_CPP_BOOL)   { m_val.pbool = &b;}
};

/*+-------------------------------------------------------------------------*
 * CXMLValueExtension
 *
 *
 * PURPOSE: interface to extend CXMLValue by more sophisticated types
 *
 *+-------------------------------------------------------------------------*/
class CXMLValueExtension
{
public:
    virtual SC ScReadFromBSTR(const BSTR bstr) = 0;     // read input into the underlying variable.
    virtual SC ScWriteToBSTR (BSTR * pbstr ) const = 0; // writes the value into provided string
    virtual LPCTSTR GetTypeName() const = 0;
};

/*+-------------------------------------------------------------------------*
 * class EnumLiteral
 *
 *
 * PURPOSE: to define enum-to-literal mapping arrays (used by CXMLEnumeration)
 *
 *+-------------------------------------------------------------------------*/

struct EnumLiteral
{
    UINT    m_enum;
    LPCTSTR m_literal;
};


/*+-------------------------------------------------------------------------*
 * class CXMLEnumeration
 *
 *
 * PURPOSE: to persist enumeration as string literal
 *          using array of enum-to-literal mappings
 *
 *+-------------------------------------------------------------------------*/

class CXMLEnumeration : public CXMLValueExtension
{
    // just an enum sized type to hold reference
    // while many enum types will be used, internally they
    // will be cast to this type
    enum enum_t { JUST_ENUM_SIZE_VALUE };
public:

    // template constructor to allow different enums to be persisted
    template<typename _ENUM>
    CXMLEnumeration(_ENUM& en, const EnumLiteral * const etols, size_t count)
                : m_pMaps(etols) ,  m_count(count), m_rVal((enum_t&)(en))
    {
        // folowing lines won't compile in case you are trying to pass
        // type other than enum or int
        COMPILETIME_ASSERT( sizeof(en) == sizeof(enum_t) );
        UINT testit = en;
    }

    // CXMLValueExtension metods required to implement
    SC ScReadFromBSTR(const BSTR bstr);     // read input into the underlying variable.
    SC ScWriteToBSTR (BSTR * pbstr ) const; // writes the value into provided string
    LPCTSTR GetTypeName() const { return _T("Enumerations"); }

    // to enable passing itself as CMLValue
    operator CXMLValue ()
    {
        return CXMLValue (*this);
    }

private:
    enum_t                          &m_rVal;
    const   EnumLiteral * const     m_pMaps;
    const   size_t                  m_count;
};

/*+-------------------------------------------------------------------------*
 * class CXMLBitFlags
 *
 *
 * PURPOSE: to persist bit flags as string literals
 *          using array of enum-to-literal mappings
 *
 *+-------------------------------------------------------------------------*/

class CXMLBitFlags
{
public:

    // template constructor to allow different enums to be persisted
    template<typename _integer>
    CXMLBitFlags(_integer& flags, const EnumLiteral * const etols, size_t count)
                : m_pMaps(etols) ,  m_count(count), m_rVal((UINT&)flags)
    {
        // folowing lines won't compile in case you are trying to pass
        // type other than enum or int
        COMPILETIME_ASSERT( sizeof(flags) == sizeof(UINT) );
        UINT testit = flags;
    }

    void PersistMultipleAttributes(LPCTSTR name, CPersistor &persistor);

private:
    UINT                           &m_rVal;
    const   EnumLiteral * const     m_pMaps;
    const   size_t                  m_count;
};

/*+-------------------------------------------------------------------------*
 * class XMLPoint
 *
 *
 * PURPOSE: Holds the name and value of a point object
 *
 *+-------------------------------------------------------------------------*/
class XMLPoint : public CXMLObject
{
    CStr            m_strObjectName;
    POINT    &      m_point;
public:
    XMLPoint(const CStr& strObjectName, POINT &point);

    DEFINE_XML_TYPE(XML_TAG_POINT);
    virtual void    Persist(CPersistor &persistor);
};

/*+-------------------------------------------------------------------------*
 * class XMLRect
 *
 *
 * PURPOSE: Holds the name and value of a rectangle object
 *
 *+-------------------------------------------------------------------------*/
class XMLRect : public CXMLObject
{
    CStr            m_strObjectName;
    RECT    &       m_rect;
public:
    XMLRect(const CStr strObjectName, RECT &rect);

    DEFINE_XML_TYPE(XML_TAG_RECTANGLE);
    virtual void    Persist(CPersistor &persistor);
};

/*+-------------------------------------------------------------------------*
 * class XMLListCollectionBase
 *
 *
 * PURPOSE: Defines the base list collection class for persisting stl:list's
 *          It's intended to be used as a base for deriving list persitence classes
 *          Persist method implements "load" by iterating thru xml elements
 *          and calling OnNewElement for each, and can be reused by derived classes.
 *
 * USAGE:   Probably the better idea is to use XMLListColLectionImp
 *          as a base to your collection instead of this class (it is richer). Use this class
 *          only if your class has special items which does not allow you to use that class.
 *
 *+-------------------------------------------------------------------------*/
class XMLListCollectionBase: public CXMLObject
{
public:
    // function called when new element is to be created and loaded
    virtual void OnNewElement(CPersistor& persistor) = 0;
    virtual void Persist(CPersistor& persistor);
};

/*+-------------------------------------------------------------------------*
 * class XMLListCollectionImp
 *
 * PURPOSE: A base class for stl::list derived collections implementing persitence of
 *          the list items as linear sequence of xml items.
 *          The items kept in the list must be either CXMLObject-derived or be
 *          of the simple type (one accepted by CXMLVBalue constructors)
 *
 * USAGE:   Derive your class from XMLListCollectionImp parametrized by the list,
 *          instead of deriving from stl::list directly. use DEFINE_XML_TYPE
 *          to define tag name for collections element.
 *
 * NOTE:    Your class should implement: GetXMLType() to be functional.
 *          you can use DEFINE_XML_TYPE macro to do it for you
 *
 * NOTE:    if provided implementation does not fit for you - f.i. your elements need
 *          a parameter to the constructor, or special initialization,
 *          use XMLListCollectionBase instead and provide your own methods
 *+-------------------------------------------------------------------------*/
template<class LT>
class XMLListCollectionImp: public XMLListCollectionBase , public LT
{
    typedef LT::iterator iter_t;
public:
    virtual void Persist(CPersistor& persistor)
    {
        if (persistor.IsStoring())
        {
            for(iter_t it = begin(); it != end(); ++it)
                persistor.Persist(*it);
        }
        else
        {
            clear();
            // let the base class do the job
            // it will call OnNewElement for every element found
            XMLListCollectionBase::Persist(persistor);
        }
    }
    // method called to create and load new element
    virtual void OnNewElement(CPersistor& persistor)
    {
        iter_t it = insert(end());
        persistor.Persist(*it);
    }
};

/*+-------------------------------------------------------------------------*
 * class XMLListCollectionWrap
 *
 * PURPOSE: A wrapper around stl::list to support persisting
 *          To be used to persist stl::list objects "from outside" - i.e. without
 *          deriving the list class from persistence-enabled classes.
 *
 * USAGE:   If you have list m_l to persist, create the object XMLListCollectionWrap wrap(m_l,"tag")
 *          on the stack and persist that object (f.i. Persistor.Persist(wrap)
 *
 * NOTE:    if provided implementation does not fit for you - see if you can use
 *          XMLListCollectionImp or XMLListCollectionBase as a base for your list.
 *+-------------------------------------------------------------------------*/
template<class LT>
class XMLListCollectionWrap: public XMLListCollectionBase
{
    typedef LT::iterator iter_t;
    LT & m_l;
    CStr    m_strListType;
public:
    XMLListCollectionWrap(LT &l, const CStr &strListType)
        : m_l(l), m_strListType(strListType) {}
    virtual void Persist(CPersistor& persistor)
    {
        if (persistor.IsStoring())
        {
            for(iter_t it = m_l.begin(); it != m_l.end(); ++it)
                persistor.Persist(*it);
        }
        else
        {
            m_l.clear();
            // let the base class do the job
            // it will call OnNewElement for every element found
            XMLListCollectionBase::Persist(persistor);
        }
    }
    // method called to create and load new element
    virtual void OnNewElement(CPersistor& persistor)
    {
        iter_t it = m_l.insert(m_l.end());
        persistor.Persist(*it);
    }
    virtual LPCTSTR GetXMLType() {return m_strListType;}
private:
    // to prevent ivalid actions on object
    XMLListCollectionWrap(const XMLListCollectionWrap& other);
    XMLListCollectionWrap& operator = ( const XMLListCollectionWrap& other ) { return *this; }
};

/*+-------------------------------------------------------------------------*
 * class XMLMapCollectionBase
 *
 *
 * PURPOSE: Defines the base map collection class for persisting stl:map's
 *          It's intended to be used as a base for deriving map persitence classes.
 *          Persist method implements "load" by iterating thru xml elements
 *          and calling OnNewElement for each pair, and can be reused by derived classes.
 *
 * USAGE:   Probably the better idea is to use XMLMapCollection or XMLMapColLectionImp
 *          as a base to your collection instead of this class (they are richer). Use this class
 *          only if your class has special items which does not allow you to use those classes.
 *
 *+-------------------------------------------------------------------------*/
class XMLMapCollectionBase: public CXMLObject
{
public:
    // function called when new element is to be created and loaded
    virtual void OnNewElement(CPersistor& persistKey,CPersistor& persistVal) = 0;
    // base implementation [loading only!] enumerates elements calling OnNewElement for each
    virtual void Persist(CPersistor& persistor);
};

/*+-------------------------------------------------------------------------*
 * class XMLMapCollection
 *
 * PURPOSE: Use this class only when you cannot use XMLMapCollectionImp due to
 *          special requirements on construction of the elements kept in the map
 *          (see also purpose of XMLMapCollectionImp)
 *
 * USAGE:   Derive your class from XMLMapCollection parametrized by the map,
 *          instead of deriving from stl::map directly. use DEFINE_XML_TYPE
 *          to define tag name for collections element. Define OnNewElement
 *
 * NOTE:    Your class should implement: GetXMLType() to be functional.
 *          you can use DEFINE_XML_TYPE macro to do it for you
 *
 * NOTE:    Your class should implement: OnNewElement to be functional.
 *
 * NOTE:    if provided implementation does not fit for you -
 *          use XMLMapCollectionBase instead and provide your own methods
 *+-------------------------------------------------------------------------*/
template<class MT>
class XMLMapCollection: public XMLMapCollectionBase, public MT
{
    typedef MT::iterator iter_t;
public:
    virtual void Persist(CPersistor& persistor)
    {
        if (persistor.IsStoring())
        {
            for(iter_t it = begin(); it != end(); ++it)
            {
                MT::key_type *pKey = const_cast<MT::key_type*>(&it->first);
                persistor.Persist(*pKey);
                persistor.Persist(it->second);
            }
        }
        else
        {
            clear();
            XMLMapCollectionBase::Persist(persistor);
        }
    }
};

/*+-------------------------------------------------------------------------*
 * class XMLMapCollectionImp
 *
 * PURPOSE: A base class for stl::map derived collections implementing persitence of
 *          the map items as linear sequence of xml items.
 *          The items kept in the map must be either CXMLObject-derived or be
 *          of the simple type (one accepted by CXMLVBalue constructors)
 *
 * USAGE:   Derive your class from XMLMapCollectionImp parametrized by the map,
 *          instead of deriving from stl::map directly. use DEFINE_XML_TYPE
 *          to define tag name for collections element.
 *
 * NOTE:    Your class should implement: GetXMLType() to be functional.
 *          you can use DEFINE_XML_TYPE macro to do it for you
 *
 * NOTE:    if provided implementation does not fit for you - f.i. your elements need
 *          a parameter to the constructor, or special initialization,
 *          use XMLMapCollection or XMLMapCollectionBase instead and provide your own methods
 *+-------------------------------------------------------------------------*/
template<class MT>
class XMLMapCollectionImp: public XMLMapCollection<MT>
{
public:
    virtual void OnNewElement(CPersistor& persistKey,CPersistor& persistVal)
    {
        MT::key_type key;
        persistKey.Persist(key);

        MT::referent_type val;
        persistVal.Persist(val);

        insert(MT::value_type(key,val));
    }
};

/*+-------------------------------------------------------------------------*
 * class XMLListCollectionWrap
 *
 * PURPOSE: A wrapper around stl::map to support persisting
 *          To be used to persist stl::map objects "from outside" - i.e. without
 *          deriving the map class from persistence-enabled classes.
 *
 * USAGE:   If you have map m_m to persist, create the object XMLMapCollectionWrap wrap(m_m,"tag")
 *          on the stack and persist that object (f.i. Persistor.Persist(wrap)
 *
 * NOTE:    if provided implementation does not fit for you - see if you can use
 *          XMLMapCollection or XMLMapCollectionImp or XMLMapCollectionBase as a base for your map
 *+-------------------------------------------------------------------------*/
template<class MT>
class XMLMapCollectionWrap: public XMLMapCollectionBase
{
    typedef MT::iterator iter_t;
    MT & m_m;
    CStr    m_strMapType;
public:
    XMLMapCollectionWrap(MT &m, const CStr &strMapType) : m_m(m), m_strMapType(strMapType) {}
    virtual void OnNewElement(CPersistor& persistKey,CPersistor& persistVal)
    {
        MT::key_type key;
        persistKey.Persist(key);

        MT::referent_type val;
        persistVal.Persist(val);

        m_m.insert(MT::value_type(key,val));
    }
    virtual void Persist(CPersistor& persistor)
    {
        if (persistor.IsStoring())
        {
            for(iter_t it = m_m.begin(); it != m_m.end(); ++it)
            {
                MT::key_type *pKey = const_cast<MT::key_type*>(&it->first);
                persistor.Persist(*pKey);
                persistor.Persist(it->second);
            }
        }
        else
        {
            m_m.clear();
            XMLMapCollectionBase::Persist(persistor);
        }
    }
    virtual LPCTSTR GetXMLType() {return m_strMapType;}
private:
    // to prevent ivalid actions on object
    XMLMapCollectionWrap(const XMLMapCollectionWrap& other);
    XMLMapCollectionWrap& operator = ( const XMLMapCollectionWrap& other ) { return *this; }
};

/*+-------------------------------------------------------------------------*
 * class CPersistor
 *
 *
 * PURPOSE: Defines the Persistor class used for XML serialization
 *             Persistors are aware if the file is being loaded or saved. Thus,
 *             methods like Persist work for both directions, and
 *             uses references to the data being persisted.
 *
 * USAGE:   1) a persistor can be created "underneath" another persistor, using
 *          the appropriate constructor.
 *          2) To make an object persistable, derive it from CXMLObject, and
 *             implement the abstract methods. The syntax persistor.Persits(object)
 *             will then automatically work correctly.
 *          3) To persist an element use Pesist method. It will create new / locate
 *             CPersist object for an element (under this persistor's element)
 *          4) Collection classes when persisting their members specify "bLockedOnChild"
 *             constructors parameter as "true". This technique changes persistor's
 *             behavior. Insted of loacting the element (#3), constructor of new
 *             persistor will only check if element pointed by parent is of required type.
 *
 * NOTES:   1) StringTableStrings can be saved with either the ID inline or the
 *             actual string value inline. The latter is useful when loading/saving
 *             XML to/from a string instead of a file. This is controlled by the
 *	           EnableValueSplit method.
 *             Binary storage usage is also controlled by it
 *+-------------------------------------------------------------------------*/
class CPersistor
{
    // NOTE: if member variable is to be inherited by child persistors,
    // don't forget to add it to CPersistor::BecomeAChildOf method
    CXMLDocument    m_XMLDocument;
    CXMLElement     m_XMLElemCurrent;
    bool            m_bIsLoading;
    bool            m_bLockedOnChild;
    DWORD           m_dwModeFlags;     // any special modes

private:
    void  SetMode(PersistorMode mode, bool bEnable) {m_dwModeFlags = (m_dwModeFlags & ~mode) | (bEnable ? mode : 0);}
    bool  IsModeSet(PersistorMode mode)  {return (m_dwModeFlags & mode);}
public:
    void  SetMode(PersistorMode mode)               {m_dwModeFlags = mode;}


public:
    // construct a persistor from a parent persistor.
    // this creates a new XML element with the given name,
    // and everything persisted to the new persistor
    // is persisted under this element.
    CPersistor(CPersistor &persistorParent, const CStr &strElementType, LPCTSTR szElementName = NULL);
    // construct a new persistor for given document and root element
    // everything persisted to the new persistor
    // is persisted under this element.
    CPersistor(CXMLDocument &document, CXMLElement& rElemRoot);
    // used to create child persistor on particular element
    // bLockedOnChild is used to create a "fake parent" persistor, which
    // will always return the child without trying to locate it (pElemCurrent)
    CPersistor(CPersistor &other, CXMLElement& rElemCurrent, bool bLockedOnChild = false);

    CXMLDocument &  GetDocument()                  {return (m_XMLDocument);}
    CXMLElement  &  GetCurrentElement()                 {return (m_XMLElemCurrent);}
    bool            HasElement(const CStr &strElementType, LPCTSTR szstrElementName);
    void            EnableValueSplit       (bool bEnable)      { SetMode(persistorModeValueSplitEnabled,       bEnable); }

    // the various modes
    bool            FEnableValueSplit()                {return IsModeSet(persistorModeValueSplitEnabled);}

    // Load/Store mode related functions.
    bool            IsLoading()        {return m_bIsLoading;}
    bool            IsStoring()        {return !m_bIsLoading;}
    void            SetLoading(bool b) {m_bIsLoading = b;}

    // special methods to set/get the Name attribute of a persistor
    void            SetName(const CStr & strName);
    CStr            GetName();

    // Canned persistence methods:

    // .. to persist CXMLObject-derived object under own sub-element
    // <this><object_tag>object_body</object_tag></this>
    void Persist(CXMLObject &object, LPCTSTR lpstrName = NULL);

    // .. to persist value of the simple type under own sub-element
    // <this><value_type value="value"/></this>
    void Persist(CXMLValue xval, LPCTSTR name = NULL);

    // .. to persist value as named attribute of this element
    // <this name="value"/>
    void PersistAttribute(LPCTSTR name,CXMLValue xval,const XMLAttributeType type = attr_required);

    // .. to persist value as contents of this element
    // <this>value</this>
    // NOTE:  xml element cannot have both value-as-contents and sub-elements
    void PersistContents(CXMLValue xval);

    // .. to persist flags as separate attributes
    void PersistAttribute( LPCTSTR name, CXMLBitFlags& flags );

    /***************************************************************************\
     *
     * METHOD:  CPersistor::PersistList
     *
     * PURPOSE: it is designated for persisting std::list type of collections
     *          as a subelement of the persistor.
     *          NOTE: list elements need to be either CXMLObject-derived or be
     *                of the simple type (one accepted by CXMLVBalue constructors)
     *          NOTE2: list elements must have default constuctor available
     *
     * PARAMETERS:
     *    const CStr &strListType   - [in] tag of new subelement
     *    LPCTSTR name              - [in] name attr. of new subelement (NULL == none)
     *    std::list<T,Al>& val      - [in] list to be persisted
     *
     * RETURNS:
     *    void
     *
    \***************************************************************************/
    template<class T, class Al>
    void PersistList(const CStr &strListType, LPCTSTR name,std::list<T,Al>& val)
    {
        typedef std::list<T,Al> LT;
        XMLListCollectionWrap<LT> lcol(val,strListType);
        Persist(lcol, name);
    }

    /***************************************************************************\
     *
     * METHOD:  PersistMap
     *
     * PURPOSE: it is designated for persisting std::map type of collections
     *          as a subelement of the persistor.
     *          NOTE: map elements (both key and val) need to be either CXMLObject-derived
     *                or be of the simple type (one accepted by CXMLVBalue constructors)
     *          NOTE2: map elements must have default constuctor available
     *
     * PARAMETERS:
     *    const CStr &strListType   - [in] tag of new subelement
     *    LPCTSTR name              - [in] name attr. of new subelement (NULL == none)
     *    std::map<K,T,Pr,Al>& val  - [in] map to be persisted
     *
     * RETURNS:
     *    void
     *
    \***************************************************************************/
    template<class K, class T, class Pr, class Al>
    void PersistMap(const CStr &strMapType, LPCTSTR name, std::map<K, T, Pr, Al>& val)
    {
        typedef std::map<K, T, Pr, Al> MT;
        XMLMapCollectionWrap<MT> mcol(val,strMapType);
        Persist(mcol, name);
    }

    void PersistString(LPCTSTR lpstrName, CStringTableStringBase &str);

private: // private implementation helpers
    // common constructor, not to be used from outside.
    // provided as common place for member initialization
    // all the constructors should call it prior to doing anything specific.
    void CommonConstruct();
    // element creation / locating
    CXMLElement AddElement(const CStr &strElementType, LPCTSTR szElementName);
    CXMLElement GetElement(const CStr &strElementType, LPCTSTR szstrElementName, int iIndex = -1);
    void AddTextElement(BSTR bstrData);
    void GetTextElement(CComBSTR &bstrData);
    CXMLElement CheckCurrentElement(const CStr &strElementType, LPCTSTR szstrElementName);
    void BecomeAChildOf(CPersistor &persistorParent, CXMLElement elem);
};


/*+-------------------------------------------------------------------------*
 * class CXML_IStorage
 *
 * PURPOSE: This class provides memory-based implementation of IStorage plus
 *          it supports persisting the data on the storage to/from XML.
 *          Mostly used to create IStorage for snapin data to be saved
 *          to console file as XML binary blob
 *
 * USAGE:   You will create the object whenever you need a memory-based IStorage
 *          implementation. To access IStorage interface use GetIStorage() method.
 *          It will create a storage if does not have one under control already.
 *          You will use returned pointer for Read and Write operations.
 *          Whenever required you will pass the object to CPersistor::Persist method
 *          to have it persisted using XML persistence model.
 *
 * NOTE:    You are encoureged to use GetIStorage() for accessing the undelying IStorage.
 *          Do not cache returned pointer, since the storage may change when persisted
 *          from XML, and this invalidates the pointer. However if you AddRef,
 *          the pointer will be valid as long as the last reference is released.
 *          That means it may outlive CXML_IStorage object itself - nothing wrong with that.
 *          You only must be aware that once persistence (loading) from XML is completed,
 *          CXML_IStorage will switch to the new storage and it will not be in sync with
 *          the pointer you have. Always use GetIStorage() to get the current pointer.
 *
 *+-------------------------------------------------------------------------*/
class CXML_IStorage : public CXMLObject
{
public: // interface methods not throwing any exceptions
    
    SC ScInitializeFrom( IStorage *pSource );
    SC ScInitialize(bool& bCreatedNewOne);
    SC ScGetIStorage( IStorage **ppStorage );
    SC ScRequestSave(IPersistStorage * pPersistStorage);

    // instruct to persist to binary storage
    virtual bool UsesBinaryStorage() { return true; }

    DEFINE_XML_TYPE(XML_TAG_ISTORAGE);

public: // interface methods throwing SC's

    virtual void Persist(CPersistor &persistor);

private:
    IStoragePtr     m_Storage;
    ILockBytesPtr   m_LockBytes;
// following methods\data is for trace support in CHK builds
#ifdef DBG
public:
    DBG_PersistTraceData m_dbg_Data;
#endif // #ifdef DBG
}; // class CXML_IStorage


/*+-------------------------------------------------------------------------*
 * class CXML_IStream
 *
 * PURPOSE: This class provides memory-based implementation of IStream plus
 *          it supports persisting the data on the stream to/from XML.
 *          Mostly used to create IStream for snapin data to be saved
 *          to console file as XML binary blob
 *
 * USAGE:   You will create the object whenever you need a memory-based IStream
 *          implementation. To access IStream interface use GetIStream() method.
 *          It will create a stream if does not have one under control already.
 *          You will use returned pointer for Read and Write operations.
 *          Whenever required you will pass the object to CPersistor::Persist method
 *          to have it persisted using XML persistence model.
 *
 * NOTE:    You are encoureged to use GetIStream() for accessing the undelying IStream.
 *          Do not cache returned pointer, since the stream may change when persisted
 *          from XML, and this invalidates the pointer. However if you AddRef,
 *          the pointer will be valid as long as the last reference is released.
 *          That means it may outlive CXML_IStream object itself - nothing wrong with that.
 *          You only must be aware that once persistence (loading) from XML is completed,
 *          CXML_IStream will switch to the new stream and it will not be in sync with
 *          the pointer you have. Always use GetIStream() to get the current pointer.
 *
 * NOTE:    Every call to GetIStream() moves stream cursor to the begining of the stream
 *
 *+-------------------------------------------------------------------------*/
class CXML_IStream : public CXMLObject
{
public: // interface methods not throwing any exceptions
    
    SC ScInitializeFrom( IStream *pSource );
    SC ScInitialize(bool& bCreatedNewOne);
    SC ScSeekBeginning();
    SC ScGetIStream( IStream **ppStream );
    SC ScRequestSave(IPersistStorage * pPersistStream);
    inline SC ScRequestSave(IPersistStream * pPersistStream)
    {
        return ScRequestSaveX(pPersistStream);
    }
    inline SC ScRequestSave(IPersistStreamInit * pPersistStreamInit)
    {
        return ScRequestSaveX(pPersistStreamInit);
    }

    // instruct to persist to binary storage
    virtual bool UsesBinaryStorage() { return true; }

    DEFINE_XML_TYPE(XML_TAG_ISTREAM);

public:
    virtual void Persist(CPersistor &persistor);

private:
    template<class TIPS>
    SC ScRequestSaveX(TIPS * pPersistStream)
    {
        DECLARE_SC(sc, TEXT("CXML_IStream::ScRequestSaveX"));

        // initialize
        bool bCreatedNewOne = false; // unused here
        sc = ScInitialize(bCreatedNewOne);
        if (sc)
            return sc;

        // recheck pointers
        sc = ScCheckPointers( m_Stream, E_UNEXPECTED );
        if (sc)
            return sc;
        
        ULARGE_INTEGER null_size = { 0, 0 };
        sc = m_Stream->SetSize( null_size );
        if(sc)
            return sc;
        
        sc = ScSeekBeginning();
        if(sc)
            return sc;

        sc = pPersistStream->Save( m_Stream, TRUE );
        if(sc)
            return sc;

        // commit the changes - this ensures everything is in HGLOBAL
        sc = m_Stream->Commit( STGC_DEFAULT );
        if(sc)
            return sc;

#ifdef DBG
        if (S_FALSE != pPersistStream->IsDirty())
            DBG_TraceNotResettingDirty(typeid(TIPS).name());
#endif // #ifdef DBG

        return sc;
    }
private:
    IStreamPtr  m_Stream;
#ifdef DBG // tracing support
public:
    DBG_PersistTraceData m_dbg_Data;
    void DBG_TraceNotResettingDirty(LPCSTR strIntfName);
#endif // #ifdef DBG
}; // class CXML_IStream

/*+-------------------------------------------------------------------------*
 * class CXMLPersistableIcon
 *
 * PURPOSE: Persists wraps for persisting CPersistableIcon
 *
 * USAGE:   Create object whenever you need to persist to CPersistableIcon
 *
 *+-------------------------------------------------------------------------*/

class CPersistableIcon;

class CXMLPersistableIcon : public CXMLObject
{
    CPersistableIcon& m_Icon;
public:
    CXMLPersistableIcon(CPersistableIcon& Icon) : m_Icon(Icon) {}
    DEFINE_XML_TYPE(XML_TAG_ICON);
    virtual void    Persist(CPersistor &persistor);
};


/*+-------------------------------------------------------------------------*
 * CXMLVariant
 *
 * This class implements a CComVariant that can persist itself to/from an
 * XML persistor.
 *--------------------------------------------------------------------------*/

class CXMLVariant :
    public CComVariant,
    public CXMLObject
{
public:
    // construction and assignment forwarders
    CXMLVariant() {}
    CXMLVariant(const VARIANT& varSrc)                  : CComVariant(varSrc)       {}
    CXMLVariant(const CComVariant& varSrc)              : CComVariant(varSrc)       {}
    CXMLVariant(const CXMLVariant& varSrc)              : CComVariant(varSrc)       {}
    CXMLVariant(BSTR bstrSrc)                           : CComVariant(bstrSrc)      {}
    CXMLVariant(LPCOLESTR lpszSrc)                      : CComVariant(lpszSrc)      {}
#ifndef OLE2ANSI
    CXMLVariant(LPCSTR lpszSrc)                         : CComVariant(lpszSrc)      {}
#endif
    CXMLVariant(bool bSrc)                              : CComVariant(bSrc)         {}
    CXMLVariant(int nSrc)                               : CComVariant(nSrc)         {}
    CXMLVariant(BYTE nSrc)                              : CComVariant(nSrc)         {}
    CXMLVariant(short nSrc)                             : CComVariant(nSrc)         {}
    CXMLVariant(float fltSrc)                           : CComVariant(fltSrc)       {}
    CXMLVariant(double dblSrc)                          : CComVariant(dblSrc)       {}
    CXMLVariant(CY cySrc)                               : CComVariant(cySrc)        {}
    CXMLVariant(long nSrc, VARTYPE vtSrc = VT_I4)       : CComVariant(nSrc, vtSrc)  {}

    CXMLVariant& operator=(const CXMLVariant& varSrc)   { CComVariant::operator=(varSrc);   return (*this); }
    CXMLVariant& operator=(const CComVariant& varSrc)   { CComVariant::operator=(varSrc);   return (*this); }
    CXMLVariant& operator=(const VARIANT& varSrc)       { CComVariant::operator=(varSrc);   return (*this); }
    CXMLVariant& operator=(BSTR bstrSrc)                { CComVariant::operator=(bstrSrc);  return (*this); }
    CXMLVariant& operator=(LPCOLESTR lpszSrc)           { CComVariant::operator=(lpszSrc);  return (*this); }
#ifndef OLE2ANSI
    CXMLVariant& operator=(LPCSTR lpszSrc)              { CComVariant::operator=(lpszSrc);  return (*this); }
#endif
    CXMLVariant& operator=(bool bSrc)                   { CComVariant::operator=(bSrc);     return (*this); }
    CXMLVariant& operator=(int nSrc)                    { CComVariant::operator=(nSrc);     return (*this); }
    CXMLVariant& operator=(BYTE nSrc)                   { CComVariant::operator=(nSrc);     return (*this); }
    CXMLVariant& operator=(short nSrc)                  { CComVariant::operator=(nSrc);     return (*this); }
    CXMLVariant& operator=(long nSrc)                   { CComVariant::operator=(nSrc);     return (*this); }
    CXMLVariant& operator=(float fltSrc)                { CComVariant::operator=(fltSrc);   return (*this); }
    CXMLVariant& operator=(double dblSrc)               { CComVariant::operator=(dblSrc);   return (*this); }
    CXMLVariant& operator=(CY cySrc)                    { CComVariant::operator=(cySrc);    return (*this); }

public:
    DEFINE_XML_TYPE(XML_TAG_VARIANT);
    virtual void Persist(CPersistor &persistor);

    bool IsPersistable() const
        { return (IsPersistable(this)); }

    static bool IsPersistable(const VARIANT* pvar)
    {
        if (pvar == NULL)
            return (false);

        /*
         * we can only store variants that are "simple" (i.e. not by-ref,
         * array, etc.)
         */
        return ((V_VT(pvar) & ~VT_TYPEMASK) == 0);
    }
};

/***************************************************************************\
 *
 * CLASS:  CConsoleFilePersistor
 *
 * PURPOSE: File persistence black box. all console file - user data logic
 *          is hiden under this class
 *
 * USAGE:   Use instance of this class to load and save console file,
 *          NOTE - saving should be done with the same instance the console
 *          was loaded.
 *          Good idea for your class maintaning console (such as AMCDocument)
 *          to either derive of contain instance of this class
 *
\***************************************************************************/
class CConsoleFilePersistor
{
public: // public interface

    CConsoleFilePersistor() : m_bCRCValid(false) {}

    SC ScSaveConsole(LPCTSTR lpstrConsolePath, bool bForAuthorMode, const CXMLDocument& xmlDocument);
    SC ScLoadConsole(LPCTSTR lpstrConsolePath, bool& bXmlBased, CXMLDocument& xmlDocument,
                     IStorage **ppStorage);

    static SC ScGetUserDataFolder(tstring& strUserDataFolder);

private: // implementation helpers

    static SC ScGetUserDataPath(LPCTSTR lpstrOriginalPath, tstring& strUserDataPath);
    static SC ScGetUserData(const tstring& strUserDataConsolePath,
                            const tstring& strFileCRC,
                            bool& bValid, CXMLDocument& xmlDocument);

    static SC ScOpenDocAsStructuredStorage(LPCTSTR lpszPathName, IStorage **ppStorage);
    static SC ScLoadXMLDocumentFromFile(CXMLDocument& xmlDocument, LPCTSTR strFileName, bool bSilentOnErrors = false);

private: // compress/uncompress the file
    static void GetBinaryCollection(CXMLDocument& xmlDocument, CXMLElementCollection&  colBinary);
    static SC ScCompressUserStateFile(LPCTSTR szConsoleFilePath, CXMLDocument & xmlDocument);
    static SC ScUncompressUserStateFile(CXMLDocument &xmlDocumentOriginal, CXMLDocument& xmlDocument);

private: // internal data

    tstring m_strFileCRC;
    bool    m_bCRCValid;
};

#endif // XMLBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\xmlimage.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      xmlimage.h
 *
 *  Contents:  Interface file for CXMLImageList
 *
 *  History:   10-Aug-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


#include "xmlbase.h"			// for CXMLObject
#include "atlbase.h"			// for CComModule
#include "atlapp.h"				// required by atlctrls.h
extern CComModule _Module;		// required by atlwin.h
#include "atlwin.h"				// required by atlctrls.h
#include "atlctrls.h"			// for WTL::CImageList
#include "strings.h"			// for XML_TAG_VALUE_BIN_DATA

/*+-------------------------------------------------------------------------*
 * class CXMLImageList
 *
 * This class adds XML persistence to WTL::CImageLists.
 *--------------------------------------------------------------------------*/

class CXMLImageList :
	public CXMLObject,
	public WTL::CImageList
{
public:
    // CXMLObject methods
    virtual void Persist(CPersistor &persistor);
    virtual bool UsesBinaryStorage()				{ return (true); }
    DEFINE_XML_TYPE(XML_TAG_VALUE_BIN_DATA);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\inc\xmlicon.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      xmlicon.h
 *
 *  Contents:  Interface file for CXMLIcon
 *
 *  History:   26-Jul-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include "xmlbase.h"	// for CXMLObject
#include "smarticon.h"	// for CSmartIcon


/*+-------------------------------------------------------------------------*
 * class CXMLIcon
 *
 * This class adds XML persistence to CSmartIcons.  CSmartIcon cannot
 * implement XML persistence on its own because it is used in the shell
 * extension.  The shell extension must be extremely lightweight, but
 * XML persistence requires mmcbase.dll.  Depending on mmcbase.dll would
 * make the shell extension too heavy, so we have this functionality split.
 *--------------------------------------------------------------------------*/

class CXMLIcon :
	public CXMLObject,
	public CSmartIcon
{
public:
	CXMLIcon (LPCTSTR pszBinaryEntryName = NULL) :
		m_strBinaryEntryName ((pszBinaryEntryName != NULL) ? pszBinaryEntryName : _T(""))
	{}

	// default copy construction, copy assignment, and destruction are fine

	CXMLIcon& operator= (const CSmartIcon& other)
	{
		CSmartIcon::operator= (other);
		return (*this);
	}

    // CXMLObject methods
public:
    virtual void Persist(CPersistor &persistor);
    virtual bool UsesBinaryStorage()				{ return (true); }
    virtual LPCTSTR GetBinaryEntryName();
    DEFINE_XML_TYPE(XML_TAG_CONSOLE_ICON);

private:
	const tstring	m_strBinaryEntryName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\lib\clsid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       clsid.c
//
//--------------------------------------------------------------------------

#include "ndmgr.h"

// This is an alternate name for the CLSID CLSID_NodeInit. There is a cpp_quote statement
// in mmc.idl to declare the extern.  This is what is published to the snap-ins

CLSID const CLSID_NodeManager =
    {0x43136EB5,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


// {80F94176-FCCC-11d2-B991-00C04F8ECD78}
const CLSID CLSID_MessageView =
{ 0x80f94176, 0xfccc, 0x11d2, { 0xb9, 0x91, 0x0, 0xc0, 0x4f, 0x8e, 0xcd, 0x78 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\lib\mmciid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmciid.c
//
//--------------------------------------------------------------------------

#include <mmc_i.c>      // from <root>\admin\published\mmc
#include <mmcobj_i.c>   // from <root>\admin\published\mmc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\lib\apimfc.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       apimfc.cpp
//
//  Contents:   
//
//  APIs:       MFC specific API in core
//
//____________________________________________________________________________
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers
#include <afxwin.h>         // MFC core and standard components

#include "..\inc\mmc.h"



LPFNPSPCALLBACK _MMCHookPropertyPage;
HHOOK           _MMCmsgHook;

LRESULT CALLBACK _MMCHookCBTProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    ASSERT(_MMCmsgHook != 0);

    if (nCode < 0)
        return CallNextHookEx(_MMCmsgHook, nCode, wParam, lParam);

    if (nCode == HCBT_CREATEWND)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        CallNextHookEx(_MMCmsgHook, nCode, wParam, lParam);
        UnhookWindowsHookEx(_MMCmsgHook);
    }
    
    return 0; // Allow the window to be created
}


UINT CALLBACK _MMCHookPropSheetPageProc(HWND hwnd,UINT uMsg,LPPROPSHEETPAGE ppsp)
{
    UINT i = _MMCHookPropertyPage(hwnd, uMsg, ppsp);
    
    switch (uMsg)
    {
        case PSPCB_CREATE:
            _MMCmsgHook = SetWindowsHookEx (WH_CBT, _MMCHookCBTProc, 
                                            GetModuleHandle(NULL), 
                                            GetCurrentThreadId());
            break;
    } 

    return i;
}


HRESULT STDAPICALLTYPE MMCPropPageCallback(void* vpsp)
{
    if (vpsp == NULL)
        return E_POINTER;

    LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)vpsp;

    if ((void*)psp->pfnCallback == (void*)_MMCHookPropSheetPageProc)
        return E_UNEXPECTED;

    _MMCHookPropertyPage = psp->pfnCallback;
    psp->pfnCallback = _MMCHookPropSheetPageProc;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\lib\api.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       API.c
//
//  Contents:
//
//  APIs:       MMCPropertyChangeNotify
//
//  History:    10/15/1996   RaviR   Created
//____________________________________________________________________________
//

#include <wtypes.h>
#include "objbase.h"
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include "commctrl.h" // for LV_ITEMW needed by ndmgrpriv.h
#include "mmc.h"
#include "ndmgr.h"
#include "ndmgrpriv.h"
#include "mmcptrs.h"
#include "ndmgrp.h"
#include "amcmsgid.h"


HRESULT MMCPropertyChangeNotify(LONG_PTR lNotifyHandle, LPARAM lParam)
{
    // Note - the property sheet is in a different thread than the console.
    // So init COM.
    HRESULT hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        LPPROPERTYSHEETNOTIFY ppsn;

        hr = CoCreateInstance (CLSID_NodeManager, NULL, CLSCTX_INPROC,
                               IID_IPropertySheetNotify,
                               reinterpret_cast<void **>(&ppsn));

        if (SUCCEEDED(hr))
        {
            LPPROPERTYNOTIFYINFO ppni = reinterpret_cast<LPPROPERTYNOTIFYINFO>(lNotifyHandle);

            ppsn->Notify (ppni, lParam);
            ppsn->Release();
        }

        // Uninit COM
        CoUninitialize();
    }

    return (hr);
}


HRESULT MMCPropertyHelp (LPOLESTR pszHelpTopic)
{
    // find the MMC main window for this process
    HWND        hwndFrame    = NULL;
    const DWORD dwCurrentPid = GetCurrentProcessId();

    while (1)
    {
        // find an MMC frame window
        hwndFrame = FindWindowEx (NULL, hwndFrame, MAINFRAME_CLASS_NAME, NULL);

        if (hwndFrame == NULL)
            break;

        // found a frame, is it on this process?
        DWORD   dwWindowPid;
        GetWindowThreadProcessId (hwndFrame, &dwWindowPid);

        if (dwCurrentPid == dwWindowPid)
            break;
    }

    if (hwndFrame == NULL)
        return (E_UNEXPECTED);

    return ((HRESULT) SendMessage (hwndFrame, MMC_MSG_SHOW_SNAPIN_HELP_TOPIC,
                                   NULL, reinterpret_cast<LPARAM>(pszHelpTopic)));
}


HRESULT MMCFreeNotifyHandle(LONG_PTR lNotifyHandle)
{

    if (lNotifyHandle == NULL)
        return E_INVALIDARG;

    LPPROPERTYNOTIFYINFO ppni =
            reinterpret_cast<LPPROPERTYNOTIFYINFO>(lNotifyHandle);

    BOOL bResult;

    if ((bResult = IsBadReadPtr(ppni, sizeof(PROPERTYNOTIFYINFO))) == FALSE)
        ::GlobalFree(ppni);

    return ((bResult == FALSE) ? S_OK : E_FAIL);
}


HRESULT MMCIsMTNodeValid(void* pMTNode, BOOL bReset)
{
    HRESULT hr = S_FALSE;
    HWND hWnd = NULL;
    DWORD dwPid = 0;
    DWORD dwTid = 0;

    if (pMTNode == NULL)
        return hr;

    while (1)
    {
        hWnd = ::FindWindowEx(NULL, hWnd, DATAWINDOW_CLASS_NAME, NULL);

        // No windows found
        if (hWnd == NULL)
            break;

        // Check if the window belongs to the current process
        dwTid = ::GetWindowThreadProcessId(hWnd, &dwPid);
        if (dwPid != ::GetCurrentProcessId())
            continue;

        // Get the extra bytes and compare the data objects
        if (GetClassLong(hWnd, GCL_CBWNDEXTRA) != WINDOW_DATA_SIZE)
            break;

        DataWindowData* pData = GetDataWindowData (hWnd);

        if (pData == NULL)
            break;

        if (pData->lpMasterNode == reinterpret_cast<LONG_PTR>(pMTNode))
        {
            // clear the data out if the user requests it
            if (bReset)
                pData->lpMasterNode = NULL;

            hr = S_OK;
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\lib\ndmgrpriv.c ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File:      ndmgrpriv.cpp
 *
 *  Contents:  Implementation file for the GUIDs defined in ndmgrpriv.h
 *             Started out from the old ndmgr_i.c file.
 *
 *  History:   5-Dec-99 VivekJ     Created
 *
 *--------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"{
#endif


#include <rpc.h>
#include <rpcndr.h>

//############################################################################
//############################################################################
//
//  Macro definitions
//
//############################################################################
//############################################################################


#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_


//############################################################################
//############################################################################
//
//  GUID definitions
//
//############################################################################
//############################################################################

MIDL_DEFINE_GUID(IID, IID_IPropertySheetNotify,0xd700dd8e,0x2646,0x11d0,0xa2,0xa7,0x00,0xc0,0x4f,0xd9,0x09,0xdd);


MIDL_DEFINE_GUID(IID, IID_IFramePrivate,0xd71d1f2a,0x1ba2,0x11d0,0xa2,0x9b,0x00,0xc0,0x4f,0xd9,0x09,0xdd);


MIDL_DEFINE_GUID(IID, IID_IScopeDataPrivate,0x60BD2FE0,0xF7C5,0x11cf,0x8A,0xFD,0x00,0xAA,0x00,0x3C,0xA9,0xF6);


MIDL_DEFINE_GUID(IID, IID_IImageListPrivate,0x7538C620,0x0083,0x11d0,0x8B,0x00,0x00,0xAA,0x00,0x3C,0xA9,0xF6);


MIDL_DEFINE_GUID(IID, IID_IResultDataPrivate,0x1EBA2300,0x0854,0x11d0,0x8B,0x03,0x00,0xAA,0x00,0x3C,0xA9,0xF6);


MIDL_DEFINE_GUID(IID, IID_IHeaderCtrlPrivate,0x0B384311,0x701B,0x4e8a,0xAE,0xC2,0xDA,0x63,0x21,0xE2,0x7A,0xD2);


MIDL_DEFINE_GUID(IID, IID_IScopeTree,0xd8dbf067,0x5fb2,0x11d0,0xa9,0x86,0x00,0xc0,0x4f,0xd8,0xd5,0x65);


MIDL_DEFINE_GUID(IID, IID_IScopeTreeIter,0xd779f8d1,0x6057,0x11d0,0xa9,0x86,0x00,0xc0,0x4f,0xd8,0xd5,0x65);


MIDL_DEFINE_GUID(IID, IID_INodeCallback,0xb241fced,0x5fb3,0x11d0,0xa9,0x86,0x00,0xc0,0x4f,0xd8,0xd5,0x65);


MIDL_DEFINE_GUID(IID, IID_IControlbarsCache,0x2e9fcd38,0xb9a0,0x11d0,0xa7,0x9d,0x00,0xc0,0x4f,0xd8,0xd5,0x65);


MIDL_DEFINE_GUID(IID, IID_INodeType,0xB08A8368,0x967F,0x11D0,0xA7,0x99,0x00,0xC0,0x4F,0xD8,0xD5,0x65);


MIDL_DEFINE_GUID(IID, IID_INodeTypesCache,0xDE40436E,0x9671,0x11D0,0xA7,0x99,0x00,0xC0,0x4F,0xD8,0xD5,0x65);


MIDL_DEFINE_GUID(IID, IID_IEnumNodeTypes,0xABBD61E6,0x9686,0x11D0,0xA7,0x99,0x00,0xC0,0x4F,0xD8,0xD5,0x65);


MIDL_DEFINE_GUID(IID, IID_IDumpSnapins,0xA16496D0,0x1D2F,0x11d3,0xAE,0xB8,0x00,0xC0,0x4F,0x8E,0xCD,0x78);


MIDL_DEFINE_GUID(IID, IID_IPropertySheetProviderPrivate,0xFEF554F8,0xA55A,0x11D0,0xA7,0xD7,0x00,0xC0,0x4F,0xD9,0x09,0xDD);


MIDL_DEFINE_GUID(IID, IID_IMMCListView,0x1B3C1392,0xD68B,0x11CF,0x8C,0x2B,0x00,0xAA,0x00,0x3C,0xA9,0xF6);


MIDL_DEFINE_GUID(IID, IID_ITaskPadHost,0x4f7606d0,0x5568,0x11d1,0x9f,0xea,0x00,0x60,0x08,0x32,0xdb,0x4a);


MIDL_DEFINE_GUID(IID, IID_IStringTablePrivate,0x461A6010,0x0F9E,0x11d2,0xA6,0xA1,0x00,0x00,0xF8,0x75,0xA9,0xCE);


MIDL_DEFINE_GUID(IID, IID_ITaskCallback,0x4b2293ba,0xe7ba,0x11d2,0x88,0x3c,0x00,0xc0,0x4f,0x72,0xc7,0x17);


MIDL_DEFINE_GUID(IID, IID_ITaskView,0x9ff7a05c,0xe7b9,0x11d2,0x88,0x3c,0x00,0xc0,0x4f,0x72,0xc7,0x17);


MIDL_DEFINE_GUID(IID, IID_ITitleView,0xdca68d28,0xeeb3,0x11d2,0x88,0x3e,0x00,0xc0,0x4f,0x72,0xc7,0x17);


MIDL_DEFINE_GUID(IID, IID_IFolderTabView,0xf4d3c5a8,0x0314,0x11d3,0x88,0x59,0x00,0xc0,0x4f,0x72,0xc7,0x17);


#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\lib\ndmgriid.c ===
#include "ndmgr_i.c"
#include "hcolwrap_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\clasfact.cpp ===
//------------------------------------------------------------------------------
//
//  File: classfact.cpp
//  Copyright (C) 1995-1997 Microsoft Corporation
//  All rights reserved.
//
//  Purpose:
//  Implementation of CLocImpClassFactory, which provides the IClassFactory
//  interface for the parser.
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE. This code contains
//  nothing parser-specific and is called only by Espresso.
//
//  Owner:
//
//------------------------------------------------------------------------------

#include "stdafx.h"


#include "dllvars.h"
#include "resource.h"
#include "impparse.h"

#include "clasfact.h"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Constructor for class factory implementation.
//------------------------------------------------------------------------------
CLocImpClassFactory::CLocImpClassFactory()
{
	m_uiRefCount = 0;

	AddRef();
	IncrementClassCount();

	return;
} // end of CLocImpClassFactory::CLocImpClassFactory()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Destructor for class factory implementation.
//------------------------------------------------------------------------------
CLocImpClassFactory::~CLocImpClassFactory()
{
	LTASSERT(0 == m_uiRefCount);
	DEBUGONLY(AssertValid());

	DecrementClassCount();

	return;
} // end of CLocImpClassFactory::~CLocImpClassFactory()


#ifdef _DEBUG

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Assert if object is not valid. Unfortunately, there really isn't anything
//  we can check.
//------------------------------------------------------------------------------
void
CLocImpClassFactory::AssertValid()
		const
{
	CLObject::AssertValid();

	return;
} // end of CLocImpClassFactory::AssertValid()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Dump all internal data to supplied dump context, for debugging purposes.
//------------------------------------------------------------------------------
void
CLocImpClassFactory::Dump(
		CDumpContext &dc)		// Context to dump to.
		const
{
	CLObject::Dump(dc);

	dc << "NET Parser CLocImpClassFactory:\n\r";
	dc << "\tm_uiRefCount: " << m_uiRefCount << "\n\r";

	return;
} // end of CLocImpClassFactory::Dump()

#endif // _DEBUG


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Increment reference count for object, return new value.
//------------------------------------------------------------------------------
ULONG
CLocImpClassFactory::AddRef()
{
	return ++m_uiRefCount;
} // end of CLocImpClassFactory::AddRef()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Decrement reference count for object. If goes to 0, delete object. Return
//  new reference count.
//------------------------------------------------------------------------------
ULONG
CLocImpClassFactory::Release()
{
	LTASSERT(m_uiRefCount != 0);

	m_uiRefCount--;

	if (0 == m_uiRefCount)
	{
		delete this;
		return 0;
	}

	return m_uiRefCount;
} // end of CLocImpClassFactory::Release()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Query whether this object supports a given interface. If it does,
//  increment the reference count for this object.
//
//  Return values: some sort of result code
//				   *ppvObj will point to this object if it does support the
//					desired interface or be NULL if not.
//------------------------------------------------------------------------------
HRESULT
CLocImpClassFactory::QueryInterface(
		REFIID iid,			// Type of interface desired.
		LPVOID *ppvObj)		// Return pointer to object with such interface.
							//  Note it's a hidden double pointer!
{
	LTASSERT(ppvObj != NULL);

	SCODE sc = E_NOINTERFACE;

	*ppvObj = NULL;

	if (IID_IUnknown == iid)
	{
		*ppvObj = (IUnknown *)this;
		sc = S_OK;
	}
	else if (IID_IClassFactory == iid)
	{
		*ppvObj = (IClassFactory *)this;
		sc = S_OK;
	}

	if (S_OK == sc)
	{
		AddRef();
	}

	return ResultFromScode(sc);
} // end of CLocImpClassFactory::QueryInterface()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Create an instance of the requested class. All interfaces are implemented
//  by the CLocImpParser object.
//
//  Return values: some sort of result code
//				   ppvObj will point to a CLocImpParser object if it does
//					support the desired interface or be NULL if not.
//------------------------------------------------------------------------------
HRESULT
CLocImpClassFactory::CreateInstance(
		LPUNKNOWN pUnknown,		// ???
		REFIID iid,				// Interface desired on parser object.
		LPVOID *ppvObj)			// Return pointer to object with interface.
								//  Note that it's a hidden double pointer!
{
	LTASSERT(ppvObj != NULL);

	SCODE sc = E_UNEXPECTED;

	*ppvObj = NULL;

	if (pUnknown != NULL)
	{
		sc = CLASS_E_NOAGGREGATION;
	}
	else
	{
		try
		{
			CLocImpParser *pParser;

			pParser = new CLocImpParser;

			sc = pParser->QueryInterface(iid, ppvObj);

			pParser->Release();
		}
		catch (CMemoryException *pMem)
		{
			sc = E_OUTOFMEMORY;
			pMem->Delete();
		}
		catch (...)
		{
		}
	}

	return ResultFromScode(sc);
} // end of CLocImpClassFactory::CreateInstance()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Not implemented. Always fails.
//------------------------------------------------------------------------------
HRESULT
CLocImpClassFactory::LockServer(
		BOOL)		// Unused.
{
	return E_NOTIMPL;
} // end of CLocImpClassFactory::LockServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\clasfact.h ===
//------------------------------------------------------------------------------
//
//  File: classfact.h
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Declaration of CLocImpClassFactory, which provides the IClassFactory
//  interface for the parser.
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE. This code contains
//  nothing parser-specific and is called only by Espresso.
//
//	Owner:
//
//------------------------------------------------------------------------------

#ifndef CLASFACT_H
#define CLASFACT_H


class CLocImpClassFactory : public IClassFactory, public CLObject
{
public:
	CLocImpClassFactory();
	~CLocImpClassFactory();

#ifdef _DEBUG
	void AssertValid() const;
	void Dump(CDumpContext &) const;
#endif

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);
	STDMETHOD(CreateInstance)(THIS_ LPUNKNOWN, REFIID, LPVOID *);
	STDMETHOD(LockServer)(THIS_ BOOL);

private:
	UINT m_uiRefCount;
};

#endif // CLASFACT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\dllentry.cpp ===
//------------------------------------------------------------------------------
//
//  File: dllentry.cpp
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Defines the initialization routines for the DLL.
//
//  This file needs minor changes, as marked by TODO comments. However, the
//  functions herein are only called by the system, Espresso, or the framework,
//  and you should not need to look at them extensively.
//
//	Owner:
//
//------------------------------------------------------------------------------

#include "stdafx.h"


#include "clasfact.h"
#include "impparse.h"

#define __DLLENTRY_CPP
#include "dllvars.h"

LONG g_lActiveClasses = 0;

static AFX_EXTENSION_MODULE parseDLL = { NULL, NULL };


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Main entry point for Win32 DLL. Returns 1, asserts, or throws an exception.
//------------------------------------------------------------------------------
extern "C" int APIENTRY
DllMain(
		HINSTANCE hInstance,	// Instance handle of this DLL.
		DWORD dwReason,			// Attaching or detaching.
		LPVOID lpReserved)		// Unused.
{
	UNREFERENCED_PARAMETER(lpReserved);

	if (DLL_PROCESS_ATTACH == dwReason)
	{
		LTTRACE("DLLNAME.DLL Initializing!\n");	// TODO: Change name.

		// Extension DLL one-time initialization.

		AfxInitExtensionModule(parseDLL, hInstance);

		// Insert this DLL into the resource chain.

		new CDynLinkLibrary(parseDLL);
		g_hDll = hInstance;
		g_puid.m_pid = CLocImpParser::m_pid;
		g_puid.m_pidParent = pidNone;

	}
	else if (DLL_PROCESS_DETACH == dwReason)
	{
		LTTRACE("DLLNAME.DLL Terminating!\n");	// TODO: Change name

		//  If there are active classes, they WILL explode badly once the
		//  DLL is unloaded...

		LTASSERT(DllCanUnloadNow() == S_OK);

		// Extension DLL shutdown.

		AfxTermExtensionModule(parseDLL);
	}

	// Return OK.

	return 1;
} // end of ::DllMain()


// TODO: Use GUIDGEN.EXE to replace this class ID with a unique one.
// GUIDGEN is supplied with MSDEV (VC++ 4.0) as part of the OLE support stuff.
// Run it and you'll get a little dialog box. Pick radio button 3, "static
// const struct GUID = {...}". Click on the "New GUID" button, then the "Copy"
// button, which puts the result in the clipboard. From there, you can just
// paste it into here. Just remember to change the type to CLSID!
static const CLSID ciImpParserCLSID =
{0x033EA178L, 0xC126, 0x11CE, {0x89, 0x49, 0x00, 0xAA, 0x00, 0xA3, 0xF5, 0x51}};

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to get the unique class ID of the parser interface.
//------------------------------------------------------------------------------
STDAPI_(void)
DllGetParserCLSID(
		CLSID &ciParserCLSID)	// Place to return parser interface class ID.
{
	ciParserCLSID = ciImpParserCLSID;

	return;
} // end of ::DllGetParserCLSID()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to register this parser. Calls base implementation in ESPUTIL.
//------------------------------------------------------------------------------
STDAPI
DllRegisterParser()
{
	LTASSERT(g_hDll != NULL);

	HRESULT hr = ResultFromScode(E_UNEXPECTED);

	hr = RegisterParser(g_hDll);

	return ResultFromScode(hr);
} // end of ::DllRegisterParser()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to unregister this parser. Calls the base implementation in
//  ESPUTIL.
//------------------------------------------------------------------------------
STDAPI
DllUnregisterParser()
{
	LTASSERT(g_hDll != NULL);

	HRESULT hr = ResultFromScode(E_UNEXPECTED);

	hr = UnregisterParser(CLocImpParser::m_pid, pidNone);

	return ResultFromScode(hr);
} // end of ::DllUnregisterParser()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to return the class factory interface.
//
//  Return values: some sort of result code
//				   ppClassFactory points to a CLocImpClassFactory object
//					on success
//------------------------------------------------------------------------------
STDAPI
DllGetClassObject(
		REFCLSID cidRequestedClass,	// Class ID for desired parser interfaces.
		REFIID iid,					// Desired parser interface.
		LPVOID *ppClassFactory)		// Return pointer to object with interface.
									//  Note that it's a hidden double pointer!
{
	LTASSERT(ppClassFactory != NULL);

	SCODE sc = E_UNEXPECTED;

	*ppClassFactory = NULL;

	if (cidRequestedClass != ciImpParserCLSID)
	{
		sc = CLASS_E_CLASSNOTAVAILABLE;
	}
	else
	{
		try
		{
			CLocImpClassFactory *pClassFactory;

			pClassFactory = new CLocImpClassFactory;

			sc = pClassFactory->QueryInterface(iid, ppClassFactory);

			pClassFactory->Release();
		}
		catch (CMemoryException *pMemExcep)
		{
			sc = E_OUTOFMEMORY;
			pMemExcep->Delete();
		}
	}

	return ResultFromScode(sc);
} // end of ::DllGetClassObject()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Entry point to query if the DLL can unload.
//------------------------------------------------------------------------------
STDAPI
DllCanUnloadNow()
{
	SCODE sc;

	sc = (0 == g_lActiveClasses) ? S_OK : S_FALSE;

	return ResultFromScode(sc);
} // end of ::DllCanUnloadNow()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Global function used in the parser to increment the active class count.
//------------------------------------------------------------------------------
void
IncrementClassCount()
{
	InterlockedIncrement(&g_lActiveClasses);

	return;
} // end of ::IncrementClassCount()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Global function used in the parser to decrement the active class count.
//------------------------------------------------------------------------------
void
DecrementClassCount()
{
	LTASSERT(g_lActiveClasses != 0);

	InterlockedDecrement(&g_lActiveClasses);

	return;
} // end of ::DecrementClassCount()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\impfile.cpp ===
//------------------------------------------------------------------------------
//
//  File: impfile.cpp
//  Copyright (C) 1995-1997 Microsoft Corporation
//  All rights reserved.
//
//  Purpose:
//  Implementation of CLocImpFile, which provides the ILocFile interface for
//  the parser.
//
//  MAJOR IMPLEMENTATION FILE.
//
//  Owner:
//
//------------------------------------------------------------------------------

#include "stdafx.h"


#include "dllvars.h"
#include "resource.h"

#include "impfile.h"
#include "impparse.h"
#include "xml_supp.h"

# define MAX_BUFFER		8192


// TODO: Format constants go here.


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Constructor for CLocImpFile.
//------------------------------------------------------------------------------
CLocImpFile::CLocImpFile(
		ILocParser *pParentClass)	// Pointer to parent class, normally NULL.
{
	//
	// C.O.M. initialization
	//

	m_pParentClass = pParentClass;
	m_ulRefCount = 0;

	//
	//  IMP file initialization
	//

	m_pOpenSourceFile = NULL;
	

	m_pReporter = NULL;
	
	m_FileType = ftMNCFileType;

	AddRef();
	IncrementClassCount();
	
	m_dwCountOfStringTables = 0;
	m_pstmSourceString = NULL;
	m_pstgSourceStringTable = NULL;
	m_pstgSourceParent = NULL;
	m_pstmTargetString = NULL;
	m_pstgTargetStringTable = NULL;
	m_pstgTargetParent = NULL;

    m_bXMLBased = false;

	// Format initialization.

	// TODO: initialize implementation member variables here.

	return;
} // end of CLocImpFile::CLocImpFile()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	Destructor for CLocImpFile.
//------------------------------------------------------------------------------
CLocImpFile::~CLocImpFile()
{
	DEBUGONLY(AssertValid());

	if (m_pOpenSourceFile != NULL)
	{
		m_pOpenSourceFile->Close();
		delete m_pOpenSourceFile;
	}

	DecrementClassCount();

	// Format deinitialization.

	//  TODO: perform any implementation cleanup here.

	return;
} // end of CLocImpFile::~CLocImpFile()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Increment the object reference count. Return the new reference count.
//------------------------------------------------------------------------------
ULONG
CLocImpFile::AddRef()
{
	if (m_pParentClass != NULL)
	{
		m_pParentClass->AddRef();
	}

	return ++m_ulRefCount;
} // end of CLocImpFile::AddRef()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Decrement the object reference count. If it goes to 0, delete the object.
//  Return the new reference count.
//------------------------------------------------------------------------------
ULONG
CLocImpFile::Release()
{
	LTASSERT(m_ulRefCount != 0);

	if (m_pParentClass != NULL)
	{
		m_pParentClass->Release();
	}

	m_ulRefCount--;
	if (0 == m_ulRefCount)
	{
		delete this;
		return 0;
	}

	return m_ulRefCount;
} // end of CLocImpFile::Release()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Query whether this object supports a given interface.
//
//  Return values: some kind of result code
//                 ppvObj will point to this object if it supports the desired
//                  interface, be NULL if not.
//------------------------------------------------------------------------------
HRESULT
CLocImpFile::QueryInterface(
		REFIID iid,		// Desired interface.
		LPVOID *ppvObj) // Return pointer to object with interface.
						//  Note that it's a hidden double pointer.
{
	LTASSERT(ppvObj != NULL);

	if (m_pParentClass != NULL)
	{
		return m_pParentClass->QueryInterface(iid, ppvObj);
	}
	else
	{
		SCODE scRetVal = E_NOINTERFACE;

		*ppvObj = NULL;

		if (IID_IUnknown == iid)
		{
			*ppvObj = (IUnknown *)this;
			scRetVal = S_OK;
		}
		else if (IID_ILocFile == iid)
		{
			*ppvObj = (ILocFile *)this;
			scRetVal = S_OK;
		}

		if (S_OK == scRetVal)
		{
			AddRef();
		}
		return ResultFromScode(scRetVal);
	}
} // end of CLocImpFile::QueryInterface()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Check object for validity. Asserts if not! (debug only)
//------------------------------------------------------------------------------
void
CLocImpFile::AssertValidInterface()
		const
{
	AssertValid();

	return;
} // end of CLocImpFile::AssertValidInterface()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Open the file and make sure it is the correct type. Return TRUE if it is,
//  FALSE if not or on error.
//------------------------------------------------------------------------------
BOOL
CLocImpFile::OpenFile(
		const CFileSpec &fsFileSpec,	// Name of file to open.
		CReporter &Reporter)			// Reporter object for messages.
{
	DEBUGONLY(fsFileSpec.AssertValid());
	DEBUGONLY(Reporter.AssertValid());

	const CPascalString &pstrFileName = fsFileSpec.GetFileName();
	BOOL fRetVal = FALSE;

	LTTRACEPOINT("OpenFile()");
	// Set reporter pointer for the duration of this function.
	m_pReporter = &Reporter;

	try
	{
		CFileException excFile;

		m_pstrFileName = pstrFileName;      // Initialize source filename.
		m_idFile = fsFileSpec.GetFileId();
		
		if (m_pOpenSourceFile != NULL)
		{
			// If source file pointer seems to be open already, close it.

			m_pOpenSourceFile->Close();
			delete m_pOpenSourceFile;
			m_pOpenSourceFile = NULL;
		}

		// Open the source file. Doesn't throw an exception if the open
		// fails, but does return FALSE and put the info in an exception
		// structure if you supply one.

		m_pOpenSourceFile = new CLFile;
		fRetVal = m_pOpenSourceFile->Open(m_pstrFileName,
				CFile::modeRead | CFile::shareDenyNone, &excFile);
		if (!fRetVal)
		{
			ReportException(&excFile);
			m_pOpenSourceFile->Abort();
			delete m_pOpenSourceFile;
			m_pOpenSourceFile = NULL;
			// fRetCode is already FALSE.
		}
		else
		{
			// Verify() assumes it is in a try/catch frame.

			fRetVal = Verify();
		}
	}
	catch(CException *e)
	{
		ReportException(e);
		delete m_pOpenSourceFile;
		m_pOpenSourceFile = NULL;
		fRetVal = FALSE;
		// m_pReporter will be NULLed by normal cleanup code below.
		e->Delete();
	}
	catch(...)
	{
		// Reset the reporter pointer, no idea if it will still be valid by
		// the time the destructor gets called. The only other thing that
		// needs to be cleaned up is the source file, which will be handled in
		// the destructor.

		m_pReporter = NULL;
		throw;
	}

	m_pReporter = NULL;

	return fRetVal;
} // end of CLocImpFile::OpenFile()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return the file type (a ft* constant from impfile.h). If you only have one
//  file type, you can just return it directly.
//------------------------------------------------------------------------------
FileType
CLocImpFile::GetFileType()
		const
{
	return m_FileType;
} // end of CLocImpFile::GetFileType()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return the file description in strDesc, according to the file type. If you
//  have only one file type, you can just return a string directly.
//------------------------------------------------------------------------------
void
CLocImpFile::GetFileTypeDescription(
		CLString &strDesc)	// Place to return file description string.
		const
{
	LTVERIFY(strDesc.LoadString(g_hDll, IDS_IMP_FILE_DESC));
	return;
} // end of CLocImpFile::GetFileTypeDescription()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return the names of any associated files as a list of strings in lstFiles.
//  Returns TRUE if there are any, FALSE if not.
//------------------------------------------------------------------------------
BOOL
CLocImpFile::GetAssociatedFiles(
		CStringList &lstFiles)          // Return associated file names here.
		const
{
	DEBUGONLY(lstFiles.AssertValid());
	LTASSERT(lstFiles.GetCount() == 0);

	// TODO: If your files have associated files, put them in lstFiles here.
	UNREFERENCED_PARAMETER(lstFiles);

	return FALSE;
} // end of CLocImpFile::GetAssociatedFiles()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Enumerate all the localizable items in this file. Returns TRUE on success,
//  FALSE on error.
//------------------------------------------------------------------------------
BOOL
CLocImpFile::EnumerateFile(
		CLocItemHandler &ihItemHandler, // Localizable-item handler and
										//  reporter object all in one!
		const CLocLangId &lid,          // Source language ID object.
		const DBID &dbidFileId)         // Database ID of file, used as parent
										//  for all top-level items in the
										//  file.
{
	DEBUGONLY(ihItemHandler.AssertValid());
	DEBUGONLY(lid.AssertValid());
	DEBUGONLY(dbidFileId.AssertValid());

	LTTRACEPOINT("EnumerateFile()");

	// Set reporter pointer for the duration of this function.
	m_pReporter = &ihItemHandler;

	if (NULL == m_pOpenSourceFile)
	{
		// Source file isn't open, whoops.

		LTASSERT(0 && "Source file isn't open in CLocImpFile::EnumerateFile()");
		return FALSE;
	}

	// Retrieve and store the ANSI code page value. Note that some types
	// of files use OEM code pages instead, or even use both. To get the
	// OEM code page, do GetCodePage(cpDos) instead.
	m_cpSource = lid.GetCodePage(cpAnsi);

	BOOL bRet = TRUE;

	try
	{
		bRet = EnumerateStrings(ihItemHandler,dbidFileId,FALSE);
	}
	catch(CException *e)
	{
		ReportException(e);
		bRet = FALSE;
		// m_pReporter will be NULLed by normal cleanup code below.
		e->Delete();
	}
	catch (...)
	{
		// Reset the reporter pointer, no idea if it will still be valid by
		// the time the destructor gets called. Reset the process pointer,
		// since it definitely won't be valid! The only other thing that
		// needs to be cleaned up is the source file, which will be handled in
		// the destructor.

		m_pReporter = NULL;
		throw;
	}

	m_pReporter = NULL;                 // Reset reporter pointer.

	return bRet;
} // end of CLocImpFile::EnumerateFile()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Create a new target file be replacing resources in the source file with the 
//  localized items from Espresso.
//------------------------------------------------------------------------------
BOOL
CLocImpFile::GenerateFile(
		const CPascalString &pstrTargetFile,// Name of target file.
		CLocItemHandler &ihItemHandler,     // Localizable-item handler and
											//  reporter object all in one!
		const CLocLangId &lidSource,        // Source language ID object.
		const CLocLangId &lidTarget,        // Target language ID object.
		const DBID &dbidParent)             // Database ID of file, used as
											//  parent for all top-level items
											//  in the file.
{
	DEBUGONLY(pstrTargetFile.AssertValid());
	DEBUGONLY(ihItemHandler.AssertValid());
	DEBUGONLY(lidSource.AssertValid());
	DEBUGONLY(lidTarget.AssertValid());
	DEBUGONLY(dbidParent.AssertValid());

	BOOL fRetVal = FALSE;

	// Set reporter pointer for the duration of this function.
	m_pReporter = &ihItemHandler;

	if (NULL == m_pOpenSourceFile)
	{
		// Source file isn't open, whoops.

		LTASSERT(0 && "Source file isn't open in CLocImpFile::GenerateFile()");
		return FALSE;
	}

	// Retrieve and store the ANSI code page values for the source and target
	// files. Note that some types of files use OEM code pages instead, or
	// even use both. To get the OEM code page, do GetCodePage(cpDos) instead.
	m_cpSource = lidSource.GetCodePage(cpAnsi);
	m_cpTarget = lidTarget.GetCodePage(cpAnsi);

	try
	{
		m_pstrTargetFile = pstrTargetFile;	// Initialize target filename.

		CFileStatus fsFileStatus;

		CLFile::CopyFile(m_pstrFileName,m_pstrTargetFile,FALSE);
		
		CLFile::GetStatus(m_pstrTargetFile, fsFileStatus);
		if(fsFileStatus.m_attribute & CFile::readOnly)
		{
			fsFileStatus.m_attribute &= ~CFile::readOnly; 
			CLFile::SetStatus(m_pstrTargetFile, fsFileStatus);
		}

		fRetVal = EnumerateStrings(ihItemHandler,dbidParent,TRUE);
		
	}
	catch(CException *e)
	{
		ReportException(e, ImpEitherError);
		fRetVal = FALSE;
		// m_pReporter will be NULLed by normal cleanup code.
		e->Delete();
	}
	catch(...)
	{
		// Generic exception handling is needed here because otherwise
		// target file will not be cleaned up. Also, no idea if reporter
		// pointer will still be valid by the time the destructor is
		// called. The process pointer definitely won't be valid, so reset
		// it too. The source file will be cleaned up by the destructor.

		m_pReporter = NULL;
		throw;
	}

	// Cleanup.

	if (!fRetVal)
	{
		try
		{
			// Nuke the target file if the generate failed.

			CLFile::Remove(pstrTargetFile);
		}
		catch(CException *e)
		{
			ReportException(e, ImpTargetError);
			// fRetVal is already FALSE
			// m_pReporter will be NULLed by normal cleanup code.
			e->Delete();
		}
		catch(...)
		{
			// Generic exception handling is needed here because otherwise
			// target file will not be cleaned up. Also, no idea if reporter
			// pointer will still be valid by the time the destructor is
			// called. The process pointer is already NULL. The source file
			// will be cleaned up by the destructor.

			m_pReporter = NULL;
			throw;
		}
	}

	// Normal cleanup code.

	m_pReporter = NULL;				// Reset reporter pointer.
	
	return fRetVal;
} // end of CLocImpFile::GenerateFile()


//------------------------------------------------------------------------------
//
//  TODO:
//  Verify that a file is a ???, as best we can. When we're reasonably sure,
//  set the reporter confidence level to high -- until then, messages will be
//  discarded, not displayed. This is also the place where m_FileType is set.
//
//  Returns TRUE if so, FALSE if not or on error, or throws an exception.
//
//  Normally there is need to catch exceptions in this function, they will
//  be caught and handled by a higher level. To avoid memory leaks, consider
//  using automatic variables or CByteArrays (as described and demonstrated in
//  the utility function FindSignature() below) instead of dynamic allocation.
//------------------------------------------------------------------------------
BOOL
CLocImpFile::Verify()
{
	DEBUGONLY(AssertValid());
	LTASSERT(m_pReporter != NULL);
	DEBUGONLY(m_pReporter->AssertValid());

	// ...

	// Set confidence level to high and return that we recognize this file.

	m_pReporter->SetConfidenceLevel(CReporter::High);
	return TRUE;
} // end of CLocImpFile::Verify()


//------------------------------------------------------------------------------
//
//  Reports the exception described by *pException. Since the message can be
//  retrieved directly from the exception, there is no need (as far as reporting
//  goes) to catch or handle different kinds of exceptions separately. Normally,
//  there is no reason for your code to call this function, since under normal
//  circumstances you don't have to catch exceptions.
//
//  THIS FUNCTION IS USED BY THE FRAMEWORK! DO NOT REMOVE IT!
//------------------------------------------------------------------------------
void
CLocImpFile::ReportException(
		CException *pException, // Exception to be reported.
		ImpFileError WhichFile) // Defaults to ImpSourceError (most common).
		const
{
	const UINT MAX_MESSAGE = 256;

	CLString strContext;
	CLString strMessage;
	char *pszMessage;

	LTASSERT(m_pReporter != NULL);
	DEBUGONLY(m_pReporter->AssertValid());

	pszMessage = strMessage.GetBuffer(MAX_MESSAGE);
	LTASSERT(pszMessage != NULL);
	pException->GetErrorMessage(pszMessage, MAX_MESSAGE);
	strMessage.ReleaseBuffer();

	switch (WhichFile)
	{
	case ImpNeitherError:   // By convention, report errors not really in any
							//  file against the source file.
	case ImpSourceError:
		m_pstrFileName.ConvertToCLString(strContext, CP_ACP);
		break;

	case ImpTargetError:
		m_pstrTargetFile.ConvertToCLString(strContext, CP_ACP);
		break;

	case ImpEitherError:
		{
			CLString strSource, strTarget;

			m_pstrFileName.ConvertToCLString(strSource, CP_ACP);
			m_pstrTargetFile.ConvertToCLString(strTarget, CP_ACP);

			strContext.Format(g_hDll, IDS_IMP_OR, (const char *) strSource,
					(const char *) strTarget);
		}
		break;

	default:
		LTASSERT(0 && "WhichFile is bad during CLocImpFile::ReportException");
		break;
	}

	CContext ctx(strContext, m_idFile, otFile, vProjWindow);

	m_pReporter->IssueMessage(esError, ctx, strMessage);

	return;
} // end of CLocImpFile::ReportException()


//------------------------------------------------------------------------------
//
//  Reports a message to the user. Note that the message will be discarded
//  unless the reporter's confidence level had been set high (see Verify()).
//------------------------------------------------------------------------------
void
CLocImpFile::ReportMessage(
		MessageSeverity sev,    // Severity of message.
								//  (esError, esWarning, esNote)
		UINT nMsgId,                    // ID of string resource to load for message.
		ImpFileError WhichFile) // Defaults to ImpSourceError (most common).
		const
{
	CLString strContext;

	LTASSERT(m_pReporter != NULL);
	DEBUGONLY(m_pReporter->AssertValid());

	switch (WhichFile)
	{
	case ImpNeitherError:   // By convention, report errors not really in any
							//  file against the source file.
	case ImpSourceError:
		m_pstrFileName.ConvertToCLString(strContext, CP_ACP);
		break;

	case ImpTargetError:
		m_pstrTargetFile.ConvertToCLString(strContext, CP_ACP);
		break;

	case ImpEitherError:
		{
			CLString strSource, strTarget;

			m_pstrFileName.ConvertToCLString(strSource, CP_ACP);
			m_pstrTargetFile.ConvertToCLString(strTarget, CP_ACP);

			strContext.Format(g_hDll, IDS_IMP_OR, (const char *) strSource,
					(const char *) strTarget);
		}
		break;

	default:
		LTASSERT(0 && "WhichFile is bad during CLocImpFile::ReportMessage");
		break;
	}

	CContext ctx(strContext, m_idFile, otFile, vProjWindow);

	m_pReporter->IssueMessage(sev, ctx, g_hDll, nMsgId);

	return;
} // end of CLocImpFile::ReportMessage()


#ifdef LTASSERT_ACTIVE

//------------------------------------------------------------------------------
//
//  Asserts if the object is not valid. Any functions you add should probably
//  call this function (in DEBUGONLY()) first thing -- see Verify() and Enum().
//------------------------------------------------------------------------------
void
CLocImpFile::AssertValid()
		const
{
	// Check base class.

	CLObject::AssertValid();

	// Check C.O.M. data. m_pParentClass should always be NULL.
	// Correct range for m_ulRefCount is unknown, but make sure it hasn't
	// wrapped around by checking for less than 100 (if we ever exceed
	// 100 references from below, there's probably something wrong too!).

	LTASSERT(NULL == m_pParentClass);
	LTASSERT(m_ulRefCount < 100);

	// Check filename strings.

	m_pstrFileName.AssertValid();
	m_pstrTargetFile.AssertValid();

	// If the file object pointers are non-NULL, check the objects.

	if (m_pOpenSourceFile != NULL)
	{
		m_pOpenSourceFile->AssertValid();
	}
	// If the reporter pointer is non-NULL, check the object.

	if (m_pReporter != NULL)
	{
		m_pReporter->AssertValid();
	}

	// If the process object pointer is non-NULL, check the object.

	// Make sure m_FileType is one of the valid types.

	switch (m_FileType)
	{
	case ftMNCFileType:
	case ftUnknown:
	// TODO: add cases for all ft* constants in impfile.h here.
	//      case ftFoo1FileType:
	//      case ftFoo2FileType:
		// These are all OK. Do nothing.
		break;

	default:
		// This is bad!
		LTASSERT(0 && "m_FileType is bad during CLocImpFile::AssertValid()");
	}

	// Can't check code page values, they could be just about anything
	// and still valid.

	// TODO: check any checkable implementation member variables here.

	return;
} // end of CLocImpFile::AssertValid()


#endif // _DEBUG


//Creating a parent node
//ihItemHandler	-> Required to send item 
//dbidFileId	-> Id of the parent of node
//pNewParentId  -> New Id will be assigned can be used if this node has
//				   child
//szNodeRes		-> Res ID of the node 
//szNodeString	-> String of the node
//				<- Returns success or failure 

BOOL CLocImpFile::CreateParentNode(CLocItemHandler & ihItemHandler,
								   const DBID & dbidFileId, 
								   DBID & pNewParentId, 
								   const char * szNodeRes, 
								   const char * szNodeString) 
{
	BOOL fRetVal = TRUE;
	CLocItemSet isItemSet;
	
	CLocUniqueId uid;
	CPascalString pstrText,pstrId;
	try
	{
		CLocItem *pLocItem = new CLocItem();
	
		pstrId.SetString(szNodeRes,strlen(szNodeRes),m_cpSource);
		
		uid.GetResId().SetId(pstrId);
		
		pstrText.SetString(szNodeString,strlen(szNodeString),m_cpSource);
	
		uid.GetTypeId().SetId(pstrText);

		uid.SetParentId(dbidFileId);

		//set up pLocItem

		pLocItem->SetUniqueId(uid);

		pLocItem->SetFDisplayable(TRUE);
		pLocItem->SetFExpandable(TRUE);
		pLocItem->SetFNoResTable(TRUE);
		pLocItem->SetIconType(CIT::Expandable);
			
		//Add the node to Item set
		isItemSet.Add(pLocItem);		
		
		//Send node to espresso

		fRetVal  = ihItemHandler.HandleItemSet(isItemSet);
	
		// If OK, retrieve DBID.

		if (fRetVal)
		{
			pNewParentId.Clear();
			pNewParentId = pLocItem->GetMyDatabaseId();
		}
		isItemSet.ClearItemSet();
	}
	catch (CMemoryException *pMemoryException)
	{
	CLString strContext;

		strContext.LoadString(g_hDll, IDS_MNC_GENERIC_LOCATION);
		
		m_pReporter->IssueMessage(esError, strContext, g_hDll, IDS_MNC_NO_MEMORY,
				g_locNull);
		fRetVal = FALSE;
		pMemoryException->Delete();
	}
	catch(CException *pException)
	{
		ReportException(pException);
		pException->Delete();
		fRetVal = FALSE;
	}
	return fRetVal;

}

//Creating a child node
//ihItemHandler	-> Required to send item 
//dbidFileId	-> Id of the parent of node
//pNewParentId  -> New Id to be use for items belonging to this child
//szNodeRes		-> Res ID of the node 
//szNodeString	-> String of the node
//				<- Returns success or failure 


BOOL CLocImpFile::CreateChildNode(CLocItemHandler & ihItemHandler,
								   const DBID & dbidFileId, 
								   DBID & pNewParentId, 
								   const char * szNodeRes, 
								   const char * szNodeString) 
{
	BOOL fRetVal = TRUE;
	CLocItemSet isItemSet;
	
	CLocUniqueId uid;
	CPascalString pstrText,pstrId;
	try
	{
		CLocItem *pLocItem = new CLocItem();
	
		pstrId.SetString(szNodeRes,strlen(szNodeRes),m_cpSource);

		pstrText.SetString(szNodeString,strlen(szNodeString),m_cpSource);
		
		uid.GetResId().SetId(pstrId);
					
		uid.GetTypeId().SetId(pstrText);
		
		uid.SetParentId(dbidFileId);

		//set up pLocItem

		pLocItem->SetUniqueId(uid);

		pLocItem->SetFDisplayable(TRUE);
		pLocItem->SetFExpandable(FALSE);
		pLocItem->SetFNoResTable(TRUE);
		pLocItem->SetIconType(CIT::String);
			
		//Add the node to Item set
		isItemSet.Add(pLocItem);		
		
		//Send node to espresso

		fRetVal  = ihItemHandler.HandleItemSet(isItemSet);
	
		// If OK, retrieve DBID.

		if (fRetVal)
		{
			pNewParentId.Clear();
			pNewParentId = pLocItem->GetMyDatabaseId();
		}
		isItemSet.ClearItemSet();
	}
	catch (CMemoryException *pMemoryException)
	{
	CLString strContext;

		strContext.LoadString(g_hDll, IDS_MNC_GENERIC_LOCATION);
		
		m_pReporter->IssueMessage(esError, strContext, g_hDll, IDS_MNC_NO_MEMORY,
				g_locNull);
		fRetVal = FALSE;
		pMemoryException->Delete();
	}
	catch(CException *pException)
	{
		ReportException(pException);
		pException->Delete();
		fRetVal = FALSE;
	}
	return fRetVal;

}


BOOL CLocImpFile::EnumerateStrings(CLocItemHandler & ihItemHandler, 
								   const DBID & dbidFileId, 
								   BOOL fGenerating)
{
BOOL fRetVal = TRUE;

	try
	{
		fRetVal = OpenStream(FALSE);
		if(!fRetVal)
			goto exit_clean;

		if(fGenerating)
			fRetVal = OpenStream(TRUE);
		if(!fRetVal)
			goto exit_clean;

        if (m_bXMLBased)
		    fRetVal = ProcessXMLStrings(ihItemHandler,dbidFileId,fGenerating);
        else
		    fRetVal = ProcessStrings(ihItemHandler,dbidFileId,fGenerating);
	}
	catch(CException *pException)
	{
		ReportException(pException);
		pException->Delete();
		fRetVal = FALSE;
	}
	
exit_clean:
	if(m_pstmSourceString)
		m_pstmSourceString->Release();
	if(m_pstgSourceStringTable)
		m_pstgSourceStringTable->Release();
	if(m_pstgSourceParent)
		m_pstgSourceParent->Release();
	if(fGenerating)
	{
		if(m_pstmTargetString)
			m_pstmTargetString->Release();
		if(m_pstgTargetStringTable)
			m_pstgTargetStringTable->Release();
		if(m_pstgTargetParent)
			m_pstgTargetParent->Release();
	}
	return fRetVal;
}

BOOL CLocImpFile::ProcessStrings(CLocItemHandler & ihItemHandler, 
								 const DBID & dbidFileId, 
								 BOOL fGenerating)
{
	DBID dbidParentId,dbidNodeId;
	BOOL fRetVal = TRUE;
    BOOL bUseBraces = ::IsConfiguredToUseBracesForStringTables();

	fRetVal = CreateParentNode(ihItemHandler,dbidFileId,dbidParentId,"String Table","String Table");
	for(DWORD i=0; i < m_dwCountOfStringTables;i++)
	{
		ULONG dwBytesRead;
		OLECHAR FAR* psz;
		char szTemp[MAX_BUFFER];
		CLocItemSet lsItemSet;
		int nLength = 0;

		dbidNodeId.Clear();
		m_pstmSourceString->Read(&m_clsidSnapIn,sizeof(CLSID),&dwBytesRead);
		StringFromCLSID(m_clsidSnapIn,&psz);
		wcstombs(szTemp,psz,MAX_BUFFER);
		nLength = strlen(szTemp);
		LTASSERT((szTemp[0] == '{') && (szTemp[nLength - 1] == '}'));

        // strip braces if configured so
        CString strGUID(szTemp);
        if ( !bUseBraces && strGUID[0] == _T('{') &&  strGUID[strGUID.GetLength() - 1] == _T('}'))
            strGUID = strGUID.Mid(1, strGUID.GetLength() - 2);

		fRetVal = CreateChildNode(ihItemHandler,dbidParentId,dbidNodeId,strGUID,strGUID);
		m_pstmSourceString->Read(&m_dwCountOfStrings,sizeof(DWORD),&dwBytesRead);
		if(fGenerating)
		{
			HRESULT hr;
			DWORD dwBytesWritten;
			hr = m_pstmTargetString->Write(&m_clsidSnapIn,sizeof(CLSID),&dwBytesWritten);
			hr = m_pstmTargetString->Write(&m_dwCountOfStrings,sizeof(DWORD),&dwBytesWritten);
		}
		for(DWORD j = 0;j < m_dwCountOfStrings;j++)
		{
			DWORD dwCharCount;
	
			m_pstmSourceString->Read(&m_dwID,sizeof(DWORD),&dwBytesRead);
			m_pstmSourceString->Read(&m_dwRefCount,sizeof(DWORD),&dwBytesRead);
			m_pstmSourceString->Read(&dwCharCount,sizeof(DWORD),&dwBytesRead);
			WCHAR *pString;
			pString = new WCHAR[dwCharCount + 1];
			m_pstmSourceString->Read(pString,dwCharCount * 2,&dwBytesRead);
			pString[dwCharCount] = L'\0';
			int nSize = WideCharToMultiByte(m_cpSource,0,pString,dwCharCount,szTemp,dwCharCount*2,NULL,NULL);
			szTemp[nSize] = '\0';
			AddItemToSet(lsItemSet,dbidNodeId,m_dwID,szTemp);
			delete []pString;
			if(!fGenerating)
				fRetVal = ihItemHandler.HandleItemSet(lsItemSet);
			else	
				fRetVal = GenerateStrings(ihItemHandler,lsItemSet);	
			lsItemSet.ClearItemSet();
		}
	}

	return fRetVal;
}

BOOL CLocImpFile::ProcessXMLStrings(CLocItemHandler & ihItemHandler, 
								 const DBID & dbidFileId, 
								 BOOL fGenerating)
{
	DBID dbidParentId,dbidNodeId;
	BOOL bOK = TRUE;
    BOOL bUseBraces = ::IsConfiguredToUseBracesForStringTables();

    // check if we have a table
    if (m_spStringTablesNode == NULL)
        return FALSE;

    // create node
	bOK = CreateParentNode(ihItemHandler, dbidFileId, dbidParentId, "String Table", "String Table");
    if (!bOK)
        return bOK;

    // read the strings from XML document
    CStringTableMap mapStringTables;
    HRESULT hr = ReadXMLStringTables(m_spStringTablesNode, mapStringTables);
    if (FAILED(hr))
        return FALSE;

    // iterate thru read data
    CStringTableMap::iterator it;
    for (it = mapStringTables.begin(); it != mapStringTables.end(); ++it)
    {
        std::wstring wstrGUID = it->first;
        const CStringMap& rStrings = it->second;

        dbidNodeId.Clear();

        // convert 2 ansi
        CString strGUID;
        wcstombs(strGUID.GetBuffer(wstrGUID.length()), wstrGUID.c_str(), wstrGUID.length());
        strGUID.ReleaseBuffer();

        // strip braces if configured so
        if ( !bUseBraces && strGUID[0] == _T('{') &&  strGUID[strGUID.GetLength() - 1] == _T('}'))
            strGUID = strGUID.Mid(1, strGUID.GetLength() - 2);

        bOK = CreateChildNode(ihItemHandler, dbidParentId, dbidNodeId, strGUID, strGUID);
        if (!bOK)
            return bOK;

        // handle the strings in map
        CStringMap::iterator its;
        for (its = rStrings.begin(); its != rStrings.end(); ++its)
        {
            DWORD dwID = its->first;
            std::wstring text = its->second;

            DWORD dwCharCount = text.length();
            CString strText;
            char *pBuffer = strText.GetBuffer(dwCharCount*2);
            if (pBuffer == NULL)
                return FALSE;
			int nSize = WideCharToMultiByte(m_cpSource, 0, text.c_str(), dwCharCount,
                                            pBuffer, dwCharCount*2, NULL, NULL);
			pBuffer[nSize] = '\0';
            strText.ReleaseBuffer();

            // use/update the string
            CLocItemSet lsItemSet;
			AddItemToSet(lsItemSet, dbidNodeId, dwID, strText);

			bOK = ihItemHandler.HandleItemSet(lsItemSet);
            if (!bOK)
                return bOK;

            if(fGenerating)
            {
				CLocItem *pLocItem = lsItemSet.GetAt(0);
                if (!pLocItem)
                    return FALSE;

                std::wstring strNewVal = pLocItem->GetLocString().GetString();
                hr = UpdateXMLString(m_spTargetStringTablesNode, wstrGUID, dwID, strNewVal);
                CString strMsg = strGUID;
                if (FAILED(hr))
                    return FALSE;
            }
			lsItemSet.ClearItemSet();

            if (!bOK)
                return bOK;
        }
    }

    // save XML document to the file
    if (fGenerating)
    {
        hr = SaveXMLContents(m_pstrTargetFile, m_spTargetStringTablesNode);
        if (FAILED(hr))
            return FALSE;
    }

	return TRUE;
}

BOOL CLocImpFile::AddItemToSet(CLocItemSet & isItemSet, 
							   const DBID &dbidNodeId,
							   DWORD dwID, 
							   LPCSTR szText)
{
	BOOL fRetVal = TRUE;
	CPascalString pstrText;
	CLocUniqueId uid;
	ULONG lItemType = 1;
	
	try
	{
		CLocItem * pNewItem = new CLocItem;
		pstrText.SetString(szText,strlen(szText),m_cpSource);
		uid.GetResId().SetId(dwID);
		uid.GetTypeId().SetId(lItemType);
		uid.SetParentId(dbidNodeId);

		pNewItem->SetUniqueId(uid);
				
		CLocString lsString;
	
		pNewItem->SetIconType(CIT::String);
		lsString.SetString(pstrText);
		
		pNewItem->SetFDevLock(FALSE);
		pNewItem->SetFUsrLock(FALSE);
		pNewItem->SetFExpandable(FALSE);
		pNewItem->SetFDisplayable(FALSE);
		pNewItem->SetFNoResTable(FALSE);
		lsString.SetCodePageType(cpAnsi);
		lsString.SetStringType(CST::Text);
		pNewItem->SetLocString(lsString);
		isItemSet.Add(pNewItem);
		fRetVal = TRUE;
	}
	catch (CMemoryException *pMemoryException)
	{
	CLString strContext;

		strContext.LoadString(g_hDll, IDS_MNC_GENERIC_LOCATION);
		
		m_pReporter->IssueMessage(esError, strContext, g_hDll, IDS_MNC_NO_MEMORY,
				g_locNull);
		fRetVal = FALSE;
		pMemoryException->Delete();	
	}
	catch(CException *pException)
	{
		ReportException(pException);
		pException->Delete();
		fRetVal = FALSE;
	}
	return fRetVal;
}

BOOL CLocImpFile::OpenStream(BOOL fGenerating)
{
BOOL fRetVal = TRUE;
HRESULT hr;
	


	if(!fGenerating)
	{
		hr = StgOpenStorage(m_pstrFileName,NULL,STGM_TRANSACTED | STGM_READ | STGM_SHARE_DENY_WRITE,NULL,0,&m_pstgSourceParent);
		if(!FAILED(hr))
		{
			CPascalString pstrStorage,pstrStream;
			pstrStorage.SetString("String Table",strlen("String Table"),cpAnsi);
			pstrStream.SetString("Strings",strlen("Strings"),cpAnsi);

			hr = m_pstgSourceParent->OpenStorage(pstrStorage,NULL,STGM_READ | STGM_SHARE_EXCLUSIVE,NULL,0,&m_pstgSourceStringTable);
			if(!FAILED(hr))
			{
				HRESULT hr = m_pstgSourceStringTable->OpenStream(pstrStream,0,STGM_READ | STGM_SHARE_EXCLUSIVE,0,&m_pstmSourceString);
				if(!FAILED(hr))
				{
					DWORD dwBytesRead;
					m_pstmSourceString->Read(&m_dwCountOfStringTables,sizeof(DWORD),&dwBytesRead);
				}
				else
					fRetVal = FALSE;
			}
			else
			{
				fRetVal = FALSE;
			}
		}
		else
		{
            // try to open this as XML document
            m_spStringTablesNode.Release(); // release the old one (if such exist)
            hr = OpenXMLStringTable(m_pstrFileName, &m_spStringTablesNode);
            if (SUCCEEDED(hr))
                m_bXMLBased = true;

            if (FAILED(hr))
            {
			    CLString strMessage, strFilePath;

			    m_pstrFileName.ConvertToCLString(strFilePath, CP_ACP);
			    strMessage.Format(g_hDll, IDS_MSC_ERR_OPENSTORAGE, strFilePath);
			    LTASSERT(m_pReporter != NULL);
			    m_pReporter->IssueMessage(esError, CLString(g_hDll, IDS_MNC_GENERIC_LOCATION),strMessage);

			    fRetVal = FALSE;
            }
		}
	}
	else if (!m_bXMLBased)
	{	
		hr = StgOpenStorage(m_pstrTargetFile,NULL,STGM_READWRITE | STGM_SHARE_EXCLUSIVE,NULL,0,&m_pstgTargetParent);
		if(!FAILED(hr))
		{
			CPascalString pstrStorage,pstrStream;
			pstrStorage.SetString("String Table",strlen("String Table"),cpAnsi);
			pstrStream.SetString("Strings",strlen("Strings"),cpAnsi);

			hr = m_pstgTargetParent->OpenStorage(pstrStorage,NULL,STGM_READWRITE | STGM_SHARE_EXCLUSIVE ,NULL,0,&m_pstgTargetStringTable);
			if(!FAILED(hr))
			{
				HRESULT hr = m_pstgTargetStringTable->CreateStream(pstrStream, STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE,0,0,&m_pstmTargetString);
				if(!FAILED(hr))
				{
					DWORD dwBytesRead;
					hr = m_pstmTargetString->Write(&m_dwCountOfStringTables,sizeof(DWORD),&dwBytesRead);
				}
				else
					fRetVal = FALSE;
			}
			else
				fRetVal = FALSE;
		}
		else
  			fRetVal = FALSE;
	}
    else
    {
        // try to open this as XML document
        m_spTargetStringTablesNode.Release(); // release the old one (if such exist)
        hr = OpenXMLStringTable(m_pstrTargetFile, &m_spTargetStringTablesNode);
        if (FAILED(hr))
    		fRetVal = FALSE;
    }
	return fRetVal;	
}

BOOL CLocImpFile::GenerateStrings(CLocItemHandler & ihItemHandler, 
								  CLocItemSet & isItemSet)
{
BOOL fRetVal = TRUE;
INT iNoOfElements = 0;
DWORD dwBytesWritten,dwCharCount;
WCHAR *pLocText;
HRESULT hr;

	try
	{
		if(ihItemHandler.HandleItemSet(isItemSet))
		{
			while(iNoOfElements < isItemSet.GetSize())
			{
				CLocItem *pLocItem;
				CPascalString pstrText;

				pLocItem = isItemSet.GetAt(iNoOfElements);

				hr = m_pstmTargetString->Write(&m_dwID,sizeof(DWORD),&dwBytesWritten);
				hr = m_pstmTargetString->Write(&m_dwRefCount,sizeof(DWORD),&dwBytesWritten);
				
				pstrText = pLocItem->GetLocString().GetString();
				dwCharCount = pstrText.GetStringLength();
				hr = m_pstmTargetString->Write(&dwCharCount,sizeof(DWORD),&dwBytesWritten);
				pLocText = pstrText.GetStringPointer();
				hr = m_pstmTargetString->Write(pLocText,dwCharCount * 2,&dwBytesWritten);
				pstrText.ReleaseStringPointer();
				iNoOfElements++;
			}
		}
	}
	catch(CException *pException)
	{
		ReportException(pException);
		pException->Delete();
		fRetVal = FALSE;
	}

	return fRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\dllvars.h ===
//------------------------------------------------------------------------------
//
//  File: dllvars.h
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Global variables and functions for the parser DLL
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE. This code contains
//  nothing parser-specific and is used only by the framework.
//
//	Owner:
//
//------------------------------------------------------------------------------

#ifndef DLLVARS_H
#define DLLVARS_H


void IncrementClassCount();
void DecrementClassCount();

#ifdef __DLLENTRY_CPP
#define __DLLENTRY_EXTERN 
#else
#define __DLLENTRY_EXTERN extern
#endif

__DLLENTRY_EXTERN HMODULE g_hDll;
__DLLENTRY_EXTERN PUID g_puid;


#endif // DLLVARS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\impfile.h ===
//------------------------------------------------------------------------------
//
//  File: impfile.h
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//  Declaration of CLocImpFile, which provides the ILocFile interface for
//  the parser
//
//  MAJOR IMPLEMENTATION FILE.
//
//	Owner:
//
//------------------------------------------------------------------------------

#ifndef IMPFILE_H
#define IMPFILE_H


const FileType ftMNCFileType = ftUnknown + 1;

class CLocImpFile : public ILocFile, public CLObject
{
public:
	CLocImpFile(ILocParser *);

protected:
	//
	//  Standard IUnknown methods
	//
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	//
	//  Standard Debugging interfaces
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(const CFileSpec REFERENCE,
			CReporter REFERENCE);
	STDMETHOD_(FileType, GetFileType)() const;
	STDMETHOD_(void, GetFileTypeDescription)(CLString REFERENCE) const;
	STDMETHOD_(BOOL, GetAssociatedFiles)(CStringList REFERENCE) const;

	STDMETHOD_(BOOL, EnumerateFile)(CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE);
	STDMETHOD_(BOOL, GenerateFile)(const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE);

	//
	//  CLObect implementation
	//
#ifdef LTASSERT_ACTIVE
	void AssertValid() const;
#endif

private:
	IStream *	m_pstmTargetString;
	IStorage *	m_pstgTargetStringTable;
	IStorage *	m_pstgTargetParent;
	DWORD		m_dwCountOfStringTables;
	IStream *	m_pstmSourceString;
	IStorage *	m_pstgSourceStringTable;
	IStorage *	m_pstgSourceParent;
	DWORD m_dwCountOfStrings;
	CLSID m_clsidSnapIn;
	DWORD m_dwID,m_dwRefCount;

    bool                    m_bXMLBased;
    CComQIPtr<IXMLDOMNode>  m_spStringTablesNode;
    CComQIPtr<IXMLDOMNode>  m_spTargetStringTablesNode;

private:
	BOOL GenerateStrings(CLocItemHandler & ihItemHandler,CLocItemSet &isItemSet);
	BOOL OpenStream(BOOL fGenerating);
	BOOL AddItemToSet(CLocItemSet & isItemSet,const DBID &dbidNodeId,DWORD dwID,LPCSTR szTemp);
	BOOL ProcessStrings(CLocItemHandler &ihItemHandler,const DBID &dbidFileId,BOOL fGenerating);
	BOOL ProcessXMLStrings(CLocItemHandler &ihItemHandler,const DBID &dbidFileId,BOOL fGenerating);
	BOOL EnumerateStrings(CLocItemHandler &ihItemHandler,const DBID &dbidFileId, BOOL fGenerating );
	BOOL CreateChildNode(CLocItemHandler & ihItemHandler,const DBID &dbidFileId, DBID & pNewParentId,const char *szNodeRes,const char *szNodeString);
	BOOL CreateParentNode(CLocItemHandler & ihItemHandler,const DBID &dbidFileId, DBID & pNewParentId,const char *szNodeRes,const char *szNodeString);
	//
	//  Private methods to prevent callers access.
	//
	~CLocImpFile();
	CLocImpFile();
	const CLocImpFile &operator=(const CLocImpFile &);

	//
	//  Private data for C.O.M. implementation
	//
	ILocParser *m_pParentClass;
	ULONG m_ulRefCount;

	//
	//  Framework data.
	//
	enum ImpFileError
	{
		ImpNoError,
		ImpSourceError,
		ImpTargetError,
		ImpEitherError,
		ImpNeitherError		// For errors which aren't really in files.
		// TODO: Add more error types here if you need them.
	};

	CPascalString m_pstrFileName;		// Filename of source file.
	DBID m_idFile;
	CPascalString m_pstrTargetFile;		// Filename of target file, set
										//  only when generating.
	CLFile *m_pOpenSourceFile;			// File object for source file.
	CLFile *m_pOpenTargetFile;			// File object for target file, set
										//  only when generating.

	CReporter *m_pReporter;		// Reporter object used to display messages.
								//  THIS POINTER IS VALID ONLY DURING CALLS TO
								//  OpenFile(), EnumerateFile(), GenerateFile(),
								//  and anything called from them. If it is
								//  not valid, it is guaranteed to be NULL.
	FileType m_FileType;		// Type (ft* constant above) for this file.

	CodePage m_cpSource;		// ANSI code page for source file.
	CodePage m_cpTarget;		// ANSI code page for target file, set
								//  only when generating.

	//
	//  Parser-specific data.
	//

	//
	//  Private implementation functions.
	//

	BOOL Verify();
	//
	// Handy utility functions. TODO: Except for ReportException(), they should
	// be removed if not used. Note ReportMessage() is used by other utility
	// functions.
	//

	void ReportException(CException *pException,	// DO NOT EVER REMOVE!
			ImpFileError WhichFile = ImpSourceError) const;
	void ReportMessage(MessageSeverity sev, UINT nMsgId,	// REMOVE CAREFULLY!
			ImpFileError WhichFile = ImpSourceError) const;
};

#endif // IMPFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by parser.rc
//
#define IDS_IMP_PARSER_DESC             12700
#define IDS_IMP_OR                      12701
#define IDS_IMP_MSG_SEND                12704
#define IDS_IMP_MSG_TOOLONG             12705
#define IDS_IMP_MSG_READERR             12706
#define IDS_IMP_PARSER_DESC_HELP        12709
#define IDS_IMP_FILE_DESC               12710
#define IDS_MNC_NO_MEMORY               12711
#define IDS_MNC_GENERIC_LOCATION        12712
#define IDS_MSC_ERR_OPENSTORAGE         12713
#define IDS_PARSER_OPTIONS              12714
#define IDS_PARSER_OPTIONS_HELP         12715
#define IDS_INCOMPAT_PARSER             12716
#define IDS_INCOMPAT_PARSER_HELP        12717

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\impparse.h ===
//------------------------------------------------------------------------------
//
//  File: impparse.h
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Declare CLocImpParser, which provides the ILocParser interface for
//  the parser.
//
//	THIS FILE SHOULD NEED ONLY MINOR CHANGES.
//
//	Owner:
//
//------------------------------------------------------------------------------

#pragma once

class CLocImpParser: public CPULocParser
{
public:
	CLocImpParser();
	~CLocImpParser();

	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType);
	virtual void OnGetParserInfo(ParserInfo &) const;
	virtual void OnGetFileDescriptions(CEnumCallback &) const;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor, BOOL &fDebug) const;

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &, CReporter *pReporter,
			const CContext &context);


	static const ParserId m_pid;

private:
	void RegisterOptions();
	void UnRegisterOptions();

	BOOL m_fOptionInit;

};

bool IsConfiguredToUseBracesForStringTables();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\impparse.cpp ===
//------------------------------------------------------------------------------
//
//  File: impparse.cpp
//	Copyright (C) 1995-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Implementation of CLocImpParser, which provides the ILocParser interface
//  for the parser.
//
//	Owner:
//
//------------------------------------------------------------------------------

#include "stdafx.h"


#include "dllvars.h"
#include "resource.h"
#include "impfile.h"
#include "impparse.h"


//
// Init statics
// TODO: get a ParserId in PARSERID.H for this new parser.
//

const ParserId CLocImpParser::m_pid = pidExchangeMNC;	// note: 100 is a bogus number

// Reference count the registering of options since these are global
// to the parser.
INT g_nOptionRegisterCount = 0;


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Constructor for CLocImpParser.
//------------------------------------------------------------------------------
CLocImpParser::CLocImpParser()
 : CPULocParser(g_hDll)
{
	LTTRACEPOINT("CLocImpParser constructor");
	m_fOptionInit = FALSE;
	IncrementClassCount();

	// TODO to add support for Binary objects, run this code
	// EnableInterface(IID_ILocBinary, TRUE);

} 


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Destructor for CLocImpParser.
//------------------------------------------------------------------------------
CLocImpParser::~CLocImpParser()
{
	LTTRACEPOINT("CLocImpParser destructor");

	LTASSERTONLY(AssertValid());

	DecrementClassCount();

	// Remove any options
	UnRegisterOptions();
} // end of CLocImpParser::~CLocImpParser()


HRESULT 
CLocImpParser::OnInit(
	IUnknown *)
{
	LTASSERT(!m_fOptionInit);

	RegisterOptions();
	return ERROR_SUCCESS;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Create the file instance for the given file type
//
//------------------------------------------------------------------------------
HRESULT 
CLocImpParser::OnCreateFileInstance(
	ILocFile * &pLocFile, 
	FileType ft)
{
	
	SCODE sc = E_INVALIDARG;
	
	pLocFile = NULL;

	switch (ft)
	{
	// TODO: This switch cases on the ft* constants supplied by you in
	// impfile.h. For each filetype, allocate an object of the correct
	// class to handle it and return a pointer to the object in pLocFile.
	// Most parsers user one class (CLocImpFile) which adjusts its behavior
	// according to the type.

	case ftUnknown:
	case ftMNCFileType:
	// Have to leave ftUnknown in because that is the type used until the
	// file has been parsed once successfully and the actual type is known.
		try
		{
			pLocFile = new CLocImpFile(NULL);
			sc = S_OK;
		}
		catch(CMemoryException *e)
		{
			sc = E_OUTOFMEMORY;
			e->Delete();
		}
		break;

	default:
	// Do nothing, sc falls through as E_INVALIDARG and the correct
	// result is returned.
		break;
	}
	
	return ResultFromScode(sc);
}	

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Supply the basic information about this parser.
//
//------------------------------------------------------------------------------
void 
CLocImpParser::OnGetParserInfo(
	ParserInfo &pi) 
	const
{
	pi.aParserIds.SetSize(1);
	pi.aParserIds[0].m_pid = m_pid;
	pi.aParserIds[0].m_pidParent = pidNone;
	pi.elExtensions.AddTail("msc");

	// TODO: Add the extentions for this parser's files to the
	// elExtensions list in pi, with lines of the form:
	//	pi.elExtensions.AddTail("TMP");

	// TODO: Update the IDS_IMP_PARSER_DESC resource string with
	// the description for this parser.	(For consistency with other
	// parsers, it should be 'FOO', not 'FOO parser', 'FOO format',
	// 'FOO files', etc.)
	LTVERIFY(pi.strDescription.LoadString(g_hDll, IDS_IMP_PARSER_DESC));
	LTVERIFY(pi.strHelp.LoadString(g_hDll, IDS_IMP_PARSER_DESC_HELP));

	return;
	
}	

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Supply descriptions for each file type supported
//
//------------------------------------------------------------------------------
void 
CLocImpParser::OnGetFileDescriptions(
	CEnumCallback &cb) 
	const
{
	EnumInfo eiFileInfo;
	CLString strDesc;

	eiFileInfo.szAbbreviation = NULL;

	// TODO: For each file type supported (the ft* constants you supplied in
	// impfile.h), return a string (loaded from a resource) describing it:
	//
	LTVERIFY(strDesc.LoadString(g_hDll, IDS_IMP_PARSER_DESC));
	eiFileInfo.szDescription = (const TCHAR *)strDesc;
	eiFileInfo.ulValue = ftMNCFileType;
	cb.ProcessEnum(eiFileInfo);
	
}	



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Supply the version of this parser
//
//------------------------------------------------------------------------------
void 
CLocImpParser::OnGetParserVersion(
	DWORD &dwMajor,	
	DWORD &dwMinor, 
	BOOL &fDebug) 
	const
{
	dwMajor = dwCurrentMajorVersion;
	dwMinor = dwCurrentMinorVersion;
	fDebug = fCurrentDebugMode;
	
}	


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Do any parser specific validation on the string
//
//------------------------------------------------------------------------------
CVC::ValidationCode 
CLocImpParser::OnValidateString(
	const CLocTypeId &ltiType,
	const CLocTranslation &lTrans, 
	CReporter *pReporter,
	const CContext &context)
{

	UNREFERENCED_PARAMETER(ltiType);
	UNREFERENCED_PARAMETER(lTrans);
	UNREFERENCED_PARAMETER(pReporter);
	UNREFERENCED_PARAMETER(context);

	// Edit time validation.
	// TODO if validation is done on strings this function and the Generate
	// functions should go through a common routine.

	return CVC::NoError;
		
}	

#define INCOMAPTIBLE_VERSION_TEXT _T("IncompatibleVersion")

BEGIN_LOC_UI_OPTIONS_BOOL(optCompatibleVersion)
    LOC_UI_OPTIONS_BOOL_ENTRY(INCOMAPTIBLE_VERSION_TEXT, TRUE, CLocUIOption::etCheckBox,
				IDS_INCOMPAT_PARSER, IDS_INCOMPAT_PARSER_HELP, NULL, 
				CLocUIOption::stOverride),

	END_LOC_UI_OPTIONS_BOOL();

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Register any options for the parser
//
//------------------------------------------------------------------------------
void
CLocImpParser::RegisterOptions()
{

	LTASSERT(g_nOptionRegisterCount >= 0);

	if (g_nOptionRegisterCount++ > 0)
	{
		// Already registered
        m_fOptionInit = true;
		return;
	}

	SmartRef<CLocUIOptionSet> spOptSet;
	CLocUIOptionImpHelper OptHelp(g_hDll);
	
	spOptSet = new CLocUIOptionSetDef;
	spOptSet->SetGroupName(g_puid.GetName());
	
	OptHelp.SetBools(optCompatibleVersion, COUNTOF(optCompatibleVersion));

	OptHelp.GetOptions(spOptSet.GetInterface(), IDS_PARSER_OPTIONS, IDS_PARSER_OPTIONS_HELP);

	m_fOptionInit = RegisterParserOptions(spOptSet.GetInterface());

	if (m_fOptionInit)
	{
		spOptSet.Extract();
	}
}

void
CLocImpParser::UnRegisterOptions()
{
	if (m_fOptionInit)
	{
		if (--g_nOptionRegisterCount == 0)
		{
			UnRegisterParserOptions(g_puid);		
		}
	}
}	

/***************************************************************************\
 *
 * METHOD:  IsConfiguredToUseBracesForStringTables
 *
 * PURPOSE: Reads option specifying how string table identifers should appear
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    bool - true == use braces
 *
\***************************************************************************/
bool IsConfiguredToUseBracesForStringTables()
{
    BOOL bIncompatibleVersion = GetParserOptionBool(g_puid, INCOMAPTIBLE_VERSION_TEXT);

    // true if compatible
    return !bIncompatibleVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\stdafx.h ===
//------------------------------------------------------------------------------
//
//  File: stdafx.h
//	Copyright (C) 1995=1996 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//	Include file for standard system include files, or project-specific
//	include files that are used frequently, but are changed infrequently
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE.
//
//	Owner:
//
//------------------------------------------------------------------------------

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>			// MFX Ole stuff
#include <afxtempl.h>	    // MFC template collection classes.
#include <atlbase.h>
#include <map>
#include <string>

// to avoid: clstring.inl(233) : error C4552: '!=' : operator has no effect
#pragma warning (disable: 4552)

#include <parser.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\stdafx.cpp ===
//------------------------------------------------------------------------------
//
//  File: stdafx.cpp
//	Copyright (C) 1995=1996 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//	Source file that includes just the standard includes. 
//	stdafx.obj will contain the pre-compiled type information.
//
//  YOU SHOULD NOT NEED TO TOUCH ANYTHING IN THIS FILE.
//
//	Owner:
//
//------------------------------------------------------------------------------

#include "stdafx.h"


// Add libs for the project.

#ifdef _DEBUG
#pragma comment(lib, "..\\..\\lib\\Debug\\esputil.lib") 
#pragma comment(lib, "..\\..\\lib\\Debug\\pbase.lib") 
#else
#pragma comment(lib, "..\\..\\lib\\Retail\\esputil.lib") 
#pragma comment(lib, "..\\..\\lib\\Retail\\pbase.lib") 
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\procobj.inl ===
//------------------------------------------------------------------------------
//
//  File: procobj.inl
//	Copyright (C) 1994-1997 Microsoft Corporation
//	All rights reserved.
//
//	Purpose:
//  Inline implementations of CProcessObj and derived classes.
//
//  YOU SHOULD NOT NEED TO CHANGE THIS FILE. However, the CProcessObj family
//  is used extensively in a typical parser implementation. See procobj.h for
//  more information.
//
//	Owner:
//
//------------------------------------------------------------------------------


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  Return a localizable-item handler.
//------------------------------------------------------------------------------
inline CLocItemHandler &
CProcessObj::GetHandler()
{
	ASSERT_VALID(&m_handler);

	return m_handler;
} // end of CProcessObj::GetHandler()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Get language ID object for source language.
//------------------------------------------------------------------------------
inline const CLocLangId &
CProcessObj::GetSrcLangID()
{
	return m_langIdSrc;
} // end of CProcessObj::GetSrcLangID()


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Get language ID object for target language (generating only).
//------------------------------------------------------------------------------
inline const CLocLangId &
CProcessObjGen::GetTgtLangID()
{
	return m_langIdTgt;
} // end of CProcessObjGen::GetTgtLangID()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\xml_supp.cpp ===
//------------------------------------------------------------------------------
//
//  File: xml_supp.cpp
//  Copyright (C) 1995-2000 Microsoft Corporation
//  All rights reserved.
//
//  Purpose:
//  implements helper functions for parsing XML document
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "xml_supp.h"

// include "strings.h" to get tag names and attribute names for XML elements in MSC file
#define INIT_MMC_BASE_STRINGS
#include "strings.h"
// note if you want to untie the project from MMC, copy the definitions for 
// the following strings from strings.h here:
/*
XML_TAG_MMC_CONSOLE_FILE;
XML_TAG_MMC_STRING_TABLE;
XML_TAG_STRING_TABLE_MAP;
XML_TAG_STRING_TABLE;
XML_TAG_VALUE_GUID;
XML_TAG_STRING_TABLE_STRING;
XML_ATTR_STRING_TABLE_STR_ID;
*/

LPCSTR strXMLStringTablePath[] = {  XML_TAG_MMC_CONSOLE_FILE, 
                                        XML_TAG_MMC_STRING_TABLE, 
                                            XML_TAG_STRING_TABLE_MAP };


/***************************************************************************\
 *
 * METHOD:  LocateNextElementNode
 *
 * PURPOSE: locates sibling node of type ELEMENT
 *
 * PARAMETERS:
 *    IXMLDOMNode *pNode   [in] - node which sibling to locate
 *    IXMLDOMNode **ppNode [out] - sibling node
 *
 * RETURNS:
 *    HRESULT - result code
 *
\***************************************************************************/
static HRESULT LocateNextElementNode(IXMLDOMNode *pNode, IXMLDOMNode **ppNode)
{
    // parameter check
    if (ppNode == NULL)
        return E_INVALIDARG;

    // init out parameter
    *ppNode = NULL;

    // check [in] parameter
    if (pNode == NULL)
        return E_INVALIDARG;

    // loop thru siblings
    CComPtr<IXMLDOMNode> spCurrNode = pNode;
    CComPtr<IXMLDOMNode> spResultNode;
    while (1)
    {
        // get sibling node
        HRESULT hr = spCurrNode->get_nextSibling(&spResultNode);
        if (FAILED(hr))
            return hr;

        // check the pointer
        if (spResultNode == NULL)
            return E_FAIL; // not found

        // done if it's ELEMENT node

        DOMNodeType elType = NODE_INVALID;
        spResultNode->get_nodeType(&elType);
        
        if (elType == NODE_ELEMENT)
        {
            *ppNode = spResultNode.Detach(); 
            return S_OK;
        }

        // get to the next one
        spCurrNode = spResultNode;
    }

    return E_UNEXPECTED;
}

/***************************************************************************\
 *
 * METHOD:  OpenXMLStringTable
 *
 * PURPOSE: Opens XML document and locates string table node in it
 *
 * PARAMETERS:
 *    LPCWSTR lpstrFileName             - [in] file to load document from
 *    IXMLDOMNode **ppStringTableNode   - [out] pointer to node containing string table
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT OpenXMLStringTable(LPCWSTR lpstrFileName, IXMLDOMNode **ppStringTableNode)
{
    // do parameter check
    if (lpstrFileName == NULL || ppStringTableNode == NULL)
        return E_INVALIDARG;

    // init return value
    *ppStringTableNode = NULL;

    // cocreate xml document
    CComQIPtr<IXMLDOMDocument> spDocument;
    HRESULT hr = spDocument.CoCreateInstance(CLSID_DOMDocument);
    if (FAILED(hr))
        return hr;

    // prevent re-formating
    spDocument->put_preserveWhiteSpace(VARIANT_TRUE);

    // load the file
    VARIANT_BOOL bOK = VARIANT_FALSE;
    hr = spDocument->load(CComVariant(lpstrFileName), &bOK);
    if (hr != S_OK || bOK != VARIANT_TRUE)
        return FAILED(hr) ? hr : E_FAIL;

    // the path represents element tags in similar to the file system manner
    // so 'c' from <a><b><c/></b></a> can be selected by "a/b/c"
    // construct the path
    std::string strPath;
    for (int i = 0; i< sizeof(strXMLStringTablePath)/sizeof(strXMLStringTablePath[0]); i++)
        strPath.append(i > 0 ? 1 : 0, '/' ).append(strXMLStringTablePath[i]);

    // locate required node
    hr = spDocument->selectSingleNode(CComBSTR(strPath.c_str()), ppStringTableNode);
    if (FAILED(hr))
        return hr;
    
    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  SaveXMLContents
 *
 * PURPOSE: Saves XML document to file
 *
 * PARAMETERS:
 *    LPCWSTR lpstrFileName         [in] - file to save to
 *    IXMLDOMNode *pStringTableNode [in] - pointer to <any> document's element
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT SaveXMLContents(LPCWSTR lpstrFileName, IXMLDOMNode *pStringTableNode)
{
    // do parameter check
    if (lpstrFileName == NULL || pStringTableNode == NULL)
        return E_INVALIDARG;

    // get the document
    CComQIPtr<IXMLDOMDocument> spDocument;
    HRESULT hr = pStringTableNode->get_ownerDocument(&spDocument);
    if (FAILED(hr))
        return hr;

    // save the file
    hr = spDocument->save(CComVariant(lpstrFileName));
    if (FAILED(hr))
        return hr;

    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  GetXMLElementContents
 *
 * PURPOSE: retuns XML text elements' contents as BSTR
 *
 * PARAMETERS:
 *    IXMLDOMNode *pNode    [in] - node which contents is requested
 *    CComBSTR& bstrResult  [out] - resulting string
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT GetXMLElementContents(IXMLDOMNode *pNode, CComBSTR& bstrResult)
{
    // init result
    bstrResult.Empty();

    // parameter check
    if (pNode == NULL)
        return E_INVALIDARG;

    // locate required node
    CComQIPtr<IXMLDOMNode> spTextNode;
    HRESULT hr = pNode->selectSingleNode(CComBSTR(L"text()"), &spTextNode);
    if (FAILED(hr))
        return hr;

    // recheck the pointer
    if (spTextNode == NULL)
        return E_POINTER;

    // done
    return spTextNode->get_text(&bstrResult);
}

/***************************************************************************\
 *
 * METHOD:  ReadXMLStringTables
 *
 * PURPOSE: Reads string tables to std::map - based structure
 *
 * PARAMETERS:
 *    IXMLDOMNode *pNode            [in] - string table node
 *    CStringTableMap& mapResult    [out] - map containing string tables
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT ReadXMLStringTables(IXMLDOMNode *pNode, CStringTableMap& mapResult)
{
    mapResult.clear();

    // parameter check
    if (pNode == NULL)
        return E_INVALIDARG;

    // get the node list 
    CComQIPtr<IXMLDOMNodeList> spGUIDNodes;
    HRESULT hr = pNode->selectNodes(CComBSTR(XML_TAG_VALUE_GUID), &spGUIDNodes);
    if (FAILED(hr))
        return hr;

    // recheck the pointer
    if (spGUIDNodes == NULL)
        return E_POINTER;

    // get the item count
    long length = 0;
    hr = spGUIDNodes->get_length(&length);
    if (FAILED(hr))
        return hr;

    // read the items
    for (int n = 0; n < length; n++)
    {
        // get one node
        CComQIPtr<IXMLDOMNode> spGUIDNode;
        hr = spGUIDNodes->get_item(n, &spGUIDNode);
        if (FAILED(hr))
            return hr;
    
        // read the text
        CComBSTR bstrLastGUID;
        hr = GetXMLElementContents(spGUIDNode, bstrLastGUID);
        if (FAILED(hr))
            return hr;

        // Add the entry to the map;
        CStringMap& rMapStrings = mapResult[static_cast<LPOLESTR>(bstrLastGUID)];

        //get the strings node following the guid
        CComPtr<IXMLDOMNode> spStringsNode;
        hr = LocateNextElementNode(spGUIDNode, &spStringsNode);
        if (FAILED(hr))
            return hr;

        // recheck
        if (spStringsNode == NULL)
            return E_POINTER;

        // select strings for this guid
        CComQIPtr<IXMLDOMNodeList> spStringNodeList;
        HRESULT hr = spStringsNode->selectNodes(CComBSTR(XML_TAG_STRING_TABLE_STRING), &spStringNodeList);
        if (FAILED(hr))
            return hr;

        // recheck the pointer
        if (spStringNodeList == NULL)
            return E_POINTER;

        // count the strings
        long nStrCount = 0;
        hr = spStringNodeList->get_length(&nStrCount);
        if (FAILED(hr))
            return hr;

        // add all the strings to map
        CComQIPtr<IXMLDOMNode> spStringNode;
		for(int iStr = 0; iStr < nStrCount; iStr++)
		{
            // get n-th string
            spStringNode.Release();
            hr = spStringNodeList->get_item(iStr, &spStringNode);
            if (FAILED(hr))
                return hr;

            CComQIPtr<IXMLDOMElement> spElement = spStringNode;
            if (spElement == NULL)
                return E_UNEXPECTED;

            // get string id
            CComVariant val;
            hr = spElement->getAttribute(CComBSTR(XML_ATTR_STRING_TABLE_STR_ID), &val);
            if (FAILED(hr))
                continue;
            
            DWORD dwID = val.bstrVal ? wcstoul(val.bstrVal, NULL, 10) : 0;

            // get string text
            CComBSTR bstrText;
            hr = GetXMLElementContents(spStringNode, bstrText);
            if (FAILED(hr))
                return hr;

            // add to the map
            rMapStrings[dwID] = bstrText;
		}
    }

	return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  UpdateXMLString
 *
 * PURPOSE: Updates string in string table
 *
 * PARAMETERS:
 *    IXMLDOMNode *pNode            [in] - string tables
 *    const std::wstring& strGUID   [in] - GUID of string table
 *    DWORD ID                      [in] - id of string
 *    const std::wstring& strNewVal [in] - new value for string
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT UpdateXMLString(IXMLDOMNode *pNode, const std::wstring& strGUID, DWORD ID, const std::wstring& strNewVal)
{
    // parameter check
    if (pNode == NULL)
        return E_INVALIDARG;

    USES_CONVERSION;
    // locate the GUID node
    std::wstring strTagGUID(T2CW(XML_TAG_VALUE_GUID)); 
    std::wstring strGUIDPattern( strTagGUID + L"[text() = \"" + strGUID + L"\"]" ); 

    CComQIPtr<IXMLDOMNode> spGUIDNode;
    HRESULT hr = pNode->selectSingleNode(CComBSTR(strGUIDPattern.c_str()), &spGUIDNode);
    if (FAILED(hr))
        return hr;

    // recheck
    if (spGUIDNode == NULL)
        return E_POINTER;

    //get the strings node following the guid
    CComPtr<IXMLDOMNode> spStringsNode;
    hr = LocateNextElementNode(spGUIDNode, &spStringsNode);
    if (FAILED(hr))
        return hr;

    // recheck
    if (spStringsNode == NULL)
        return E_POINTER;

    // locate the string node by ID (actually its text node)
    CString strPattern;
    strPattern.Format("%s[@%s = %d]/text()", XML_TAG_STRING_TABLE_STRING, 
                                            XML_ATTR_STRING_TABLE_STR_ID, ID);

    CComQIPtr<IXMLDOMNode> spTextNode;
    hr = spStringsNode->selectSingleNode(CComBSTR(strPattern), &spTextNode);
    if (FAILED(hr))
        return hr;

    // recheck
    if (spTextNode == NULL)
        return E_POINTER;

    // set the contents
    hr = spTextNode->put_text(CComBSTR(strNewVal.c_str()));
    if (FAILED(hr))
        return hr;
        
    return S_OK; // done
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\version.h ===
#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "MMC Localization Parser DLL"
#define VER_INTERNALNAME_STR            "mmcparse.dll"
#define VER_ORIGINALFILENAME_STR        "mmcparse.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\xml_supp.h ===
//------------------------------------------------------------------------------
//
//  File: xml_supp.h
//  Copyright (C) 1995-2000 Microsoft Corporation
//  All rights reserved.
//
//  Purpose:
//  defines helper functions for parsing XML document
//
//------------------------------------------------------------------------------


typedef std::map<int, std::wstring> CStringMap;
typedef std::map<std::wstring, CStringMap> CStringTableMap;

HRESULT OpenXMLStringTable(LPCWSTR lpstrFileName, IXMLDOMNode **ppStringTableNode);
HRESULT SaveXMLContents(LPCWSTR lpstrFileName, IXMLDOMNode *pStringTableNode);
HRESULT GetXMLElementContents(IXMLDOMNode *pNode, CComBSTR& bstrResult);
HRESULT ReadXMLStringTables(IXMLDOMNode *pNode, CStringTableMap& mapResult);
HRESULT UpdateXMLString(IXMLDOMNode *pNode, const std::wstring& strGUID, DWORD ID, 
                        const std::wstring& strNewVal);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil.h ===
//-----------------------------------------------------------------------------
//  
//  File: esputil.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Common classes for Espresso
//  
//  
//-----------------------------------------------------------------------------

#pragma once

#pragma comment(lib, "esputil.lib")

#ifdef __cplusplus
#include <mitutil.h>
#include <locutil.h>

//
//  Not everybody gets this by default.

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>
#include <loctypes.h>					//  Generic types.
#include ".\esputil\puid.h"			//  Parser Unique ID
#include ".\esputil\espreg.h"
#include ".\esputil\espenum.h"			//  Various enumeration like objects
#include ".\esputil\dbid.h"			//  Database IDs
#include ".\esputil\globalid.h"
#include ".\esputil\location.h"		//  location for Got To functionality
#include ".\esputil\goto.h"
#include ".\esputil\filespec.h"
#include ".\esputil\context.h"			//  Context for messages - string and location

#include ".\esputil\reporter.h"		//  Message reporting mechanism
#include ".\esputil\espopts.h"


#include ".\esputil\clfile.h"			//  Wrapper for CFile
#include ".\esputil\_wtrmark.h"

#include ".\esputil\resid.h"			//  Resource ID class
#include ".\esputil\typeid.h"			//  Type ID class
#include ".\esputil\uniqid.h"			//  Loc item ID
#include ".\esputil\binary.h"			//  LocItem binary data object
#include ".\esputil\interface.h"
#include ".\esputil\locitem.h"			//  Contents of a single loc item.
#include ".\esputil\itemhand.h"		//  Item handler call-back class


#include ".\esputil\LUnknown.h"		//	CLUnknown child IUnknown helper class.

//
//  These pieces are for the Espresso core components only.
//
#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including ESPUTIL private components")

//
//  These files are semi-private - Parsers should not see them.
//
#include ".\esputil\SoftInfo.h"		//	Information about Software projects.
#include ".\esputil\_var.h"
#include ".\esputil\_importo.h"			//  Import options object
#include ".\esputil\_globalid.h"
#include ".\esputil\_goto.h"
#include ".\espUtil\_reporter.h"
#include ".\esputil\_errorrep.h"
#include ".\esputil\_espopts.h"
#include ".\esputil\_interface.h"
#endif


#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\extension.h ===
//-----------------------------------------------------------------------------
//  
//  File: extension.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#include <esputil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\buildnum.h ===
//-----------------------------------------------------------------------------
//  
//  File: buildnum.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Build number file.  This converts the SLM build numbers in PRODVER.H
//  to something a little more useful.
//  
//  This is mostly used by version stamp resoruces.  If you want the build
//  numbers, you should PROBABLY use the ones exported in PBASE (if you are
//  a parser), or function GetVersionInfo() in ESPUTIL.
//
//-----------------------------------------------------------------------------

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-1998 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-1998 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\helpids.h ===
//-----------------------------------------------------------------------------
//  
//  File: helpids.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

//
//  We based off 12000 since that is the start of our resource ID range.
//  DON'T USE MATH -  the Help compiler isnt very good...
//
//  These have to be unique.  ESPPRJ and RESTBL use up the range 12000-12400
//  for their system wide unique resource ID's, so start at 12400.
//
#define IDH_SPELLDIALOG				12400
#define IDH_UNICODE_CONV			12401   
#define IDH_ENUMERATION_UNSUCCESS		12402
#define IDH_DLGLNIT_RESOURCE			12404
//#define IDH_ACME_PAGEFAULT			12406
#define IDH_NO_PARSER_UPDATE			12408
#define IDH_NO_PARSER_UPLOAD			12410
#define IDH_GENERATE_TERMINATED		12412
#define IDH_OSTRMANX_CLEAR			12414
#define IDH_ITEMS_UNMATCHED			12416
#define IDH_MESSAGE_TABLE			12418
//#define IDH_LINKER_OLD			12426
#define IDH_GETROW_ERROR			12428
#define IDH_SDM_DIALOG				12430
#define IDH_ESPGCOMP				12432
#define IDH_ESPGCOMP_OPTIONS			12434
#define IDH_Eraser_Message			12436
#define IDH_SOURCE_SAME_GEN			12438
#define IDH_SOURCE_SAME_UP			12440	



//The following are for the Project Settings and User Settings Tabs
#define IDH_RESOPT_VALIDATION			12442
#define IDH_RESOPT_SPELLING			12444
#define IDH_RESOPT_TRANSLATION		12446
#define IDH_ESPOPT_FILE				12448
#define IDH_ESPOPT_COPY_ACROSS		12450
#define IDH_ESPOPT_ADMIN			12452
#define IDH_ESPOPT_SET_FONT			12454
#define IDH_ESPOPT_RES_ANLY			12456
#define IDH_ESPOPT_CUSTOM			12003
#define IDH_ESPOPT_LOOKUP			12453
#define IDH_ESPOPT_CUSTFIELD_GLO		30536
#define IDH_ESPOPT_CUSTFIELD_PRO		12003
#define IDH_ESPOPT_COLUMNS			12513
#define IDH_ESPOPT_SUGGESTIONS		37692
#define IDH_ESPOPT_PSEUDO			12478

//The following are for the Parser Properties dialog, General and <parser name> tabs
#define IDH_ESPOPT_PARSER_PROP_GEN		12458
#define	IDH_ESPOPT_PARSER_PROP_SPEC	12460

//This provides help @ the output/translation window when the user presses F1 with the focus there...
#define IDH_PROJECT_WINDOW_F_ONE			12462
#define IDH_TRANS_WINDOW_F_ONE				12464
#define IDH_OUTPUT_PLACEHOLDER				12466

//This is for F1-on-error-message-in-output-window-help
#define IDH_UNEXPECTED_NULL_MACSDM		12468

#define IDH_WORKSPACE_WINDOW_GLOSSARY_F_ONE	12470
#define IDH_WORKSPACE_WINDOW_FILTER_F_ONE 	12472
#define IDH_GLOSSARY_TABLE_F_ONE			12474
#define IDH_SUGGESTIONS_F_ONE				12476

#define IDH_ESPOPT_EXTENSIONS				12480
#define IDH_ESPOPT_ACCELERATORS			12482

//File|Open glossary
#define IDH_FILE_OPEN_GLOSSARY	28676
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\ltapi.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltapi.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: locutil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef LOCUTIL_H
#define LOCUTIL_H
#pragma once

#pragma comment(lib, "locutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#include <ComDef.h>
#pragma warning(ZCOM_WARNING_DEFAULT)

#ifndef __AFXOLE_H__
#include <afxole.h>
#pragma message("Warning: <afxole.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>
#include ".\LocUtil\FieldVal.h"
#include ".\LocUtil\Operator.h"
#include ".\LocUtil\FieldDef.h"
#include ".\LocUtil\FldDefList.h"
#include ".\LocUtil\Schema.h"
#include ".\LocUtil\FldDefHelp.h"

#include ".\LocUtil\locobj.h"
#include ".\LocUtil\locenum.h"
#include ".\LocUtil\espreg.h"			//  Registry and version info

#include ".\LocUtil\goto.h"
#include ".\LocUtil\gotohelp.h"

#include ".\locutil\report.h"
#include ".\LocUtil\progress.h"		//  'Progressive' objects base class
#include ".\LocUtil\cancel.h"			//  Base class for 'Cancelable" objects
#include ".\locutil\logfile.h"
#include ".\LocUtil\locpct.h"			//  Percent helper classes


#include ".\LocUtil\espopts.h"
#include ".\LocUtil\espstate.h"

#include ".\LocUtil\interface.h"
#include ".\LocUtil\product.h"			//	General functions about the Espresso product installed
#include ".\LocUtil\locstr.h"
#include ".\LocUtil\StringHelp.h"		//	String UI helpers
#include ".\LocUtil\ExtList.h"			//	File Extension list
#include ".\LocUtil\lstime.h"

#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including LOCUTIL private components")


//  These files are semi-private - Parsers should not see them.
//
#include ".\LocUtil\FileDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\FileExclDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\DcsGrid.h"			// Function for DisplayColumn and MIT Grid
#include ".\LocUtil\PasStrMerge.h"

#include ".\LocUtil\_errorrep.h"		//  Error reporting mechanism
#include ".\LocUtil\_pumpidle.h"		//  Mechanism for idle time
#include ".\LocUtil\_username.h"
#include ".\LocUtil\_progress.h"
#include ".\LocUtil\_cancel.h"
#include ".\LocUtil\_locstr.h"
#include ".\LocUtil\_optvalstore.h"
#include ".\LocUtil\_espopts.h"
#include ".\LocUtil\_extension.h"
#include ".\LocUtil\_interface.h"
#include ".\LocUtil\_locenum.h"
#include ".\LocUtil\_report.h"

#include ".\LocUtil\ShowWarnings.h"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mitthrow.h ===
//-----------------------------------------------------------------------------
//  
//  File: MitThrow.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#include ".\Mit\inc\MitThrow.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mitutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitutil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  This is just a redirector to the 'real' MITUTIL.H.
//  
//-----------------------------------------------------------------------------

#include ".\mit\inc\mitutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\loctypes.h ===
//-----------------------------------------------------------------------------
//  
//  File: loctypes.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  This file contains defintions for simple types that have no
//  implementation.  If you have a 'universal' type that requires
//  implementation, put it in the 'esputil' directory.
//  
//-----------------------------------------------------------------------------
 

#pragma once

typedef ULONG SequenceNum;
//typedef int CodePage;
typedef ULONG FileId;
typedef ULONG BinaryId;

const BinaryId bidInvalid = 0;

typedef WORD ParserId;
const ParserId pidNone = 0;

typedef CWordArray CLocParserIdArray;

typedef WORD FileType;

//const CodePage cpInvalidCodePage = 0xDEADBEEF;

const FileType ftUnknown = 0; //Global filetype for an unknown type

// maximum number of bytes for strings corresponding to text fields
const size_t MAX_TXT = 255;

//Maximum number of nodes for Espresso szParents fields
const int MAX_PARENT_NODES = 31;
//
//  These values given to us by the VC guys, and are also in shell\ids.h
//
#ifndef MIN_ESPRESSO_RESOURCE_ID
const DWORD MIN_ESPRESSO_RESOURCE_ID  = 12000;
#endif
#ifndef MAX_ESPRESSO_RESOURCE_ID
const DWORD MAX_ESPRESSO_RESOURCE_ID  = 13999;
#endif

//
//  Now partion our range up for UI and non-UI (shared) components.
//
const DWORD MIN_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID;
const DWORD MAX_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID + 699;
const DWORD MIN_ESP_NONUI_RESOURCE_ID = MAX_ESP_UI_RESOURCE_ID + 1;
const DWORD MAX_ESP_NONUI_RESOURCE_ID = MAX_ESPRESSO_RESOURCE_ID;


enum VisualEditor
{
	veNone,
	veApstudio,
	veApstudioSubRes,
	veExternalEditor

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parseman.h ===
//-----------------------------------------------------------------------------
//  
//  File: parseman.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once
#pragma comment(lib, "parseman.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>

#include ".\parseman\pinfo.h"
#include ".\parseman\pmanager.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mitwarning.h ===
//******************************************************************************
//
// MitWarning.h: MIT Template Library warnings
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parser.h ===
//-----------------------------------------------------------------------------
//  
//  File: parser.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Mother of all include files for parsers.  This should be everything that
//  a parser needs.
//  
//-----------------------------------------------------------------------------

#pragma once

#define ESPRESSO_AUX_COMPONENT

#include <esputil.h>
#include <pbase.h>
#include <parsutil.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\precenum.h ===
#include ".\mit\inc\PreCEnum.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase.h ===
//-----------------------------------------------------------------------------
//  
//  File: pbase.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Parser base classes.  Parsers should really be using parsers.h
//  
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "pbase.lib")

#include ".\pbase\locfile.h"
#include ".\pbase\parseapi.h"
#include ".\pbase\pversion.h"
#include ".\pbase\subparse.h"
#include ".\pbase\binary.h"
#include ".\pbase\imgres32.h"
#include ".\pbase\mnemonic.h"
#include ".\pbase\idupdate.h"
#include ".\pbase\updatelog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\puser.h ===
//-----------------------------------------------------------------------------
//  
//  File: puser.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Master include file for components that need to use parsers, but not
//  implement a parser.
//
//  If you are implementing a parser, use PARSER.H instead.
//  
//-----------------------------------------------------------------------------
 
#pragma once

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
#include <parseman.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parserid.h ===
//-----------------------------------------------------------------------------
//
// File: parserid.h
// Copyright (c) 1994-1998 Microsoft Corporation
// All rights reserved.
//
// See 'parserid.txt' in the Parsers directory for a description of these
// constants.
//
//-----------------------------------------------------------------------------
 
#pragma once

const ParserId pidMac   = 1;
const ParserId pidText  = 2;
const ParserId pidWin32 = 3;
const ParserId pidIni   = 4;
const ParserId pidWin16 = 5;
const ParserId pidTok   = 6;
const ParserId pidInf   = 7;
const ParserId pidRiff  = 8;
const ParserId pidFox   = 9;
const ParserId pidDos7  = 10;
const ParserId pidNet	= 11;
const ParserId pidVxd	= 12;
const ParserId pidScan	= 13;
const ParserId pidMsg   = 14;
const ParserId pidWinboot = 15;
const ParserId pidRPLBoot = 16;
const ParserId pidMacTok = 17;
const ParserId pidPpd   = 18;
const ParserId pidBmpIcon = 19;
const ParserId pidProject = 20;
const ParserId pidSrg = 21;
const ParserId pidHEAT = 22;

const ParserId pidNashville_BEGIN = 23;	
const ParserId pidNashville_END = 32;   

const ParserId pidPegasus_BEGIN = 33;
const ParserId pidPegasus_STR = 33;
const ParserId pidPegasus_END = 47;   

const ParserId pidOPC = 48;
const ParserId pidDAT = 49;

const ParserId pidPublisher_BEGIN = 50;	
const ParserId pidPublisher_DES = 50;
const ParserId pidPublisher_POC = 51;
const ParserId pidPublisher_CAT = 52;
const ParserId pidPublisher_END = 59;

const ParserId pidJavaRB = 60;

const ParserId pidOffice_BEGIN = 61;
const ParserId pidOffice_END = 80;

const ParserId pidAccWiz = 81;
const ParserId pidINX = 82;

const ParserId pidMsi = 83;
const ParserId pidForms3 = 84;
const ParserId pidVbForms = 85;
const ParserId pidMmc = 86;
const ParserId pidMAPIcfg = 87;

const ParserId pidServerApps_BEGIN = 88;
const ParserId pidServerApps_SysMessages = 88;
const ParserId pidServerApps_END = 92;

const ParserId pidProjectLCP = 93;
const ParserId pidExchangeMNC = 94;

const ParserId pidFsfParse = 95;

const ParserId pidCBTParse = 96;
const ParserId pidWMI = 97;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parsutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: parsutil.h|inc
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "parsutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>						// Provide interface definitions 

#include ".\parsers\ParsUtil\LocParser.h"
#include ".\parsers\ParsUtil\LocChild.h"
#include ".\parsers\ParsUtil\LocBinary.h"
#include ".\parsers\ParsUtil\LocVersion.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\binary.h ===
//-----------------------------------------------------------------------------
//  
//  File: binary.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_BINARY_H
#define ESPUTIL_BINARY_H


//
//  Base class for binary classes.  This allows serialization
//  of arbitrary data.
//

class CLocVariant;
class CLocItem;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocBinary : public CObject
{
public:
	CLocBinary();

	virtual void AssertValid(void) const;

	//
	//  Serialization routines. Supports serialization withour dynamic creation
	//
	virtual void Serialize(CArchive &archive);  //Afx serialize function

	//
	//  Result code for comparing one binary class from another.
	//
	enum CompareCode
	{
		noChange,		
		partialChange,    //Only non-localizable data changed
		fullChange        //Localizable data changed
	};
	virtual CompareCode Compare (const CLocBinary *) = 0;

	// Called to update the non-localizable data - Used when compare returns
	// partialChange

	virtual void PartialUpdate(const CLocBinary * binSource) = 0;

	enum Alignment
	{
		a_Default,
		a_Left,
		a_Center,
		a_Right,
		a_Top,
		a_VCenter,
		a_Bottom
	};

	//
	//  The universe of possible binary properties that may be queried for.
	//  This order must NOT change, or you may break old parsers!  Put new
	//  properties at the end.
	//
	enum Property
	{
		//
		//  Native formats..
		//
		p_dwXPosition,
		p_dwYPosition,
		p_dwXDimension,
		p_dwYDimension,
		p_dwAlignment,
		p_blbNativeImage,

		p_dwFontSize,
		p_pasFontName,
		p_dwFontWeight,
		p_dwFontStyle,

		//
		//  Interchange formats..
		//
		p_dwWin32XPosition,
		p_dwWin32YPosition,
		p_dwWin32XDimension,
		p_dwWin32YDimension,
		p_dwWin32Alignment,				// Use Alignment enum
		p_dwWin32ExtAlignment,			// Extended - Use Alignment enum
		p_blbWin32Bitmap,
		p_blbWin32DialogInit,
		
		//
		//  Generic - usable both for Native and Interchange
		//
		p_bVisible,						// Is the item visable?
		p_bDisabled,					// Is the item disabled?
		p_bLTRReadingOrder,				// Is the reading order L to R?
		p_bLeftScrollBar,				// Scroll bar on left?

		//
		//	"Styles" tab for dialog controls.
		//
		p_bLeftText,					// Display text to left of control?

	
		p_bWin32LTRLayout,              // WS_EX_LAYOUT_RTL
		p_bWin32NoInheritLayout,        // WS_EX_NOINHERIT_LAYOUT

		p_dwWin32VAlignment,				// Use Alignment enum

		// Insert new entries here
	};

	virtual BOOL GetProp(const Property, CLocVariant &) const;
	virtual BOOL SetProp(const Property, const CLocVariant &);
	
	//
	// Attempts to convert CBinary in CLocItem to same type as this 
	//
	virtual BOOL Convert(CLocItem *);
	virtual BinaryId GetBinaryId(void) const = 0;
	
	virtual ~CLocBinary();

	BOOL NOTHROW GetFBinaryDirty(void) const;
	BOOL NOTHROW GetFPartialUpdateBinary(void) const;
	void NOTHROW SetFBinaryDirty(BOOL);
	void NOTHROW SetFPartialUpdateBinary(BOOL);

protected:
	
private:
	//
	//  Copy constructor and assignment are hidden, since we
	//  shouldn't be copying these things around.
	//
	CLocBinary(const CLocBinary &);
	const CLocBinary& operator=(const CLocBinary &);
	//
	//  These allow a user to determine what parts of the item have been
	//  changed.
	//
	struct Flags
	{
		BOOL m_fBinaryDirty         :1;
		BOOL m_fPartialUpdateBinary :1;
	};

	Flags m_Flags;
};

#pragma warning(default: 4275)

#include "binary.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\binary.inl ===
//-----------------------------------------------------------------------------
//  
//  File: binary.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Required inline functions for generating binary info template classes.
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFBinaryDirty(void)
		const
{
	return m_Flags.m_fBinaryDirty;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFBinaryDirty(
		BOOL f)
{
	m_Flags.m_fBinaryDirty = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFPartialUpdateBinary(void)
		const
{
	return m_Flags.m_fPartialUpdateBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFPartialUpdateBinary(
		BOOL f)
{
	m_Flags.m_fPartialUpdateBinary = f;
}



//-----------------------------------------------------------------------------
//
//  Default conversion of one Binary to another format - it fails
//
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::Convert(CLocItem *)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\context.h ===
//-----------------------------------------------------------------------------
//  
//  File: context.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_CONTEXT_H
#define ESPUTIL_CONTEXT_H



//
//  This class should NOT be used as a base class.
//
class LTAPIENTRY CContext
{
public:
	CContext();
	CContext(const CContext &);
	CContext(const CLString &);
	CContext(HINSTANCE, UINT uiStringId); 
	CContext(const CLString &, const CLocation &);
	CContext(HINSTANCE, UINT uiStringId, const CLocation &);
	CContext(const CLString &, const DBID &, ObjectType, View,
			TabId = NullTabId, Component = cmpNone);
	CContext(HINSTANCE, UINT uiStringID, const DBID &, ObjectType, View, 
			TabId = NullTabId, Component = cmpNone);
	
	void AssertValid(void) const;

	const CContext &operator=(const CContext &);

	const CLString &GetContext(void) const;
	const CLocation &GetLocation(void) const;

	BOOL operator==(const CContext &);
			
private:

	CLString m_strContext;
	CLocation m_loc;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "context.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\dbid.h ===
//-----------------------------------------------------------------------------
//  
//  File: dbid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef DBID_H
#define DBID_H


//
// represents a database id
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY DBID : public CObject
{
public:
	//
	// ctors
	//
	DBID();
	DBID(const DBID& id);
	DBID(long l);
	~DBID();

	//
	// debug methods
	//
	void AssertValid() const;
	//
	// 'get like' methods
	//
	BOOL NOTHROW IsNull() const;
	NOTHROW operator long () const;
	int NOTHROW operator==(const DBID &) const;
	int NOTHROW operator!=(const DBID &) const;

	//
	// 'put like' methods
	//
	void NOTHROW operator=(const DBID&);
	void NOTHROW Set(long);
	void NOTHROW Clear();

protected:
	long m_l;

private:
	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)

typedef CArray<DBID, DBID &> CDBIDArray;

	
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "dbid.inl"
#endif

const extern LTAPIENTRY DBID g_NullDBID;
  
#endif // DBID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\clfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: clfile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Wrapper class for CFile.  It allows us to use CPascalString for
//  file names, and does some 'text mode' read/write operations.
//  This class contains a pointer to a CFile but contains most of
//  the CFile methods thus it can be used as a CFile.  CLFile will either
//  use an existing CFile provided at construction time or it will create its
//  own CFile as needed.  In either case, the enbeded CFile is destroyed when
//  the CLFile is destroyed.
//  
//-----------------------------------------------------------------------------
 
#ifndef CLFILE_H
#define CLFILE_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLFile : public CObject
{
public:
	CLFile();
	CLFile(CFile *);
	~CLFile();

	void AssertValid(void) const;

//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
	DWORD GetPosition() const;

	DWORD SeekToEnd();
	void SeekToBegin();

	LONG Seek(LONG lOff, UINT nFrom);
	void SetLength(DWORD dwNewLen);
	DWORD GetLength() const;

	UINT Read(void* lpBuf, UINT nCount);
	void Write(const void* lpBuf, UINT nCount);

	void LockRange(DWORD dwPos, DWORD dwCount);
	void UnlockRange(DWORD dwPos, DWORD dwCount);

	void Abort();
	void Flush();
	void Close();

	CLString GetFileName(void) const;

//-----------------------------------------------------------------------------
// The following are all the CLFile methods
//-----------------------------------------------------------------------------


	BOOL Open(const CPascalString &pstrFileName, UINT nOpenFlags,
			CFileException *pError = NULL);

	static void Rename(const CPascalString &pstrFileName,
			const CPascalString &pstrNewName);
	static void Remove(const CPascalString &pstrFileName);

	static void CopyFile(
			const CPascalString &pasSource,
			const CPascalString &pasTarget,
			BOOL fFailIfExist = TRUE,
			CProgressiveObject *pProgress = NULL);
	
	static BOOL GetStatus(const CPascalString &pstrFileName,
			CFileStatus &rStatus);
	static void SetStatus(const CPascalString &pstrFileName,
			const CFileStatus &status);

	UINT ReadLine(CPascalString &pstrLine, CodePage cp);
	UINT ReadLine(CPascalString &pstrLine);

	UINT ReadString(CPascalString &pstrLine, CodePage cp);
	UINT ReadString(CPascalString &pstrLine);

	UINT ReadByte(BYTE &);
	UINT ReadWord(WORD &, BOOL BigEnded = FALSE);
	UINT ReadDWord(DWORD &, BOOL BigEnded = FALSE);

	UINT ReadPascalB(CPascalString &);
	UINT ReadPascalW(CPascalString &);
	UINT ReadPascalD(CPascalString &);

	UINT ReadPascalB(CPascalString &, CodePage);
	UINT ReadPascalW(CPascalString &, CodePage);
	UINT ReadPascalD(CPascalString &, CodePage);

	UINT Read(CPascalString &pstr, UINT nCount, CodePage cp);
	UINT Read(CPascalString &pstr, UINT nCount);

	UINT WriteLine(const CPascalString &pstrLine, CodePage cp);
	UINT WriteLine(const CPascalString &pstrLine);

	UINT WriteString(const CPascalString &pstrString, CodePage cp);
	UINT WriteString(const CPascalString &pstrString);

	UINT WriteByte(const BYTE &);
	UINT WriteWord(const WORD &, BOOL BigEnded = FALSE);
	UINT WriteDWord(const DWORD &, BOOL BigEnded = FALSE);

	UINT WritePascalB(const CPascalString &);
	UINT WritePascalW(const CPascalString &);
	UINT WritePascalD(const CPascalString &);

	UINT WritePascalB(const CPascalString &, CodePage);
	UINT WritePascalW(const CPascalString &, CodePage);
	UINT WritePascalD(const CPascalString &, CodePage);

	UINT Write(const CPascalString &pstrString);
	UINT Write(const CPascalString &pstrString, CodePage cp);

	UINT SkipToBoundary(UINT nBoundary);
	UINT PadToBoundary(UINT nBoundary, BYTE ucPad = 0);
	void Pad(UINT nCount, BYTE ucPad = 0);

	UINT CopyRange(CLFile &Target, UINT uiNumBytes,
			CProgressiveObject *pProgress = NULL);
	
protected:
	CFile *m_pFile;
	BOOL m_bDeleteFile;	//Should we delete m_pFile in our destructor?
};


enum FileStat
{
	fsNoStatus = 0x00,
	fsNotFound = 0x01,
	fsUpToDate = 0x02,
	fsFileNewer = 0x04,
	fsFileOlder = 0x08,
	fsNotReadable = 0x10,
	fsNotWritable = 0x20
};



WORD
LTAPIENTRY LocateFile(
		const CLString &strFileName,
		const COleDateTime &tGmtFileTime);



#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clfile.inl"
#endif

#endif // CLFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\clfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: clfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - we create the CFile
//  
//-----------------------------------------------------------------------------
inline
CLFile::CLFile()
{
	m_pFile = new CFile();
	m_bDeleteFile = TRUE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - user provides a CFile.  User is
//  responsible for the CFile object!
//  
//-----------------------------------------------------------------------------

inline
CLFile::CLFile(
		CFile *pFile)
{
	LTASSERT(pFile != NULL);
	m_pFile = pFile;
	m_bDeleteFile = FALSE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Destructor - also delete contained CFile if not user supplied.
//
//-----------------------------------------------------------------------------

inline
CLFile::~CLFile()
{
	DEBUGONLY(AssertValid());
	if (m_bDeleteFile)
	{
		delete m_pFile;
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Read a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count read 
CLFile::ReadByte(
	BYTE & byte)				//where to place the byte
{
	if (Read(&byte, sizeof(BYTE)) != sizeof(BYTE))
	{
		AfxThrowFileException(CFileException::endOfFile);
	}
	return sizeof(BYTE);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Write a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count written
CLFile::WriteByte(
		const BYTE & byte)
{
	Write(&byte, sizeof(BYTE));
	return sizeof(BYTE);
}


//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
inline
DWORD
CLFile::GetPosition()
		const
{
	return m_pFile->GetPosition();
}

inline
DWORD
CLFile::SeekToEnd()
{
	return m_pFile->SeekToEnd();
}

inline
void
CLFile::SeekToBegin()
{
	m_pFile->SeekToBegin();
}

inline
LONG
CLFile::Seek(
		LONG lOff,
		UINT nFrom)
{
	return m_pFile->Seek(lOff, nFrom);
}

inline
void
CLFile::SetLength(
		DWORD dwNewLen)
{
	m_pFile->SetLength(dwNewLen);
}

inline
DWORD
CLFile::GetLength()
		const
{
	return m_pFile->GetLength();
}

inline
UINT
CLFile::Read(
		void* lpBuf,
		UINT nCount)
{
	return m_pFile->Read(lpBuf, nCount);
}

inline
void
CLFile::Write(
		const void* lpBuf,
		UINT nCount)
{
	m_pFile->Write(lpBuf, nCount);
}

inline
void
CLFile::Flush()
{
	m_pFile->Flush();
}

inline
void
CLFile::Close()
{
 	m_pFile->Close();
}


inline
void
CLFile::Abort()
{
	m_pFile->Abort();
}



inline
CLString
CLFile::GetFileName(void)
		const
{
	return m_pFile->GetFileName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\context.inl ===
//-----------------------------------------------------------------------------
//  
//  File: context.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
CContext::CContext()
{}


inline
CContext::CContext(
		const CContext & context)
	: m_strContext(context.m_strContext), m_loc(context.m_loc)
{}


inline
CContext::CContext(
		const CLString &strContext)
	: m_strContext(strContext)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID)
	: m_strContext(hDll, uiStringID)
{}



inline
CContext::CContext(
		const CLString &strContext,
		const CLocation &loc)
	: m_strContext(strContext), m_loc(loc)
{}

	

inline
CContext::CContext(
		const CLString &strContext,
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabid,
		Component component)
	: m_strContext(strContext), m_loc(dbid, ot, view, tabid, component)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID,
		const CLocation &loc)
	: m_strContext(hDll, uiStringID), m_loc(loc)
{}


inline
CContext::CContext(
		HINSTANCE hDll, 
		UINT uiStringID, 
		const DBID & dbid, 
		ObjectType ot, 
		View view, 
		TabId tabid, 
		Component component)
	: m_strContext(hDll, uiStringID), 
	  m_loc(dbid, ot, view, tabid, component)
{}


inline
const CLString &
CContext::GetContext(void) const
{
	return m_strContext;
}



inline
const CLocation &
CContext::GetLocation(void)
		const
{
	return m_loc;
}



inline
const 
CContext &
CContext::operator=(const CContext & context)
{
	m_strContext	= context.m_strContext;
	m_loc			= context.m_loc;

	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\dbid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: dbid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// every new DBID is null
//
//-----------------------------------------------------------------------------
inline
DBID::DBID()
{
	m_l = 0;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid LONG
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		LONG l)
{
	LTASSERT(l > 0);

	m_l = l;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid other dbid
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		const DBID& id)
{
	ASSERT_VALID(&id);

	m_l = id.m_l;

	DEBUGONLY(++m_UsageCounter);
}



inline
DBID::~DBID()
{
	DEBUGONLY(--m_UsageCounter);
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::Set(
		LONG l)
{
	ASSERT_VALID(this);
	LTASSERT(l > 0);
	LTASSERT(m_l == 0);

	m_l = l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::operator=(
		const DBID& id)
{
	ASSERT_VALID(this);
	LTASSERT(m_l == 0);
	ASSERT_VALID(&id);

	m_l = id.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// LONG operator, the only way to get the value of a DBID, any attempt to get
// the value of a null DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
DBID::operator LONG ()
		const
{
	ASSERT_VALID(this);
	LTASSERT(m_l > 0);

	return m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to clear (make it null) the dbid must be explicit
//
//-----------------------------------------------------------------------------
inline
void
DBID::Clear()
{
	ASSERT_VALID(this);

	m_l = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to know if a dbid is null
//
//-----------------------------------------------------------------------------
inline
BOOL
DBID::IsNull()
		const
{
	ASSERT_VALID(this);

	return (m_l == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator==(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l == dbid.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator!=(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l != dbid.m_l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\espenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: espenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPENUM_H
#define ESPENUM_H



extern const LTAPIENTRY CString ftDescUnknown; //Description for unknown file types


class LTAPIENTRY CIconType
{
public:
	// Special note: these enum value sequence is of vital importance to
	// the GUI components.  Please preserve them.
	enum IconType
	{
		None = 0,
		Project,		// project root icon
		Directory,		// Part of project structure
		File,			// File object in the project
		Expandable,		// Generic Expandable node in a file.
						// Special note: Any value up to Expandable is
						// currently display as a folder in prj window
		Bitmap,			// Bitmap
		Dialog,			// Dialog like items
		Icon,			// Icon resource
		Version,		// Version stamping resources
		String,			// String resources
		Accel,			// Accelerator
		Cursor,			// Cursor resource
		Menu,			// Menu resources
		Custom,			// Custom resources
		Reference		// icon for reference glossary
	};

	NOTHROW static const TCHAR * GetIconName(CIconType::IconType);
	NOTHROW static HBITMAP GetIconBitmap(CIconType::IconType);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szIconNames[];
	CIconType();
};

typedef CIconType CIT;



class LTAPIENTRY CLocStatus
{
public:
	enum LocStatus
	{
		InvalidLocStatus = 0,
		NotLocalized,
		Updated,
		Obsolete_AutoTranslated,  //  Don't use this!  Obsolete!
		Localized = 4,
		NotApplicable,
		InvalidLocStatus2  // used by edbval to determine a invalid status
		                   // a new "valid" status must be entered before this.
	};

	NOTHROW static const TCHAR * GetStatusText(CLocStatus::LocStatus);
	NOTHROW static const TCHAR * GetStatusShortText(CLocStatus::LocStatus);
	NOTHROW static CLocStatus::LocStatus MapShortTextToEnum(const TCHAR *);
	NOTHROW static CLocStatus::LocStatus MapCharToEnum(const TCHAR);
	NOTHROW static CLocStatus::LocStatus MapLongTextToEnum(const TCHAR *szLongName);
	
	static void Enumerate(CEnumCallback &);
	
private:
	struct StatusInfo
	{
		const TCHAR *szStatusShortText;
		const TCHAR *szStatusText;
	};

	static const StatusInfo m_Info[];

	CLocStatus();
};

typedef CLocStatus CLS;




#endif // ESPENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


LTAPIENTRY BOOL RegisterParserOptions(CLocUIOptionSet*);
LTAPIENTRY void UnRegisterParserOptions(const PUID&);

LTAPIENTRY BOOL GetParserOptionValue(const PUID &, LPCTSTR szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetParserOptionBool(const PUID&, LPCTSTR pszName);
LTAPIENTRY const CPascalString GetParserOptionString(const PUID&, LPCTSTR pszName);
LTAPIENTRY DWORD GetParserOptionNumber(const PUID&, LPCTSTR pszName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\espreg.h ===
//-----------------------------------------------------------------------------
//  
//  File: espreg.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Registry and version information for Espresso 2.x
//  
//-----------------------------------------------------------------------------
 



//
//  Provided so parsers can register themselves.
//
LTAPIENTRY HRESULT RegisterParser(HMODULE);
LTAPIENTRY HRESULT UnregisterParser(ParserId pid, ParserId pidParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\filespec.h ===
//-----------------------------------------------------------------------------
//  
//  File: filespec.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_FILESPEC_H
#define ESPUTIL_FILESPEC_H

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFileSpec : public CObject
{
public:
	NOTHROW CFileSpec();
	NOTHROW CFileSpec(const CFileSpec &);
	NOTHROW CFileSpec(const CPascalString &, const DBID &);

	void AssertValid(void) const;

	NOTHROW void SetFileName(const CPascalString &);
	NOTHROW void SetFileId(const DBID &);

	NOTHROW const CPascalString & GetFileName(void) const;
	NOTHROW const DBID & GetFileId(void) const;

	NOTHROW const CFileSpec & operator=(const CFileSpec &);
	
	~CFileSpec();
	
private:
	
	CPascalString m_pasFileName;
	DBID m_didFileId;
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Various public interfaces in Espresso.
//  
//-----------------------------------------------------------------------------
 
#pragma once


extern const LTAPIENTRY IID IID_ILocStringValidation;

class CLocTranslation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocTranslation REFERENCE,
				CReporter *, const CContext &) PURE;
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\goto.h ===
//-----------------------------------------------------------------------------
//  
//  File: goto.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


LTAPIENTRY CGoto *CreateEspGoto(const CLocation &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\globals.h ===
//-----------------------------------------------------------------------------
//  
//  File: globals.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\globalid.h ===
//-----------------------------------------------------------------------------
//  
//  File: globalid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL_GLOBALID_H
#define ESPUTIL_GLOBALID_H

enum ObjectType
{
	otNone,
	otFile,
	otResource,
};



///////////////////////////////////////////////////////////////////////////////
//
// global id object, represents what fully qualifies any database item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CGlobalId: public CObject
{
public:
	//
	// ctor/dtor
	//
	NOTHROW CGlobalId();
	NOTHROW CGlobalId(const DBID &dbid, ObjectType otType);
	NOTHROW CGlobalId(const CGlobalId &id);
	NOTHROW ~CGlobalId();
	
	//
	// operators
	//
	NOTHROW int operator==(const CGlobalId &) const;
	NOTHROW int operator!=(const CGlobalId &) const;

	NOTHROW const CGlobalId & operator=(const CGlobalId &);
	
	NOTHROW const DBID & GetDBID() const;
	NOTHROW ObjectType GetObjType(void) const;
	
protected:
	//
	// debug routines
	//
	virtual void AssertValid() const;

	//
	// data members
	//
	DBID  m_dbid;
	ObjectType  m_otObjType;

	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "globalid.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\globalid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: globalid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CGlobalId::CGlobalId()
{
	m_otObjType = otNone;
	
	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ctor
//
//-----------------------------------------------------------------------------
inline
CGlobalId::CGlobalId(
		const DBID &dbid,
		ObjectType ot)
{
	m_dbid = dbid;
	m_otObjType = ot;

	DEBUGONLY(++m_UsageCounter);
}

inline
CGlobalId::CGlobalId(
		const CGlobalId &id)
{
	m_dbid = id.m_dbid;
	m_otObjType = id.m_otObjType;

	DEBUGONLY(++m_UsageCounter);
}



inline
CGlobalId::~CGlobalId()
{
	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator==(
		const CGlobalId& id)
		const
{
	return (m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator!=(
		const CGlobalId& id)
		const
{
	return !(m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Get the dbid
//
//-----------------------------------------------------------------------------

inline
const DBID &
CGlobalId::GetDBID()
		const
{
	return m_dbid;
}


inline
ObjectType
CGlobalId::GetObjType(void)
		const
{
	return m_otObjType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\itemhand.h ===
//-----------------------------------------------------------------------------
//  
//  File: itemhand.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration for the item handler class.  This encapsulates the call-back
//  functionality for the Parsers during an enumeration.
//  
//-----------------------------------------------------------------------------
 

#ifndef ITEMHAND_H
#define ITEMHAND_H


class LTAPIENTRY CLocItemHandler : public CReporter, public CCancelableObject
{
public:
	CLocItemHandler();

	void AssertValid(void) const;
	
	virtual BOOL HandleItemSet(CLocItemSet &) = 0;

	virtual ~CLocItemHandler();
			
private:
};

#endif //  ITEMHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\itemhand.inl ===
//-----------------------------------------------------------------------------
//  
//  File: itemhand.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Retail versions do nothing.  Debug code is in reporter.cpp
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\lunknown.h ===
//-----------------------------------------------------------------------------
//  
//  File: LUnknown.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined (EspUtil_LUnknown_h)
#define EspUtil_LUnknown_h


////////////////////////////////////////////////////////////////////////////////
// CLUnknown
//
//	A abstract base class that is designed to help when creating child classes
//	that depend on a parent class.  These classes can not exist by themselves,
//	but instead mearly export different interfaces to the parent class.
//
// Rules:
//	1.	All classes must have a valid, non-NULL parent pointer.
//	2.	The parent class is responsible for AddRef()'ing itself during
//		QueryInterface().
//
////////////////////////////////////////////////////////////////////////////////

class LTAPIENTRY CLUnknown
{
// Construction
public:
	CLUnknown(IUnknown * pParent);
protected:  // Don't allow stack objects
	virtual ~CLUnknown() = 0;

// Data
protected:
	ULONG		m_ulRef;	// Reference count
	IUnknown *	m_pParent;	// Parent of object

// Operations
public:
	ULONG AddRef();
	ULONG Release();
	HRESULT QueryInterface(REFIID iid, LPVOID * ppvObject);
};
////////////////////////////////////////////////////////////////////////////////

#include "LUnknown.inl"

#if !defined(DECLARE_CLUNKNOWN)

#define DECLARE_CLUNKNOWN() \
public: \
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj); \
	STDMETHOD_(ULONG, AddRef)(THIS); \
	STDMETHOD_(ULONG, Release)(THIS);

#endif

#if !defined(IMPLEMENT_CLUNKNOWN)

#define IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::AddRef(void) \
	{ \
		return CLUnknown::AddRef(); \
	}

#define IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::Release(void) \
	{ \
		return CLUnknown::Release(); \
	}

#define IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass) \
	STDMETHODIMP ObjectClass::QueryInterface(REFIID riid, LPVOID *ppVoid) \
	{ \
		return (HRESULT) CLUnknown::QueryInterface(riid, ppVoid); \
	}

#define IMPLEMENT_CLUNKNOWN(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass)

#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\locitem.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locitem.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the CLocItem class.  This is included by locitem.h.
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has a localizable string.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if there's a localizable string
CLocItem::HasLocString(void)
		const
{
	return !GetLocString().GetString().IsNull();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has binary info.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if the item has bin. content
CLocItem::HasBinary(void)
		const
{
	return m_pBinary!= NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the database id for the item.  This is internal to the DB, and
//  should not be used except to indicate parent child relationships and for
//  database operations.
//  
//-----------------------------------------------------------------------------
inline
const DBID&								// The database id for the item.
CLocItem::GetMyDatabaseId(void)
		const
{
	return m_dbid;
}





inline
const DBID &
CLocItem::GetPseudoParentId(void)
		const
{
	return m_PseudoParent;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
const CLocUniqueId &
CLocItem::GetUniqueId(void)
	const
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
CLocUniqueId &
CLocItem::GetUniqueId(void)
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the translation of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetTranslationStatus(void)
		const
{
	return m_lsTranslationStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the binary part of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetBinaryStatus(void)
		const
{
	return m_lsBinaryStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current translation origin for the item.
//  
//-----------------------------------------------------------------------------
inline
CTO::TranslationOrigin							// origin for the item.
CLocItem::GetTranslationOrigin(void)
		const
{
	return m_toTranslationOrigin;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAS::ApprovalState							// Status for the item.
CLocItem::GetApprovalStatus(void)
		const
{
	return m_asApprovalStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current auto approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAA::AutoApproved 						// Status for the item.
CLocItem::GetAutoApproved(void)
		const
{
	return m_auto_approved;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current confidence level for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetConfidenceLevel(void)
		const
{
	return m_confidence_level;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom1 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom1(void)
		const
{
	return m_custom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom2 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom2(void)
		const
{
	return m_custom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom3 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom3(void)
		const
{
	return m_custom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom4 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom4(void)
		const
{
	return m_custom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom5 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom5(void)
		const
{
	return m_custom5;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom6 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom6(void)
		const
{
	return m_custom6;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the display order for the item. This is used to provide a default
//  ordering of items in the resource table.  Lower values are displayed first.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Display order for the item.
CLocItem::GetDisplayOrder(void)
		const
{
	return m_uiDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the CLocString for the item.  To determine if it is valid, use
//  HasLocString().  A valid string can be blank!
//  
//-----------------------------------------------------------------------------
inline
const CLocString &						// Current string for the item.
CLocItem::GetLocString(void)
	const
{
	return m_lsString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'intructions' (developer provided comments) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Developer intructions.
CLocItem::GetInstructions(void)
		const
{
	return m_pstrInstructions;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'term notes' (glossary note) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Glossary Notes.
CLocItem::GetTermNotes(void)
		const
{
	return m_pstrTermNotes;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'InstrAtt'  for an item.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFInstrAtt(void)
		const
{
	return m_Flags.m_fInstrAtt;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the binary content for an item.  If this function returns FALSE, the
//  return pointer is set to NULL.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the content is valid.
CLocItem::GetBinary(
		const CLocBinary *&pBinary) // RETURN pointer
		const
{
	pBinary = m_pBinary;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Similar to GetBinary() but after this call
//	the item will no longer have a CLocBinary.
//	By calling this member, the caller gets
//	ownership of the CLocBinary, so he is responsible
//	of either deleting the CLocBinary or assigning
//	it to another CLocItem via the SetBinary() member.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if a CLocBinary was extracted.
CLocItem::ExtractBinary(
		CLocBinary *&pBinary) // RETURN pointer
{
	pBinary = m_pBinary;
	m_pBinary = NULL;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the icon type fro the item.
//  
//-----------------------------------------------------------------------------
inline
CIT::IconType
CLocItem::GetIconType(void)
		const
{
	return m_icIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the editor for this item (and all it's children!).
//  
//-----------------------------------------------------------------------------
inline
VisualEditor
CLocItem::GetVisualEditor(void)
		const
{
	return m_veEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the database id for the item.  ONLY the database code should use
//  this method.  This may become protected/private in the future!
//
//  The Database id will not allow itself be set twice!
//
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetMyDatabaseId(
		const DBID& dbid)				// New datbase id for this item.
{
	m_dbid = dbid;
}



inline void
CLocItem::SetPseudoParent(
		const DBID &dbid)
{
	m_PseudoParent.Clear();
	
	m_PseudoParent = dbid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the translation part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsTranslationStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the binary part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetBinaryStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsBinaryStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the translation origin for the item.  This is of interest to the
//  Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationOrigin(
		CTO::TranslationOrigin toNewOrigin)		// New origin for the item.
{
	m_toTranslationOrigin = toNewOrigin;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the approval status for the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetApprovalStatus(
		CAS::ApprovalState asNewStatus)		// New status for the item.
{
	m_asApprovalStatus = asNewStatus;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the auto approval status for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetAutoApproved(
		CAA::AutoApproved aaNewStatus)		// New status for the item.
{
	m_auto_approved = aaNewStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the confidence level for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetConfidenceLevel(
		long lConfLevel)		// New confidence level for the item.
{
	m_confidence_level = lConfLevel;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom1 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom1(
		long lCustom1)		
{
	m_custom1 = lCustom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom2 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom2(
		long lCustom2)		
{
	m_custom2 = lCustom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom3 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom3(
		long lCustom3)		
{
	m_custom3 = lCustom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom4 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom4(
		long lCustom4)		
{
	m_custom4 = lCustom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom5 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom5(
		long lCustom5)		
{
	m_custom5 = lCustom5;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom6 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom6(
		long lCustom6)		
{
	m_custom6 = lCustom6;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the display order for an item.  This is used to provide a default
//  ordering of items in the resource table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetDisplayOrder(
		UINT uiNewDisplayOrder)			// New display order for the item.
{
	m_uiDisplayOrder = uiNewDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the visual editor for the item.  The parser sets this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetVisualEditor(
		VisualEditor veNewEditor)
{
	m_veEditor = veNewEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the icon type.  This is displayed bside the item in the Translation
//  table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetIconType(
		CIT::IconType itNewIconType)
{
	m_icIconType = itNewIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the intstructions for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetInstructions(
		const CPascalString &pstrNewInstructions) // New instructions.
{
	if (pstrNewInstructions != m_pstrInstructions)
	{
		m_pstrInstructions = pstrNewInstructions;
		SetFInstructionsDirty(TRUE);
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the term notes for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTermNotes(
		const CPascalString &pstrNewTermNotes) // New Term Notes.
{
	if (pstrNewTermNotes != m_pstrTermNotes)
	{
		m_pstrTermNotes = pstrNewTermNotes;
	}
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the InstrAtt for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFInstrAtt(
		BOOL f)
{
	m_Flags.m_fInstrAtt = f;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears all the dirty flags for the item and its sub-components.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::ClearDirtyFlags(void)
{
	m_Flags.m_fTargetStringDirty = m_Flags.m_fStringDirty = 
			m_Flags.m_fItemDirty = m_Flags.m_fInstructionsDirty = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various internal state flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtString(void) const
{
	return m_Flags.m_fEqualSrcTgtString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtString(BOOL f)
{
	m_Flags.m_fEqualSrcTgtString = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtBinary(void) const
{
	return m_Flags.m_fEqualSrcTgtBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtBinary(BOOL f)
{
	m_Flags.m_fEqualSrcTgtBinary = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get and set methods for all the Dirty flags.  Used by the update code.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFStringDirty(void) const
{
	return m_Flags.m_fStringDirty;
}

inline
void
CLocItem::SetFStringDirty(BOOL f)
{
	m_Flags.m_fStringDirty = f;
}

inline
BOOL
CLocItem::GetFTargetStringDirty(void) const
{
	return m_Flags.m_fTargetStringDirty;
}

inline
void
CLocItem::SetFTargetStringDirty(BOOL f)
{
	m_Flags.m_fTargetStringDirty = f;
}

inline
BOOL
CLocItem::GetFItemDirty(void) const
{
	return m_Flags.m_fItemDirty;
}

inline
void
CLocItem::SetFItemDirty(BOOL f)
{
	m_Flags.m_fItemDirty = f;
}

inline
BOOL
CLocItem::GetFInstructionsDirty(void)
		const
{
	return m_Flags.m_fInstructionsDirty;
}

inline
void
CLocItem::SetFInstructionsDirty(
		BOOL f)
{
	m_Flags.m_fInstructionsDirty = f;
}

inline
BOOL
CLocItem::GetFValidTranslation(void) const
{
	return m_Flags.m_fValidTranslation;
}

inline
void
CLocItem::SetFValidTranslation(BOOL f)
{
	m_Flags.m_fValidTranslation = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Global is anything in this CBinary dirty
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::IsAnyDirty()
{
	return m_Flags.m_fItemDirty ||
		m_Flags.m_fStringDirty || 
		m_Flags.m_fTargetStringDirty ||
		m_Flags.m_fInstructionsDirty ||
		(m_pBinary==NULL ? FALSE : m_pBinary->GetFBinaryDirty());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various parser flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFDevLock(void) const
{
	return m_Flags.m_fDevLock;
}

inline
void
CLocItem::SetFDevLock(BOOL f)
{
	m_Flags.m_fDevLock = f;
}

inline
BOOL
CLocItem::GetFUsrLock(void) const
{
	return m_Flags.m_fUsrLock;
}
inline
void
CLocItem::SetFUsrLock(BOOL f)
{
	m_Flags.m_fUsrLock = f;
}

inline
BOOL
CLocItem::GetFTransLock(void) const
{
	return m_Flags.m_fTransLock;
}
inline
void
CLocItem::SetFTransLock(BOOL f)
{
	m_Flags.m_fTransLock = f;
}


inline
BOOL
CLocItem::GetFExpandable(void) const
{
	return m_Flags.m_fExpandable;
}

inline
void
CLocItem::SetFExpandable(BOOL f)
{
	m_Flags.m_fExpandable = f;
}

inline
BOOL
CLocItem::GetFDisplayable(void) const
{
	return m_Flags.m_fDisplayable;
}

inline
void
CLocItem::SetFDisplayable(BOOL f)
{
	m_Flags.m_fDisplayable = f;
}

inline
BOOL
CLocItem::GetFNoResTable(void) const
{
	return m_Flags.m_fNoResTable;
}

inline
void
CLocItem::SetFNoResTable(BOOL f)
{
	m_Flags.m_fNoResTable = f;
}



inline
void
CLocItem::SetLocString(
		const CLocString &lsNewString)
{
	m_lsString = lsNewString;
}



inline
void
CLocItem::SetUniqueId(
		const CLocUniqueId &uid)
{
	m_uid = uid;
}



inline
void
CLocItem::ClearUniqueId(void)
{
	m_uid.ClearId();
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the binary content for the item.  If there was a previous binary
//  content, it is deleted.
//  
//-----------------------------------------------------------------------------
inline 
void
CLocItem::SetBinary(
		CLocBinary *pNewBinary)
{
	if (m_pBinary != NULL)
	{
		delete m_pBinary;
	}
	m_pBinary = pNewBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item editable?
//  
//-----------------------------------------------------------------------------
inline
BOOL 
CLocItem::IsLocked(void) const
{
	return (GetFDevLock() || GetFUsrLock());
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
BOOL CLocItem::GetFVisEditorIgnore(void) const
{
	return m_Flags.m_fVisEditorIgnore;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set if the item is ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
void 
CLocItem::SetFVisEditorIgnore(BOOL f)
{
	m_Flags.m_fVisEditorIgnore = f; 
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Needed so that the CMnemonic class can be used as the key of a CMap
//  
//-----------------------------------------------------------------------------
inline
CMnemonic::operator unsigned long() const
{
	return MAKELONG(m_cHotkeyChar, m_nHotkeyScope);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\location.h ===
//-----------------------------------------------------------------------------
//  
//  File: location.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOCATION_H
#define ESPUTIL_LOCATION_H



typedef CWnd *TabId;
const TabId NullTabId = 0;

enum View
{
	vNone,
	vTransTab,
	vVisualEditor,
	vProjWindow
};

enum Component
{
	cmpNone,
	cmpSource,
	cmpTarget,
	cmpSourceAndTarget
};
	
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocation : public CObject
{
public:
	NOTHROW CLocation();
	NOTHROW CLocation(const CLocation &);
	NOTHROW CLocation(const CGlobalId &, View, TabId = NullTabId, Component = cmpNone);
	NOTHROW CLocation(const DBID &, ObjectType, View, TabId = NullTabId, Component = cmpNone);
	
#ifdef _DEBUG
	virtual void AssertValid(void) const;
#endif
	
	NOTHROW const CLocation & operator=(const CLocation &);
	NOTHROW int operator==(const CLocation &) const;
	NOTHROW int operator!=(const CLocation &) const;

	NOTHROW const CGlobalId & GetGlobalId(void) const;
	NOTHROW TabId GetTabId(void) const;
	NOTHROW View GetView(void) const;
	NOTHROW Component GetComponent(void) const;
	NOTHROW BOOL IsVisual(void) const;

	NOTHROW void SetGlobalId(const CGlobalId &);
	NOTHROW void SetTabId(const TabId);
	NOTHROW void SetView(View);
	NOTHROW void SetComponent(Component);

	NOTHROW ~CLocation() {};

private:
	NOTHROW void AssignFrom(const CLocation &);
	NOTHROW BOOL Compare(const CLocation &) const;
	
	CGlobalId m_giId;
	TabId m_TabId;
	View m_View;
	Component m_Component;
};

#pragma warning(default: 4275)

const extern LTAPIENTRY CLocation g_locNull;

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "location.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\locitem.h ===
//-----------------------------------------------------------------------------
//  
//  File: locitem.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCITEM_H
#define LOCITEM_H



#pragma warning(disable : 4251)  // Shut up already about _declspec(import)
#pragma warning(disable : 4275)  // Shut up already about _declspec(export)

class CLocItem;


//
//  Class to hold an array of pointers to items.
//
class LTAPIENTRY CLocItemPtrArray : public CTypedPtrArray<CPtrArray, CLocItem *>
{
public:
	NOTHROW CLocItemPtrArray(BOOL fDelete=TRUE);

	void AssertValid(void) const;

	void NOTHROW ClearItemPtrArray(void);
	int NOTHROW Find(DBID, const CLocItem * &, BOOL bLocalizableOnly = FALSE) const;

	virtual ~CLocItemPtrArray();

private:
	CLocItemPtrArray(const CLocItemPtrArray &);
	void operator=(const CLocItemPtrArray &);

	BOOL m_fDelete;
};


//
//  Class to hold an item set.  This is an array of items that all have the
//  same identifier.
//
class LTAPIENTRY CLocItemSet : public CLocItemPtrArray
{
public:
	NOTHROW CLocItemSet(BOOL fDelete=TRUE);

	void AssertValid(void) const;
	
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	NOTHROW const DBID & GetPseudoParentId(void) const;

	NOTHROW void ClearItemSet(void);

	NOTHROW void Match(const CLocItemSet &, CMap<int, int, int, int> &);

	NOTHROW int Find(CLocItem * pItem, int nStartAt = 0);
	
	NOTHROW ~CLocItemSet();
	
private:
	static const CLocUniqueId m_luid;     //This is a default last ditch 
	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  A localizable item. 
//  It represents either source or target data, depending on the context, but not both.
//
class LTAPIENTRY CLocItem : public CObject
{
public:
	NOTHROW CLocItem();

	void AssertValid(void) const;
	
	//
	//  Read-only access members
	//
	NOTHROW BOOL HasLocString(void) const;
	NOTHROW BOOL HasBinary(void) const;
	
	NOTHROW const DBID & GetMyDatabaseId(void) const;
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	const DBID &GetPseudoParentId(void) const;
	NOTHROW CLocUniqueId & GetUniqueId(void);
	
	NOTHROW CLS::LocStatus GetTranslationStatus(void) const;
	NOTHROW CLS::LocStatus GetBinaryStatus(void) const;
	NOTHROW CTO::TranslationOrigin GetTranslationOrigin(void) const;
	NOTHROW CAS::ApprovalState GetApprovalStatus(void) const;
	NOTHROW CAA::AutoApproved GetAutoApproved(void) const;
	NOTHROW long GetConfidenceLevel(void) const;
	NOTHROW long GetCustom1(void) const;
	NOTHROW long GetCustom2(void) const;
	NOTHROW long GetCustom3(void) const;
	NOTHROW long GetCustom4(void) const;
	NOTHROW long GetCustom5(void) const;
	NOTHROW long GetCustom6(void) const;

	NOTHROW const CLocString & GetLocString(void) const;
	
	NOTHROW BOOL GetBinary(const CLocBinary *&) const;

	NOTHROW CIT::IconType GetIconType(void) const;
	NOTHROW const CPascalString & GetInstructions(void) const;
	NOTHROW const CPascalString GetInstructions(BOOL) const;
	NOTHROW const CPascalString & GetTermNotes(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	NOTHROW VisualEditor GetVisualEditor(void) const;

	NOTHROW BOOL GetFEqualSrcTgtString(void) const;
	NOTHROW void SetFEqualSrcTgtString(BOOL);
	NOTHROW BOOL GetFEqualSrcTgtBinary(void) const;
	NOTHROW void SetFEqualSrcTgtBinary(BOOL);
	NOTHROW BOOL GetFStringDirty(void) const;
	NOTHROW void SetFStringDirty(BOOL);
	NOTHROW BOOL GetFTargetStringDirty(void) const;
	NOTHROW void SetFTargetStringDirty(BOOL);
	NOTHROW BOOL GetFItemDirty(void) const;
	NOTHROW void SetFItemDirty(BOOL);
	NOTHROW BOOL IsAnyDirty(void);
	NOTHROW BOOL IsLocked(void) const;

	NOTHROW BOOL GetFDevLock(void) const;
	NOTHROW void SetFDevLock(BOOL);
	NOTHROW BOOL GetFTransLock(void) const;
	NOTHROW void SetFTransLock(BOOL);
	NOTHROW BOOL GetFUsrLock(void) const;
	NOTHROW void SetFUsrLock(BOOL);
	NOTHROW BOOL GetFExpandable(void) const;
	NOTHROW void SetFExpandable(BOOL);
	NOTHROW BOOL GetFDisplayable(void) const;
	NOTHROW void SetFDisplayable(BOOL);
	NOTHROW BOOL GetFNoResTable(void) const;
	NOTHROW void SetFNoResTable(BOOL);
	NOTHROW BOOL GetFValidTranslation(void) const;
	NOTHROW void SetFValidTranslation(BOOL);
	NOTHROW BOOL GetFVisEditorIgnore(void) const;
	NOTHROW void SetFVisEditorIgnore(BOOL);

	NOTHROW void SetFInstructionsDirty(BOOL);
	NOTHROW BOOL GetFInstructionsDirty(void) const;
	
	NOTHROW void SetFInstrAtt(BOOL);
	NOTHROW BOOL GetFInstrAtt(void) const;

	//
	//  Assignment members.  These set the appropriate dirty flags in the
	//  item.
	//

	NOTHROW void SetMyDatabaseId(const DBID&);
	NOTHROW void SetUniqueId(const CLocUniqueId &);
	NOTHROW void SetPseudoParent(const DBID &);
	NOTHROW void SetLocString(const CLocString &);
	NOTHROW void ClearUniqueId(void);
	NOTHROW void SetTranslationStatus(CLS::LocStatus);
	NOTHROW void SetBinaryStatus(CLS::LocStatus);
	NOTHROW void SetTranslationOrigin(CTO::TranslationOrigin);
	NOTHROW void SetApprovalStatus(CAS::ApprovalState);
	NOTHROW void SetAutoApproved(CAA::AutoApproved);
	NOTHROW void SetConfidenceLevel(long);
	NOTHROW void SetCustom1(long);
	NOTHROW void SetCustom2(long);
	NOTHROW void SetCustom3(long);
	NOTHROW void SetCustom4(long);	
	NOTHROW void SetCustom5(long);
	NOTHROW void SetCustom6(long);
	NOTHROW void SetIconType(CIT::IconType);
	NOTHROW void SetInstructions(const CPascalString &);
	NOTHROW void SetTermNotes(const CPascalString &);
	NOTHROW void SetDisplayOrder(UINT);
	NOTHROW void SetVisualEditor(VisualEditor);


	//
	//  Setting the binary part will delete the
	//  previous one!
	//
	NOTHROW void SetBinary(CLocBinary *);

	NOTHROW BOOL ExtractBinary(CLocBinary *&);

	NOTHROW void TransferBinary(CLocItem *);

	//
	//  Clear ALL the dirty flags for the item.
	//
	NOTHROW void ClearDirtyFlags(void);

	//	Kind of smart assignment
	BOOL UpdateFrom(CLocItem &);

	enum eLocContent
	{
		Source,
		Target
	};

	enum eDataFlow
	{
		FromFileToDb,
		FromDbToFile
	};
	//	Kind of assignment for localizable content only.
	BOOL UpdateLocContentFrom(
		CLocItem & itemInput, 
		eDataFlow nDataFlow, 
		eLocContent nFrom, 
		eLocContent nTo);
	//Used to know how similar is the localizable content between 2 items
	enum eMatchType
	{
		matchEmpty,
		matchBinary,
		matchString,
		matchFull
	};
	int MatchLocContent(const CLocItem &);
	//
	//  Comparisons between localizable items.
	//
	NOTHROW int operator==(const CLocItem &) const;
	NOTHROW int operator!=(const CLocItem &) const;

	NOTHROW BOOL BobsConsistencyChecker(void) const;
	
	virtual ~CLocItem();

protected:
	
	//
	//  Private helper functions.
	//
	NOTHROW BOOL CompareItems(const CLocItem &);
	
private:

	//
	//  Flags that apply to the entire item.  These control the display and
	//  editablity and internal status of an item.
	//
	struct Flags
	{
		BOOL m_fDevLock           :1; // Resource locked (in source file) from parser data
		BOOL m_fUsrLock           :1; // Resource locked (by user) from parser data
		BOOL m_fTransLock         :1; // Resource locked (for the user) from parser data
		BOOL m_fExpandable        :1; // Expandable in project window
		BOOL m_fDisplayable       :1; // Display in project window
		BOOL m_fNoResTable        :1; // Don't display in res table
		BOOL m_fStringDirty       :1; // has the source locstring changed?
		BOOL m_fTargetStringDirty :1; // has the target locstring changed?
		BOOL m_fItemDirty         :1; // has any other part of the item changed?
		BOOL m_fEqualSrcTgtString :1; // are the src&tgt strings equal?
		BOOL m_fEqualSrcTgtBinary :1; // are the src&tgt binaries equal?
		BOOL m_fValidTranslation  :1; // is the target string (the translation) good 
									  // for an autotranslate ?
		BOOL m_fVisEditorIgnore   :1; // is the item ignored in the visual editor?
									  // in memory state only.
		BOOL m_fInstructionsDirty :1;
		BOOL m_fInstrAtt		  :1; // has the instruction changed by Update command?
	};

	//
	//  Prevents the default copy constructor from being called.
	//
	CLocItem(const CLocItem &);
	virtual void Serialize(CArchive &) {}
	const CLocItem &operator=(const CLocItem &);
	
	//
	//  Item data.
	//

	//Language-independent members
	DBID           m_dbid;             //Id of item within the db
	DBID           m_PseudoParent;
	CLocUniqueId   m_uid;
	CLocString     m_lsString;
	CIT::IconType  m_icIconType;       //UI Icon that visually indicates item type
	CPascalString  m_pstrInstructions; //Instructions on how to localize the item
	CPascalString  m_pstrTermNotes;    // glossary notes 
	CLS::LocStatus m_lsTranslationStatus;		// Translation Loc status
	CLS::LocStatus m_lsBinaryStatus;			// Binary Loc status
	CTO::TranslationOrigin m_toTranslationOrigin;	// translation origin
	CAS::ApprovalState	m_asApprovalStatus;
	CAA::AutoApproved m_auto_approved;		// AUTO APPROVED
	long m_confidence_level;				// confidence level
	long m_custom1;							// CUSTOM1
	long m_custom2;							// CUSTOM2
	long m_custom3;							// CUSTOM3
	long m_custom4;							// CUSTOM4
	long m_custom5;							// CUSTOM5
	long m_custom6;							// CUSTOM6
	VisualEditor   m_veEditor;         //Graphical editor used for the item
	Flags          m_Flags;            //Various flags

	//Language-dependent members
	UINT           m_uiDisplayOrder;   //Physical order of item in the file
	CLocBinary    *m_pBinary;        //Parser-specific properties

	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  Callback class used to provide information about
//  items to the item log.
//
class LTAPIENTRY CItemInfo
{
public:
	CItemInfo() {};
	
	virtual ~CItemInfo() {};

	virtual CLString GetFileName(const CLocItem *) = 0;
	virtual CLString GetItemName(const CLocItem *) = 0;
	
private:
	CItemInfo(const CItemInfo &);
	const CItemInfo & operator=(const CItemInfo &);
};



//Classes used to retrieve mnemonics (aka hotkeys) from parsers
class LTAPIENTRY CMnemonic
{
public:
	NOTHROW operator unsigned long() const;
	WCHAR m_cHotkeyChar;
	WORD m_nHotkeyScope;

};

class LTAPIENTRY CMnemonicsMap : public CMap<CMnemonic, CMnemonic &,
					  CLocItemPtrArray *, CLocItemPtrArray * &>
{
public:
	CMnemonicsMap() 
	{};

	~CMnemonicsMap();

private:
	CMnemonicsMap(const CMnemonicsMap &);
	void operator=(int);
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locitem.inl"
#endif

#endif // LOCITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\location.inl ===
//-----------------------------------------------------------------------------
//  
//  File: location.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
void
CLocation::AssignFrom(
		const CLocation &other)
{
	m_giId = other.m_giId;
	m_TabId = other.m_TabId;
	m_View = other.m_View;
	m_Component = other.m_Component;
}



inline
BOOL
CLocation::Compare(
		const CLocation &other)
		const
{
	return m_giId == other.m_giId &&
		m_TabId == other.m_TabId &&
		m_View == other.m_View &&
		m_Component == other. m_Component;
}



inline
CLocation::CLocation()
{
	m_TabId = NullTabId;
	m_View = vNone;
	m_Component = cmpNone;
}



inline
CLocation::CLocation(
		const CLocation &Other)
{
	AssignFrom(Other);
}



inline
CLocation::CLocation(
		const CGlobalId &giId,
		View view,
		TabId tabId,
		Component component)
	: m_giId(giId), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
CLocation::CLocation(
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabId,
		Component component)
	: m_giId(dbid, ot), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
const CLocation &
CLocation::operator=(
		const CLocation &Other)
{
	AssignFrom(Other);

	return *this;
}



inline
int
CLocation::operator==(
		const CLocation &Other) const
{
	return Compare(Other);
}



inline
int
CLocation::operator!=(
		const CLocation &Other) const
{
	return !Compare(Other);
}



inline
const CGlobalId &
CLocation::GetGlobalId(void)
		const
{
	return m_giId;
}



inline
TabId
CLocation::GetTabId(void)
		const
{
	return m_TabId;
}



inline
View
CLocation::GetView(void)
		const
{
	return m_View;
}



inline
Component
CLocation::GetComponent(void)
		const
{
	return m_Component;
}



inline
BOOL
CLocation::IsVisual(void)
		const
{
	return (m_View == vVisualEditor);
}



inline
void
CLocation::SetGlobalId(
		const CGlobalId &gid)
{
	m_giId = gid;
}



inline
void
CLocation::SetTabId(
		const TabId TabId)
{
	m_TabId = TabId;
}



inline
void
CLocation::SetView(
		View vView)
{
	m_View = vView;
}



inline
void
CLocation::SetComponent(
		Component comp)
{
	m_Component = comp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\puid.h ===
//-----------------------------------------------------------------------------
//  
//  File: puid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#pragma once

struct LTAPIENTRY PUID
{
	PUID();
	PUID(ParserId pid, ParserId pidParent);
	CLString GetName(void) const;
	
	ParserId m_pid;
	ParserId m_pidParent;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "puid.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\lunknown.inl ===
//-----------------------------------------------------------------------------
//  
//  File: LUnknown.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//*****************************************************************************
//
// CLUnknown Constructions / Destruction
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::CLUnknown(
		IUnknown * pParent
		)
{
	LTASSERT(pParent != NULL);

	m_ulRef = 0;
	m_pParent = pParent;
	m_pParent->AddRef();
//	AddRef();  // Don't AddRef() itself.  The caller is expected to do this
}


///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::~CLUnknown()
{
	LTASSERT(m_ulRef == 0);

	LTASSERT(m_pParent != NULL);
	m_pParent->Release();	
}


//*****************************************************************************
//
// CLUnknown Operations
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::AddRef()
{
	return ++m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::Release()
{
	LTASSERT(m_ulRef > 0);

	if (--m_ulRef == 0)
	{
		delete this;
		return 0;
	}

	return m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
HRESULT
CLUnknown::QueryInterface(REFIID iid, LPVOID * ppvObject)
{
	LTASSERT(ppvObject != NULL);

	return m_pParent->QueryInterface(iid, ppvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\resid.h ===
//-----------------------------------------------------------------------------
//  
//  File: resid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef RESID_H
#define RESID_H


class LTAPIENTRY CLocResId : public CLocId
{
public:
	NOTHROW CLocResId();

	void AssertValid(void) const;

	const CLocResId &operator=(const CLocResId &);

	int NOTHROW operator==(const CLocResId &) const;
	int NOTHROW operator!=(const CLocResId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "resid.inl"
#endif

#endif  // RESID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\reporter.inl ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\stdafx.h ===
//-----------------------------------------------------------------------------
//  
//  File: stdafx.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma warning(disable : 4663 )
#pragma warning(disable : 4665 )

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#pragma warning(disable : 4664 )
#include <afxtempl.h>

#include <mitutil.h>
#include <locutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\puid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: puid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


inline
PUID::PUID()
{
	m_pid = pidNone;
	m_pidParent = pidNone;
}



inline
PUID::PUID(
		ParserId pid,
		ParserId pidParent)
{
	m_pid = pid;
	m_pidParent = pidParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Espresso.rc
//
#define IDS_NOTE                        12746
#define IDS_WARNING                     12747
#define IDS_ERROR                       12748
#define IDS_ABORT                       12749
#define IDS_SHUTDOWN                    12750
#define IDS_OUTTAB_FILE                 12751
#define IDS_OUTTAB_TEST                 12752
#define IDS_OUTTAB_GBOX                 12753
#define IDS_OUTTAB_LOCK                 12754
#define IDS_OUTTAB_UPDATE               12755
#define IDS_OUTTAB_MESSAGES             12756
#define IDS_SETTINGS_CTX                12766
#define IDS_SETTINGS_INDENT             12767
#define IDS_SETTINGS_SEP                12768
#define IDS_SETTINGS_DEFAULT            12769
#define IDS_SETTINGS_USER               12770
#define IDS_SETTINGS_OVERRIDE           12771
#define IDS_DISP_ICON                   12772
#define IDS_DISP_SOURCE                 12773
#define IDS_DISP_TRANSLATION            12774
#define IDS_DISP_PREVIOUS               12775
#define IDS_DISP_INSTRUCTIONS           12776
#define IDS_DISP_TERM_NOTE              12777
#define IDS_DISP_RESOURCE_ID            12778
#define IDS_DISP_TRANSLATION_STATUS     12779
#define IDS_DISP_BINARY_STATUS          12780
#define IDS_DISP_TRANSLATION_ORIGIN     12781
#define IDS_DISP_STRING_CATEGORY        12782
#define IDS_DISP_APPROVAL               12783
#define IDS_DISP_LOCK                   12784
#define IDS_DISP_SRC_LOCK               12785
#define IDS_DISP_PARSER_ID              12786
#define IDS_DISP_MODIFIED_DATE          12787
#define IDS_DISP_MODIFIED_BY            12788
#define IDS_DISP_CUSTOM1                12789
#define IDS_DISP_CUSTOM2                12790
#define IDS_DISP_CUSTOM3                12791
#define IDS_DISP_CUSTOM4                12792
#define IDS_DISP_CUSTOM5                12793
#define IDS_DISP_CUSTOM6                12794
#define IDS_IconHelp                    12795
#define IDS_SourceTermHelp              12796
#define IDS_TranslationHelp             12797
#define IDS_PreviousSourceHelp          12798
#define IDS_InstructionHelp             12799
#define IDS_TermNoteHelp                12800
#define IDS_ResourceIDHelp              12801
#define IDS_TransStatusHelp             12802
#define IDS_BinStatusHelp               12803
#define IDS_TransOriginHelp             12804
#define IDS_StringCategoryHelp          12805
#define IDS_ApprovalStatusHelp          12806
#define IDS_UserLockHelp                12807
#define IDS_DevLockHelp                 12808
#define IDS_ParserIDHelp                12809
#define IDS_ModifiedDateHelp            12810
#define IDS_ModifiedByHelp              12811
#define IDS_Custom1Help                 12812
#define IDS_Custom2Help                 12813
#define IDS_Custom3Help                 12814
#define IDS_Custom4Help                 12815
#define IDS_Custom5Help                 12816
#define IDS_Custom6Help                 12817
#define IDS_SoftwareDescription         12818
#define IDS_DISP_INSTRUCTIONS_ATT       12819
#define IDS_InstructionAttHelp          12820
#define IDS_DISP_SRC_LEN                12821
#define IDS_SRC_LEN_HELP                12822
#define IDS_DISP_TGT_LEN                12823
#define IDS_TGT_LEN_HELP                12824
#define IDS_TransLockHelp               12825
#define IDS_DISP_TRANS_LOCK             12826
#define IDS_DISP_SRC_HK                 12827
#define IDS_SRC_HK_HELP                 12828
#define IDS_DISP_TGT_HK                 12829
#define IDS_TGT_HK_HELP                 12830
#define IDS_DISP_AUTO_APPROVED          12831
#define IDS_AutoApprovedHelp            12832
#define IDS_DISP_CONFIDENCE_LEVEL       12833
#define IDS_ConfidenceLevelHelp         12834
#define IDS_ConfidenceLevel_Invalid     12835

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12604
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12608
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\reporter.h ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Mechanism for reporting messages and such to people.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_REPORTER_H
#define ESPUTIL_REPORTER_H



//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReporter : public CReport
{
public:
	CReporter() {};

	void AssertValid(void) const;


 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	//
	//  The usage of these versions of IssueMessage is discouraged.  Use the
	//  versions with the CGoto objects instead.
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity,
			const CPascalString &strContext, const CLString &strMessage,
			const CLocation &, UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			HMODULE hResourceModule, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, const CLString &strMessage ,
			const CLocation &, UINT uiHelpContext = 0);
	
	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);


	virtual void IssueMessage(MessageSeverity, const CContext &context,
			const CLString &strMessage, UINT uiHelpId = 0);
	virtual void IssueMessage(MessageSeverity, const CContext &context,
			HMODULE hResourceModule, UINT uiStringId, UINT uiHelpId = 0);
	
	virtual ~CReporter();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReporter(const CReporter &);
	const CReporter &operator=(const CReporter &);

};

#pragma warning(default: 4275)


#endif // ESPUTIL_REPORTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\softinfo.h ===
//******************************************************************************
//
// SoftInfo.h: Software Utility classes
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(ESPUTIL_SoftInfo_h_INCLUDED)
#define ESPUTIL_SoftInfo_h_INCLUDED

struct LTAPIENTRY SoftCol
{
	// Unique string names for columns
	static const WCHAR * szIcon;
	static const WCHAR * szSource;
	static const WCHAR * szTarget;
	static const WCHAR * szPreviousSource;
	static const WCHAR * szInstructions;
	static const WCHAR * szInstrAtt;
	static const WCHAR * szNote;
	static const WCHAR * szResourceID;
	static const WCHAR * szTranslationStatus;
	static const WCHAR * szBinaryStatus;
	static const WCHAR * szOrigin;
	static const WCHAR * szCategory;
	static const WCHAR * szApproval;
	static const WCHAR * szLock;
	static const WCHAR * szSourceLock;
	static const WCHAR * szTransLock;
	static const WCHAR * szModifiedDate;
	static const WCHAR * szModifiedBy;
	static const WCHAR * szAutoApproved;
	static const WCHAR * szConfidenceLevel;
	static const WCHAR * szCustom1;
	static const WCHAR * szCustom2;
	static const WCHAR * szCustom3;
	static const WCHAR * szCustom4;
	static const WCHAR * szCustom5;
	static const WCHAR * szCustom6;
	static const WCHAR * szParserID;
	static const WCHAR * szSrcLen;
	static const WCHAR * szTgtLen;
	static const WCHAR * szSrcHotKey;
	static const WCHAR * szTgtHotKey;
	
	// Unique ID's for columns
	//
	// DO NOT 'INSERT' ITEMS.  You will change the ID's and
	// mess people up.
	
	typedef enum
	{
		FLD_ICON,
		FLD_SOURCE_TERM,
		FLD_TARGET_TERM,
		FLD_PREVIOUS_SOURCE_TERM,
		FLD_INSTRUCTIONS,
		FLD_INSTR_ATT,
		FLD_GLOSSARY_NOTE,
		FLD_UNIQUE_ID,
		FLD_TRANSLATION_STATUS,
		FLD_BINARY_STATUS,
		FLD_TRANSLATION_ORIGIN,
		FLD_STRING_TYPE,
		FLD_APPROVAL_STATE,
		FLD_USR_LOCK,
		FLD_DEV_LOCK,
		FLD_TRANS_LOCK,
		FLD_MODIFIED_DATE,
		FLD_MODIFIED_BY,
		FLD_AUTO_APPROVED,
		FLD_CONFIDENCE_LEVEL,
		FLD_CUSTOM1,
		FLD_CUSTOM2,
		FLD_CUSTOM3,
		FLD_CUSTOM4,
		FLD_CUSTOM5,
		FLD_CUSTOM6,
		//
		//  Add displayable columns here.
		
		FLD_PARSER_ID = 50,
		//
		//  Add non-displayable, RESTBL required columns here

		FLD_SRC_LEN = 100,
		FLD_TGT_LEN,
		FLD_SRC_HK,
		FLD_TGT_HK,
		//
		//  Add non-displayable, non-RESTBL columns here. 
		
		FLD_COUNT = 30					// Make sure this is accurate!
	} FIELD;

	// RAID:  LS42 Bug 46 fixed by MikeL
	// Functions to validate the value of the above
	// column types.  All validate functions must pass
	// two parameters:  1-LPCTSTR. and 2-DWORD
	static BOOL ValidateDefault (LPCTSTR lpszNewText, DWORD dwNewNum);
	static BOOL ValidateConfidenceLevel (LPCTSTR lpszNewText, DWORD dwNewNum);

	// Exported functions
	static void GetSoftwareSchema(CTableSchema * & pSchema);
	static const CLString & GetDisplayName(FIELD col);

	static const CColumnDefinition * GetColumnDefinition(FIELD col);

	static int GetColumnCount();

	static int GetCustomColumnCount();
	static BOOL IsCustomColumn(FIELD col);

// Implementation
protected:
	static void BuildStringCategory(CTableSchema * pSchema);
	static void BuildApprovalState(CTableSchema * pSchema);
};

#endif // ESPUTIL_SoftInfo_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\typeid.h ===
//-----------------------------------------------------------------------------
//  
//  File: typeid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef TYPEID_H
#define TYPEID_H


class LTAPIENTRY CLocTypeId : public CLocId
{
public:
	NOTHROW CLocTypeId();

	void AssertValid(void) const;

	const CLocTypeId &operator=(const CLocTypeId &);

	int NOTHROW operator==(const CLocTypeId &) const;
	int NOTHROW operator!=(const CLocTypeId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "typeid.inl"
#endif

#endif // TYPEID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\resid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: resid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline funxtions for the Resource ID.  This file should ONLY be included
//  by resid.h.
//  
//-----------------------------------------------------------------------------
 
//-----------------------------------------------------------------------------
//  
//  File: resid.inl
//
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocResId::CLocResId()
{}



inline
const CLocResId &
CLocResId::operator=(
		const CLocResId & locId)
{
	CLocId::operator=(locId);
	return *this;
}


inline
int
CLocResId::operator==(
		const CLocResId & locId)
		const
{
	return CLocId::operator==(locId);
}


inline
int
CLocResId::operator!=(
		const CLocResId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\uniqid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uniqid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline function definitions for the Espresso Unique ID.  This file should
//  ONLY be included by uniqid.h.
//  
//-----------------------------------------------------------------------------
 

inline
const DBID&
CLocUniqueId::GetParentId(void)
		const
{
	return m_dbid;
}



inline
const CLocTypeId &
CLocUniqueId::GetTypeId(void)
		const
{
	return m_tid;
}



inline
const CLocResId &
CLocUniqueId::GetResId(void)
		const
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the parent ID for the item.  This portion of the ID is set by the
//  parser.
//  
//-----------------------------------------------------------------------------
inline
DBID&
CLocUniqueId::GetParentId(void)
{
	return m_dbid;
}

inline
CLocTypeId &
CLocUniqueId::GetTypeId(void)
{
	return m_tid;
}

inline
CLocResId &
CLocUniqueId::GetResId(void)
{
	return m_rid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comapre two ID's.  
//  
//-----------------------------------------------------------------------------
inline
int								        //  Zero if different
CLocUniqueId::operator==(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return IsEqualTo(uidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compare two ID's
//  
//-----------------------------------------------------------------------------
inline
int										// Zero if identical
CLocUniqueId::operator!=(
		const CLocUniqueId &uidOther)	// ID to compare to.
		const
{
	return !IsEqualTo(uidOther);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the Parent ID component of the ID.
//  
//-----------------------------------------------------------------------------
inline
void
CLocUniqueId::SetParentId(
		const DBID& dbidNewId)			// New Parent ID
{
	m_dbid = dbidNewId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_errorrep.h ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Error reporting mechanism for Espresso 2.0
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__ERRORREP_H
#define ESPUTIL__ERRORREP_H


////////////////////// the new global issuemessage functions.
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLString &strMessage, const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		HINSTANCE hResourceDll, UINT uiStringId, const CLocation &,
		UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CLString &strContext,
		const CLocation &, CException *);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLString &strMessage, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContextId, UINT uiStringId, 
		const CLocation &, UINT uiHelpContext = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, HINSTANCE hResourceDll,
		UINT uiContext, const CLocation &, CException *);

void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		const CLString &, UINT uiHelpId = 0);
void LTAPIENTRY IssueMessage(MessageSeverity, const CContext &,
		HINSTANCE, UINT, UINT uiHelpId = 0);

void LTAPIENTRY SetErrorReporter(CReporter *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReporter(CReporter *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_espenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: _espenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__ESPENUM_H
#define ESPUTIL__ESPENUM_H


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\typeid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: typeid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the Type ID.  This file should ONLY be included
//  by typeid.h.
//
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocTypeId::CLocTypeId()
{}



inline
const CLocTypeId &
CLocTypeId::operator=(
		const CLocTypeId & locId)
{
	CLocId::operator=(locId);

	return *this;
}

inline
int
CLocTypeId::operator==(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator==(locId);
}



inline
int
CLocTypeId::operator!=(
		const CLocTypeId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\uniqid.h ===
//-----------------------------------------------------------------------------
//  
//  File: uniqid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  What we use to uniquely identify a localizable item.
//  
//-----------------------------------------------------------------------------
 

#ifndef UNIQID_H
#define UNIQID_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUniqueId : public CObject
{
public:
	NOTHROW CLocUniqueId();

	void AssertValid(void) const;

	NOTHROW const DBID & GetParentId(void) const;
	NOTHROW const CLocTypeId & GetTypeId(void) const;
	NOTHROW const CLocResId & GetResId(void) const;

	NOTHROW DBID & GetParentId(void);
	NOTHROW CLocTypeId & GetTypeId(void);
	NOTHROW CLocResId & GetResId(void);
	
	void GetDisplayableUniqueId(CPascalString &) const;	
	
	NOTHROW int operator==(const CLocUniqueId &) const;
	NOTHROW int operator!=(const CLocUniqueId &) const;
	
	const CLocUniqueId &operator=(const CLocUniqueId&);

	void SetParentId(const DBID&);

	NOTHROW void ClearId(void);
	NOTHROW BOOL IsNull();
	
	virtual ~CLocUniqueId();

protected:
	//
	//  Implementation functions.
	//
	NOTHROW BOOL IsEqualTo(const CLocUniqueId &) const;

private:
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocUniqueId(const CLocUniqueId &);
	void Serialize(CArchive &ar);

	DBID       m_dbid;
	CLocTypeId m_tid;
	CLocResId  m_rid;
	
	DEBUGONLY(static CCounter m_DisplayCounter);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uniqid.inl"
#endif

#endif // UNIQID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: _espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

LTAPIENTRY CLocOptionValStore *  GetParserOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetParserOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateParserOptionValues(void);
LTAPIENTRY CLocUIOptionSet * GetParserOptionSet(const PUID &);

LTAPIENTRY void SummarizeParserOptions(CReport *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_globalid.h ===
//-----------------------------------------------------------------------------
//  
//  File: _globalid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__GLOBALID_H
#define ESPUTIL__GLOBALID_H

///////////////////////////////////////////////////////////////////////////////
//
// global id path object, represents a fully qualified path from the root of
// the project to a specified item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable : 4275)
class LTAPIENTRY CGlobalIdPath : public CTypedPtrList < CPtrList, CGlobalId * >
{
public:
	int NOTHROW operator==(const CGlobalIdPath &) const;
	const CGlobalIdPath & operator = (const CGlobalIdPath& idPath);
	~CGlobalIdPath();

	void SetIdPath(const CLString &strFilePath, 
					const CLString &strResourcePath);

	void GetStrPath(CLString &strFilePath, CLString &strResourcePath) const;

	void NOTHROW DeleteContents();
};
#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_goto.h ===
//-----------------------------------------------------------------------------
//  
//  File: _goto.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined(ESPUTIL__goto_h_INCLUDED)
#define ESPUTIL__goto_h_INCLUDED
 
class LTAPIENTRY CEspGotoFactory : public CRefCount
{
public:
	CEspGotoFactory() {};
	
	virtual CGoto * CreateGoto(const CLocation &) = 0;

private:
	CEspGotoFactory(const CEspGotoFactory &);
};



void LTAPIENTRY RegisterEspGotoFactory(CEspGotoFactory *);

#endif // ESPUTIL__goto_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_importo.h ===
//-----------------------------------------------------------------------------
//  
//  File: importo.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class for Import Data Options
//
//  Owner: KenWal
//
//  Code Review Status: Not Reviewed
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__IMPORTO_H
#define ESPUTIL__IMPORTO_H


#pragma warning(disable : 4251)			// class 'bar' needs to have dll-
										//interface to be used by clients of
										//class 'Foo'
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocImportOptions : public CObject
{
public:

	CLocImportOptions();
	CLocImportOptions(const CLocImportOptions&);

	enum Option
	{
		coor_size = 0,
		allNonText,
		instructions,
		lockFlag,
		translockFlag,
		stringCategory,
		approvalStatus,
		custom1,
		custom2,
		custom3,
		custom4,
		custom5,
		custom6,
		termNote,
		parserOptions,
		copy,
		MAX_OPTION		//always last in the list
	};

	NOTHROW void Reset();
	NOTHROW BOOL HasOptionSet() const;
	NOTHROW BOOL GetOption(Option opt) const;
	NOTHROW void SetOption(Option opt, BOOL bEnable);

	const CStringArray &GetGroupNames(void) const;
	void AddGroupName(const CString &);
	
	NOTHROW CLocImportOptions& operator=(const CLocImportOptions&);

	virtual void AssertValid(void) const;

protected:
	BYTE m_storage[MAX_OPTION];
	CStringArray m_aOptionGroupNames;
};

struct LTAPIENTRY ImportCount
{
	ImportCount();
	
	ULONG ulResources;
	ULONG ulParserOptions;
	ULONG ulEspressoOptions;
	ULONG ulCustomFields;
};

#pragma warning(default : 4251)
#pragma warning(default: 4275)

#endif //ESPUTIL_IMPORTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_errorrep.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		const CLString &strContext,
		HINSTANCE hResourceDll,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLString &strMessage,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);

	IssueMessage(sev, strContext, strMessage, loc, uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		UINT uiStringId,
		const CLocation &loc,
		UINT uiHelpContext)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, hResourceDll, uiStringId, loc,uiHelpContext);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
IssueMessage(
		MessageSeverity sev,
		HINSTANCE hResourceDll,
		UINT uiContext,
		const CLocation &loc, 
		CException *pe)
{
	CLString strContext;

	strContext.LoadString(hResourceDll, uiContext);
	IssueMessage(sev, strContext, loc, pe);
}




inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		const CLString &strMessage,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), strMessage, context.GetLocation(),
			uiHelpId);
	
}



inline
void
IssueMessage(
		MessageSeverity sev,
		const CContext &context,
		HINSTANCE hResDll,
		UINT uiStringId,
		UINT uiHelpId)
{
	IssueMessage(sev, context.GetContext(), hResDll, uiStringId,
			context.GetLocation(), uiHelpId);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: _interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


struct LOCRESOURCEFILEINFO
{
	CFile *pFile;						// Res32 file
	LangId idLang;						// Language of the file
};

typedef LOCRESOURCEFILEINFO *LPLOCRESOURCEFILEINFO;

struct SProjectInfo
{
	CLString m_strProjPath;
	LangId m_lSource;
	LangId m_lTarget;
};


	
DECLARE_INTERFACE_(ILocExtensionResource, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum ResourceEvent
	{
		reNewFile,
		reUserCancel,
		reMakeSrcResFailed		// RAID: LS42 bug 250 fixed by MikeL (Added)
	};
	
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ CReport *, const SProjectInfo &) PURE;

	STDMETHOD(Stop)(THIS_ CReport *) PURE;

	STDMETHOD(OnEvent)(THIS_ ResourceEvent event, const CLocVariant &var,
			CReport *pReporter) PURE;
	STDMETHOD(Analyze)(THIS_
			const LOCRESOURCEFILEINFO &SourceFileInfo,
			const LOCRESOURCEFILEINFO &pTargetFileInfo,
			const CDBIDArray &aDBID,
			CReport *pReporter,
			const CLString &strContext,
			BOOL &fModifiedTarget) PURE;

	STDMETHOD_(void, SetProjName)(const CLString & strProjName) PURE;
	STDMETHOD_(BOOL, InitReports)() PURE;
};

	
interface __declspec(uuid("{9F9D180F-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtensionResource;


interface ILocTransFields;


DECLARE_INTERFACE_(ILocExtensionTranslation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum TranslationEvent
	{
		teNewFile,
		teUserCancel,
	};
	
	enum StartLocation
	{
		slProjectTree,
		slTranslationWindow
	};

	STDMETHOD_(BOOL, IsReadOnly)() CONST_METHOD PURE;
	STDMETHOD_(void, GetOperationInfo)(CLString &strContext,
			COutputTabs::OutputTabs &) CONST_METHOD PURE;
	
	STDMETHOD(Start)(THIS_ StartLocation slStart,
			CReport *, const SProjectInfo &) PURE;
	
	STDMETHOD(Stop)(THIS_ CReport *) PURE;
	
	STDMETHOD(OnEvent)(THIS_ TranslationEvent event,
			const CLocVariant &var, CReport *pReport) PURE;

	STDMETHOD(ProcessRow)(THIS_ ILocTransFields *pITransFields,
			CReport *, const CLString &strContext) PURE;
};

interface __declspec(uuid("{C35F8B61-FE4D-11d0-A5A1-00C04FC2C6D8}"))
		ILocExtensionTranslation;



DECLARE_INTERFACE_(ILocTransFields, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	enum PreferredGoto
	{
		pgDefault,
		pgProjWindow,
		pgTransTable,
		pgVisEditor
	};
	
	//
	//  Properties
	STDMETHOD_(CGoto *, GetGoto)(PreferredGoto pg = pgDefault) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullItemName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetFullFileName)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasString)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, HasBinary)() CONST_METHOD PURE;
	STDMETHOD_(BOOL, IsStringLocked)() CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValues)(UINT, CPasStringArray &)
		CONST_METHOD PURE;
	
	//
	//  Data retrieval methods
	STDMETHOD_(void, GetUniqueID)(CLocUniqueId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTargetString)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetPreviousSource)(CLocString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetInstructions)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTermNote)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTextStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetBinaryStatus)(CLS::LocStatus &) CONST_METHOD PURE;
	STDMETHOD_(void, GetStringType)(CST::StringType &) CONST_METHOD PURE;
	STDMETHOD_(void, GetApprovalState)(CAS::ApprovalState &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTranslationOrigin)(CTO::TranslationOrigin &)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetTgtLockedToSource)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetUserLock)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetAutoApproved)(CAA::AutoApproved & aa) CONST_METHOD PURE;
	STDMETHOD_(void, GetParserId)(ParserId &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdatedBy)(CPascalString &) CONST_METHOD PURE;
	STDMETHOD_(void, GetLastUpdateTime)(COleDateTime &) CONST_METHOD PURE;
	STDMETHOD_(void, GetSourceBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetTargetBinary)(CLocBinary *&) PURE;
	STDMETHOD_(void, GetInstrAttn)(BOOL &) CONST_METHOD PURE;
	STDMETHOD_(void, GetConfidenceLevel)(LONG &) CONST_METHOD PURE;
	STDMETHOD(GetCustomFieldValue)(UINT, CPascalString &) CONST_METHOD PURE;

	//
	//  Danger!  Use these, and you can totally destroy user data
	//  MAKE SURE YOU KNOW WHAT YOU ARE DOING!
	STDMETHOD(BeginEdit)() PURE;
	STDMETHOD(EndEdit)(BOOL fCommit) PURE;

	//
	//  NOTE!  Set methods implement 'business logic' - changing an item may
	//  lead to several other changes - for example, changing the target
	//  string may change the localization status.
	STDMETHOD(SetCustomFieldValue)(const UINT, const CPascalString &) PURE;	
 	STDMETHOD(SetInstructions)(const CPascalString &) PURE;
 	STDMETHOD(SetTermNote)(const CPascalString &) PURE;
 	STDMETHOD(SetStringType)(const CST::StringType) PURE;

 	STDMETHOD(SetTranslationOrigin)(const CTO::TranslationOrigin) PURE;

 	STDMETHOD(SetTextStatus)(const CLS::LocStatus) PURE;
 	STDMETHOD(SetApprovalState)(const CAS::ApprovalState) PURE;
 	STDMETHOD(SetTargetString)(const CLocString &) PURE;
 	STDMETHOD(SetTgtLockedToSource)(BOOL) PURE;
 	STDMETHOD(SetUserLock)(BOOL) PURE;
 	STDMETHOD(SetAutoApproved)(const CAA::AutoApproved aa) PURE;
	STDMETHOD(SetInstrAttn)(BOOL) PURE;
	
 	STDMETHOD(RevertString)() PURE;

	STDMETHOD(SetTargetBinary)(const CLocBinary *) PURE;
 	STDMETHOD(SetBinaryStatus)(const CLS::LocStatus) PURE;

};


interface __declspec(uuid("{42C5D1E7-FE50-11d0-A5A1-00C04FC2C6D8}"))
		ILocTransFields;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_wtrmark.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _wtrmark.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

inline
CLocWMCommon::CLocWMCommon(
	const CLString& strSource, 
	const ParserId& pid, 
	const CLString& strParserVer)
{
	m_strSource = strSource;
	m_pid = pid;
	m_strParserVer = strParserVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\cancel.h ===
//-----------------------------------------------------------------------------
//  
//  File: cancel.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_CANCEL_H
#define ESPUTIL_CANCEL_H



class CCancelDialog;

class LTAPIENTRY CCancelableObject : public CProgressiveObject
{
public:
	CCancelableObject(void);

	virtual void AssertValid(void) const;
	
	virtual BOOL fCancel(void) const = 0;

	virtual ~CCancelableObject();
};



#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cancel.inl"
#endif

#endif // ESPUTIL_CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_wtrmark.h ===
//-----------------------------------------------------------------------------
//  
//  File: _wtrmark.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#pragma once


const int EWM_MAX_LENGTH = 512;		  // Watermarks should never be longer
                                      // than this	

static TCHAR g_cWMSep = _T('\t');

// All watermarks begin with this string
static TCHAR g_szWMLocString[] = _T("Localized");


//
// This class does not need to be exported as all implementations
// are inline
//
class CLocWMCommon
{
 public:
	CLocWMCommon(const CLString& strSource, const ParserId& pid, 
			const CLString& strParserVer);

	CLString m_strSource;		// Name of the source file
	ParserId m_pid;				// Parser using the watermark
	CLString m_strParserVer;  	// Version of the parser 
};

//
// struct defining the header of watermarks when encoded in binary file types
//
#include <pshpack1.h>

struct EWM_HEADER
{
	BYTE bVersion;	   	// Version of the binary data                            
	WORD wLength;		// Length of the string		
};

#include <poppack.h>

const BYTE EWM_ESP21_VERSION = 0;
const BYTE EWM_ESP30_VERSION = 1;
const BYTE EWM_DEFAULT_VERSION = 1;

//
// This function will retrieve the current date from the system and build the 
// common Espresso WaterMark. A Tab character separates elements of the 
// watermark.
//
void LTAPIENTRY ComposeWaterMark(const CLocWMCommon& wm, 
	CLString& strWaterMark);


//
// This function will encode the watermark into non-readable characters and 
// place the encoded string with the WM_HEADER in baOut.  
//
void LTAPIENTRY EncodeWaterMark(const CLString& strNormal, CByteArray& baOut);

void LTAPIENTRY EnCryptWaterMark(DWORD* pData, int nLength);


#include "_wtrmark.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_reporter.h ===
//-----------------------------------------------------------------------------
//  
//  File: _reporter.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__REPORTER_H
#define ESPUTIL__REPORTER_H


//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReporter : public CReporter
{
public:
	CNullReporter()	{};

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
};

		


#pragma warning (disable:4251)

class LTAPIENTRY CBufferReporter : public CReporter
{
public:
	CBufferReporter();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReporter();

	const CBufferReport & GetBufReport(void) const;

private:
	CBufferReport m_bufReport;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReporter : public CReporter
{
public:
	CMessageBoxReporter();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

private:
	CMessageBoxReport m_mbReport;
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReporter : public CReporter
{
public:
	CFileReporter();

	BOOL InitFileReporter(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReporter();

private:
	CFileReport m_fReport;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReporter : public CReporter
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);
private:
	CStdOutReport m_stReport;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReporter : public CReporter
{
public:
	CRedirectReporter();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReporter *pReporter);
	
private:
	CRedirectReport m_rdReport;
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReporter : public CReporter
{
public:
	CActivateReporter(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	CActivateReport m_actReport;
};



//
//  Allows you to use a CReport as a CReporter.
class LTAPIENTRY CReportReporter : public CReporter
{
public:
	CReportReporter(CReport *);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto,
			CGotoHelp *pGotoHelp);
	virtual void Activate();
	virtual void Clear();
	virtual void SetConfidenceLevel(ConfidenceLevel);
	
	
private:
	CReport *m_pReport;
};


#pragma warning(default:4251)

//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReporter(COutputTabs::OutputTabs idx, CReporter *pReporter);
NOTHROW LTAPIENTRY CReporter * GetReporter(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReporters();

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_reporter.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\dbhelp.h ===
//******************************************************************************
//
//  DbHelp.h:  LocStudio LocUtil
//
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//******************************************************************************

#if !defined(ESPUTIL_DbHelp_h_INCLUDED)
#define ESPUTIL_DbHelp_h_INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY DbHelp
{
// Operations
public:
	static void GetSecFilePath(CLString & stPathName);
	static BOOL BuildSecFile(CLString & stSystemRegKey);
	static BOOL CreateSecurityFile();
	static BOOL SetupRegistry();

// Data
protected:
	static BOOL		m_fInit;
	static CLString m_stRegKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\cancel.inl ===
//-----------------------------------------------------------------------------
//  
//  File: cancel.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CCancelableObject::CCancelableObject(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_reporter.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetNotes(void)
		const
{
	return m_bufReport.GetNotes();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetWarnings(void)
		const
{
	return m_bufReport.GetWarnings();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetErrors(void)
		const
{
	return m_bufReport.GetErrors();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReporter.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetAborts(void)
		const
{
	return m_bufReport.GetAborts();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReporter.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReporter::GetMessages(void)
		const
{
	return m_bufReport.GetMessages();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Returns the CBufferReport object.
//  
//-----------------------------------------------------------------------------
inline
const CBufferReport &
CBufferReporter::GetBufReport(void)
	const
{
	return m_bufReport;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\esputil\_var.h ===
//-----------------------------------------------------------------------------
//  
//  File: var.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__VAR_H
#define ESPUTIL__VAR_H


//
// variant object, represents a VARIANT
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY  CVar : public CObject
{
public:
	CVar();
	CVar(const CVar&);
	CVar(VARIANT);
	CVar(const CPascalString&);
	CVar(PWSTR);
	CVar(PCWSTR);
	CVar(PSTR);
	CVar(PCSTR);
	CVar(SHORT);
	CVar(WCHAR);
	CVar(UINT);
	CVar(BOOL);
	CVar(BYTE);
	CVar(LONG);
	CVar(DATE);
	CVar(DWORD);
	CVar(tm*);			// build from a date in tm format
	~CVar();

	NOTHROW const CVar& operator = (const CVar &);
	NOTHROW const CVar& operator = (VARIANT);
	NOTHROW const CVar& operator = (const CPascalString&);
	NOTHROW const CVar& operator = (PWSTR);
	NOTHROW const CVar& operator = (PCWSTR);
	NOTHROW const CVar& operator = (PSTR);
	NOTHROW const CVar& operator = (PCSTR);
	NOTHROW const CVar& operator = (SHORT);
	NOTHROW const CVar& operator = (WCHAR);
	NOTHROW const CVar& operator = (UINT);
	NOTHROW const CVar& operator = (BOOL);
	NOTHROW const CVar& operator = (BYTE);
	NOTHROW const CVar& operator = (LONG);
	NOTHROW const CVar& operator = (DATE);
	NOTHROW const CVar& operator = (DWORD);

	NOTHROW operator COleVariant   (VOID) const;
	NOTHROW operator LPVARIANT     (VOID);
	NOTHROW operator CPascalString (VOID) const;
	NOTHROW operator SHORT         (VOID) const;
	NOTHROW operator WCHAR         (VOID) const;
	NOTHROW operator UINT          (VOID) const;
	NOTHROW operator BOOL          (VOID) const;
	NOTHROW operator BYTE          (VOID) const;
	NOTHROW operator LONG          (VOID) const;
	NOTHROW operator DATE          (VOID) const;
	NOTHROW operator DWORD         (VOID) const;
	NOTHROW operator PSTR          (VOID) const;
	NOTHROW operator PCSTR         (VOID) const;
	NOTHROW operator PWSTR         (VOID) const;
	NOTHROW operator PCWSTR        (VOID) const;

	void AnsiToWide();
	void WideToAnsi();

	void SetBSTR(BSTR);
	
	void SetStringByteLen(const char * sz, unsigned int ui);

	NOTHROW int GetLength();

	NOTHROW BOOL IsNull() const;
	NOTHROW VOID SetNull();
	NOTHROW VOID SetError();

	NOTHROW BOOL operator==(const CVar& v) const;
	NOTHROW BOOL operator!=(const CVar& v) const;

	//
	// debug routines
	//
	virtual void AssertValid() const;

private:
	VARIANT m_var;
};

#pragma warning(default: 4275)


#endif //ESPUTIL_VAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\dcsgrid.h ===
//------------------------------------------------------------------------------
//
// File: DcsGrid.h
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//
//------------------------------------------------------------------------------
 
#if !defined(__DcsGrid_h__)
#define __DcsGrid_h__

namespace MitDisplayColumns
{
	interface IOption;
	interface IColumn;
};

//------------------------------------------------------------------------------
class LTAPIENTRY CDcsGrid
{
public:
	static int DisplayOrder(MitDisplayColumns::IOption * pdcOption, 
			long nColumnID, long nOffsetDO);
	static int DisplayOrder(MitDisplayColumns::IColumn * pdcColumn, 
			long nOffsetDO);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\enumplatform.h ===
//******************************************************************************
//
// EnumPlatform.h: Common enum Platform definitions
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important: all new values must be added TO THE END, or you 
//  will break old parsers...
//

BEGIN_ENUM(Platform)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Windows)
	ENUM_ENTRY(gdo, WinNT)
	ENUM_ENTRY(gdo, Macintosh)
	ENUM_ENTRY(gdo, DOS)
	ENUM_ENTRY(gdo, Other)
	ENUM_ENTRY(gdo, All)
END_ENUM(Platform)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\extlist.h ===
//-----------------------------------------------------------------------------
//  
//  File: extlist.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Definition of an extension list.  Used by the parsers to tell the caller
//  what the parser is will to handle.
//  
//-----------------------------------------------------------------------------
 
#ifndef EXTLIST_H
#define EXTLIST_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLocExtensionList : public CStringList
{
public:
	CLocExtensionList();

	void AssertValid(void) const;
	
	//
	//  Conversion routines to/from CLString's.
	//
	void NOTHROW ConvertToCLString(CLString &) const;
	BOOL NOTHROW ConvertFromCLString(const CLString &);
	
	~CLocExtensionList();
private:
	
};

#pragma warning(default : 4275)

#endif // EXTLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\enumstringtype.h ===
//******************************************************************************
//
// EnumStringType.h: Common enum String Type definitions
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

// Note: This file can be included by both MIDL and C++.  Make sure to #include
// "PreMidlEnum.h" or "PreCEnum.h" before #including this file.

//
//  This order is important - if must change it, make sure you make the
//  corresponding changes in GetTypeName() and GetTypeTLA()!
//  All new values must be added TO THE END, or you will break old
//  parsers...
//

BEGIN_ENUM(StringType)
	ENUM_ENTRY_(gdo, None, 0)
	ENUM_ENTRY(gdo, Text)
	ENUM_ENTRY(gdo, Message)
	ENUM_ENTRY(gdo, ErrorMessage)
	ENUM_ENTRY(gdo, Comment)
	ENUM_ENTRY(gdo, StatusBarText)
	ENUM_ENTRY(gdo, ToolTipText)
	ENUM_ENTRY(gdo, KeyName)
	ENUM_ENTRY(gdo, ArgumentName)
	ENUM_ENTRY(gdo, FunctionName)
	ENUM_ENTRY(gdo, FolderName)
	ENUM_ENTRY(gdo, FontName)
	ENUM_ENTRY(gdo, StaticText)
	ENUM_ENTRY(gdo, DialogTitle)
	ENUM_ENTRY(gdo, TabControl)
	ENUM_ENTRY(gdo, GroupBoxTitle)
	ENUM_ENTRY(gdo, EditBox)
	ENUM_ENTRY(gdo, Button)
	ENUM_ENTRY(gdo, OptionButton)
	ENUM_ENTRY(gdo, CheckBox)
	ENUM_ENTRY(gdo, CustomControl)
	ENUM_ENTRY(gdo, TrackBar)
	ENUM_ENTRY(gdo, ProgressBar)
	ENUM_ENTRY(gdo, DriveLetter)
	ENUM_ENTRY(gdo, Folder)
	ENUM_ENTRY(gdo, MenuItem)
	ENUM_ENTRY(gdo, Accelerator)
	ENUM_ENTRY(gdo, Version)
	ENUM_ENTRY(gdo, Translation)
	ENUM_ENTRY(gdo, ListBox)
	ENUM_ENTRY(gdo, ScrollBar)
	ENUM_ENTRY(gdo, ComboBox)
	ENUM_ENTRY(gdo, RadioButton)
	ENUM_ENTRY(gdo, GroupBox)
	ENUM_ENTRY(gdo, General)
	ENUM_ENTRY(gdo, Unknown)
	ENUM_ENTRY(gdo, Keyword)
	ENUM_ENTRY(gdo, TopicTitle)
	ENUM_ENTRY(gdo, PageTitle)
	ENUM_ENTRY(gdo, Command)
	ENUM_ENTRY(gdo, Address)
	ENUM_ENTRY(gdo, AlternativeText)
	ENUM_ENTRY(gdo, HTMLText)
	ENUM_ENTRY(gdo, HTMLTitle)
	ENUM_ENTRY(gdo, JavaText)
	ENUM_ENTRY(gdo, Number)
	ENUM_ENTRY(gdo, PageInformation)
	ENUM_ENTRY(gdo, Style)
	ENUM_ENTRY(gdo, VBScriptText)
	ENUM_ENTRY(gdo, Property)
	ENUM_ENTRY(gdo, MacroAction)
	ENUM_ENTRY(gdo, FileName)
	ENUM_ENTRY(gdo, Billboards)
	ENUM_ENTRY(gdo, DialogItem)
	ENUM_ENTRY(gdo, Description)
	ENUM_ENTRY(gdo, FeatureTitle)
	ENUM_ENTRY(gdo, FeatureDescription)
	ENUM_ENTRY(gdo, INIFileName)
	ENUM_ENTRY(gdo, INIFileKey)
	ENUM_ENTRY(gdo, INIFileSection)
	ENUM_ENTRY(gdo, INIFileValue)
	ENUM_ENTRY(gdo, AppData)
	ENUM_ENTRY(gdo, RegistryValue)
	ENUM_ENTRY(gdo, ResourceData)
	ENUM_ENTRY(gdo, ShortcutDescription)
	ENUM_ENTRY(gdo, ShortcutName)
	ENUM_ENTRY(gdo, ShortcutHotKey)
	ENUM_ENTRY(gdo, ShortcutArgument)
	ENUM_ENTRY(gdo, Verb)
	ENUM_ENTRY(gdo, Argument)
	ENUM_ENTRY(gdo, ComponentID)
	ENUM_ENTRY(gdo, FileSize)
	ENUM_ENTRY(gdo, Fileversion)
	ENUM_ENTRY(gdo, FileLanguage)
	ENUM_ENTRY(gdo, Documentation)
END_ENUM(StringType)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\espstate.h ===
//-----------------------------------------------------------------------------
//  
//  File: espstate.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


// *************************************************************************************************
// TEMPORARY: Move to seperate file

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CEspState : public CObject
{
// Construction
public:
	CEspState();

// Enums
public:
	enum eState
	{
		esIdle				= 0,
		esUpdate			= 1,
		esGenerate			= 2,
		esUpload			= 3,
		esCopyData			= 4,
		esImportData		= 5,
		esImportGlossary	= 7,
		esInternal			= 8,
		esMerge				= 9,
		esOther					= 10,
		esOpeningMainTab		= 11,
		esOpeningResEdTab		= 12,
		esSavingResEdChanges	= 13,
		esApplyingFilter		= 14,
		esOpeningEDB            = 15,
		NUM_STATES
	};

// Data
private:
	BOOL		m_fComplete;
	IDispatch * m_pdispCheckTree;
	IDispatch * m_pdispDescBox;
	IDispatch * m_pdispDlgGlosGrid;
	eState		m_nOperation;		// Current operation
	eState		m_nLastOperation;	// Previous operation

// Operations
public:
	eState GetState();
	eState GetLastState();
	BOOL SetState(eState state);
	BOOL StartState(eState state);  // Moves to state and not complete
	BOOL FinishState();				// Moves to idle and complete

	BOOL GetComplete();
	void SetComplete(BOOL fComplete = TRUE);

	// Functions to store the current CheckTree and DescBox.
	//
	// NOTE: These functions do not AddRef() the pointers assigned since they
	// should never hold onto the interface outside of the parent's lifetime.
	//
	IDispatch * GetCurrentCheckTree();
	IDispatch * GetCurrentDescBox();
	IDispatch * GetCurrentDlgGlosGrid();
	void SetCurrentCheckTree(IDispatch * pdisp);
	void SetCurrentDescBox(IDispatch * pdisp);
	void SetCurrentDlgGlosGrid(IDispatch * pdisp);
};


//
//  Sets a state on creation, calls FinishState on destruction
class LTAPIENTRY CEspStateObj
{
public:
	CEspStateObj(CEspState::eState);
	
	~CEspStateObj();

private:
	int foo;
};

	

#pragma warning(default: 4275)

LTAPIENTRY CEspState & GetEspState();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\espreg.h ===
//-----------------------------------------------------------------------------
//  
//  File: espreg.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Registry and version information for Espresso 2.x
//  
//-----------------------------------------------------------------------------
 

struct LocVersionInfo
{
	WORD    wVerMajor;
	WORD    wVerMinor;
	WORD    wVerBuild;
	CString strVerString;
};


LTAPIENTRY void NOTHROW GetVersionInfo(LocVersionInfo &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoUserSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoUserSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineKey(HKEY &);

LTAPIENTRY BOOL NOTHROW OpenEspressoMachineSubKey(HKEY &, const CLString &);

LTAPIENTRY BOOL NOTHROW EspressoMachineSubKeyExists(const CLString &);

LTAPIENTRY BOOL NOTHROW MyRegDeleteKey(HKEY &, const TCHAR *);

LTAPIENTRY void NOTHROW GetRegistryString(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\filedlg.h ===
//-----------------------------------------------------------------------------
//
// File: FileDlg.h
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------
 
#if !defined(__FileDlg_h__)
#define __FileDlg_h__

#pragma warning(disable : 4275)

class LTAPIENTRY CLFileDialog : public CFileDialog
{
	DECLARE_DYNAMIC(CLFileDialog)

public:
	CLFileDialog(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);

// Operations
public:
	CString GetFileFilter();

	virtual int DoModal();

// Attributes
public:
	virtual void SetOkButtonText(TCHAR const * const szOkText);
	virtual void SetOkButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCancelButtonText(TCHAR const * const szCancelText);
	virtual void SetCancelButtonText(HINSTANCE const hResourceDll,
			UINT const uStringId);

	virtual void SetCheckIfBufferTooSmall(BOOL const bCheckIfBufferTooSmall);

// Data
protected:
	CLString m_strOkButton;				// new OK button text for dialog
	CLString m_strCancelButton;			// new Cancel button text for dialog
	BOOL m_bCheckIfBufferTooSmall;		// should DoModal() checks condition?

// Implementation
protected:
	//{{AFX_MSG(CProjectOpenDlg)
    virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Implementation
protected:
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT * pResult);
};

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\fileexcldlg.h ===
//-----------------------------------------------------------------------------
//
// File: FileExclDlg.h
// Copyright (C) 1994-1997 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------
#if !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
#define AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_

#pragma warning(disable : 4275)
#pragma warning(disable : 4251)


class LTAPIENTRY CLFileExclDlg : public CLFileDialog
{
	DECLARE_DYNAMIC(CLFileExclDlg)

public:
	CLFileExclDlg(
		BOOL bOpenFileDialog = TRUE, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		LPCTSTR pszTitle = NULL);


	BOOL GetExclusivePref( ) const;

// Dialog Data
	//{{AFX_DATA(CLFileExclDlg)
	BOOL m_bExclusive;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLFileExclDlg)
    public:
    virtual int DoModal();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
	//{{AFX_MSG(CLFileExclDlg)
		// NOTE - the ClassWizard will add and remove member functions here.
    virtual BOOL OnInitDialog();
	afx_msg void OnClickChkExcl();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#pragma warning(default : 4275)
#pragma warning(default : 4251)


#endif // !defined(AFX_FILEEXCLDLG_H__A0269213_4B2B_11D1_9F0F_006008166DEA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\fieldval.inl ===
//-----------------------------------------------------------------------------
//  
//  File: FieldVar.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

inline
CColumnVal::CColumnVal()
{
	m_cvt = cvtNone;
}



inline
void
CColumnVal::SetString(
		const CPascalString &pas)
{
	m_cvt		= cvtString;
	m_pasString	= pas;
}



inline
void
CColumnVal::SetLong(
		long nValue)
{
	m_cvt	= cvtLong;
	m_long	= nValue;
}



inline
void
CColumnVal::SetDate(
		const COleDateTime &dt)
{
	m_cvt = cvtDate;
	m_Time = dt;
}



inline
void
CColumnVal::SetBool(
		BOOL b)
{
	m_cvt = cvtBool;

	m_bool = b;
}



inline
CColumnVal::CColumnVal(
		const CColumnVal &other)
{
	AssignFrom(other);
}



inline
CColumnVal::CColumnVal(
		const CPascalString &pas)
{
	SetString(pas);
}



inline
CColumnVal::CColumnVal(
		long nValue)
{
	SetLong(nValue);
}



inline
CColumnVal::CColumnVal(
		const COleDateTime &dt)
{
	SetDate(dt);
}



inline
CColumnVal::CColumnVal(
		BOOL b)
{
	SetBool(b);
}

		
		

inline
const CColumnVal &
CColumnVal::operator=(const CColumnVal &other)
{
	AssignFrom(other);
	
	return *this;
}



inline
void
CColumnVal::SetStringIndex(
		long idxValue)
{
	m_cvt	= cvtStringList;
	m_long	= idxValue;
}



inline
CColumnVal::ColumnValType
CColumnVal::GetType()
		const
{
	return m_cvt;
}



inline
const CPascalString &
CColumnVal::GetString()
		const
{
	LTASSERT(m_cvt == cvtString);
	return m_pasString;
}



inline
long
CColumnVal::GetLong()
		const
{
	LTASSERT(m_cvt == cvtLong);
	return m_long;
}



inline
const COleDateTime &
CColumnVal::GetDate()
		const
{
	LTASSERT(m_cvt == cvtDate);
	return m_Time;
}



inline
BOOL
CColumnVal::GetBool()
		const
{
	LTASSERT(m_cvt == cvtBool);
	return m_bool;
}



inline
long
CColumnVal::GetStringIndex()
		const
{
	LTASSERT(m_cvt == cvtStringList);
	return m_long;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\globals.h ===
//-----------------------------------------------------------------------------
//  
//  File: globals.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#include "resource.h"
 
extern HINSTANCE g_hLocUtilDll;

void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\flddeflist.h ===
//-----------------------------------------------------------------------------
//  
//  File: flddeflist.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CColumnDefinition;

//------------------------------------------------------------------------------
class LTAPIENTRY CColDefList : public CTypedPtrList<CPtrList, CColumnDefinition *>
{
// Construction
public:
	CColDefList();
	CColDefList(const CColDefList &);
	
	~CColDefList();

// Operations
public:
	BOOL FindColumnDefinition(long nSearchID, const CColumnDefinition * & pFoundColDef) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

#pragma warning(default : 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\fielddef.h ===
//******************************************************************************
//  
//  FieldDef.h:	Common Column Definitions
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//******************************************************************************
 
#pragma once

#pragma warning(disable:4275)  // Exported classes

//------------------------------------------------------------------------------
struct LTAPIENTRY COLUMN_STRING_ENTRY
{
// Construction
public:
	COLUMN_STRING_ENTRY();
	COLUMN_STRING_ENTRY(const COLUMN_STRING_ENTRY & entry);

// Data
public:
	CLString	st;				// Display String
	long		nID;			// User value (unique ID)

// Operations
public:
	const COLUMN_STRING_ENTRY & operator=(const COLUMN_STRING_ENTRY & entry);
};

typedef CArray<COLUMN_STRING_ENTRY, COLUMN_STRING_ENTRY&> CColStrEntryArray;

//------------------------------------------------------------------------------
class LTAPIENTRY CColumnStrList : public CLocThingList<COLUMN_STRING_ENTRY>
{
// Operations
public:
	BOOL FindDisplayName(long nID, CLString & stName) const;
	BOOL FindID(const CLString &stName,long &nID) const;
};

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added m_pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
class LTAPIENTRY CColumnDefinition : public CRefCount
{
public:
	CColumnDefinition(const WCHAR * pszInternalName, long nID,
			const CLString &strName, const CLString &strHelp,
			CColumnVal::ColumnValType vt, Operators ops,
			BOOL fDisplayable, BOOL fSortable, BOOL fReadOnly,
			PFNVALIDATE pfnValidateFunc);

	void SetStringList(const CColumnStrList & lstColumnStr);
	
	const CPascalString & GetInternalName() const;
	long GetID() const;
	const CLString & GetDisplayName() const;
	const CLString & GetHelpText() const;
	BOOL IsDisplayable() const;
	BOOL IsSortable() const;
	BOOL IsReadOnly() const;
	
	CColumnVal::ColumnValType GetColumnType() const;
	Operators GetOperators() const;

	const CColumnStrList & GetStringList() const; 

	BOOL Validate (LPCTSTR lpsz, DWORD dw) const;

	
private:
	CPascalString	m_pasInternalName;	// Unique String ID
	long		m_nID;				// Unique Number ID (can be any number)
	CLString	m_strDisplayName;	// Displayed name
	CLString	m_strHelpText;		// Description of column
	CColumnVal::ColumnValType m_vt;	// Type of data
	Operators	m_ops;				// Valid filtering operations
	BOOL		m_fDisplayable;		// Column is displayable
	BOOL		m_fSortable;		// Column is sortable
	BOOL		m_fReadOnly;		// Column is read-only
	PFNVALIDATE	m_pfnValidateFunc;	// Pointer to column value validation func

	CColumnStrList m_lstColumnStr;
};


//------------------------------------------------------------------------------
// CEnumIntoColStrList provides a method of enumerating directly into a list of
// COLUMN_STRING_ENTRY's.
//
class LTAPIENTRY CEnumIntoColStrList : public CEnumCallback
{
// Construction
public:
	CEnumIntoColStrList(CColumnStrList & lstColStr, BOOL fLock = TRUE);
	~CEnumIntoColStrList();

// CEnumCallback implementation
public:
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CColumnStrList & m_lstColStr;
	BOOL	m_fLock;				// Lock list when finished
};


//------------------------------------------------------------------------------
class LTAPIENTRY CColDefUtil
{
// Operations
public:
	static void FillBool(CButton * pbtn, BOOL fValue = TRUE);	
	static void FillBool(CListBox * plbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	
	static void FillBool(CComboBox * pcbc, BOOL fValue = TRUE, BOOL fEmpty = TRUE);	

	static void FillStringList(CListBox * plbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);	
	static void FillStringList(CComboBox * pcbc, const CColumnStrList & lstColStr,
			long idSelect = -1, BOOL fEmpty = TRUE);


	//------------------------------------------------------------------------------
	class LTAPIENTRY CColDefCB : public CObject
	{
	public:
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CCheckBoxCB : public CColDefCB
	{
	public:
		CCheckBoxCB(CButton * pbtn);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CButton * const m_pbtn;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CListBoxCB : public CColDefCB
	{
	public:
		CListBoxCB(CListBox * plbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CListBox * const m_plbc;
	};


	//------------------------------------------------------------------------------
	class LTAPIENTRY CComboBoxCB : public CColDefCB
	{
	public:
		CComboBoxCB(CComboBox * pcbc);
		virtual int AddItem(const CLString & stName, long nID);
		virtual void SetCurSel(long nSelect);
		virtual void FillBool(BOOL fValue = TRUE, BOOL fEmpty = TRUE);
		virtual void FillStringList(const CColumnStrList & lstColStr, long idSelect = -1, BOOL fEmpty = TRUE);
		virtual void Empty();

#ifdef _DEBUG
		virtual void AssertValid() const;
#endif

	protected:
		CComboBox * const m_pcbc;
	};
};

LTAPIENTRY int AddListBoxItem(CListBox * plbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, const CLString & stAdd, DWORD dwItemData);
LTAPIENTRY int AddListBoxItem(CListBox * plbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);
LTAPIENTRY int AddComboBoxItem(CComboBox * pcbc, HINSTANCE hDll, UINT nStringID, DWORD dwItemData);

LTAPIENTRY void GetBoolValue(BOOL fValue, CLString & stValue);

#pragma warning(default:4275)  // Exported classes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\flddefhelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: flddefhelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

// RAID:  LS42 Bug 46 fixed by MikeL
// Pointer to a function to allow each column
// type to have its own validation function.
typedef BOOL (* PFNVALIDATE) (LPCTSTR, DWORD);

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validation function.
//------------------------------------------------------------------------------
struct SBasicColumn
{
	const WCHAR *szInternalName;
	long nID;
	UINT IDSName;
	UINT IDSHelp;
	CColumnVal::ColumnValType vt;
	Operators ops;
	BOOL fDisplay;
	BOOL fSort;
	BOOL fReadOnly;
	PFNVALIDATE pfnValidateFunc;
};


struct SStringListColumn
{
	SBasicColumn sBasic;
	UINT IDSStringList;
};


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CColDefHelper : public CObject
{
public:
	CColDefHelper(HINSTANCE h);

	void SetBasicColumns(const SBasicColumn * pBasic, UINT nCntBasic);
	void SetStringColumns(const SStringListColumn * pStrings, UINT nCntStrings);
	
	CTableSchema * CreateSchema(const SchemaId &, UINT IDSDescription);
	
private:
	HINSTANCE				 m_hInst;
	const SBasicColumn *	 m_pBasicColumns;
	const SStringListColumn *m_pStringColumns;
	UINT					 m_uiBasicCount;
	UINT					 m_uiStringCount;
};


#pragma warning(default : 4275)

const TCHAR COL_PICK_SEPARATOR = _T('\n');

#define BEGIN_BASIC_COLUMN_DEFS(var) \
const SBasicColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define BASIC_COLUMN_DEF_ENTRY(name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc) \
	{name, nID, IDSName, IDSHelp, cvt, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc}

#define END_BASIC_COLUMN_DEFS() \
}

#define BEGIN_STRING_LIST_COLUMN_DEFS(var) \
const SStringListColumn var[] = \
{

// RAID:  LS42 Bug 46 fixed by MikeL
// Added pfnValidateFunc to allow each column
// type to have its own validate function.
#define STRING_LIST_COLUMN_ENTRY(name, nID, IDSName, IDSHelp, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc, IDSList) \
	{ { name, nID, IDSName, IDSHelp, CColumnVal::cvtStringList, ops, fDisplay, fSort, fReadOnly, pfnValidateFunc }, IDSList}

#define END_STRING_LIST_COLUMN_DEFS() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\fieldval.h ===
//-----------------------------------------------------------------------------
//  
//  File: FieldVal.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma warning(disable : 4251)
class LTAPIENTRY CColumnVal
{
public:
	CColumnVal();
	explicit CColumnVal(const CColumnVal & val);
	explicit CColumnVal(const CPascalString & pasValue);
	explicit CColumnVal(long nValue);
	explicit CColumnVal(const COleDateTime & dateValue);
	explicit CColumnVal(BOOL fValue);
	
	enum ColumnValType
	{
		cvtNone,
		cvtString,
		cvtLong,
		cvtDate,
		cvtBool,
		cvtStringList,
		cvtLocTerm
	};

	void Serialize(CArchive &);
	
	const CColumnVal & operator=(const CColumnVal & val);
	void SetString(const CPascalString & pasValue);
	void SetLong(const long nValue);
	void SetDate(const COleDateTime & dateValue);
	void SetBool(const BOOL fValue);
	void SetStringIndex(const long nValue);
	
	ColumnValType GetType() const;
	const CPascalString &GetString() const;
	long GetLong() const;
	const COleDateTime & GetDate() const;
	BOOL GetBool() const;
	long GetStringIndex() const;
	
	int operator==(const CColumnVal &);
	int operator!=(const CColumnVal &);
	
#ifdef LTASSERT_ACTIVE
	void AssertValid(void) const;
#endif
	
private:
	BOOL Compare(const CColumnVal & valCompare);
	void AssignFrom(const CColumnVal & valSrc);
	
	ColumnValType m_cvt;
	
	union
	{
		long m_long;
		BOOL m_bool;
	};
	CPascalString m_pasString;
	COleDateTime m_Time;
};

typedef CColumnVal CCV;

#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "FieldVal.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\goto.h ===
//-----------------------------------------------------------------------------
//  
//  File: goto.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

class LTAPIENTRY CGoto : public CRefCount
{
public:
	CGoto()	{};
	
	virtual void Edit() = 0;
	virtual BOOL Go() = 0;


private:
	CGoto(const CGoto &);
	
};

#pragma warning(disable:4251)

class LTAPIENTRY CShellGoto : public CGoto
{
public:
	CShellGoto(const TCHAR *szFileName);

	virtual void Edit();
	virtual BOOL Go();

private:

	CLString m_strFileName;
};

#pragma warning(default:4251)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\gotohelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: gotohelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
class LTAPIENTRY CGotoHelp : public CRefCount
{
public:
	virtual void Edit() = 0;
	
	virtual BOOL GotoHelp() = 0;
	
};



class LTAPIENTRY CEspGotoHelp : public CGotoHelp
{
public:
	explicit CEspGotoHelp(UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	UINT m_uiHelpId;
};


class LTAPIENTRY CExternalGotoHelp : public CGotoHelp
{
public:
	CExternalGotoHelp(const TCHAR *szFileName, UINT uiHelpId);

	virtual void Edit();
	virtual BOOL GotoHelp();

private:
	CLString m_strFileName;
	UINT m_uiHelpId;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Various public interfaces in Espresso.
//  
//-----------------------------------------------------------------------------
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: locenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//------------------------------------------------------------------------------
class LTAPIENTRY CStringType
{
public:
	//
	//  This order is important - if must change it, make sure you make the
	//  corresponding changes in GetTypeName() and GetTypeTLA()!
	//  All new values must be added TO THE END, or you will break old
	//  parsers...
	//
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumStringType.h"
	
	static int DefaultValue;
	NOTHROW static const TCHAR * GetTypeName(CStringType::StringType);
	NOTHROW static const TCHAR * GetTypeTLA(CStringType::StringType);
	static void Enumerate(CEnumCallback &);
	static const CStringType::StringType GetStringType(const TCHAR * tChIn);
	static const TCHAR * GetDefaultStringTypeText();
	static const CStringType::StringType GetDefaultStringType();
	static bool IsValidStringType(const CStringType::StringType &nIn);
	static bool IsValidStringType(const TCHAR * tChIn);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CStringType();

	//
	//  Used to store the info about each element in the enum...
	//
	struct StringTypeInfo
	{
		TCHAR szTLA[4];
		const TCHAR * szName;
	};

	static const StringTypeInfo m_Info[];
};

typedef CStringType CST;


//------------------------------------------------------------------------------
class LTAPIENTRY CPlatform
{
public:
	// NOTE: These #include files define an enumeration.  They MUST be inside this
	// class definition.
	//
#include "PreCEnum.h"
#include "EnumPlatform.h"
	
	NOTHROW static const TCHAR * GetPlatformName(CPlatform::Platform);
	static void Enumerate(CEnumCallback &);
	static const CPlatform::Platform CPlatform::GetPlatformType(const TCHAR * tChplat);
	static const TCHAR * GetDefaultPlatformText();
	static const CPlatform::Platform GetDefaultPlatform();
	static bool IsValidPlatform(const CPlatform::Platform &nIn);
	static bool IsValidPlatform(const TCHAR * tChplat);
	
private:
	static int DefaultValue;
	COSPlatform();
	static const TCHAR * const m_szPlatformNames[];
};


//------------------------------------------------------------------------------
class LTAPIENTRY CLocApprovalState
{
public:
	enum ApprovalState
	{
		Invalid = 0,
		Old_Pending,					// OBSOLETE! Do Not Use!
		Approved,
		PreApproved,
		NotReady,
		Failed,
		ForResearch,
		NotApplicable
	};
	static ApprovalState DefaultValue;
	NOTHROW static const TCHAR * GetApprovalText(CLocApprovalState::ApprovalState);
	static void Enumerate(CEnumCallback &);
	static const CLocApprovalState::ApprovalState GetApprovalState(const TCHAR * );
	static const TCHAR * GetDefaultApprovalText();
	static const CLocApprovalState::ApprovalState GetDefaultApprovalState();
	static BOOL IsValidApprovalState(const CLocApprovalState::ApprovalState &nIn);
	static BOOL IsValidApprovalState(const TCHAR * );
	
private:
	struct SStateName
	{
		ApprovalState as;
		const TCHAR *szName;
	};
	
	static const SStateName m_aStateNames[];
	CLocApprovalState();
};

typedef CLocApprovalState CAS;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocAutoApproved
{
// Operations
public:
	enum AutoApproved
	{
		Invalid = 0,
		No,
		Partial,
		Yes,
		NotApplicable
	};

	NOTHROW static TCHAR const * GetAutoApprovedText(AutoApproved const aa);
	static void Enumerate(CEnumCallback & cbEnumCallback);
	static AutoApproved const GetAutoApproved(TCHAR const * const tChIn);
	static TCHAR const * GetDefaultAutoApprovedText();
	static AutoApproved const GetDefaultAutoApproved();
	static bool IsValidAutoApproved(AutoApproved const nIn);
	static bool IsValidAutoApproved(TCHAR const * tChIn);
	
// Construction
private:
	// prevent constructing, copying and assigning
	CLocAutoApproved();
	CLocAutoApproved(CLocAutoApproved const &);
	CLocAutoApproved const & operator=(CLocAutoApproved const &);

// Member Variables
private:
	static TCHAR const * const m_szAutoApprovedNames[];
	static AutoApproved const DefaultValue;
};

typedef CLocAutoApproved CAA;


//------------------------------------------------------------------------------
class LTAPIENTRY CLocTranslationOrigin
{
public:
	enum TranslationOrigin
	{
		Invalid = 0,
		New,
		Uploaded,
		AutoTranslated,
		Copied,
		PreviousVersion,
		NotApplicable
	};

	NOTHROW static const TCHAR * GetOriginText(CLocTranslationOrigin::TranslationOrigin);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szOriginNames[];
	CLocTranslationOrigin();
};

typedef CLocTranslationOrigin CTO;

class LTAPIENTRY COutputTabs
{
public:
	enum OutputTabs
	{
		File,
		Test,
		Messages,
		Update,
		Utility,
		GlobalErrorBox,
		OutputMax
	};

	static void Enumerate(CEnumCallback &);
	
private:
	static const UINT m_nStateNames[];
	COutputTabs();
};



class LTAPIENTRY CValidationCode
{
public:
	enum ValidationCode
	{
		NotHandled,			// for sub-parser use ONLY
		NoError,
		Warning,
		Error
	};

	NOTHROW static ValidationCode UpgradeValue(ValidationCode OldValue,
			ValidationCode NewValue);
	
private:
	CValidationCode();
};

typedef CValidationCode CVC;


//------------------------------------------------------------------------------
class LTAPIENTRY CValidationOptions
{
public:
	CValidationOptions();
	
	enum ValidationOption
	{
		CheckDBCSHotKeyPos = 0,
		CheckDBCSHotKeyChar,
		CheckRemovedHotKey,
		CheckAddedHotKey,
		CheckHotKeyPosition,
		CheckRemovedAccelerator,
		CheckReorderableParams,
		CheckPrintf,
		CheckBlankTarget,
		CheckBlankSource,
		CheckNewLineCount,
		CheckChangedTerminator,
		CheckLeadingPunctuation,
		CheckTrailingPunctuation,
		CheckLeadingSpaces,
		CheckTrailingSpaces,
		CheckTranslationSize,
		CheckNULChanges,
		CheckCharsInCodePage,
		//
		//  Internal value, DO NOT USE
		//
		END_MARKER
	};

	static void Enumerate(CEnumCallback &);
	NOTHROW static void GetText(ValidationOption, CLString &);
	NOTHROW static void GetLongText(ValidationOption vo, CLString &strText);

	NOTHROW void SetFlag(ValidationOption, BOOL);
	NOTHROW BOOL GetFlag(ValidationOption) const;
	NOTHROW const CValidationOptions & operator=(const CValidationOptions &);
	
private:
	DWORD dwFlags;
};

typedef CValidationOptions CVO;


//------------------------------------------------------------------------------
class LTAPIENTRY CAmpKeyword
{
public:
	enum AmpKeyword
	{
		amp = 0,
		lt,
		gt,
	};
	
	static const WCHAR * GetValue(CAmpKeyword::AmpKeyword);
	static unsigned int GetValueLength(CAmpKeyword::AmpKeyword);
	static WCHAR GetEquivalentChar(CAmpKeyword::AmpKeyword);
	static int FindAmpKeyword(const WCHAR * pwszStr, unsigned int nPos);
	
private:
	//
	//  Nobody should actually CONTRUCT one of these.
	//
	CAmpKeyword();

	//
	//  Used to store the info about each element in the enum...
	//
	struct SAmpKeyword
	{
		const WCHAR * m_wszValue;
		WCHAR m_chEquivalentChar;
	};

	static const SAmpKeyword m_aAmpKeywords[];
	static const int m_nNumAmpKeywords;
};

typedef CAmpKeyword CAK;


//------------------------------------------------------------------------------
// CEnumIntoPasStrList provides a method of enumerating directly into a list of
// CPascalString's.
//
// ASSUMPTIONS:
// 1.  Enumerators will send data in proper increasing order
// 2.  No gaps in indicies.
//
class LTAPIENTRY CEnumIntoPasStrList: public CEnumCallback
{
// Construction
public:
	CEnumIntoPasStrList(CPasStringList & lstPasStr, BOOL fLock = TRUE);
	~CEnumIntoPasStrList();

// CEnumCallback implementation
public:
	virtual void SetRange(UINT nStart, UINT nFinish);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CPasStringList & m_lstPasStr;
	UINT	m_nStart;				// Start of range
	UINT	m_nFinish;				// End of range
	UINT	m_nCurrent;				// Check of current item TO retrieve
	BOOL	m_fLock;				// Lock list when finished
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locobj.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locobj.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Mother object constructor.  Does nothing, since for now we rely on
//  AFX CObject to do the work for us.
//  
//-----------------------------------------------------------------------------
inline
CLObject::CLObject()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locpct.h ===
//-----------------------------------------------------------------------------
//  
//  File: LOCPCT.H
//  
//  Declarations for CLocPercentFrame and CLocPercentHelper
//
//  Author:  kenwal
//
//  Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
//  
//-----------------------------------------------------------------------------

#ifndef LOCUTIL__LocPct_H__INCLUDED
#define LOCUTIL__LocPct_H__INCLUDED

// Classes in this header file
class CLocPercentHelper;
class CLocPercentFrame;

//
// The CLocPercentHelper class can help in building acurate
// percentage complete messages for complicated processes.
//
// Here is how the CLocPercentHelper works.
//
// The CLocPercentHelper class deals with "frames" of work.  Each frame
// is 100% of a unit of work.  A CLocPercentHelper will always
// start off with 1 frame.  If you want to use these functions
// you first need to call PercentSetUnits passing a number that will
// represent 100% complete.  For example if you need to process 4 items
// you could set this to 4.  After you process each item you would
// call PercentAddValue.  Correct status messages would be sent
// indicating you are 1/4, 2/4, 3/4, and 4/4 done.

// This processing comes in handy when you break up the work
// in sub functions, or "frames" of work.  Each function only 
// knows about what it needs to do.  

// Say in the resource example you call a function to handle each
// resource.  Each time the handler is called it is given 1/4 
// of the total time.  The handler can break up its time however 
// it likes without knowing how much total time there is.  

// Say the sub function needs to do 10 things.  It calls PercentSetUnits(10).
// It then calls PercentAddValue as each of the 10 things are
// accomplished.  The total percent will reflect that 100% of this
// sub function is really only 1/4 of the total percent.  The sub function
// only needs to worry about what it knows it has to do.  
// The sub function can assign part of its work to other functions
// by creating frames for them.  There is no limit to the number
// of frames.
// 

// Override the virtual function void OnSendPercentage(UINT nPct) 
// in your subclass of CLocPercentHelper to do what you want
// with the percent calculated from the helper.

// Example:

/*

	CLocPercentHelper pctHelp;
	pctHelp.PercentSetUnits(4); //assume 4 items to process
	
	do
	{
		pctHelp.PercentPushFrame(1); //Set up a new Frame equal
		                             //to 1 of my units of work.
									 //In this case 1/4 of the
									 //total time.
									 
									 //All of the Percent... functions
									 //called made now deal with
									 //this new frame.
		
		HandleItem(pctHelp);
		
		pctHelp.PersentPopFrame();	 //Remove the frame created
		                             //and mark the amount 
									 //of time it was equal to
									 //completed.
									 
	  
	}
	while (more items)
	  
-----------------------------------------------------------------------

  HandleItem(CLocPercentHelper& pctHelp) function
  
	pctHelp.PercentSetUnits(10);  //Assume this is a dialog resource
	                              //with 10 controls.  
								  //This function divides up 
								  //the work it needs to do in
								  //a way that makes sence for it.
								  //
								  //When this "frame" is at 100%
								  //the total percentage is still
								  //just 1/4 of the total time
								  //since this frame was given 1/4
								  //of the total time from the caller.
								  
  
	do
	{
					
		// This function can assign part of its processing 
		// to another function by calling PercentPushFrame also.
		
		HandleControl();
		pctHelp.PercentAddValue();	//Send a message to the 
		                            //handler indicating the 
									//current percentage.
									//The object will calculate
									//the total percent based on 
									//the current stack of frames.
	}
	
	while (more controls)  
		
		  
			
*/



//
// CLocPercentFrame represents a working unit of progress.  
// The progress model implemented with the CLocPercentHelper will
// support unlimited levels of work units.  
//
// This class is a helper class used only by CLocPercentHelper
//


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocPercentFrame : public CObject
{
	friend CLocPercentHelper;

protected:
	CLocPercentFrame();
	CLocPercentFrame(CLocPercentFrame* pParent, UINT nValueInParent);
	
	void SetComplete();
	// Force this frame to represent 100%. 
	
	void AddValue(UINT nValue);
	// Add nValue to the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetValue(UINT nValue);
	// Set the internal value.
	// The internal value will never be greater than
	// the internal units.
	
	void SetUnits(UINT nUnits);
	// Set the internal units
	
	UINT m_nUnits;			     //Number that represents 100%
	UINT m_nValue;          	 //Number that represent how far done
	                             //this frame is.
	
	CLocPercentFrame* m_pParent;	 //Pointer to the parent frame
	UINT m_nValueInParent;       //How much this frame is worth
	                             //in the parents context.
	
	void MemberInit();			 
	// Initialize member values 
};

//
// List of frames in the helper
//

class LTAPIENTRY CLocPercentFrameList : public CTypedPtrList<CPtrList, CLocPercentFrame*>
{
};


class LTAPIENTRY CLocPercentHelper : public CObject
{
public:
	
	CLocPercentHelper();

	virtual ~CLocPercentHelper();
	
	void PercentSetUnits(UINT nUnits, BOOL bReport = FALSE);
	// Set the units of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentSetValue(UINT nValue, BOOL bReport = TRUE);
	// Set the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.

	void PercentAddValue(UINT nValue = 1, BOOL bReport = TRUE);
	// Add nValue to the value of the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetComplete(BOOL bReport = TRUE);
	// Set the current frame complete.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentForceAllComplete(BOOL bReport = TRUE);
	// Force all frames complete.
	// Calculate and report 100% done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentPushFrame(UINT nValueInParent = 1);
	// Create a new frame and assign in nValueInParent 
	// All Percent... calls made after this call deal with
	// the new frame.  
	
	void PercentPopFrame(BOOL bReport = TRUE);
	// Set the current frame complete and add the current
	// frames valueInParent to its parent frame. 
	// The current frames parent is now the current frame.
	// Calculate and report the total % done through 
	// OnSendPercentage if bReport is TRUE.
	
	void PercentSetStrict(BOOL bOnOff = TRUE);
	// Strict behavior means the helper will ASSERT (_DEBUG only) if 
	// the calculated percent is over 100%.  This can happen
	// if the unit values assigned to frames are not truly what 
	// the process does.  If you are unable to set acurate
	// unit values and the program quesses, you can turn
	// strict off.
	
	BOOL PercentIsStrict();
	// Return TRUE or FALSE if strict is on.
	
protected:

	// Support for Progress Reporting
	CLocPercentFrame m_FrameMain;	        //The main frame always 
	                                    //present.  This frame
	                                    //will never have a parent.
	
	CLocPercentFrameList m_FrameList;      //List of open frames.
	
	CLocPercentFrame* m_pCurrentFrame;     //Pointer to the current
	                                    //frame
	
	BOOL m_bStrict;						//Strict on will ASSERT if 
										//total % gets over 100
	
	
	void SendPercentage();
	// Calculates the percentage based on the current frame
	// Calles OnSendPercentage with the calulated value.
	
	void SafeDeleteFrame(CLocPercentFrame* pFrame);
	// Safely deletes a frame making sure the pFrame is 
	// not m_FrameMain.
	
	virtual void OnSendPercentage(UINT nPct);
	// Callback function for subclasses to do what they
	// want with the percentage.  Default implementation
	// does nothing.
 	
};

#pragma warning(default: 4275)

//
// Helper class with a CProgressiveObject
//
class LTAPIENTRY CLocPctProgress : public CLocPercentHelper
{
public:
	CLocPctProgress();
	CLocPctProgress(CProgressiveObject* pProgObj);

	void SetProgressiveObject(CProgressiveObject* pProgObj);

protected:
	virtual void OnSendPercentage(UINT nPct);

	CProgressiveObject* m_pProgObj;
};

#endif // LOCUTIL__LocPct_H__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locobj.h ===
//-----------------------------------------------------------------------------
//  
//  File: locobj.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Defines the mother of all classes for the Espresso 2.0 project.  For now,
//  this just devolved to CObject.  We define it just in case we decide to
//  implement our own mother of all classes.
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCOBJ_H
#define LOCOBJ_H


//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CObject is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CLObject : public CObject
{
public:
	CLObject();

	virtual void AssertValid(void) const;

	virtual void Serialize(CArchive &ar);

	virtual UINT GetSchema(void) const;
	
	virtual ~CLObject();

protected:

private:
};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locobj.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locstr.h ===
//-----------------------------------------------------------------------------
//  
//  File: locstr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Definition of a localizable string.  The following classes are defined:
//      CLocString - all the operations we can do on a localizable string.
//  
//-----------------------------------------------------------------------------
 

#ifndef LOCSTR_H
#define LOCSTR_H


interface ILocStringValidation;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocString : public CObject
{
public:
	NOTHROW CLocString();

	void AssertValid(void) const;
	
	//
	//  Information about the localizable string...
	//
	NOTHROW BOOL HasHotKey(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	
	NOTHROW int operator==(const CLocString &) const;
	NOTHROW int operator!=(const CLocString &) const;
	//
	//  Some useful assigment operators.
	//
 	NOTHROW void SetString(const CPascalString&);
	NOTHROW void SetHotKeyChar(WCHAR);
	NOTHROW void SetHotKeyPos(UINT);
	NOTHROW void ClearHotKey(void);
	NOTHROW void SetNote(const CPascalString &);
	
	// Conversion from/to Windows hot key strings
	// This is also the format used to display strings in edit mode
	NOTHROW int ParseString(const CPascalString & pasStr, WORD langId);
	NOTHROW void ComposeString(CPascalString & pasStr, WORD langId) const;


	NOTHROW CST::StringType GetStringType(void) const;
	NOTHROW CodePageType GetCodePageType(void) const;
	NOTHROW void SetStringType(CST::StringType);
	NOTHROW void SetCodePageType(CodePageType);


	// Conversion from/to displayable string in the resource table.
	void GetDisplayLString(CLString &strDest, LangId langId);
	void GetDisplayPString(CPascalString &strDest, LangId langId, BOOL bReplaceMetaCharacters);
	void GetEditableString(CLString &strDest, LangId langId);
	int ParseEditableString(const CLString &strSrc, LangId langId, CString &strErr);
	int ParseEscapeChar(BOOL bSetHotkeyPos, CPascalString &strErr);
	int ParseAmpersand(LangId langId,BOOL bSetHotkeyPos,CPascalString &strErr);
	
	NOTHROW const CLocString& operator=(const CLocString&);
	
	NOTHROW ~CLocString();

protected:

private:

	//
	//  Private implementation functions.
	//
	NOTHROW void CopyLocString(const CLocString &);
	virtual void Serialize(CArchive &) {}
	
	//
	//  Prevents the default copy constructor from being called.
	//
	CLocString(const CLocString&);

	CPascalString m_pasBaseString;
	CST::StringType m_stStringType;
	WCHAR m_wchHotKeyChar;
	UINT m_uiHotKeyPos;
	CodePageType m_cptCodePageType;		 //  cpAnsi
	CPascalString m_pstrNote;
};



class LTAPIENTRY CLocTranslation : public CObject
{
public:
	CLocTranslation();
	CLocTranslation(const CLocTranslation &);
	CLocTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);

	NOTHROW int operator==(const CLocTranslation &) const;
	NOTHROW int operator!=(const CLocTranslation &) const;

	void AssertValid(void) const;

	NOTHROW void SetTranslation(const CLocString &Source, LangId lidSource,
			const CLocString &Target, LangId lidTarget);
	NOTHROW void SetNote(const CPascalString &);
	NOTHROW void CalculateRanking(const CLocString &);
	
	NOTHROW const CLocString & GetSourceString(void) const;
	NOTHROW const CLocString & GetTargetString(void) const;
	NOTHROW const CPascalString & GetNote(void) const;
	NOTHROW UINT GetRanking(void) const;
	NOTHROW LangId GetSourceLanguage(void) const;
	NOTHROW LangId GetTargetLanguage(void) const;
	
	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &) const;

	NOTHROW CVC::ValidationCode ValidateTranslation(
			const CValidationOptions &, BOOL,
			const CLString &, CReport *, CGoto *) const;
	
	NOTHROW const CLocTranslation & operator=(const CLocTranslation &);
	
	~CLocTranslation();

private:
	NOTHROW void CopyTranslation(const CLocTranslation &);

	NOTHROW void ReordBuildSig(const CLocString &, CPascalString *) const;
	NOTHROW void PrintfBuildSig(const CLocString &, CPascalString &) const;
	NOTHROW int ReplaceableLength(const CPascalString &, UINT) const;
	
	CLocString      m_lsSource;
	LangId          m_lidSource;
	CLocString      m_lsTarget;
	LangId          m_lidTarget;
	CPascalString   m_pstrGlossaryNote;
	UINT            m_uiRanking;
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locstr.inl"
#endif


#endif //LOCSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\logfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: logfile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_LOGFILE_H
#define LOCUTIL_LOGFILE_H


class LTAPIENTRY CLogFile
{
public:
	CLogFile();
	
	virtual void IssueMessage(const CLString &strFileName, const CLString &strItemId,
			const CLString  &strChange, UINT uiChangeId,
			const CLString &strDetails, CGoto *, CGotoHelp *) = 0;
	
	virtual ~CLogFile();
	

private:
	CLogFile(const CLogFile &);
	const CLogFile &operator=(const CLogFile &);
};



CLString LTAPIENTRY GetLogFileName(const TCHAR *szProjectPath,
		const TCHAR *szAddOn, const TCHAR *szExtension);

#include "logfile.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\passtrmerge.h ===
//-----------------------------------------------------------------------------
//
// File: PasStrMerge.h
// Copyright (C) 1994-1998 Microsoft Corporation
// All rights reserved.
//
// Declaration of a class which handles the merge of two Pascal strings.
//
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_PasStrMerge_h_INCLUDED
#define LOCUTIL_PasStrMerge_h_INCLUDED


class LTAPIENTRY CPascalStringMerge
{
public:
	static BOOL NOTHROW Merge(CPascalString &, const CPascalString &);

	static BOOL NOTHROW Merge(CPascalString & pasDestination,
			CPascalString const & pasSource, UINT const nMaxLength,
			CReport * const pReport, CLString const & strContext,
			CGoto * const pGoto = NULL);

private:
	static BOOL NOTHROW IsParagraph(const CPascalString &, const CPascalString &);

};


#endif	// #ifndef LOCUTIL_PasStrMerge_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\operator.h ===
//-----------------------------------------------------------------------------
//  
//  File: operator.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

typedef UINT Operators;


class LTAPIENTRY CColumnOp
{
public:
	enum Operator
	{
		None   = 0,
		EQ 	   = 0x00000001,
		NOTEQ  = 0x00000002,
		GT     = 0x00000004,
		LT     = 0x00000008,
		LTEQ   = 0x00000010,
		GTEQ   = 0x00000020,
		WITHIN = 0x00000040,
		BEYOND = 0x00000080,

		CONTAINS     = 0x00000100,
		CONTAINSWORD = 0x00000200,
		STARTWITH    = 0x00000400,
		ENDWITH      = 0x00000800,
	};

	typedef CList<Operator, Operator> COperatorList;

	static CLString GetText(Operator);
	static void GetOperators(const Operators, COperatorList &);


private:
	CColumnOp();
};

typedef CColumnOp CCO;

const Operators NoOps = 0;
const Operators NumericOps = CCO::EQ | CCO::NOTEQ | CCO::GT | CCO::LT;
const Operators SimpStrOps = CCO::EQ | CCO::NOTEQ | CCO::STARTWITH | CCO::ENDWITH;
const Operators CompStrOps = CCO::CONTAINS | CCO::CONTAINSWORD;
const Operators StringOps  = SimpStrOps | CompStrOps;
const Operators StrListOps = CCO::EQ | CCO::NOTEQ;
const Operators DateOps    = CCO::LT | CCO::GT | CCO::EQ | CCO::NOTEQ | CCO::WITHIN | CCO::BEYOND;
const Operators BooleanOps = CCO::EQ | CCO::NOTEQ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\logfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: logfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
CLogFile::CLogFile()
{}



inline
CLogFile::~CLogFile()
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\lstime.h ===
//-----------------------------------------------------------------------------
//  
//  File: lstime.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
VOID
LTAPIENTRY GMTTimeToLocalTime(COleDateTime &);


VOID
LTAPIENTRY LocalTimeToGMTTime(COleDateTime &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\locstr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locstr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the CLocString object.  This file is included by
//  locstr.h, and should never be used directly.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return the 'generic' type of the string.  
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocString::GetStringType(void)
		const
{
	if (!m_pasBaseString.IsNull())
	{
		return m_stStringType;
	}
	else
	{
		return CST::None;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'Base' string.  This is the localizable string, 
//  It is the part that weighs most heavily in auto-translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetString(void)
		const
{
	return m_pasBaseString;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
CodePageType
CLocString::GetCodePageType(void)
		const
{
	return m_cptCodePageType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocString::GetNote(void)
		const
{
	return m_pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the string type.  The parser and database are the only people who
//  should be setting this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetStringType(
		CST::StringType newType)
{ 
	m_stStringType = newType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the 'Base' string.
//
//  This method can throw the following exceptions:
//      CMemoryException
//
//-----------------------------------------------------------------------------
inline
void
CLocString::SetString(
		const CPascalString &pstrNewBaseString)
{
	m_pasBaseString = pstrNewBaseString;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the code page type for the string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetCodePageType(
		CodePageType cptNew)
{
	m_cptCodePageType = cptNew;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears out the hot-key to an uninitialized state.
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::ClearHotKey(void)
{
	m_wchHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  See if the hotkey has any info in it.  Checks to see if the hotkey is
//  a valid character (ie non-zero).
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if it contains a hotkey
CLocString::HasHotKey(void)
		const
{
	return (m_wchHotKeyChar != L'\0');
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character.  If the hot-key is not initialized, this
//  returns NUL.
//  
//-----------------------------------------------------------------------------
inline
WCHAR									// Hot key character.
CLocString::GetHotKeyChar(void)
		const
{
	return m_wchHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key position.  Interpretationb of the position is left up
//  to the caller.  If the hot-key is uninitialized, this returns 0.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Position of the hot key.
CLocString::GetHotKeyPos(void)
		const
{
	return m_uiHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the hot-key character
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyChar(
		WCHAR wchNewHotKeyChar)			// Character to set as hot key.
{
	m_wchHotKeyChar = wchNewHotKeyChar;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the position of the hot-key
//  
//-----------------------------------------------------------------------------
inline
void
CLocString::SetHotKeyPos(
		UINT uiNewHotKeyPos)			// Position for the hot-key.
{
	m_uiHotKeyPos = uiNewHotKeyPos;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for LocStrings.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocString::operator=(
		const CLocString &lsSource)
{
	CopyLocString(lsSource);

	return *this;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator==(
		const CLocString &lsOtherString) // String to compare
		const
{
	return ((((HasHotKey() && lsOtherString.HasHotKey()) &&
			(GetHotKeyChar() == lsOtherString.GetHotKeyChar()) &&
			(GetHotKeyPos() == lsOtherString.GetHotKeyPos())) ||
			(!HasHotKey() && !lsOtherString.HasHotKey())) &&
			m_pasBaseString == lsOtherString.m_pasBaseString);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CLocString::operator!=(
		const CLocString &lsOtherString) // String to compare
		const
{
	return !(operator==(lsOtherString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the Translation Object.  Just sets the components to
//  default bad values.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation()
{
	m_lidSource = BAD_LOCALE;
	m_lidTarget = BAD_LOCALE;
	m_uiRanking = 0;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for copying a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::CopyTranslation(
		const CLocTranslation &Source)
{
	m_lsSource = Source.m_lsSource;
	m_lidSource = Source.m_lidSource;
	m_lsTarget = Source.m_lsTarget;
	m_lidTarget = Source.m_lidTarget;
	m_pstrGlossaryNote = Source.m_pstrGlossaryNote;
	m_uiRanking = Source.m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for a CLocTranslation
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocTranslation &Source)
{
	CopyTranslation(Source);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets all the required components of a translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	m_lsSource = Source;
	m_lidSource = lidSource;
	m_lsTarget = Target;
	m_lidTarget = lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the glossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslation::SetNote(
		const CPascalString &pstrNote)
{
	m_pstrGlossaryNote = pstrNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the translation that takes all the required info.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::CLocTranslation(
		const CLocString &Source,
		LangId lidSource,
		const CLocString &Target,
 		LangId lidTarget)
{
	SetTranslation(Source, lidSource, Target, lidTarget);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int 
CLocTranslation::operator==(const CLocTranslation &locTran) const
{
	return (
			GetSourceString() == locTran.GetSourceString()
			&& GetSourceString().GetStringType() 
					== locTran.GetSourceString().GetStringType()
			&& GetTargetString() == locTran.GetTargetString()
			&& GetTargetString().GetStringType() 
					== locTran.GetTargetString().GetStringType()
			&& GetNote() == locTran.GetNote()
			&& GetRanking() == locTran.GetRanking()
		   );
}

inline
int 
CLocTranslation::operator!=(const CLocTranslation &locTran) const
{
	return !(operator==(locTran));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the source string of the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetSourceString(void)
		const
{
	return m_lsSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the target string for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CLocString &
CLocTranslation::GetTargetString(void)
		const
{
	return m_lsTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the glkossary note for the translation.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocTranslation::GetNote(void)
		const
{
	return m_pstrGlossaryNote;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the translation ranking for the strnslation.  See
//  CalculateRanking().
//  
//-----------------------------------------------------------------------------
inline
UINT
CLocTranslation::GetRanking(void)
		const
{
	return m_uiRanking;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded source language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetSourceLanguage(void)
		const
{
	return m_lidSource;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the embedded target language for the translation.
//  
//-----------------------------------------------------------------------------
inline
LangId
CLocTranslation::GetTargetLanguage(void)
		const
{
	return m_lidTarget;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Validates the translation.  This make sure that all the needed components
//  of tghe source string exist in some form in the target string.  This
//  simply returns a validation code.
//  
//-----------------------------------------------------------------------------
inline
CVC::ValidationCode
CLocTranslation::ValidateTranslation(
		const CValidationOptions &Options)
		const
{
	CLString str;
	
	return ValidateTranslation(Options, FALSE, str, NULL, NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for the translation object.
//  
//-----------------------------------------------------------------------------
inline
const CLocTranslation &
CLocTranslation::operator=(
		const CLocTranslation &Source)	// Translation to copy from.
{
	CopyTranslation(Source);
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for the translation.  Nothing interesting happens here.
//  
//-----------------------------------------------------------------------------
inline
CLocTranslation::~CLocTranslation()
{
	DEBUGONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\report.inl ===
//-----------------------------------------------------------------------------
//  
//  File: reporter.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\product.h ===
//-----------------------------------------------------------------------------
//  
//  File: product.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#pragma once


struct ESP_USER_SETUP_DATA
{
	CLString strName;
	CLString strCompany;
};


BOOL LTAPIENTRY GetEspressoVersion(CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileVersion(const CLString& strFile, 
	CLString& strVersion);

BOOL LTAPIENTRY GetEspressoFileCopyright(const CLString& strFile, 
	CLString& strCopyright);

BOOL LTAPIENTRY GetSetupUserInfo(ESP_USER_SETUP_DATA& userData);

void LTAPIENTRY GetApplicationDirectory(CLString &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LocUtil.rc
//
#define IDD_CANCELABLE                  12600
#define IDC_CANCEL_CURRENT              12601
#define IDC_TASK                        12602
#define IDD_PROGRESS                    12603
#define IDC_CANCEL_DESCRIPTION          12603
#define IDC_PROGDLG_PROGRESS            12604
#define IDC_OPERATION                   12606
#define IDC_PROGRESS                    12607
#define IDD_WARNINGS                    12608
#define IDC_CHK_EXCL                    12608
#define IDC_WARNINGS_EDT                12609
#define IDD_OPEN_EXCL                   12610
#define IDS_SETTINGS_INDENT             12700
#define IDS_SETTINGS_SEP                12701
#define IDS_SETTINGS_CTX                12702
#define IDS_SETTINGS_DEFAULT            12703
#define IDS_SETTINGS_USER               12704
#define IDS_SETTINGS_OVERRIDE           12705
#define IDS_TRUNCATED_TO_FIT            12706
#define IDS_AMPERSAND_NOT_ALONE         12707
#define IDS_CANT_HAVE_2HOTKEY           12708
#define IDS_AMPERSAND_NO_BLANK          12709
#define IDS_INVALID_HOTKEY_CHAR         12710
#define IDS_OUTTAB_FILE                 12712
#define IDS_OUTTAB_TEST                 12713
#define IDS_OUTTAB_GBOX                 12714
#define IDS_OUTTAB_LOCK                 12715
#define IDS_OUTTAB_UPDATE               12716
#define IDS_OUTTAB_MESSAGES             12717
#define IDS_VAL_BLANK_TARGET            12718
#define IDS_VAL_BLANK_SOURCE            12719
#define IDS_VAL_REMOVE_HK               12720
#define IDS_VAL_ADDED_HK                12721
#define IDS_VAL_LINE_COUNT              12722
#define IDS_VAL_REMOVE_ACCEL            12723
#define IDS_VAL_CHANGED_TERMINATOR      12724
#define IDS_VAL_LEADING_WHITESPACE      12725
#define IDS_VAL_LEADING_PUNCTUATION     12726
#define IDS_VAL_TRAILING_WHITESPACE     12727
#define IDS_VAL_TRAILING_PUNCTUATION    12728
#define IDS_VAL_TRANSLATION_SIZE        12729
#define IDS_VAL_HOTKEY_POSITION         12730
#define IDS_VAL_DBCS_POS                12731
#define IDS_VAL_DBCS_CHAR               12732
#define IDS_VAL_BLANK_TARGET_LONG       12733
#define IDS_VAL_BLANK_SOURCE_LONG       12734
#define IDS_VAL_REMOVE_HK_LONG          12735
#define IDS_VAL_ADDED_HK_LONG           12736
#define IDS_VAL_LINE_COUNT_LONG         12737
#define IDS_VAL_REMOVE_ACCEL_LONG       12738
#define IDS_VAL_CHANGED_TERMINATOR_LONG 12739
#define IDS_VAL_LEADING_WHITESPACE_LONG 12740
#define IDS_VAL_LEADING_PUNCTUATION_LONG 12741
#define IDS_VAL_TRAILING_WHITESPACE_LONG 12742
#define IDS_VAL_TRAILING_PUNCTUATION_LONG 12743
#define IDS_VAL_TRANSLATION_SIZE_LONG   12744
#define IDS_VAL_HOTKEY_POSITION_LONG    12745
#define IDS_VAL_DBCS_POS_LONG           12746
#define IDS_VAL_DBCS_CHAR_LONG          12747
#define IDS_VAL_REORDERABLE             12748
#define IDS_VAL_PRINTF                  12749
#define IDS_VAL_REORDERABLE_LONG        12750
#define IDS_VAL_PRINTF_LONG             12751
#define IDS_VAL_CHECK_NUL               12752
#define IDS_VAL_CHECK_NUL_LONG          12753
#define IDS_VAL_CHECK_CHARS_IN_CP       12754
#define IDS_VAL_CHECK_CHARS_IN_CP_LONG  12755
#define IDS_NOTE                        12756
#define IDS_WARNING                     12757
#define IDS_ERROR                       12758
#define IDS_ABORT                       12759
#define IDS_TOO_MANY_FILES_SELECTED     12760
#define IDS_TRUE                        12761
#define IDS_FALSE                       12762
#define IDS_OUTTAB_UTILITY              12763
#define IDS_EQ                          12764
#define IDS_NOTEQ                       12765
#define IDS_GT                          12766
#define IDS_LT                          12767
#define IDS_LTEQ                        12768
#define IDS_GTEQ                        12769
#define IDS_WITHIN                      12770
#define IDS_BEYOND                      12771
#define IDS_CONTAINS                    12772
#define IDS_EXTENSIONS                  12773
#define IDS_EXTENSIONS_HELP             12774
#define IDS_CONTAINSWORD                12775
#define IDS_CANCEL                      12776
#define IDS_STOP                        12777
#define IDS_STARTWITH                   12778
#define IDS_ENDWITH                     12779

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        12611
#define _APS_NEXT_COMMAND_VALUE         12600
#define _APS_NEXT_CONTROL_VALUE         12609
#define _APS_NEXT_SYMED_VALUE           12602
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\report.h ===
//-----------------------------------------------------------------------------
//  
//  File: report.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Mechanism for reporting messages and such to people.
//  
//-----------------------------------------------------------------------------
 


enum MessageSeverity
{
	esNote,
	esWarning,
	esError,
	esAbort
};

//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReport  // : virtual public CObject
{
public:
	CReport();

	virtual void AssertValid(void) const;

	virtual void Activate(void);
	virtual void Clear(void);

	enum ConfidenceLevel
	{
		Low,
		High
	};
	
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	
	NOTHROW static const CLString & GetErrorCodeText(MessageSeverity ms);
	
	virtual ~CReport();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReport(const CReport &);
	const CReport &operator=(const CReport &);

	//
	//  Text for MessageSeverities.
	//
	static CLString strSeverities[4];
	friend void GlobalInitStrings(void);
};

#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\showwarnings.h ===
//-----------------------------------------------------------------------------
//  
//  File: ShowWarnings.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(PKGUTIL__ShowWarnings_h__INCLUDED)
#define PKGUTIL__ShowWarnings_h__INCLUDED

enum eWarningFilter
{
	wfNote,
	wfWarning,
	wfError,
	wfAbort,
	wfAll
};


int LTAPIENTRY ShowWarnings(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL,
		eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, UINT nMsgBoxFlags = MB_OK);

#endif // PKGUTIL__ShowWarnings_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\progress.h ===
//-----------------------------------------------------------------------------
//  
//  File: progress.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#ifndef _ESPUTIL_PROGRESS
#define _ESPUTIL_PROGRESS


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CProgressiveObject : virtual public CObject
{
public:
	CProgressiveObject();

	void AssertValid(void) const;
	
	virtual void SetProgressIndicator(UINT uiPercentage) = 0;
	virtual void SetDescription(HINSTANCE, DWORD);

	~CProgressiveObject();

	virtual void SetCurrentTask(CLString const & strTask) = 0;
	virtual void SetDescriptionString(CLString const & strDescription) = 0;
	
private:
	//
	// Private so nobody will use them...
	//
	CProgressiveObject(const CProgressiveObject &);
	const CProgressiveObject &operator=(const CProgressiveObject &);
};

#pragma warning(default: 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "progress.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\schema.h ===
//-----------------------------------------------------------------------------
//  
//  File: schema.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL_Schema_h_INCLUDED)
#define LOCUTIL_Schema_h_INCLUDED

#pragma once

namespace MitDisplayColumns
{
	interface IManager;
	interface IOption;
};

class CColDefList;

//------------------------------------------------------------------------------
class LTAPIENTRY SchemaId : public _GUID
{
public:
	SchemaId();
	SchemaId(const _GUID &);
	
	void Load(CArchive &);
	void Store(CArchive &) const;
	void Serialize(CArchive &);

	const SchemaId & operator=(const SchemaId &);
	const SchemaId & operator=(const _GUID &);
	
	INT operator==(const SchemaId &);
	INT operator!=(const SchemaId &);

private:
	BOOL Compare(const SchemaId &);
};


//------------------------------------------------------------------------------
class LTAPIENTRY CTableSchema : public CRefCount
{
// Construction
public:
	CTableSchema(const SchemaId &, const CLString &, const CColDefList &);
	
// Data
protected:
	SchemaId	m_Schema;
	CLString	m_strDescription;
	CColDefList	m_lstColDefs;

// Attributes
public:
	const SchemaId & GetSchemaId() const;
	const CLString & GetDescription() const;
	const CColDefList & GetColDefList() const;

	int GetDisplayColumnCount() const;

// Operations
public:
	const CColumnDefinition * GetColumnDefinition(long nSearchID) const;
	const CColumnDefinition * GetColumnDefinition(const CLString & stSearchID) const;

// Debugging
#ifdef _DEBUG
	void AssertValid() const;
#endif
};


//------------------------------------------------------------------------------
struct LTAPIENTRY DcsHelp
{
	static void
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, 
			MitDisplayColumns::IManager * const pManager, 
			MitDisplayColumns::IOption ** ppOption = NULL);

	static void 
			BuildDCOption(CTableSchema const * const pSchema, _bstr_t bstrID, _bstr_t bstrName, 
			MitDisplayColumns::IManager * const pManager, long rgID[], int cIDs,
			MitDisplayColumns::IOption ** ppOption = NULL);
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "schema.inl"
#endif

#endif // LOCUTIL_Schema_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\stdafx.h ===
//-----------------------------------------------------------------------------
//  
//  File: stdafx.h|locutil
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <afxtempl.h>
#include <afxole.h>

#include <mitutil.h>
#include <MitTL.h>

// Import TypeLibs before header files
#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#import <TypeLibs\MitDC.tlb> named_guids, raw_method_prefix("raw_")
#pragma warning(ZCOM_WARNING_DEFAULT)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9BCC8577_DEA0_11D0_A709_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\progress.inl ===
//-----------------------------------------------------------------------------
//  
//  File: progress.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

inline
CProgressiveObject::CProgressiveObject()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\schema.inl ===
//-----------------------------------------------------------------------------
//  
//  File: schema.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 


inline
SchemaId::SchemaId()
	: _GUID(GUID_NULL)
{}

	

inline
SchemaId::SchemaId(
		const _GUID &guid)
	: _GUID(guid)
{}



inline
void
SchemaId::Load(
		CArchive &ar)
{
	if (ar.Read((_GUID *) this, sizeof(_GUID)) != sizeof(_GUID))
	{
		AfxThrowArchiveException(CArchiveException::endOfFile);
	}
}



inline
void
SchemaId::Store(
		CArchive &ar)
		const
{
	ar.Write((_GUID *) this, sizeof(_GUID));
}




inline
void
SchemaId::Serialize(
		CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
const SchemaId &
SchemaId::operator=(
		const SchemaId &other)
{
	return operator=((_GUID &)other);
}



inline
const SchemaId &
SchemaId::operator=(
		const _GUID &other)
{
	(_GUID &)(*this) = other;

	return *this;
}



inline
int
SchemaId::operator==(
		const SchemaId &other)
{
	return Compare(other);
}



inline
int
SchemaId::operator!=(
		const SchemaId &other)
{
	return !Compare(other);
}



inline
BOOL
SchemaId::Compare(
		const SchemaId &other)
{
	return ((_GUID &)*this) == ((_GUID &)other);
}



inline
const SchemaId & 
CTableSchema::GetSchemaId() const
{
	return m_Schema;
}


inline
const CLString & 
CTableSchema::GetDescription() const
{
	return m_strDescription;
}


inline
const CColDefList & 
CTableSchema::GetColDefList() const
{
	return m_lstColDefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\warndlg.h ===
//******************************************************************************
//  
//  File: WarnDlg.H
//
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//******************************************************************************

#if !defined(LOCUTIL__WarnDlg_h__INCLUDED)
#define LOCUTIL__WarnDlg_h__INCLUDED

//------------------------------------------------------------------------------
class CWarningsDlg : public CDialog
{
// Construction
public:
	CWarningsDlg(const CBufferReport * pBufMsg, LPCTSTR pszTitle = NULL, 
			eWarningFilter wf = wfWarning, BOOL fShowContext = FALSE, 
			UINT nMsgBoxFlags = MB_OK, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CWarningsDlg)
	enum { IDD = IDD_WARNINGS };
	CButton	m_btnYes;
	CButton	m_btnCancel;
	CButton	m_btnNo;
	CButton	m_btnOK;
	//}}AFX_DATA

// Data
protected:
	const CBufferReport *	m_pBufMsg;
	CLString				m_stTitle;
	eWarningFilter			m_wf;
	BOOL					m_fShowContext;
	UINT					m_nMsgBoxFlags;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWarningsDlg)
	public:
	virtual int DoModal();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void AddString(CEdit * pebc, const CLString & stAdd, int & len);

	// Generated message map functions
	//{{AFX_MSG(CWarningsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnYes();
	afx_msg void OnNo();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif  // LOCUTIL__WarnDlg_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_errorrep.h ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Error reporting mechanism for Espresso 2.0
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL__errorrep_h_INCLUDED)
#define LOCUTIL__errorrep_h_INCLUDED

////////////////////// the new global issuemessage functions.

UINT LTAPIENTRY EspMessageBox(const CLString strMessage, UINT uiType = MB_OK,
		UINT uiDefault=IDOK, UINT uiHelpContext=0);
UINT LTAPIENTRY EspMessageBox(HINSTANCE hResourceDll, UINT uiStringId,
		UINT uiType=MB_OK, UINT uiDefault=IDOK, UINT uiHelp = 0);

class CReport;

void LTAPIENTRY SetErrorReport(CReport *, BOOL fBatchMode);
void LTAPIENTRY GetErrorReport(CReport *&, BOOL &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_errorrep.inl"
#endif

#endif // LOCUTIL__errorrep_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_cancel.h ===
//-----------------------------------------------------------------------------
//
// File: _cancel.h
// Copyright (C) 1994-1998 Microsoft Corporation
// All rights reserved.
//
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__CANCEL_H
#define ESPUTIL__CANCEL_H

#pragma once

#pragma warning(disable:4275 4251)

class CCancelDialog;

class LTAPIENTRY CCancelDisplay : public CCancelableObject
{
public:
	CCancelDisplay(CWnd *pParent = NULL);

	//
	//  CCancelableObject methods.
	virtual BOOL fCancel(void) const;

	virtual void SetDescriptionString(const CLString &);
	virtual void SetCurrentTask(const CLString &);

	//
	//  CProgressiveObject methods.
	virtual void SetProgressIndicator(UINT uiPercentage);

	~CCancelDisplay();

	void SetDelay(clock_t);

	enum CancelButtonText { nCancel, nStop, COUNT_OF_ENUM };
	void SetCancelButtonText(CancelButtonText const nCancelButtonText);

	void DisplayDialog(BOOL);

protected:
	friend CCancelDialog;
	void SetCancel(BOOL);
	void ChangeCancelButtonText();

private:
	BOOL m_fCancel;
	CCancelDialog *m_pCancelDialog;
	CLString m_strDescription;
	CLString m_strTask;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t m_ctDisplayTime;
	CancelButtonText m_nCancelButtonText;
	BOOL m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CWnd *m_pParent;
};


#pragma warning(default:4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_cancel.inl"
#endif

#endif // ESPUTIL__CANCEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_espopts.h ===
//-----------------------------------------------------------------------------
//  
//  File: _espopts.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#if !defined(LOCUTIL__espopts_h_INCLUDED)
#define LOCUTIL__espopts_h_INCLUDED

LTAPIENTRY BOOL RegisterOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterOptions(const TCHAR *szName);
LTAPIENTRY BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetGroupName(const TCHAR * szName, CLString & strGroup);
LTAPIENTRY BOOL SetOptionDefault(const TCHAR *szName, const CLocVariant &);

LTAPIENTRY const CLocUIOptionSetList &  GetOptions(void);

LTAPIENTRY CLocOptionValStore *  GetOptionStore(CLocUIOption::StorageType);
LTAPIENTRY void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
LTAPIENTRY void UpdateOptionValues(void);

LTAPIENTRY void SummarizeOptions(CReport *);


#pragma warning(disable : 4251) // class 'foo' needs to have dll-interface 
								// to be used by clients of class 'bar' 

class LTAPIENTRY CLocOptionManager
{
public:
	const CLocUIOptionSetList &GetOptions(void);

	CLocOptionValStore *GetOptionStore(CLocUIOption::StorageType);
	void SetOptionStore(CLocUIOption::StorageType, CLocOptionValStore *);
	BOOL RegisterOptions(CLocUIOptionSet *);
	void UnRegisterOptions(const TCHAR *szOptSetName);

	BOOL GetOptionValue(const TCHAR *szName, CLocOptionVal *&);
	BOOL GetOptionValue(const TCHAR *szGroupName, const TCHAR *szName,
			CLocOptionVal *&);
	
	void UpdateOptionValues(void);
	void SummarizeOptionValues(CReport *pReport);
	
	BOOL SetOptionDefault(const TCHAR *szName, const
			CLocVariant &varValue);
	void UpdateCurrentValue(CLocUIOption *pOption);
	BOOL GetGroupName(const TCHAR* szName, CLString& strGroup);	
protected:
	void NotifyAll(void);
	void GetCurrentValue(CLocUIOption *, CLocOptionVal *&);
	void DumpOptionSet(CLocUIOptionSet *, UINT, CReport *);
	
private:
	CLocUIOptionSetList m_osOptSetList;
	SmartRef<CLocOptionValStore> m_spUserStore;
	SmartRef<CLocOptionValStore> m_spOverrideStore;
};

#pragma warning(default : 4251)

#endif // LOCUTIL__espopts_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_errorrep.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _errorrep.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
UINT
EspMessageBox(
		HINSTANCE hResourceDll,
		UINT uiStringId,
		UINT uiType,
		UINT uiDefault,
		UINT uiHelp)
{
	CLString strMessage;

	strMessage.LoadString(hResourceDll, uiStringId);
	return EspMessageBox(strMessage, uiType, uiDefault, uiHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_extension.h ===
//-----------------------------------------------------------------------------
//  
//  File: _extension.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Classes to support the new Espresso Extensions interfaces.
//  
//-----------------------------------------------------------------------------
 
#pragma once

typedef UUID ExtensionID;
typedef UUID OperationID;

struct LTAPIENTRY LOCEXTENSIONMENU
{
	LOCEXTENSIONMENU();
	
	CLString strMenuName;				// Name of the Menu
	IID      iidProcess;				// IID for the process interface the
										// menu requires
	OperationID    idOp;				// Allows a single DLL to implement
};

typedef CArray<LOCEXTENSIONMENU, LOCEXTENSIONMENU &> CLocMenuArray;


DECLARE_INTERFACE_(ILocExtension, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;


	//
	//  ILocExtension methods
	//

	//
	//  In Initialize, extension will...
	//   Add any menus it needs to the array of menu obejcts
	//   Register any options it has with Espresso
	//   Ignore the IUnknown for now.
	STDMETHOD(Initialize)(IUnknown *) PURE;

	//
	//  Since extensions may have state, we can't use QueryInterface.
	//  This method has similar semantics, except that in most cases
	//  we expect to get a new objects.  Also, QI on a returned
	//  object doesn't have to support ILocExtension.
	STDMETHOD(GetExtension)(const OperationID &, LPVOID FAR*ppvObj) PURE;
	
	//
	//  In UnInitialize the extension will...
	//   UnRegister any of its options.
	STDMETHOD(UnInitialize)(void) PURE;
};

struct __declspec(uuid("{9F9D180E-6F38-11d0-98FD-00C04FC2C6D8}"))
		ILocExtension;

LTAPIENTRY void UUIDToString(const UUID &, CLString &);

LTAPIENTRY void RegisterExtension(const ExtensionID &,
		const TCHAR *szDescription, HINSTANCE,
		const CLocMenuArray &);
LTAPIENTRY void UnRegisterExtension(const ExtensionID &);

LTAPIENTRY BOOL RegisterExtensionOptions(CLocUIOptionSet *);
LTAPIENTRY void UnRegisterExtensionOptions(const TCHAR *szName);


//
//  Extensions need to export the following function:
//  STDAPI GetExtension(ILocExtension *&);
typedef HRESULT (STDAPICALLTYPE *PFNExtensionEntryPoint)(ILocExtension *&);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\stringhelp.h ===
//******************************************************************************
//
// StringHelp.h: Microsoft LocStudio
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(LOCUTIL__StringHelp_h__INCLUDED)
#define LOCUTIL__StringHelp_h__INCLUDED

//------------------------------------------------------------------------------
class LTAPIENTRY CStringHelp
{
// Enums
public:
	enum Mode
	{
		mDisplay,	// Use display-mode logic
		mEdit		// Use edit-mode logic
	};

// Construction
public:
	CStringHelp(Mode mode, CReport * pReport);

// Data
protected:
	Mode		m_mode;
	CReport *	m_pReport;
	int			m_cErrors;
	CLString	m_stContext;

	BOOL			m_fFirstErrorSet;
	CWnd const *	m_pwndError;		// Optional window of first error
	int				m_idxError;			// Optional index of first error

// Attributes
public:
	int GetErrorCount();
	void ResetErrorCount();
	const CLString & GetContext();
	void SetContext(const CLString & stContext);

	BOOL GetFirstError(CWnd const * & pwnd, int & idxError);

// Operations
public:
	void LoadString(const CPascalString & pasSrc, CLString & stDest);
	void LoadString(_bstr_t bstrSrc, CLString & stDest);
	void LoadString(const CPascalString & pasSrc, CEdit * pebc);
	void LoadString(_bstr_t bstrSrc, CEdit * pebc);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest);
	BOOL SaveString(CEdit const * const pebc, CPascalString & pasDest);
	BOOL SaveString(CEdit const * const pebc, _bstr_t & bstrDest);

// Implementation
protected:
	void SetError(CWnd const * pwnd, int idxError);

	BOOL SaveString(const CLString & stSrc, CPascalString & pasDest, CWnd const * pwnd);
	BOOL SaveString(const CLString & stSrc, _bstr_t & bstrDest, CWnd const * pwnd);
};

#endif // LOCUTIL__StringHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_cancel.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _cancel.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_interface.h ===
//-----------------------------------------------------------------------------
//  
//  File: _interface.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_optvalstore.h ===
//-----------------------------------------------------------------------------
//  
//  File: _optvalstore.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValStore : public CRefCount, public CObject
{ public: CLocOptionValStore() {};

	void AssertValid(void) const;

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup)
			= 0;

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
 			const CLString &strOptionName) = 0;
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLocOptionVal *);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &) = 0;
	virtual BOOL RemoveOptions(const CLString &strOptionGroup) = 0;

private:
	CLocOptionValStore(const CLocOptionValStore &);
	void operator=(int);
};
	

class LTAPIENTRY CLocOptionValRegStore : public CLocOptionValStore
{
public:
	CLocOptionValRegStore();

	void AssertValid(void) const;
	
	BOOL SetRegistryKeyName(const TCHAR *);

	virtual CLocOptionValSet *GetOptions(const CLString &strOptionGroup);

	virtual BOOL RemoveOption(const CLString &strOptionGroup,
			const CLString &strOptionName);
	virtual BOOL StoreOption(const CLString &strOptionGroup,
			const CLString &strName, const CLocVariant &);
	virtual BOOL RemoveOptions(const CLString &strOptionGroup);

	virtual ~CLocOptionValRegStore();

private:
	HKEY m_hkRegStorage;
	CLocOptionValSetList m_oslCache;

	void PurgeOptionCache(void);
};



#pragma warning(default: 4275)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_locenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: _locenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#if !defined(LOCUTIL__locenum_h_INCLUDED)
#define LOCUTIL__locenum_h_INCLUDED
 
//
//  This class is used in UI. SetSel() is used to set the initial
//	selection in the combo box
//
class LTAPIENTRY CEnumIntoComboBox: public CEnumCallback
{
public:
	CEnumIntoComboBox(CComboBox *pLB=NULL, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
};

class LTAPIENTRY CEnumIntoListBox: public CEnumCallback
{
public:
	CEnumIntoListBox(CListBox *pLB=NULL, 
				DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const EnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
};


class LTAPIENTRY CWEnumIntoComboBox: public CWEnumCallback
{
public:
	CWEnumIntoComboBox(CComboBox *pLB=NULL, BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CComboBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	BOOL		m_bForEdit;   // If this flag is true, the strings in the Combo box are displayed in Editing mode
};


class LTAPIENTRY CWEnumIntoListBox: public CWEnumCallback
{
public:
	CWEnumIntoListBox(CListBox *pLB=NULL, 
				BOOL bForEdit = TRUE, DWORD val=0, BOOL bAbbrev=FALSE, LPCTSTR lpszPrefix=NULL);
	void SetSel(DWORD val);
	virtual BOOL ProcessEnum(const WEnumInfo &);

protected:
	CListBox	*m_pLB;
	BOOL		m_bAbbrev;
	DWORD		m_dwVal;
	LPCTSTR		m_lpszPrefix;
	BOOL		m_bForEdit;		// If this flag is true, the strings in the Listbox are displayed in Editing mode
};

#endif  // LOCUTIL__locenum_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_report.h ===
//-----------------------------------------------------------------------------
//  
//  File: _report.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCUTIL_REPORT_H
#define LOCUTIL_REPORT_H

#pragma once

//
//  Throws away ALL messages.
//
class LTAPIENTRY CNullReport : public CReport
{
public:
	CNullReport() {};
	
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

};


//
//  This stuff is used for an implementation of CReport that will
//  'buffer' messages.  Use CBufferReporter if you don't want to
//  process messages until after the process producing them is done.
//  You can get the messages either by severity, or as a list of all
//  messages as they were issued.
//
struct ReportMessage
{
	MessageSeverity sev;
	CLString strContext;
	CLString strMessage;
	SmartRef<CGoto> spGoto;
	SmartRef<CGotoHelp> spGotoHelp;
};


typedef CTypedPtrList<CPtrList, ReportMessage *> MessageList;

#pragma warning (disable:4251)

class LTAPIENTRY CBufferReport : public CReport
{
public:
	CBufferReport();

	void AssertValid(void) const;
	

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Clear(void);

	NOTHROW const MessageList & GetNotes(void) const;
	NOTHROW const MessageList & GetWarnings(void) const;
	NOTHROW const MessageList & GetErrors(void) const;
	NOTHROW const MessageList & GetAborts(void) const;

	NOTHROW const MessageList & GetMessages(void) const;
	void DumpTo(CReport *) const;
	
	~CBufferReport();

private:

	MessageList m_mlNotes;
	MessageList m_mlWarnings;
	MessageList m_mlErrors;
	MessageList m_mlAborts;

	mutable MessageList m_mlMessages;
};


//
//  This reporter just send all its messages directly to a message box.
//
class LTAPIENTRY CMessageBoxReport : public CReport
{
public:
	CMessageBoxReport();

	void AssertValid(void) const;

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CMessageBoxReport();

private:
	
};



//
//  This reporter is used to send all messages to a file.
//
class LTAPIENTRY CFileReport : public CReport
{
public:
	CFileReport();

	BOOL InitFileReport(const CLString &strFileName);

	virtual void Clear(void);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	~CFileReport();

private:

	CFile m_OutputFile;
};

//
//  This reporter is used for command line utilities.  Output goes to stdout
//
class LTAPIENTRY CStdOutReport : public CReport
{
public:

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	virtual void SetConfidenceLevel(ConfidenceLevel);

private:
	BOOL m_fEnabled;
};


//
//  This is used to 'redirect' messages to a single reporter.  It's used
//  when several different reporters are required by the current
//  implementation, but the desired effect is that they all send their messages
//  to a common location.
//
//  This class takes ownership of another Reporter, then uses reference
//  counting semantics to determine when to delete that reporter.
//
class LTAPIENTRY CRedirectReport : public CReport
{
public:
	CRedirectReport();

	virtual void Activate(void);
	virtual void Clear(void);
	virtual void SetConfidenceLevel(ConfidenceLevel);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	//  Used for initial attachment to a CReporter.
	NOTHROW void RedirectTo(CReport *pReport);

	//  Used to share a single reporter among several CRedirectReporter's.
	NOTHROW void RedirectTo(CRedirectReport *pReport);
	
	~CRedirectReport();

private:
	struct RedirectInfo
	{
		SmartPtr<CReport> pReport;
		UINT uiRefCount;
	};

	RedirectInfo *m_pRedirectInfo;
	void NOTHROW Detach(void);
};


//
//  
//  This class is used to re-direct output through a reporter.  It will
//  automatically call Clear() and Activate() the first time output is sent
//  to the reporter.  If the usre calls Activate first on this reporter, then
//  no action is taken when something is output.
//  
//
class LTAPIENTRY CActivateReport : public CReport
{
public:
	CActivateReport(CReport *);

 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL);

	void Activate();
	void Clear();

private:
	BOOL m_fActivated;
	CReport *m_pReport;
};



//
//  The following manage a global 'pool' of reporters that are used by
//  different components in the system.
//  Each reporter has to be distinct.  Once the reporter has been 'added',
//  the global pool *owns* the reporter and will delete it.  This is done by
//  ReleaseAllReporters().
//
NOTHROW LTAPIENTRY void AddReport(COutputTabs::OutputTabs idx, CReport *pReport);
NOTHROW LTAPIENTRY CReport * GetReport(COutputTabs::OutputTabs);
NOTHROW LTAPIENTRY void ReleaseAllReports();

#include "_report.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\buildnum.h ===
//-----------------------------------------------------------------------------
//  
//  File: buildnum.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Build number file.  This converts the SLM build numbers in PRODVER.H
//  to something a little more useful.
//  
//  This is mostly used by version stamp resoruces.  If you want the build
//  numbers, you should PROBABLY use the ones exported in PBASE (if you are
//  a parser), or function GetVersionInfo() in ESPUTIL.
//
//-----------------------------------------------------------------------------

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-1998 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-1998 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_pumpidle.h ===
//-----------------------------------------------------------------------------
//  
//  File: pumpidle.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__PUMPIDLE_H
#define ESPUTIL__PUMPIDLE_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CPumpAndIdle : public CObject
{
public:
	CPumpAndIdle(BOOL fDelete);
	
	virtual BOOL PumpAndIdle(long lCount) = 0;

	void Delete(void);
	
private:
	CPumpAndIdle();
	CPumpAndIdle(const CPumpAndIdle &);
	void operator=(const CPumpAndIdle &);

	BOOL m_fDelete;
};

#pragma warning(default: 4275)

class LTAPIENTRY CTimerPump : public CPumpAndIdle
{
public:
	CTimerPump(BOOL fDelete, UINT uiSeconds);

	BOOL PumpAndIdle(long lCount);

	virtual void OnTimeout(void)  = 0;
	
private:
	UINT m_uiTimeout;
	clock_t m_tLastRun;
};



void LTAPIENTRY NOTHROW AddPumpClass(CPumpAndIdle *);
BOOL LTAPIENTRY NOTHROW RemovePumpClass(CPumpAndIdle *);

BOOL LTAPIENTRY PumpAndIdle(long lCount);
void LTAPIENTRY PumpAndIdle(void);

class CProgressDialog;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CInputBlocker : public CObject
{
public:
	CInputBlocker(CWnd* pParent = NULL);

	~CInputBlocker();

private:
	CInputBlocker(const CInputBlocker &);
	void operator=(const CInputBlocker &);

	CProgressDialog *pDlg;
	
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\ltapi.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltapi.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_progress.h ===
//-----------------------------------------------------------------------------
//  
//  File: _progress.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef ESPUTIL__PROGRESS_H
#define ESPUTIL__PROGRESS_H

class CProgressDialog;
class CInputBlocker;

#pragma warning(disable:4251)

class LTAPIENTRY CProgressDisplay : public CProgressiveObject
{
public:
	CProgressDisplay(CWnd *pParent = NULL);

	void SetDelay(clock_t);
	void DisplayDialog(BOOL);

	void SetProgressIndicator(UINT uiPercentage);

	void SetTitle(const CLString &);
	void SetTitle(HINSTANCE, DWORD);
	~CProgressDisplay();

	virtual void SetCurrentTask(CLString const & strTask);
	virtual void SetDescriptionString(CLString const & strDescription);

private:
	CProgressDialog *m_pDialog;
	UINT m_uiLastPercentage;
	clock_t m_ctLastTime;
	clock_t         m_ctDisplayTime;
	BOOL	m_fDisplay;
	BOOL	m_fWaitCursor;
	SmartPtr<CInputBlocker>	m_spBlocker;

	CLString m_strTitle;
	CLString m_strDescription;

	CWnd *m_pParent;
};

#pragma warning(default:4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_locstr.h ===
//-----------------------------------------------------------------------------
//  
//  File: _locstr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


#ifndef ESPUTIL__LOCSTR_H
#define ESPUTIL__LOCSTR_H


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CLocTranslationArray : public CArray<CLocTranslation, CLocTranslation &>
{
public:

protected:
	 NOTHROW void SwapElements(UINT, UINT);
};


#pragma warning(disable : 4251)	// class 'foo' needs to have dll-interface to be
							    // used by clients of class 'bar' 

class LTAPIENTRY CLocCrackedString : public CObject
{
public:
	CLocCrackedString();
			
	void AssertValid(void) const;
	
	const CLocCrackedString &operator=(const CLocCrackedString &);

	NOTHROW int operator==(const CLocCrackedString &) const;
	NOTHROW int operator!=(const CLocCrackedString &) const;

	NOTHROW void CrackLocString(const CLocString &, BOOL fAsSource);
	NOTHROW UINT GetRanking(const CLocCrackedString &) const;

	NOTHROW BOOL HasExtension(void) const;
	NOTHROW BOOL HasControl(void) const;
	NOTHROW BOOL HasHotKey() const;

	NOTHROW const CPascalString & GetBaseString(void) const;
	NOTHROW const CPascalString & GetExtension(void) const;
	NOTHROW const CPascalString & GetControl(void) const;
	NOTHROW WCHAR GetHotKeyChar(void) const;
	NOTHROW UINT GetHotKeyPos(void) const;
	NOTHROW CST::StringType GetStringType(void) const;
	
	void SetBaseString(const CPascalString &pasBaseString);
	void SetHotKey(WCHAR cHotKeyChar, UINT uiHotKeyPos);
	
	void MergeCrackedStrings(const CLocCrackedString &, LangId,
			BOOL fMergeAccel);

	NOTHROW void ConvertToLocString(CLocString &) const;

	static void SetModifiers(const CPasStringList &);
	static void SetKeyNames(const CPasStringList &);
	static WCHAR m_cKeyNameSeparator;
	
	~CLocCrackedString();

private:
	CLocCrackedString(const CLocCrackedString &);

	NOTHROW BOOL Compare(const CLocCrackedString &) const;
	NOTHROW void ClearCrackedString(void);
	NOTHROW static BOOL IsControl(const CPascalString &, BOOL fAsSource);
	NOTHROW static void TranslateControl(CPascalString &);
	void SetDefaultModifierNames();
	void SetDefaultKeyNames();
	
	NOTHROW static BOOL IsTerminator(const CPascalString &);
	static CPasStringArray m_psaModifiersSource;
	static CPasStringArray m_psaKeyNamesSource;
	static CPasStringArray m_psaModifiersTarget;
	static CPasStringArray m_psaKeyNamesTarget;
	static BOOL m_fModifiersInitialized;
	static BOOL m_fKeyNamesInitialized;
	
	CPascalString m_pstrBaseString;
	CPascalString m_pstrExtension;
	CPascalString m_pstrControl;
	WCHAR m_cControlLeader;
	WCHAR m_cHotKeyChar;
	UINT m_uiHotKeyPos;
	CST::StringType m_stStringType;
};

#pragma warning(default : 4275)
#pragma warning(default : 4251)	

LTAPIENTRY const CValidationOptions & GetValidationOptions(void);
LTAPIENTRY void SetValidationOptions(const CValidationOptions &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "_locstr.inl"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_username.h ===
//-----------------------------------------------------------------------------
//  
//  File: username.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL__USERNAME_H
#define ESPUTIL__USERNAME_H

LTAPIENTRY const NOTHROW CPascalString &GetCurrentUserName();
LTAPIENTRY void NOTHROW SetUserName(const CPascalString &);
LTAPIENTRY void NOTHROW ResetUserName(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_locstr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _locstr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Swaps two elements of the translation array.
//  
//-----------------------------------------------------------------------------
inline
void
CLocTranslationArray::SwapElements(
		UINT iOne,						// First index to swap
		UINT iTwo)						// Second index to swap
{
	CLocTranslation Temp;
	
	LTASSERT(iOne <= (UINT)GetSize());
	LTASSERT(iTwo <= (UINT)GetSize());

	Temp = (*this)[iOne];
	(*this)[iOne] = (*this)[iTwo];
	(*this)[iTwo] = Temp;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator for cracked strings.
//  
//-----------------------------------------------------------------------------
inline
const CLocCrackedString &
CLocCrackedString::operator=(
		const CLocCrackedString &csSource)
{
	m_pstrBaseString = csSource.m_pstrBaseString;
	m_pstrExtension = csSource.m_pstrExtension;
	m_pstrControl = csSource.m_pstrControl;
	m_cControlLeader = csSource.m_cControlLeader;
	m_cHotKeyChar = csSource.m_cHotKeyChar;
	m_uiHotKeyPos = csSource.m_uiHotKeyPos;

	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Implementation for comparing two cracked strings.  Language ID and
//  string type are NOT significant!
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocCrackedString::Compare(
		const CLocCrackedString &csOther)
		const
{
	return ((m_uiHotKeyPos    == csOther.m_uiHotKeyPos) &&
			(m_cHotKeyChar    == csOther.m_cHotKeyChar) &&
			(m_pstrControl    == csOther.m_pstrControl) &&
			(m_cControlLeader == csOther.m_cControlLeader) &&
			(m_pstrExtension  == csOther.m_pstrExtension) &&
			(m_pstrBaseString == csOther.m_pstrBaseString));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator==(
		const CLocCrackedString &csOther)
		const
{
	return Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparision operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocCrackedString::operator!=(
		const CLocCrackedString &csOther)
		const
{
	return !Compare(csOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the Cracked string has an 'extension'.  The extension
//  is a sequence of characters ("...", ">>", stc) that indicates that this
//  item leads to another UI element.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the extension is non-null.
CLocCrackedString::HasExtension(void)
		const
{
	return m_pstrExtension.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests to see if the cracked string has a 'control' sequence.  This is
//  usually text describing a shortcut key that invokes the same action as this
//  item, for example "Ctrl + F".
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the control seq. is non-null
CLocCrackedString::HasControl(void)
		const
{
	return m_pstrControl.GetStringLength() != 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Check to see if the cracked string has a hot-key.  This come directly out
//  of the CLocString that was parsed into the Cracked String.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the string has a hot-key.
CLocCrackedString::HasHotKey(void)
		const
{
	return (m_cHotKeyChar != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the 'base string'.  This is the original string stripped of
//  extension and control sequences, and of the hot-key.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Base string.
CLocCrackedString::GetBaseString(void)
		const
{
	return m_pstrBaseString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the extension component of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetExtension(void)
		const
{
	return m_pstrExtension;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the constol sequence of the string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocCrackedString::GetControl(void)
		const
{
	return m_pstrControl;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the hot-key character for the string.
//  
//-----------------------------------------------------------------------------
inline
WCHAR
CLocCrackedString::GetHotKeyChar(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_cHotKeyChar;
}



inline
UINT
CLocCrackedString::GetHotKeyPos(void)
		const
{
	LTASSERT(HasHotKey());
	
	return m_uiHotKeyPos;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string type for the string.
//  
//-----------------------------------------------------------------------------
inline
CST::StringType
CLocCrackedString::GetStringType(void)
		const
{
	return m_stStringType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleans out all the components of the cracked string.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCrackedString::ClearCrackedString(void)
{
	m_pstrBaseString.ClearString();
	m_pstrExtension.ClearString();
	m_pstrControl.ClearString();
	m_cControlLeader = L'\0';
	m_cHotKeyChar = L'\0';
	m_uiHotKeyPos = 0;
	m_stStringType = CST::None;
}



inline
void
CLocCrackedString::SetBaseString(
		const CPascalString &pasBase)
{
	m_pstrBaseString = pasBase;
}



inline
void
CLocCrackedString::SetHotKey(
		WCHAR cHotKeyChar,
		UINT uiHotKeyPos)
{
	m_cHotKeyChar = cHotKeyChar;
	m_uiHotKeyPos = uiHotKeyPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitctrl.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitctrl.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  Owner: KenWal
//
//-----------------------------------------------------------------------------

#include "..\mitctrl\mitctrllib.h"

#ifndef MIT_MITCTRL_H
#define MIT_MITCTRL_H

//TODO get this from some other place
const	eventidSelChanged = 1L;
const	eventidCheckStateChange = 2L;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitthrow.h ===
//-----------------------------------------------------------------------------
//  
//  File: MitThrow.h
//  Copyright (C) 1994-1996 Microsoft Corporation
//  All rights reserved.
//  
//  Entry point macros for DLL's
//  
//-----------------------------------------------------------------------------
 
#if !defined(MIT_MitThrow)
#define MIT_MitThrow

#if !defined(NO_NOTHROW)

#if !defined(NOTHROW)
#define NOTHROW __declspec(nothrow)
#endif

#else

#if defined(NOTHROW)
#undef NOTHROW
#endif

#define NOTHROW

#endif

#endif // MIT_MitThrow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitwarning.h ===
//******************************************************************************
//
// MitWarning.h: MIT Template Library warnings
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mittl.h ===
//******************************************************************************
//
// MitTL.h: MIT Template Library
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MIT_TL_INCLUDED)
#define MIT_TL_INCLUDED

// General helpers

#include "..\MitTL\ComHelp.h"

#if defined(__ATLCOM_H__)			// Include ATL helpers if ATL is defined
	#include "..\MitTL\AtlComHelp.h"
#endif

#include "..\MitTL\MapHelp.h"

#include "MitThrow.h"
#include "..\MitTL\SmartPtr.h"

// Shared objects

#if defined(MitTL_UseDispIDCache)
	#include "..\MitTL\DispIDCache.h"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\locutil\_report.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _report.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Note' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetNotes(void)
		const
{
	return m_mlNotes;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Warning' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetWarnings(void)
		const
{
	return m_mlWarnings;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Error' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetErrors(void)
		const
{
	return m_mlErrors;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets all the 'Abort' severity messages from the CBufferReport.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetAborts(void)
		const
{
	return m_mlAborts;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns ALL the messages issued to the CBufferReport.  The messages
//  are stored in chronological order.
//  
//-----------------------------------------------------------------------------
inline
const MessageList &
CBufferReport::GetMessages(void)
		const
{
	return m_mlMessages;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitui.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitui.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma comment(lib, "MITUI.LIB")

#include "..\mitui\bumpbox.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\precenum.h ===
#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	enum name \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst) \
	name = enumconst,

#undef END_ENUM
#define END_ENUM(name) \
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitutil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#ifndef IMPLEMENT
#pragma comment(lib, "mitutil.lib")
#endif

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#ifdef __cplusplus


#ifndef __AFXTEMPL_H__
#include <afxtempl.h>
#pragma message("Warning: <afxtempl.h> not in pre-compiled header file, including")
#endif

#ifndef _OLE2_H_
#include <ole2.h>
#pragma message("Warning: <ole2.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>						// Provide interface definitions
#include "..\mitutil\macros.h"
#include "..\mitutil\ltdebug.h"					//  Espresso debugging facilities
#ifndef MIT_NO_DEBUG
#include "..\mitutil\stacktrace.h"
#include "..\mitutil\counter.h"
#endif

#ifndef MIT_NO_IMAGEHLP
#include <imagehlp.h>
#include "..\mitutil\imagehelp.h"	 	//	Helper class for imagehlp.dll
#endif

#include "..\mitutil\refcount.h"


#ifndef MIT_NO_SMART
#include "..\mitutil\smartptr.h"
#include "..\mitutil\smartref.h"
#endif


#ifndef MIT_NO_STRING
#include "..\mitutil\counter.h"
#include "..\mitutil\clstring.h"		//  Wrapper for CString
#include "..\mitutil\mitenum.h"
#include "..\mitutil\espnls.h"			//  Language Supportxo
#include "..\mitutil\cowblob.h"			//  Copy-on-write Blob class
#include "..\mitutil\passtr.h"			//  Pascal style (counted) strings
#include "..\mitutil\StringBlast.h"
#include "..\mitutil\strlist.h"
#include "..\mitutil\stringtokenizer.h"
#endif

#ifndef MIT_NO_FILE
#include "..\mitutil\loadlib.h"	        //  Wrapper for LoadLibrary
#include "..\mitutil\blobfile.h"
#include "..\mitutil\path.h"
#endif

#ifndef MIT_NO_OPTIONS
#include "..\mitutil\smartref.h"
#include "..\mitutil\locid.h"			//  Espresso ID's
#include "..\mitutil\locvar.h"			//  Variant type for CBinary
#include "..\mitutil\optionval.h"
#include "..\mitutil\optvalset.h"
#include "..\mitutil\uioptions.h"
#include "..\mitutil\uioptset.h"
#include "..\mitutil\uiopthelp.h"
#endif

#ifndef MIT_NO_MISC
#include "..\mitutil\flushmem.h"
#include "..\MitUtil\RegHelp.h"			// Registry helpers
#include "..\MitUtil\EditHelp.h"
#endif

#ifndef MIT_NO_DIFF
#include "..\mitutil\redvisit.h"
#include "..\mitutil\gnudiffalg.h"
#endif

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\mitdiff.h ===
//------------------------------------------------------------------------------
//  
//  mitdiff.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//------------------------------------------------------------------------------

#ifndef _MITDIFF_H
#define _MITDIFF_H


#ifdef MITDIFF
#define MITDIFFAPI __declspec(dllexport)
#else
#define MITDIFFAPI __declspec(dllimport)
#endif


//------------------------------------------------------------------------------
//
//	Support routines
//
//------------------------------------------------------------------------------

// Rotating hash from DDJ Sept. 97
inline unsigned
_HashString (const wchar_t *pwch, int cwch)
{
	int h = cwch;
	while (cwch--)
	{
		h = (h << 5) ^ (h >> 27) ^ *pwch++;
	}
	return h;
}


//------------------------------------------------------------------------------
//
//	Define the data types we want to diff
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Encapsulates a _bstr_t
class CBStr
{
public:
	CBStr () { }

	operator unsigned () const;								// Hash
	bool operator== (const CBStr& rhs) const;				// Compare

	_bstr_t m_bstr;
};

inline
CBStr::operator unsigned () const
{
	return _HashString (m_bstr, wcslen (m_bstr));
}

inline bool
CBStr::operator== (const CBStr& rhs) const
{
	return wcscmp (m_bstr, rhs.m_bstr) == 0;
}


//------------------------------------------------------------------------------
// Word (not zero-terminated) including word-class
class CWord
{
public:
	CWord () { }

	operator unsigned () const;								// Hash
	bool operator== (const CWord& rhs) const;				// Compare

	const wchar_t *m_pwchWord;
	int m_cwchWord;

	enum wordclass
	{
		wcWORD, wcSPACE, wcMIXED
	};
	wordclass m_wc;
};

inline
CWord::operator unsigned () const
{
	return _HashString (m_pwchWord, m_cwchWord);
}

inline bool
CWord::operator== (const CWord& rhs) const
{
	return m_wc == rhs.m_wc &&
			m_cwchWord == rhs.m_cwchWord &&
			memcmp (m_pwchWord, rhs.m_pwchWord, m_cwchWord * sizeof (wchar_t)) == 0;
}


//------------------------------------------------------------------------------
// Zero-terminated string + custom data
class CCustomString
{
public:
	CCustomString () { }

	operator unsigned () const;								// Hash
	bool operator== (const CCustomString& rhs) const;		// Compare

	const wchar_t *m_pwsz;
	DWORD m_custdata;
};

inline
CCustomString::operator unsigned () const
{
	return _HashString (m_pwsz, wcslen (m_pwsz));
}

inline bool
CCustomString::operator== (const CCustomString& rhs) const
{
	return m_custdata == rhs.m_custdata &&
			wcscmp (m_pwsz, rhs.m_pwsz) == 0;
}


//------------------------------------------------------------------------------
// Binary data block of size 16
class CBlob16
{
public:
	operator unsigned () const;								// Hash
	bool operator== (const CBlob16& rhs) const;				// Compare

	BYTE m_data[16];
};

inline
CBlob16::operator unsigned () const
{
	return _HashString ((const wchar_t *) m_data, 8);
}

inline bool
CBlob16::operator== (const CBlob16& rhs) const
{
	return memcmp (m_data, rhs.m_data, 16) == 0;
}


//------------------------------------------------------------------------------
//
//	Class holding diff result
//
//------------------------------------------------------------------------------

class CDiffResult
{
public:
	CByteArray m_abChanges1;
	CByteArray m_abChanges2;
	int m_iNumAdditions;
	int m_iNumDeletions;
	int m_iNumSubstitutions;
};


//------------------------------------------------------------------------------
//
//	Exported functions
//
//------------------------------------------------------------------------------

// Diff arrays of CBStr
void MITDIFFAPI Diff (
		const CBStr *aElems1,
		int iNumElems1,
		const CBStr *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CWord
void MITDIFFAPI Diff (
		const CWord *aElems1,
		int iNumElems1,
		const CWord *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CCustomString
void MITDIFFAPI Diff (
		const CCustomString *aElems1,
		int iNumElems1,
		const CCustomString *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of CBlob16
void MITDIFFAPI Diff (
		const CBlob16 *aElems1,
		int iNumElems1,
		const CBlob16 *aElems2,
		int iNumElems2,
		CDiffResult *result);

// Diff arrays of wchar_t (no class definition needed)
void MITDIFFAPI Diff (
		const wchar_t *aElems1,
		int iNumElems1,
		const wchar_t *aElems2,
		int iNumElems2,
		CDiffResult *result);


#endif	// !_MITDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\premidlenum.h ===
#undef BEGIN_ENUM
#define BEGIN_ENUM(name) \
	typedef enum \
	{

#undef ENUM_ENTRY
#define ENUM_ENTRY(typelib, name) \
	typelib##name,

#undef ENUM_ENTRY_
#define ENUM_ENTRY_(typelib, name, number) \
	typelib##name = number,

#undef MARK_ENTRY
#define MARK_ENTRY(name, enumconst)

#undef END_ENUM
#define END_ENUM(name) \
	} name;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\inc\profile.h ===
//-----------------------------------------------------------------------------
//  
//  File: profile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//
//  LocStudio  profile marks
//
//-----------------------------------------------------------------------------

#include "icecap\icapexp.h"

// Marks for profiling

// Note: numbers must be > 1000 

const long MARK_GRIDONPAINT1 = 1001;
const long MARK_GRIDONPAINT2 = 1002;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\blobfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: _blobfile.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_BLOBFILE_H
#define ESPUTIL_BLOBFILE_H


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Class CBlobFile is similar to CMemFile, except that it is implemented 
//	with a CLocCOWBlob
//------------------------------------------------------------------------------
//
//  The compiler worries when you export a class that has a base class
//  that is not exported.  Since I *know* that CFile is exported
//  tell the compliler that this really isn't a problem right here.
//
#pragma warning(disable : 4275)

class LTAPIENTRY CBlobFile : public CFile
{
	DECLARE_DYNAMIC(CBlobFile)

public:
	// Constructor
	CBlobFile(UINT nGrowBytes = 0);
	CBlobFile(const CLocCOWBlob &, UINT nGrowBytes = 0);
	
	virtual ~CBlobFile();

	virtual void AssertValid() const;
	UINT GetBlobSize(void) const;

	virtual DWORD GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual DWORD GetLength() const;
	virtual void SetLength(DWORD dwNewLen);
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount = 0,
		void** ppBufStart = NULL, void** ppBufMax = NULL);

	//
	//  These operators can't work on const objects, since they
	//  'fix up' the blob size.
	//
	operator const CLocCOWBlob &(void);
	const CLocCOWBlob &GetBlob(void);
	
	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);

protected:
	// Advanced Overridables
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, UINT nBytes);
	virtual void GrowFile(DWORD dwNewLen);

protected:
	// Implementation
	UINT m_nGrowBytes;	//unit of growth of 'm_blobData'
	const UINT cm_nDefaultGrowth; //default unit of growth
	DWORD m_nPosition;	//current position within file
	DWORD m_nFileSize;	//actual number of bytes written to the file
	CLocCOWBlob m_blobData; //file data
	BYTE * m_pBuffer;		//pointer to buffer in blob

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "blobfile.inl"
#endif

#endif  //  BLOBFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\counter.h ===
//-----------------------------------------------------------------------------
//  
//  File: counter.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_COUNTER_H
#define ESPUTIL_COUNTER_H


class LTAPIENTRY CCounter
{
public:
	CCounter(const TCHAR *);
	
	UINT operator++(void);
	UINT operator--(void);
	void operator+=(UINT);
	void operator-=(UINT);
	
	void Dump(void) const;
	
	~CCounter();
	
private:
	UINT m_uiCurCount;
	UINT m_uiMaxCount;
	UINT m_uiTotal;
	
	const TCHAR *m_szDescription;
};


//------------------------------------------------------------------------------
class LTAPIENTRY CSmartCheck
{
public:
	CSmartCheck(DWORD dwFreqMilli = 2000);

	void Reset();
	BOOL Check();

protected:
	DWORD	m_dwFreqMilli;
	DWORD	m_dwCancelTickMin;	// prevents calling fCancel() too often
	DWORD	m_dwCancelTickMax;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\blobfile.inl ===
//-----------------------------------------------------------------------------
//  
//  File: _blobfile.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the position with in the file. The position can be set (by calling
//	'Seek()') beyond the end of the data in the file, even beyond the space 
//	allocated for the file. In any case, 'Read()' and 'Write()' will deal with
//	that.
//------------------------------------------------------------------------------
inline
DWORD	//Returns current file position 
CBlobFile::GetPosition() const
{
	ASSERT_VALID(this);
	return m_nPosition;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Gets the actual data size in the file, which is what determines the end
//	of file during readings.
//------------------------------------------------------------------------------
inline
DWORD	//Returns the file data length in bytes.
CBlobFile::GetLength() const
{
	ASSERT_VALID(this);
	return m_nFileSize; 
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Since we keep the file in memory always, we don't need to flush.
//------------------------------------------------------------------------------
inline
void CBlobFile::Flush()
{
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Aborting is like closing.
//------------------------------------------------------------------------------
inline
void CBlobFile::Abort()
{
	ASSERT_VALID(this);

	Close();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
void CBlobFile::LockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline 
void CBlobFile::UnlockRange(DWORD /* dwPos */, DWORD /* dwCount */)
{
	AfxThrowNotSupportedException();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Unsupported function
//------------------------------------------------------------------------------
inline
CFile* CBlobFile::Duplicate() const
{
	AfxThrowNotSupportedException();
	return NULL;
}

inline
UINT CBlobFile::GetBlobSize(void) const
{
	ASSERT_VALID(this);
	return m_blobData.GetBlobSize();
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	That's the only way to that a caller can have access to the buffer data
//	of the blobfile's internal cowblob.	  
//  
//-----------------------------------------------------------------------------
inline
CBlobFile::operator const CLocCOWBlob &(void)
{
	return GetBlob();
}

inline
const CLocCOWBlob &
CBlobFile::GetBlob(void)
{
 	if (m_pBuffer != NULL)
	{
		m_blobData.ReleasePointer();
		m_pBuffer = NULL;
	}
	//Set correct requested cowblob size before giving access to the data.
	m_blobData.ReallocBlob(m_nFileSize);
	return m_blobData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\clstring.inl ===
//-----------------------------------------------------------------------------
//  
//  File: clstring.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All these methods re-direct to the CString methods.
//  
//-----------------------------------------------------------------------------
inline
CLString::CLString()
		:
		CString()
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const CLString &stringSrc)
		:
		CString(stringSrc)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		TCHAR ch,
		int nRepeat)
		:
		CString(ch, nRepeat)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCSTR lpsz)
		:
		CString(lpsz)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		LPCTSTR lpch,
		int nLength)
		:
		CString(lpch, nLength)
{
	DEBUGONLY(++m_UsageCounter);
}

inline
CLString::CLString(
		const unsigned char * psz)
		:
		CString(psz)
{
	DEBUGONLY(++m_UsageCounter);
}



inline
CLString::CLString(
		HINSTANCE hDll,
		UINT uiStringID)
{
	LTVERIFY(LoadString(hDll, uiStringID));
	DEBUGONLY(++m_UsageCounter);
}



inline 
const CLString &
CLString::operator=(
		const CString& stringSrc)
{
	CString::operator=(stringSrc);

	return *this;
}

inline
const CLString &
CLString::operator=(
		TCHAR ch)
{
	CString::operator=(ch);

	return *this;
}


#ifdef _UNICODE

inline
const CLString &
CLString::operator=(
		char ch)
{
	CString::operator=(ch);

	return *this;
}

#endif //  _UNICODE

inline
const CLString &
CLString::operator=(
		LPCSTR lpsz)
{
	CString::operator=(lpsz);

	return *this;
}

inline
const CLString &
CLString::operator=(
		const unsigned char * psz)
{
	CString::operator=(psz);

	return *this;
}

inline
const CLString &
CLString::operator+=(
		const CString & string)
{
	CString::operator+=(string);

	return *this;
}



inline 
const CLString &
CLString::operator+=(
		TCHAR ch)
{
	CString::operator+=(ch);

	return *this;
}

		

#ifdef _UNICODE

inline
const CLString &
CLString::operator+=(
		char ch)
{
	CString::operator+=(ch);

	return *this;
}

#endif  // _UNICODE

inline
const CLString &
CLString::operator+=(
		LPCTSTR lpsz)
{
	CString::operator+=(lpsz);

	return *this;
}


inline
CLString
CLString::operator+(
		const CString &str)
		const
{
	return CLString(*this)+=str;
}



inline
CLString
CLString::operator+(
		const TCHAR *sz)
		const
{
	return CLString(*this)+=sz;
}



inline
void
CLString::Format(
		LPCTSTR lpszFormat, ...)
{

	//
	//  This stolen from CString::Format()
	//
	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
	
}

inline
void
CLString::Format(
		HMODULE hResourceModule,
		UINT nFormatID, ...)
{
	CLString strFormat;
	LTVERIFY(strFormat.LoadString(hResourceModule, nFormatID) != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}


#ifdef _DEBUG
inline
CLString::~CLString()
{
	DEBUGONLY(--m_UsageCounter);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\cowblob.h ===
//-----------------------------------------------------------------------------
//  
//  File: cowblob.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Copy-On-Write (COW) blob class.  Hold binary information, but only copies
//  the data when it's written to.
//  
//  Owner: MHotchin
//
//  Code Review Status: Reviewed
//
//-----------------------------------------------------------------------------
 
#ifndef COWBLOB_H
#define COWBLOB_H


class LTAPIENTRY CLocCOWBlob 
{
public:
	CLocCOWBlob();
	CLocCOWBlob(const CLocCOWBlob &);

	void AssertValid(void) const;

	LTASSERTONLY(UINT GetWriteCount(void) const);
	
	UINT GetBlobSize(void) const;
	void SetBlobSize(UINT);
	void ReallocBlob(UINT);
	void SetGrowSize(UINT);
	
	void *GetPointer(void);
	void ReleasePointer(void);
	void SetBuffer(const void *, size_t);
	
	operator const void *(void) const;

	const CLocCOWBlob &operator=(const CLocCOWBlob &);
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	~CLocCOWBlob();

	//  Comparison operators
	//
	NOTHROW int operator==(const CLocCOWBlob &) const;
	NOTHROW int operator!=(const CLocCOWBlob &) const;

protected:

private:
	typedef struct
	{
		DWORD RefCount;
		DWORD AllocSize;
		DWORD RequestedSize;
	} BlobHeader;

	NOTHROW void Attach(const CLocCOWBlob &);
	NOTHROW void Detach(void);
	NOTHROW void MakeWritable(void);
	NOTHROW BYTE * DataPointer(void) const;
	NOTHROW BlobHeader * GetBlobHeader(void);
	NOTHROW const BlobHeader * GetBlobHeader(void) const;
	NOTHROW DWORD & GetRefCount(void);
	NOTHROW DWORD GetAllocatedSize(void) const;
	NOTHROW DWORD GetRequestedSize(void) const;
	NOTHROW DWORD CalcNewSize(DWORD) const;
	BOOL Compare(const CLocCOWBlob &) const;
	
	BYTE *m_pBuffer;
	DWORD m_WriteCount;
	UINT m_uiGrowSize;
	static const UINT m_uiDefaultGrowSize;

#ifdef _DEBUG
	static CCounter m_UsageCounter;
	void FillEndZone(void);
	void CheckEndZone();
#endif
	
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "cowblob.inl"
#endif

#endif // COWBLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\clstring.h ===
//-----------------------------------------------------------------------------
//  
//  File: clstring.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef CLSTRING_H
#define CLSTRING_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLString : public CString
{
public:
	CLString();
	CLString(const CLString& stringSrc);
	CLString(TCHAR ch, int nRepeat = 1);
	CLString(LPCSTR lpsz);
	CLString(LPCTSTR lpch, int nLength);
	CLString(const unsigned char* psz);
	CLString(HINSTANCE, UINT);
	
	BOOL ReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bMatchCase);

	// overloaded assignment
	NOTHROW const CLString& operator=(const CString& stringSrc);
	
	NOTHROW const CLString& operator=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator=(char ch);
#endif
	NOTHROW const CLString& operator=(LPCSTR lpsz);
	NOTHROW const CLString& operator=(const unsigned char* psz);

	// string concatenation
	NOTHROW const CLString& operator+=(const CString &);
	NOTHROW const CLString& operator+=(TCHAR ch);
#ifdef _UNICODE
	NOTHROW const CLString& operator+=(char ch);
#endif
	NOTHROW const CLString& operator+=(LPCTSTR lpsz);

	CLString operator+(const CString &) const;
	CLString operator+(LPCTSTR sz) const;

	NOTHROW BOOL LoadString(HMODULE, UINT nId);

	//
	//  The following were copied from CString so we can
	//  'overload' them.

	NOTHROW void Format(LPCTSTR lpszFormat, ...);
	NOTHROW void Format(HMODULE, UINT nFormatID, ...);

	enum ECRLF
	{
		eNone	= 0,
		eCR		= 0x0001,		// '\r'
		eLF		= 0x0002,		// '\n'
		eAll	= eCR | eLF
	};
	void FixCRLF(UINT nCRLF, LPCTSTR pszIndent = NULL);

	DEBUGONLY(~CLString());
protected:

private:
	DEBUGONLY(static CCounter m_UsageCounter);

	//
	//  Evil!  Implicit Unicode conversions!
	CLString(LPCWSTR lpsz);
	NOTHROW const CLString& operator=(LPCWSTR lpsz);
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

};

#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clstring.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\cowblob.inl ===
//-----------------------------------------------------------------------------
//  
//  File: cowblob.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for CLocCOWBlob.  This file should only be used by
//  cowblob.h
//  
//  Owner: MHotchin
//
//  Code Review Status: Reviewed
//
//-----------------------------------------------------------------------------
 


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the blob.  Set the current size to zero.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::CLocCOWBlob()
{
	m_pBuffer = NULL;
	m_WriteCount = 0;

	m_uiGrowSize = m_uiDefaultGrowSize;

	DEBUGONLY(++m_UsageCounter);
}




#ifdef LTASSERT_ACTIVE
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the number of outstanding GetPointer()'s there are.
//  DEBUGONLY method!
//
//-----------------------------------------------------------------------------
inline
UINT
CLocCOWBlob::GetWriteCount(void)
		const
{
	return m_WriteCount;
}

#endif // _DEBUG



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the granularity for memory allocations.  Memory will always be
//  allocated in amounts that are a multiple of the GrowSize.  This can be
//  useful if you are making small incremental reallocs - by setting a larger
//  grow size, you will allocate memory less often (but some may end up
//  being unused).
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::SetGrowSize(
		UINT uiGrowSize)
{
	LTASSERT(uiGrowSize != 0);
	
	if (uiGrowSize == 0)
	{
		m_uiGrowSize = m_uiDefaultGrowSize;
	}
	else
	{
		m_uiGrowSize = uiGrowSize;
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Release a writable pointer.  GetPointer and ReleasePointer should be
//  paired.
//  
//-----------------------------------------------------------------------------
inline
void
CLocCOWBlob::ReleasePointer(void)
{
	LTASSERT(m_WriteCount != 0);

	if (m_WriteCount != 0)
	{
		m_WriteCount--;
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Return a read only pointer to storage.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::operator const void *(void)
		const
{
	return DataPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor.  Just detaches this blob from the user memory.
//  
//-----------------------------------------------------------------------------
inline
CLocCOWBlob::~CLocCOWBlob()
{
	DEBUGONLY(CLocCOWBlob::AssertValid());
	
	Detach();

	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob NOT equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs are NOT identical
CLocCOWBlob::operator!=(
		const CLocCOWBlob & SourceBlob)
		const
{
	return !Compare(SourceBlob);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the data of this blob IS equal to the data in the given blob?
//
//-----------------------------------------------------------------------------
inline
int										//TRUE if both blobs ARE identical
CLocCOWBlob::operator==(
		const CLocCOWBlob & SourceBlob)
		const
{
	return Compare(SourceBlob);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\diff.h ===
//-----------------------------------------------------------------------------
//  
//  File: diff.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of the following classes needed for string differencing:
//	CDifference, CDelta, CDeltaVisitor, CDiffAlgorithm, CDiffAlgortihmFactory,
//	CDiffEngine  
//-----------------------------------------------------------------------------
 
#ifndef DIFF_H
#define DIFF_H


class CDifference;
class CDeltaVisitor;
class CDelta;
class CDiffAlgorithm;
class CDiffAlgortihmFactory;
class CDiffEngine;

class CDifference // Represents each of the elements in a CDelta object
{
public:
	virtual ~CDifference();
	enum ChangeType
	{
		NoChange,
		Added,
		Deleted
	};
	virtual ChangeType GetChangeType() const = 0;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const = 0; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const = 0; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const = 0;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const = 0; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const = 0; //append this string to unit string
	virtual bool IsFirst() const = 0; //is this first difference in delta?
	virtual bool IsLast() const = 0; //is this last difference in delta?
};

class LTAPIENTRY CDeltaVisitor
{
public:
	//called for each element in a CDelta
	virtual void VisitDifference(const CDifference & diff) const = 0; 
};

class CDelta // sequence of CDifference elements
{
public:
	virtual ~CDelta();
	// Starts a visit to all CDifference elements in CDelta
	virtual void Traverse(const CDeltaVisitor & dv) = 0; 
};

class LTAPIENTRY CDiffAlgorithm
{
public:
	virtual ~CDiffAlgorithm();
	// Computes a CDelta object based on a certain diff algorithm
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2) = 0; 
};

// Encapsulates the creation of the diff algorithm
class LTAPIENTRY CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm() = 0;
};



// Generic diff engine that calculates delta and processes each difference in it
class LTAPIENTRY CDiffEngine
{
public:
	static void Diff(CDiffAlgorithm & diffalg, 
		const wchar_t * seq1, 
		const wchar_t * seq2, 
		const CDeltaVisitor & dv);
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "diff.inl"
#endif

#endif  //  DIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\dllvars.h ===
//-----------------------------------------------------------------------------
//  
//  File: dllvars.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

extern HINSTANCE g_hMITUtilDll;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\gnudiffalg.h ===
//-----------------------------------------------------------------------------
//  
//  File: gnudiffalg.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of the CGNUDiffAlgorithm, CGNUDiffAlgFact
//-----------------------------------------------------------------------------
 
#ifndef GNUDIFFALG_H
#define GNUDIFFALG_H

#include "diff.h"

class LTAPIENTRY CGNUDiffAlgorithm : public CDiffAlgorithm
{
public:
	virtual CDelta * CalculateDelta(
		const wchar_t * seq1, 
		const wchar_t * seq2); 
};

class LTAPIENTRY CGNUDiffAlgFact : public CDiffAlgorithmFactory
{
public:
	virtual CDiffAlgorithm * CreateDiffAlgorithm();
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "gnudiffalg.inl"
#endif

#endif  //  GNUDIFFALG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\flushmem.h ===
//-----------------------------------------------------------------------------
//  
//  File: flushmem.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFlushMemory : public CObject
{
public:
	CFlushMemory(BOOL fDelete);

	virtual void FlushMemory(void) = 0;

	void Delete(void);

private:
	CFlushMemory();
	CFlushMemory(const CFlushMemory &);
	void operator=(const CFlushMemory &);

	BOOL m_fDelete;
};



class LTAPIENTRY CMinWorkSet : public CFlushMemory
{
public:
	CMinWorkSet(BOOL fDelete);
	
	void FlushMemory(void);
};



#pragma warning(default: 4275)

void LTAPIENTRY NOTHROW AddFlushClass(CFlushMemory *);
BOOL LTAPIENTRY NOTHROW RemoveFlushClass(CFlushMemory *);

void LTAPIENTRY FlushMemory(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\diff.inl ===
//-----------------------------------------------------------------------------
//  
//  File: diff.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
inline
CDifference::~CDifference()
{
}

inline
CDelta::~CDelta()
{
}

inline
CDiffAlgorithm::~CDiffAlgorithm()
{
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Calculates the delta following the given algorithm and then traverses
//	the delta and calls back the delta visitor for each difference in the delta.
//------------------------------------------------------------------------------
inline
void 
CDiffEngine::Diff(
	CDiffAlgorithm & diffalg, 
	const wchar_t * seq1, // [in] old sequence
	const wchar_t * seq2, // [in] new sequence
	const CDeltaVisitor & dv)
{
	CDelta * d;
	d = diffalg.CalculateDelta(seq1, seq2);
	d->Traverse(dv);
	delete d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\espnls.h ===
//-----------------------------------------------------------------------------
//  
//  File: espnls.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Language support functions for Espresso.
//  
//-----------------------------------------------------------------------------
 

#ifndef ESPUTIL_ESPNLS_H
#define ESPUTIL_ESPNLS_H


typedef int CodePage;
const CodePage cpInvalidCodePage = 0xDEADBEEF;
const CodePage US_ACP = 1252;

typedef WORD LangId;
const int BAD_LOCALE = 0xFFFF;

enum CodePageType
{
	cpUnknown,
	cpAnsi,
	cpDos,
	cpMac,
	cpUnicode
};


struct LanguageInfo
{
	LangId lid;
	CodePage cpAnsi;
	CodePage cpDos;
	CodePage cpMac;
	const TCHAR *szName;
	const TCHAR *szShortName;
	WORD fLangFlags;
};

const WORD lfNoFlags = 0;
const WORD lfDBCSHotKey = 0x0001;

typedef void (*pfnLangHandler)(const LanguageInfo &, void *);

class LTAPIENTRY CLocLangId 
{
public:
	CLocLangId(void);
	
	LTASSERTONLY(void AssertValid(void) const);

	NOTHROW LangId GetLanguageId(void) const;
	NOTHROW CodePage GetCodePage(CodePageType) const;
	NOTHROW void GetLangName(CLString &) const;
	NOTHROW void GetLangShortName(CLString &) const;
	
	NOTHROW BOOL SetLanguageId(LangId);
	NOTHROW const CLocLangId & operator=(const CLocLangId &);
	
	NOTHROW int operator==(const CLocLangId &) const;
	NOTHROW int operator!=(const CLocLangId &) const;
	
	NOTHROW static UINT GetNumLangInfo(void);
	static void EnumerateLanguages(pfnLangHandler, void *);
	static void Enumerate(CEnumCallback &);
	NOTHROW static BOOL IsDBCSHotKey(LangId);
	NOTHROW BOOL IsDBCSHotKey(void) const;
	NOTHROW static BOOL IsValidLangId(LangId lid);
	
	LTASSERTONLY(~CLocLangId());
	
private:
	//
	//  Private implementation.
	//
	NOTHROW static const LanguageInfo & LocateLangInfo(LangId);
	NOTHROW static const LanguageInfo & GetLangInfo(UINT);
	
	//
	//  Private data.
	//
	LangId m_lid;
	const LanguageInfo *m_pLangInfo;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "espnls.inl"
#endif

#endif // ESPUTIL_ESPNLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\edithelp.h ===
//******************************************************************************
//  
//  EditHelp.h
//
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//******************************************************************************

#if !defined(MITUTIL__EditHelp_h__INCLUDED)
#define MITUTIL__EditHelp_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY EditHelp
{
	static BOOL SetTopLine(CEdit * pebc, int iLine);

	static BOOL CanUndo(CEdit * pebc);
	static BOOL CanRedo(CEdit * pebc);
	static BOOL CanCut(CEdit * pebc);
	static BOOL CanClear(CEdit * pebc);
	static BOOL CanPaste(CEdit * pebc);
	static BOOL CanCopy(CEdit * pebc);
	static BOOL CanSelectAll(CEdit * pebc);

	static BOOL Undo(CEdit * pebc);
	static BOOL Redo(CEdit * pebc);
	static void Cut(CEdit * pebc);
	static void Copy(CEdit * pebc);
	static void Clear(CEdit * pebc);
	static void Paste(CEdit * pebc);
	static void SelectAll(CEdit * pebc);
	
	static BOOL IsReadOnly(CEdit * pebc);
	static BOOL IsEnabled(CEdit * pebc, UINT nCmdID);

	static BOOL DoEditCmd(CEdit * pebc, UINT nCmdID);
};

#endif // MITUTIL__EditHelp_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\espnls.inl ===
//-----------------------------------------------------------------------------
//  
//  File: espnls.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the language id object.  This file should ONLY be
//  included by espnls.h
//  
//-----------------------------------------------------------------------------
 

inline
LangId
CLocLangId::GetLanguageId(void)
		const
{
	return m_lid;
}



inline
void
CLocLangId::GetLangName(
		CLString &strLangName)
		const
{
	LTASSERT(m_lid != 0);
	
	strLangName = m_pLangInfo->szName;
}



inline
void
CLocLangId::GetLangShortName(
		CLString &strLangShortName)
		const
{

	strLangShortName = m_pLangInfo->szShortName;
}



inline
int
CLocLangId::operator==(
		const CLocLangId &lidOther)
		const
{
	return (m_lid == lidOther.GetLanguageId());
}



inline
int
CLocLangId::operator!=(
		const CLocLangId &lidOther)
		const
{
	return !operator==(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\listdelta.h ===
//-----------------------------------------------------------------------------
//  
//  File: listdelta.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of CListDelta
//-----------------------------------------------------------------------------
 
#ifndef LISTDELTA_H
#define LISTDELTA_H

#include "diff.h"

class CListDelta : public CDelta, public CList<CDifference *, CDifference * &>
{
public:
	virtual ~CListDelta();
	virtual void Traverse(const CDeltaVisitor & dv); 
};

#endif  //  LISTDELTA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\imagehelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: imagehelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  This file is a re-director for IMAGEHLP.DLL.  Rather than linking directly
//  with the DLL (which may not exist on Win 95 systems), this class will
//  dynamically load IMAGEHLP.DLL and then provide certain functions from it.
//  The functions currently available are those that I found immediately
//  useful, so this is not a complete list of IMAGEHLP functionality.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_IMAGEHLP_H
#define ESPUTIL_IMAGEHLP_H




class LTAPIENTRY CImageHelp
{
public:
	CImageHelp();
	BOOL ImagehlpAvailable(void);
			
	BOOL EnumerateLoadedModules(HANDLE, PENUMLOADED_MODULES_CALLBACK, void *);
	PIMAGE_NT_HEADERS ImageNtHeader(LPVOID);

	LPAPI_VERSION ImagehlpApiVersion(void);
	BOOL StackWalk(
			DWORD                             MachineType,
			HANDLE                            hProcess,
			HANDLE                            hThread,
			LPSTACKFRAME                      StackFrame,
			LPVOID                            ContextRecord,
			PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
			PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
			PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
			PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
		);

	BOOL SymGetModuleInfo(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PIMAGEHLP_MODULE    ModuleInfo
		);
	LPVOID SymFunctionTableAccess(
			HANDLE  hProcess,
			DWORD   AddrBase
		);

	BOOL SymGetSymFromAddr(
			IN  HANDLE              hProcess,
			IN  DWORD               dwAddr,
			OUT PDWORD              pdwDisplacement,
			OUT PIMAGEHLP_SYMBOL    Symbol
		);

	BOOL SymInitialize(
			IN HANDLE   hProcess,
			IN LPSTR    UserSearchPath,
			IN BOOL     fInvadeProcess
		);

	BOOL SymUnDName(
			IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
			OUT LPSTR            UnDecName,         // Buffer to store undecorated name in
			IN  DWORD            UnDecNameLength    // Size of the buffer
		);

	DWORD SymLoadModule(
			IN  HANDLE          hProcess,
			IN  HANDLE          hFile,
			IN  PSTR            ImageName,
			IN  PSTR            ModuleName,
			IN  DWORD           BaseOfDll,
			IN  DWORD           SizeOfDll
		);
	DWORD UnDecorateSymbolName(
			LPSTR    DecoratedName,         // Name to undecorate
			LPSTR    UnDecoratedName,       // If NULL, it will be allocated
			DWORD    UndecoratedLength,     // The maximym length
			DWORD    Flags                  // See IMAGEHLP.H
		);

	DWORD SymGetOptions(void);
	DWORD SymSetOptions(DWORD);
	
	PIMAGE_NT_HEADERS CheckSumMappedFile(
	    LPVOID BaseAddress,
	    DWORD FileLength,
	    LPDWORD HeaderSum,
	    LPDWORD CheckSum
	    );

	BOOL MakeSureDirectoryPathExists(const TCHAR *);
	
private:

	void LoadImageHelp(void);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\locid.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locid.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  In line definitions for the CLocID class.  This fgile should ONLY be
//  included by locid.h
//  
//-----------------------------------------------------------------------------
 

//-----------------------------------------------------------------------------
//  
//  Implementation.  Clears the contents of the ID.  Both parts are marked
//  invalid.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::ClearId(void)
{
	m_fHasNumericId = FALSE;
	m_fHasStringId = FALSE;

	m_ulNumericId = 0;
	m_pstrStringId.ClearString();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constuctor for a localization ID.  Sets it to have no valid ID.
//  
//-----------------------------------------------------------------------------
inline
CLocId::CLocId()
{
	ClearId();

	DEBUGONLY(++m_UsageCounter);
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the numeric ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL                              //  TRUE means the numeric ID is valid
CLocId::HasNumericId(void)
		const
{
	return m_fHasNumericId;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Tests if the string ID is valid.
//  
//-----------------------------------------------------------------------------
inline
BOOL							        //  TRUE means the string ID is valid
CLocId::HasStringId(void)
		const
{
	return m_fHasStringId;
}



inline
BOOL
CLocId::IsNull(void)
		const
{
	return
		!HasStringId() &&
		!HasNumericId();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current numeric ID.  If the ID is invalid, the ID will be
//  zero.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		ULONG &ulNumericId)				// Location to put ID
		const
{
	ulNumericId = m_ulNumericId;
	
	return m_fHasNumericId;
}

		

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current string ID.  If the ID is invalid, it will be a NULL
//  string.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE indicates the ID is valid
CLocId::GetId(
		CPascalString &pstrStringId)	// Location to put the ID.
		const
{
	pstrStringId = m_pstrStringId;
	
	return m_fHasStringId;
}


//-----------------------------------------------------------------------------
//  
//  Checks if the ID has been assigned to before.  If it has, throw an
//  exception.
//  
//-----------------------------------------------------------------------------
inline
void
CLocId::CheckPreviousAssignment(void)
		const
{
	if (m_fHasStringId || m_fHasNumericId)
	{
		AfxThrowNotSupportedException();
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Compares two ID's to see if they are the same.  
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator==(
		const CLocId &lidOther)			// ID to compare to
		const
{
	return IsIdenticalTo(lidOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Checks for in-equality between two ID's
//  
//-----------------------------------------------------------------------------
inline
int
CLocId::operator!=(
		const CLocId &lidOther)
		const
{
	return !IsIdenticalTo(lidOther);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\loadlib.h ===
//-----------------------------------------------------------------------------
//  
//  File: loadlib.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class to manage LoadLibray/FreeLibary style DLL usage.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOADLIB_H
#define ESPUTIL_LOADLIB_H


#pragma warning(disable : 4251)
class LTAPIENTRY CLoadLibrary
{
public:
	NOTHROW CLoadLibrary(void);
	NOTHROW CLoadLibrary(const CLoadLibrary &);

	NOTHROW BOOL LoadLibrary(const TCHAR *szFileName);
	NOTHROW BOOL FreeLibrary(void);

	NOTHROW void WrapLibrary(HINSTANCE);
	
	NOTHROW void operator=(const CLoadLibrary &);

	NOTHROW HINSTANCE GetHandle(void) const;
	NOTHROW HINSTANCE ExtractHandle(void);
	NOTHROW operator HINSTANCE(void) const;

	NOTHROW FARPROC GetProcAddress(const TCHAR *) const;
	
	NOTHROW const CString & GetFileName(void) const;
	
	NOTHROW ~CLoadLibrary();
	
private:
	CString m_strFileName;
	HINSTANCE m_hDll;
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "loadlib.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\gnudiffalg.inl ===
//-----------------------------------------------------------------------------
//  
//  File: gnudiffalg.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline implementation of CDumbDiffAlgorithm, CDumbDiffAlgFact
//-----------------------------------------------------------------------------
 
inline 
CDiffAlgorithm * 
CGNUDiffAlgFact::CreateDiffAlgorithm()
{
	return new CGNUDiffAlgorithm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\loadlib.inl ===
//-----------------------------------------------------------------------------
//  
//  File: loadlib.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------


inline
CLoadLibrary::CLoadLibrary(void)
{
	m_hDll = NULL;
}



inline
HINSTANCE
CLoadLibrary::GetHandle(void)
		const
{
	return m_hDll;
}



inline
CLoadLibrary::operator HINSTANCE(void)
		const
{
	return GetHandle();
}



inline
HINSTANCE
CLoadLibrary::ExtractHandle(void)
{
	HINSTANCE hReturn;

	hReturn = m_hDll;

	m_strFileName.Empty();
	m_hDll = NULL;

	return hReturn;
}

	   

inline
const CString &
CLoadLibrary::GetFileName(void)
		const
{
	return m_strFileName;
}



inline
BOOL
CLoadLibrary::LoadLibrary(
		const TCHAR *szFileName)
{
	LTASSERT(m_hDll == NULL);
	   
	m_strFileName = szFileName;
	m_hDll = AfxLoadLibrary(m_strFileName);

	return (m_hDll != NULL);
}



inline
void
CLoadLibrary::WrapLibrary(
		HINSTANCE hDll)
{
	m_hDll = hDll;
}



inline
CLoadLibrary::CLoadLibrary(
		const CLoadLibrary &llSource)
{
	m_hDll = NULL;

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
void
CLoadLibrary::operator=(
		const CLoadLibrary &llSource)
{
	LTASSERT(m_hDll == NULL);

	if (llSource.GetHandle() != NULL)
	{
		LoadLibrary(llSource.GetFileName());
	}
}



inline
FARPROC
CLoadLibrary::GetProcAddress(
		const TCHAR *szProcName)
		const
{
	FARPROC fpFunction = NULL;
	
	if (m_hDll != NULL)
	{
		fpFunction = ::GetProcAddress(m_hDll, szProcName);
	}

	return fpFunction;
}



inline
BOOL
CLoadLibrary::FreeLibrary(void)
{
	BOOL fRetVal = TRUE;
	
 	if (m_hDll != NULL)
	{
		fRetVal = AfxFreeLibrary(m_hDll);
		m_hDll = NULL;
		m_strFileName.Empty();
	}

	return fRetVal;
}



inline
CLoadLibrary::~CLoadLibrary()
{
	FreeLibrary();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\locid.h ===
//-----------------------------------------------------------------------------
//  
//  File: locid.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  This is the definition of a localization ID.  It makes up part of the
//  localization unique ID, and is eesentially the implementation for
//  CLocResId and CLocTypeId.
//  
//-----------------------------------------------------------------------------
 
#ifndef LOCID_H
#define LOCID_H

#pragma warning(disable : 4275)

class LTAPIENTRY CLocId : public CObject
{
public:
	NOTHROW CLocId();

	void AssertValid(void) const;

	BOOL NOTHROW HasNumericId(void) const;
	BOOL NOTHROW HasStringId(void) const;
	BOOL NOTHROW IsNull(void) const;
	
	BOOL NOTHROW GetId(ULONG &) const;
	BOOL NOTHROW GetId(CPascalString &) const;

	void NOTHROW GetDisplayableId(CPascalString &) const;

	//
	//  These 'set' functions are 'write once'.  Once the ID has been
	//  set, it can't be changed.  Trying to set the ID again will
	//  cause an AfxNotSupportedException to be thrown.
	//
	void SetId(ULONG);
	void SetId(const CPascalString &);
	void SetId(const WCHAR *);
	void SetId(ULONG, const CPascalString &);
	void SetId(ULONG, const WCHAR *);
	
	const CLocId &operator=(const CLocId &);

	void NOTHROW ClearId(void);
	
	int NOTHROW operator==(const CLocId &) const;
	int NOTHROW operator!=(const CLocId &) const;

	virtual void Serialize(CArchive &ar);

	virtual ~CLocId();

protected:
	//
	//  Internal implementation functions.
	//
	BOOL NOTHROW IsIdenticalTo(const CLocId&) const;
	void NOTHROW CheckPreviousAssignment(void) const;
	 
private:
	//
	//  This prevent the default copy constructor from being
	//  called.
	//
	CLocId(const CLocId&);

	ULONG m_ulNumericId;            //  The numeric ID of the resource
	CPascalString m_pstrStringId;   //  The string ID of the resource
	BOOL m_fHasNumericId :1;		//  Indicates if the numeric ID is valid
	BOOL m_fHasStringId  :1;		//  Indicates if the string ID is valid

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_DisplayCounter);
};
#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locid.inl"
#endif

#endif  //  LOCID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\locvar.inl ===
//-----------------------------------------------------------------------------
//  
//  File: locvar.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Inline functions for the variant class.  This should ONLY be included from
//  locvar.h
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor.  Sets the variant type to none ie no value is in
//  the variant.
//  
//-----------------------------------------------------------------------------
inline
CLocVariant::CLocVariant()
{
	m_VarType = lvtNone;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the type of the data in the variant.
//  
//-----------------------------------------------------------------------------
inline
LocVariantType
CLocVariant::GetVariantType(void)
		const
{
	return m_VarType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the integer data in the variant.  The data must have been set
//  previously as an integer.
//  
//-----------------------------------------------------------------------------
inline
DWORD
CLocVariant::GetDword(void)
		const
{
	LTASSERT(m_VarType == lvtInteger || m_VarType == lvtStringList);

	if (m_VarType == lvtInteger)
	{
		return m_dwInteger;
	}
	else
	{
		return m_StringList.GetIndex();
	}
}



inline
BOOL
CLocVariant::GetBOOL(void)
		const
{
	LTASSERT(m_VarType == lvtBOOL);
	
	return m_fBOOL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the string data in the variant.  The data must have been set
//  previously as an string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &
CLocVariant::GetString(void)
		const
{
	LTASSERT(m_VarType == lvtString || m_VarType == lvtFileName);
		
	return m_psString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the dual string/integer data in the variant.  The data must have
//  been set previously as an dual string/integer.
//  
//-----------------------------------------------------------------------------
inline
const CLocId &
CLocVariant::GetIntPlusString(void)
		const
{
	LTASSERT(m_VarType == lvtIntPlusString);

	return m_IntPlusString;
}



inline
const CLocCOWBlob &
CLocVariant::GetBlob(void)
		const
{
	LTASSERT(m_VarType == lvtBlob);

	return m_Blob;
}



inline
const CPasStringList &
CLocVariant::GetStringList(void)
		const
{
	LTASSERT(m_VarType == lvtStringList);

	return m_StringList;
}

inline
const CLString & 
CLocVariant::GetFileExtensions(void) 
	const
{
	LTASSERT(m_VarType == lvtFileName);

	return m_strFileExtensions;
}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator==(
		const CLocVariant &lvOther)
		const
{

	return IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator.
//  
//-----------------------------------------------------------------------------
inline
int
CLocVariant::operator!=(
		const CLocVariant &lvOther)
		const
{
	return !IsEqualTo(lvOther);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to an integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetDword(
		const DWORD dwNewValue)
{
	m_VarType = lvtInteger;

	m_dwInteger = dwNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetBOOL(
		const BOOL fNewValue)
{
	m_VarType = lvtBOOL;

	m_fBOOL = fNewValue;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a CPascalString value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetString(
		const CPascalString &psNewValue)
{
	m_VarType = lvtString;

	m_psString = psNewValue;
}

inline
void 
CLocVariant::SetFileName(
	const CPascalString &psNewValue,
	const CLString & strExtensions)
{
	m_VarType = lvtFileName;

	m_psString = psNewValue;
	m_strFileExtensions = strExtensions;

}	


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the variant to a dual string/integer value.
//  
//-----------------------------------------------------------------------------
inline
void
CLocVariant::SetIntPlusString(
		const CLocId &NewIntPlusString)
{
	m_VarType = lvtIntPlusString;

	m_IntPlusString = NewIntPlusString;
}



inline
void
CLocVariant::SetBlob(
		const CLocCOWBlob &blbNewValue)
{
	m_VarType = lvtBlob;

	m_Blob = blbNewValue;
}



inline
void
CLocVariant::SetStringList(
		const CPasStringList &slNewValue)
{
	m_VarType = lvtStringList;

	m_StringList = slNewValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\ltdebug.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltdebug.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Debugging facilities for Espresso 2.x.  Included are augmented TRACE
//  and ASSERT facilities.
//  
//-----------------------------------------------------------------------------
 
#ifndef MITUTIL_LtDebug_h_INCLUDED
#define MITUTIL_LtDebug_h_INCLUDED

#pragma once


#if defined(_DEBUG)
#define LTTRACE_ACTIVE
#define LTASSERT_ACTIVE

#define new DEBUG_NEW
#define LTGetAllocNumber() LTGetAllocNumberImpl()

//
//  Executes code only in a DEBUG build.
//
#define DEBUGONLY(x) x

#define LTDebugBreak() LTBreak()

#else  // _DEBUG

#define DEBUGONLY(x) 

#define LTDebugBreak() (void) 0
#define LTGetAllocNumber() 0

#endif  // _DEBUG

#if defined(LTASSERT_ACTIVE) || defined (ASSERT_ALWAYS)
#ifdef ASSERT
#undef ASSERT
#endif
#ifdef VERIFY
#undef VERIFY
#endif
#define ASSERT LTASSERT
#define VERIFY LTVERIFY

#ifndef _DEBUG
#pragma message("Warning: LTASSERT Active in non-debug build")
#endif
//
// The multilevel assert macros ensure that the line numbers get expanded to
// something like "115" instead of "line" or "__LINE__"
//
// This will evaluate the expression only once, UNLESS to ask it to 'Retry'.
// Then it will re-evaluate the expression after the return from the debugger.
//
#define LTASSERTONLY(x) x

#define LTASSERT(x) LTASSERT2(x, TEXT(__FILE__), __LINE__)

#define LTASSERT2(exp, file, line)  \
        while (!(exp) && LTFailedAssert(TEXT(#exp), file, line)) (void) 0

#define LTVERIFY(x) LTASSERT(x)

#else // defined(_DEBUG) || defined(ASSERT_ALWAYS)

#define LTASSERTONLY(x)
#define LTASSERT(x) (void) 0
#define LTVERIFY(x) x

#endif // defined(_DEBUG) || defined(ASSERT_ALWAYS)


#ifndef MIT_NO_DEBUG
//
//  Name of the project
//
#ifndef LTTRACEPROJECT
#define LTTRACEPROJECT "Borg"
#endif

//
//  Default value for the exe name if one was not supplied.
//
#ifndef LTTRACEEXE
#define LTTRACEEXE MSLOC
#endif

//
//  Used to put quotes around the LTTRACEEXE macro.
//
#define __stringify2(x) #x
#define __stringify(x) __stringify2(x)

//
// TODO - find a better place for this

		LTAPIENTRY void CopyToClipboard(const char *szMessage);

		
		
struct LTModuleInfo
{
	UINT uiPreferredLoadAddress;
	UINT uiActualLoadAddress;
	UINT uiModuleSize;
	char szName[MAX_PATH];
};

LTAPIENTRY void LTInitDebug(void);

LTAPIENTRY void LTInstallIMallocTracking();
LTAPIENTRY void LTDumpIMallocs(void);
LTAPIENTRY void LTTrackIMalloc(BOOL f);
LTAPIENTRY void LTRevokeIMallocTracking();

LTAPIENTRY void LTShutdownDebug(void);

LTAPIENTRY BOOL LTSetAssertSilent(BOOL);
LTAPIENTRY BOOL LTFailedAssert(const TCHAR *, const TCHAR *, int);
LTAPIENTRY void LTBreak(void);

LTAPIENTRY LONG LTGetAllocNumberImpl(void);
LTAPIENTRY void LTBreakOnAlloc(const char *szFilename, int nLineNum, long nAllocNum);

LTAPIENTRY BOOL LTCheckBaseAddress(HMODULE);
LTAPIENTRY BOOL LTCheckAllBaseAddresses(void);
LTAPIENTRY void LTCheckPagesFor(HINSTANCE);
LTAPIENTRY void LTCheckPagesForAll(void);

LTAPIENTRY void LTDumpAllModules(void);
LTAPIENTRY BOOL LTLocateModule(DWORD dwAddress, HMODULE *pInstance);
LTAPIENTRY BOOL LTGetModuleInfo(HMODULE, LTModuleInfo *);

LTAPIENTRY UINT LTGenStackTrace(TCHAR *szBuffer, UINT nBuffSize,
		UINT nSkip, UINT nTotal);

LTAPIENTRY void LTSetBoringModules(const char *aszBoring[]);
LTAPIENTRY void LTTrackAllocations(BOOL);
LTAPIENTRY void LTDumpAllocations(void);

LTAPIENTRY BOOL LTCheckResourceRange(HINSTANCE, WORD UniqueStart, WORD UniqueEnd,
		WORD SharedStart, WORD SharedEnd);
LTAPIENTRY BOOL LTCheckAllResRanges(WORD, WORD);

#pragma warning(disable:4275)

class LTAPIENTRY CAssertFailedException : public CException
{
public:
	CAssertFailedException(const TCHAR *);
	CAssertFailedException(const TCHAR *, BOOL);

	BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
			PUINT pnHelpContext = NULL);

	~CAssertFailedException();
	
private:
	CAssertFailedException();
	CAssertFailedException(const CAssertFailedException &);

	TCHAR *m_pszAssert;
};



class LTAPIENTRY LTTracePoint
{
public:
	LTTracePoint(const TCHAR *);

	~LTTracePoint();

private:
	LTTracePoint();

	const TCHAR *m_psz;
};



#pragma warning(default:4275)

//
//  Comment this out to remove ASSERTs from retail builds
//  #define LTASSERT_ACTIVE


#if defined(LTTRACE_ACTIVE)


static const TCHAR *szLTTRACEEXE = TEXT(__stringify(LTTRACEEXE));

//
//  The following let us control the output dynamically.  We use a function
//  pointer to route our debug output, and change the function pointer to
//  enable/disable tracing.
//
static void LTTRACEINIT(const TCHAR *, ...);
static void (*LTTRACE)(const TCHAR *, ...) = LTTRACEINIT;

void LTAPIENTRY LTTRACEOUT(const TCHAR *szFormat, va_list args);
void LTAPIENTRY LTTRACEON(const TCHAR *szFormat, ...);
void LTAPIENTRY LTTRACEOFF(const TCHAR *szFormat, ...);


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  LTTRACE is initialized to point to this function.  When first called, it
//  determines if tracing should be enabled, then routes LTTRACE through the
//  right handler.
//  
//-----------------------------------------------------------------------------
static
void
LTTRACEINIT(
		const TCHAR *szFormat,			//  printf style formatting string
		...)							//  Variable argument list to format 
{
	BOOL fDoTrace = 1;
	va_list args;
	const TCHAR * const szTraceProfile = TEXT("lttrace.ini");

	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT("Default"),
			fDoTrace,
			szTraceProfile);
	
	fDoTrace = GetPrivateProfileInt(
			TEXT("ProjectTracing"),
			TEXT(LTTRACEPROJECT),
			fDoTrace,
			szTraceProfile);
	
	if (fDoTrace)
	{
		fDoTrace = GetPrivateProfileInt(
				TEXT("ExecutableTracing"),
				szLTTRACEEXE,
				fDoTrace,
				szTraceProfile);
	}
	
	if (fDoTrace)
	{
		LTTRACE = LTTRACEON;
		
		va_start(args, szFormat);
		
		LTTRACEOUT(szFormat, args);
	}
	else
	{
		LTTRACE = LTTRACEOFF;
	}
}


#define LTTRACEPOINT(sz) LTTracePoint lttp##__LINE__(TEXT(sz))

#else // defined(LTTRACE_ACTIVE)

//
//  Retail version of the debugging macros.  Everything
//  just 'goes away'.  We use (void) 0 so that these things
//  are statements in both the debug and retail builds.
//

static inline void LTNOTRACE(const TCHAR *, ...) 
{}

#define LTTRACE 1 ? (void) 0 : (void) LTNOTRACE
#define LTTRACEPOINT(x) (void) 0

#endif  // defined(LTTRACE_ACTIVE)


#endif // MIT_NO_DEBUG


#endif // #ifndef MITUTIL_LtDebug_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\locvar.h ===
//-----------------------------------------------------------------------------
//  
//  File: locvar.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of CLocVariant, our variant class.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_LOCVAR_H
#define ESPUTIL_LOCVAR_H


enum LocVariantType
{
	lvtNone,
	lvtInteger,
	lvtString,
	lvtIntPlusString,
	lvtBOOL,
	lvtBlob,
	lvtStringList,
	lvtFileName,			// stores file name and editing extension string
};


typedef CLocThingList<CPascalString> CPasStringList;

UINT StoreToBlob(const CPasStringList &, CLocCOWBlob &, UINT uiOffset);
UINT LoadFromBlob(CPasStringList &, const CLocCOWBlob &, UINT uiOffset);
#pragma warning(disable : 4275 4251)

class LTAPIENTRY CLocVariant : public CObject
{
public:
	NOTHROW CLocVariant();

	void AssertValid(void) const;

	NOTHROW LocVariantType GetVariantType(void) const;
	
	NOTHROW DWORD GetDword(void) const;
	NOTHROW BOOL GetBOOL(void) const;
	NOTHROW const CPascalString & GetString(void) const;
	NOTHROW const CLocId & GetIntPlusString(void) const;
	NOTHROW const CLocCOWBlob & GetBlob(void) const;
	NOTHROW const CPasStringList & GetStringList(void) const;
	NOTHROW const CLString & GetFileExtensions(void) const;
	
	NOTHROW int operator==(const CLocVariant &) const;
	NOTHROW int operator!=(const CLocVariant &) const;
	
	NOTHROW void SetDword(const DWORD);
	NOTHROW void SetBOOL(const BOOL);
	NOTHROW void SetString(const CPascalString &);
	NOTHROW void SetIntPlusString(const CLocId &);
	NOTHROW void SetBlob(const CLocCOWBlob &);
	NOTHROW void SetStringList(const CPasStringList &);
	NOTHROW void SetFileName(const CPascalString &, const CLString &);
	
	NOTHROW const CLocVariant & operator=(const CLocVariant &);
	BOOL ImportVariant(const VARIANT& var);
	BOOL ExportVariant(VARIANT& var) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	NOTHROW BOOL IsEqualTo(const CLocVariant &) const;
	
private:
	CLocVariant(const CLocVariant &);

	
	LocVariantType m_VarType;

	//
	//  Class objects can't be in a union.
	//
	union
	{
		DWORD m_dwInteger;
		BOOL  m_fBOOL;
	};
	CPascalString  m_psString;
	CLocId         m_IntPlusString;
	CLocCOWBlob    m_Blob;
	CPasStringList m_StringList;
	CLString       m_strFileExtensions;
};

#pragma warning(default : 4275 4251)


void Store(CArchive &, const CPasStringList &);
void Load(CArchive &, CPasStringList &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locvar.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\macros.h ===
//-----------------------------------------------------------------------------
//  
//  File: macros.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

#define COUNTOF(x) (sizeof(x)/sizeof(*x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\ltimalloc.h ===
//-----------------------------------------------------------------------------
//  
//  File: ltimalloc.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
class LTIMallocSpy : public IMallocSpy
{
public:
	LTIMallocSpy();
	~LTIMallocSpy();

	
	//
	// IUnknown interface
	virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
	
	virtual ULONG STDMETHODCALLTYPE AddRef( void);
	
	virtual ULONG STDMETHODCALLTYPE Release( void);
	
private:

	//
	// IMallocSpy methods.
	virtual ULONG STDMETHODCALLTYPE PreAlloc( 
            /* [in] */ ULONG cbRequest);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostAlloc( 
            /* [in] */ void __RPC_FAR *pActual);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreFree( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void STDMETHODCALLTYPE PostFree( 
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PreRealloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PostRealloc( 
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreGetSize( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual ULONG STDMETHODCALLTYPE PostGetSize( 
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed);
        
	virtual void __RPC_FAR *STDMETHODCALLTYPE PreDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
	virtual int STDMETHODCALLTYPE PostDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual);
        
	virtual void STDMETHODCALLTYPE PreHeapMinimize( void);
        
	virtual void STDMETHODCALLTYPE PostHeapMinimize( void);

	UINT m_uiRefCount;
	CCounter m_IMallocCounter;
	CCounter m_IMallocUsage;

	ULONG m_ulSize;
};


void DumpOutstandingAllocs(void);
void SetTrackingMode(BOOL);

void LTAPIENTRY BreakOnIMalloc(DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\mitenum.h ===
//-----------------------------------------------------------------------------
//  
//  File: mitenum.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#pragma once

//
//  This is the information we enumerate about enumerators.
//
struct EnumInfo
{
	const TCHAR *szDescription;
	const TCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const EnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CEnumCallback() {};

private:
	CEnumCallback(const CEnumCallback &);
	CEnumCallback &operator=(const CEnumCallback &);
};


//
struct WEnumInfo
{
	const WCHAR *szDescription;
	const WCHAR *szAbbreviation;
	ULONG ulValue;
};

//
//  This class is used as a base for a call-back class when enumerating
//  enum values.  For each value, the PrecessEnum() method is called.
//
class LTAPIENTRY CWEnumCallback 
{
public:
	virtual BOOL ProcessEnum(const WEnumInfo &) = 0;
	virtual void SetRange(UINT /* nStart */, UINT /* nFinish */) {}
	inline CWEnumCallback() {};

private:
	CWEnumCallback(const CWEnumCallback &);
	CWEnumCallback &operator=(const CWEnumCallback &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\optionval.inl ===
//-----------------------------------------------------------------------------
//  
//  File: optionval.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline
const CLString &
CLocOptionVal::GetName(void)
		const
{
	return m_strName;
}



inline
const CLocVariant &
CLocOptionVal::GetValue(void)
		const
{
	return m_lvValue;
}



inline
void
CLocOptionVal::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
void
CLocOptionVal::SetValue(
		const CLocVariant &lvValue)
{
	m_lvValue = lvValue;

	LTASSERTONLY(AssertValid());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\optionval.h ===
//-----------------------------------------------------------------------------
//  
//  File: optionval.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionVal : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionVal();

	void AssertValid(void) const;

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	NOTHROW void SetName(const CLString &);
	NOTHROW void SetValue(const CLocVariant &);

	NOTHROW const CLString & GetName(void) const;
	NOTHROW const CLocVariant & GetValue(void) const;

	void Serialize(CArchive &);
	void Load(CArchive &);
	void Store(CArchive &) const;
	
protected:
	virtual ~CLocOptionVal();

private:
	CLString m_strName;
	CLocVariant m_lvValue;

};


class LTAPIENTRY CLocOptionValList :
	public CTypedPtrList<CPtrList, CLocOptionVal *>
{
public:
	NOTHROW CLocOptionValList();

	void AssertValid(void) const;

	NOTHROW ~CLocOptionValList();

private:
	CLocOptionValList(const CLocOptionValList &);

	void operator=(const CLocOptionValList &);
};


#pragma warning(default: 4275)


//
//  Worker function for options upgrade.
LTAPIENTRY void DorkData(BYTE *, DWORD &);


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optionval.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\optvalset.h ===
//-----------------------------------------------------------------------------
//  
//  File: optvalset.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocOptionValEnumCallback : public CObject
{
public:
	CLocOptionValEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocOptionVal *) = 0;
	virtual BOOL ProcessOption(const CLocOptionVal *) = 0;
	
private:
	CLocOptionValEnumCallback(const CLocOptionValEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocOptionValSet;

class LTAPIENTRY CLocOptionValSetList :
	public CTypedPtrList<CPtrList, CLocOptionValSet *>
{
public:
	NOTHROW CLocOptionValSetList() {};

	void AssertValid(void) const;

	NOTHROW void ReleaseAll();
	NOTHROW ~CLocOptionValSetList();

private:
	CLocOptionValSetList(const CLocOptionValSetList &);
	void operator=(const CLocOptionValSetList &);
};

 
class LTAPIENTRY CLocOptionValSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocOptionValSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocOptionVal *);
	NOTHROW void AddOptionSet(CLocOptionValSet *);
	NOTHROW void SetName(const CLString &);
	
	NOTHROW const CLocOptionValList & GetOptionList(void) const;
	NOTHROW const CLocOptionValSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindOptionVal(const CLString &, CLocOptionVal *&pOption);
	NOTHROW BOOL FindOptionVal(const CLString &, const CLocOptionVal *&pOption) const;
	NOTHROW const CLString & GetName(void) const;
	
	NOTHROW BOOL IsEmpty(void) const;
	
	BOOL EnumOptions(CLocOptionValEnumCallback *);
	BOOL EnumOptions(CLocOptionValEnumCallback *) const;
	
	//
	//  Escape hatch.
	//
	NOTHROW void * GetPExtra(void) const;
	NOTHROW DWORD GetDWExtra(void) const;
	NOTHROW void SetExtra(void *);
	NOTHROW void SetExtra(DWORD);

protected:
	NOTHROW virtual ~CLocOptionValSet();

private:
	CLocOptionValList m_olOptions;
	CLocOptionValSetList m_oslSubOptions;
	CLString m_strName;
	
	union
	{
		void *m_pExtra;
		DWORD m_dwExtra;
	};
	
	CLocOptionValSet(const CLocOptionValSet &);
	void operator=(const CLocOptionValSet &);
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "optvalset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\optvalset.inl ===
//-----------------------------------------------------------------------------
//  
//  File: optvalset.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline		
void
CLocOptionValSet::AddOption(
		CLocOptionVal *pOption)
{
	m_olOptions.AddTail(pOption);
}



inline
void
CLocOptionValSet::AddOptionSet(
		CLocOptionValSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);
}



inline
void
CLocOptionValSet::SetName(
		const CLString &strName)
{
	m_strName = strName;
}



inline
const CLocOptionValList &
CLocOptionValSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocOptionValSetList &
CLocOptionValSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocOptionValSet::GetName(void)
		const
{
	return m_strName;
}



inline
BOOL
CLocOptionValSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void *
CLocOptionValSet::GetPExtra(void)
		const
{
	return m_pExtra;
}



inline
DWORD
CLocOptionValSet::GetDWExtra(void)
		const
{
	return m_dwExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		void *pExtra)
{
	m_pExtra = pExtra;
}



inline
void
CLocOptionValSet::SetExtra(
		DWORD dwExtra)
{
	m_dwExtra = dwExtra;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\redvisit.h ===
//-----------------------------------------------------------------------------
//  
//  File: redvisit.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of CRichEditDeltaVisitor
//-----------------------------------------------------------------------------
 
#ifndef REDVISIT_H
#define REDVISIT_H

#include "diff.h"

class CRichEditCtrl;

class LTAPIENTRY CRichEditDeltaVisitor : public CDeltaVisitor
{
public:
	CRichEditDeltaVisitor(CRichEditCtrl & red);
	virtual void VisitDifference(const CDifference & diff) const; 

private: 
	CRichEditCtrl & m_red;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "redvisit.inl"
#endif

#endif  //  REDVISIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\path.h ===
//////////////////////////////////////////////////////////////////////
// PATH.H
//
// Definition of CPath and CDir objects.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 07-May-93	mattg		Created
// 12-May-93	danw		Add operator = and GetDisplayName
// 20-May-93	mattg		Added CDir object
// 22-May-93	danw		Added ConstructObject and DestructObject
//								for collections.
// 11-Jul-93	mattg		Added many new methods to CPath and CDir
//							Also "TCHAR'ified"
// 20-Jul-93    danw        Added relativization functions.
//////////////////////////////////////////////////////////////////////

#ifndef __PATH_H__
#define __PATH_H__

#ifndef _INC_DIRECT
#include <direct.h>
#endif

#ifndef _INC_IO
#include <io.h>
#endif

#ifndef _INC_TCHAR
#include <tchar.h>
#endif

#ifndef _WIN32
#include <ctype.h>
#endif

#ifndef _INC_STAT
#include <sys\stat.h>
#endif

#pragma warning(disable : 4275 4251)


size_t RemoveNewlines(_TCHAR *);

//
// Compatible_GetFileAttributesEx
// g_pGetFileAttributesEx initially points to a function that chooses the new win32 api,
// GetFileAttributesEx if supported, or selects a compatible function that uses FindFirstFile.
//
extern BOOL AFX_DATA (WINAPI *g_pGetFileAttributesEx)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
__inline BOOL Compatible_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	return (*g_pGetFileAttributesEx)( lpFileName, fInfoLevelId, lpFileInformation);
}


//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
	class CPath;
	class CDir;
//////////////////////////////////////////////////////////////////////
// Scan a path in see if it contains special charaters that would
// required it to be quoted:
BOOL ScanPathForSpecialCharacters (const TCHAR *pPath);
//////////////////////////////////////////////////////////////////////
// CPath
class LTAPIENTRY CPath : public CObject
{
	DECLARE_DYNAMIC(CPath)

	friend	class		CDir;

	friend	static VOID		ConstructElement(CPath *);
	friend	static VOID		DestructElement(CPath *);

protected:
	// Data
			CString		m_strCanon;
			int		m_ichLastSlash;	// used to quickly extract only dir or filename
			BOOL		m_Flags;
			enum	PathFlags
				{
					eIsActualCase = 1,
					eWantsRelative = 2,
				};
				// Canonicalized representation of pathname.
			static CMapStringToString c_DirCaseMap;
public:
	// Constructors, destructors, initialization methods
	inline				CPath() { m_ichLastSlash = -1; m_Flags = 0;}
	inline				CPath(const CPath & path)
							 {
								 m_strCanon = path.m_strCanon;
								 m_ichLastSlash = path.m_ichLastSlash;
								 m_Flags = path.m_Flags;
							 }
	virtual				~CPath();

	inline	BOOL		GetAlwaysRelative() const { return ((m_Flags & eWantsRelative) != 0); }
	inline	void		SetAlwaysRelative(BOOL bWantsRel = TRUE) { m_Flags =
			(bWantsRel) ? m_Flags | eWantsRelative : m_Flags & ~eWantsRelative;}

	inline	BOOL		IsInit() const { ASSERT(this!=NULL); return (m_ichLastSlash > 0); }

			BOOL		Create(const TCHAR *);
				// Initialize the object, given a filename.  The resulting
				// canonicalized filename will be relative to the current
				// directory.  For example, if the current directory is
				// C:\TEST and the argument is "FOO.C", the resulting
				// canonicalized filename will be "C:\TEST\FOO.C".  If the
				// argument is "..\FOO.C", the resulting canonicalized
				// filename will be "C:\FOO.C".

			BOOL		CreateFromDirAndFilename(const CDir &, const TCHAR *);
				// Initialize the object given a directory (CDir object) and
				// a filename.  This behaves exactly the same as the Create()
				// method, except that the Create() method canonicalizes the
				// filename relative to the CURRENT directory, whereas this
				// method canonicalizes the filename relative to the SPECIFIED
				// directory.

			BOOL		CreateTemporaryName(const CDir &, BOOL fKeep = TRUE);
				// Initialize the object given a directory.  The resulting
				// object will represent a UNIQUE filename in that directory.
				// This is useful for creating temporary filenames.
				//
				// WARNING
				// -------
				// After this method returns, the filename represented by this
				// object will EXIST ON DISK as a zero length file.  This is
				// to prevent subsequent calls to this method from returning
				// the same filename (this method checks to make sure it
				// doesn't return the name of an existing file).  IT IS YOUR
				// RESPONSIBILITY to delete the file one way or another.
				//
				// If you don't want this behavior, pass FALSE for 'fKeep',
				// and the file will not exist on disk.  Be aware, though,
				// that if you do this, subsequent calls to this method may
				// return the same filename.

			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strCanon);
						}
				// Scan the pathname for special character.  We cache this
				// information.

	inline  CPath &		operator =(const CPath & path)
						{
							ASSERT(path.IsInit());
							m_strCanon = path.m_strCanon;
							m_ichLastSlash = path.m_ichLastSlash;
							m_Flags = path.m_Flags;
							return(*this);
						}
				// Assignment operator.

	// Query methods
	inline	const TCHAR * GetFileName() const
					{
						ASSERT(IsInit());
						ASSERT(m_ichLastSlash==m_strCanon.ReverseFind('\\'));
						return ((const TCHAR *)m_strCanon + m_ichLastSlash + 1);
					}

				// Return a pointer to the filename part of the canonicalized
				// pathname, i.e., the filename with no leading drive or path
				// information. Return whole string if no backslash (not init).
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

			VOID		PostFixNumber();
				// Modifies the path by postfixing a number on the end of the path's
				// basename. If there is no number on the end of the path's basename
				// then the number 1 is postfixed. Otherwise if there already is a
				// number on the end of the path's basename then that number is
				// incremented by 1 and postfixed on the end of the basename (less the
				// original number).
				//
				// e.g. foo.cpp -> foo1.cpp -> foo2.cpp -> foo3.cpp
			
			VOID		GetBaseNameString(CString &) const;
				// Creates a CString representing the base name of the fully
				// canonicalized pathname.  For example, the base name of
				// the pathname "C:\FOO\BAR.C" is "BAR".
				//
				// This method can't return a pointer to internal data like
				// some of the other methods since it would have to remove
				// the extension in order to do so.

			VOID  		GetDisplayNameString(
										CString &,
										int cchMax = 16,
										BOOL bTakeAllAsDefault = FALSE
										) const;
				// Creates a CString representing the name of the file
				// shortened to cchMax CHARACTERS (TCHARs, not bytes) or
				// less.  Only the actual characters are counted; the
				// terminating '\0' is not considered, so
				// CString::GetLength() on the result MAY return as much as
				// cchMax.  If cchMax is less than the length of the base
				// filename, the resulting CString will be empty, unless
				// bTakeAllAsDefault is TRUE, in which the base name is
				// copied in, regardless of length.
				//
				// As an example, "C:\SOMEDIR\OTHERDIR\SUBDIR\SPECIAL\FOO.C"
				// will be shortened to "C:\...\SPECIAL\FOO.C" if cchMax is 25.

		inline	const TCHAR * GetExtension() const
					{
						ASSERT(IsInit());
						int iDot = m_strCanon.ReverseFind(_T('.'));
 						if (iDot < m_ichLastSlash)
							iDot = m_strCanon.GetLength();
						const TCHAR * retval = ((const TCHAR *)m_strCanon) + iDot;
 						return retval;
					}

				// Return a pointer to the extension part of the canonicalized
				// pathname.  Returns a pointer to the '.' character of the
				// extension.  If the filename doesn't have an extension,
				// the pointer returned will point to the terminating '\0'.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	const TCHAR * GetFullPath() const { return(m_strCanon); }
				// Return a pointer to the full (canonicalized) pathname.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!
	inline	const TCHAR * GetFullPath(CString & strPath) const { return(strPath = m_strCanon); }

	inline	BOOL		IsActualCase() const { ASSERT(this!=NULL); return ((m_Flags & eIsActualCase)!=0); }
	void GetActualCase(BOOL bEntirePath = FALSE);
				// Adjusts the paths case to match the actual path and filename
				// on disk.
	void SetActualCase(LPCTSTR pszFileCase); 
				// Adjusts the paths case to match the actual path and filename
				// on disk, where pszFileCase already contains the correct case
				// for just the filename portion.
	static void ResetDirMap();

	inline				operator const TCHAR *() const { return(m_strCanon); }
				// Return the fully canonicalized filename as a (const TCHAR *).
				// Same thing as GetFullPath(), but more convenient in some
				// cases.
				//
				// Please do not write through this pointer, as it is pointing
				// to internal data!

	inline	BOOL		IsUNC() const { return(m_strCanon[0] == _T('\\')); }
				// Returns TRUE if the pathname is UNC (e.g.,
				// "\\server\share\file"), FALSE if not.

	inline BOOL IsEmpty() const { return (m_strCanon.IsEmpty()); }

	// Comparison methods

			int			operator ==(const CPath &) const;
				// Returns 1 if the two CPaths are identical, 0 if they are
				// different.

	inline	int			operator !=(const CPath & path) const { return(!(operator ==(path))); }
				// Returns 1 if the two CPaths are different, 0 if they are
				// identical.

	// Modification methods

			VOID		ChangeFileName(const TCHAR *);
				// Changes the file name to that specified by the
				// (const TCHAR *) argument.  The directory portion of the
				// pathname remains unchanged.  DO NOT pass in anything
				// other than a simple filename, i.e., do not pass in
				// anything with path modifiers.

			VOID		ChangeExtension(const TCHAR *);
				// Changes the extension of the pathname to be that specified
				// by the (const TCHAR *) argument.  The argument can either be
				// of the form ".EXT" or "EXT".  If the current pathname has
				// no extension, this is equivalent to adding the new extension.

			BOOL 		GetRelativeName (const CDir&, CString&, BOOL bQuote = FALSE, BOOL bIgnoreAlwaysRelative = FALSE) const;
				// Makes the path name relative to the supplied directory and
				// placed the result in strResult.  Function will only go
				// down from the supplied directy (no ..'s).  Returns TRUE if
				// relativization was successful, or FALSE if not (e.g. if
				// string doesn't start with ".\" or ..\ or at least \).
				//
				// Thus, if the base directory is c:\sushi\vcpp32:
				//
				//  s:\sushi\vcpp32\c\fmake.c => s:\sushi\vcpp32\c\fmake.c
				//  c:\sushi\vcpp32\c\fmake.c => .\fmake.c
				//  c:\dolftool\bin\cl.exe    => \dolftool\bin\cl.exe
				//	\\danwhite\tmp\test.cpp   => \\danwhite\tmp\test.cpp

				// Thus, if the base directory is \\danwhite\c$\sushi\vcpp32:
				//
				// \\danwhite\c$\dolftool\bin\cl.exe => \dolftool\bin\cl.exe
				// \\danwhite\tmp\test.cpp           => \\danwhite\tmp\test.cpp

				// If bQuote is true, then quotes are put around the relative
				// file name. (Useful for writing the filename out to a file)

				// If (!bIgnoreAlwaysRelative && GetAlwaysRelative()) is TRUE
				// and if the file is on the same drive we will ALWAYS
				// relativize it. Thus for the base dir c:\sushi\vcpp32
				//  c:\dolftool\bin\cl.exe    => ..\..\dolftool\bin\cl.exe

			BOOL        CreateFromDirAndRelative (const CDir&, const TCHAR *);
				// THIS FUNCTION IS OBSOLETE.  New code should use
				// CreateFromDirAndFilename().  The only difference between
				// that function and this one is that this one will
				// automatically remove quotes from around the relative
				// path name (if present).


	// Miscellaneous methods
	inline	BOOL		IsReadOnlyOnDisk() const
						{
							HANDLE	h;

							ASSERT(IsInit());
							h = CreateFile(m_strCanon, GENERIC_WRITE,
								FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL, NULL);

							if (h == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
								return TRUE;

							if (h != INVALID_HANDLE_VALUE)
								CloseHandle(h);

							return FALSE;
						}
				// Returns TRUE if the filename represented by this object
				// is read-only on disk, FALSE if not.  NOT guaranteed to
				// work in all circumstances -- for example, will not return
				// TRUE for a file on a floppy drive that has been write-
				// protected.  I don't know of any way to get this information
				// from NT (GetFileAttributes doesn't work; GetVolumeInformation
				// doesn't work; _access just calls GetFileAttributes; etc.).
				// This method WILL correctly detect:
				//		- Files marked as read-only
				//		- Files on read-only network drives

	inline	BOOL		ExistsOnDisk() const
						{
							ASSERT(IsInit());
							return(_access(m_strCanon, 00) != -1);
						}
				// Returns TRUE if the filename represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CanCreateOnDisk(BOOL fOverwriteOK = FALSE) const
						{
							ASSERT(IsInit());
							if (!fOverwriteOK && ExistsOnDisk())
								return(FALSE);
							int hFile = _creat(m_strCanon, _S_IREAD | _S_IWRITE);
							BOOL fCreate = (hFile != -1);
							if (fCreate)
							{
								VERIFY(_close(hFile) == 0);
								VERIFY(_unlink(m_strCanon) == 0);
							}
							return(fCreate);
						}
				// Returns TRUE if the filename represented by this object
				// can be created on disk, FALSE if not.

	inline	BOOL		DeleteFromDisk() const
						{
							ASSERT(IsInit());
#ifdef _WIN32
							return(DeleteFile((TCHAR *)(const TCHAR *)m_strCanon));
#else
							return(remove(m_strCanon) != -1);
#endif
						}
				// Removes the file represented by this object from the disk.

	BOOL GetFileTime(LPFILETIME lpftLastWrite);
	BOOL GetFileTime(CString& rstrLastWrite, DWORD dwFlags = DATE_SHORTDATE);
	// Returns the last modified time, as either an FILETIME struct or a string
};
//	Creation and destruction functions used by CMapPathToOb:

extern const CString AFX_DATA pthEmptyString;

static inline VOID ConstructElement(CPath * pNewData)
{
	memcpy(&pNewData->m_strCanon, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CPath * pOldData)
{
	pOldData->m_strCanon.Empty();
}


//	File Name Utility Functions
//		These are redundant and could be replaced with use of CPath, but are
//		kept since they are easier to use and already exist in VRES.

// Remove the drive and directory from a file name.
CString StripPath(LPCTSTR szFilePath);

// Remove the name part of a file path.  Return just the drive and directory.
CString StripName(LPCTSTR szFilePath);

// Get only the extension of a file path.
CString GetExtension(LPCTSTR szFilePath);

// Return the path to szFilePath relative to szDirectory.  (e.g. if szFilePath
// is "C:\FOO\BAR\CDR.CAR" and szDirectory is "C:\FOO", then "BAR\CDR.CAR"
// is returned.  This will never use '..'; if szFilePath is not in szDirectory
// or a sub-directory, then szFilePath is returned unchanged.
//
CString GetRelativeName(LPCTSTR szFilePath, LPCTSTR szDirectory = NULL);

// Makes a file path look like in MRU.
CString GetDisplayName(LPCTSTR szFilePath, int nMaxDisplayLength,
	LPCTSTR szDirectory = NULL);

BOOL FileExists(LPCTSTR szFilePath);
BOOL IsFileWritable(LPCTSTR szFilePath);

UINT SushiGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);

//////////////////////////////////////////////////////////////////////
// CDir
//
// The CDir object represents a file system directory on some disk.
//
// A CDir object can be created to represent the current directory,
// to represent the directory of a CPath object (i.e., the directory
// in which a file resides), and to represent a temporary directory.
// Note that a CDir object CANNOT be created given an arbitrary string --
// this is intentional, since this should not be necessary.
//
// The string representation of a CDir object (e.g., operator const TCHAR *())
// MAY or MAY NOT end in '\'.  The root directory of a local drive (e.g., C:)
// will end in '\' ("C:\"), while other directories on a local drive will
// not ("C:\OTHERDIR").  The root directory on a REMOTE drive will NOT end
// in '\' ("\\server\share").  Don't make any assumptions about whether or
// not the string representation ends in '\'.
//
// See also several CPath methods which use CDir objects.

class LTAPIENTRY CDir : public CObject
{
	DECLARE_DYNAMIC(CDir)

	friend	class		CPath;

	friend	static VOID		ConstructElement(CDir *);
	friend	static VOID		DestructElement(CDir *);

protected:
			CString		m_strDir;
				// Directory name, including drive letter or
				// server/share.  Do NOT make any assumptions
				// about whether or not this ends in '\'!

			// Creates multi level directories just fine
			BOOL MakeDirectory(LPCTSTR lpszPathName) const;
public:
	// Constructors, destructors, initialization methods
	inline				CDir() {}
	inline				CDir(const CDir & dir) { m_strDir = dir.m_strDir; }
	virtual				~CDir();

			BOOL		CreateFromCurrent();
				// Initialize from the current working directory.  This
				// may fail if the current working directory is unknown
				// or invalid.

			BOOL		CreateFromPath(const CPath &);
				// Initialize based on the directory of the specified
				// CPath object.  That is, if the CPath object represents
				// the file "C:\FOO\BAR\BLIX.C", the resulting directory
				// for this object will be "C:\FOO\BAR".  Returns FALSE
				// on failure.

			BOOL		CreateFromPath(const TCHAR *pszPath);
				// Initialize based on the directory of the specified
				// string.  That is, if the string contains the file name
				// "C:\FOO\BAR\BLIX.C", the generated directory for this
				// string will be "C:\FOO\BAR".  Returns FALSE on failure.

			BOOL		CreateTemporaryName();
				// Initialize this object to represent a temporary directory
				// on disk (e.g., "C:\TMP").

			inline BOOL		CreateFromString(const TCHAR * sz)
					{
						return  CreateFromStringEx(sz, FALSE);
					}	
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!

			BOOL		CreateFromStringEx(const TCHAR * sz, BOOL fRootRelative);
				// Create from a string (e.g., "C:\", "C:\TMP", etc.).  Please
				// do not use this method when another would suffice!
				// same as CreateFromString with minor change. Not treating as bug fix to CFS
				// due to lateness in VC 4.0 project time

				// if fRootRelative true, treat dir ending with colon as relative not root dir 
				// (actual correct handling)


			BOOL		ContainsSpecialCharacters () const
						{
							return ::ScanPathForSpecialCharacters(m_strDir);
						}
				// Scan the pathname for special character.  We cache this information.

	inline	CDir &		operator =(const CDir & dir)
						{
							m_strDir = dir.m_strDir;
							return(*this);
						}
				// Assignment operator.

	// Query methods

	inline				operator const TCHAR *() const { return(m_strDir); }
				// Return the directory name as a (const TCHAR *) string.

	inline int GetLength() const { return m_strDir.GetLength(); }
	      // Returns the length of the directory name

	// Miscellaneous methods

	BOOL	MakeCurrent() const;
				// Make this object the current working directory.  May fail
				// if the directory no longer exists (e.g., a floppy drive).

	inline	BOOL		ExistsOnDisk() const
						{
							// Tests if the directory exists.  We return FALSE
							// if <m_strDir> exists but is not a directory
							struct _stat statDir;
							if (_stat(m_strDir, &statDir) == -1)
								return FALSE;		 // Not found.
							else if (!(statDir.st_mode & _S_IFDIR))
								return FALSE;		 // Not a directory.
							else
								return TRUE;
						}
				// Returns TRUE if the directory represented by this object
				// exists on disk, FALSE if not.

	inline	BOOL		CreateOnDisk() const { return MakeDirectory(m_strDir); }
				// Creates the directory on disk.  If this fails, returns
				// FALSE.  If the directory already existed on disk, returns
				// TRUE (i.e., that is not an error condition).

	inline	BOOL		RemoveFromDisk() const { return RemoveDirectory(m_strDir); }
				// Removes the directory from the disk.  If this fails for
				// any reason (directory does not exist, directory is not
				// empty, etc.), returns FALSE.

			BOOL		IsRootDir() const;
				// Returns TRUE if the directory represented by this object
				// is a root directory (e.g., "C:\"), FALSE if not.  Note that
				// calling this method will NOT tell you whether or not the
				// string representation ends in '\', since "\\server\share"
				// is a root directory, and does not end in '\'.

	inline	BOOL		IsUNC() const { return(m_strDir[0] == _T('\\')); }
				// Returns TRUE if this is a UNC directory, FALSE if not.

			VOID		AppendSubdirName(const TCHAR *);
				// Adds a subdirectory name.  For example, if this object
				// currently represents "C:\FOO\BAR", and the argument is
				// "$AUTSAV$", the resulting object represents
				// "C:\FOO\BAR\$AUTSAV$".
				//
				// WARNING: This method does NO validation of the result --
				// it does not check for illegal characters, or for a
				// directory name that is too long.  In particular, don't
				// pass "DIR1/DIR2" as an argument, since no conversion
				// (of '/' to '\') will occur.

			VOID		RemoveLastSubdirName();
				// Removes the last component of the directory name.  For
				// example, if this object currently represents
				// "C:\FOO\BAR\$AUTSAV$", after this method it will
				// represent "C:\FOO\BAR".  If you try to call this method
				// when the object represents a root directory (e.g., "C:\"),
				// it will ASSERT.

	// Comparison methods

			int			operator ==(const CDir &) const;
				// Returns 1 if the two CDirs are identical, 0 if they are
				// different.

	inline	int			operator !=(const CDir & dir) const { return(!(operator ==(dir))); }
				// Returns 1 if the two CDirs are different, 0 if they are
				// identical.
};

//	Creation and destruction functions used by CMapDirToOb:

static inline VOID ConstructElement(CDir * pNewData)
{
	memcpy(&pNewData->m_strDir, &pthEmptyString, sizeof(CString));
}

static inline VOID DestructElement(CDir * pOldData)
{
	pOldData->m_strDir.Empty();
}

///////////////////////////////////////////////////////////////////////////////
//	CCurDir
//		This class is used to switch the current drive/directory during the
//		life of the object and to restore the previous dirve/directory upon
//		destruction.

class LTAPIENTRY CCurDir : CDir
{
public:
	CCurDir(const char* szPath, BOOL bFile = FALSE);
	CCurDir(const CDir& dir);
	CCurDir();	// just saves the current directory and resets it
	~CCurDir();

	CDir m_dir;
};


///////////////////////////////////////////////////////////////////////////////
//	CFileOpenReturn
//		This class represents the return value from the Common Dialogs
//		File.Open.  It handles both single and multiple select types.
//

class LTAPIENTRY CFileOpenReturn : CObject
{
	BOOL		m_bSingle;
	BOOL		m_bBufferInUse;
	BOOL		m_bArrayHasChanged;

	int			m_cbData;
	_TCHAR * 	m_pchData;

	// Multiple Files
	CPtrArray	m_rgszNames;

public:
	CFileOpenReturn (const _TCHAR * szRawString = NULL);
	~CFileOpenReturn ();

	inline BOOL IsSingle () const;
	inline BOOL IsDirty() const;
	inline BOOL BufferOverflow () const;
	//inline int  GetLength () const;

	// GetBuffer gives permission for something else to directly change the buffer
	// ReleaseBuffer signifies that the something else is done with it.
	_TCHAR * GetBuffer (int cbBufferNew);
	inline void ReleaseBuffer ();

	// allows the object to be re-initialized
	void ReInit (const _TCHAR * szRawString);

	// This supports the dynamic file extension update in OnFileNameOK().
	void ChangeExtension (int i, const CString& szExt);

	void CopyBuffer (_TCHAR * szTarget);

	// This is the function to use to get at the user's selections,
	// whether single or multiple.
	BOOL GetPathname (int i, CString& strPath) const;

private:
	void GenArrayFromBuffer ();
	void GenBufferFromArray ();
	void ClearNamesArray ();
	void SetBuffer (const _TCHAR * szRawString);	
};


inline BOOL CFileOpenReturn::IsSingle () const
{
	return m_bSingle;
}

inline BOOL CFileOpenReturn::IsDirty() const
{
	return m_bArrayHasChanged;
}

inline BOOL CFileOpenReturn::BufferOverflow () const
{
	return m_cbData == 2 && m_pchData[0] == '?';
}

///// ReleaseBuffer - Tell object we're done changing the buffer
//
//	Processes the raw string
//
///
inline void CFileOpenReturn::ReleaseBuffer ()
{
	m_bBufferInUse = FALSE;
	GenArrayFromBuffer ();
}

///////////////////////////////////////////////////////////////////////////////
//	Smart case helpers.
//		These functions are used to do smart casing of paths and file extensions.

extern BOOL GetActualFileCase( CString& rFilename, LPCTSTR lpszDir = NULL );
extern LPCTSTR GetExtensionCase( LPCTSTR lpszFilename, LPCTSTR lpszExtension );

extern BOOL GetDisplayFile(CString &rFilename, CDC *pDC, int &cxPels); // truncates from left

/////////////////////////////////////////////////////////////////////////////
#pragma warning(default : 4275 4251)

#endif // __PATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\refcount.h ===
//-----------------------------------------------------------------------------
//  
//  File: refcount.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once



class LTAPIENTRY CRefCount
{
public:
	CRefCount();

	//
	//  Declared as STDMETHOD so as compatible with COM.
	//
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);

	//
	//
	ULONG AddRef(void) const;
	ULONG Release(void) const;
	
protected:
	
	virtual ~CRefCount() = 0;

private:

	CRefCount(const CRefCount &);
	const CRefCount & operator=(const CRefCount &);
	UINT operator==(const CRefCount &);
	
	mutable UINT m_uiRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\passtr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: passtr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Default constructor for a Pascal string.  Sets the length to zero, with
//  no storage.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString()
{
	//
	//  The string data class is initialized by it's constructor.
	//
	LTASSERT(m_blbData.GetBlobSize() == 0);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator to convert a CPascalString to a blob.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const CLocCOWBlob &(void)
		const
{
	return m_blbData;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - CPascalString to CPascalString.  
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &                     // Allows a=b=c;
CPascalString::operator=(
		const CPascalString &pstrSource)  // Source string
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData = ((const CLocCOWBlob &)pstrSource);
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Copy constructor for CPascalString's
//  
//-----------------------------------------------------------------------------
inline
CPascalString::CPascalString(
		const CPascalString &pstrSource)
{
	LTASSERT(pstrSource.m_blbData.GetWriteCount() == 0);
	 
	operator=(pstrSource);

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Assignment operator - Wide character C String to CPascalString.  The string
//  is COPIED into the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &             //  Allows a=b=c;
CPascalString::operator=(
		const WCHAR *wszSource)   //  Source, zero terminated string
{
	SetString(wszSource, wcslen(wszSource));

	return *this;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Appends a CPascalString to the current string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &			        // Allows a=b+=c syntax
CPascalString::operator+=(
		const CPascalString &pstrTail)	// Pascal string to append
{
	AppendBuffer(pstrTail, pstrTail.GetStringLength());
	
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a NUL terminated Unicode string to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR *szTail)			// NUL terminated string to append
{
	AppendBuffer(szTail, wcslen(szTail));
	return *this;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Append a Unicode character to a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Allows a-b+=L"Hi There" syntax
CPascalString::operator+=(
		const WCHAR wch)			// WCHAR to append
{
	AppendBuffer(&wch, 1);
	return *this;
}



//-----------------------------------------------------------------------------
//  
//  Comparison function for Pascal strings.
//  
//-----------------------------------------------------------------------------
inline
BOOL                                                // TRUE (1) if the same
CPascalString::IsEqualTo(
		const CPascalString &pstrOtherString) const // String to compare to
{
	return m_blbData == (const CLocCOWBlob &)pstrOtherString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator == version of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int								              // TRUE (1) if equal
CPascalString::operator==(
		const CPascalString &pstrOtherString) // String to compare
		const
{
	return IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Operator != - just the negative of IsEqualTo
//  
//-----------------------------------------------------------------------------
inline
int                                                 // TRUE (1) if *not* equal
CPascalString::operator!=(
		const CPascalString &pstrOtherString) const // String to compare
{

	return !IsEqualTo(pstrOtherString);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL terminated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline
int
CPascalString::operator==(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Comparison operator for NUL termninated WCHAR strings.
//  
//-----------------------------------------------------------------------------
inline int
CPascalString::operator!=(
		const WCHAR *pwch)
		const
{
	return (wcscmp(*this, pwch) != 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is there anything in the string?  This is different from a string of zero
//  length.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CPascalString::IsNull(void)
		const
{
	return ((const void *)m_blbData == NULL);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the length of the pascal string.  If the length is zero, there may be
//  no storage associated with the string.  Use IsNull to check for storage.
//  
//-----------------------------------------------------------------------------
inline
UINT                                         // length of the string.
CPascalString::GetStringLength(void) const
{
	UINT uiBufferSize;

	uiBufferSize = m_blbData.GetBlobSize();
	LTASSERT((uiBufferSize % sizeof(WCHAR)) == 0);
	
	return (uiBufferSize != 0 ? (uiBufferSize/sizeof(WCHAR)-1): 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the length of the pascal string.  String contents are not preserved
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::SetStringLength(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize((uNewSize + 1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Realloc a string - set true size
//  
//-----------------------------------------------------------------------------
inline
void                                         // length of the string.
CPascalString::ReallocString(UINT uNewSize)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.ReallocBlob((uNewSize +  1) * sizeof(WCHAR));
	DEBUGONLY(m_StorageCounter += m_blbData.GetBlobSize());
	*(GetStringPointer() + uNewSize) = L'\0';
	ReleaseStringPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  As an optimization, the user can ask the Pascal string to reserve some
//  memory for future growth.  This would allow incremental additions to be
//  very efficent.  The reported size of the string is not changed - only the
//  amount of storage reserved for the string.
//
//  If the user requests less space than is already allocated, nothing
//  happens.
//
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReserveStorage(
		UINT nMinSize)					// Size (in chars) to reserve for
{
	if (nMinSize > GetStringLength())
	{
		UINT uiCurSize;

		uiCurSize = GetStringLength();
		ReallocString(nMinSize);
		ReallocString(uiCurSize);
	}
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get a pointer to the storage for the string.  This may be NULL if the
//  string has length 0.  This pointer should be considered INVALID if any
//  other assignment operation is performed on the Pascal string.  Calling
//  this dis-ables teh COW behavior of the CPascalString.
//  
//-----------------------------------------------------------------------------
inline
WCHAR *
CPascalString::GetStringPointer(void)
{
	return (WCHAR *)m_blbData.GetPointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Anytime you do a GetStringPointer, use ReleaseStringPointer to allow
//  the PascalString to revert to COW behavior.  Once you call this, the
//  pointer from GetStringPointer is INVALID.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ReleaseStringPointer(void)
{
	m_blbData.ReleasePointer();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Casting operator version of GetString pointer.  Cast a CPascalString to
//  const WCHAR *, and you get a pointer to the string.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::operator const WCHAR *(void) const
{
	return (const WCHAR *)(const void *)(m_blbData);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Cleanup on the string.  Sets the length to zero, and remove all storage.
//  This is different than assigning a NULL string - that is a string of
//  length 1, consisting of the NUL (zero) character.
//  
//-----------------------------------------------------------------------------
inline
void
CPascalString::ClearString(void)
{
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
	m_blbData.SetBlobSize(0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Destructor for a Pascal string.  Frees up the current storage.  After
//  a Pascal string goes out of scope, all pointers to the internal storage
//  are invalid.
//  
//-----------------------------------------------------------------------------
inline
CPascalString::~CPascalString()
{
	LTASSERTONLY(AssertValid());
	DEBUGONLY(--m_UsageCounter);
	DEBUGONLY(m_StorageCounter -= m_blbData.GetBlobSize());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Serialize for a Pascal string.
//  
//-----------------------------------------------------------------------------
inline
void CPascalString::Serialize(CArchive &ar)
{
	if (ar.IsStoring())
	{
		Store(ar);
	}
	else
	{
		Load(ar);
	}
}



inline
void
CPascalString::Store(
		CArchive &ar)
		const
{
	LTASSERT(ar.IsStoring());
	LTASSERTONLY(AssertValid());

	//
	//  HACK HACK HACK
	//  Emulate Old Espresso 3.0 serialization.
	m_blbData.Store(ar);
	
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator==(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Helper function - comparison operator for a NUL terminated WCHAR string
//  and a CPascalString.
//  
//-----------------------------------------------------------------------------
inline
int
operator!=(
		const WCHAR *pwch,
		const CPascalString &pstr)
{
	return (wcscmp(pwch, pstr) != 0);
}



inline
int CPascalString::operator!=(
		const _bstr_t &bsOther)
		const
{
	return !(operator==(bsOther));
}



inline
int
operator==(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr == bsOther;
}



inline
int
operator!=(
		const _bstr_t &bsOther,
		const CPascalString &pstr)
{
	return pstr != bsOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\redvisit.inl ===
//-----------------------------------------------------------------------------
//  
//  File: redvisit.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//-----------------------------------------------------------------------------
 
inline
CRichEditDeltaVisitor::CRichEditDeltaVisitor(
	CRichEditCtrl & red) :
	m_red(red)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\reghelp.h ===
//******************************************************************************
//
// RegHelp.h : Collection of Registry helping functions
//
// Copyright (C) 1994-1997 by Microsoft Corporation
// All rights reserved.
//
//******************************************************************************

#if !defined(MITUTIL_RegHelp_h_INCLUDED)
#define MITUTIL_RegHelp_h_INCLUDED

#pragma once

//------------------------------------------------------------------------------
class LTAPIENTRY CRegHelp
{
public:
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, CString & stValue);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, DWORD & dwNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, long & nNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, VARIANT_BOOL & fNum);
	static BOOL GetRegValue(HKEY hKey, LPCTSTR pszPath, const CString & stName, GUID & guid);
};

#endif // MITUTIL_RegHelp_h_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\smartptr.h ===
//-----------------------------------------------------------------------------
//  
//  File: smartptr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_SMARTPTR_H
#define ESPUTIL_SMARTPTR_H



template<class T>
class SmartPtr
{
public:
	NOTHROW SmartPtr();
	NOTHROW SmartPtr(T *);

	NOTHROW T & operator*(void) const;
	NOTHROW T * operator->(void) const;
	NOTHROW T* Extract(void);
	NOTHROW T* GetPointer(void);
	NOTHROW const T * GetPointer(void) const;
	NOTHROW BOOL IsNull(void) const;
	
	void operator=(T *);
	operator T* &(void);

	NOTHROW ~SmartPtr();
	
private:
	T *m_pObject;

	SmartPtr(const SmartPtr<T> &);
	void operator=(const SmartPtr<T> &);
	
	//
	//  This hackery prevents Smart Pointer from being on the heap
	//
	void operator delete(void *);
};

#include "smartptr.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\passtr.h ===
//-----------------------------------------------------------------------------
//  
//  File: passtr.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration for a pascal (counted) style wide character string class.
//  The count reflects the number of characters (including NUL characters),
//  not the amount of storage.  Any string in a PascalString is automatically
//  given a NULL terminator, even if it already has one.  This extra terminator
//  is NOT in the count of characters in the string.
//  
//-----------------------------------------------------------------------------
 
#ifndef PASSTR_H
#define PASSTR_H


class _bstr_t;

class CUnicodeException : public CSimpleException
{
public:
	enum UnicodeCause
	{
		noCause = 0,
		invalidChar = 1,
		unknownCodePage
	};

	UnicodeCause m_cause;

	NOTHROW CUnicodeException(UnicodeCause);
	NOTHROW CUnicodeException(UnicodeCause, BOOL);
	
	NOTHROW ~CUnicodeException();

	virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError, 
		PUINT pnHelpContext = NULL );
};


void LTAPIENTRY ThrowUnicodeException(CUnicodeException::UnicodeCause);


class LTAPIENTRY CPascalString
{
public:
	NOTHROW CPascalString();
	NOTHROW CPascalString(const CPascalString &);

	void AssertValid(void) const;

	//
	//  The ultimate assignment operator - any random collection
	//  of WIDE characters can be placed in the string.
	//  Also, we can convert any collection of DBCS style strings,
	//  so long as the user provides a code page to work with...
	//
	void SetString(const WCHAR *, UINT);
	void SetString(const char *, UINT, CodePage);
	void SetString(const CLString &, CodePage);
	
	//
	//  Useful assignment operators
	//
	const CPascalString & operator=(const CPascalString &);
	const CPascalString & operator=(const WCHAR *);
	const CPascalString & operator=(const _bstr_t &);
	
	const CPascalString & operator+=(const CPascalString &);
	const CPascalString & operator+=(const WCHAR *);
	const CPascalString & operator+=(const WCHAR);

	void Format(const WCHAR *, ...);

	//
	//  Comparison operators for counted strings.
	//
	NOTHROW int operator==(const CPascalString &) const;
	NOTHROW int operator!=(const CPascalString &) const;

	NOTHROW int operator==(const _bstr_t &) const;
	NOTHROW int operator!=(const _bstr_t &) const;

	NOTHROW int operator==(const WCHAR *) const;
	NOTHROW int operator!=(const WCHAR *) const;
	
	NOTHROW BOOL IsNull(void) const;

	//
	//  Retrieving the data from the string.
	//
	NOTHROW UINT GetStringLength(void) const;
	void SetStringLength(UINT);
	void ReallocString(UINT);
	void ReserveStorage(UINT);

	NOTHROW WCHAR * GetStringPointer(void);
	NOTHROW void ReleaseStringPointer(void);

	NOTHROW operator const WCHAR *(void) const;
	// const BSTR GetBSTR(void) const;

	NOTHROW WCHAR operator[](UINT) const;
	NOTHROW WCHAR & operator[](UINT);

	//
	//  Sub-string extraction
	//
	NOTHROW void Left(CPascalString &, UINT) const;
	NOTHROW void Right(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT) const;
	NOTHROW void Mid(CPascalString &, UINT, UINT) const;

	//
	//  Locate
	//
	NOTHROW BOOL Find(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL FindOneOf(const CPascalString&, UINT, UINT &) const;
	NOTHROW BOOL FindExcept(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL FindSubString(const CPascalString &, UINT, UINT &) const;
	
	NOTHROW BOOL ReverseFind(WCHAR, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindOneOf(const CPascalString &, UINT, UINT &) const;
	NOTHROW BOOL ReverseFindExcept(const CPascalString &, UINT, UINT &) const;
	
	//
	//  Clears the contents of a Pascal string.
	//
	NOTHROW void ClearString(void);

	//
	//  Conversion API's for Pascal style strings.
	//
	enum ConvFlags 
	{
		ConvNoFlags = 0,					// No conversion options
		HexifyDefaultChars = 0x01,			// Hexify chars that convert to the default char
		HexifyNonPrintingChars = 0x02,
		HexifyWhiteSpace = 0x04,
		ConvAddNull = 0x08,
		ConvAllFlags = 0xFF
	};
	
	void ConvertToCLString(CLString &, CodePage, BOOL fHex=FALSE) const;
	void ConvertToMBCSBlob(CLocCOWBlob &, CodePage, DWORD dwFlags = ConvNoFlags) const;
	NOTHROW void MakeUpper(void);
	NOTHROW void MakeLower(void);
	_bstr_t MakeBSTRT() const;
	
	void Serialize(CArchive &ar);
	void Load(CArchive &ar);
	void Store(CArchive &ar) const;
	
	static const char *szUnmappableChar;
	static char cHexLeaderChar;
	
 	static void EscapeBackSlash(const CPascalString &srcStr, 
		CPascalString &destStr);

	int ParseEscapeSequences(CPascalString &pasError);
	
	~CPascalString();
 
protected:
	NOTHROW BOOL IsEqualTo(const CPascalString &) const;
	NOTHROW void AppendBuffer(const WCHAR *, UINT);
	
private:
	void FormatV(const WCHAR *, va_list arglist);
	
	CLocCOWBlob m_blbData;
	operator const CLocCOWBlob &(void) const;

	DEBUGONLY(static CCounter m_UsageCounter);
	DEBUGONLY(static CCounter m_StorageCounter);
};

typedef CArray<CPascalString, CPascalString &> CPasStringArray;
	
//
//  Comparison helper functions.  These should all have the
//  CPascalString as the SECOND arguement.
//
NOTHROW int LTAPIENTRY operator==(const WCHAR *, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const WCHAR *, const CPascalString &);

NOTHROW int LTAPIENTRY operator==(const _bstr_t &, const CPascalString &);
NOTHROW int LTAPIENTRY operator!=(const _bstr_t, const CPascalString &);

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "passtr.inl"
#endif

#endif  //  PASSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\smartref.h ===
//-----------------------------------------------------------------------------
//  
//  File: SmartRef.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_SmartRef_H
#define ESPUTIL_SmartRef_H


template<class T>
class SmartRef
{
private:
	T *m_pInterface;

public:
	NOTHROW SmartRef()
	{
		m_pInterface = NULL;
	}

	//  Compiler bug, must be inline!
	NOTHROW SmartRef(T *pI) {m_pInterface = pI;};
	NOTHROW SmartRef(const SmartRef<T> &);

	NOTHROW T * operator->(void)
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW const T * operator->(void) const
	{
		LTASSERT(m_pInterface != NULL);
		return m_pInterface;
	}
	
	NOTHROW T & operator*(void)
	{
		LTASSERT(m_pInterface != NULL);
		return *m_pInterface;
	}
	NOTHROW T * Extract(void)
	{
		return ExtractImpl();
	};
	
	NOTHROW T * GetInterface(BOOL fAddRef = FALSE)	
	{
		return GetInterfaceImpl(fAddRef);
	};

	NOTHROW const T * GetInterface(void) const
	{
		return m_pInterface;
	}
	
	NOTHROW BOOL IsNull(void) const
	{
		return m_pInterface == NULL;
	}
	
	NOTHROW ~SmartRef()
	{
		if (m_pInterface != NULL)
		{
			m_pInterface->Release();
		}
	}

	void operator=(T* pOther)
	{
		opEqImpl(pOther);
	}
	void operator=(const SmartRef<T> &other);

	T ** operator&(void);
	operator T* &(void) {return opTpRef();};
	
private:
	void operator delete(void *);

	NOTHROW T * ExtractImpl(void);
	NOTHROW T * GetInterfaceImpl(BOOL fAddRef);
	NOTHROW T * & opTpRef(void);
	void opEqImpl(T* pOther);

};

#include "SmartRef.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mitutil.rc
//
#define IDS_BAD_UNICODE_CHAR            12700
#define IDS_BAD_CODE_PAGE               12701
#define IDS_UIVAL_ON                    12702
#define IDS_UIVAL_OFF                   12703
#define IDS_UIVAL_TRUE                  12704
#define IDS_UIVAL_FALSE                 12705
#define IDS_UIVAL_YES                   12706
#define IDS_UIVAL_NO                    12707
#define IDS_UIVAL_BLOB                  12708
#define IDS_HEX_MUST_BE_4DIGITS         12709
#define IDS_INVALID_ESCAPE              12710

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
#define AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_

#pragma once


// StrigBlast requires the CString implicit conversions.
#ifdef _LS_NO_IMPLICIT
#undef _LS_NO_IMPLICIT
#endif // #ifdef _LS_NO_IMPLICIT

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>
#include <afxdisp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__857ED3C1_A0BE_11D0_A6EB_00C04FC2C6D8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\smartref.inl ===
//-----------------------------------------------------------------------------
//  
//  File: SmartRef.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 



template <class T>
SmartRef< T >::SmartRef(
		const SmartRef<T> &other)
{
	m_pInterface = const_cast<T *>(other.m_pInterface);
	m_pInterface->AddRef();
}



template <class T>
void
SmartRef< T >::operator=(
		const SmartRef<T> &pInterface)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = ((SmartRef<T> &)pInterface).GetInterface(TRUE);
}



template <class T>
T **
SmartRef< T >::operator&(void)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
		m_pInterface = NULL;
	}

	return &m_pInterface;
}



template <class T>
T *
SmartRef< T >::ExtractImpl(void)
{
	T *pInterface = m_pInterface;
	m_pInterface = NULL;
	return pInterface;
}


template <class T>
T *
SmartRef< T >::GetInterfaceImpl(
	BOOL fAddRef /*= FALSE*/)
{
	// Should never ask to AddRef with a NULL pointer

	LTASSERT(!fAddRef || NULL != m_pInterface);

	if (fAddRef)
	{
		m_pInterface->AddRef();
	}

	return m_pInterface;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// 
// This should only be used to init a smart pointer.
// 
//-----------------------------------------------------------------------------
template <class T>
T * &
SmartRef< T >::opTpRef(void)
{
	LTASSERT(m_pInterface == NULL);
	
	return m_pInterface;
}


template <class T>
void
SmartRef< T >::opEqImpl(
		T *pOther)
{
	if (m_pInterface != NULL)
	{
		m_pInterface->Release();
	}
	m_pInterface = pOther;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\smartptr.inl ===
//-----------------------------------------------------------------------------
//  
//  File: smartptr.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

template <class T>
SmartPtr< T >::SmartPtr()
{
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::SmartPtr(
		T *pObject)
{
	m_pObject = pObject;
}



template <class T>
T &
SmartPtr< T >::operator*(void)
		const
{
	LTASSERT(m_pObject != NULL);
	return *m_pObject;
}



template <class T>
T *
SmartPtr< T >::operator->(void)
		const
{
	LTASSERT(m_pObject != NULL);
	
	return m_pObject;
}


template <class  T>
T *
SmartPtr< T >::Extract(void)
{
	T *pObj = m_pObject;
	m_pObject = NULL;

	return pObj;
}



template <class T>
T*
SmartPtr< T >::GetPointer(void)
{
	return m_pObject;
}


template <class T>
const T*
SmartPtr< T >::GetPointer(void) const
{
	return m_pObject;
}


template <class T>
BOOL
SmartPtr< T >::IsNull(void)
		const
{
	return m_pObject == NULL;
}



template <class T>
void
SmartPtr< T >::operator=(
		T *pObject)
{
	LTASSERT(m_pObject == NULL);

	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
	m_pObject = pObject;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  This should only be used to init a smart pointer.
//  
//-----------------------------------------------------------------------------
template <class T>
SmartPtr< T >::operator T * & (void)
{
	LTASSERT(m_pObject == NULL);
	
	return m_pObject;
}


template <class T>
void
SmartPtr< T >::operator delete(
		void *)
{
	LTASSERT(m_pObject != NULL);

	delete m_pObject;
	m_pObject = NULL;
}



template <class T>
SmartPtr< T >::~SmartPtr()
{
	if (m_pObject != NULL)
	{
		delete m_pObject;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\stacktrace.h ===
//-----------------------------------------------------------------------------
//  
//  File: stacktrace.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Provides a mechanism for generating stacktraces and converting them to
//  human readable form.
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_STACKTRACE_H
#define ESPUTIL_STACKTRACE_H


const UINT MODULE_NAME_LEN = 64;
const UINT SYMBOL_NAME_LEN = 128;


//
//  'human readable' form of a stack-frame.  Provides module and function name.
namespace LocStudio {

struct SYMBOL_INFO
{
	DWORD dwAddress;
	DWORD dwOffset;
    TCHAR szModule[MODULE_NAME_LEN];
    TCHAR szSymbol[SYMBOL_NAME_LEN];
	BOOL fSymbolLocated;
};

} // namespace LocStudio

#pragma warning(disable:4275)

//
//  How we return a complete human readable stack walk.
//
class LTAPIENTRY CSymbolList : public CTypedPtrList<CPtrList, LocStudio::SYMBOL_INFO *>
{
public:
	CSymbolList();

	void Clear(void);
	~CSymbolList();

private:
	CSymbolList(const CSymbolList &);
	void operator=(const CSymbolList &);
};

#pragma warning(default:4275)	

//
//  Class for generating stack traces.  Provides both native (compact) data
//  (in case you want to store it for later), and a human (versbose) form.
//
#pragma warning(disable : 4251)
class LTAPIENTRY CStackTrace
{
public:
	CStackTrace();

	~CStackTrace();

	void CreateStackTrace(void);
	void CreateStackTrace(UINT nSkip, UINT nTotal);
	void SetAddresses(const CDWordArray &);
	
	const CDWordArray &GetAddresses(void) const;

	void GetSymbolList(CSymbolList &) const;
	
private:
	CStackTrace(const CStackTrace &);
	void operator=(const CStackTrace &);

	CDWordArray m_adwAddresses;
};
#pragma warning(default : 4251)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\stringtokenizer.h ===
//-----------------------------------------------------------------------------
//  
//  File: StringTokenizer.h
//  Copyright (C) 1997 Microsoft Corporation
//  All rights reserved.
//
//  This file declares the CStringTokenizer class, which implements simple
//  linear tokenization of a String. The set of delimiters, which defaults
//  to common whitespace characters, may be specified at creation time or on a 
//  per-token basis.
//  Example usage:
//	CString s = "a test string";
//	CStringTokenizer st = new CStringTokenizer(s);
//	while (st.hasMoreTokens())
//  {
//		cout << st.nextToken() << endl;
//	}
//-----------------------------------------------------------------------------
#pragma once

#ifndef StringTokenizer_h
#define StringTokenizer_h

class LTAPIENTRY CStringTokenizer 
{
public:
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//-----------------------------------------------------------------------------
  CStringTokenizer();
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer with default delimiters
//   str - in, the string to be tokenized
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str, const WCHAR* delimiters);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// constructs a tokenizer
//   str - in, the string to be tokenized
//   delimiters - in, the delimiters; null terminated
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  CStringTokenizer(const WCHAR* str,
                   const WCHAR* delimiters,
                   BOOL  returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// destructs this tokenizer
//-----------------------------------------------------------------------------
  virtual ~CStringTokenizer();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// configure whether return delimiter as token
//   returnTokens - in, TRUE indicates return delimiter as token
//-----------------------------------------------------------------------------
  void setReturnTokens(BOOL returnTokens);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// sets delimiters
//   delimiters - in, the delimiters; null terminated
//-----------------------------------------------------------------------------
  void setDelimiters(const WCHAR* delimiters);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// parse a string to be tokenized
//   str - in, the null terminated string
//-----------------------------------------------------------------------------
  void parse(const WCHAR* str);
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// checks whether there are more tokens
//-----------------------------------------------------------------------------
  BOOL hasMoreTokens();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// get next token
//   length - out, the length of the token
//   return the pointer to the begining of the token
//-----------------------------------------------------------------------------
  const WCHAR* nextToken(unsigned int & length);

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// count total number of tokens
//-----------------------------------------------------------------------------
  int     countTokens();

private:
  void skipDelimiters();
  int  IsDelimiter(WCHAR ch) const;

  int          m_currentPosition;
  int          m_maxPosition;
  const WCHAR* m_str;
  WCHAR*       m_delimiters;
  int          m_lenDelimiters;
  BOOL         m_retTokens;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\strlist.h ===
//-----------------------------------------------------------------------------
//  
//  File: strlist.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef ESPUTIL_STRLIST_H
#define ESPUTIL_STRLIST_H


const UINT NO_INDEX = (DWORD) -1;
	
template<class T>
class CLocThingList
{
	
public:
	NOTHROW CLocThingList();

	UINT NOTHROW GetIndex(void) const;
	const CArray<T, T&> &GetStringArray(void) const;
	BOOL NOTHROW AdditionsAllowed(void) const;

	void SetThingList(const CArray<T, T&> &);
	UINT AddThing(T &);
	void InsertThing(UINT idxInsert, T & tNew);
	BOOL DeleteThing(UINT);
	BOOL NOTHROW SetIndex(UINT);
	void NOTHROW SetAdditionsAllowed(BOOL);
	UINT GetSize();

	const CLocThingList<T> &operator=(const CLocThingList<T> &);
	int NOTHROW operator==(const CLocThingList<T> &) const;
	int NOTHROW operator!=(const CLocThingList<T> &) const;
	
	NOTHROW ~CLocThingList();

private:
	CLocThingList(const CLocThingList<T> &);

	UINT m_uiIndex;
	CArray<T, T&> m_aThings;
	BOOL m_fAdditionsAllowed;
};

#include "strlist.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\uiopthelp.h ===
//-----------------------------------------------------------------------------
//  
//  File: uiopthelp.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class used to represent a single 'option'.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#pragma once

//
// Base structure
//
struct UI_OPTS_BASE
{
	TCHAR* pszName;				   // internal name of the option 
	UINT nDisplayName;			   // string id of the display name
	UINT nDisplayHelp;			   // string id of the help string
	PFNOnValidateUIOption pfnVal;    // function to call during validation. 
	                               // This may be null
	WORD wStorageTypes;			   // storage type of option	
	CLocUIOptionDef::ControlType wReadOnly;	  // ReadOnly value
	CLocUIOptionDef::ControlType wVisible;	  // Visible value
};



// Structures of option data

//
// BOOL options
//

struct UI_OPTS_BOOL
{
	UI_OPTS_BASE base;                // base class data 
	BOOL bDefValue;				   // default value of the option
	CLocUIOption::EditorType et;     // type of BOOL option
};

//
//  PICK options
//

struct UI_OPTS_PICK
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	BOOL bAdd;					   // allow additions to the list	
	UINT nListEntries;             // list of entries to pick from
	                               // Each entry is separated by \n
	                               // The last entry does not have a \n
};

const TCHAR UI_PICK_TERMINATOR = _T('\n');

// 
// DWORD options

struct UI_OPTS_DWORD
{
	UI_OPTS_BASE base;                // base class data 
	DWORD dwDefValue;			   // default value of the option
	CLocUIOption::EditorType et;     // type of DWORD option
};


//
// String options
//
struct UI_OPTS_STR
{
	UI_OPTS_BASE base;                // base class data 
	UINT nDefValue;				   // string table entry for default value 
	CLocUIOption::EditorType et;
};


//
//  String list options
//

struct UI_OPTS_STRLIST
{
	UI_OPTS_BASE base;					// base class data 
	UINT nDefList;						// Each entry is separated by \n
										// The last entry does not have a \n
};


//
// File Name options
//
struct UI_OPTS_FILENAME
{
	UI_OPTS_BASE base;                // base class data 
	UINT nExtensions;	    		  // The default extensions to the UI
	UINT nDefValue;			  	      // string table entry for default value 
};


//
// Helper class definition
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionImpHelper : public CObject
{
public:

	CLocUIOptionImpHelper(HINSTANCE hInst);

	void GetOptions(CLocUIOptionSet *pOptionSet, UINT nDesc, UINT nHelp);
	
	void SetBools(const UI_OPTS_BOOL* pBools, int nCntBools);
	void SetPicks(const UI_OPTS_PICK* pPicks, int nCntPicks);
	void SetDwords(const UI_OPTS_DWORD* pDwords, int nCntDwords);
	void SetStrs(const UI_OPTS_STR* pStrs, int nCntStrs);
	void SetStrLists(const UI_OPTS_STRLIST* pStrLists, int nCntStrLists);
	void SetFNames(const UI_OPTS_FILENAME* pFNames, int nCntFNames);

	void AssertValid(void) const;

protected:
	HINSTANCE m_hInst;

	const UI_OPTS_BOOL* m_pBools;
	int m_nCntBools;

	const UI_OPTS_PICK* m_pPicks;
	int m_nCntPicks;

	const UI_OPTS_DWORD* m_pDwords;
	int m_nCntDwords;

	const UI_OPTS_STR* m_pStrs;
	int m_nCntStrs;

	const UI_OPTS_STRLIST* m_pStrLists;
	int m_nCntStrLists;

	const UI_OPTS_FILENAME* m_pFNames;
	int m_nCntFNames;

	void GetBoolOptions(CLocUIOptionSet* pOptionSet);
	void GetPicksOptions(CLocUIOptionSet* pOptionSet);
	void GetDwordsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrsOptions(CLocUIOptionSet* pOptionSet);
	void GetStrListsOptions(CLocUIOptionSet* pOptionSet);
	void GetFNamesOptions(CLocUIOptionSet* pOptionSet);

	void GetListFromId(UINT nId, CPasStringList& pasList);
	void GetStringFromId(UINT nId, CPascalString& pas);
};

#pragma warning(default : 4275)

//
// Helper macros for building data structures
//
// The _EXT versions of the macros allow setting the less common
// attributes (readonly and visible)
//


// BOOL
#define BEGIN_LOC_UI_OPTIONS_BOOL(var) \
const UI_OPTS_BOOL var[] =    \
{								 

#define LOC_UI_OPTIONS_BOOL_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_BOOL_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_BOOL() \
}                             



// Pick
#define BEGIN_LOC_UI_OPTIONS_PICK(var) \
const UI_OPTS_PICK var[] = \
{

#define LOC_UI_OPTIONS_PICK_ENTRY(name, def, add, list, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, add, list}

#define LOC_UI_OPTIONS_PICK_ENTRY_EXT(name, def, add, list, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, add, list}

#define END_LOC_UI_OPTIONS_PICK() \
}


// DWORD
#define BEGIN_LOC_UI_OPTIONS_DWORD(var) \
const UI_OPTS_DWORD var[] =    \
{								 

#define LOC_UI_OPTIONS_DWORD_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault},def, et}

#define LOC_UI_OPTIONS_DWORD_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible},def, et}

#define END_LOC_UI_OPTIONS_DWORD() \
}


// String
#define BEGIN_LOC_UI_OPTIONS_STR(var) \
const UI_OPTS_STR var[] =    \
{								 

#define LOC_UI_OPTIONS_STR_ENTRY(name, def, et, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def, et}

#define LOC_UI_OPTIONS_STR_ENTRY_EXT(name, def, et, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def, et}

#define END_LOC_UI_OPTIONS_STR() \
}


// String List
#define BEGIN_LOC_UI_OPTIONS_STRLIST(var) \
const UI_OPTS_STRLIST var[] =    \
{								 

#define LOC_UI_OPTIONS_STRLIST_ENTRY(name, def, id, idHelp, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, def}

#define LOC_UI_OPTIONS_STRLIST_ENTRY_EXT(name, def, id, idHelp, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, def}

#define END_LOC_UI_OPTIONS_STRLIST() \
}

// File Names
#define BEGIN_LOC_UI_OPTIONS_FILENAME(var) \
const UI_OPTS_FILENAME var[] =    \
{								 

#define LOC_UI_OPTIONS_FILENAME_ENTRY(name, def, id, idHelp, idExt, pfnval, st) \
	{ {name, id, idHelp, pfnval, st, CLocUIOptionDef::ctDefault,  CLocUIOptionDef::ctDefault}, idExt, def}

#define LOC_UI_OPTIONS_FILENAME_ENTRY_EXT(name, def, id, idHelp, idExt, pfnval, st, ro, visible) \
	{ {name, id, idHelp, pfnval, st, ro, visible}, idExt, def}

#define END_LOC_UI_OPTIONS_FILENAME() \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\uioptions.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uioptions.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------




inline
CLocUIOption::CLocUIOption()
{
	m_hDescDll = NULL;
	m_hHelpDll = NULL;
	m_idsDesc = 0;
	m_idsHelp = 0;
	m_etEditor = etNone;

	m_wStorageTypes = 0;
	m_uiDisplayOrder = 0;

	m_pParent = NULL;
}



inline
void
CLocUIOption::SetDescription(
		const HINSTANCE hDll,
		UINT nDescriptionID)
{
	m_hDescDll = hDll;
	m_idsDesc = nDescriptionID;
}



inline
void
CLocUIOption::SetHelpText(
		const HINSTANCE hDll,
		UINT nHelpTextId)
{
	m_hHelpDll = hDll;
	m_idsHelp = nHelpTextId;
}



inline
void
CLocUIOption::SetEditor(
		EditorType et)
{
	m_etEditor = et;
}


inline
void
CLocUIOption::SetStorageTypes(
		WORD wStorageTypes)
{
	m_wStorageTypes = wStorageTypes;
}



inline 
CLocUIOption::EditorType
CLocUIOption::GetEditor(void) 
		const
{
	return m_etEditor;
}



inline
void
CLocUIOption::GetDescription(
		CLString &strDesc)
		const
{
	LTASSERT(m_hDescDll != NULL);
	LTASSERT(m_idsDesc != 0);
	
	strDesc.LoadString(m_hDescDll, m_idsDesc);
}



inline
void
CLocUIOption::GetHelpText(
		CLString &strHelp)
		const
{
	LTASSERT(m_hHelpDll != NULL);
	LTASSERT(m_idsHelp != 0);

	strHelp.LoadString(m_hHelpDll, m_idsHelp);
}



inline
WORD
CLocUIOption::GetStorageTypes(void)
		const
{
	return m_wStorageTypes;
}



inline
void
CLocUIOption::SetParent(
		CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}



inline
const CLocUIOptionSet *
CLocUIOption::GetParent(void)
		const
{
	return m_pParent;
}



inline
const CLocUIOptionData &
CLocUIOption::GetOptionValues(void) const
{
	return m_Values;
}



inline
CLocUIOptionData &
CLocUIOption::GetOptionValues(void)
{
	return m_Values;
}

inline
void CLocUIOptionDef::SetReadOnly(
	ControlType ct)
{
	m_ctReadOnly = ct;		
}	

inline
void CLocUIOptionDef::SetVisible(
	ControlType ct)
{
	m_ctVisible = ct;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\stringblast.h ===
//******************************************************************************
//
// StringBlast.h: Microsoft LocStudio
//
// Copyright (C) 1996-1997 by Microsoft Corporation.
// All rights reserved.
//
//******************************************************************************

#if !defined(MITUTIL__StringBlast_h__INCLUDED)
#define MITUTIL__StringBlast_h__INCLUDED

//------------------------------------------------------------------------------
struct LTAPIENTRY StringBlast
{
// Fast Win32 conversions
	static CLString MakeString(_bstr_t bstrSrc);
	static CLString MakeString(const CPascalString & pasSrc);
	static CLString MakeStringFromBStr(BSTR bstrSrc);
	static CLString MakeStringFromWide(const wchar_t * szwSrc);

	static _bstr_t MakeBStr(const char * szBuffer);
	static _bstr_t MakeBStrFromWide(const wchar_t * wszBuffer);
	static _bstr_t MakeBStr(const CLString & stSrc);
	static _bstr_t MakeBStrFromBStr(BSTR bstrSrc);
	static _bstr_t MakeBStr(const CPascalString & pasSrc);
	static _bstr_t MakeBStr(HINSTANCE hDll, UINT nStringID);

	// Use these functions when you need to get a raw BSTR
	static BSTR MakeDetachedBStr(const char * szBuffer);
	static BSTR MakeDetachedBStrFromWide(const wchar_t * wszBuffer);
	static BSTR MakeDetachedBStr(const CLString & stSrc);

};

#endif // MITUTIL__StringBlast_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\strlist.inl ===
//-----------------------------------------------------------------------------
//  
//  File: strlist.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 

template <class T>
CLocThingList<T>::CLocThingList()
{
	m_fAdditionsAllowed = FALSE;
	m_uiIndex = NO_INDEX;
}


template <class T>
UINT
CLocThingList<T>::GetIndex(void)
		const
{
	return m_uiIndex;
}



template <class T>
const CArray<T, T&> &
CLocThingList<T>::GetStringArray(void)
		const
{
	return m_aThings;
}



template <class T>
BOOL
CLocThingList<T>::AdditionsAllowed(void)
		const
{
	return m_fAdditionsAllowed;
}



template <class T>
void
CLocThingList<T>::SetThingList(
		const CArray<T, T&> &aNewThings)
{
	UINT uiNewSize = aNewThings.GetSize();
	
	m_aThings.SetSize(uiNewSize);

	for (UINT i=0; i<uiNewSize; i++)
	{
		m_aThings[i] = aNewThings[i];
	}
}



template <class T>
inline
UINT
CLocThingList<T>::AddThing(
		T &NewThing)
{
	return m_aThings.Add(NewThing);
}


template <class T>
inline
void
CLocThingList<T>::InsertThing(
		UINT idxInsert, 
		T & tNew
		)
{
	m_aThings.InsertAt(idxInsert, tNew);
}


template <class T>
inline
BOOL
CLocThingList<T>::DeleteThing(
		UINT iIndex)
{
    BOOL fRetVal = FALSE;
	if (iIndex < GetSize())
	{
		m_aThings.RemoveAt(iIndex);
		fRetVal = TRUE;
	}
	return fRetVal;	
}



template <class T>
inline
BOOL
CLocThingList<T>::SetIndex(
		UINT uiNewIndex)
{
	m_uiIndex = uiNewIndex;
	return FALSE;
}



template <class T>
inline
void
CLocThingList<T>::SetAdditionsAllowed(
		BOOL fAllowed)
{
	m_fAdditionsAllowed = fAllowed;
}


template <class T>
inline
UINT
CLocThingList<T>::GetSize()
{
	return m_aThings.GetSize();
}


template <class T>
const CLocThingList<T> &
CLocThingList<T>::operator=(
		const CLocThingList<T>& slOther)
{
	SetThingList(slOther.GetStringArray());
	SetIndex(slOther.GetIndex());

	SetAdditionsAllowed(slOther.AdditionsAllowed());
	
	return *this;
}


template <class T>
CLocThingList<T>::~CLocThingList()
{
	m_aThings.SetSize(0);
}

template <class T>
inline
int 
CLocThingList<T>::operator==(
		const CLocThingList<T>& list)
		const
{
	if (m_uiIndex != list.m_uiIndex
		|| m_fAdditionsAllowed != list.m_fAdditionsAllowed
		|| m_aThings.GetSize() != list.m_aThings.GetSize())
	{
		return 0;
	}

	for (int i=m_aThings.GetUpperBound(); i>=0; i--)
	{
		if (m_aThings[i] != list.m_aThings[i])
		{
			return 0;
		}
	}
	
	return 1;
}

template <class T>
inline
int 
CLocThingList<T>::operator!=(
		const CLocThingList<T>& list)
		const
{
	return !(operator==(list));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\worddiff.h ===
//-----------------------------------------------------------------------------
//  
//  File: worddiff.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Declaration of the CWordDiff
//-----------------------------------------------------------------------------
 
#ifndef WORDDIFF_H
#define WORDDIFF_H

typedef _bstr_t CWordUnit;

class CWordDiff : public CDifference
{
public:
	CWordDiff(ChangeType type, 
		int nOldPos,
		int nNewPos,
		bool bIsFirst,
		bool bIsLast,
		_bstr_t bstrWord,
		const wchar_t * pwszPrefix,
		const wchar_t * pwszSufix);

	virtual ChangeType GetChangeType() const;	// types of change that caused the difference
	virtual const wchar_t * GetUnit() const; // comparison unit (0-terminated string)
	virtual int GetOldUnitPosition() const; // 0-based position in old sequence. -1 if Added
	virtual int GetNewUnitPosition() const;	// 0-based position in new sequence. -1 if Deleted
	virtual const wchar_t * GetPrefix() const; //prpend this string to unit string
	virtual const wchar_t * GetSufix() const; //append this string to unit string
	virtual bool IsFirst() const; //is this first difference in delta?
	virtual bool IsLast() const; //is this last difference in delta?

private:
	ChangeType m_ChangeType;
	CWordUnit m_Word;
	const wchar_t * m_pwszPrefix;
	const wchar_t * m_pwszSufix;
	bool m_bIsFirst;
	bool m_bIsLast;
	int m_nOldPos;
	int m_nNewPos;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "worddiff.inl"
#endif

#endif  //  WORDDIFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\uioptset.inl ===
//-----------------------------------------------------------------------------
//  
//  File: uioptset.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
inline		
void
CLocUIOptionSet::AddOption(
		CLocUIOption *pOption)
{
	m_olOptions.AddTail(pOption);

	pOption->SetParent(this);
}



inline
void
CLocUIOptionSet::AddOptionSet(
		CLocUIOptionSet *pOptionSet)
{
	m_oslSubOptions.AddTail(pOptionSet);

	pOptionSet->SetParent(this);
}


inline
const CLocUIOptionList &
CLocUIOptionSet::GetOptionList(void)
		const
{
	return m_olOptions;
}


inline
const CLocUIOptionSetList &
CLocUIOptionSet::GetOptionSets(void)
		const
{
	return m_oslSubOptions;
}



inline
const CLString &
CLocUIOptionSet::GetGroupName(void)
		const
{
	if (GetParent() != NULL)
	{
		return GetParent()->GetGroupName();
	}
	else
	{
		return m_strGroup;
	}
}

inline
UINT 
CLocUIOptionSet::GetDisplayOrder()
	 const
{
	return m_uiDisplayOrder;	
}	


inline
void
CLocUIOptionSet::SetDescription(
		const HINSTANCE hDll,
		UINT idsDesc)
{
	m_strDesc.LoadString(hDll, idsDesc);
}



inline
void
CLocUIOptionSet::SetDescription(
		const CLString &strDesc)
{
	m_strDesc = strDesc;
}


inline
void
CLocUIOptionSet::SetHelpText(
		const HINSTANCE hDll,
		UINT idsHelp)
{
	m_strHelp.LoadString(hDll, idsHelp);
}



inline
void
CLocUIOptionSet::SetHelpID(UINT uiHelpId)
{
	m_idHelp = uiHelpId;
}



inline
void
CLocUIOptionSet::SetGroupName(
		const TCHAR *szGroupName)
{
	m_strGroup = szGroupName;
}




inline
void
CLocUIOptionSet::SetHelpText(
		const CLString &strHelp)
{
	m_strHelp = strHelp;
}



inline
void
CLocUIOptionSet::GetDescription(
		CLString &strDesc)
		const
{
	strDesc = m_strDesc;
}



inline
void
CLocUIOptionSet::GetHelpText(
		CLString &strHelp)
		const
{
	strHelp = m_strHelp;
}



inline
UINT
CLocUIOptionSet::GetHelpID(void)
		const
{
	return m_idHelp;
}



inline
BOOL
CLocUIOptionSet::IsEmpty(void)
		const
{
	return m_olOptions.IsEmpty() && m_oslSubOptions.IsEmpty();
}


inline
void
CLocUIOptionSet::SetParent(
		const CLocUIOptionSet *pParent)
{
	m_pParent = pParent;
}

inline
void 
CLocUIOptionSet::SetDisplayOrder(
	UINT uiDisplayOrder)
{
	m_uiDisplayOrder = uiDisplayOrder;
}	


inline
const
CLocUIOptionSet *
CLocUIOptionSet::GetParent(void)
		const
{
	return m_pParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\uioptset.h ===
//-----------------------------------------------------------------------------
//  
//  File: uioptset.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class CLocUIOption;
class CLocUIOptionList;

class LTAPIENTRY CLocUIOptionEnumCallback : public CObject
{
public:
	CLocUIOptionEnumCallback() {};

	void AssertValid(void) const;
			
	virtual BOOL ProcessOption(CLocUIOption *) = 0;
	virtual BOOL ProcessOption(const CLocUIOption *) = 0;
	
private:
	CLocUIOptionEnumCallback(const CLocUIOptionEnumCallback &);
	void operator=(int);
};


class LTAPIENTRY CLocUIOptionSet;

class LTAPIENTRY CLocUIOptionSetList :
	public CTypedPtrList<CPtrList, CLocUIOptionSet *>
{
public:
	NOTHROW CLocUIOptionSetList() {};

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionSetList();

private:
	CLocUIOptionSetList(const CLocUIOptionSetList &);
	void operator=(const CLocUIOptionSetList &);
};


//
//  This is used to control the order of the tabs displayed in the options
//  dialog.
enum OptionSetDisplayOrder
{
	osDefault = 50
};



class LTAPIENTRY CLocUIOptionSet : public CRefCount, public CObject
{
public:
	NOTHROW CLocUIOptionSet();

	void AssertValid(void) const;
	
	NOTHROW void AddOption(CLocUIOption *);
	NOTHROW void AddOptionSet(CLocUIOptionSet *);
	NOTHROW void RemoveOptionSet(const TCHAR *);
	
	NOTHROW const CLocUIOptionList & GetOptionList(void) const;
	NOTHROW const CLocUIOptionSetList & GetOptionSets(void) const;
	NOTHROW BOOL FindUIOption(const TCHAR *, CLocUIOption *&pOption);
	NOTHROW BOOL FindUIOption(const TCHAR *, const CLocUIOption *&pOption) const;
	
	NOTHROW void SetDescription(const HINSTANCE hDescDll, UINT idsDesc);
	NOTHROW void SetDescription(const CLString &);
	NOTHROW void SetHelpText(const HINSTANCE hHelpDll, UINT idsHelp);
	NOTHROW void SetHelpText(const CLString &);
	NOTHROW void SetHelpID(UINT);
	void SetGroupName(const TCHAR *);
	NOTHROW void SetDisplayOrder(UINT);
	
	NOTHROW void GetDescription(CLString &) const;
	NOTHROW void GetHelpText(CLString &) const;
	NOTHROW UINT GetHelpID(void) const;
	NOTHROW BOOL IsEmpty(void) const;
	const CLString &GetGroupName(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
		
	BOOL EnumOptions(CLocUIOptionEnumCallback *);
	BOOL EnumOptions(CLocUIOptionEnumCallback *) const;
	
	virtual void OnChange(void) const = 0;
	
protected:
	NOTHROW virtual ~CLocUIOptionSet();

	void SetParent(const CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

private:
	CLocUIOptionList m_olOptions;
	CLocUIOptionSetList m_oslSubOptions;
	CLString m_strDesc, m_strHelp;
	UINT m_idHelp;
	const CLocUIOptionSet *m_pParent;
	CLString m_strGroup;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet(const CLocUIOptionSet &);
	void operator=(const CLocUIOptionSet &);
};


class LTAPIENTRY CLocUIOptionSetDef : public CLocUIOptionSet
{
public:
	CLocUIOptionSetDef();

	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);

	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;

	virtual void OnChange(void) const;

	const CLocUIOptionSetDef & operator=(const CLocUIOptionSetDef &);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
};

#pragma warning(default: 4275)
 
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptset.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\worddiff.inl ===
//-----------------------------------------------------------------------------
//  
//  File: worddiff.inl
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Implementation of CWordDiff
//-----------------------------------------------------------------------------
 
#include "ltdebug.h"

inline
CWordDiff::CWordDiff(
	CDifference::ChangeType type, 
	int nOldPos,
	int nNewPos,
	bool bIsFirst,
	bool bIsLast,
	_bstr_t bstrWord,
	const wchar_t * pwszPrefix,
	const wchar_t * pwszSufix) :
	m_ChangeType(type), m_Word(bstrWord), m_pwszPrefix(pwszPrefix),
	m_pwszSufix(pwszSufix), m_bIsFirst(bIsFirst), m_bIsLast(bIsLast),
	m_nOldPos(nOldPos), m_nNewPos(nNewPos)

{
	LTASSERT(pwszPrefix != NULL);
	LTASSERT(pwszSufix != NULL);
	LTASSERT(nOldPos >= -1);
	LTASSERT(nNewPos >= -1);
}

inline
CDifference::ChangeType 
CWordDiff::GetChangeType() 
const
{
	return m_ChangeType;
}

inline
const wchar_t * 
CWordDiff::GetUnit() 
const
{
	return m_Word;
}

inline
int 
CWordDiff::GetOldUnitPosition() 
const 
{
	return m_nOldPos;
}

inline
int 
CWordDiff::GetNewUnitPosition() 
const
{
	return m_nNewPos;
}

inline
const wchar_t * 
CWordDiff::GetPrefix() 
const
{
	return m_pwszPrefix;
}

inline
const wchar_t * 
CWordDiff::GetSufix() 
const
{
	return m_pwszSufix;
}

inline
bool 
CWordDiff::IsFirst() 
const
{
	return m_bIsFirst;
}

inline
bool 
CWordDiff::IsLast() 
const
{
	return m_bIsLast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\mit\mitutil\uioptions.h ===
//-----------------------------------------------------------------------------
//  
//  File: uioptions.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once


class CReport;

#pragma warning(disable : 4251)

class LTAPIENTRY CLocUIOptionData
{
public:

	enum OptVal
	{
		ovCurrent,
		ovDefault,
		ovUser,
		ovOverride
	};
	
	CLocOptionVal *GetOptionValue(OptVal);

	CLocOptionVal *GetOptionValue(OptVal) const;
	
	void SetOptionValue(OptVal, CLocOptionVal *);
	BOOL Purge(void);
	
private:
	SmartRef<CLocOptionVal> m_spCurrentVal;
	SmartRef<CLocOptionVal> m_spUserVal;
	SmartRef<CLocOptionVal> m_spOverrideVal;
};


class CLocUIOptionSet;

class LTAPIENTRY CLocUIOption: public CLocOptionVal
{
public:
	CLocUIOption();

	void AssertValid(void) const;

	//
	//  New editor types should go at the END, so that old parsers
	//  can still use the ENUM without being re-compiled..
	//
	enum EditorType
	{
		etNone,
		etInteger,						// Maps to lvtInteger
		etUINT,							// Maps to lvtInteger
		etString,						// Maps to lvtString
		etFileName,						// Maps to lvtFileName
		etDirName,						// Maps to lvtString
		etStringList,					// Maps to lvtStringList
		etPickOne,						// Maps to lvtStringList
		etCheckBox,						// Maps to lvtBOOL
		etTrueFalse,					// Maps to lvtBOOL
		etYesNo,						// Maps to lvtBOOL
		etOnOff,						// Maps to lvtBOOL
		etCustom,						// Custom editor
	};

	//
	//  Used as bit flags to indicate where the option can be stored.
	enum StorageType
	{
		stUser = 0x0001,
		stOverride = 0x0002
	};

	enum OptionCode
	{
		ocNoError,
		ocUnknownOption,
		ocInvalidValue,
		ocInvalidType
	};

	void NOTHROW SetDescription(const HINSTANCE hDll, UINT nDescriptionID);
	void NOTHROW SetHelpText(const HINSTANCE hDll, UINT nHelpTextId);
	void NOTHROW SetEditor(EditorType);
	void NOTHROW SetStorageTypes(WORD);
	void NOTHROW SetDisplayOrder(UINT);
	
	void NOTHROW GetDescription(CLString &) const;
	void NOTHROW GetHelpText(CLString &) const;
	EditorType NOTHROW GetEditor(void) const;
	WORD NOTHROW GetStorageTypes(void) const;
	UINT NOTHROW GetDisplayOrder(void) const;
	CLocUIOptionData::OptVal GetOptionValLocation(void) const;
	
	virtual BOOL IsReadOnly(void) const = 0;
	virtual BOOL IsVisible(void) const = 0;
	virtual const CLString &GetGroupName(void) const = 0;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const = 0;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE) = 0;
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var) = 0;

protected:
	virtual ~CLocUIOption();

	friend class CLocUIOptionSet;
	friend class CLocOptionManager;
	friend class CUpdateOptionValCallback;
	
	void SetParent(CLocUIOptionSet *);
	const CLocUIOptionSet *GetParent(void) const;

	const CLocUIOptionData &GetOptionValues(void) const;
	CLocUIOptionData &GetOptionValues(void);
	
private:
	HINSTANCE m_hDescDll, m_hHelpDll;
	UINT m_idsDesc, m_idsHelp;
	EditorType m_etEditor;
	WORD m_wStorageTypes;
	UINT m_uiDisplayOrder;
	
	CLocUIOptionSet *m_pParent;
	CLocUIOptionData m_Values;
};


// Validate callback function
// This function will be called during the ValidateOption handling.

typedef CLocUIOption::OptionCode (*PFNOnValidateUIOption)
	(const CLocUIOption *pOption, CReport *pReport, const CLocVariant&);
 
class LTAPIENTRY CLocUIOptionDef : public CLocUIOption
{
public:
	CLocUIOptionDef();
	
	enum ControlType
	{
		ctDefault,
		ctAlways,
		ctNever
	};
	
	void SetReadOnly(ControlType);
	void SetVisible(ControlType);
	
	virtual BOOL IsReadOnly(void) const;
	virtual BOOL IsVisible(void) const;
	virtual const CLString &GetGroupName(void) const;
	virtual OptionCode ValidateOption(CReport *, 
		const CLocVariant& var) const;
	virtual void FormatDisplayString(const CLocVariant& var, 
		CLString& strOut, BOOL fVerbose = FALSE);
	virtual void EditCustom(CWnd* pWndParent, CLocVariant& var);

	void SetValidationFunction(PFNOnValidateUIOption);
	
private:
	ControlType m_ctReadOnly;
	ControlType m_ctVisible;
	PFNOnValidateUIOption m_pfnValidate;
};

	

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocUIOptionList :
	public CTypedPtrList<CPtrList, CLocUIOption *>
{
public:
	NOTHROW CLocUIOptionList();

	void AssertValid(void) const;

	NOTHROW ~CLocUIOptionList();
 
private:
	CLocUIOptionList(const CLocUIOptionList &);

	void operator=(const CLocUIOptionList &);
};

#pragma warning(default: 4275 4251)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "uioptions.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parseman\pdesc.h ===
//-----------------------------------------------------------------------------
//  
//  File: pdesc.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PARSEMAN_PDESC_H
#define PARSEMAN_PDESC_H

typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

//
//  This class is used to gather all the file descriptions before
//  we write them into the registry.  
//
class CFileDescriptionsCallback : public CEnumCallback
{
public:
	CFileDescriptionsCallback();
	
	BOOL ProcessEnum(const EnumInfo &);
	
	const FileDescriptionList &GetFileDescriptions(void) const;
	
	~CFileDescriptionsCallback();
	
private:
	FileDescriptionList m_FileDescriptions;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parseman\pinfo.h ===
//-----------------------------------------------------------------------------
//  
//  File: pinfo.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Class that holds information about a parser.
//  
//-----------------------------------------------------------------------------
 
#ifndef PINFO_H
#define PINFO_H


class CLocParserManager;

class CLocParserInfo;
typedef CTypedPtrList<CPtrList, CLocParserInfo *> CLocParserList;

#pragma warning(disable : 4251)

interface ILocParser;
interface ILocStringValidation;

class LTAPIENTRY CLocParserInfo : public CLObject
{
public:

	void AssertValid(void) const;

	const CLString &GetParserName(void) const;
	const CLString &GetParserDescription(void) const;
	const CLString &GetParserHelp(void) const;
	ParserId GetParserId(void) const;
	BOOL GetDllVersion(CLString &) const;
	const CLocExtensionList &GetExtensionList() const;
	const CLocParserList &GetSubParserList(void) const;

	~CLocParserInfo();

protected:
	friend CLocParserManager;
	
	CLocParserInfo();

	HINSTANCE GetParserHandle(void) const;
	ILocParser * GetParserPointer(void) const;
	ILocStringValidation *GetValidationPointer(void);
	
	BOOL LoadParserDll(void);
	BOOL InitSubParsers(ILocParser *);
	
	BOOL FreeParserDll(void);
	BOOL AttemptUnload(void);
	
	BOOL IsLoaded(void) const;
	
	void SetParserName(const CLString &);
	void SetParserDescription(const CLString &);
	void SetParserHelp(const CLString &);
	
	void SetParserId(ParserId);
	BOOL SetExtensionList(const CLString  &);
	void AddSubParser(CLocParserInfo *);
	void AddExtensions(const CLocExtensionList &);
	CLocParserList &GetSubParserList(void);

	clock_t GetLastAccessTime(void) const;
	
	static BOOL LoadParserDll(const CLString &strFileName,
			CReporter *pReporter, HMODULE &hDll, ILocParser *&pLocParser);
	static BOOL GetParserObjects(CReporter *, CLoadLibrary &, ILocParser *&);
	
private:
	
	CLString m_strParserName;
	CLString m_strParserDescription;
	CLString m_strParserHelp;
	CLocExtensionList m_elExtList;
	ParserId m_pidParserId;
	HINSTANCE m_hParserDll;
	ILocParser *m_pParserObject;
	ILocStringValidation *m_pValidationObject;
	BOOL m_fLoadAttempted;
	BOOL m_fValidationTried;
	UINT m_uiSubParserUsageCount;
	mutable clock_t m_tLastAccess;
	
	CLocParserList m_pSubParsers;
};

#pragma warning(default : 4251)



#endif  // PINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parseman\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by parseman.rc
//
#define IDS_PARSEMAN_CONTEXT            12700
#define IDS_BAD_VERSION                 12701
#define IDS_FILT_ALL_FILES              12702
#define IDS_DEBUG_MISMATCH              12703

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\locchild.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocChild.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCCHILD_H)
#define PARSUTIL_LOCCHILD_H


#pragma warning(disable : 4275)


class CPULocParser;

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocChild : public CLUnknown, public CLObject
{
// Construction
public:
	CPULocChild(CPULocParser * pParent);
	virtual ~CPULocChild();

// Data
private:
	CPULocParser * m_pParent;

// Attributes
public:
	CPULocParser * GetParent() const;

// COM Interfaces
public:

// Overrides
public:

// Implementation
protected:

	//  CLObject

	virtual void AssertValid(void) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parseman\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
#include <afxtempl.h>

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parseman\pmanager.h ===
//-----------------------------------------------------------------------------
//  
//  File: pmanager.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Owner: MHotchin
//  
//-----------------------------------------------------------------------------
 
#ifndef PMANAGER_H
#define PMANAGER_H


#pragma warning(disable : 4251)

typedef CTypedPtrMap<CMapWordToPtr, ParserId, CLocParserInfo *> CLocParserMap;
typedef CTypedPtrMap<CMapStringToPtr, CString, CLocParserList *> CLocExtMap;
typedef CTypedPtrList<CPtrList, EnumInfo *> FileDescriptionList;

interface ILocFile;
struct ParserInfo;

class CParserUnloader;

class LTAPIENTRY CLocParserManager : public CLObject
{
	friend CLocParserInfo;
public:
	CLocParserManager();
	
	void AssertValid(void) const;
	
	BOOL InitParserManager(IUnknown *);
	static BOOL ReloadRegistry(void);
	static void UnloadParsers(void);
	static void UnloadUnusedParsers(void);
	
	static void GetManagerVersion(DWORD &dwMajor, DWORD &dwMinor, BOOL &fDebug);
	static BOOL AddParserToSystem(const CLString &);
	static const CLocParserInfo *GetParserInfo(ParserId pid, ParserId pidParent);
	static BOOL RemoveParserFromSystem(ParserId pid, ParserId pidParent);
	static UINT FindParsers(void);
	
	static BOOL GetLocParser(ParserId, ILocParser *&);
	static BOOL GetLocFile(const CFileSpec &, ParserId, FileType,
			ILocFile *&, CReporter &);
	static BOOL FindLocFile(const CPascalString &, CLocParserIdArray &);
	static BOOL GetStringValidation(ParserId, ILocStringValidation *&);
	
	static const CLocParserList &GetParserList(void);

	static void GetParserFilterString(CLString &);

	~CLocParserManager();

protected:
	static void RemoveCurrentInfo(void);
	static BOOL LoadParserInfo(const HKEY &, CLocParserInfo *&);
	static BOOL LoadMasterParserInfo(const HKEY &);
	static BOOL LoadSubParsers(const HKEY &, CLocParserInfo *);
	static BOOL WriteFileTypes(const HKEY &, const FileDescriptionList &);
	
	static BOOL OpenParserSubKey(HKEY &, ParserId, ParserId);
	static BOOL AddParserToRegistry(const CLString &, const ParserInfo &,
			const FileDescriptionList &);

	static void AddToFilter(const CLocParserInfo *, const CLocExtensionList &);

private:
	static LONG             m_lRefCount;    // 
	static CLocParserMap    m_ParserMap;    // Associative map, ID -> Parser.
	static CLocParserList   m_ParserList;   // List of open parser DLL's.
	static CLocParserList   m_SubParserList;// list of all sub-parsers.
	static CLocExtMap       m_ExtensionMap;	// Associative map, extension->parser.
	static CLString         m_strFilter;    // Filter list for parser files.
	static IUnknown *       m_pUnknown;
	static CParserUnloader  m_Unloader;
};


//
//  Undecorated versions of these functions for GetProcAddress users...
//
extern "C"
{
	LTAPIENTRY HRESULT AddParserToSystem(const TCHAR *strFileName);
	LTAPIENTRY HRESULT RemoveParserFromSystem(ParserId pid, ParserId pidParent);
}

		
#pragma warning(default : 4251)

#endif // PMANAGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parseman\unloader.h ===
//-----------------------------------------------------------------------------
//  
//  File: uloader.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#pragma once

class CParserUnloader : public CFlushMemory
{
public:
	CParserUnloader(BOOL fDelete);
	
	void FlushMemory(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\locparser.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocParser.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCPARSER_H)
#define PARSUTIL_LOCPARSER_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocParser : public ILocParser, public CLObject
{
// Construction
public:
	CPULocParser(HINSTANCE hDll);
	virtual ~CPULocParser();

// Data
private:
	ULONG				m_ulRefCount;	// COM reference count
	HINSTANCE			m_hInst;		// Instance Handle

	BOOL				m_fEnableVersion;
	BOOL				m_fEnableBinary;
	BOOL				m_fEnableStrVal;

// COM Interfaces
public:

	//  IUnknown standard interface.
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID * ppvObj);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocParser interface implementation
	HRESULT STDMETHODCALLTYPE Init(IUnknown *);
	HRESULT STDMETHODCALLTYPE CreateFileInstance(ILocFile * REFERENCE, FileType);
	void STDMETHODCALLTYPE GetParserInfo(ParserInfo &) const;
	void STDMETHODCALLTYPE GetFileDescriptions(CEnumCallback &) const;

// Operations
public:

// Implementation
protected:
	BOOL EnableInterface(REFIID riid, BOOL fEnable = TRUE);
	virtual BOOL IsInterfaceEnabled(REFIID riid) const;

// Overrides
public:

	// IUnknown
	virtual HRESULT OnQueryInterface(REFIID riid, LPVOID * ppvObj);

	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType) = 0;
	virtual void OnGetParserInfo(ParserInfo &) const = 0;
	virtual void OnGetFileDescriptions(CEnumCallback &) const = 0;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor,
			BOOL &fDebug) const = 0;

	// ILocBinary
	virtual BOOL OnCreateBinaryObject(BinaryId id, CLocBinary * REFERENCE pBinary);

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &, CReporter *pReporter,
			const CContext &context) = 0;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\locstrval.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocStrVal.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCSTRVAL_H)
#define PARSUTIL_LOCSTRVAL_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocStringValidation : public CPULocChild, public ILocStringValidation
{
// Construction
public:
	CPULocStringValidation(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocStringValidation
	CVC::ValidationCode STDMETHODCALLTYPE ValidateString(
			const CLocTypeId &ltiType, const CLocTranslation &trTrans,
			CReporter *pReporter, const CContext &context);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\locbinary.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocBinary.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCBINARY_H)
#define PARSUTIL_LOCBINARY_H


#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocBinary : public ILocBinary, public CPULocChild
{
// Construction
public:
	CPULocBinary(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//
	// ILocBinary interface
	//
	BOOL STDMETHODCALLTYPE CreateBinaryObject(BinaryId,	CLocBinary * REFERENCE);
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\parsutil.h ===
//-----------------------------------------------------------------------------
//  
//  File: ParsUtil.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------

#if !defined (__ParsUtil_h__)
#define __ParsUtil_h__

void IncrementClassCount();
void DecrementClassCount();

extern HMODULE g_hDll;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\binary.h ===
//-----------------------------------------------------------------------------
//  
//  File: Binary.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  Class to hold 'binary' (non-string) information about a localizable item.
//  
//-----------------------------------------------------------------------------

#ifndef BINARY_H
#define BINARY_H


//
//  Binary interface.  Parsers provide an implementation of this in order
//  to create binary objects for other users.
//
extern const IID IID_ILocBinary;

DECLARE_INTERFACE_(ILocBinary, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, CreateBinaryObject)(THIS_ BinaryId, CLocBinary *REFERENCE) PURE;
};



#endif  // BINARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by PARSUTIL.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxcoll.h>		// MFC collection support
#include <afxtempl.h>		// MFC template support

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\imgres32.h ===
//-----------------------------------------------------------------------------
//  
//  File: ImgRes32.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//	Declaration of ILocRes32Image. 
//	This interface allows to convert the localizable items of a resource 
//	into a res32 image, and viceversa.
//  
//-----------------------------------------------------------------------------

#ifndef IMGRES32_H
#define IMGRES32_H


struct Res32FontInfo
{
	WORD wLength;			//Structure length
	WORD wPointSize;		
	WORD wWeight;
	WORD wStyle;
	CPascalString pasName;
};

class CLocItemPtrArray;
class CFile;

extern const IID IID_ILocRes32Image;

DECLARE_INTERFACE_(ILocRes32Image, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Builds a Res32 file image of a resource from the resource's CLocItem objects
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to an existing empty CFile.
	//  - A pointer to a Res32FontInfo structure
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The CFile object has the res32 image of the resource.
	//	- The CLocItemPtrArray object has its items ordered by physical
	//	location in the res32 image.	
	//Return:
	//	TRUE if the image was created successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, MakeRes32Image)(THIS_ CLocItemPtrArray *, int, int, 
		LangId, CFile *, Res32FontInfo*, CLocItemHandler *) PURE;

	//Breaks the Res32 image of a resource into the corresponding CLocItem objects.
	//Inputs:
	//	- A pointer to a CFile object containing the res32 image of a resource.
	//	- The resource's language id.
	//	- A pointer to a CLocItemPtrArray containing the CLocItem objects of the
 	//	resource. The items are expected to be ordered by position in the res32 image.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- The items in the CLocItemPtrArray object are updated with the new data from
 	//	the res32 image.
	//Return:
	//	TRUE if the imaged could be parsed and if the items could be updated successfully.
	//	FALSE, otherwise.
	STDMETHOD_(BOOL, CrackRes32Image)(THIS_ CFile *, LangId, CLocItemPtrArray *, CLocItemHandler *) PURE;
};



#endif  // IMGRES32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\idupdate.h ===
//-----------------------------------------------------------------------------
//  
//  File: idupdate.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_IDUPDATE_H
#define PBASE_IDUPDATE_H

extern const IID IID_ILocIDUpdate;

DECLARE_INTERFACE_(ILocIDUpdate, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ID Update methods.
	//
	STDMETHOD_(BOOL, RequiresUpdate)(THIS_ FileType) PURE;
	STDMETHOD_(FileType, GetUpdatedFileType)(THIS_ FileType) PURE;

	STDMETHOD_(BOOL, GetOldUniqueId)(THIS_ CLocUniqueId REFERENCE) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\parsers\parsutil\locversion.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocVersion.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Written by: jstall
//  
//-----------------------------------------------------------------------------
 
#if !defined (PARSUTIL_LOCVERSION_H)
#define PARSUTIL_LOCVERSION_H

#include "LocChild.h"

#pragma warning(disable : 4275)

////////////////////////////////////////////////////////////////////////////////
class LTAPIENTRY CPULocVersion : public CPULocChild, public ILocVersion
{
// Construction
public:
	CPULocVersion(CPULocParser * pParent);

	DECLARE_CLUNKNOWN();

// COM Interfaces
public:
	//  Standard Debugging interface.
	void STDMETHODCALLTYPE AssertValidInterface() const;

	//  ILocVersion
	void STDMETHODCALLTYPE GetParserVersion(DWORD &dwMajor, DWORD &dwMinor,
			BOOL &fDebug) const;
};
////////////////////////////////////////////////////////////////////////////////

#pragma warning(default : 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\pstrval.h ===
//-----------------------------------------------------------------------------
//  
//  File: pstrval.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  String Validation interface.
//
//  Owner: MHotchin
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_PSTRVAL_H
#define PBASE_PSTRVAL_H

extern const IID IID_ILocStringValidation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocString REFERENCE,
				CReporter *) PURE;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\iresobj.h ===
//-----------------------------------------------------------------------------
//  
//  File: IResObj.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//	Declaration of ILocRes32Image. 
//	This interface allows to convert the localizable items of a resource 
//	into a res32 image, and viceversa.
//  
//-----------------------------------------------------------------------------

#ifndef IRESOBJ_H
#define IRESOBJ_H


class CLocItemPtrArray;
class CFile;
class CResObj;
class CLocItem;

extern const IID IID_ICreateResObj;

DECLARE_INTERFACE_(ICreateResObj, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	// Creates a CResObj for win32 resoruce processing
	//Inputs:
	//	- A pointer to a CLocItem object containing the type and Id of the item
	//	- The size of the resource.
	//	- An void pointer to unknown data to be passed from enumeration to generate
	//Return:
	//	- A CResObj pointer or NULL if the type is not recognized
	STDMETHOD_(CResObj *, CreateResObj)(THIS_ CLocItem * pLocItem,
		DWORD dwSize, void * pvHeader) PURE;
};
#endif  // IRESOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\locfile.h ===
//-----------------------------------------------------------------------------
//  
//  File: LocFile.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//  Operations we can perforn on a localizable file.
//  
//-----------------------------------------------------------------------------

#ifndef PBASE_LOCFILE_H
#define PBASE_LOCFILE_H


class CLocItemHandler;


extern const IID IID_ILocFile;


DECLARE_INTERFACE_(ILocFile, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(THIS_ const CFileSpec REFERENCE,
			CReporter REFERENCE) PURE;
	STDMETHOD_(FileType, GetFileType)(THIS) const PURE;
	STDMETHOD_(void, GetFileTypeDescription)(THIS_ CLString REFERENCE)
		const PURE;
	STDMETHOD_(BOOL, GetAssociatedFiles)(THIS_ CStringList REFERENCE)
		const PURE;

	STDMETHOD_(BOOL, EnumerateFile)(THIS_ CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE) PURE;
	STDMETHOD_(BOOL, GenerateFile)(THIS_ const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE) PURE;
};


#endif //  PBASE_LOCFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\parseapi.h ===
//-----------------------------------------------------------------------------
//  
//  File: parseapi.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  Main interface to a file parser DLL.
//
//  Owner: MHotchin
//
//-----------------------------------------------------------------------------
 
#ifndef PARSEAPI_H
#define PARSEAPI_H


extern const IID IID_ILocParser;
extern const IID IID_ILocParser_20;

struct ParserInfo
{
	CArray<PUID, PUID &> aParserIds;
	CLString strDescription;
	CLocExtensionList elExtensions;
	CLString strHelp;
};


DECLARE_INTERFACE_(ILocParser, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//  LocParser methods.
	//
	STDMETHOD(Init)(THIS_ IUnknown *) PURE;
	
	STDMETHOD(CreateFileInstance)(THIS_ ILocFile *REFERENCE, FileType) PURE;

	STDMETHOD_(void, GetParserInfo)(THIS_ ParserInfo REFERENCE)
		CONST_METHOD PURE;
	STDMETHOD_(void, GetFileDescriptions)(THIS_ CEnumCallback &)
		CONST_METHOD PURE;
};


//
//  Here for DOCUMENTATION only.  Implementors should export the following
//  functions from every Parser DLL.
//
static const char * szParserEntryPointName = "DllGetParserCLSID";
typedef void (STDAPICALLTYPE *PFNParserEntryPoint)(CLSID REFERENCE);

STDAPI_(void) DllGetParserCLSID(CLSID REFERENCE);


static const char * szParserRegisterEntryPointName = "DllRegisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserRegisterEntryPoint)(void);

STDAPI DllRegisterParser(void);


static const char *szParserUnregisterEntryPointName = "DllUnregisterParser";
typedef HRESULT (STDAPICALLTYPE *PFNParserUnregisterEntryPoint)(void);

STDAPI DllUnregisterParser(void);

//
//  Implementors also need to implement the DllGetClassObject function.
//  An optional (but RECOMMENDED) function is DllCanUnloadNow.
//  See the OLE 2 reference manual for details about these functions.
//

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI DllCanUnloadNow(void);


#endif // PARSEAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\pversion.h ===
//-----------------------------------------------------------------------------
//  
//  File: pversion.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PVERSION_H
#define PVERSION_H

extern const IID IID_ILocVersion;

extern const DWORD dwCurrentMajorVersion;
extern const DWORD dwCurrentMinorVersion;
#ifdef _DEBUG
const BOOL fCurrentDebugMode = TRUE;
#else
const BOOL fCurrentDebugMode = FALSE;
#endif

DECLARE_INTERFACE_(ILocVersion, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//
	//
	//
	STDMETHOD_(void, GetParserVersion)(
			THIS_ DWORD REFERENCE dwMajor,
			DWORD REFERENCE dwMinor,
			BOOL REFERENCE fDebug)
		CONST_METHOD PURE;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\mnemonic.h ===
//-----------------------------------------------------------------------------
//  
//  File: Mnemonic.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//
//	Declaration of ILocMnemonics. 
//	This interface allows to retrieve the mnemonics (aka hotkeys) of a 
//	resource
//
//	Owner: EduardoF
//  
//-----------------------------------------------------------------------------

#ifndef MNEMONIC_H
#define MNEMONIC_H


extern const IID IID_ILocMnemonics;

DECLARE_INTERFACE_(ILocMnemonics, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;
	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	//Gets the mnemonics (aka hotkeys) in the resource array of locitems.
	//Inputs:
	//	- A pointer to a CLocItemPtrArray object containing the CLocItem objects of
	//	a resource (like a dialog or a menu).
	//	- An array index to the root item of the resource.
	//	- An array index to the selected item of the resource.
	//	- The resource's language id.
	//	- A pointer to a reporter object where all error messages are sent.
	//Outputs:
	//	- A 'CHotkeysMap' map containing the mnemonics.
	//Return:
	//	TRUE if the mnemonics could be retrieved successfully. FALSE, otherwise.
	STDMETHOD_(BOOL, GetMnemonics)
			(THIS_ CLocItemPtrArray &, int, int, LangId, CReporter * pReporter, 
			CMnemonicsMap &) PURE;

};



#endif  // MNEMONIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\subparse.h ===
//-----------------------------------------------------------------------------
//  
//  File: SubParse.H
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------

#ifndef PBASE_SUBPARSE_H
#define PBASE_SUBPARSE_H


extern const IID IID_ILocSubParserManager;

typedef CTypedPtrArray<CPtrArray, ILocParser *> ILocSubParserArray;

DECLARE_INTERFACE_(ILocSubParserManager, IUnknown)
{
	//
	//  IUnknown standard interface.
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interface.
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD(InitSubParsers)(THIS_ ILocSubParserArray REFERENCE)
		CONST_METHOD PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\about.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       about.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "about.h"
#include "bitmap.h"

#define EDIT_CONTROL_CRLF  _T("\r\r\n")

//
// This file implements the About Properties used by the snap-in manager
//

CSnapinAbout::CSnapinAbout()
{
    TRACE_METHOD(CSnapinAbout, CSnapinAbout);

    CommonContruct();
}

void CSnapinAbout::CommonContruct()
{
    m_bBasicInfo = FALSE;
    m_bFullInfo = FALSE;
    m_cMask = RGB(0,0,0);
    m_hrObjectStatus = S_OK;
}


BOOL CSnapinAbout::GetInformation(CLSID& clsid, int nType)
{
    TRACE_METHOD(CSnapinAbout, GetInformation);

    if (m_bFullInfo == TRUE || m_bBasicInfo == TRUE)
    {
        TRACE(_T("Destroying old Snapin information\n"));

        // Preserve the snapin name, it can't be reloaded from
        // the snapin ISnapinAbout interface
        LPOLESTR strTemp = m_lpszSnapinName.Detach();
        CSnapinAbout::~CSnapinAbout();
        m_lpszSnapinName.Attach(strTemp);
    }

    m_bFullInfo = m_bBasicInfo = FALSE;

    // Create the interface and get the snap-in information
    ISnapinAboutPtr spAboutInfo;
    m_hrObjectStatus = spAboutInfo.CreateInstance(clsid, NULL, MMC_CLSCTX_INPROC);

    if (FAILED(m_hrObjectStatus))
        return FALSE;

    // Basic info (required to display snapin node)
    HBITMAP hbmSmallImage;
    HBITMAP hbmSmallImageOpen;
    HBITMAP hbmLargeImage;

    if (SUCCEEDED(spAboutInfo->GetStaticFolderImage (&hbmSmallImage,
													 &hbmSmallImageOpen,
													 &hbmLargeImage,
													 &m_cMask)))
    {
        /*
         * Bug 249817: The bitmaps are out parameters, so the caller (MMC)
         * should own them and be responsible for destroying them.
         * Unfortunately, the docs for ISnapinAbout::GetStaticFolderImage
         * specifically instruct the snap-in to destroy them when the
         * ISnapinAbout interface is released.  We have to make copies instead.
         */
        m_SmallImage     = CopyBitmap (hbmSmallImage);
        m_SmallImageOpen = CopyBitmap (hbmSmallImageOpen);
        m_LargeImage     = CopyBitmap (hbmLargeImage);
    }

    m_bBasicInfo = TRUE;

    if (nType == BASIC_INFO)
        return TRUE;

    // Full information (required for About box)

    HICON hTemp;

    /*
     * Bug 249817: The icon is an out parameter, so the caller (MMC)
     * should own it and be responsible for destroying it.
     * Unfortunately, the docs for ISnapinAbout::GetSnapinImage
     * specifically instruct the snap-in to destroy it when the
     * ISnapinAbout interface is released.  We have to make a copy instead.
     */
    if (SUCCEEDED(spAboutInfo->GetSnapinImage(&hTemp)))
        m_AppIcon.Attach(CopyIcon(hTemp));

    LPOLESTR strTemp;

    if (SUCCEEDED(spAboutInfo->GetSnapinDescription(&strTemp)))
        m_lpszDescription.Attach(strTemp);

    if (SUCCEEDED(spAboutInfo->GetProvider(&strTemp)))
        m_lpszCompanyName.Attach(strTemp);

    if (SUCCEEDED(spAboutInfo->GetSnapinVersion(&strTemp)))
        m_lpszVersion.Attach(strTemp);

    m_bFullInfo = TRUE;

    return TRUE;
}


void CSnapinAbout::ShowAboutBox()
{
    TRACE_METHOD(CSnapinAbout, Show);

    CSnapinAboutDialog dlg(this);
    dlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CSnapinAboutPage message handlers

LRESULT CSnapinAboutDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // hook up controls
	DECLARE_SC(sc, TEXT("CSnapinAboutDialog::OnInitDialog"));
	sc = ScCheckPointers(m_pAboutInfo, E_UNEXPECTED);
	if (sc)
		return TRUE;

    // Title should be set "About <SnapinName>"
	tstring szTitle;
	bool bRet = szTitle.LoadString(GetStringModule(), IDS_ABOUT);
	if (!bRet)
		return TRUE;

    USES_CONVERSION;
	LPCOLESTR lpszSnapinName = m_pAboutInfo->GetSnapinName();	
	if (lpszSnapinName)
		szTitle += OLE2CT(lpszSnapinName);
	else
	{
		tstring szSnapin;
		bRet = szSnapin.LoadString(GetStringModule(), IDS_SNAPINSTR);
		if (!bRet)
			return TRUE;

		szTitle += szSnapin;
	}

	SetWindowText(szTitle.data());

	HWND hwndSnapinInfo = ::GetDlgItem(*this, IDC_SNAPIN_INFO);
	sc = ScCheckPointers(hwndSnapinInfo, E_UNEXPECTED);
	if (sc)
		return TRUE;

	m_SnapinInfo.Attach(hwndSnapinInfo);

	if (lpszSnapinName)
	{
		m_SnapinInfo.AppendText(OLE2CT(lpszSnapinName));
		m_SnapinInfo.AppendText(EDIT_CONTROL_CRLF);
	}

	LPCOLESTR lpszCompanyName = m_pAboutInfo->GetCompanyName();
	if (lpszCompanyName)
	{
		m_SnapinInfo.AppendText(OLE2CT(lpszCompanyName));
		m_SnapinInfo.AppendText(EDIT_CONTROL_CRLF);
	}

	LPCOLESTR lpszVersion = m_pAboutInfo->GetVersion();
	if (lpszVersion)
	{
		tstring szVersion;
		bRet = szVersion.LoadString(GetStringModule(), IDS_VERSION);
		if (!bRet)
			return TRUE;

		m_SnapinInfo.AppendText(szVersion.data());
		m_SnapinInfo.AppendText(OLE2CT(lpszVersion));
	}

	HWND hwndSnapinDesc = ::GetDlgItem(*this, IDC_SNAPIN_DESC);
	sc = ScCheckPointers(hwndSnapinDesc, E_UNEXPECTED);
	if (sc)
		return TRUE;

	m_SnapinDesc.Attach(hwndSnapinDesc);

	LPCOLESTR lpszDescription = m_pAboutInfo->GetDescription();

    sc = ScSetDescriptionUIText(m_SnapinDesc, lpszDescription ? OLE2CT(lpszDescription) : _T(""));
    if (sc)
        return TRUE;

    // App icon
    HICON hAppIcon = m_pAboutInfo->GetSnapinIcon();
	if (hAppIcon)
	{
		HWND const icon = ::GetDlgItem(*this, IDC_APPICON);
		ASSERT(icon != NULL);
		m_hIcon.Attach(icon);
        m_hIcon.SetIcon(hAppIcon);
	}

    return TRUE;
}


LRESULT
CSnapinAboutDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog(IDOK);
    return TRUE;
}

LRESULT
CSnapinAboutDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog(IDCANCEL);
    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:      ScSetDescriptionUIText
//
//  Synopsis:    Given a edit control window & description text. Insert
//               the text into the control and enable scrollbar if needed.
//
//  Arguments:   [hwndSnapinDescEdit] - The edit control window handle.
//               [lpszDescription]    - The description text (cant be NULL).
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC ScSetDescriptionUIText(HWND hwndSnapinDescEdit, LPCTSTR lpszDescription)
{
    DECLARE_SC(sc, TEXT("ScSetDescriptionUIText"));
    sc = ScCheckPointers(hwndSnapinDescEdit, lpszDescription);
    if (sc)
        return sc;

    // 1. Attach the window to WTL::CEdit object.
    WTL::CEdit wndsnapinDesc(hwndSnapinDescEdit);

    // 2. Insert the text into the window.
    wndsnapinDesc.SetWindowText(lpszDescription);

	/*
	 * 3. The description control may need scroll bar.
	 *    This is determined below, if ( (# of lines * height of one line) > rectangle-height).
	 */

    // 3a)  turn-off scroll & do the calculation, so that scroll-bar width does not
    // modify linecount below.
    wndsnapinDesc.ShowScrollBar(SB_VERT, FALSE);

    WTL::CDC dc(wndsnapinDesc.GetWindowDC());
    if (dc.IsNull())
        return (sc = E_UNEXPECTED);

    TEXTMETRIC  tm;

    // 3b) Calculate height of a single line.
    HFONT hOldFont = dc.SelectFont(wndsnapinDesc.GetFont());
    dc.GetTextMetrics(&tm);
    int cyLineHeight = tm.tmHeight + tm.tmExternalLeading;

    // 3c) Calculate edit box dimensions in logical units.
    WTL::CRect rect;
    wndsnapinDesc.GetRect(&rect);
    dc.DPtoLP(&rect);

    int nLines = wndsnapinDesc.GetLineCount();

    // 3d) If the total text height exceeds edit box height so turn on scroll.
    if ( (nLines * cyLineHeight) > rect.Height())
        wndsnapinDesc.ShowScrollBar(SB_VERT, TRUE);

    dc.SelectFont(hOldFont);

	wndsnapinDesc.SetSel(0, 0);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\prodver\prodver.h ===
#define rmj 4
#define rmm 2
#define rup 169
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\addsnpin.cpp ===
// AddSnpIn.cpp : implementation file
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      AddSnpIn.cpp
//
//  Contents:  Add snapin manager
//
//  History:   20-Sept-96 WayneSc    Created
//--------------------------------------------------------------------------


#include "stdafx.h"
#include <stdio.h>
#include "winreg.h"
#include "macros.h"
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include "ndmgr.h"
#include "nodemgr.h"
#include "strings.h"

//using namespace AMC;
using namespace MMC_ATL;

#include "AddSnpIn.h"
#include "policy.h"
#include "msimodul.h"
#include "process.h"
#include "siprop.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define BITMAPS_COUNT 5

#define __PDC_UNAVAILABLE

#include "about.h"

// GUID for looking up snap-in components
const TCHAR* g_szMMCSnapInGuid = TEXT("{374F2F70-060F-11d2-B9A8-0060977B1D78}");

HRESULT AmcNodeWizard(MID_LIST NewNodeType, CMTNode* pNode, HWND hWnd);
void EnableButton(HWND hwndDialog, int iCtrlID, BOOL bEnable);

/////////////////////////////////////////////////////////////////////////////
#ifdef DBG
CTraceTag tagAboutInfoThread    (TEXT("Snapin Manager"), TEXT("CAboutInfo"));
CTraceTag tagSnapinManager      (TEXT("Snapin Manager"), TEXT("CSnapinManager"));
CTraceTag tagSnapinManagerThread(TEXT("Snapin Manager"), TEXT("Snapin Manager Thread"));
#endif //DBG
/////////////////////////////////////////////////////////////////////////////

//TEMP TEMP TEMP
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#ifndef __PDC_UNAVAILABLE

typedef struct tag_teststr
{
    TCHAR   szCLSID[64];
} TESTSTR;

static TESTSTR s_teststr[] =
{
 {_T("{12345601-EA27-11CF-ADCF-00AA00A80033}")},
 {_T("{19876201-EA27-11CF-ADCF-00AA00A80033}")},
 {_T("{1eeeeeee-d390-11cf-b607-00c04fd8d565}")},
};

#endif //__PDC_UNAVAILABLE


//############################################################################
//############################################################################
//
//  Debug routines
//
//############################################################################
//############################################################################

#ifdef DBG


void CSnapinInfoCache::Dump(void)
{

    TRACE(_T("===========Dump of SnapinInfoCache ===============\n"));
    POSITION pos = GetStartPosition();
    while(pos != NULL)
    {
        PSNAPININFO pSnapInfo;
        GUID clsid;
        TCHAR* pszAction;

        GetNextAssoc(pos, clsid, pSnapInfo);

        if (pSnapInfo->IsUsed() && (pSnapInfo->GetSnapIn() == NULL))
            pszAction = _T("Add");
        else if (!pSnapInfo->IsUsed() && (pSnapInfo->GetSnapIn() != NULL))
            pszAction = _T("Remove");
        else
            continue;

        TRACE(_T("\n"));
        TRACE(_T("%s: %s\n"), pSnapInfo->GetSnapinName(), pszAction);

        PEXTENSIONLINK pExt = pSnapInfo->GetExtensions();
        while (pExt)
        {
            if (pExt->IsChanged())
            {
                pszAction = pExt->GetState() ? _T("Add") : _T("Remove");
                TRACE(_T("   %s: %s\n"), pExt->GetSnapinInfo()->GetSnapinName(),pszAction);
            }
            pExt = pExt->Next();
        }
    }
}

#endif // DBG


//############################################################################
//############################################################################
//
//  Implementation of class CCheckList
//
//############################################################################
//############################################################################

LRESULT CCheckList::OnKeyDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    bHandled = FALSE;
    int iItem;

    if ((int)wParam == VK_SPACE)
    {
        // Is the focused item selected ?
        if ( (iItem = GetNextItem(-1, LVNI_FOCUSED|LVNI_SELECTED)) >= 0)
        {
            // if so, set all selected and enabled items to the opposite state
            BOOL bNewState = !GetItemCheck(iItem);

            iItem = -1;
            while( (iItem = GetNextItem(iItem, LVNI_SELECTED)) >= 0)
            {
                BOOL bEnable;
                GetItemCheck(iItem, &bEnable);

                if (bEnable)
                    SetItemCheck(iItem, bNewState);
            }
        }
        else
        {
            if ( (iItem = GetNextItem(-1, LVNI_FOCUSED)) >= 0)
            {
                BOOL bEnable;
                GetItemCheck(iItem, &bEnable);

                if (bEnable)
                    ToggleItemCheck(iItem);

                SetItemState(iItem, LVIS_SELECTED, LVIS_SELECTED);
            }
        }

        bHandled = TRUE;
    }

    return 0;
}

LRESULT CCheckList::OnLButtonDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    LV_HITTESTINFO info;

    info.pt.x = LOWORD( lParam );
    info.pt.y = HIWORD( lParam );

    int iItem = HitTest( &info );

    if( iItem >= 0 && (info.flags & LVHT_ONITEMSTATEICON))
    {
       BOOL bEnable;
       GetItemCheck(iItem, &bEnable);

       if (bEnable)
           ToggleItemCheck(iItem);

       bHandled = TRUE;
    }
    else
    {
        bHandled = FALSE;
    }

    return 0;
}

LRESULT CCheckList::OnLButtonDblClk( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    LV_HITTESTINFO info;

    info.pt.x = LOWORD( lParam );
    info.pt.y = HIWORD( lParam );

    int iItem = HitTest( &info );
    if( iItem >= 0 )
    {
        BOOL bEnable;
        GetItemCheck(iItem, &bEnable);

        if (bEnable)
            ToggleItemCheck(iItem);
    }

    return 0;
}

//############################################################################
//############################################################################
//
//  Implementation of class CAboutInfoThread
//
//############################################################################
//############################################################################

CAboutInfoThread::~CAboutInfoThread()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CAboutInfoThread);

    Trace(tagAboutInfoThread, TEXT("CAboutInfoThread::~CAboutInfoThread"));

    // Make sure the thread is dead before MMC quits
    if (m_hThread != NULL)
    {
        PostThreadMessage(m_uThreadID, WM_QUIT, 0, 0);

        MSG msg;
        while (TRUE)
        {
            // Wait either for the thread to be signaled or any input event.
            DWORD dwStat = MsgWaitForMultipleObjects(1, &m_hThread, FALSE, INFINITE, QS_ALLINPUT);

            if (WAIT_OBJECT_0 == dwStat)
                break;  // The thread is signaled.

            // There is one or more window message available.
            // Dispatch them and wait.
            if (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        CloseHandle(m_hThread);
        CloseHandle(m_hEvent);
    }
}



//-----------------------------------------------------------------------------
// CAboutInfoThread::StartThread
//
// Start the thread
//-----------------------------------------------------------------------------

BOOL CAboutInfoThread::StartThread()
{
    // If thread exists, just return
    if (m_hThread != NULL)
        return TRUE;

    BOOL bRet = FALSE;
    do // False loop
    {
        // Create start event
        m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hEvent == NULL)
            break;

        // Start the thread
        m_hThread = (HANDLE)_beginthreadex(NULL, 0, ThreadProc, this, 0, &m_uThreadID);
        if (m_hThread == NULL)
            break;

        // Wait for start event
        DWORD dwEvStat = WaitForSingleObject(m_hEvent, 10000);
        if (dwEvStat != WAIT_OBJECT_0)
            break;

        bRet = TRUE;
    }
    while (0);

    ASSERT(bRet);

    // Clean up on failure
    if (!bRet)
    {
        if (m_hEvent)
        {
            CloseHandle(m_hEvent);
            m_hEvent = NULL;
        }

        if (m_hThread)
        {
            CloseHandle(m_hThread);
            m_hThread = NULL;
        }
    }

    return bRet;
}

BOOL CAboutInfoThread::PostRequest(CSnapinInfo* pSnapInfo, HWND hWndNotify)
{
    // make sure thread is active
    if (!StartThread())
        return FALSE;

    // Ref the info object to keep it alive until the thread releases it
    pSnapInfo->AddRef();

    BOOL bRet = PostThreadMessage(m_uThreadID, MSG_LOADABOUT_REQUEST,
                                    (WPARAM)pSnapInfo, LPARAM(hWndNotify));

    // if failed to post, delete the ref
    if (!bRet)
        pSnapInfo->Release();

    return bRet;
}

unsigned _stdcall CAboutInfoThread::ThreadProc(void* pVoid )
{
    // Do a PeekMessage to create the message queue
    MSG msg;
    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

    // Then signal that thread is started
    CAboutInfoThread* pThis = reinterpret_cast<CAboutInfoThread*>(pVoid);
    ASSERT(pThis->m_hEvent != NULL);
    SetEvent(pThis->m_hEvent);

    CoInitialize(NULL);

    // Mesage loop
    while (TRUE)
    {
        long lStat = GetMessage(&msg, NULL, 0, 0);

        // zero => WM_QUIT received, so exit thread function
        if (lStat == 0)
            break;

        if (lStat > 0)
        {
            // Only process thread message of the expected type
            if (msg.hwnd == NULL && msg.message == MSG_LOADABOUT_REQUEST)
            {
                // Get SnapinInfo instance
                PSNAPININFO pSnapinInfo = reinterpret_cast<PSNAPININFO>(msg.wParam);
                ASSERT(pSnapinInfo != NULL);

                // Get the requested items
                pSnapinInfo->LoadAboutInfo();

                // Release our ref to the info
                pSnapinInfo->Release();

                // Send completion notification (if window still exists)
                if (msg.lParam != NULL && IsWindow((HWND)msg.lParam))
                    PostMessage((HWND)msg.lParam, MSG_LOADABOUT_COMPLETE,
                                (WPARAM)pSnapinInfo, (LPARAM)0);
            }
            else
            {
                DispatchMessage(&msg);
            }
        }
    } // WHILE (TRUE)

    Trace(tagSnapinManagerThread, TEXT("Snapin manager thread about to exit"));

    CoUninitialize();

    return 0;
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapinInfo
//
//############################################################################
//############################################################################

//-----------------------------------------------------------------------------
// CSnapinInfo::~CSnapinInfo
//
// Destructor
//-----------------------------------------------------------------------------
CSnapinInfo::~CSnapinInfo()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinInfo);

    // Delete all the extension links
    PEXTENSIONLINK pExt = m_pExtensions;
    PEXTENSIONLINK pNext;

    while (pExt != NULL)
    {
        pNext = pExt->Next();
        delete pExt;
        pExt = pNext;
    }
}


//-----------------------------------------------------------------------------
// CSnapinInfo::InitFromMMCReg
//
// Initialize the snapin info from the supplied registry key. The caller is
// responsible for openning and closing the key.
//-----------------------------------------------------------------------------
BOOL CSnapinInfo::InitFromMMCReg(GUID& clsid, CRegKeyEx& regkey, BOOL bPermitted)
{
    TCHAR   szValue[MAX_PATH];
    long    lStat;
    DWORD   dwCnt;
    DWORD   dwType;
    LPOLESTR lpsz;

    USES_CONVERSION;

    // save class ID
    m_clsid = clsid;

    // Save permission
    m_bPolicyPermission = bPermitted;

    // Get name string
	WTL::CString strName;
    SC sc = ScGetSnapinNameFromRegistry (regkey, strName);
    if (!sc.IsError())
    {
        SetSnapinName(T2COLE(strName));
    }
	else
	{
		// need to protect ourselves from the invalid snapin registration.
		// see windows bug #401220	( ntbugs9 5/23/2001 )
		OLECHAR szCLSID[40];
		int iRet = StringFromGUID2(GetCLSID(), szCLSID, countof(szCLSID));
		if (iRet == 0)
	        SetSnapinName( L"" );
		else
	        SetSnapinName( szCLSID );
	}

    // get "About" class ID
    dwCnt = sizeof(szValue);
    lStat = RegQueryValueEx(regkey, g_szAbout, NULL, &dwType, (LPBYTE)szValue, &dwCnt);
    if (lStat == ERROR_SUCCESS && dwType == REG_SZ)
    {
        if (CLSIDFromString( T2OLE(szValue), &m_clsidAbout) == S_OK)
        {
            m_bAboutValid = TRUE;
        }
        else
        {
            ASSERT(FALSE);
        }
    }

    MMC_ATL::CRegKey TestKey;

    // Test for StandAlone key
    m_bStandAlone = FALSE;
    lStat = TestKey.Open(regkey, g_szStandAlone, KEY_READ);
    if (lStat == ERROR_SUCCESS)
    {
        m_bStandAlone = TRUE;
        TestKey.Close();
    }

    // Test for NodeTypes key to see if extendable
    m_bExtendable = FALSE;
    lStat = TestKey.Open(regkey, g_szNodeTypes, KEY_READ);
    if (lStat == ERROR_SUCCESS)
    {
        m_bExtendable = TRUE;
        TestKey.Close();
    }

    // Mark registered snap-ins as installed
    m_bInstalled = TRUE;

    return TRUE;
}

//-----------------------------------------------------------------------------
// CSnapinInfo::InitFromComponentReg
//
// Initialize the snapin info from component registry information. This is done
// for snap-in that are not yet installed on the local machine.
//-----------------------------------------------------------------------------
BOOL CSnapinInfo::InitFromComponentReg(GUID& clsid, LPCTSTR pszName, BOOL bStandAlone,  BOOL bPermitted)
{

    USES_CONVERSION;

    // save class ID
    m_clsid = clsid;

    // Save permission
    m_bPolicyPermission = bPermitted;

    // Set name string
    ASSERT(pszName != NULL);
    SetSnapinName(T2COLE(pszName));

    // stand-alone or extension
    m_bStandAlone = bStandAlone;

    // With no information, must assume that it could be extendable
    m_bExtendable = TRUE;

    return TRUE;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinInfo::ScInstall
 *
 * PURPOSE: Call the installer to install this snap-in. If the install works then
 *          update the snap-in info from the MMC registry.
 *          If loading an extension snap-in the clsid of extended snap-in must be
 *          provided.
 *
 * PARAMETERS:
 *    CLSID* pclsidPrimaryComp :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CSnapinInfo::ScInstall(CLSID* pclsidPrimaryComp)
{
    DECLARE_SC(sc, TEXT("CSnapinInfo::Install"));

    USES_CONVERSION;

    LPCTSTR pszPrimaryCLSID;
    OLECHAR szCLSIDPrimary[40];

    if (pclsidPrimaryComp != NULL)
    {
        int iRet = StringFromGUID2(*pclsidPrimaryComp, szCLSIDPrimary, countof(szCLSIDPrimary));
        if (iRet == 0)
            return(sc = E_UNEXPECTED);

        pszPrimaryCLSID = OLE2T(szCLSIDPrimary);
    }
    else
    {
        pszPrimaryCLSID = g_szMMCSnapInGuid;
    }

    OLECHAR szCLSID[40];
    int iRet = StringFromGUID2(GetCLSID(), szCLSID, countof(szCLSID));
    if (iRet == 0)
        return(sc = E_UNEXPECTED);

    TCHAR szCompPath[MAX_PATH];
    DWORD dwPathCnt = MAX_PATH;

    // install the snapin on the machine
    sc.FromWin32(MsiModule().ProvideQualifiedComponent(pszPrimaryCLSID, OLE2T(szCLSID), INSTALLMODE_DEFAULT, szCompPath, &dwPathCnt));
    if (sc)
        return sc;

    // the caller should call CSnapinManager::ScLoadSnapinInfo to update all the snapin info objects

    return sc;
}


//--------------------------------------------------------------------
// CSnapinInfo::AttachSnapIn
//
// Attach to the CSnapin associated with this info. If the snapin has
// active extensions, then add extension links for them. Recursively
// call AttachSnapIn for any extension snapins linked to.
//--------------------------------------------------------------------
void  CSnapinInfo::AttachSnapIn(CSnapIn* pSnapIn, CSnapinInfoCache& InfoCache)
{
    // If already attached, nothing to do
    if (m_spSnapin != NULL)
    {
        ASSERT(m_spSnapin == pSnapIn); // Better be the same one!
        return;
    }

    // Save ref to snapin
    m_spSnapin = pSnapIn;

    // If not extendable, there's nothing more to do
    if (!IsExtendable())
        return;

    // If required extensions not yet loaded, do it now
    if (!pSnapIn->RequiredExtensionsLoaded() && IsPermittedByPolicy())
    {
        // Create instance of snapin
        IComponentDataPtr spICD;
        HRESULT hr = CreateSnapIn(m_clsid, &spICD, FALSE);
        ASSERT(SUCCEEDED(hr) && spICD != NULL);

        if (SUCCEEDED(hr) && spICD != NULL)
        {
            // Load required extensions into snapin cache
            LoadRequiredExtensions(pSnapIn, spICD);
        }
    }

    // Copy state of Enable All flags
    SetEnableAllExtensions(pSnapIn->AreAllExtensionsEnabled());


    // Do for all snapin's extensions
    CExtSI* pSnapInExt  = pSnapIn->GetExtensionSnapIn();
    while (pSnapInExt != NULL)
    {
        // Find snapin info entry for the extension snapin
        PSNAPININFO pSnapInfo = InfoCache.FindEntry(pSnapInExt->GetSnapIn()->GetSnapInCLSID());

        if (pSnapInfo != NULL)
        {
            // Create new link and add to list
            PEXTENSIONLINK pNewExt = new CExtensionLink(pSnapInfo);
            pNewExt->SetNext(m_pExtensions);
            m_pExtensions = pNewExt;

            // Initialize to ON
            pNewExt->SetInitialState(CExtensionLink::EXTEN_ON);
            pNewExt->SetState(CExtensionLink::EXTEN_ON);

            // Copy Required state
            pNewExt->SetRequired(pSnapInExt->IsRequired());

            // recursively connect the extension snapin info to its snapin
            pSnapInfo->AttachSnapIn(pSnapInExt->GetSnapIn(), InfoCache);
        }

        pSnapInExt = pSnapInExt->Next();
    }
}

//--------------------------------------------------------------------
// CSnapinInfo::LoadImages
//
// Get small bitmap images from the snapin and add them to the image list.
//--------------------------------------------------------------------
void CSnapinInfo::LoadImages( WTL::CImageList iml )
{
    DECLARE_SC(sc, TEXT("CSnapinInfo::LoadImages"));

    // if already loaded, just return
    if (m_iImage != -1)
        return;

    // try to get images from the snap-in About object
    // Get basic info from snapin
    if (HasAbout() && !HasBasicInformation())
    {
        GetBasicInformation(m_clsidAbout);
    }

    ASSERT(iml != NULL);

    // get the small bitmaps
    HBITMAP hImage = NULL;
    HBITMAP hOpenImage = NULL;
    COLORREF cMask;
    GetSmallImages(&hImage, &hOpenImage, &cMask);

    // Add to the image list
    if (hImage != NULL)
        m_iImage = iml.Add(hImage, cMask);

	/*
	 * if the snap-in didn't give us an open image, just use the "closed" image
	 */
    if (hOpenImage != NULL)
        m_iOpenImage = iml.Add(hOpenImage, cMask);
	else
		m_iOpenImage = m_iImage;

    // if couldn't get from snap-in, try getting default icon from CLSID key
    if (m_iImage == -1)
        do // dummy loop
        {
            USES_CONVERSION;

            OLECHAR szCLSID[40];
            int iRet = StringFromGUID2(GetCLSID(), szCLSID, countof(szCLSID));
            if (iRet == 0)
            {
                (sc = E_UNEXPECTED).TraceAndClear();
                break;
            }

            CStr strKeyName(TEXT("CLSID\\"));
            strKeyName += W2T(szCLSID);
            strKeyName += TEXT("\\DefaultIcon");

            CRegKeyEx regKey;
            sc = regKey.ScOpen (HKEY_CLASSES_ROOT, strKeyName, KEY_QUERY_VALUE);
            if (sc)
			{
				sc.Clear();
                break;
			}

            TCHAR szIconPath[MAX_PATH];
            DWORD dwSize = sizeof(szIconPath);
            DWORD dwType;

            sc = regKey.ScQueryValue (NULL, &dwType, szIconPath, &dwSize);
            if (sc)
			{
				sc.Clear();
                break;
			}

			if (dwType != REG_SZ)
				break;

            // Icon path has the form <file path>,<icon index>
            // if no index, use default of zero
            int nIconIndex = 0;

            TCHAR *pcComma = _tcsrchr(szIconPath, TEXT(','));
            if (pcComma != NULL)
            {
                // terminate path name at ','
                *(pcComma++) = TEXT('\0');

                // Convert rest of string to an index value
                if ((*pcComma != '-') && *pcComma < TEXT('0') || *pcComma > TEXT('9'))
                {
                    ASSERT(FALSE);
                    break;
                }

                nIconIndex = _ttoi(pcComma);
            }

            HICON hiconSmall;

            UINT nIcons = ExtractIconEx(szIconPath, nIconIndex, NULL, &hiconSmall, 1);
            if (nIcons != 1 || hiconSmall == NULL)
                break;

            // Add to image list (returns -1 on failure)
            m_iImage = m_iOpenImage = iml.AddIcon(hiconSmall);
            ASSERT(m_iImage != -1);

            DestroyIcon(hiconSmall);

        } while (0); // Dummy loop


    // Use default images on failure
    if (m_iImage == -1)
	{
		WTL::CBitmap bmp;
		VERIFY (bmp.LoadBitmap (IDB_FOLDER_16));
		m_iImage = iml.Add (bmp, RGB (255, 0, 255));
	}

    if (m_iOpenImage == -1)
	{
		WTL::CBitmap bmp;
		VERIFY (bmp.LoadBitmap (IDB_FOLDEROPEN_16));
		m_iOpenImage = iml.Add (bmp, RGB (255, 0, 255));
	}
}


//--------------------------------------------------------------------
// CSnapinInfo::ShowAboutPages
//
// Show About property pages for this snapin
//--------------------------------------------------------------------
void CSnapinInfo::ShowAboutPages(HWND hWndParent)
{
    // Load information if not already there
    if (m_bAboutValid && !HasInformation())
    {
        GetSnapinInformation(m_clsidAbout);
    }

    // If it's there, show it
    if (HasInformation())
    {
        ShowAboutBox();
    }
}

//--------------------------------------------------------------------
// CSnapinInfo::AddUseRef
//
// Handle increment of use count. If count was zero, then set all
// READY extensions to the ON state. Note this can cascade as
// activated links cause other SnapinInfo ref counts to increment.
//--------------------------------------------------------------------
void CSnapinInfo::AddUseRef(void)
{
    // If first reference, activate all READY extensions
    if (m_nUseCnt++ == 0)
    {
        PEXTENSIONLINK pExt = GetExtensions();
        while(pExt != NULL)
        {
            if (pExt->GetState() == CExtensionLink::EXTEN_READY)
                pExt->SetState(CExtensionLink::EXTEN_ON);
            pExt = pExt->Next();
        }
    }
}

//--------------------------------------------------------------------
// CSnapinInfo::DeleteUseRef
//
// Handle decrement of use count. If count reaches zero, then
// set all ON extensions to a READY state. Note this can cascade as
// deactivated links cause other SnapinInfo ref counts to drop.
//--------------------------------------------------------------------
void CSnapinInfo::DeleteUseRef(void)
{
    ASSERT(m_nUseCnt > 0);

    // If no more references, turn off all extensions
    if (--m_nUseCnt == 0)
    {
        PEXTENSIONLINK pExt = GetExtensions();
        while(pExt != NULL)
        {
            if (pExt->GetState() == CExtensionLink::EXTEN_ON)
                pExt->SetState(CExtensionLink::EXTEN_READY);
            pExt = pExt->Next();
        }
    }
}


//--------------------------------------------------------------------
// CSnapinInfo::GetAvailableExtensions
//
// Return list of available extensions for this snapin.
// On first call, create the list from the registry.
//--------------------------------------------------------------------
PEXTENSIONLINK CSnapinInfo::GetAvailableExtensions(CSnapinInfoCache* pInfoCache,CPolicy* pMMCPolicy)
{
    DECLARE_SC(sc, TEXT("CSnapinInfo::GetAvailableExtensions"));

    // if already loaded, return the pointer
    if (m_bExtensionsLoaded)
        return m_pExtensions;

    // set flag even on failure, so we don't keep retrying
    m_bExtensionsLoaded = TRUE;

    // call service to get extension CLSIDs
    CExtensionsCache  ExtCache;
    HRESULT hr = MMCGetExtensionsForSnapIn(m_clsid, ExtCache);
    if (FAILED(hr))
        return NULL;

    // Create an extension link for each one found
    CExtensionsCacheIterator ExtIter(ExtCache);
    for (; ExtIter.IsEnd() == FALSE; ExtIter.Advance())
    {
        // if can't be used statically, skip it
        if ((ExtIter.GetValue() & CExtSI::EXT_TYPE_STATIC) == 0)
            continue;

        GUID clsid = ExtIter.GetKey();

        // See if extension is already in the list
        PEXTENSIONLINK pExt = FindExtension(clsid);

        // if link isn't present
        if (pExt == NULL)
        {
            // Locate snapin info for the extension
            PSNAPININFO pSnapInfo = pInfoCache->FindEntry(clsid);
            ASSERT(pSnapInfo != NULL);

            if (pSnapInfo)
            {
                // Create new link and add to list
                PEXTENSIONLINK pNewExt = new CExtensionLink(pSnapInfo);
                ASSERT(pNewExt != NULL);

                pNewExt->SetNext(m_pExtensions);
                m_pExtensions = pNewExt;

                // Save extension type flags
                pNewExt->SetExtTypes(ExtIter.GetValue());
            }
        }
        else
        {
            pExt->SetExtTypes(ExtIter.GetValue());
        }
    }

    // If no installer module present, return now
    if (!MsiModule().IsPresent())
        return m_pExtensions;

    // Enumerate uninstalled extensions for this snap-in
    DWORD dwQualifCnt;
    DWORD dwAppDataCnt;
    TCHAR szQualifBuf[MAX_PATH];
    TCHAR szAppDataBuf[MAX_PATH];

    USES_CONVERSION;

    OLECHAR szSnapInGUID[40];
    int iRet = StringFromGUID2(m_clsid, szSnapInGUID, countof(szSnapInGUID));
    if (iRet == 0)
    {
        sc = E_UNEXPECTED;
        return m_pExtensions;
    }

    LPTSTR pszSnapInGUID = OLE2T(szSnapInGUID);

    // Snap-in extension components are registerd as qualifiers of the snap-in component
    for (int iIndex = 0; TRUE; iIndex++)
    {
        dwQualifCnt = dwAppDataCnt = MAX_PATH;
        szQualifBuf[0] = szAppDataBuf[0] = 0;

        UINT uRet = MsiModule().EnumComponentQualifiers(pszSnapInGUID, iIndex, szQualifBuf, &dwQualifCnt,
                                                szAppDataBuf, &dwAppDataCnt);

        ASSERT(uRet == ERROR_SUCCESS || uRet == ERROR_NO_MORE_ITEMS || uRet == ERROR_UNKNOWN_COMPONENT);
        if (uRet != ERROR_SUCCESS)
            break;

        ASSERT(dwQualifCnt != 0);
        ASSERT(dwAppDataCnt != 0);

        GUID clsidExt;
        HRESULT hr = CLSIDFromString(T2OLE(szQualifBuf), &clsidExt);
        ASSERT(SUCCEEDED(hr));

        // Skip it if this extension has already been found
        if (FindExtension(clsidExt) != NULL)
            continue;

        // Locate snap-in info for extension
        PSNAPININFO pSnapInfo = pInfoCache->FindEntry(clsidExt);

        // if extension is not in the MMC registry, create a snapin info for it
        if (pSnapInfo == NULL)
        {
            pSnapInfo = new CSnapinInfo;
            ASSERT(pSnapInfo != NULL);

            ASSERT(pMMCPolicy != NULL);
            BOOL bPermission = pMMCPolicy->IsPermittedSnapIn(clsidExt);

            if (pSnapInfo->InitFromComponentReg(clsidExt, szAppDataBuf, FALSE, bPermission))
            {
                pInfoCache->AddEntry(pSnapInfo);
            }
            else
            {
                delete pSnapInfo;
                pSnapInfo = NULL;
            }
        }

        if (pSnapInfo != NULL)
        {
            // Create new link and add to list
            PEXTENSIONLINK pNewExt = new CExtensionLink(pSnapInfo);
            ASSERT(pNewExt != NULL);

            pNewExt->SetNext(m_pExtensions);
            m_pExtensions = pNewExt;

            // Since we don't know, assume that extension can be static or dynamic
            pNewExt->SetExtTypes(CExtSI::EXT_TYPE_STATIC|CExtSI::EXT_TYPE_DYNAMIC);
        }
    }

    return m_pExtensions;
}


//---------------------------------------------------------------------------
// CSnapinInfo::FindExtension
//
// Search snap-in's extension list for an extension with the specified CLSID.
// If foudn, return a pointer to it, else return NULL.
//----------------------------------------------------------------------------
CExtensionLink* CSnapinInfo::FindExtension(CLSID& clsid)
{
    PEXTENSIONLINK pExt = m_pExtensions;

    while (pExt != NULL)
    {
        if (IsEqualCLSID(clsid, pExt->GetSnapinInfo()->GetCLSID()))
            break;

        pExt = pExt->Next();
    }

    return pExt;
}


//############################################################################
//############################################################################
//
//  Implementation of class CExtensionLink
//
//############################################################################
//############################################################################

//---------------------------------------------------------------------------
// CExtensionLink::SetState
//
// Set state of extension link. If state changes to or from EXTEN_ON, add or
// remove a reference to the extension snapin info.
//----------------------------------------------------------------------------
void CExtensionLink::SetState(EXTENSION_STATE eNewState)
{
    if (eNewState == m_eCurState)
        return;

    EXTENSION_STATE eOldState = m_eCurState;
    m_eCurState = eNewState;

    ASSERT(m_pSnapInfo != NULL);

    if (eNewState == EXTEN_ON)
    {
        m_pSnapInfo->AddUseRef();
    }
    else if (eOldState == EXTEN_ON)
    {
        m_pSnapInfo->DeleteUseRef();
    }
}


//############################################################################
//############################################################################
//
//  Implementation of class CManagerNode
//
//############################################################################
//############################################################################

//-------------------------------------------------------------------
// CManagerNode::~CManagerNode
//-------------------------------------------------------------------
CManagerNode::~CManagerNode()
{
    // Delete ref to snapin info
    if (m_pSnapInfo)
    {
        m_pSnapInfo->DeleteUseRef();
    }

    // Delete all child nodes
    POSITION pos = m_ChildList.GetHeadPosition();
    while (pos != NULL)
    {
        PMANAGERNODE pmgNode = m_ChildList.GetNext(pos);
        delete pmgNode;
    }
}


//--------------------------------------------------------------------
// CManagerNode::AddChild
//
// Add a child node to this node.
//--------------------------------------------------------------------
VOID CManagerNode::AddChild(PMANAGERNODE pmgNode)
{
    ASSERT(pmgNode != NULL);

    // up link to parent
    pmgNode->m_pmgnParent = this;

    // set indent level for combo box display
    pmgNode->m_iIndent = m_iIndent + 1;

    // add node to CList
    m_ChildList.AddTail(pmgNode);
}


//--------------------------------------------------------------------
// CManagerNode::RemoveChild
//
// Remove a child node from this node
//--------------------------------------------------------------------
VOID CManagerNode::RemoveChild(PMANAGERNODE pmgNode)
{
    ASSERT(pmgNode && pmgNode->m_pmgnParent == this);

    // delete child from CList
    POSITION pos = m_ChildList.Find(pmgNode);
    ASSERT(pos != NULL);

    m_ChildList.RemoveAt(pos);
}


//############################################################################
//############################################################################
//
//  Implementation of class CNewTreeNode
//
//############################################################################
//############################################################################

//-----------------------------------------------------------------------
// CNewTreeNode::AddChild
//
// Add a child node to this node.
//------------------------------------------------------------------------
VOID CNewTreeNode::AddChild(PNEWTREENODE pntNode)
{
    ASSERT(pntNode != NULL);

    // up link to parent
    pntNode->m_pParent = this;

    // Add child node to end of linked
    if (m_pChild == NULL)
    {
        m_pChild = pntNode;
    }
    else
    {
         PNEWTREENODE pChild= m_pChild;
         while (pChild->m_pNext != NULL)
            pChild = pChild->m_pNext;

         pChild->m_pNext = pntNode;
    }
}

//----------------------------------------------------------------------
// CNewTreeNode::RemoveChild
//
// Remove a child node from this node
//----------------------------------------------------------------------
VOID CNewTreeNode::RemoveChild(PNEWTREENODE pntNode)
{
    ASSERT(pntNode && pntNode->m_pParent == this);

    // locate child node in linked list and unlink it
    if (m_pChild == pntNode)
    {
        m_pChild = pntNode->m_pNext;
    }
    else
    {
        PNEWTREENODE pChild = m_pChild;
        while (pChild && pChild->m_pNext != pntNode)
        {
            pChild = pChild->m_pNext;
        }

        ASSERT(pChild != NULL);
        pChild->m_pNext = pntNode->m_pNext;
    }
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapinManager
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapinManager);



//-------------------------------------------------------------------------
// CSnapinManager::CSnapinManager
//
// Constructor
//--------------------------------------------------------------------------
CSnapinManager::CSnapinManager(CMTNode *pmtNode) :
                m_pmtNode(pmtNode),
                m_proppStandAlone(this),
                m_proppExtension(this),
                m_bInitialized(false)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinManager);

    static TCHAR titleBuffer[ 256 ];
    ::LoadString( GetStringModule(), ID_SNP_MANAGER_TITLE, titleBuffer, sizeof(titleBuffer) / sizeof(TCHAR) );
    m_psh.pszCaption = titleBuffer;

    ASSERT(m_pmtNode != NULL);

    // Add the property pages
    AddPage( m_proppStandAlone );
    AddPage( m_proppExtension );

    // hide the Apply button
    m_psh.dwFlags |= PSH_NOAPPLYNOW;

    m_pMMCPolicy = NULL;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinManager);
}


//-------------------------------------------------------------------------
// CSnapinManager::~CSnapinManager
//
// Destructor
//-------------------------------------------------------------------------
CSnapinManager::~CSnapinManager()
{
    DECLARE_SC(sc, TEXT("CSnapinManager::~CSnapinManager"));

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinManager);

    Trace(tagSnapinManager, TEXT("CSnapinManager::~CSnapinManager"));


    // Delete all manager nodes
    if (m_mgNodeList.GetCount() > 0)
    {
        ASSERT(m_mgNodeList.GetCount() == 1);
        delete m_mgNodeList.GetHead();
        m_mgNodeList.RemoveAll();
    }

    // Delete added nodes
    POSITION pos = m_NewNodesList.GetHeadPosition();
    while (pos!=NULL)
    {
        delete m_NewNodesList.GetNext(pos);
    }
    m_NewNodesList.RemoveAll();

    // Clear deleted node list
    m_mtnDeletedNodesList.RemoveAll();

    // Free snapin info cache
    GUID guid;
    PSNAPININFO pSnapInfo;

    pos = m_SnapinInfoCache.GetStartPosition();
    while(pos != NULL)
    {
        m_SnapinInfoCache.GetNextAssoc(pos, guid, pSnapInfo);
        pSnapInfo->Release();
    }
    m_SnapinInfoCache.RemoveAll();

    if (m_pMMCPolicy)
        delete m_pMMCPolicy;

    // destroy imagelist
    m_iml.Destroy();

    // purge the snapin cache, since we released all references
    // and some snapins should die
    CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
    sc = ScCheckPointers( pSnapInCache, E_UNEXPECTED );
    if ( !sc.IsError() )
        pSnapInCache->Purge();

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinManager);
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::ScGetSnapinInfo
//
//  Synopsis:    Given Class-id or prog-id or name of a snapin, return
//               the snapins's CSnapinInfo object. (Assumes the
//               CSnapinInfoCache is already populated).
//
//  Arguments:   [szSnapinNameOrCLSIDOrProgID] - [In] snapin name or class-id or prog-id.
//               [ppSnapinInfo]                - [Out] param to return CSnapinInfo value.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinManager::ScGetSnapinInfo(LPCWSTR szSnapinNameOrCLSIDOrProgID, CSnapinInfo **ppSnapinInfo)
{
    DECLARE_SC(sc, _T("CSnapinManager::ScFindSnapinAndInitSnapinInfo"));
    sc = ScCheckPointers(szSnapinNameOrCLSIDOrProgID, ppSnapinInfo);
    if (sc)
        return sc;

    // 0. The given string may be snapin name, class-id or prog-id.

    // 1. convert the string to a CLSID
    CLSID SnapinCLSID;
    sc = CLSIDFromString( const_cast<LPWSTR>(szSnapinNameOrCLSIDOrProgID), &SnapinCLSID);

    // 2. improper formatting. try to interpret the string as a ProgID
    if(sc == SC(CO_E_CLASSSTRING))
        sc = CLSIDFromProgID( const_cast<LPWSTR>(szSnapinNameOrCLSIDOrProgID), &SnapinCLSID);

    // 3. If class-id is extracted successfully find the CSnapinInfo in the cache and return.
    if (! sc.IsError())
    {
        *ppSnapinInfo = m_SnapinInfoCache.FindEntry(SnapinCLSID);
        return sc;
    }

    // 4. Else interpret the string as snapin name.

    USES_CONVERSION;

    const tstring& strSnapinName = OLE2CT(szSnapinNameOrCLSIDOrProgID);
    // This assumes the snapincache is populated.
    POSITION pos  = m_SnapinInfoCache.GetStartPosition();
    while(pos != NULL)
    {
	    GUID guid;
        PSNAPININFO pTempSnapInfo = NULL;
        m_SnapinInfoCache.GetNextAssoc(pos, guid, pTempSnapInfo);

        sc = ScCheckPointers(pTempSnapInfo, E_UNEXPECTED);
        if (sc)
            return sc;

        // Match the name. (Exact match).

        if ( CSTR_EQUAL == CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                          strSnapinName.data() , -1, OLE2CT(pTempSnapInfo->GetSnapinName()), -1))
//        if ( 0 == _wcsicmp(szSnapinNameOrCLSIDOrProgID, pTempSnapInfo->GetSnapinName()) )
        {
			*ppSnapinInfo = pTempSnapInfo;
			return sc;
        }
    }

    return (sc = MMC_E_SNAPINNOTFOUND);
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapinManager::ScAddSnapin
 *
 * PURPOSE: Adds the snapin specified by pSnapinInfo to the console file,
 *          below Console Root.
 *          TODO: Allow the caller to specify the parent node.
 *
 * PARAMETERS:
 *    szSnapinNameOrCLSIDOrProgID : [IN] Specifies the snapin to be added (class-id
 *                                       or prog-id or full name).
 *    pProperties                 : [IN] Any properties.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CSnapinManager::ScAddSnapin(LPCWSTR szSnapinNameOrCLSIDOrProgID, SnapIn* pParentSnapinNode, Properties *pProperties)
{
    DECLARE_SC(sc, TEXT("CSnapinManager::ScAddSnapin"));

    CSnapinStandAlonePage   dlgStandalonePage(this);

    sc = ScInitialize();
    if (sc)
        return sc;

    // Above ScInitialize has populated CSnapinInfoCache, now is a good time
    // to get CSnapinInfo for given snapin
    CSnapinInfo *pSnapinInfo = NULL;
    sc = ScGetSnapinInfo(szSnapinNameOrCLSIDOrProgID, &pSnapinInfo);
    if (sc)
        return sc;

    sc = ScCheckPointers(pSnapinInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    // Set the given properties in the SnapinInfo.
    pSnapinInfo->SetInitProperties(pProperties);

    // Set the node under which this snapin will be added as console root)
    PMANAGERNODE pmgNodeParent = NULL;

    // If a parent snapin under which this snapin should be added is given then
    // get the parent MANAGERNODE (else it is console root as above).
    if (pParentSnapinNode)
    {
        // Get the MTNode for this snapin root.
        CMTSnapInNode *pMTSnapinNode = NULL;

        sc = CMTSnapInNode::ScGetCMTSnapinNode(pParentSnapinNode, &pMTSnapinNode);
        if (sc)
            return sc;

        // Find the MANAGERNODE from MTNode.
        pmgNodeParent = FindManagerNode(m_mgNodeList, static_cast<CMTNode*>(pMTSnapinNode));
        if (! pmgNodeParent)
            return (sc = E_UNEXPECTED);
    }
	else
		pmgNodeParent = m_mgNodeList.GetHead();

    sc = dlgStandalonePage.ScAddOneSnapin(pmgNodeParent, pSnapinInfo);
    if(sc)
        return sc;

    // Caller must provide master tree before each DoModal
    m_pmtNode = NULL;

    // Apply changes
    UpdateSnapInCache();

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::FindManagerNode
//
//  Synopsis:    Given MTNode of a snapin, find the managernode
//
//  Arguments:   [mgNodeList] - the MANAGERNODE list.
//               [pMTNode]    - the CMTNode* whose MANAGERNODE representation is needed.
//
//  Returns:     The CManagerNode ptr or NULL.
//
//--------------------------------------------------------------------
PMANAGERNODE CSnapinManager::FindManagerNode(const ManagerNodeList& mgNodeList, CMTNode *pMTNode)
{
    PMANAGERNODE pmgNode = NULL;

    POSITION pos = mgNodeList.GetHeadPosition();
    while (pos)
    {
        pmgNode = mgNodeList.GetNext(pos);

        if (pmgNode->m_pmtNode == pMTNode)
        {
            return pmgNode;
        }

        // One standalone snapin can be added below another.
        pmgNode = FindManagerNode(pmgNode->m_ChildList, pMTNode);

        if (pmgNode)
            return pmgNode;
    }

    return NULL;
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::ScRemoveSnapin
//
//  Synopsis:    Remove the snapin represented by given CMTNode*.
//
//  Arguments:   [pMTNode] - the snapin to be removed.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinManager::ScRemoveSnapin (CMTNode *pMTNode)
{
    DECLARE_SC(sc, _T("CSnapinManager::ScRemoveSnapin"));

    CSnapinStandAlonePage   dlgStandalonePage(this);

    sc = ScInitialize();
    if (sc)
        return sc;

    // Find the MANAGERNODE from MTNode.
    PMANAGERNODE pmgNode = FindManagerNode(m_mgNodeList, pMTNode);
    if (! pmgNode)
        return (sc = E_UNEXPECTED);

    // Remove the snapin.
    sc = dlgStandalonePage.ScRemoveOneSnapin(pmgNode, /*iItem*/ -1, /*bVisible*/ false);
    if(sc)
        return sc;

    delete pmgNode;

    // Apply changes
    UpdateSnapInCache();

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::ScInitialize
//
//  Synopsis:    Initialize the snapin mgr object by loading snapin-info
//               MTNode tree & creating imagelist for snapins.
//
//  Arguments:
//
//  Returns:     SC
//
// Note: Should be called only once per CSnapinManager instance.
//
//--------------------------------------------------------------------
SC CSnapinManager::ScInitialize ()
{
    DECLARE_SC(sc, _T("CSnapinManager::ScInitialize"));

    sc = ScCheckPointers(m_pmtNode, E_UNEXPECTED);
    if (sc)
        return sc;

    // If already initialized just Reload the MTNode tree.
    if (m_bInitialized)
    {
        if (!LoadMTNodeTree(NULL, m_pmtNode))
            return (sc = E_FAIL);

        return sc;
    }

    m_pMMCPolicy = new CPolicy;
    sc = ScCheckPointers(m_pMMCPolicy, E_OUTOFMEMORY);
    if (sc)
        return sc;

    sc = m_pMMCPolicy->ScInit();
    if (sc)
        return sc;

    sc = ScLoadSnapinInfo();
    if (sc)
        return sc;

    // Create the image list
    if (!m_iml.Create (16/*cx*/, 16/*cy*/, ILC_COLOR | ILC_MASK, 16/*nInitial*/, 16/*cGrow*/))
        return (sc = E_FAIL);

    if (!LoadMTNodeTree(NULL, m_pmtNode))
        return (sc = E_FAIL);

    m_bInitialized = true;

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::ScEnableAllExtensions
//
//  Synopsis:    Enable all the extensions for the given snapin
//
//  Arguments:   [clsidSnapin] - Snapin clsid for which extensions be enabled.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinManager::ScEnableAllExtensions (const CLSID& clsidSnapin, BOOL bEnable)
{
    DECLARE_SC(sc, _T("CSnapinManager::ScEnableAllExtensions"));

    sc = ScInitialize();
    if (sc)
        return sc;

    // Get the snapin's SnapinInfo.
    CSnapinInfo *pSnapinInfo = m_SnapinInfoCache.FindEntry(clsidSnapin);
    sc = ScCheckPointers(pSnapinInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    if (!pSnapinInfo->IsUsed())
        return (ScFromMMC(MMC_E_SnapinNotAdded));

    PEXTENSIONLINK pExt = pSnapinInfo->GetAvailableExtensions(&m_SnapinInfoCache, m_pMMCPolicy);
    if (!pExt)
        return (sc = S_FALSE); // No extensions

    pSnapinInfo->SetEnableAllExtensions(bEnable);

    // if enabling all extensions, turn on all installed extensions
    if (pSnapinInfo->AreAllExtensionsEnabled())
    {
        PEXTENSIONLINK pExt = pSnapinInfo->GetExtensions();
        while (pExt != NULL)
        {
            if (pExt->GetSnapinInfo()->IsInstalled())
                pExt->SetState(CExtensionLink::EXTEN_ON);

            pExt = pExt->Next();
        }
    }

    // Update the snapin mgr's snapin cache.
    UpdateSnapInCache();

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinManager::ScEnableExtension
//
//  Synopsis:    Enable or disable an extension.
//
//  Arguments:   [clsidPrimarySnapin] -
//               [clsidExtension]     - snapin to be enabled/disabled
//               [bEnable]            - Enable or disable
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinManager::ScEnableExtension (const CLSID& clsidPrimarySnapin,
                                      const CLSID& clsidExtension,
                                      bool bEnable)
{
    DECLARE_SC(sc, _T("CSnapinManager::ScEnableExtension"));

    sc = ScInitialize();
    if (sc)
        return sc;

    // Get the snapin's SnapinInfo.
    CSnapinInfo *pSnapinInfo = m_SnapinInfoCache.FindEntry(clsidPrimarySnapin);
    sc = ScCheckPointers(pSnapinInfo, E_UNEXPECTED);
    if (sc)
        return sc;

    if (!pSnapinInfo->IsUsed())
        return (ScFromMMC(MMC_E_SnapinNotAdded));

    // If disable make sure all extensions are not enabled.
    if ( (!bEnable) && (pSnapinInfo->AreAllExtensionsEnabled()) )
        return ScFromMMC(MMC_E_CannotDisableExtension);

    // Load the extensions for the primary.
    PEXTENSIONLINK pExt = pSnapinInfo->GetAvailableExtensions(&m_SnapinInfoCache, m_pMMCPolicy);
    if (!pExt)
        return (sc = S_FALSE); // No extensions

    // Find our extension.
    while (pExt)
    {
        CSnapinInfo *pExtSnapinInfo = pExt->GetSnapinInfo();
        sc = ScCheckPointers(pExtSnapinInfo, E_UNEXPECTED);
        if (sc)
            return sc;

        if (pExtSnapinInfo->GetCLSID() == clsidExtension)
            break;

        pExt = pExt->Next();
    }

    sc = ScCheckPointers(pExt, E_UNEXPECTED);
    if (sc)
        return sc;

    pExt->SetState(bEnable ? CExtensionLink::EXTEN_ON : CExtensionLink::EXTEN_OFF);

    // Update the snapin mgr's snapin cache.
    UpdateSnapInCache();

    return (sc);
}


//--------------------------------------------------------------------------
// CSnapinManager::DoModal
//
// Initialize local data structures and present the manager property sheet.
// Return user selection (OK or Cancel).
//
// Note: Should be called only once per CSnapinManager instance.
//
//-------------------------------------------------------------------------
int CSnapinManager::DoModal()
{
    DECLARE_SC(sc, TEXT("CSnapinManager::DoModal"));

    int iResp = 0; // 0 is failure

    sc = ScCheckPointers(m_pmtNode, E_UNEXPECTED);
    if (sc)
        return iResp;

    // init ComboBoxEx window class
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC   = ICC_USEREX_CLASSES;

    if (!InitCommonControlsEx(&icex))
    {
        sc = E_FAIL;
        return iResp;
    }

    sc = ScInitialize();
    if (sc)
        return iResp;

    // Do the property sheet
    iResp = CPropertySheet::DoModal();

    // Caller must provide master tree before each DoModal
    m_pmtNode = NULL;

    if (iResp == IDOK)
    {
        // Apply changes
        UpdateSnapInCache();
    }

    // Delete all manager nodes
    ASSERT(m_mgNodeList.GetCount() == 1);
    delete m_mgNodeList.GetHead();
    m_mgNodeList.RemoveAll();

    return iResp;
}


//----------------------------------------------------------------------
// CSnapinManager::UpdateSnapInCache
//
// Apply changes recorded in the SnapinInfo cache to the SnapinCache.
//----------------------------------------------------------------------
void CSnapinManager::UpdateSnapInCache(void)
{
    CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
    ASSERT(pSnapInCache != NULL);

    GUID guid;
    PSNAPININFO pSnapInfo;
    POSITION pos;

    // First create any new snapins
    pos  = m_SnapinInfoCache.GetStartPosition();
    while(pos != NULL)
    {
        m_SnapinInfoCache.GetNextAssoc(pos, guid, pSnapInfo);

        // if snapin is ref'd but doesn't exist yet
        if (pSnapInfo->IsUsed() && pSnapInfo->GetSnapIn() == NULL)
        {
              CSnapInPtr spSnapIn;
              SC sc = pSnapInCache->ScGetSnapIn(pSnapInfo->GetCLSID(), &spSnapIn);
              ASSERT(!sc.IsError());
              if (!sc.IsError())
                  pSnapInfo->SetSnapIn(spSnapIn);
        }
    }

    // Next add or remove all changed extensions
    pos = m_SnapinInfoCache.GetStartPosition();
    while(pos != NULL)
    {
        m_SnapinInfoCache.GetNextAssoc(pos, guid, pSnapInfo);
        CSnapIn* pSnapIn = pSnapInfo->GetSnapIn();

        if (pSnapInfo->IsUsed())
        {
            // Update state of Enable All flag
            pSnapIn->SetAllExtensionsEnabled(pSnapInfo->AreAllExtensionsEnabled());

            // Error to override the snap-in's  enable
            ASSERT(!(pSnapIn->DoesSnapInEnableAll() && !pSnapIn->AreAllExtensionsEnabled()));
        }

        PEXTENSIONLINK pExt = pSnapInfo->GetExtensions();
        while (pExt)
        {
            // if extension added or removed
            if (pExt->IsChanged())
            {
                CSnapIn* pExtSnapIn = pExt->GetSnapinInfo()->GetSnapIn();
                ASSERT(pExtSnapIn != NULL);

                // Apply change to SnapIn
                if (pExtSnapIn)
                {
                    if (pExt->GetState() == CExtensionLink::EXTEN_ON)
                    {
                        CExtSI* pExtSI = pSnapIn->AddExtension(pExtSnapIn);
                        ASSERT(pExtSI != NULL);
                        pExtSI->SetExtensionTypes(pExt->GetExtTypes());
                        pExt->SetInitialState(CExtensionLink::EXTEN_ON);
                    }
                    else
                    {
                        pSnapIn->MarkExtensionDeleted(pExtSnapIn);
                        pExt->SetInitialState(CExtensionLink::EXTEN_OFF);
                    }
                }

                // if namespace extension changed, mark SnapIn as changed
                if (pExt->GetExtTypes() & CExtSI::EXT_TYPE_NAMESPACE)
                {
                    pSnapIn->SetNameSpaceChanged();
                }

                // Change in extension set the help collection dirty.
                pSnapInCache->SetHelpCollectionDirty();

            }
            pExt = pExt->Next();
        }
    }


    // Propagate snapin change flags up the tree
    // This is needed in case an extension that extends another extension has changed
    BOOL bChange;
    do
    {
        bChange = FALSE;

        pos = m_SnapinInfoCache.GetStartPosition();
        while(pos != NULL)
        {
            m_SnapinInfoCache.GetNextAssoc(pos, guid, pSnapInfo);
            CSnapIn* pSnapIn = pSnapInfo->GetSnapIn();

            if (pSnapIn && !pSnapIn->HasNameSpaceChanged())
            {
                PEXTENSIONLINK pExt = pSnapInfo->GetExtensions();
                while (pExt)
                {
                    CSnapIn* pExtSnapIn = pExt->GetSnapinInfo()->GetSnapIn();

                    if (pExtSnapIn && pExtSnapIn->HasNameSpaceChanged())
                    {
                        pSnapIn->SetNameSpaceChanged();
                        bChange = TRUE;
                        break;
                    }
                    pExt = pExt->Next();
                }
            }
        }
    } while (bChange);


    //  Next release snapin info refs to snapins that aren't used
    pos  = m_SnapinInfoCache.GetStartPosition();
    while(pos != NULL)
    {
        m_SnapinInfoCache.GetNextAssoc(pos, guid, pSnapInfo);

        // if snapin exists, but isn't ref'd
        if (pSnapInfo->GetSnapIn() != NULL && !pSnapInfo->IsUsed())
        {
            pSnapInfo->DetachSnapIn();
        }
    }

#ifdef DBG
    pSnapInCache->DebugDump();
#endif

}


//----------------------------------------------------------------------
// CSnapinManager::LoadSnapinInfo
//
// Read snapin registry information. Create a snapin info object for
// each registered snapin and place in CMap indexed by snapin CLSID.
// Then enumerate snap-ins that are registered as components, but are
// not in the MMC snap-in registry. These are snap-in that will have to
// be downloaded/installed when created.
//----------------------------------------------------------------------
SC CSnapinManager::ScLoadSnapinInfo(void)
{
    DECLARE_SC(sc, TEXT("CSnapinManager::LoadSnapinInfo"));

    GUID  SnapinCLSID;
    MMC_ATL::CRegKey SnapinKey;
    CRegKeyEx ItemKey;
    long    lStat;
    TCHAR   szItemKey[MAX_PATH];

    USES_CONVERSION;

    // open MMC\Snapins key
    lStat = SnapinKey.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY, KEY_READ);
    ASSERT(lStat == ERROR_SUCCESS);

    if (lStat == ERROR_SUCCESS)
    {
        DWORD dwIndex = 0;
        DWORD dwLen = MAX_PATH;

        // enumerate all snapin keys
        while (RegEnumKeyEx(SnapinKey, dwIndex, szItemKey, &dwLen,
                            NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
        {
            sc = CLSIDFromString( T2OLE(szItemKey), &SnapinCLSID);
            if (!sc)
            {
                // Open the snapin key and create a SnapinInfo object
                // from it. Add the object to the cache (CMap)
                lStat = ItemKey.Open(SnapinKey, szItemKey, KEY_READ);
                ASSERT(lStat == ERROR_SUCCESS);
                if (lStat == ERROR_SUCCESS)
                {
                    BOOL bPermission = m_pMMCPolicy->IsPermittedSnapIn(SnapinCLSID);

                    // Don't create a new entry if a CSnapinInfo object already exists; just re-initialize it
                    PSNAPININFO pSnapInfo = m_SnapinInfoCache.FindEntry(SnapinCLSID);
                    if(pSnapInfo != NULL)
                    {
                        //re-initialize it
                        if(!pSnapInfo->InitFromMMCReg(SnapinCLSID, ItemKey, bPermission))
                            return (sc=E_FAIL);
                    }
                    else
                    {
                        // create a new object
                        pSnapInfo = new CSnapinInfo;
                        sc = ScCheckPointers(pSnapInfo, E_OUTOFMEMORY);
                        if(sc)
                            return sc;

                        if (pSnapInfo->InitFromMMCReg(SnapinCLSID, ItemKey, bPermission))
                        {
                            m_SnapinInfoCache.AddEntry(pSnapInfo);
                        }
                        else
                        {
                            delete pSnapInfo;
                        }
                    }


                    ItemKey.Close();
                }
            }

            dwIndex++;
            dwLen = MAX_PATH;
        }
    }

    // If no installer module present, return now
    if (!MsiModule().IsPresent())
        return sc;

    // Enumerate standalone snapin components
    DWORD dwQualifCnt;
    DWORD dwAppDataCnt;
    TCHAR szQualifBuf[MAX_PATH];
    TCHAR szAppDataBuf[MAX_PATH];

    // enumerate all standalone snap-in components and create snap info entries
    for (int iIndex = 0; TRUE; iIndex++)
    {
        dwQualifCnt = dwAppDataCnt = MAX_PATH;
        szQualifBuf[0] = szAppDataBuf[0] = 0;

        UINT uRet = MsiModule().EnumComponentQualifiers(const_cast<TCHAR*>(g_szMMCSnapInGuid),
                iIndex, szQualifBuf, &dwQualifCnt, szAppDataBuf, &dwAppDataCnt);

        ASSERT(uRet == ERROR_SUCCESS || uRet == ERROR_NO_MORE_ITEMS
                || uRet == ERROR_UNKNOWN_COMPONENT || uRet == ERROR_CALL_NOT_IMPLEMENTED);

        if (uRet != ERROR_SUCCESS)
            break;

        ASSERT(dwQualifCnt != 0);
        ASSERT(dwAppDataCnt != 0);

        sc = CLSIDFromString(T2OLE(szQualifBuf), &SnapinCLSID);
        if (sc)
        {
            sc.TraceAndClear();
            continue;
        }

        // Skip if this snap-in was already found in the MMC registry
        if (m_SnapinInfoCache.FindEntry(SnapinCLSID) != NULL)
            continue;

        PSNAPININFO pSnapInfo = new CSnapinInfo;

        BOOL bPermission = m_pMMCPolicy->IsPermittedSnapIn(SnapinCLSID);

        if (pSnapInfo->InitFromComponentReg(SnapinCLSID, szAppDataBuf, TRUE, bPermission))
        {
            m_SnapinInfoCache.AddEntry(pSnapInfo);
        }
        else
        {
            delete pSnapInfo;
        }

    }

    return sc;
}


//---------------------------------------------------------------------------
// CSnapinManager::LoadMTNodeTree
//
// Recursively walk the static portion of the master tree provided by and
// create a parallel tree of manager nodes.
//---------------------------------------------------------------------------
BOOL CSnapinManager::LoadMTNodeTree(PMANAGERNODE pmgnParent, CMTNode* pmtNode)
{
    ManagerNodeList* pChildList;
    int iIndent;

    // Determine child list to add to
    if (pmgnParent == NULL)
    {
        pChildList = &m_mgNodeList;
        iIndent = 0;
    }
    else
    {
        pChildList = &pmgnParent->m_ChildList;
        iIndent = pmgnParent->m_iIndent + 1;
    }

    // Do for all nodes
    while (pmtNode != NULL)
    {
        // Only walk static portions
        if (pmtNode->IsStaticNode())
        {
            // Create a manager node
            PMANAGERNODE pmgNode = new CManagerNode;
			if ( pmgNode == NULL )
				return FALSE;

            pmgNode->m_pmtNode = pmtNode;
            pmgNode->m_pmgnParent = pmgnParent;
            pmgNode->m_iIndent = iIndent;

			tstring strName = pmtNode->GetDisplayName();
            pmgNode->m_strValue = strName.data();

            // See if this node is provided by a snapin
            CSnapIn* pSnapin = pmtNode->GetPrimarySnapIn();

            if (pSnapin)
            {
                pmgNode->m_nType = ADDSNP_SNAPIN;

                // get snapin's CLSID and use it to look up the snapin info object
                PSNAPININFO pSnapInfo = m_SnapinInfoCache.FindEntry(
                                            pmtNode->GetPrimarySnapInCLSID());
                if (pSnapInfo)
                {
                    // link node to snapin info
                    pmgNode->m_pSnapInfo = pSnapInfo;
                    pSnapInfo->AddUseRef();

                    // Link snapin to snapin info
                    pSnapInfo->AttachSnapIn(pSnapin, m_SnapinInfoCache);

                    // get images from snapin
                    pSnapInfo->LoadImages(m_iml);
                    pmgNode->m_iImage = pSnapInfo->GetImage();
                    pmgNode->m_iOpenImage = pSnapInfo->GetOpenImage();
                }
            }
            else
            {
                pmgNode->m_nType = ADDSNP_STATICNODE;

                // for built-ins, get image info directly from node
                pmgNode->m_iImage = pmtNode->GetImage();
                pmgNode->m_iOpenImage = pmtNode->GetOpenImage();
            }

            // add node to child list
            pChildList->AddTail(pmgNode);

            // add all children of this node
            if (!LoadMTNodeTree(pmgNode, pmtNode->Child()))
				return FALSE;
        }

        // go on to node next sibling
        pmtNode = pmtNode->Next();
    }

    return TRUE;
}






//############################################################################
//############################################################################
//
//  Implementation of class CSnapinStandAlonePage
//
//############################################################################
//############################################################################


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::CSnapinStandAlonePage()
//
//  Contructor
//----------------------------------------------------------------------------

CSnapinStandAlonePage::CSnapinStandAlonePage(CSnapinManager* pManager) :
            m_pManager(pManager),
            m_pmgnParent(NULL),
            m_pmgnChild(NULL),
            m_dlgAdd(pManager, this)
{
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::~CSnapinStandAlonePage()
//
//  Destructor
//----------------------------------------------------------------------------
CSnapinStandAlonePage::~CSnapinStandAlonePage()
{
    m_snpComboBox.Detach();
    m_snpListCtrl.Detach();
}

//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnInitDialog
//
//  Initialize the property page controls.
//----------------------------------------------------------------------------
LRESULT CSnapinStandAlonePage::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    static TBBUTTON tbBtn[] =
        {{ 0, ID_SNP_UP, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 }};

    // Attach control objects to control windows
    m_snpComboBox.Attach( ::GetDlgItem(m_hWnd, IDC_SNAPIN_COMBOEX ) );
    m_snpListCtrl.Attach( ::GetDlgItem(m_hWnd, IDC_SNAPIN_ADDED_LIST) );


    // The following code is needed because a toolbar created by the dialog resource
    // won't accept any buttons. This should be investigated further.

    // Get rect from dummy placeholder control
    HWND hWndStatic = GetDlgItem(IDC_TOOLBAR);
    ASSERT(hWndStatic != NULL);

    RECT rc;
    ::GetWindowRect( hWndStatic, &rc);
    ::ScreenToClient( m_hWnd, (LPPOINT)&rc);
    ::ScreenToClient( m_hWnd, ((LPPOINT)&rc)+1);

	// for RLT locales this mapping may produce wrong
	// result ( since client coordinated are mirrored)
	// following is to fix that:
    if (GetExStyle() & WS_EX_LAYOUTRTL) {
        // Swap left and right
		LONG temp = rc.left;
		rc.left = rc.right;
		rc.right = temp;
    }

    // Create a toolbar with the same coordiantes
//    BOOL bStat = m_ToolbarCtrl.Create( WS_VISIBLE|WS_CHILD|TBSTYLE_TOOLTIPS|CCS_NORESIZE|CCS_NODIVIDER, rc, this, 1);
//    ASSERT(bStat);
    HWND hToolBar = ::CreateWindow( TOOLBARCLASSNAME, _T( "" ), WS_VISIBLE|WS_CHILD|TBSTYLE_TOOLTIPS|TBSTYLE_TRANSPARENT|CCS_NORESIZE|CCS_NODIVIDER,
                                        rc.left, rc.top, ( rc.right - rc.left ), ( rc.bottom - rc.top ), *this, (HMENU) IDC_TOOLBAR,
                                        _Module.GetModuleInstance(), NULL );
    ASSERT( hToolBar );
    ::SendMessage( hToolBar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0L );
    m_ToolbarCtrl.Attach( hToolBar );

    int iStat = m_ToolbarCtrl.AddBitmap( 1, IDB_SNP_MANAGER );
    ASSERT(iStat != -1);

    BOOL bStat = m_ToolbarCtrl.AddButtons( 1, tbBtn );
    ASSERT(bStat);

    // attach image list to the combo box and list view controls
    m_snpComboBox.SetImageList(m_pManager->m_iml);
    m_snpListCtrl.SetImageList(m_pManager->m_iml, LVSIL_SMALL);

  // Apply workarounds for NT4 comboboxex bugs
    m_snpComboBox.FixUp();

    // Load combo box list with current node tree
    AddNodeListToTree(m_pManager->m_mgNodeList);

    // Add single column to list box
    m_snpListCtrl.GetClientRect(&rc);

    LV_COLUMN lvc;
    lvc.mask = LVCF_WIDTH | LVCF_SUBITEM;
    lvc.cx = rc.right - rc.left - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;

    int iCol = m_snpListCtrl.InsertColumn(0, &lvc);
    ASSERT(iCol == 0);

    // Select the first node as the current parent
    PMANAGERNODE pmgNode = m_pManager->m_mgNodeList.GetHead();

    if (pmgNode != NULL)
        SelectParentNodeItem(pmgNode);

    // Turn off the scroll bar in description edit box.
	::ShowScrollBar(GetDlgItem(IDC_SNAPIN_DESCR), SB_VERT, FALSE);

    return TRUE;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::AddNodeListToTree
//
// Populate the ComboBoxEx control from the manager node tree.
//----------------------------------------------------------------------------
VOID CSnapinStandAlonePage::AddNodeListToTree(ManagerNodeList& NodeList)
{
    COMBOBOXEXITEM ComboItem;

    ComboItem.mask = CBEIF_INDENT | CBEIF_LPARAM | CBEIF_IMAGE | CBEIF_TEXT | CBEIF_SELECTEDIMAGE;
    ComboItem.iItem = -1;

    // Add each node in list to the combo box
    POSITION pos = NodeList.GetHeadPosition();
    while (pos != NULL)
    {
        PMANAGERNODE pmgNode = NodeList.GetNext(pos);

        ComboItem.iIndent        = pmgNode->m_iIndent;
        ComboItem.iImage         = pmgNode->m_iImage;
        ComboItem.iSelectedImage = pmgNode->m_iOpenImage;
        ComboItem.lParam         = reinterpret_cast<LPARAM>(pmgNode);
        ComboItem.pszText        = const_cast<LPTSTR>((LPCTSTR)pmgNode->m_strValue);

        m_snpComboBox.InsertItem(&ComboItem);

        // Add node's children directly under the node
        AddNodeListToTree(pmgNode->m_ChildList);
    }
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::AddChildToTree
//
//  Add new manager node to ComboBoxEx control
//----------------------------------------------------------------------------

int CSnapinStandAlonePage::AddChildToTree(PMANAGERNODE pmgNode)
{
    COMBOBOXEXITEM ComboItem;

    PMANAGERNODE pmgnParent = pmgNode->m_pmgnParent;
    ASSERT(pmgnParent != NULL);


    // Get item index of parent
    ComboItem.mask = CBEIF_LPARAM;
    ComboItem.lParam = (LPARAM)pmgnParent;
    int iItem = m_snpComboBox.FindItem(&ComboItem);
    ASSERT(iItem != -1);

    // Locate index of next sibling (or higher) node
    iItem = m_snpComboBox.FindNextBranch(iItem);

    // Insert new node at that position
    ComboItem.mask           = CBEIF_INDENT | CBEIF_LPARAM | CBEIF_IMAGE | CBEIF_TEXT | CBEIF_SELECTEDIMAGE;
    ComboItem.iItem          = iItem;
    ComboItem.iIndent        = pmgNode->m_iIndent;
    ComboItem.iImage         = pmgNode->m_iImage;
    ComboItem.iSelectedImage = pmgNode->m_iOpenImage;
    ComboItem.lParam         = (LPARAM)pmgNode;
    ComboItem.pszText        = const_cast<LPTSTR>((LPCTSTR)pmgNode->m_strValue);

    iItem = m_snpComboBox.InsertItem(&ComboItem);
    ASSERT(iItem != -1);

    return iItem;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::DisplayChildList
//
//  Display a list of nodes in the listbox control. This is called whenever
//  the current parent node is changed.
//----------------------------------------------------------------------------

VOID CSnapinStandAlonePage::DisplayChildList(ManagerNodeList& NodeList)
{

    // Clear old list
    m_snpListCtrl.DeleteAllItems();

    int iIndex = 0;

    // Add each node from the list
    POSITION pos = NodeList.GetHeadPosition();
    while (pos != NULL)
    {
        PMANAGERNODE pmgNode = NodeList.GetNext(pos);
        AddChildToList(pmgNode, iIndex++);
    }

    // Clear current selection
    SetupChildNode(NULL);

    // Set focus to the first item
    m_snpListCtrl.SetItemState(0, LVIS_FOCUSED, LVIS_FOCUSED);
}




//----------------------------------------------------------------------------
// CSnapinStandAlonePage::AddChildToList
//
//  Add a manager node to the listview control.
//----------------------------------------------------------------------------
int CSnapinStandAlonePage::AddChildToList(PMANAGERNODE pmgNode, int iIndex)
{
    LV_ITEM LVItem;

    LVItem.mask     = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    LVItem.iItem    = (iIndex >= 0) ? iIndex : m_snpListCtrl.GetItemCount();
    LVItem.iSubItem = 0;
    LVItem.iImage   = pmgNode->m_iImage;
    LVItem.pszText  = const_cast<LPTSTR>((LPCTSTR)pmgNode->m_strValue);
    LVItem.lParam   = reinterpret_cast<LPARAM>(pmgNode);

    iIndex = m_snpListCtrl.InsertItem(&LVItem);
    ASSERT (iIndex != -1);

    return iIndex;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnTreeItemSelect
//
// Handle selection of item from ComboBoxEx control. Make the selected
// item the current parent node.
//----------------------------------------------------------------------------
LRESULT CSnapinStandAlonePage::OnTreeItemSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_snpComboBox.GetCurSel();
    ASSERT(iItem >= 0);
    if (iItem < 0)
        return 0;

    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_LPARAM;
    ComboItem.iItem = iItem;

    BOOL bStat = m_snpComboBox.GetItem(&ComboItem);
    ASSERT(bStat);

    PMANAGERNODE pMgrNode = reinterpret_cast<PMANAGERNODE>(ComboItem.lParam);
    ASSERT(pMgrNode != NULL);

    SetupParentNode(pMgrNode);

    return 0;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnTreeUp
//
// Handle activation of folder-up button. Make parent of the current parent
// node the new current parent.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnTreeUp( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    ASSERT(m_pmgnParent != NULL && m_pmgnParent->m_pmgnParent != NULL);

    SelectParentNodeItem(m_pmgnParent->m_pmgnParent);

    return 0;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::SelectParentNodeItem
//
// Handle selection of item from ComboBoxEx control. Make the selected
// item the current parent node.
//----------------------------------------------------------------------------

void CSnapinStandAlonePage::SelectParentNodeItem(PMANAGERNODE pMgrNode)
{
    // Locate node entry in the dropdown combo box
    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_LPARAM;
    ComboItem.lParam = reinterpret_cast<LPARAM>(pMgrNode);

    int iComboItem = m_snpComboBox.FindItem(&ComboItem);
    ASSERT(iComboItem != -1);
    if (iComboItem < 0)
        return;

    // Select the combo box entry
    m_snpComboBox.SetCurSel(iComboItem);

    SetupParentNode(pMgrNode);
}


/*+-------------------------------------------------------------------------*
 *
 * CSnapinStandAlonePage::SetupParentNode
 *
 * PURPOSE: Setup a manger node as the current parent.
 *
 * PARAMETERS:
 *    PMANAGERNODE  pMgrNode :
 *    bool          bVisible : false if this dialog is not being shown.
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
CSnapinStandAlonePage::SetupParentNode(PMANAGERNODE pMgrNode, bool bVisible)
{
    ASSERT(pMgrNode != NULL);

    // Set node as current parent
    m_pmgnParent = pMgrNode;

    if(!bVisible)
        return;

    // Display children in list view
    DisplayChildList(pMgrNode->m_ChildList);

    // Enable folder-up button if current parent has a parent
    m_ToolbarCtrl.EnableButton(ID_SNP_UP,( pMgrNode->m_pmgnParent != NULL));

    // Present selection to Visual Test (It can't get it through the ComboBoxEx)
    TCHAR VTBuf[100];
    _stprintf(VTBuf,_T("%d,%s\0"), pMgrNode->m_iIndent, pMgrNode->m_strValue);
    ::SetWindowText( GetDlgItem(IDC_VTHELPER), VTBuf );
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::SetupChildNode
//
// Setup a manger node as the current child.
//----------------------------------------------------------------------------

void CSnapinStandAlonePage::SetupChildNode(PMANAGERNODE pMgrNode)
{
    // Set node as current child
    m_pmgnChild = pMgrNode;

    // Enable/disable Delete button
    EnableButton(m_hWnd, IDC_SNAPIN_MANAGER_DELETE, m_snpListCtrl.GetSelectedCount() != 0);

    // Enable/disable About button
    EnableButton(m_hWnd, IDC_SNAPIN_ABOUT, m_pmgnChild && m_pmgnChild->HasAboutInfo());
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnListItemChanged
//
// Handle selection of item from listview control. Update description text
// and Delete button state.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnListItemChanged( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pnmh;
    PMANAGERNODE pmgNode = NULL;

    // if item selected
    if (~pNMListView->uOldState & pNMListView->uNewState & LVIS_SELECTED)
    {
        // get description text from snapin info
        pmgNode = (PMANAGERNODE)pNMListView->lParam;

        // Get description text if any available
        LPOLESTR lpsz = NULL;
        if (pmgNode->GetSnapinInfo())
        {
            pmgNode->GetSnapinInfo()->LoadAboutInfo();
            lpsz = pmgNode->GetSnapinInfo()->GetDescription();
        }

        // display in description window
        USES_CONVERSION;
        SC sc = ScSetDescriptionUIText(GetDlgItem(IDC_SNAPIN_DESCR), lpsz ? OLE2CT(lpsz ): _T(""));
        if (sc)
            sc.TraceAndClear();

        // Make node the current child
        SetupChildNode(pmgNode);
     }
     else
     {
        SetupChildNode(NULL);
     }

     return 0;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnListItemDblClick
//
// Handle double click of listview item. Make the selected node the current
// parent node.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnListItemDblClick( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    // Get the selected item
    int iItem = m_snpListCtrl.GetNextItem(-1, LVNI_SELECTED);
    if (iItem < 0)
        return 0;

    // Get the item data (ManagerNode pointer)
    PMANAGERNODE pmgNode = reinterpret_cast<PMANAGERNODE>(m_snpListCtrl.GetItemData(iItem));

    // Select this node as the current parent
    SelectParentNodeItem(pmgNode);

    return 0;
}

//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnListKeyDown
//
// Handle double click of listview item. Make the selected node the current
// parent node.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnListKeyDown( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    LV_KEYDOWN* pNotify = reinterpret_cast<LV_KEYDOWN*>(pnmh);

    if (pNotify->wVKey == VK_DELETE)
    {
        OnDeleteSnapin( 1, IDC_SNAPIN_MANAGER_DELETE, (HWND)GetDlgItem(IDC_SNAPIN_MANAGER_DELETE), bHandled );
    }
    else
    {
        bHandled = FALSE;
    }

    return 0;
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnAddSnapin
//
// Handle activation of Add Snapin button. Bring up the Add dialog and create
// a NewTreeNode for the selected snapin type.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnAddSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    ASSERT(m_pmgnParent != NULL);

    // display the Add dialog
    GetAddDialog().DoModal();

    return 0;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinStandAlonePage::ScAddOneSnapin
 *
 * PURPOSE: Called to add a single snapin underneath the specified node.
 *          Does not use the UI.
 *
 * PARAMETERS:
 *    PMANAGERNODE  pmgNodeParent:  The parent node to add this below
 *    PSNAPININFO   pSnapInfo :     The snapin to add.
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CSnapinStandAlonePage::ScAddOneSnapin(PMANAGERNODE pmgNodeParent, PSNAPININFO pSnapInfo)
{
    DECLARE_SC(sc, TEXT("CSnapinStandAlonePage::ScAddOneSnapin"));

    // check parameters
    if( (NULL == pmgNodeParent) || (NULL == pSnapInfo) )
    {
        sc = E_POINTER;
        return sc;
    }

    // set up the parent node pointer
    SetupParentNode(pmgNodeParent, false /*bVisible*/);

    // add the snapin.
    sc = AddOneSnapin(pSnapInfo, false /*bVisual*/);
    if (sc)
        return sc;

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CSnapinStandAlonePage::AddOneSnapin
 *
 * PURPOSE: This method is called from the add snap-in dialog each time the user requests
 *          to add a snap-in node. The method creates the node and adds it to the
 *          snap-in manager's copy of the master tree.
 *
 * PARAMETERS:
 *    PSNAPININFO  pSnapInfo :
 *    bool         bVisible :   true if the addition is being done with
 *                             the snapin manager being visible, false
 *                             if the addition is being done by automation.
 *
 * RETURNS:
 *    LRESULT
 *
 *+-------------------------------------------------------------------------*/
HRESULT CSnapinStandAlonePage::AddOneSnapin(PSNAPININFO pSnapInfo, bool bVisible)
{
    DECLARE_SC(sc, TEXT("CSnapinStandAlonePage::AddOneSnapin"));

    if (pSnapInfo == NULL)
        return S_FALSE;

    // If this snapin type is not currrently in use
    if (pSnapInfo->GetSnapIn() == NULL)
    {
        // ensure that the snapin is in the cache so if the user
        // requests help from the wizard pages, the help collection
        // will contain this snapin's topics
        CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
        ASSERT(pSnapInCache != NULL);

        // use a smart pointer because we don't need to hold it once
        // the cache entry is created
        CSnapInPtr spSnapIn;
        sc = pSnapInCache->ScFindSnapIn(pSnapInfo->GetCLSID(), &spSnapIn);
        if (sc)
        {
            sc = pSnapInCache->ScGetSnapIn(pSnapInfo->GetCLSID(), &spSnapIn);
            if(sc)
                sc.TraceAndClear();  // not a big issue - we can ignore it
                                    // - just normaly shouldn't be so

            // Set stand-alone change, to invalidate help collection
            pSnapInCache->SetHelpCollectionDirty();
        }
    }

    // If component is not installed yet, do it now
    if (!pSnapInfo->IsInstalled())
    {
        // 1. install the component
        sc = pSnapInfo->ScInstall(NULL);
        if(sc)
            return sc.ToHr();

        // 2. update all the snapin info objects from the registry. This is because installing a
        // single msi package may install several snapins.
        sc = ScCheckPointers(m_pManager, E_UNEXPECTED);
        if(sc)
            return sc.ToHr();

        sc = m_pManager->ScLoadSnapinInfo();
        if(sc)
            return sc.ToHr();
    }

    // Run wizard to get component data
    // (returns a ref'd interface)
    HWND hWndParent = NULL;
    if(bVisible)
    {
        hWndParent = GetAddDialog().m_hWnd;
    }
    else
    {
        hWndParent = ::GetDesktopWindow();
    }

    IComponentDataPtr   spIComponentData;
    PropertiesPtr       spSnapinProps;

    sc = ScRunSnapinWizard (pSnapInfo->GetCLSID(),
                               hWndParent,
                               pSnapInfo->GetInitProperties(),
                               *&spIComponentData,
                               *&spSnapinProps);
    if (sc)
        return (sc.ToHr());

    // if the creation succeeded
    if (spIComponentData != NULL)
    {
        // Create new tree node
        CNewTreeNode* pNewTreeNode = new CNewTreeNode;
        if (pNewTreeNode == NULL)
            return ((sc = E_OUTOFMEMORY).ToHr());

        // if snapin node
        pNewTreeNode->m_spIComponentData = spIComponentData;
        pNewTreeNode->m_clsidSnapIn      = pSnapInfo->GetCLSID();
        pNewTreeNode->m_spSnapinProps    = spSnapinProps;

        // must be child of existing MT node or another new node
        ASSERT(m_pmgnParent->m_pmtNode || m_pmgnParent->m_pNewNode);

        // If adding to existing node
        if (m_pmgnParent->m_pmtNode)
        {
            // Add directly to new nodes list
            pNewTreeNode->m_pmtNode = m_pmgnParent->m_pmtNode;
            m_pManager->m_NewNodesList.AddTail(pNewTreeNode);
        }
        else
        {
            // Add as child to new node
            pNewTreeNode->m_pParent = m_pmgnParent->m_pNewNode;
            m_pmgnParent->m_pNewNode->AddChild(pNewTreeNode);
        }

        // Create new manger node
        PMANAGERNODE pmgNode = new CManagerNode;
        pmgNode->m_pNewNode = pNewTreeNode;

        pSnapInfo->AddUseRef();
        pmgNode->m_pSnapInfo = pSnapInfo;
        pmgNode->m_nType = ADDSNP_SNAPIN;

        // if this snapin type isn't currently in use
        if (pSnapInfo->GetSnapIn() == NULL)
        {
            // if so, get the snapin's cache entry so we can
            // determine its required extensions.
            CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
            ASSERT(pSnapInCache != NULL);

            CSnapInPtr spSnapIn;
            SC sc = pSnapInCache->ScGetSnapIn(pSnapInfo->GetCLSID(), &spSnapIn);
            ASSERT(!sc.IsError());

            if (!sc.IsError())
            {   // Load the extensions then call AttachSnapIn so snapin manager
                // will load the required extensions from the cache and turn
                // them on by default. (Do the load here to prevent AttachSnapIn
                // from creating another instance of the snapin.)
                LoadRequiredExtensions(spSnapIn, spIComponentData);
                pSnapInfo->AttachSnapIn(spSnapIn, m_pManager->m_SnapinInfoCache);
            }
        }
        if(bVisible)
        {
            // Get images from snapin
            pSnapInfo->LoadImages(m_pManager->m_iml);
            pmgNode->m_iImage = pSnapInfo->GetImage();
            pmgNode->m_iOpenImage = pSnapInfo->GetOpenImage();
        }

        // get display name from component data
        if ( FAILED(LoadRootDisplayName(spIComponentData, pmgNode->m_strValue)) )
        {
            ASSERT(FALSE);
            pmgNode->m_strValue = pSnapInfo->GetSnapinName();
        }

        // Add to manager node tree, listview and combobox controls
        m_pmgnParent->AddChild(pmgNode);

        if(bVisible)
        {
            AddChildToTree(pmgNode);

            int iIndex = AddChildToList(pmgNode);

            // Give focus to new item and make it visible
            m_snpListCtrl.EnsureVisible(iIndex, FALSE);
            m_snpListCtrl.SetItemState(iIndex,LVIS_FOCUSED,LVIS_FOCUSED);
        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:      CSnapinStandAlonePage::ScRemoveOneSnapin
//
//  Synopsis:    Removes the snapin from the snapin manager data structures.
//
//  Arguments:   [pmgNode]  - The (MANAGERNODE of) snapin to be removed.
//               [iItem]    - index of the snapin in snapin mgr,
//                            valid only if snapin mgr is visible.
//               [bVisible] - Snapin mgr UI is visible/hidden.
//
//  Returns:     SC
//
//  Note:        The caller should delete PMANAGERNODE passed else memory will leak.
//
//--------------------------------------------------------------------
SC
CSnapinStandAlonePage::ScRemoveOneSnapin (
    PMANAGERNODE pmgNode,
    int          iItem,
    bool bVisible /*= true*/)
{
    DECLARE_SC(sc, _T("CSnapinStandAlonePage::ScRemoveOneSnapin"));
    sc = ScCheckPointers(pmgNode);
    if (sc)
        return sc;

    sc = ScCheckPointers(m_pManager, pmgNode->m_pmgnParent, E_UNEXPECTED);
    if (sc)
        return sc;

    // If existing MT node
    if (pmgNode->m_pmtNode != NULL)
    {
        // Add MT node to delete list
        m_pManager->m_mtnDeletedNodesList.AddTail(pmgNode->m_pmtNode);

        // Delete any new nodes attached to this one
        POSITION pos = m_pManager->m_NewNodesList.GetHeadPosition();
        while (pos)
        {
            POSITION posTemp = pos;

            PNEWTREENODE pNew = m_pManager->m_NewNodesList.GetNext(pos);
            sc = ScCheckPointers(pNew, E_UNEXPECTED);
            if (sc)
                return sc;

            if (pNew->m_pmtNode == pmgNode->m_pmtNode)
            {
                m_pManager->m_NewNodesList.RemoveAt(posTemp);
                delete pNew;  // delete and release IComponent
            }
        }
    }
    else // if new node
    {
        PNEWTREENODE pNew = pmgNode->m_pNewNode;

        // This is a new node.
        if (NULL == pNew)
            return (sc = E_UNEXPECTED);

        // If child of an existing MT node?
        if (pNew->GetMTNode())
        {
            // Locate in new node list
            POSITION pos = m_pManager->m_NewNodesList.Find(pNew);
            if(pos == NULL)
                return (sc = E_UNEXPECTED);

            // delete this item and all it's children
            m_pManager->m_NewNodesList.RemoveAt(pos);
            delete pNew; // delete and release IComponent
        }
        else // child of new node
        {
            if (NULL == pNew->Parent())
                return (sc = E_UNEXPECTED);

            pNew->Parent()->RemoveChild(pNew);
            delete pNew;
        }
    }

    // Remove from manager tree
    pmgNode->m_pmgnParent->RemoveChild(pmgNode);

    CSnapInsCache* pSnapInCache = theApp.GetSnapInsCache();
    sc = ScCheckPointers(pSnapInCache, E_UNEXPECTED);
    if (sc)
        return sc;

    // Snapin removed set help collection invalid.
    pSnapInCache->SetHelpCollectionDirty();

    if (bVisible)
    {
        m_snpListCtrl.DeleteItem(iItem);

        // Remove item and all children from combo box
        COMBOBOXEXITEM ComboItem;
        ComboItem.mask = CBEIF_LPARAM;
        ComboItem.lParam = (LPARAM)pmgNode;
        int iCombo = m_snpComboBox.FindItem(&ComboItem);

        ASSERT(iCombo != -1);
        m_snpComboBox.DeleteBranch(iCombo);
    }

    return (sc);
}


//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnDeleteSnapin
//
// Handle activation of Delete button. Delete all selected snapins.
// item the current parent node.
//----------------------------------------------------------------------------

LRESULT CSnapinStandAlonePage::OnDeleteSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    DECLARE_SC(sc, _T("CSnapinStandAlonePage::OnDeleteSnapin"));

    BOOL bChildren = FALSE;

    // Check if any of the selected node have children
    int iItem = -1;
    while ((iItem = m_snpListCtrl.GetNextItem(iItem, LVNI_SELECTED)) >= 0)
    {
        PMANAGERNODE pmgNode = (PMANAGERNODE)m_snpListCtrl.GetItemData(iItem);
        if (!pmgNode->m_ChildList.IsEmpty())
        {
            bChildren = TRUE;
            break;
        }
    }

    // If so, give user a chance to cancel
    if (bChildren)
    {
        CStr strTitle;
        strTitle.LoadString(GetStringModule(), SNP_DELETE_TITLE);

        CStr strText;
        strText.LoadString(GetStringModule(), SNP_DELETE_TEXT);

        if (MessageBox(strText, strTitle, MB_ICONQUESTION|MB_YESNO) != IDYES)
        {
            return 0;
        }
    }

    // Do for all selected items in listview
    int iLastDelete = -1;
    iItem = -1;
    while ((iItem = m_snpListCtrl.GetNextItem(iItem, LVNI_SELECTED)) >= 0)
    {
        // get manager node from item
        PMANAGERNODE pmgNode = (PMANAGERNODE)m_snpListCtrl.GetItemData(iItem);

        sc = ScRemoveOneSnapin(pmgNode, iItem, true);
        if (sc)
            return 0;

        // destroy the removed node (and its children)
        delete pmgNode;

        iLastDelete = iItem;
        iItem--;
    }

    // if items deleted, set focus near last deleted item
    if (iLastDelete != -1)
    {
        int nCnt = m_snpListCtrl.GetItemCount();
        if (nCnt > 0)
        {
            // if deleted the last item, backup to previous one
            if (iLastDelete >= nCnt)
                iLastDelete = nCnt - 1;

            m_snpListCtrl.SetItemState(iLastDelete, LVIS_FOCUSED, LVIS_FOCUSED);
        }
    }

    SetupChildNode(NULL);

    // Clear description text
    sc = ScSetDescriptionUIText(GetDlgItem(IDC_SNAPIN_DESCR), _T(""));
    if (sc)
        sc.TraceAndClear();

    return 0;
}

//----------------------------------------------------------------------------
// CSnapinStandAlonePage::OnAboutSnapin
//
// Handle activation of About button. Display About dialog for the selected
// child node's snapin.
//----------------------------------------------------------------------------
LRESULT CSnapinStandAlonePage::OnAboutSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (m_pmgnChild && m_pmgnChild->HasAboutInfo())
        m_pmgnChild->GetSnapinInfo()->ShowAboutPages(m_pManager->m_hWnd);

    return 0;
}

//----------------------------------------------------------------------------
// CSnapinStandAlonePage::ScRunSnapinWizard
//
// Run Snapin wizard to create snapin instance and return the IComponentData.
//----------------------------------------------------------------------------
SC CSnapinStandAlonePage::ScRunSnapinWizard (
    const CLSID&        clsid,              /* I:snap-in to create          */
    HWND                hwndParent,         /* I:parent of wizard           */
    Properties*         pInitProps,         /* I:properties to init with    */
    IComponentData*&    rpComponentData,    /* O:snap-in's IComponentData   */
    Properties*&        rpSnapinProps)      /* O:snap-in's properties       */
{
    DECLARE_SC (sc, _T("CSnapinStandAlonePage::ScRunSnapinWizard"));

    rpComponentData = NULL;
    rpSnapinProps   = NULL;

    /*
     * create a new node manager for the snap-in
     */
    IUnknownPtr pIunkNodemgr;
    sc = pIunkNodemgr.CreateInstance(CLSID_NodeInit, NULL, MMC_CLSCTX_INPROC);
    if (sc)
        return (sc);

    if (pIunkNodemgr == NULL)
        return (sc = E_UNEXPECTED);

    /*
     * create the snap-in
     */
    sc = CreateSnapIn(clsid, &rpComponentData, false);
    if (sc)
        return (sc);

    if (rpComponentData == NULL)
        return (sc = E_UNEXPECTED);


    /*-----------------------------------------------------------------
     * From this point on a failure isn't considered catastrophic.  If
     * anything fails, we'll return at that point, but return success.
     */


    /*
     * if we got properties to initialize with, see if the snap-in
     * supports ISnapinProperties
     */
    ISnapinPropertiesPtr spISP;

    if (pInitProps && ((spISP = rpComponentData) != NULL))
    {
        CComObject<CSnapinProperties>* pSnapinProps;
        CComObject<CSnapinProperties>::CreateInstance (&pSnapinProps);

        /*
         * Initialize the snap-in with the initial properties.  If the
         * snap-in fails to initialize, we'll release the CSnapinProperties
         * we created (because the spSnapinProps smart pointer will go out
         * of scope), but we won't return failure.
         */
        if (pSnapinProps != NULL)
        {
            /*
             * add a ref here, if ScInitialize fails, the balancing
             * Release will delete the Properties object
             */
            pSnapinProps->AddRef();

            if (!pSnapinProps->ScInitialize(spISP, pInitProps, NULL).IsError())
            {
                /*        `
                 * If we get here, the snap-in's ISnapinProperties was
                 * initilialized correctly.  Put a ref on for the client.
                 */
                rpSnapinProps = pSnapinProps;
                rpSnapinProps->AddRef();
            }

            /*
             * release the ref we put on above, if ScInitialize failed,
             * this release will delete the Properties
             */
            pSnapinProps->Release();
        }
    }


    /*
     * get the snap-in's data object
     */
    IDataObjectPtr pIDataObject;
    sc = rpComponentData->QueryDataObject(NULL, CCT_SNAPIN_MANAGER, &pIDataObject);
    if (sc.IsError() || (pIDataObject == NULL))
        return (sc);

    IPropertySheetProviderPtr pIPSP = pIunkNodemgr;

    if (pIPSP == NULL)
        return (sc);

    IPropertySheetCallbackPtr pIPSC = pIunkNodemgr;

    if (pIPSC == NULL)
        return (sc);

    // determine which pointer to use
    IExtendPropertySheetPtr     spExtend  = rpComponentData;
    IExtendPropertySheet2Ptr    spExtend2 = rpComponentData;

    IExtendPropertySheet* pIPSE;

    if (spExtend2 != NULL)
        pIPSE = spExtend2;
    else
        pIPSE = spExtend;

    // Snap-in may not have a property sheet to set the properties of the snap-in
    if (pIPSE == NULL)
        return (sc);

    do
    {
        // Create the PropertySheet , FALSE = WIZARD
        sc = pIPSP->CreatePropertySheet( L"", FALSE, NULL, pIDataObject, MMC_PSO_NEWWIZARDTYPE);
        if(sc.ToHr() != S_OK)
            break;

        // Add Primary pages without notify handle
        sc = pIPSP->AddPrimaryPages(rpComponentData, FALSE, NULL, FALSE);

        if (sc.ToHr() == S_OK)
        {
            // Show the property sheet
            sc = pIPSP->Show((LONG_PTR)hwndParent, 0);
            if (sc.ToHr() != S_OK)
                break;
        }
        else
        {
            // force the property sheet to be destroyed
            pIPSP->Show(-1, 0);

            // abort if snapin had a failure
            if (sc)
                break;
        }

        return sc;
    }
    while (0);

    // already checked for NULL above, but repeating the check here
    if(rpComponentData != NULL)
    {
        rpComponentData->Release();
        rpComponentData = NULL;
    }

    return (sc);
}

//############################################################################
//############################################################################
//
//  Implementation of class CSnapinExtensionPage
//
//############################################################################
//############################################################################



//----------------------------------------------------------------------------
// CSnapinExtensionPage::~CSnapinExtensionPage
//
//  Destructor
//----------------------------------------------------------------------------
CSnapinExtensionPage::~CSnapinExtensionPage()
{
    m_ilCheckbox.Destroy();
    m_SnapComboBox.Detach();
    m_ExtListCtrl.Detach();
}


//----------------------------------------------------------------------------
// CSnapinExtensionPage::OnInitDialog
//
//  Initialize the property page controls.
//----------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    // Attach control objects to control windows
    m_SnapComboBox.Attach( ::GetDlgItem(m_hWnd, IDC_SNAPIN_COMBOEX ) );
    m_ExtListCtrl.SubclassWindow( ::GetDlgItem( *this, IDC_EXTENSION_LIST ) );

    // attach shared image list to both listviews
    m_SnapComboBox.SetImageList(m_pManager->m_iml);
    m_ExtListCtrl.SetImageList(m_pManager->m_iml, LVSIL_SMALL);

    // Add single column to list box
    RECT rc;
    m_ExtListCtrl.GetClientRect(&rc);

    LV_COLUMN lvc;
    lvc.mask = LVCF_WIDTH | LVCF_SUBITEM;
    lvc.cx = rc.right - rc.left - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;

    int iCol = m_ExtListCtrl.InsertColumn(0, &lvc);
    ASSERT(iCol == 0);

    // Load checkbox images
    if (m_ilCheckbox.Create(IDB_CHECKBOX, 16, 3, RGB(255,0,255)))
    {
        // Set background color to match list control, so checkboxes aren't drawn transparently
        m_ilCheckbox.SetBkColor(m_ExtListCtrl.GetBkColor());
        m_ExtListCtrl.SetImageList(m_ilCheckbox, LVSIL_STATE);
    }
    else
    {
        ASSERT(FALSE); // Unable to create imagelist
    }

    // Apply workarounds for NT4 comboboxex bugs
    m_SnapComboBox.FixUp();

    // Turn off the scroll bar in description edit box.
	::ShowScrollBar(GetDlgItem(IDC_SNAPIN_DESCR), SB_VERT, FALSE);

    return 0;
}


//--------------------------------------------------------------------------
// CSnapinExtensionPage::OnSetActive
//
// Update the data
//--------------------------------------------------------------------------
BOOL CSnapinExtensionPage::OnSetActive()
{
    BC::OnSetActive();

    BuildSnapinList();

    return TRUE;
}


//-------------------------------------------------------------------------
// CSnapinExtensionPage::OnSnapinDropDown
//
// Called when snapin dropdown is about to be displayed. Rebuilds the list
// if the update flag is set.
//-------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnSnapinDropDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (m_bUpdateSnapinList)
    {
        BuildSnapinList();
    }

    return 0;
}


//--------------------------------------------------------------------------
// CSnapinExtensionPage::OnSnapinSelect
//
// Handle selection of snapin from combobox. Make it the current snapin
// and display its extension list.
//--------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnSnapinSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_SnapComboBox.GetCurSel();
    ASSERT(iItem >= 0);
    if (iItem < 0)
        return 0;

    PSNAPININFO pSnapInfo = reinterpret_cast<PSNAPININFO>(m_SnapComboBox.GetItemDataPtr(iItem));
    ASSERT((LONG_PTR)pSnapInfo != -1);

    m_pCurSnapInfo = pSnapInfo;
    BuildExtensionList(pSnapInfo);

    return 0;
}


//----------------------------------------------------------------------------
// CSnapinExtensionPage::OnAboutSnapin
//
// Handle activation of About button. Display About dialog for the selected
// extension's snapin.
//----------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnAboutSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (m_pExtLink && m_pExtLink->GetSnapinInfo()->HasAbout())
    {
        m_pExtLink->GetSnapinInfo()->ShowAboutPages(m_hWnd);
    }

    return 0;
}

//----------------------------------------------------------------------------
// CSnapinExtensionPage::OnDownloadSnapin
//
// Handle activation of Download button. Download the selected extension
// snapin.
//----------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnDownloadSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    DECLARE_SC(sc, TEXT("CSnapinExtensionPage::OnDownloadSnapin"));

    ASSERT(m_pExtLink && m_pExtLink->GetSnapinInfo());

    // 1. install the component
    sc = m_pExtLink->GetSnapinInfo()->ScInstall(&m_pCurSnapInfo->GetCLSID());
    if(sc)
        return 0;

    // 2. update all the snapin info objects from the registry. This is because installing a
    // single msi package may install several snapins.
    sc = ScCheckPointers(m_pManager, E_UNEXPECTED);
    if(sc)
        return 0;

    sc = m_pManager->ScLoadSnapinInfo();
    if(sc)
        return 0;

    // Better to update the individual extention
    // For now, just rebuild the list
    BuildExtensionList(m_pCurSnapInfo);

    return 0;
}

//----------------------------------------------------------------------------
// CSnapinExtensionPage::BuildSnapinList
//
// Load the combo box with the existing snapins and extensions
//----------------------------------------------------------------------------
void CSnapinExtensionPage::BuildSnapinList()
{
    CSnapinInfoCache* pInfoCache = &m_pManager->m_SnapinInfoCache;

    // Clear the items
    m_SnapComboBox.ResetContent();

    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_LPARAM | CBEIF_IMAGE | CBEIF_TEXT | CBEIF_SELECTEDIMAGE;

    int iCount = 0;

    // Do for all snapinfo objects
    POSITION pos = pInfoCache->GetStartPosition();
    while (pos != NULL)
    {
        USES_CONVERSION;
        GUID clsid;
        PSNAPININFO pSnapInfo;

        pInfoCache->GetNextAssoc(pos, clsid, pSnapInfo);
        ASSERT(pSnapInfo != NULL);

        // Only show snapins that are used and have extensions available
        if (pSnapInfo->IsUsed() && pSnapInfo->IsPermittedByPolicy() &&
            pSnapInfo->GetAvailableExtensions(pInfoCache, m_pManager->m_pMMCPolicy))
        {
            ComboItem.lParam = reinterpret_cast<LPARAM>(pSnapInfo);
            pSnapInfo->LoadImages(m_pManager->m_iml);
            ComboItem.iImage = pSnapInfo->GetImage();
            ComboItem.iSelectedImage = pSnapInfo->GetOpenImage();
            ComboItem.pszText = OLE2T(pSnapInfo->GetSnapinName());

            // CComboBoxEx doesn't support CBS_SORT and has no add method, only insert
            // So we need to find the insertion point ourselves. Because it's a short
            // list, just do a linear search.
            int iInsert;
            for (iInsert = 0; iInsert < iCount; iInsert++)
            {
                PSNAPININFO pSnapEntry = reinterpret_cast<PSNAPININFO>(m_SnapComboBox.GetItemData(iInsert));

				// need to protect ourselves from the invalid snapin registration.
				// see windows bug #401220	( ntbugs9 5/23/2001 )
				if ( NULL == pSnapInfo->GetSnapinName() || NULL == pSnapEntry->GetSnapinName() )
					break;

                if( wcscmp( pSnapInfo->GetSnapinName(), pSnapEntry->GetSnapinName() ) < 0)
                    break;
            }
            ComboItem.iItem = iInsert;

            int iItem = m_SnapComboBox.InsertItem(&ComboItem);
            if (iItem != -1)
            {
                iCount++;
            }
            else
            {
                ASSERT(FALSE);
            }
        }
    }


    int iSelect = -1;

    // if any items in list
    if (iCount > 0)
    {
        // try to get index of previously selected snapin
        if (m_pCurSnapInfo) {
            for (int iFind = 0; iFind < iCount; iFind++)
            {
                if (m_SnapComboBox.GetItemData(iFind) == reinterpret_cast<LPARAM>(m_pCurSnapInfo))
                    iSelect = iFind;
            }
        }

        // if not in list any more, select first item by default
        if (iSelect == -1)
        {
            m_pCurSnapInfo = reinterpret_cast<PSNAPININFO>(m_SnapComboBox.GetItemData(0));
            iSelect = 0;
        }

        m_SnapComboBox.SetCurSel(iSelect);
        m_SnapComboBox.EnableWindow(TRUE);
    }
    else
    {
        // NT 4.0 comctl32 has a bug that displays garbage characters in an empty
        // comboboxex control, so create a phoney item with an blank name.
        // The control is disabled, so the user can't select the item.

        ComboItem.mask = CBEIF_TEXT;
        ComboItem.pszText = _T("");
        ComboItem.iItem = 0;
        m_SnapComboBox.InsertItem(&ComboItem);
        m_SnapComboBox.SetCurSel(0);

        m_pCurSnapInfo = NULL;
        m_SnapComboBox.EnableWindow(FALSE);
    }

    ::EnableWindow(GetDlgItem(IDC_SNAPIN_LABEL), (iCount > 0));

    BuildExtensionList(m_pCurSnapInfo);

    // reset update flag
    m_bUpdateSnapinList = FALSE;
}


//----------------------------------------------------------------------------
// CSnapinExtensionPage::BuildExtensionList
//
// Load list control with available extensions for a snapin.
//----------------------------------------------------------------------------
void CSnapinExtensionPage::BuildExtensionList(PSNAPININFO pSnapInfo)
{
    // Clear the list
    m_ExtListCtrl.DeleteAllItems();

    if (pSnapInfo != NULL)
    {
        LV_ITEM LVItem;
        LVItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE | LVIF_STATE;
        LVItem.stateMask =  LVIS_STATEIMAGEMASK;
        LVItem.iItem = 0;
        LVItem.iSubItem = 0;

        CStr strNotInst;

        // Do for all extensions
        PEXTENSIONLINK pExt = pSnapInfo->GetExtensions();
        while (pExt != NULL)
        {
            PSNAPININFO pExtInfo = pExt->GetSnapinInfo();

            // if permitted by policy
            if (pExtInfo->IsPermittedByPolicy())
            {
                LVItem.lParam = reinterpret_cast<LPARAM>(pExt);
                pExtInfo->LoadImages(m_pManager->m_iml);
                LVItem.iImage = pExtInfo->GetImage();

                USES_CONVERSION;
                CStr strName = OLE2T(pExtInfo->GetSnapinName());

                if (!pExtInfo->IsInstalled())
                {
                    if (strNotInst.IsEmpty())
                        strNotInst.LoadString(GetStringModule(), IDS_NOT_INSTALLED);

                    strName += _T(" ");
                    strName += strNotInst;
                }

                LVItem.pszText = const_cast<LPTSTR>((LPCTSTR)strName);

                // Due to a bug in the ListView code, the checkbox state must be off
                // for insertions to prevent an OFF transition notification
                LVItem.state = CCheckList::CHECKOFF_STATE;

                int iIndex = m_ExtListCtrl.InsertItem(&LVItem);
                ASSERT (iIndex != -1);

                if (iIndex >= 0)
                {
                    // Set checkbox if extension is ON
                    if (pExt->GetState() == CExtensionLink::EXTEN_ON)
                    {
                        // Disable checkbox if it is required by snap-in
                        // or is not installed or all extensiosn are enabled
                        m_ExtListCtrl.SetItemCheck(iIndex, TRUE,
                                    !( pExt->IsRequired() || !pExtInfo->IsInstalled() ||
                                       pSnapInfo->AreAllExtensionsEnabled()) );
                    }
                    else
                    {
                        // if extension is not installed, then disable it
                        if (!pExtInfo->IsInstalled())
                            m_ExtListCtrl.SetItemCheck(iIndex, FALSE, FALSE);
                    }

                    LVItem.iItem++;
                }
            }

            pExt = pExt->Next();
        }

        // Set focus to the first item
        m_ExtListCtrl.SetItemState(0, LVIS_FOCUSED, LVIS_FOCUSED);

        // Provide name of current snapin to Visual Test (it can't get it from a ComboBoxEx)
        USES_CONVERSION;
        ::SetWindowText( GetDlgItem(IDC_VTHELPER), OLE2CT(pSnapInfo->GetSnapinName()) );
    }

    // Set state of "Enable All" checkbox for this snap-in
    BOOL bState = pSnapInfo && pSnapInfo->AreAllExtensionsEnabled();
    ::SendMessage(GetDlgItem(IDC_SNAPIN_ENABLEALL), BM_SETCHECK, (WPARAM)bState, 0);

    // Enable "Enable All" checkbox if it isn't controled by the snap-in
    BOOL bEnable = pSnapInfo &&
                    !(pSnapInfo->GetSnapIn() && pSnapInfo->GetSnapIn()->DoesSnapInEnableAll());
    ::EnableWindow(GetDlgItem(IDC_SNAPIN_ENABLEALL), bEnable);

    // Enable window if extendable snapin selected
    bEnable = pSnapInfo && pSnapInfo->GetExtensions();

    m_ExtListCtrl.EnableWindow(bEnable);
    ::EnableWindow(GetDlgItem(IDC_EXTENSION_LABEL),    bEnable);
    ::EnableWindow(GetDlgItem(IDC_SNAPIN_DESCR_LABEL), bEnable);
    ::EnableWindow(GetDlgItem(IDC_SNAPIN_DESCR),       bEnable);

    // disable "About" and "Download" until extension is selected
    EnableButton(m_hWnd, IDC_SNAPIN_ABOUT, FALSE);
    EnableButton(m_hWnd, IDC_SNAPIN_DOWNLOAD, FALSE);

    // Clear the description text
    SC sc = ScSetDescriptionUIText(GetDlgItem(IDC_SNAPIN_DESCR), _T(""));
    if (sc)
        sc.TraceAndClear();
}


//----------------------------------------------------------------------------
// CSnapinExtensionPage::OnEnableAllChange
//
// Handle change to "enable all extensions" checkbox
//----------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnEnableAllChanged( WORD wNotifyCode, WORD wID, HWND hWndCtrl, BOOL& bHandled )
{
    if (m_pCurSnapInfo)
    {
        m_pCurSnapInfo->SetEnableAllExtensions(!m_pCurSnapInfo->AreAllExtensionsEnabled());

        // if enabling all extensions, turn on all installed extensions
        if (m_pCurSnapInfo->AreAllExtensionsEnabled())
        {
            PEXTENSIONLINK pExt = m_pCurSnapInfo->GetExtensions();
            while (pExt != NULL)
            {
                if (pExt->GetSnapinInfo()->IsInstalled())
                    pExt->SetState(CExtensionLink::EXTEN_ON);

                pExt = pExt->Next();
            }
        }

        BuildExtensionList(m_pCurSnapInfo);
    }

    return 0;
}


//----------------------------------------------------------------------------
// CSnapinExtensionPage::OnExtensionChange
//
// Handle change to extension item
//----------------------------------------------------------------------------
LRESULT CSnapinExtensionPage::OnExtensionChanged( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pnmh;
    PEXTENSIONLINK pExt = (PEXTENSIONLINK)pNMListView->lParam;
    ASSERT(pExt != NULL);

    // if selection state change
    if ( (pNMListView->uOldState ^ pNMListView->uNewState) & LVIS_SELECTED)
    {
        LPOLESTR lpsz = NULL;

        // if selected
        if (pNMListView->uNewState & LVIS_SELECTED)
        {
            // Get description text if any
            if (pExt->GetSnapinInfo())
            {
                pExt->GetSnapinInfo()->LoadAboutInfo();
                lpsz = pExt->GetSnapinInfo()->GetDescription();
            }

            // Save current selection
            m_pExtLink = pExt;
        }
        else
        {
            m_pExtLink = NULL;
        }

        // Update description field
        USES_CONVERSION;
        SC sc = ScSetDescriptionUIText(GetDlgItem(IDC_SNAPIN_DESCR), lpsz ? OLE2T(lpsz) : _T(""));
        if (sc)
            sc.TraceAndClear();
    }

    // if image state change
    if ((pNMListView->uOldState ^ pNMListView->uNewState) & LVIS_STATEIMAGEMASK)
    {
        // Set extension state based on check state
        if ((pNMListView->uNewState & LVIS_STATEIMAGEMASK) == CCheckList::CHECKON_STATE)
        {
            pExt->SetState(CExtensionLink::EXTEN_ON);
        }
        else if ((pNMListView->uNewState & LVIS_STATEIMAGEMASK) == CCheckList::CHECKOFF_STATE)
        {
            pExt->SetState(CExtensionLink::EXTEN_OFF);
        }

        // Trigger rebuild of extendable snapins
        m_bUpdateSnapinList = TRUE;
    }

    // Enable/disable About button
    EnableButton(m_hWnd, IDC_SNAPIN_ABOUT, (m_pExtLink && m_pExtLink->GetSnapinInfo()->HasAbout()));

    // Enable/disable Download button
    EnableButton(m_hWnd, IDC_SNAPIN_DOWNLOAD, (m_pExtLink && !m_pExtLink->GetSnapinInfo()->IsInstalled()));

    return 0;
}


//############################################################################
//############################################################################
//
//  Implementation of class CSnapinManagerAdd
//
//############################################################################
//############################################################################

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapinManagerAdd);


//----------------------------------------------------------------------------
// CSnapinManagerAdd::CSnapinManagerAdd
//
// Constructor
//----------------------------------------------------------------------------
CSnapinManagerAdd::CSnapinManagerAdd(CSnapinManager* pManager, CSnapinStandAlonePage* pStandAlonePage)
{
    ASSERT(pManager != NULL);

    m_pListCtrl = NULL;
    m_pManager = pManager;
    m_pStandAlonePage = pStandAlonePage;

    m_pInfoSelected = NULL;
    m_bDoOnce = TRUE;

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinManagerAdd);
}


//----------------------------------------------------------------------------
// CSnapinManagerAdd::CSnapinManagerAdd
//
// Destructor
//----------------------------------------------------------------------------
CSnapinManagerAdd::~CSnapinManagerAdd()
{
    delete m_pListCtrl;

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinManagerAdd);
}


//----------------------------------------------------------------------------
// CSnapinManagerAdd::OnInitDialog
//
// Initialize the listview control. Load it with the available snapins.
//----------------------------------------------------------------------------
LRESULT CSnapinManagerAdd::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Move the dialog a single pixel. This disables the default centering
    // so that the coordinates specified in the dialog resource are used.
    RECT rc;
    GetWindowRect(&rc);
    ::OffsetRect(&rc, 1, 1);
    MoveWindow(&rc);

    InitCommonControls();

    m_pListCtrl = new WTL::CListViewCtrl;
    ASSERT(m_pListCtrl != NULL);
	// check the pointer before using it
	// prefix bug #294766 ntbug9 6/27/01
	if ( m_pListCtrl == NULL )
	{
		// get out as quickly as you can
		EndDialog(IDCANCEL);
		return TRUE;
	}

    // Attach list control to member object
    m_pListCtrl->Attach( ::GetDlgItem( m_hWnd, IDC_SNAPIN_LV ) );

    // Attach shared imagelist to it
    m_pListCtrl->SetImageList( m_pManager->m_iml, LVSIL_SMALL );

    // Setup Snap-in and Vendor columns
    m_pListCtrl->GetClientRect(&rc);

    // Adjust width if there will be a vertical scrollbar
    if (m_pListCtrl->GetCountPerPage() < m_pManager->m_SnapinInfoCache.GetCount())
        rc.right -= GetSystemMetrics(SM_CXVSCROLL);

    LV_COLUMN lvc;
    lvc.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    CStr temp;
    temp.LoadString(GetStringModule(), IDS_SNAPINSTR);
    lvc.pszText = const_cast<LPTSTR>((LPCTSTR)temp);

    lvc.cx = (rc.right*3)/5;
    lvc.iSubItem = 0;

    int iCol = m_pListCtrl->InsertColumn(0, &lvc);
    ASSERT(iCol == 0);

    temp.LoadString(GetStringModule(), IDS_VENDOR);
    lvc.pszText = const_cast<LPTSTR>((LPCTSTR)temp);

    lvc.cx = rc.right - lvc.cx;
    lvc.iSubItem = 1;

    iCol = m_pListCtrl->InsertColumn(1, &lvc);
    ASSERT(iCol == 1);

    m_iGetInfoIndex = -1;

    // Load snapin items
    BuildSnapinList();

    // Turn off the scroll bar in description edit box.
	::ShowScrollBar(GetDlgItem(IDC_SNAPIN_DESCR), SB_VERT, FALSE);

    return TRUE;
}

//----------------------------------------------------------------------------
// CSnapinManagerAdd::BuildSnapinList
//
// Add item to listview for each standalone snapin in the snapin info cache.
//----------------------------------------------------------------------------
void CSnapinManagerAdd::BuildSnapinList()
{
    USES_CONVERSION;
    CSnapinInfoCache* pCache = &m_pManager->m_SnapinInfoCache;

    LV_ITEM LVItem;
    LVItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    LVItem.iItem = 0;
    LVItem.iSubItem = 0;

    POSITION pos = pCache->GetStartPosition();
    while (pos != NULL)
    {
        GUID clsid;
        PSNAPININFO pSnapInfo;

        pCache->GetNextAssoc(pos, clsid, pSnapInfo);
        ASSERT(pSnapInfo != NULL);

        if (pSnapInfo->IsStandAlone() && pSnapInfo->IsPermittedByPolicy())
        {
            // Set image to callback to defer costly image access from ISnapinHelp object.
            LVItem.iImage = I_IMAGECALLBACK ;
            LVItem.pszText = OLE2T( pSnapInfo->GetSnapinName() );
            LVItem.lParam = reinterpret_cast<LPARAM>(pSnapInfo);

            int iIndex = m_pListCtrl->InsertItem(&LVItem);
            ASSERT(iIndex != -1);

            LVItem.iItem++;
        }
    }

    // LV_Item for setting vendor column
    LV_ITEM LVItem2;
    LVItem2.mask = LVIF_TEXT;
    LVItem2.iSubItem = 1;
    LVItem2.pszText = _T("");

    // select the first item
    LVItem.mask = LVIF_STATE;
    LVItem.state = LVIS_SELECTED|LVIS_FOCUSED;
    LVItem.stateMask = LVIS_SELECTED|LVIS_FOCUSED;
    LVItem.iItem = 0;
    m_pListCtrl->SetItem(&LVItem);

    // Post a NULL completion msg to kick off info collection
    PostMessage(MSG_LOADABOUT_COMPLETE, 0, 0);
}


//--------------------------------------------------------------------------
// CSnapinManagerAdd::OnShowWindow
//
// First time dialog is shown, position it offset from its parent
//--------------------------------------------------------------------------
LRESULT CSnapinManagerAdd::OnShowWindow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    BOOL bShow = (BOOL) wParam;
    int nStatus = (int) lParam;

    ::ShowWindow(m_hWnd, bShow);

    // Repos window below of Snapin Manager window
    if (bShow == TRUE && m_bDoOnce == FALSE)
    {
        RECT rc;
        GetWindowRect(&rc);
        ::SetWindowPos(m_hWnd, HWND_TOP, rc.left+14, rc.top+21, 0, 0, SWP_NOSIZE|SWP_NOZORDER);
        m_bDoOnce=FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------------------
// CSnapinManagerAdd::OnGetDispInfo
//
// Handle deferred loading of item image and vendor information
//--------------------------------------------------------------------------
LRESULT CSnapinManagerAdd::OnGetDispInfo(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    NMLVDISPINFO* pNMDispInfo = (NMLVDISPINFO*)pNMHDR;

    PSNAPININFO pSnapInfo = reinterpret_cast<PSNAPININFO>(pNMDispInfo->item.lParam);

    switch (pNMDispInfo->item.iSubItem)
    {
    case 0:
        // Should only request image for primary item
        ASSERT(pNMDispInfo->item.mask == LVIF_IMAGE);

        // if don't have images yet
        if (pSnapInfo->GetImage() == -1)
        {
            // if snapin supports about
            if (pSnapInfo->HasAbout())
            {
                // use folder for now, background thread will get the image
                pNMDispInfo->item.iImage = eStockImage_Folder;
            }
            else
            {
                // Load images now (will get from MSI database)
                pSnapInfo->LoadImages(m_pManager->m_iml);
                pNMDispInfo->item.iImage = pSnapInfo->GetImage();
            }
        }
        else
        {
           pNMDispInfo->item.iImage = pSnapInfo->GetImage();
        }
        break;

    case 1:
        {
            // Should only request text for sub item
            ASSERT(pNMDispInfo->item.mask == LVIF_TEXT);
            ASSERT(pNMDispInfo->item.pszText != NULL);

            USES_CONVERSION;

            if (pSnapInfo->IsInstalled())
            {
                if (pSnapInfo->GetCompanyName() != NULL)
                {
                    lstrcpyn(pNMDispInfo->item.pszText, OLE2T(pSnapInfo->GetCompanyName()), pNMDispInfo->item.cchTextMax);
                }
                else
                {
                   pNMDispInfo->item.pszText[0] = 0;
                }
            }
            else
            {
                // if snap-in is not installed, display "Not Installed in vendor column
                if (m_strNotInstalled.IsEmpty())
                    m_strNotInstalled.LoadString(GetStringModule(), IDS_NOT_INSTALLED2);

                lstrcpyn(pNMDispInfo->item.pszText, m_strNotInstalled, pNMDispInfo->item.cchTextMax);

            }
            break;
        }

    default:
        ASSERT(FALSE);
        return 0;
    }

    bHandled = TRUE;

    return 0;
}

LRESULT CSnapinManagerAdd::OnLoadAboutComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // If real request just completed, do completion processing
    if (wParam != 0)
    {
        PSNAPININFO pSnapInfo = reinterpret_cast<PSNAPININFO>(wParam);

        // If About object exists but didn't provide a ISnapinAbout interface
        // it probably didn't register a threading model so can't be created on
        // a secondary thread. Give it another try on the main thread.
        if (pSnapInfo->GetObjectStatus() == E_NOINTERFACE)
        {
            // Reset error state first or LoadAboutInfo() won't try again
            pSnapInfo->ResetAboutInfo();
            pSnapInfo->LoadAboutInfo();
        }

        // Locate snapin item in list
        LV_FINDINFO find;
        find.flags = LVFI_PARAM;
        find.lParam = wParam;

        int iIndex = m_pListCtrl->FindItem(&find, -1);
        ASSERT(iIndex >= 0);

        // Force update of list item
        pSnapInfo->LoadImages(m_pManager->m_iml);
        m_pListCtrl->Update(iIndex);

        // If item is currently selected
        if (pSnapInfo == m_pInfoSelected)
        {
            // Update the description field
            USES_CONVERSION;
            LPOLESTR lpsz = m_pInfoSelected->GetDescription();

            SC sc = ScSetDescriptionUIText(::GetDlgItem(m_hWnd, IDC_SNAPIN_DESCR), lpsz ? OLE2T(lpsz) : _T(""));
            if (sc)
                sc.TraceAndClear();
        }
    }

    PSNAPININFO pInfoNext = NULL;

    // If selected item doesn't have info, it has first priority
    if (m_pInfoSelected != NULL && m_pInfoSelected->HasAbout() && !m_pInfoSelected->HasInformation())
    {
        pInfoNext = m_pInfoSelected;
    }
    else
    {
        // Else starting with first visible item find snapin that needs info
        int iVisible = m_pListCtrl->GetTopIndex();
        int iItemMax = min(m_pListCtrl->GetItemCount(), iVisible + m_pListCtrl->GetCountPerPage());

        for (int i=0; i<iItemMax; i++)
        {
            LPARAM lParam = m_pListCtrl->GetItemData(i);
            PSNAPININFO pSnapInfo = reinterpret_cast<PSNAPININFO>(lParam);

            if (pSnapInfo->HasAbout() && !pSnapInfo->HasInformation())
            {
                pInfoNext = pSnapInfo;
                break;
            }
        }
    }

    // If all visible items handled, continue through the full list
    if (pInfoNext == NULL)
    {
        // Locate next snap-in
        int iCnt = m_pListCtrl->GetItemCount();
        while (++m_iGetInfoIndex < iCnt)
        {
            LPARAM lParam = m_pListCtrl->GetItemData(m_iGetInfoIndex);
            PSNAPININFO pSnapInfo = reinterpret_cast<PSNAPININFO>(lParam);

            if (pSnapInfo->HasAbout() && !pSnapInfo->HasInformation())
            {
                pInfoNext = pSnapInfo;
                break;
            }
        }
    }

    // if item found, post the info request
    if (pInfoNext != NULL)
        m_pManager->m_AboutInfoThread.PostRequest(pInfoNext, m_hWnd);

    bHandled = TRUE;
    return 0;
}


//--------------------------------------------------------------------------
// CSnapinManagerAdd::OnItemChanged
//
// Handle selection of listview item. Display description text for item.
//--------------------------------------------------------------------------

LRESULT CSnapinManagerAdd::OnItemChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    LPOLESTR lpsz = NULL;

    // if select change
    if ((pNMListView->uOldState ^ pNMListView->uNewState) & LVIS_SELECTED)
    {
        if (pNMListView->uNewState & LVIS_SELECTED)
        {

            m_pInfoSelected = reinterpret_cast<PSNAPININFO>(pNMListView->lParam);

            // get description text from snapin info
            if (m_pInfoSelected->HasInformation() || !m_pInfoSelected->HasAbout())
                lpsz = m_pInfoSelected->GetDescription();
        }
        else
        {
            m_pInfoSelected = NULL;
        }

        // display description
        USES_CONVERSION;
        SC sc = ScSetDescriptionUIText(::GetDlgItem(m_hWnd, IDC_SNAPIN_DESCR), lpsz ? OLE2T(lpsz) : _T(""));
        if (sc)
            sc.TraceAndClear();
     }

    return TRUE;
}


//--------------------------------------------------------------------------
// CSnapinManagerAdd::OnListDblClick
//
// Handle double click in listview. If item selected, do OK processing.
//--------------------------------------------------------------------------
LRESULT CSnapinManagerAdd::OnListDblClick(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{

    // Get mouse position in screen co-ord
    POINT pt;
    DWORD dwPos=GetMessagePos();
    pt.x=LOWORD(dwPos);
    pt.y=HIWORD(dwPos);

    // Find position in result control
    m_pListCtrl->ScreenToClient(&pt);

    // Check for tree object hit
    UINT fHit;
    int iItem = m_pListCtrl->HitTest(pt, &fHit);

    if (iItem!=-1)
    {
        HRESULT hr = m_pStandAlonePage->AddOneSnapin(m_pInfoSelected);
    }


    return TRUE;
}


LRESULT CSnapinManagerAdd::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    WORD wID = LOWORD(wParam);

    switch (wID)
    {
    case IDOK:
        m_pStandAlonePage->AddOneSnapin(m_pInfoSelected);
        break;

    case IDCANCEL:
        EndDialog(wID);
        break;

    default:
        bHandled=FALSE;
    }

    return TRUE;
}


LRESULT CSnapinManagerAdd::OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (wParam == SC_CLOSE)
        EndDialog(IDCANCEL);
    else
        bHandled=FALSE;

    return TRUE;
}


//--------------------------------------------------------------------------
// EnableButton
//
// Enables or disables a dialog control. If the control has the focus when
// it is disabled, the focus is moved to the next control
//--------------------------------------------------------------------------
void EnableButton(HWND hwndDialog, int iCtrlID, BOOL bEnable)
{
    HWND hWndCtrl = ::GetDlgItem(hwndDialog, iCtrlID);
    ASSERT(::IsWindow(hWndCtrl));

    if (!bEnable && ::GetFocus() == hWndCtrl)
    {
        HWND hWndNextCtrl = ::GetNextDlgTabItem(hwndDialog, hWndCtrl, FALSE);
        if (hWndNextCtrl != NULL && hWndNextCtrl != hWndCtrl)
        {
            ::SetFocus(hWndNextCtrl);
        }
    }

    ::EnableWindow(hWndCtrl, bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\locparser\locstudiosdk\inc\pbase\updatelog.h ===
//-----------------------------------------------------------------------------
//  
//  File: updatelog.h
//  Copyright (C) 1994-1997 Microsoft Corporation
//  All rights reserved.
//  
//  
//  
//-----------------------------------------------------------------------------
 
#ifndef PBASE_UPDATELOG_H
#define PBASE_UPDATELOG_H


extern const IID IID_ILocUpdateLog;

DECLARE_INTERFACE_(ILocUpdateLog, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(BOOL, ReportItemDifferences)
		(THIS_ const CLocItem *pOldItem, const CLocItem *pNewItem,
				CItemInfo *, CLogFile *) PURE;
};


struct __declspec(uuid("{6005AF23-EE76-11d0-A599-00C04FC2C6D8}")) ILocUpdateLog;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\ccomboex.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ccomboex.cpp
//
//--------------------------------------------------------------------------

// CComboex.cpp

#include "stdafx.h"
#include "ccomboex.h"

BOOL CComboBoxEx2::FindItem(COMBOBOXEXITEM* pComboItem, int nStart)
{
    ASSERT(pComboItem != NULL);
    ASSERT(nStart >= -1);

    // Only suport lparam search for now
    ASSERT(pComboItem->mask == CBEIF_LPARAM);

    int nItems = GetCount();

    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_LPARAM;

    for (int iItem = nStart+1; iItem < nItems; iItem++)
    {
        ComboItem.iItem = iItem;
        BOOL bStat = GetItem(&ComboItem);
        ASSERT(bStat);

        if (ComboItem.lParam == pComboItem->lParam)
            return iItem;
    }
        
    return -1;
}

//+-------------------------------------------------------
//
// FindNextBranch(iItem)
//
// This function returns the index of the next item which
// is not within the branch rooted at iItem. If no next
// branch is found, the fucntion returns the item count. 
//+------------------------------------------------------- 
 
int CComboBoxEx2::FindNextBranch(int iItem)
{
    int nItems = GetCount();
    ASSERT(iItem >= 0 && iItem < nItems);

    COMBOBOXEXITEM ComboItem;
    ComboItem.mask = CBEIF_INDENT;

    // Get indent of start item
    ComboItem.iItem = iItem;
    BOOL bStat = GetItem(&ComboItem);
    ASSERT(bStat);
    int iIndent = ComboItem.iIndent;

    // Locate next item with LE indent  
    while (++iItem < nItems)
    {
        ComboItem.iItem = iItem;
        BOOL bStat = GetItem(&ComboItem);
        ASSERT(bStat);

        if (ComboItem.iIndent <= iIndent)
            return iItem;
    }

    return nItems;
}


//+------------------------------------------------------
//
// DeleteBranch
//
// This function deletes the item as the specified index
// and all children of the item.
//+------------------------------------------------------
void CComboBoxEx2::DeleteBranch(int iItem)
{
    int iNextBranch = FindNextBranch(iItem);

    for (int i=iItem; i< iNextBranch; i++)
    {
        DeleteItem(iItem);
    }
}

//+------------------------------------------------------
//
// FixUp
//
// This function is a workaround for two bugs in the NT4
// version of comctl32.dll. First it turns off the 
// nointegralheight style of the inner combo box, which
// the comboxex code forces on during creation. Next it
// adjusts the size of the outer comboboxex wnd to be the 
// same size as the inner combobox wnd. Without this the 
// outer box cuts off the bottom of the inner box. 
//+------------------------------------------------------

void CComboBoxEx2::FixUp()
{
    ASSERT(::IsWindow(m_hWnd));

    HWND hWndCombo = GetComboControl();
    ASSERT(::IsWindow(hWndCombo));

    ::SetWindowLong( hWndCombo, GWL_STYLE, ::GetWindowLong( hWndCombo, GWL_STYLE ) & ~CBS_NOINTEGRALHEIGHT );

    RECT rc;
    ::GetWindowRect(hWndCombo,&rc);
    SetWindowPos(NULL, 0, 0, rc.right - rc.left, rc.bottom - rc.top, SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOREPOSITION|SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\ccomboex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ccomboex.h
//
//--------------------------------------------------------------------------

// ccomboex.h - Class wrapper for ComboBoxEx control


#ifndef _CCOMBOEX_H_
#define _CCOMBOEX_H_

class CComboBoxEx2 : public WTL::CComboBox
{
public:

    WTL::CImageList SetImageList ( WTL::CImageList ImageList );

    int InsertItem ( COMBOBOXEXITEM* pItem );

    int DeleteItem ( int iItem ); 

    BOOL GetItem ( COMBOBOXEXITEM* pItem );

    int FindItem ( COMBOBOXEXITEM* pItem, int nStart = -1 );

    int FindNextBranch ( int iItem );

    void DeleteBranch ( int iItem );

    HWND GetComboControl( void );

    void FixUp( void );
};

                    
inline WTL::CImageList CComboBoxEx2::SetImageList( WTL::CImageList ImageList)
{
    ASSERT(::IsWindow(m_hWnd));
     
    HIMAGELIST himlOld = (HIMAGELIST) SendMessage(CBEM_SETIMAGELIST, 0, (LPARAM)(ImageList.m_hImageList));
    return (WTL::CImageList (himlOld));
}


inline int CComboBoxEx2::InsertItem(COMBOBOXEXITEM* pItem)
{
    ASSERT(::IsWindow(m_hWnd));
    ASSERT(pItem != NULL);
     
    return SendMessage(CBEM_INSERTITEM, (WPARAM)0, (LPARAM)pItem); 
}

inline int CComboBoxEx2::DeleteItem(int iItem)
{
    ASSERT(::IsWindow(m_hWnd));
    return SendMessage(CBEM_DELETEITEM, (WPARAM)iItem, (LPARAM)0);
}

inline BOOL CComboBoxEx2::GetItem(COMBOBOXEXITEM* pItem)
{
    ASSERT(::IsWindow(m_hWnd));
    ASSERT(pItem != NULL);
     
    return SendMessage(CBEM_GETITEM, (WPARAM)0, (LPARAM)pItem); 
}

inline HWND CComboBoxEx2::GetComboControl(void)
{
    ASSERT(::IsWindow(m_hWnd));
    return (HWND)SendMessage(CBEM_GETCOMBOCONTROL, (WPARAM)0, (LPARAM)0);
}
 
#endif // _CCOMBOEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\about.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       about.h
//
//--------------------------------------------------------------------------

#ifndef _ABOUT_H
#define _ABOUT_H

#include "util.h"

class CSnapinAbout;

SC ScSetDescriptionUIText(HWND hwndSnapinDescEdit, LPCTSTR lpszDescription);

/////////////////////////////////////////////////////////////////////////////
// CSnapinAboutDialog

class CSnapinAboutDialog : public CDialogImpl<CSnapinAboutDialog>
{
	typedef CSnapinAboutDialog               ThisClass;
    typedef CDialogImpl<CSnapinAboutDialog>  BaseClass;
public:
    enum { IDD = IDD_SNAPIN_ABOUT };

    CSnapinAboutDialog(CSnapinAbout *pSnapinAbout) : m_pAboutInfo(pSnapinAbout) {}

    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER    (WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER (IDOK,          OnOK)
        COMMAND_ID_HANDLER (IDCANCEL,      OnCancel)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK        (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel    (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
    CSnapinAbout*   m_pAboutInfo;

    WTL::CStatic    m_hIcon;
	WTL::CEdit      m_SnapinInfo;
	WTL::CEdit      m_SnapinDesc;
};

class CSnapinAbout
{
	// smart handle for icons
	class CIcon
	{
	public:
		CIcon() : m_hIcon(NULL) {}
		~CIcon() { DeleteObject(); }
	
		void Attach(HICON hIcon) { DeleteObject(); m_hIcon = hIcon; }
		operator HICON() { return m_hIcon; }
	
		void DeleteObject() { if (m_hIcon != NULL) ::DestroyIcon(m_hIcon); m_hIcon = NULL; }
	
	private:
		HICON m_hIcon;
	};
	
	// smart pointer for CoTaskMem allocated OLESTR
	typedef CCoTaskMemPtr<OLECHAR> CCtmOleStrPtr;

// Constructor/Destructor
public:
    CSnapinAbout();

// Interfaces
public:
    void    ShowAboutBox();
    BOOL    GetBasicInformation(CLSID& clsid)
                { return GetInformation(clsid, BASIC_INFO); }
    BOOL    GetSnapinInformation(CLSID& clsid)
                { return GetInformation(clsid, FULL_INFO); }
    BOOL    HasBasicInformation() {return m_bBasicInfo;}
    BOOL    HasInformation() {return m_bFullInfo;}
    void    GetSmallImages(HBITMAP* hImage, HBITMAP* hImageOpen, COLORREF* cMask)
            {
                *hImage     = m_SmallImage;
                *hImageOpen = m_SmallImageOpen;
                *cMask      = m_cMask;
            }

    void    GetLargeImage(HBITMAP* hImage, COLORREF* cMask)
            {
                *hImage = m_LargeImage;
                *cMask  = m_cMask;
            }

    const LPOLESTR  GetCompanyName() {return m_lpszCompanyName;};
    const LPOLESTR  GetDescription() {return m_lpszDescription;};
    const LPOLESTR  GetVersion() {return m_lpszVersion;};
    const LPOLESTR  GetSnapinName() {return m_lpszSnapinName;};
    const HICON     GetSnapinIcon() { return m_AppIcon; }
    const HRESULT   GetObjectStatus() { return m_hrObjectStatus; }

public: // Not published by about object, name derived from console
    void SetSnapinName(LPCOLESTR lpszName)
        {
            ASSERT(lpszName != NULL);
            m_lpszSnapinName.Delete(); // delete any existing name
            m_lpszSnapinName.Attach(CoTaskDupString(lpszName));
        }

private:
    void CommonContruct();

    enum INFORMATION_TYPE
    {
        BASIC_INFO,
        FULL_INFO
    };
    BOOL GetInformation(CLSID& clsid, int nType);

// Attributes
private:
    BOOL            m_bBasicInfo;       // TRUE if basic info is loaded
    BOOL            m_bFullInfo;        // TRUE if all snapin info is loaded

    CCtmOleStrPtr   m_lpszSnapinName;   // Snap-in name Note: this is not exposed by the snap-in.
    CCtmOleStrPtr   m_lpszCompanyName;  // Company Name (Provider)
    CCtmOleStrPtr   m_lpszDescription;  // Description box text
    CCtmOleStrPtr   m_lpszVersion;      // Version string

    CIcon           m_AppIcon;          // Property page icon
    WTL::CBitmap    m_SmallImage;       // Small image for scope and result pane
	WTL::CBitmap    m_SmallImageOpen;   // Open image for scope pane.
	WTL::CBitmap    m_LargeImage;       // Large image for result pane
    COLORREF        m_cMask;
    HRESULT         m_hrObjectStatus;     // Result from object creation
};

#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\addsnpin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       addsnpin.h
//
//--------------------------------------------------------------------------

// AddSnpIn.h : header file
//

/*
 * CSnapinInfo:
 *    This object represents a snapin entry in the registry. So if same snapin
 *    is added several times to a console they will all refer to same instance
 *    of this object. This object has a linked list of extensions.
 *
 * CExtensionLink:
 *    This object represents an extension snapin. So if an extension extends
 *    two different snapins then there are two instances of this object for
 *    each extension. Each CExtensionLink refers to underlying snapin through
 *    CSnapinInfo. So for the two extensions there will be two CExtensionLink
 *    objects but only one CSnapinInfo object.
 *
 * CSnapinManager:
 *    Has a SnapinInfoCache, standalone & extension pages, policy objects.
 *    It can initialize by populating snapininfo cache, loading mtnode tree
 *    And update the snapin-info cache if there are any changes.
 *
 */

/////////////////////////////////////////////////////////////////////////////
// CSnapinManager dialog

#ifndef __ADDSNPIN_H__
#define __ADDSNPIN_H__

#include "dlgs.h"


#include "ccomboex.h"
#include "regutil.h"  // need HashKey(GUID&) function
#include "about.h"

#define BMP_EXTENSION   0
#define BMP_DIRECTORY   0

#define ADDSNP_ROOTFOLDER   1
#define ADDSNP_SNAPIN       2
#define ADDSNP_EXTENSIONUI  3
#define ADDSNP_EXTENSION    4
#define ADDSNP_STATICNODE   5

#define MSG_LOADABOUT_REQUEST (WM_USER + 100)
#define MSG_LOADABOUT_COMPLETE (WM_USER + 101)

class CSnapinManager;
class CSnapinStandAlonePage;
class CSnapinExtensionPage;
class CSnapinManagerAdd;
class CSnapinInfo;
class CSnapinInfoCache;
class CNewTreeNode;
class CManagerNode;
class CExtensionLink;
class CPolicy;
class CAboutInfoThread;

//-----------------------------------------------------
// CCheckList class
//
// Helper class for listview with checkboxes
//-----------------------------------------------------

class CCheckList : public MMC_ATL::CWindowImpl<CCheckList, WTL::CListViewCtrl>
{
public:
    DECLARE_WND_SUPERCLASS (NULL, WTL::CListViewCtrl::GetWndClassName())

BEGIN_MSG_MAP(CCheckList)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
    MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClk )
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown )
END_MSG_MAP()

    LRESULT OnKeyDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnLButtonDblClk( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnLButtonDown( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

public:
    enum
    {
        CHECKOFF_STATE   = INDEXTOSTATEIMAGEMASK(1),
        CHECKON_STATE    = INDEXTOSTATEIMAGEMASK(2),
        DISABLEOFF_STATE = INDEXTOSTATEIMAGEMASK(3),
        DISABLEON_STATE =  INDEXTOSTATEIMAGEMASK(4)
    };


    BOOL GetItemCheck(int iItem, BOOL* pbEnable = NULL)
    {
        ASSERT(::IsWindow(m_hWnd));
        ASSERT(iItem >= 0 && iItem < GetItemCount());

        int iState = GetItemState(iItem, LVIS_STATEIMAGEMASK);
        if (pbEnable != NULL)
            *pbEnable = (iState <= CHECKON_STATE);

        return (iState == CHECKON_STATE || iState == DISABLEON_STATE);
    }


    void SetItemCheck(int iItem, BOOL bState, BOOL bEnable = TRUE)
    {
        ASSERT(::IsWindow(m_hWnd));
        ASSERT(iItem >= 0 && iItem < GetItemCount());

        int iState = bState ? CHECKON_STATE : CHECKOFF_STATE;
        if (!bEnable)
            iState += (DISABLEOFF_STATE - CHECKOFF_STATE);

        SetItemState(iItem, iState, LVIS_STATEIMAGEMASK);
    }


    void ToggleItemCheck(int iItem)
    {
       ASSERT(::IsWindow(m_hWnd));
       ASSERT(iItem >= 0 && iItem < GetItemCount());

       SetItemState(iItem, GetItemState(iItem, LVIS_STATEIMAGEMASK)^(CHECKON_STATE^CHECKOFF_STATE), LVIS_STATEIMAGEMASK);
    }
};

//-----------------------------------------------------
// CAboutInfoThread
//
// This class handles the creation/deletion of the
// AboutInfo thread. One static instance of this class
// must be defined in addsnpin.cpp.
//-----------------------------------------------------
class CAboutInfoThread
{
public:
    CAboutInfoThread()
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CAboutInfoThread);
        m_hThread = NULL;
        m_hEvent = NULL;
        m_uThreadID = 0;
    }

    ~CAboutInfoThread();

    BOOL StartThread();
    BOOL PostRequest(CSnapinInfo* pSnapInfo, HWND hWndNotify);

private:
    static unsigned _stdcall ThreadProc(void* pVoid);
    HANDLE m_hThread;           // thread handle
    HANDLE m_hEvent;            // start event
    unsigned m_uThreadID;       // thread ID
};

//-----------------------------------------------------
// CSnapinInfo class
//
// Contains the registry information for a snapin.
// Also provides access to the ISnapinAbout information.
//-----------------------------------------------------

typedef CSnapinInfo* PSNAPININFO;

class CSnapinInfo : public CSnapinAbout
{
    friend class CSnapinInfoCache;

public:
    // Constructor/Destructor
    CSnapinInfo (Properties* pInitProps = NULL) :
        m_lRefCnt           (0),
        m_nUseCnt           (0),
        m_iImage            (-1),
        m_iOpenImage        (-1),
        m_spSnapin          (NULL),
        m_pExtensions       (NULL),
        m_spInitProps       (pInitProps),
        m_bAboutValid       (false),
        m_bStandAlone       (false),
        m_bExtendable       (false),
        m_bExtensionsLoaded (false),
        m_bEnableAllExts    (false),
        m_bInstalled        (false),
        m_bPolicyPermission (false)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinInfo);
    }

   ~CSnapinInfo();

private:
    // Attributes
    long     m_lRefCnt;                 // COM-type ref count (controls lifetime)
    int      m_nUseCnt;                 // Number of node and extension references
    GUID     m_clsid;                   // snapin CLSID
    GUID     m_clsidAbout;              // About  CLSID
    int      m_iImage;                  // small icon image index
    int      m_iOpenImage;              // index of open image
    CSnapInPtr m_spSnapin;              // ptr to CSnapIn (if snapin in use prior
                                        // to this manager session)
    CExtensionLink* m_pExtensions;      // linked list of extensions
    PropertiesPtr   m_spInitProps;      // properties to initialize with

    bool     m_bAboutValid       : 1;   // TRUE if About CLSID is valid
    bool     m_bStandAlone       : 1;   // TRUE if snapin is standalone
    bool     m_bExtendable       : 1;   // TRUE if snapin can be extended
    bool     m_bExtensionsLoaded : 1;   // Available extensions loaded
    bool     m_bEnableAllExts    : 1;   // TRUE if all extensions enabled
    bool     m_bInstalled        : 1;   // TRUE if snap-in is installed locally
    bool     m_bPolicyPermission : 1;   // Says if current user can use the snapin

public:
    // Operations
    BOOL  InitFromMMCReg(GUID& clsid, CRegKeyEx& regkey, BOOL bPermitted);
    BOOL  InitFromComponentReg(GUID& clsid, LPCTSTR pszName, BOOL bStandAlone, BOOL bPermitted);

    ULONG AddRef(void)
    {
        return InterlockedIncrement(&m_lRefCnt);
    }

    ULONG Release(void)
    {
        LONG lRet = InterlockedDecrement(&m_lRefCnt);
        ASSERT(lRet >= 0);

        if (lRet == 0)
            delete this;

        return static_cast<ULONG>(lRet);
    }

    void  AddUseRef(void);
    void  DeleteUseRef(void);

    GUID& GetCLSID(void) { return m_clsid; }
    void  LoadImages( WTL::CImageList iml );
    int   GetImage(void) { return m_iImage; }
    int   GetOpenImage(void) { return m_iOpenImage; }

    BOOL  IsStandAlone(void) { return m_bStandAlone; }
    BOOL  IsExtendable(void) { return m_bExtendable; }
    BOOL  IsUsed(void) { return (m_nUseCnt != 0); }
    BOOL  AreAllExtensionsEnabled(void) { return m_bEnableAllExts; }
    BOOL  IsInstalled(void) { return m_bInstalled; }

    CSnapIn* GetSnapIn(void) { return m_spSnapin; }
    void  SetSnapIn(CSnapIn* pSnapIn) { m_spSnapin = pSnapIn; }
    void  AttachSnapIn(CSnapIn* pSnapIn, CSnapinInfoCache& InfoCache);
    void  DetachSnapIn() { m_spSnapin = NULL; }
    void SetEnableAllExtensions(BOOL bState) { m_bEnableAllExts = bState; }
    SC    ScInstall(CLSID* pclsidPrimary);

    BOOL  HasAbout(void) { return m_bAboutValid; }
   // const LPOLESTR GetDescription(void);
    void  ShowAboutPages(HWND hWndParent);

    BOOL  IsPermittedByPolicy() { return m_bPolicyPermission; }


    BOOL LoadAboutInfo()
    {
        if (m_bAboutValid && !HasInformation())
        {
           BOOL bStat = GetSnapinInformation(m_clsidAbout);

           // if failure, About object is not really valid
           if (!bStat)
                m_bAboutValid = FALSE;
        }
        return HasInformation();
    }

    void ResetAboutInfo() { m_bAboutValid = TRUE; }

    CExtensionLink* GetExtensions(void) { return m_pExtensions; }
    CExtensionLink* FindExtension(CLSID& ExtCLSID);
    CExtensionLink* GetAvailableExtensions(CSnapinInfoCache* pInfoCache, CPolicy *pMMCPolicy);
    Properties*     GetInitProperties() const {return m_spInitProps; }
    void            SetInitProperties(Properties *pInitProps) { m_spInitProps = pInitProps;}
};

// CMap for holding all CSnapinInfo objects indexed by CLSID
class CSnapinInfoCache : public CMap<GUID, const GUID&, PSNAPININFO, PSNAPININFO>
{
public:
    // Constructor
    CSnapinInfoCache(void) 
    { 
        DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapinInfoCache);
        InitHashTable(31); 
    }

    ~CSnapinInfoCache()
    {
        DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinInfoCache);
    }

    // Operators
    void AddEntry(CSnapinInfo* pSnapInfo)
    {
        SetAt(pSnapInfo->m_clsid, pSnapInfo);
        pSnapInfo->AddRef();
    }
    CSnapinInfo* FindEntry( const GUID& clsid);
#ifdef DBG
    void Dump(void);
#else
    void Dump(void) {}
#endif

};

inline CSnapinInfo* CSnapinInfoCache::FindEntry(const GUID& rclsid)
{
    CSnapinInfo* pSnapInfo = NULL;
    Lookup(rclsid, pSnapInfo);
    return pSnapInfo;
}

inline UINT HashKey(const GUID& guid)
{
    unsigned short* Values = (unsigned short *)&guid;

    return (Values[0] ^ Values[1] ^ Values[2] ^ Values[3] ^
            Values[4] ^ Values[5] ^ Values[6] ^ Values[7]);
}

//-----------------------------------------------------
// CExtensionLink class
//
// Represents one link from a snapin to an extension.
// Each CSnapinInfo object maintains a list of these.
//-----------------------------------------------------

typedef CExtensionLink* PEXTENSIONLINK;

class CExtensionLink
{
public:
    typedef enum _EXTENSION_STATE
    {
        EXTEN_OFF,
        EXTEN_READY,
        EXTEN_ON
    } EXTENSION_STATE;

    // Constructor/Destructor
    CExtensionLink(CSnapinInfo* pSnapInfo) :
                    m_pSnapInfo(pSnapInfo), m_pNext(NULL), m_iExtTypes(0),
                    m_eOrigState(EXTEN_OFF), m_bRequired(FALSE), m_eCurState(EXTEN_OFF) {}
private:

    // Attributes
    EXTENSION_STATE  m_eOrigState;    // Original state of link
    EXTENSION_STATE  m_eCurState;     // Current state
    BOOL             m_bRequired;     // Is a required extension
    int              m_iExtTypes;     // Extension type flags (from class CExtSI)
    CSnapinInfo*     m_pSnapInfo;     // ptr to extension snapin info
    PEXTENSIONLINK   m_pNext;         // ptr to next extension link

public:
    // Operations
    void SetInitialState(EXTENSION_STATE eState) { m_eOrigState = eState; }
    void SetState(EXTENSION_STATE eState);
    void SetExtTypes(int iExtTypes) { m_iExtTypes = iExtTypes; }
    int GetExtTypes() { return m_iExtTypes; }
    void SetNext(CExtensionLink* pExtNext) { m_pNext = pExtNext; }
    EXTENSION_STATE GetState(void) { return m_eCurState; }
    CSnapinInfo* GetSnapinInfo(void) { return m_pSnapInfo; }
    BOOL IsChanged(void)
    { return (m_eOrigState == EXTEN_ON && m_eCurState != EXTEN_ON) ||
             (m_eOrigState != EXTEN_ON && m_eCurState == EXTEN_ON);
    }
    BOOL IsRequired(void) { return m_bRequired; }
    void SetRequired(BOOL bState = TRUE) { m_bRequired = bState; }
    PEXTENSIONLINK Next(void) { return m_pNext; }
};

//-----------------------------------------------------
// CNewTreeNode class
//
// Holds information for a new node created by the
// snapin manager. The objects are kept in a NewNodeList
// owned by the CSnapinManager. The list is passed to
// the scope tree handler to create the real nodes.
//-----------------------------------------------------

class  CNewTreeNode
{
public:
    // Contructor / Destructor
    CNewTreeNode() : m_pmtNode(NULL), m_pNext(NULL),
                     m_pChild(NULL), m_pParent(NULL), m_pmtNewNode(NULL),
                     m_pmtNewSnapInNode(NULL)
    {};

    ~CNewTreeNode() { if (m_pmtNewNode) m_pmtNewNode->Release(); delete Child(); delete Next(); }

public:
    // Operators
    PNEWTREENODE Next() { return m_pNext; }
    PNEWTREENODE Child() { return m_pChild; }
    PNEWTREENODE Parent() { return m_pParent;}
    CMTNode*     GetMTNode() {return m_pmtNode;}
    VOID         AddChild(PNEWTREENODE pntNode);
    VOID         RemoveChild(PNEWTREENODE pntNode);

public:
    // Attributes
    CMTNode*            m_pmtNode;     // pointer to parent MTNode (NULL if child of new node)
    PNEWTREENODE        m_pNext;       // pointer to next sibling
    PNEWTREENODE        m_pChild;      // pointer to first child
    PNEWTREENODE        m_pParent;     // pointer to new node parent (NULL if child of MTNode)

    //Specific node data
    IComponentDataPtr   m_spIComponentData;  // pointer to the snapin's IComponentData (if snapin)
    CLSID               m_clsidSnapIn;       // snapin CLSID (if snapin)
    CMTNode*            m_pmtNewNode;        // Pointer to new node (if not snapin node)

    PropertiesPtr       m_spSnapinProps;        // pointer to the snap-in's properties
    CMTSnapInNode*      m_pmtNewSnapInNode;     // new snap-in node
};


//------------------------------------------------------
// CManagerNode class
//
// Primary object that node manager handles. Each object
// represents one static standalone node. The objects
// are linked in a tree structure owned by the
// CSnapinManager class.
//------------------------------------------------------

typedef CManagerNode* PMANAGERNODE;
typedef CList <PMANAGERNODE, PMANAGERNODE> ManagerNodeList;

class CManagerNode
{
public:
    // Constructor / Destructor
    CManagerNode(): m_nType(0), m_pmtNode(NULL),
                    m_pSnapInfo(NULL), m_pNewNode(NULL) {}
    ~CManagerNode();

public:
    // Attributes
    PMANAGERNODE    m_pmgnParent;    // pointer to parent node
    ManagerNodeList m_ChildList;     // Child node list

    CStr            m_strValue;       // Display name string
    int             m_nType;          // node type (ADDNSP_SNAPIN or ADDSNP_STATICNODE)

    CMTNode*        m_pmtNode;        // pointer to MTNode (for existing node only)
    PNEWTREENODE    m_pNewNode;       // pointer to new tree node (for new nodes only)
    PSNAPININFO     m_pSnapInfo;      // pointer Snapin information

    int             m_iImage;         // image list indices
    int             m_iOpenImage;
    int             m_iIndent;        // indentation level for tree view

    // Operators
    VOID AddChild(PMANAGERNODE pmgnNode);
    VOID RemoveChild(PMANAGERNODE pmgnNode);
    PSNAPININFO GetSnapinInfo(void) { return m_pSnapInfo; }
    BOOL HasAboutInfo(void) { return (m_pSnapInfo && m_pSnapInfo->HasAbout()); }

};

/*+-------------------------------------------------------------------------*
 * class CSnapinManagerAdd
 *
 *
 * PURPOSE: Dialog for selecting type of snapin to add. Called by
 *          CSnapinStandAlonePage to enable the user to select a page. When the user
 *          selects a snapin, calls back into the CSnapinStandAlonePage to add
 *          the snapin.
 *
 * NOTE:    This object does not know about where in the tree the snapin will
 *          be added. That is handled by the CSnapinStandalone page.
 ************************************************************************/
class CSnapinManagerAdd : public CDialogImpl<CSnapinManagerAdd>
{

// Constructor/Destrcutor
public:
     CSnapinManagerAdd(CSnapinManager* pManager, CSnapinStandAlonePage* pStandAlonePage);
    ~CSnapinManagerAdd();

//MSGMAP
public:
    BEGIN_MSG_MAP(CSnapinManagerAdd)
//        MESSAGE_HANDLER(WM_SHOWWINDOW, OnShowWindow)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_COMMAND, OnCommand)
        MESSAGE_HANDLER(WM_SYSCOMMAND, OnSysCommand);
        CONTEXT_HELP_HANDLER()
        MESSAGE_HANDLER(MSG_LOADABOUT_COMPLETE, OnLoadAboutComplete)
        NOTIFY_HANDLER(IDC_SNAPIN_LV, LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_HANDLER(IDC_SNAPIN_LV, LVN_GETDISPINFO, OnGetDispInfo)
        NOTIFY_HANDLER(IDC_SNAPIN_LV, NM_DBLCLK, OnListDblClick)
    END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_SNAPIN_MANAGER_ADD);

// Operators
    PSNAPININFO SelectedInfo() { return m_pInfoSelected; }

public:
    // Operators
    enum { IDD = IDD_SNAPIN_MANAGER_ADD };

// Generated message map functions
protected:
    LRESULT OnShowWindow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnGetDispInfo(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnListDblClick(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnLoadAboutComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);


    void BuildSnapinList();

    // Attributes
    CSnapinManager* m_pManager;               // Pointer to owning manager
    CSnapinStandAlonePage* m_pStandAlonePage; // Pointer to calling page
    WTL::CListViewCtrl*  m_pListCtrl;         // snapin listview
    BOOL        m_bDoOnce;                    // TRUE first time through ShowWindow
    PSNAPININFO m_pInfoSelected;              // Selected snapin info
    int         m_iGetInfoIndex;              // index of snapin with pending About info
    CStr        m_strNotInstalled;            // string to display for uninstalled snap-ins
};

//------------------------------------------------------
// CSnapinStandAlonePage class
//
// The property page for adding/removing standalone
// snapin nodes.
//------------------------------------------------------

class CSnapinStandAlonePage : public WTL::CPropertyPageImpl<CSnapinStandAlonePage>
{

public:
    typedef WTL::CPropertyPageImpl<CSnapinStandAlonePage> BC;

    // Constructor/destructor
    CSnapinStandAlonePage(CSnapinManager* pManager);
    ~CSnapinStandAlonePage();

    enum { IDD = IDD_SNAPIN_STANDALONE_PROPP };

private:
    CSnapinManagerAdd& GetAddDialog()  {return m_dlgAdd;}

private:
    // attributes
    CSnapinManager*    m_pManager;      // pointer to owning snapin manager
    CSnapinManagerAdd  m_dlgAdd;       // pointer to add dialog
    WTL::CListViewCtrl m_snpListCtrl;   // listview for displaying child nodes
    CComboBoxEx2       m_snpComboBox;   // combobox for selecting parent node
    WTL::CToolBarCtrl     m_ToolbarCtrl;   // toolbar for folder-up button
    PMANAGERNODE       m_pmgnParent;    // currently selcted parent node
    PMANAGERNODE       m_pmgnChild;     // currently selcted child node


protected:
    BEGIN_MSG_MAP( CSnapinStandAlonePage )
        COMMAND_HANDLER(IDC_SNAPIN_COMBOEX, CBN_SELENDOK, OnTreeItemSelect)
        NOTIFY_HANDLER(IDC_SNAPIN_ADDED_LIST, LVN_ITEMCHANGED, OnListItemChanged)
        NOTIFY_HANDLER(IDC_SNAPIN_ADDED_LIST, LVN_KEYDOWN, OnListKeyDown)
        NOTIFY_HANDLER(IDC_SNAPIN_ADDED_LIST, NM_DBLCLK, OnListItemDblClick)
        COMMAND_ID_HANDLER(ID_SNP_UP, OnTreeUp)
        COMMAND_ID_HANDLER(IDC_SNAPIN_MANAGER_ADD, OnAddSnapin)
        COMMAND_ID_HANDLER(IDC_SNAPIN_MANAGER_DELETE, OnDeleteSnapin)
        COMMAND_ID_HANDLER(IDC_SNAPIN_ABOUT, OnAboutSnapin)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_SNAPIN_STANDALONE_PROPP);

    // operations
    LRESULT OnTreeItemSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnListItemChanged( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnListKeyDown( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnListItemDblClick( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnTreeUp( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnAddSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnDeleteSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnAboutSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    VOID AddNodeListToTree(ManagerNodeList& NodeList);
    int  AddChildToTree(PMANAGERNODE pMgrNode);
    VOID DisplayChildList(ManagerNodeList& NodeList);
    int  AddChildToList(PMANAGERNODE pMgrNode, int iIndex = -1);
    VOID SelectParentNodeItem(PMANAGERNODE pMgrNode);
    VOID SetupParentNode(PMANAGERNODE pMgrNode, bool bVisible = true);
    VOID SetupChildNode(PMANAGERNODE pMgrNode);

    SC ScRunSnapinWizard (const CLSID& clsid, HWND hwndParent,
                          Properties* pInitProps,
                          IComponentData*& rpComponentData,
                          Properties*& rpSnapinProps);

public:
    HRESULT AddOneSnapin(CSnapinInfo* pSnapInfo, bool bVisible = true);
    SC      ScAddOneSnapin(PMANAGERNODE pmgNodeParent, PSNAPININFO pSnapInfo);

    SC      ScRemoveOneSnapin(PMANAGERNODE pmgNodeTobeRemoved, int iItem, bool bVisible = true);
};



//------------------------------------------------------
// CSnapinExtensionPage class
//
// The property page configuring snapin extensions.
//------------------------------------------------------

class CSnapinExtensionPage : public WTL::CPropertyPageImpl<CSnapinExtensionPage>
{

public:
    typedef WTL::CPropertyPageImpl<CSnapinExtensionPage> BC;

    // Constructor/destructor
    CSnapinExtensionPage(CSnapinManager* pManager) :
                m_pManager(pManager), m_pCurSnapInfo(NULL), m_pExtLink(NULL) {}

    ~CSnapinExtensionPage();

    enum { IDD = IDD_SNAPIN_EXTENSION_PROPP };

private:
    // Attributes

    CSnapinManager* m_pManager;          // ptr to owning manager
    CComboBoxEx2 m_SnapComboBox;          // combobox for selecting snapin
    CCheckList       m_ExtListCtrl;      // list of extensions
    PSNAPININFO     m_pCurSnapInfo;      // currently selected snapin
    PEXTENSIONLINK  m_pExtLink;          // currently selected extension
    BOOL            m_bUpdateSnapinList; // TRUE if snapin list may have changed
    WTL::CImageList m_ilCheckbox;        // checkbox image list

protected:
    BEGIN_MSG_MAP(CSnapinExtensPage)
        COMMAND_HANDLER( IDC_SNAPIN_COMBOEX, CBN_SELENDOK, OnSnapinSelect )
        COMMAND_HANDLER( IDC_SNAPIN_COMBOEX, CBN_DROPDOWN, OnSnapinDropDown )
        COMMAND_HANDLER( IDC_SNAPIN_ENABLEALL, BN_CLICKED, OnEnableAllChanged )
        COMMAND_ID_HANDLER( IDC_SNAPIN_ABOUT, OnAboutSnapin )
        COMMAND_ID_HANDLER( IDC_SNAPIN_DOWNLOAD, OnDownloadSnapin )
        NOTIFY_HANDLER( IDC_EXTENSION_LIST, LVN_ITEMCHANGED, OnExtensionChanged )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CONTEXT_HELP_HANDLER()
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_SNAPIN_EXTENSION_PROPP);

    // Operations
    LRESULT OnSnapinSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnExtensionChanged( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );
    LRESULT OnEnableAllChanged( WORD wNotifyCode, WORD wID, HWND hWndCtrl, BOOL& bHandled );
    LRESULT OnSnapinDropDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnAboutSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnDownloadSnapin( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    BOOL OnSetActive(void);

    void BuildSnapinList(void);
    void BuildExtensionList(PSNAPININFO pSnapInfo);
};


//------------------------------------------------------
// CSnapinManager class
//
// Top level mannger object.
//------------------------------------------------------

typedef CList<CMTNode*, CMTNode*> MTNodesList;

class CSnapinManager : public WTL::CPropertySheet
{
    friend class CSnapinStandAlonePage;
    friend class CSnapinExtensionPage;
    friend class CSnapinManagerAdd;

    DECLARE_NOT_COPIABLE   (CSnapinManager)
    DECLARE_NOT_ASSIGNABLE (CSnapinManager)

public:
    // Constructor/Destructor
    CSnapinManager(CMTNode *pmtNode);
    ~CSnapinManager();

    // Attributes
    typedef CList<CSnapIn*, CSnapIn*> SNPList; // TEMP TEMP
    SNPList     m_snpSnapinChangedList;        // List of modified snapins
    MTNodesList m_mtnDeletedNodesList;         // List of delted MT ndoes
    NewNodeList m_NewNodesList;                // Tree of added nodes

    // Operators
    virtual int  DoModal(void);

    MTNodesList* GetDeletedNodesList(void) { return &m_mtnDeletedNodesList; }
    NewNodeList* GetNewNodes(void) { return &m_NewNodesList; }
    SNPList*     GetSnapinChangedList(void) { return &m_snpSnapinChangedList; }
    HRESULT      LoadAboutInfoAsync(PSNAPININFO pSnapInfo, HWND hWndNotify);
    CSnapinInfoCache &GetSnapinInfoCache()  {return m_SnapinInfoCache;}

    SC           ScInitialize();
public:
    // object method operations
    SC          ScAddSnapin(LPCWSTR szSnapinNameOrCLSIDOrProgID, SnapIn* pParentSnapinNode, Properties *pProperties);
    SC          ScRemoveSnapin(CMTNode *pMTNode);
    SC          ScEnableAllExtensions(const CLSID& clsidSnapin, BOOL bEnable);
    SC          ScEnableExtension(const CLSID& clsidPrimarySnapin, const CLSID& clsidExtension, bool bEnable);

protected:
    // Operations
    BOOL LoadMTNodeTree(PMANAGERNODE pmgnParent, CMTNode* pMTNode);
    SC   ScLoadSnapinInfo(void);
    void UpdateSnapInCache();
    PMANAGERNODE FindManagerNode(const ManagerNodeList& mgNodeList, CMTNode *pMTNode);
    SC    ScGetSnapinInfo(LPCWSTR szSnapinNameOrCLSIDOrProgID, CSnapinInfo **ppSnapinInfo);


    // Attributes
    WTL::CImageList  m_iml;                    // imagelist shared by all controls
    CMTNode*         m_pmtNode;                // Root node of master tree
    ManagerNodeList  m_mgNodeList;             // List of manager nodes
    CSnapinInfoCache m_SnapinInfoCache;        // Cache of snapin info objects
    CAboutInfoThread m_AboutInfoThread;        // Worker thread class
    bool             m_bInitialized : 1;       // Should initialize only once.

private:
    // Attributes
    CSnapinStandAlonePage  m_proppStandAlone;   // Standalone property page
    CSnapinExtensionPage   m_proppExtension;    // Extensions property page
    CPolicy               *m_pMMCPolicy;

};


int CALLBACK _ListViewCompareFunc(LPARAM lParam1,LPARAM lParam2,LPARAM lParamSort);

#endif  // __ADDSNPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\coldata.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       coldata.h
//
//  Contents:   Classes to access persisted column data.
//
//  Classes:    CColumnData
//
//  History:    25-Jan-99 AnandhaG     Created
//
//--------------------------------------------------------------------

#ifndef COLDATA_H
#define COLDATA_H

class CNodeInitObject;

/////////////////////////////////////////////////////////////////////////////
// CColumnData
class CColumnData : public IColumnData
{
public:
    CColumnData();
    ~CColumnData();

IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()

public:
    // IColumnData members.
    STDMETHOD(SetColumnConfigData)(SColumnSetID* pColID,MMC_COLUMN_SET_DATA*  pColSetData);
    STDMETHOD(GetColumnConfigData)(SColumnSetID* pColID,MMC_COLUMN_SET_DATA** ppColSetData);
    STDMETHOD(SetColumnSortData)(SColumnSetID* pColID,MMC_SORT_SET_DATA*  pColSortData);
    STDMETHOD(GetColumnSortData)(SColumnSetID* pColID,MMC_SORT_SET_DATA** ppColSortData);

private:
    HRESULT GetColumnData(SColumnSetID* pColID, CColumnSetData& columnSetData);
    HRESULT SetColumnData(SColumnSetID* pColID, CColumnSetData& columnSetData);
};

HRESULT WINAPI ColumnInterfaceFunc(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw);

#endif /* COLDATA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\colwidth.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      colwidth.cpp
//
//  Contents:  Column Persistence data structures and property pages
//             implementation.
//
//  History:   16-Oct-98 AnandhaG    Created
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "colwidth.h"
#include "macros.h"
#include "comdbg.h"
#include "columninfo.h"

#define MAX_COLUMNS_PERSISTED 50

//+-------------------------------------------------------------------
//
//  Class:      ViewToColSetDataMapPersistor (wrapper, helper)
//
//  Purpose:    wraps ViewToColSetDataMap implementing XML persistence
//              map is persisted as linear list
//
// see "Data structures used to persist column information" comment
// int file colwidth.h for more information
//--------------------------------------------------------------------
class ViewToColSetDataMapPersistor : public XMLListCollectionBase
{
public:
    ViewToColSetDataMapPersistor(ViewToColSetDataMap &map, ColSetDataList &list)
                                : m_map(map),  m_list(list) {}

    DEFINE_XML_TYPE(XML_TAG_COLUMN_SET);
    virtual void  Persist(CPersistor &persistor);
    virtual void  OnNewElement(CPersistor& persistor);
private:
    ViewToColSetDataMap &m_map;     // wrapped map
    ColSetDataList      &m_list;    // value list to persist actual information
};

//+-------------------------------------------------------------------
//
//  Class:      ColSetIDToViewTableMapPersistor (wrapper, helper)
//
//  Purpose:    wraps ColSetIDToViewTableMap implementing XML persistence
//              map is persisted as linear list
//
// see "Data structures used to persist column information" comment
// int file colwidth.h for more information
//--------------------------------------------------------------------
class ColSetIDToViewTableMapPersistor : public XMLListCollectionBase
{
public:
    ColSetIDToViewTableMapPersistor(ColSetIDToViewTableMap &map, ColSetDataList &list)
                                    : m_map(map),  m_list(list) {}

    DEFINE_XML_TYPE(XML_TAG_COLUMN_PERIST_ENTRY);
    virtual void  Persist(CPersistor &persistor);
    virtual void  OnNewElement(CPersistor& persistor);
private:
    ColSetIDToViewTableMap &m_map;  // wrapped map
    ColSetDataList         &m_list; // value list to persist actual information
};

//+-------------------------------------------------------------------
//
//  Class:      SnapinToColSetIDMapPersistor (wrapper, helper)
//
//  Purpose:    wraps SnapinToColSetIDMap implementing XML persistence
//              map is persisted as linear list
//
// see "Data structures used to persist column information" comment
// int file colwidth.h for more information
//--------------------------------------------------------------------
class SnapinToColSetIDMapPersistor : public XMLListCollectionBase
{
public:
    SnapinToColSetIDMapPersistor(SnapinToColSetIDMap &map, ColSetDataList &list)
                               : m_map(map),  m_list(list) {}

    DEFINE_XML_TYPE(XML_TAG_COLUMN_PERIST_ENTRY);
    virtual void  Persist(CPersistor &persistor);
    virtual void  OnNewElement(CPersistor& persistor);

    // prior-to-save cleanup
    SC ScPurgeUnusedColumnData();
private:
    SnapinToColSetIDMap &m_map;     // wrapped map
    ColSetDataList      &m_list;    // value list to persist actual information
};

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Read the given version of CColumnSortInfo object from
//              the given stream.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - version of CColumnSortInfo to be read.
//
//                          The format is :
//                              INT        column index
//                              DWORD      Sort options
//                              ULONG_PTR  Any user (snapin) param
//
//--------------------------------------------------------------------
HRESULT CColumnSortInfo::ReadSerialObject(IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (GetVersion() >= nVersion)
    {
        try
        {
            stm >> m_nCol;

            // In version we stored just ascending or descending flag
            if (1 == nVersion)
            {
                BYTE bAscend;
                stm >> bAscend;
                m_dwSortOptions |= (bAscend ? 0 : RSI_DESCENDING);
            }
            else if (nVersion > 1)
            {
                // Versions greater than 1 has these sort data which
                // includes ascend/descend flags and a user param.
                stm >> m_dwSortOptions;
                stm >> m_lpUserParam;
            }

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CColumnSortInfo::Persist
//
//  Synopsis:   Persists object data
//
//  Arguments:
//
//  History:    10-10-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CColumnSortInfo::Persist(CPersistor &persistor)
{
    persistor.PersistAttribute(XML_ATTR_COLUMN_SORT_INFO_COLMN,  m_nCol) ;

    static const EnumLiteral sortOptions[] =
    {
        { RSI_DESCENDING,      XML_BITFLAG_COL_SORT_DESCENDING },
        { RSI_NOSORTICON,      XML_BITFLAG_COL_SORT_NOSORTICON },
    };

    CXMLBitFlags optionPersistor(m_dwSortOptions, sortOptions, countof(sortOptions));

    persistor.PersistAttribute(XML_ATTR_COLUMN_SORT_INFO_OPTNS, optionPersistor) ;
}

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Reads CColumnSortList data from stream.
//
//  Format:     number of columns : each CColumnSortInfo entry.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - Version of CColumnSortList to be read.
//
//
//--------------------------------------------------------------------
HRESULT CColumnSortList::ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (GetVersion() == nVersion)
    {
        try
        {
            // Number of columns.
            DWORD dwCols;
            stm >> dwCols;

            clear();

            for (int i = 0; i < dwCols; i++)
            {
                CColumnSortInfo colSortEntry;

                // Read data into colSortEntry structure.
                if (colSortEntry.Read(stm) != S_OK)
                    continue;

                push_back(colSortEntry);
            }

            hr = S_OK;
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}

/***************************************************************************\
 *
 * METHOD:  CColumnSortList::Persist
 *
 * PURPOSE: persists object to XML
 *
 * PARAMETERS:
 *    CPersistor& persistor [in/out] persistor to persist under
 *
 * RETURNS:
 *    void
 *
\***************************************************************************/
void CColumnSortList::PersistSortList(CPersistor& persistor)
{
    DECLARE_SC(sc, TEXT("CColumnSortList::PersistSortList"));

    if (persistor.IsLoading())
    {
        clear();
        CColumnSortInfo sortInfo;
        if (persistor.HasElement(sortInfo.GetXMLType(), NULL))
        {
            persistor.Persist(sortInfo);
            insert(end(), sortInfo);
        }
    }
    else
    {
        if (size() > 1)
            sc.Throw(E_UNEXPECTED);
        else if (size())
            persistor.Persist(*begin());
    }
}

//+-------------------------------------------------------------------
//
//  Member:     ReadSerialObject
//
//  Synopsis:   Read CColumnSetData data from the stream.
//
//  Arguments:  [stm]      - The input stream.
//              [nVersion] - Version of CColumnSetData structure.
//
//  Format :    CColumnInfoList : CColumnSortList
//
//
//--------------------------------------------------------------------
HRESULT CColumnSetData::ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/)
{
    HRESULT hr = S_FALSE;   // assume bad version

    if (GetVersion() == nVersion)
    {
        try
        {
            do  // not a loop
            {
                // Read the rank
                stm >> m_dwRank;

                // Read the CColumnInfoList
                hr = get_ColumnInfoList()->Read(stm);
                if (hr != S_OK)
                    break;

                // Read the CColumnSortList
                hr = get_ColumnSortList()->Read(stm);
                if (hr != S_OK)
                    break;

                ASSERT (hr == S_OK);

            } while (false);
        }
        catch (_com_error& err)
        {
            hr = err.Error();
            ASSERT (false && "Caught _com_error");
        }
    }

    return (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CColumnSetData::Persist
//
//  Synopsis:   Persists object data
//
//  Arguments:
//
//  History:    10-10-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CColumnSetData::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CColumnSetData::Persist"));

    sc = ScCheckPointers(get_ColumnInfoList(), get_ColumnSortList());
    if (sc)
        sc.Throw();

    persistor.PersistAttribute(XML_ATTR_COLUMN_SET_RANK,  m_dwRank);

    // Write CColumnInfoList
    persistor.Persist(*get_ColumnInfoList());
    // Write CColumnSortList
    get_ColumnSortList()->PersistSortList(persistor);
}

//------------------------------------------------------------------
// class CColumnPersistInfo
//------------------------------------------------------------------
CColumnPersistInfo::CColumnPersistInfo() :
    m_bInitialized(FALSE), m_dwMaxItems(MAX_COLUMNS_PERSISTED),
    m_bDirty(FALSE)
{
}

CColumnPersistInfo::~CColumnPersistInfo()
{
}

//+-------------------------------------------------------------------
//
//  Member:     RetrieveColumnData
//
//  Synopsis:   Copy and return the persisted column information
//              for given column id and view id.
//
//  Arguments:  [refSnapinCLSID] - Snapin Guid
//              [SColumnSetID]       - Column Set Identifier.
//              [nViewID]        - View ID.
//              [columnSetData]  - CColumnSetData, used to return the
//                                 persisted column information.
//
//  Returns:    TRUE - Loaded successfully.
//
//  History:    10-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
BOOL CColumnPersistInfo::RetrieveColumnData( const CLSID& refSnapinCLSID,
                                            const SColumnSetID& colID,
                                            INT nViewID,
                                            CColumnSetData& columnSetData)
{
    BOOL bFound = FALSE;

    // Make sure we are initialized.
    if (!m_bInitialized && !Init())
    {
        ASSERT(FALSE);
        return bFound;
    }

    // Construct CColumnSetID.
    CColumnSetID colSetID(colID);

    // Use the snapin clsid to get the ColSetIDToViewTableMap.
    SnapinToColSetIDMap::iterator        itSnapins;
    itSnapins = m_spSnapinsMap->find(refSnapinCLSID);
    if (itSnapins == m_spSnapinsMap->end())
        return bFound;

    // The ColSetIDToViewTableMap is a simple map.
    ColSetIDToViewTableMap::iterator      itColSetIDMap;
    ColSetIDToViewTableMap& colSetIDMap = itSnapins->second;

    // Get the data for colSetID.
    itColSetIDMap = colSetIDMap.find(colSetID);
    if (colSetIDMap.end() == itColSetIDMap)
        return bFound;

    ViewToColSetDataMap& viewData = itColSetIDMap->second;
    ViewToColSetDataMap::iterator itViews;

    // See if our view is present.
    itViews = viewData.find(nViewID);
    if (viewData.end() != itViews)
    {
        // Found the item.
        bFound = TRUE;
        ItColSetDataList itColSetData = itViews->second;

        // Copy the data.
        columnSetData = *itColSetData;

        // So move this item to the top of the queue.
        m_spColSetList->erase(itColSetData);

        itColSetData = m_spColSetList->insert(m_spColSetList->begin(), columnSetData);
        itViews->second = itColSetData;
    }

    return bFound;
}

//+-------------------------------------------------------------------
//
//  Member:     SaveColumnData
//
//  Synopsis:   Save/Modify the column information for persistence into
//              CColumnPersistInfo.
//
//  Arguments:
//              [refSnapinCLSID] - Snapin Guid.
//              [SColumnSetID]       - Column Set Identifier.
//              [nViewID]        - View ID.
//              [columnSetData]  - CColumnSetData, Column data.
//
//  Returns:    TRUE - Saved successfully.
//
//  History:    10-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
BOOL CColumnPersistInfo::SaveColumnData( const CLSID& refSnapinCLSID,
                                         const SColumnSetID& colID,
                                         INT nViewID,
                                         CColumnSetData& columnSetData)
{
    // Make sure we are init
    if (!m_bInitialized && !Init())
    {
        ASSERT(FALSE);
        return FALSE;
    }

    // Construct the CColumnSetID.
    CColumnSetID colSetID(colID);

    // Garbage collect if the number of items in the list is 40% more then pre-set limit.
    if (m_spColSetList->size() >= (m_dwMaxItems * (1 + COLUMNS_MAXLIMIT)) )
        GarbageCollectItems();

    // Insert this item to the top of the queue.
    ItColSetDataList itColData;
    itColData = m_spColSetList->insert(m_spColSetList->begin(), columnSetData);

    SnapinToColSetIDMap::iterator itSnapins;
    itSnapins = m_spSnapinsMap->find(refSnapinCLSID);

    if (itSnapins != m_spSnapinsMap->end())
    {
        // Snapin is already in the map.
        // Look if the col-id is already inserted.
        ColSetIDToViewTableMap::iterator       itColSetIDMap;

        ColSetIDToViewTableMap& colSetIDMap = itSnapins->second;

        // Get the data for the colSetID.
        itColSetIDMap = colSetIDMap.find(colSetID);

        if (colSetIDMap.end() == itColSetIDMap)
        {
            // The column-id not found.
            // So insert new one.

            // Construct the view-id to column-data map
            ViewToColSetDataMap viewIDMap;
            viewIDMap.insert( ViewToColSetDataVal(nViewID, itColData) );

            colSetIDMap.insert(ColSetIDToViewTableVal(colSetID, viewIDMap) );
        }
        else
        {
            // The data for Col-ID exists.
            // find if the given view exists in the map.

            ViewToColSetDataMap::iterator itViewIDMap;
            ViewToColSetDataMap& viewIDMap = itColSetIDMap->second;

            itViewIDMap = viewIDMap.find(nViewID);
            if (viewIDMap.end() != itViewIDMap)
            {
                // The map from ViewID to column list exists.
                // So delete the old data and insert new data
                // at the top of the queue.
                m_spColSetList->erase(itViewIDMap->second);
                itViewIDMap->second = itColData;
            }
            else
            {
                // This view is not found.
                // So insert new one.

                viewIDMap.insert( ViewToColSetDataVal(nViewID, itColData) );
            }

        }

    }
    else
    {
        // Insert the snapin into the map.

        // Construct the ViewID to column-data map.
        ViewToColSetDataMap viewIDMap;
        viewIDMap.insert( ViewToColSetDataVal(nViewID, itColData) );

        // Insert the above into the col-id map.
        ColSetIDToViewTableMap colIDMap;
        colIDMap.insert( ColSetIDToViewTableVal(colSetID, viewIDMap) );

        // Insert into the snapins map.
        m_spSnapinsMap->insert( SnapinToColSetIDVal(refSnapinCLSID, colIDMap) );
    }

    // Set dirty after modifying the column-data.
    m_bDirty = TRUE;

    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     DeleteColumnData
//
//  Synopsis:   Delete the persisted column information for the given
//              snapin, col-id and view id.
//
//  Arguments:
//              [refSnapinCLSID] - Snapin Guid.
//              [SColumnSetID]       - Column Set Identifier.
//              [nViewID]        - View ID.
//
//  Returns:    None.
//
//  History:    02-13-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
VOID CColumnPersistInfo::DeleteColumnData( const CLSID& refSnapinCLSID,
                                           const SColumnSetID& colID,
                                           INT nViewID)
{
    // Make sure we are initialized.
    if (!m_bInitialized && !Init())
    {
        ASSERT(FALSE);
        return;
    }

    // Construct CColumnSetID.
    CColumnSetID colSetID(colID);

    // Use the snapin clsid to get the ColSetIDToViewTableMap.
    SnapinToColSetIDMap::iterator        itSnapins;
    itSnapins = m_spSnapinsMap->find(refSnapinCLSID);
    if (itSnapins == m_spSnapinsMap->end())
        return;

    // The ColSetIDToViewTableMap is a simple map.
    ColSetIDToViewTableMap::iterator       itColSetIDMap;
    ColSetIDToViewTableMap& colSetIDMap = itSnapins->second;

    // Get the data for colSetID.
    itColSetIDMap = colSetIDMap.find(colSetID);
    if (colSetIDMap.end() == itColSetIDMap)
        return;

    ViewToColSetDataMap& viewData = itColSetIDMap->second;
    ViewToColSetDataMap::iterator itViews;

    // See if our view is present.
    itViews = viewData.find(nViewID);
    if (viewData.end() == itViews)
        return;

    ItColSetDataList itColSetData = itViews->second;
    itColSetData->m_bInvalid = TRUE;

    // Delete the invalid items.
    DeleteMarkedItems();

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     DeleteColumnDataOfSnapin
//
//  Synopsis:   Delete the column data of given snapin.
//
//  Arguments:  [refSnapinCLSID] - Snapin Guid.
//
//  Returns:    TRUE - Data removed successfully.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
BOOL CColumnPersistInfo::DeleteColumnDataOfSnapin( const CLSID& refSnapinCLSID)
{
    // Make sure we are init
    if (!m_bInitialized)
    {
        return FALSE;
    }

    SnapinToColSetIDMap::iterator itSnapinsMap;
    itSnapinsMap = m_spSnapinsMap->find(refSnapinCLSID);

    // Find the given snapin.
    // Iterate thro all the col-ids of this snapin and
    // all the views of those col-id and set the data
    // to be invalid.
    if (m_spSnapinsMap->end() != itSnapinsMap)
    {
        ColSetIDToViewTableMap& colSets = itSnapinsMap->second;

        // Iterate thro' all colset ids of this snapin.
        ColSetIDToViewTableMap::iterator itColumnSetIDMap;

        for (itColumnSetIDMap  = colSets.begin();
             itColumnSetIDMap != colSets.end();
             ++itColumnSetIDMap)
        {
            // Get the view map

            ViewToColSetDataMap& viewIDMap = itColumnSetIDMap->second;
            ViewToColSetDataMap::iterator itViewIDMap;

            // Iterate thro' all views and set the data invalid.
            for (itViewIDMap  = viewIDMap.begin();
                 itViewIDMap != viewIDMap.end();
                 ++itViewIDMap)
            {
                ItColSetDataList itColSetData = itViewIDMap->second;
                itColSetData->m_bInvalid = TRUE;
            }
        }
    }

    // Delete the invalid items.
    DeleteMarkedItems();

    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     DeleteColumnDataOfView
//
//  Synopsis:   Delete the column data of given view.
//
//  Arguments:  [nViewID] - View ID.
//
//  Returns:    TRUE - Data removed successfully.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
BOOL CColumnPersistInfo::DeleteColumnDataOfView( int nViewID)
{
    // Make sure we are init
    if (!m_bInitialized)
    {
        return FALSE;
    }

    // Iterate thro all snapins, col-ids and find the matching
    // view and set data to be invalid.
    SnapinToColSetIDMap::iterator itSnapinsMap;

    // Iterate thro all snapins.
    for (itSnapinsMap = m_spSnapinsMap->begin();
         m_spSnapinsMap->end() != itSnapinsMap;
         ++itSnapinsMap)
    {
        ColSetIDToViewTableMap& colSets = itSnapinsMap->second;
        ColSetIDToViewTableMap::iterator itColumnSetIDMap;

        // Iterate thro' all colset ids of this snapin.
        for (itColumnSetIDMap  = colSets.begin();
             itColumnSetIDMap != colSets.end();
             ++itColumnSetIDMap)
        {
            // Get the view map
            ViewToColSetDataMap& viewIDMap = itColumnSetIDMap->second;
            ViewToColSetDataMap::iterator itViewIDMap;

            // Find the matching views and mark them to be deleted.
            for (itViewIDMap  = viewIDMap.begin();
                 itViewIDMap != viewIDMap.end();
                 ++itViewIDMap)
            {
                if (nViewID == itViewIDMap->first)
                {
                    ItColSetDataList itColSetData = itViewIDMap->second;
                    itColSetData->m_bInvalid = TRUE;
                }
            }

        }
    }

    // Delete the invalid items.
    DeleteMarkedItems();

    return TRUE;
}



//+-------------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   Create the Map and the list for CColumnSetData.
//
//  Returns:    TRUE - for success.
//
//  History:    10-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
BOOL CColumnPersistInfo::Init()
{
	// Create the data structures to store column data.
	m_spSnapinsMap = auto_ptr<SnapinToColSetIDMap>(new SnapinToColSetIDMap);

	m_spColSetList = auto_ptr<ColSetDataList> (new ColSetDataList);

	// Now the objects are created, so now set initialized to true.
	m_bInitialized = TRUE;

	// Now read the registry to see if m_dwMaxItems is specified.
	// Check if the settings key exists.
	CRegKeyEx rSettingsKey;
	if (rSettingsKey.ScOpen (HKEY_LOCAL_MACHINE, SETTINGS_KEY, KEY_READ).IsError())
		return m_bInitialized;

	// Read the values for MaxColDataPersisted.
	if (rSettingsKey.IsValuePresent(g_szMaxColumnDataPersisted))
	{
		DWORD  dwType = REG_DWORD;
		DWORD  dwSize = sizeof(DWORD);

		SC sc = rSettingsKey.ScQueryValue (g_szMaxColumnDataPersisted, &dwType,
										   &m_dwMaxItems, &dwSize);

		if (sc)
			sc.TraceAndClear();
	}

    return m_bInitialized;
}

//+-------------------------------------------------------------------
//
//  Member:     GarbageCollectItems
//
//  Synopsis:   Free least used column data.
//
//  Arguments:  None.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
VOID CColumnPersistInfo::GarbageCollectItems()
{
    INT nItemsToBeRemoved = COLUMNS_MAXLIMIT * m_dwMaxItems;

    // Go thro' the list and set the nItemsToBeRemoved that was least recently
    // accessed to be invalid.
    INT nIndex = 0;
    ItColSetDataList itColList;

    // Skip first m_dwMaxItems.
    for (itColList  = m_spColSetList->begin();
         ( (itColList != m_spColSetList->end()) && (nIndex <= m_dwMaxItems) );
         ++itColList, nIndex++)
    {
        nIndex++;
    }

    // Mark rest of the items to be garbage.
    while (itColList != m_spColSetList->end())
    {
        itColList->m_bInvalid = TRUE;
        ++itColList;
    }

    // Delete the invalid items.
    DeleteMarkedItems();

    return;
}


//+-------------------------------------------------------------------
//
//  Member:     DeleteMarkedItems
//
//  Synopsis:   Delete invalidated items. This involves iterating thro
//              the maps to find the invalid items. Then deleting the
//              items. If the map becomes empty then delete the map.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
VOID CColumnPersistInfo::DeleteMarkedItems()
{
    SnapinToColSetIDMap::iterator itSnapinsMap, itSnapinsMapNew;

    // Now iterate thro the map and remove those elements.
    itSnapinsMap  = m_spSnapinsMap->begin();

    while (itSnapinsMap != m_spSnapinsMap->end())
    {
        ColSetIDToViewTableMap& colSets = itSnapinsMap->second;
        ColSetIDToViewTableMap::iterator itColumnSetIDMap;

        // Iterate thro this snapins col-ids.
        itColumnSetIDMap  = colSets.begin();

        while (itColumnSetIDMap != colSets.end())
        {
            // Get the view map
            ViewToColSetDataMap& viewIDMap = itColumnSetIDMap->second;
            ViewToColSetDataMap::iterator itViewIDMap;

            // Iterate thro all the views.
            itViewIDMap = viewIDMap.begin();

            while (itViewIDMap != viewIDMap.end())
            {
                ItColSetDataList itColSetData = itViewIDMap->second;

                if (itColSetData->m_bInvalid)
                {
                    // Delete the item ref from the map.
                    // Erase returns iterator to next item.
                    itViewIDMap = viewIDMap.erase(itViewIDMap);

                    // Delete the item from the list.
                    m_spColSetList->erase(itColSetData);
                }
                else
                    // Item is valid item.
                    ++itViewIDMap;
            }

            // If the view has zero items we need to remove this
            // view map. (ColID to ViewMap).
            if (0 == viewIDMap.size())
            {
                // Delete the col-id map.
                // Erase returns iterator to next item.
                itColumnSetIDMap = colSets.erase(itColumnSetIDMap);
            }
            else
                ++itColumnSetIDMap;
        }

        // If there are no col-id's remove the
        // Snapin to this col-id map.
        if (0 == colSets.size())
        {
            // Delete this snapin map.
            // Erase returns iterator to next item.
            itSnapinsMap = m_spSnapinsMap->erase(itSnapinsMap);
        }
        else
            ++itSnapinsMap;
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   Load the persisted column information.
//
//  Arguments:  [pStream]- ISteam from which column widths to be loaded.
//
//  Returns:    S_OK - Loaded successfully.
//
//  History:    10-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnPersistInfo::Load (IStream* pStream)
{
    HRESULT hr = E_FAIL;

    if (!m_bInitialized && !Init())
    {
        ASSERT(FALSE);
        return hr;
    }

    // read the column width information.
    try
    {
        do
        {
            // Read the version. If it did not match return
            INT   nVersion                      = 0;
            *pStream >> nVersion;
            if (COLPersistenceVersion != nVersion)
                return S_FALSE;

            // Read the # of Snapins
            DWORD dwSnapins = 0;
            *pStream >> dwSnapins;

            m_spColSetList->clear();
            m_spSnapinsMap->clear();

            // For each snapin...
            for (int nSnapIdx = 0; nSnapIdx < dwSnapins; nSnapIdx++)
            {
                // Read snapin CLSID.
                CLSID clsidSnapin;
                *pStream >> clsidSnapin;

                // Read the number of col-ids for this snapin.
                DWORD dwColIDs = 0;
                *pStream >> dwColIDs;

                ColSetIDToViewTableMap colSetsMap;

                // For each col-id...
                for (int nColIDIdx = 0; nColIDIdx < dwColIDs; nColIDIdx++)
                {
                    // Read the col-id
                    CColumnSetID colSetID;
                    *pStream >> colSetID;

                    // Read the number of views.
                    DWORD dwNumViews = 0;
                    *pStream >> dwNumViews;

                    ViewToColSetDataMap ViewIDMap;

                    // For each view...
                    for (int nViewIdx = 0; nViewIdx < dwNumViews; nViewIdx++)
                    {
                        // Read view id.
                        DWORD dwViewID;
                        *pStream >> dwViewID;

                        // Read the CColumnSetData.
                        CColumnSetData   ColData;
                        ColData.Read(*pStream);

                        // Insert the data into the global linked list.
                        ItColSetDataList itColSetData;
                        itColSetData = m_spColSetList->insert(m_spColSetList->begin(), ColData);

                        // Insert the pointer to the data in to view map.
                        ViewIDMap.insert(ViewToColSetDataVal(dwViewID, itColSetData));
                    }

                    // Insert the view map into the col-id map.
                    colSetsMap.insert(ColSetIDToViewTableVal(colSetID, ViewIDMap));
                }

                // Insert the col-id map into the snapin map.
                m_spSnapinsMap->insert(SnapinToColSetIDVal(clsidSnapin, colSetsMap));
            }

            // Now sort the list.
            m_spColSetList->sort();

        } while (FALSE);
    }
    catch (_com_error& err)
    {
        hr = err.Error();
    }
    catch (...)
    {
        ASSERT (0 && "Unexpected exception");
        throw;
    }

    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   Persist the column information.
//
//  Arguments:  [pStream]- IStream in which column widths are to be saved.
//
//  Returns:    S_OK - Saved successfully.
//
//  History:    10-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnPersistInfo::Save (IStream* pStream, BOOL bClearDirty)
{
    // absolete method.
    // this method is left here since we use IPersistStream to export
    // persistence to CONUI side and need to implement it.
    // But this interface will never be called to save data
    // [we will use CPersistor-based XML saving instead]
    // so the method will always fail.
    ASSERT(FALSE && "Should never come here");
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------
//
//  Member:     Persist
//
//  Synopsis:   Persists the column information.
//
//  Arguments:  [persistor]- CPersistor in/from which column widths are persisted.
//
//  Returns:    void.
//
//  History:    10-08-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CColumnPersistInfo::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CColumnPersistInfo::Persist"));

    if (!m_bInitialized && !Init())
        sc.Throw(E_FAIL);

    sc = ScCheckPointers(m_spColSetList.get(), m_spSnapinsMap.get(), E_UNEXPECTED);
    if (sc)
        sc.Throw();

    if (persistor.IsStoring())
    {
        // Give ranking to each column data.
        ItColSetDataList itColList;
        DWORD dwRank = 0;
        for (itColList = m_spColSetList->begin();
             itColList != m_spColSetList->end();
             ++itColList)
        {
            itColList->m_dwRank = dwRank++;
        }
    }
    else // if (persistor.IsLoading())
    {
        m_spColSetList->clear();
        m_spSnapinsMap->clear();
    }

    SnapinToColSetIDMapPersistor childPersisot(*m_spSnapinsMap, *m_spColSetList);
    childPersisot.Persist(persistor);

    if (persistor.IsStoring())
        m_bDirty = FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     OnInitDialog
//
//  Synopsis:   Initialize the Columns dialog.
//
//  Arguments:
//
//  History:    11-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
LRESULT CColumnsDlg::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_btnAdd      = ::GetDlgItem(m_hWnd, IDC_ADD_COLUMNS);
    m_btnRemove   = ::GetDlgItem(m_hWnd, IDC_REMOVE_COLUMNS);
    m_btnRestoreDefaultColumns    = ::GetDlgItem(m_hWnd, IDC_RESTORE_DEFAULT_COLUMNS);
    m_btnMoveUp   = ::GetDlgItem(m_hWnd, IDC_MOVEUP_COLUMN);
    m_btnMoveDown = ::GetDlgItem(m_hWnd, IDC_MOVEDOWN_COLUMN);

    m_HiddenColList.Attach(::GetDlgItem(m_hWnd, IDC_HIDDEN_COLUMNS));
    m_DisplayedColList.Attach(::GetDlgItem(m_hWnd, IDC_DISPLAYED_COLUMNS));

    m_bUsingDefaultColumnSettings = (*m_pColumnInfoList == m_DefaultColumnInfoList);

    InitializeLists();
    EnableUIObjects();

    return 0;
}


//+-------------------------------------------------------------------
//
//  Member:     OnOK
//
//  Synopsis:   Get the hidden and visible columns.
//
//  Arguments:
//
//  History:    11-16-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
LRESULT CColumnsDlg::OnOK (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (! m_bDirty) // column settings are not modified
    {
        EndDialog (IDCANCEL);

        return 1;
    }

    if (m_bUsingDefaultColumnSettings)
    {
        EndDialog(IDC_RESTORE_DEFAULT_COLUMNS);
        return 1;
    }

    ASSERT(NULL != m_pColumnInfoList);
    if (NULL == m_pColumnInfoList)
        return 0;

    WTL::CString strColumnName;
    CColumnInfoList::iterator   it;
    CColumnInfo                 colinfo;

    // Get the strings from Hidden_List_Box.
    // These cols are to be hidden. So put them first in the list.
    int cItems =    m_HiddenColList.GetCount();
    for (int i = 0; i < cItems; i++)
    {
        // Get the text from list box
        int nRet = m_HiddenColList.GetText(i, strColumnName);
        if (LB_ERR == nRet)
        {
            ASSERT(FALSE);
            break;
        }

        // Use the string to get the actual index of the column.
        int nIndex = GetColIndex(strColumnName);
        if (0 > nIndex )
        {
            ASSERT(FALSE);
            break;
        }

        // With the index get the column and insert it at beginning.
        it = find_if(m_pColumnInfoList->begin(), m_pColumnInfoList->end(),
                     bind2nd(ColPosCompare(), nIndex));

        if (it == m_pColumnInfoList->end())
        {
            ASSERT(FALSE);
            break;
        }

        // Set the *it flag to be hidden. Insert it at beginning.
        colinfo = *it;
        colinfo.SetColHidden();

        // Move the item to the head of the list
        m_pColumnInfoList->erase(it);
        m_pColumnInfoList->push_front(colinfo);
    }

    // Then get the strings from DisplayedColumns_List_Box.
    cItems = m_DisplayedColList.GetCount();
    for (i = 0; i < cItems; i++)
    {
        // Get the text from list box
        int nRet = m_DisplayedColList.GetText(i, strColumnName);
        if (LB_ERR == nRet)
        {
            ASSERT(FALSE);
            break;
        }

        // Use the column name to get the column index.
        int nIndex = GetColIndex(strColumnName);

        if (0 > nIndex )
        {
            ASSERT(FALSE);
            break;
        }

        // Get the CColumnInfo and insert at end.
        it = find_if(m_pColumnInfoList->begin(), m_pColumnInfoList->end(),
                     bind2nd(ColPosCompare(), nIndex));

        if (it == m_pColumnInfoList->end())
            break;

        colinfo = *it;

        if (colinfo.IsColHidden())
        {
            // If hidden column is made visible
            // reset the hidden flag and set the width
            // to auto_width.
            colinfo.SetColHidden(false);
            if (colinfo.GetColWidth() <= 0)
                colinfo.SetColWidth(AUTO_WIDTH);
        }

        // Move it to the end of the list.
        m_pColumnInfoList->erase(it);
        m_pColumnInfoList->push_back(colinfo);
    }

    EndDialog (IDOK);
    return 1;
}

LRESULT CColumnsDlg::OnCancel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog (IDCANCEL);
    return 0;
}


LRESULT CColumnsDlg::OnMoveUp (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MoveItem(TRUE);

    return 0;
}

LRESULT CColumnsDlg::OnMoveDown (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MoveItem(FALSE);

    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     OnAdd
//
//  Synopsis:   Adds a column to displayed columns list by removing
//              the currently selected column from hidden column list.
//
//  Arguments:
//
//--------------------------------------------------------------------
LRESULT CColumnsDlg::OnAdd (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // First remove from hidden column list.
    int nCurSel = m_HiddenColList.GetCurSel();

    WTL::CString strColumnName;
    int nRet = m_HiddenColList.GetText(nCurSel, strColumnName);
    if (LB_ERR == nRet)
    {
        ASSERT(FALSE);
        return 0;
    }

    m_HiddenColList.DeleteString(nCurSel);

    // now add it to Displayed column list.
    m_DisplayedColList.AddString(strColumnName);
    SetDirty();

    if (nCurSel > m_HiddenColList.GetCount()-1)
        nCurSel = m_HiddenColList.GetCount()-1;

    m_HiddenColList.SetCurSel(nCurSel);
    m_DisplayedColList.SelectString(0, strColumnName);

    SetListBoxHScrollSize();
    EnableUIObjects();
    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     OnRemove
//
//  Synopsis:   Removes the currently selected column from displayed
//              columns list by removing and adds it to hidden column list.
//
//  Arguments:
//
//--------------------------------------------------------------------
LRESULT CColumnsDlg::OnRemove (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Get the currently selected item in Displayed Columns list.
    int nCurSel = m_DisplayedColList.GetCurSel();

    WTL::CString strColumnName;
    int nRet = m_DisplayedColList.GetText(nCurSel, strColumnName);
    if (LB_ERR == nRet)
    {
        ASSERT(FALSE);
        return 0;
    }

    // If column zero do not hide it.
    if (0 == GetColIndex(strColumnName))
        return 0;

    m_DisplayedColList.DeleteString(nCurSel);

    // Add it to hidden column list.
    m_HiddenColList.AddString(strColumnName);
    SetDirty();

    if (nCurSel > m_DisplayedColList.GetCount()-1)
        nCurSel = m_DisplayedColList.GetCount()-1;

    m_DisplayedColList.SetCurSel(nCurSel);
    m_HiddenColList.SelectString(0, strColumnName);

    EnableUIObjects();

    SetListBoxHScrollSize();

    return 0;
}

LRESULT CColumnsDlg::OnRestoreDefaultColumns (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DECLARE_SC(sc, TEXT("CColumnsDlg::OnRestoreDefaultColumns"));

    // Get the default data and populate the columns dialog.
    *m_pColumnInfoList = m_DefaultColumnInfoList;

    SetUsingDefaultColumnSettings();

    InitializeLists();
    EnableUIObjects();

	// Button is disabled so put the focus on the dialog.
    SetFocus();

    return 0;
}


LRESULT CColumnsDlg::OnSelChange (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EnableUIObjects();

    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     MoveItem
//
//  Synopsis:   Moves an item in the displayed columns list up or down.
//              The up down order is same as column visible order from
//              left to right.
//
//  Arguments:  [BOOL] - up or down.
//
//--------------------------------------------------------------------
void CColumnsDlg::MoveItem (BOOL bMoveUp)
{
    int nCurSel = m_DisplayedColList.GetCurSel();

    WTL::CString strColumnName;
    int nRet = m_DisplayedColList.GetText(nCurSel, strColumnName);
    if (LB_ERR == nRet)
    {
        ASSERT(FALSE);
        return;
    }

    m_DisplayedColList.DeleteString(nCurSel);
    if (bMoveUp)
        m_DisplayedColList.InsertString(nCurSel-1, strColumnName);
    else
        m_DisplayedColList.InsertString(nCurSel+1, strColumnName);

    m_DisplayedColList.SelectString(0, strColumnName);

    SetDirty();

    EnableUIObjects();
    return;
}

//+-------------------------------------------------------------------
//
//  Member:     EnableUIObjects
//
//  Synopsis:   Enable/Disable the UI objects in the dialog.
//
//  Arguments:
//
//--------------------------------------------------------------------
void CColumnsDlg::EnableUIObjects()
{
    int  curselAvailable    = m_HiddenColList.GetCurSel();
    int  curselShow         = m_DisplayedColList.GetCurSel();
    int  cItems             = m_HiddenColList.GetCount();
    BOOL bEnableAdd         = ((curselAvailable != LB_ERR) && (curselAvailable || cItems)) ? TRUE: FALSE;
    BOOL bEnableRemove      = ((curselShow != LB_ERR)) ? TRUE: FALSE;
    BOOL bEnableMoveUp      = ((curselShow != LB_ERR) && curselShow) ? TRUE: FALSE;
    cItems                  = m_DisplayedColList.GetCount();
    BOOL bEnableMoveDown    = cItems && (curselShow != LB_ERR) && (cItems!=curselShow+1);

    BOOL bRet = FALSE;

    bRet = m_btnAdd.EnableWindow(bEnableAdd);
    bRet = m_btnRemove.EnableWindow(bEnableRemove);
    bRet = m_btnMoveUp.EnableWindow(bEnableMoveUp);
    bRet = m_btnMoveDown.EnableWindow(bEnableMoveDown);

    // Enable restore defaults only if columns are already customized before bringing the dialog
    bRet = m_btnRestoreDefaultColumns.EnableWindow( (!m_bUsingDefaultColumnSettings));

    // Disable Remove/Move Up/Move Down buttons for Col zero.
    int nCurSel = m_DisplayedColList.GetCurSel();

    WTL::CString strColumnName;
    int nRet = m_DisplayedColList.GetText(nCurSel, strColumnName);
    if (LB_ERR == nRet)
    {
        ASSERT(FALSE);
        return;
    }

    if (0 == GetColIndex(strColumnName)) // Column 0
        m_btnRemove.EnableWindow(FALSE);
}

int CColumnsDlg::GetColIndex(LPCTSTR lpszColName)
{
    TStringVector::iterator itStrVec1;

    USES_CONVERSION;

    itStrVec1 = find(m_pStringVector->begin(), m_pStringVector->end(), lpszColName);

    if (m_pStringVector->end() != itStrVec1)
        return (itStrVec1 - m_pStringVector->begin());
    else
        // Unknown column
        return -1;
}

//+-------------------------------------------------------------------
//
//  Member:     SetListBoxHorizontalScrollbar
//
//  Synopsis:   For the given list box enumerate the strings added and find
//              the largest string. Calculate scrollbar size for this string
//              and set it.
//
//  Arguments:  [listBox] - Given list box.
//
//--------------------------------------------------------------------
void CColumnsDlg::SetListBoxHorizontalScrollbar(WTL::CListBox& listBox)
{
    int          dx=0;
    WTL::CDC     dc(listBox.GetWindowDC());
    if (dc.IsNull())
        return;

    // Find the longest string in the list box.
    for (int i=0;i < listBox.GetCount();i++)
    {
	    WTL::CString str;
        int nRet = listBox.GetText( i, str );
        if (nRet == LB_ERR)
            return;

	    WTL::CSize   sz;
        if (! dc.GetTextExtent(str, str.GetLength(), &sz))
            return;

        if (sz.cx > dx)
            dx = sz.cx;
    }

    // Set the horizontal extent so every character of all strings
    // can be scrolled to.
    listBox.SetHorizontalExtent(dx);

    return;
}

/* CColumnsDlg::InitializeLists
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *      void
 */
void CColumnsDlg::InitializeLists()
{
    CColumnInfoList::iterator it;
    int j = 0;

    if (!m_pColumnInfoList)
    {
        ASSERT(FALSE);
        return;
    }

    m_HiddenColList.ResetContent();
    m_DisplayedColList.ResetContent();

    USES_CONVERSION;
    for (it = m_pColumnInfoList->begin(); it != m_pColumnInfoList->end(); ++it)
    {
        if (it->IsColHidden())
        {
            m_HiddenColList.AddString(m_pStringVector->at(it->GetColIndex()).data());
        }
        else
        {
            m_DisplayedColList.InsertString(j++, m_pStringVector->at(it->GetColIndex()).data());
        }
    }

    m_DisplayedColList.SetCurSel(m_DisplayedColList.GetCount()-1);
    m_HiddenColList.SetCurSel(m_HiddenColList.GetCount()-1);

    SetListBoxHScrollSize();
}

//+-------------------------------------------------------------------
//
//  Member:     CColumnSetID::Persist
//
//  Synopsis:   Persists object data
//
//  Arguments:
//
//  History:    10-10-1999   AudriusZ   Created
//
//--------------------------------------------------------------------
void CColumnSetID::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("CColumnSetID::Persist"));

    CXMLAutoBinary binary;
    if (persistor.IsStoring() && m_vID.size()) // fill only if have data
    {
        sc = binary.ScAlloc(m_vID.size());
        if (sc)
            sc.Throw();

        CXMLBinaryLock sLock(binary); // will unlock in destructor

        LPBYTE pData = NULL;
        sc = sLock.ScLock(&pData);
        if (sc)
            sc.Throw();

        sc = ScCheckPointers(pData, E_UNEXPECTED);
        if (sc)
            sc.Throw();

        std::copy(m_vID.begin(), m_vID.end(), pData);
    }
    persistor.PersistAttribute(XML_ATTR_COLUMN_SET_ID_PATH, binary);
    if (persistor.IsLoading())
    {
        m_vID.clear();

        if (binary.GetSize())
        {
            CXMLBinaryLock sLock(binary); // will unlock in destructor

            LPBYTE pData = NULL;
            sc = sLock.ScLock(&pData);
            if (sc)
                sc.Throw();

            sc = ScCheckPointers(pData, E_UNEXPECTED);
            if (sc)
                sc.Throw();

            m_vID.insert(m_vID.end(), pData, pData + binary.GetSize());
        }
    }

   persistor.PersistAttribute(XML_ATTR_COLUMN_SET_ID_FLAGS, m_dwFlags);
}


/***************************************************************************\
 *
 * METHOD:  ViewToColSetDataMapPersistor::Persist
 *
 * PURPOSE: called by the base class to create and persist the new element
 *
 * PARAMETERS:
 *    CPersistor& persistor - [in] persistor from which to persist new element
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void ViewToColSetDataMapPersistor::Persist(CPersistor &persistor)
{
    if (persistor.IsStoring())
    {
        // iterate and save all elements as linear list
        ViewToColSetDataMap::iterator it;
        for (it = m_map.begin(); it != m_map.end(); ++it)
        {
            // we will sneak under child's element to persist the KEY value as an attribute
            // of the child element. To do that we use tag got from _GetXMLType() of the child
            CPersistor persistorChild(persistor, it->second->GetXMLType());

            int view_id = it->first; // just to cast constness out (we do not have const Persist)
            persistorChild.PersistAttribute(XML_ATTR_COLUMN_SET_ID_VIEW, view_id);
            // note: we are asking the child to persist on the same level.
            // thats to save on depth
            it->second->Persist(persistorChild);
        }
    }
    else
    {
        // use base class to read. it will call OnNewElement for each found
        m_map.clear();
        XMLListCollectionBase::Persist(persistor);
    }
}

/***************************************************************************\
 *
 * METHOD:  ViewToColSetDataMapPersistor::OnNewElement
 *
 * PURPOSE: called by the base class to create and persist the new element
 *
 * PARAMETERS:
 *    CPersistor& persistor - [in] persistor from which to persist new element
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void ViewToColSetDataMapPersistor::OnNewElement(CPersistor& persistor)
{
    // we will sneak under child's element to persist the KEY value as an attribute
    // of the child element. To do that we use tag got from GetXMLType() of the child
    CColumnSetData setData;
    CPersistor persistorChild(persistor, setData.GetXMLType());

    // read the key value from the child element
    int view_id = 0;
    persistorChild.PersistAttribute(XML_ATTR_COLUMN_SET_ID_VIEW, view_id);

    // insert value to the list
    ColSetDataList::iterator it = m_list.insert(m_list.end(), setData);
    // ad list iterator to the map
    m_map[view_id] = it;

    // persist contents of the list item
    it->Persist(persistorChild);
}

/***************************************************************************\
 *
 * METHOD:  ColSetIDToViewTableMapPersistor::Persist
 *
 * PURPOSE: called as a request for the object to persist it's data
 *
 * PARAMETERS:
 *    CPersistor &persistor [in] persistor to persist to/from
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void ColSetIDToViewTableMapPersistor::Persist(CPersistor &persistor)
{
    if (persistor.IsStoring())
    {
        // iterate and save all elements as linear list
        ColSetIDToViewTableMap::iterator it;
        for (it = m_map.begin(); it != m_map.end(); ++it)
        {
            // we will sneak under child's element to persist the KEY value as an attribute
            // of the child element. To do that we use tag got from _GetXMLType() of the child
            CPersistor persistorChild(persistor, ViewToColSetDataMapPersistor::_GetXMLType());
            CColumnSetID& rID = *const_cast<CColumnSetID *>(&it->first);
            rID.Persist(persistorChild);

            // note: we are asking the child to persist on the same level.
            // thats to save on depth
            ViewToColSetDataMapPersistor mapPersistor(it->second, m_list);
            mapPersistor.Persist(persistorChild);
        }
    }
    else
    {
        // use base class to read. it will call OnNewElement for each found
        m_map.clear();
        XMLListCollectionBase::Persist(persistor);
    }
}

/***************************************************************************\
 *
 * METHOD:  ColSetIDToViewTableMapPersistor::OnNewElement
 *
 * PURPOSE: called by the base class to create and persist the new element
 *
 * PARAMETERS:
 *    CPersistor& persistor - [in] persistor from which to persist new element
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void ColSetIDToViewTableMapPersistor::OnNewElement(CPersistor& persistor)
{
    // we will sneak under child's element to persist the KEY value as an attribute
    // of the child element. To do that we use tag got from _GetXMLType() of the child
    CPersistor persistorChild(persistor, ViewToColSetDataMapPersistor::_GetXMLType());

    // read the key value from the child element
    // note that we are forcing CColumnSetID to share the same element,
    // therefore we are not using persistor.Persist()
    CColumnSetID ID;
    ID.Persist(persistorChild);

    // insert the new element into the map
    ViewToColSetDataMap &rMap = m_map[ID];

    // create the wrapper on inserted map value
    // (pass a list to wrapper. we actually have it [list] for this only reason)
    ViewToColSetDataMapPersistor mapPersistor(m_map[ID], m_list);

    // ask wrapper to read the rest
    mapPersistor.Persist(persistorChild);
}

/***************************************************************************\
 *
 * METHOD:  SnapinToColSetIDMapPersistor::Persist
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    CPersistor &persistor
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void SnapinToColSetIDMapPersistor::Persist(CPersistor &persistor)
{
    DECLARE_SC(sc, TEXT("SnapinToColSetIDMapPersistor::Persist"));

    if (persistor.IsStoring())
    {
        // prior-to-save cleanup
        sc = ScPurgeUnusedColumnData();
        if (sc)
            sc.Throw();

        // iterate and save all elements as linear list
        SnapinToColSetIDMap::iterator it;
        for (it = m_map.begin(); it != m_map.end(); ++it)
        {
            // we will sneak under child's element to persist the KEY value as an attribute
            // of the child element. To do that we use tag got from _GetXMLType() of the child
            CPersistor persistorChild(persistor, ColSetIDToViewTableMapPersistor::_GetXMLType());

            // write the key value.
             // just to cast constness out (we do not have const Persist)
            GUID& guid = *const_cast<GUID *>(&it->first);
            persistorChild.PersistAttribute(XML_ATTR_COLUMN_INFO_SNAPIN, guid);

            // create a wrapper on the value (which is also a map)
            // (pass a list to wrapper. though it's not used for storing)
            ColSetIDToViewTableMapPersistor mapPersistor(it->second, m_list);

            // persist the wrapper
            mapPersistor.Persist(persistorChild);
        }
    }
    else
    {
        // use base class to read. it will call OnNewElement for each found
        m_map.clear();
        XMLListCollectionBase::Persist(persistor);
    }
}

/***************************************************************************\
 *
 * METHOD:  SnapinToColSetIDMapPersistor::OnNewElement
 *
 * PURPOSE: called by the base class to create and persist the new element
 *
 * PARAMETERS:
 *    CPersistor& persistor - [in] persistor from which to persist new element
 *
 * RETURNS:
 *    void
 *
 * see "Data structures used to persist column information" comment
 * int file colwidth.h for more information
\***************************************************************************/
void SnapinToColSetIDMapPersistor::OnNewElement(CPersistor& persistor)
{
    // we will sneak under child's element to persist the KEY value as an attribute
    // of the child element. To do that we use tag got from _GetXMLType() of the child
    CPersistor persistorChild(persistor, ColSetIDToViewTableMapPersistor::_GetXMLType());

    GUID guid;
    // read the key value
    persistorChild.PersistAttribute(XML_ATTR_COLUMN_INFO_SNAPIN, guid);

    // insert the new element into the map
    ColSetIDToViewTableMap &rMap = m_map[guid];

    // create the wrapper on inserted map value
    // (pass a list to wrapper. we actually have it [list] for this only reason)
    ColSetIDToViewTableMapPersistor mapPersistor(rMap, m_list);

    // ask wrapper to read the rest
    mapPersistor.Persist(persistorChild);
}

/***************************************************************************\
 *
 * METHOD:  SnapinToColSetIDMapPersistor::ScPurgeUnusedColumnData
 *
 * PURPOSE: prior-to-save cleanup. removes unused snapin entries
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC SnapinToColSetIDMapPersistor::ScPurgeUnusedColumnData()
{
    DECLARE_SC(sc, TEXT("SnapinToColSetIDMapPersistor::ScPurgeUnusedColumnData"));

    // get the scopetree pointer
    CScopeTree *pScopeTree = CScopeTree::GetScopeTree();

    // check it
    sc = ScCheckPointers(pScopeTree, E_UNEXPECTED);
    if (sc)
        return sc;

    // iterate and remove unused entries
    SnapinToColSetIDMap::iterator it = m_map.begin();
    while (it != m_map.end())
    {
        // ask the scope tree if snapin is in use
        BOOL bInUse = FALSE;
        sc = pScopeTree->IsSnapinInUse(it->first, &bInUse);
        if (sc)
            return sc;

        // act depending on usage
        if (bInUse)
        {
            ++it;   // skip also the stuff currently in use
        }
        else
        {
            // to the trash can

            ColSetIDToViewTableMap& colSets = it->second;

            // Iterate thro' all colset ids of this snapin.
            ColSetIDToViewTableMap::iterator itColumnSetIDMap = colSets.begin();

            while(itColumnSetIDMap != colSets.end())
            {
                // Get the view map

                ViewToColSetDataMap& viewIDMap = itColumnSetIDMap->second;
                ViewToColSetDataMap::iterator itViewIDMap = viewIDMap.begin();

                // Iterate thro' all views and remove entries
                while (itViewIDMap  != viewIDMap.end())
                {
                    m_list.erase(/*(ItColSetDataList)*/itViewIDMap->second);
                    itViewIDMap = viewIDMap.erase(itViewIDMap);
                }

                itColumnSetIDMap = colSets.erase(itColumnSetIDMap);
            }

            it = m_map.erase(it);
        }

    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\cmenu.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cmenu.cpp
//
//--------------------------------------------------------------------------

// cmenu.cpp : Implementation of IContextMenuProvider and DLL registration.

#include "stdafx.h"
#include "oncmenu.h"
#include "menuitem.h"
#include "constatbar.h"
#include "regutil.h"
#include "moreutil.h"
#include "multisel.h"
#include "cmenuinfo.h"
#include "conview.h"
#include "scopndcb.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*+-------------------------------------------------------------------------*
 * class CNativeExtendContextMenu
 *
 *
 * PURPOSE: implements IExtendContextMenu by forwarding calls to CContextMenu
 *          but does not affect lifetime of CContextMenu
 *
 *+-------------------------------------------------------------------------*/
class CNativeExtendContextMenu :
    public CTiedComObject<CContextMenu>,
    public CComObjectRoot,
    public IExtendContextMenu  // this is used so that menu items can be executed uniformly.
{
protected:
    typedef CNativeExtendContextMenu ThisClass;
    typedef CContextMenu CMyTiedObject;

public:

    // com entry points
    BEGIN_COM_MAP(ThisClass)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(ThisClass)

    // IExtendContexMenu methods
    MMC_METHOD3( AddMenuItems, LPDATAOBJECT, LPCONTEXTMENUCALLBACK, long * );
    MMC_METHOD2( Command, long, LPDATAOBJECT );
};

//############################################################################
//############################################################################
//
//  Implementation of methods on CNodeInitObject that
//  forward to CContextMenu
//
//############################################################################
//############################################################################

CContextMenu *
CNodeInitObject::GetContextMenu()
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::GetContextMenu"));

    if(m_spContextMenu == NULL)
    {
        // check internal pointers
        sc = ScCheckPointers(m_spScopeTree, E_UNEXPECTED);
        if (sc)
            return NULL;

        // get scopetree and call back pointers
        CScopeTree* const pScopeTree =
            dynamic_cast<CScopeTree*>(m_spScopeTree.GetInterfacePtr());

        // if the menu is created by component data, it does not have the node.
        // in that case menu is created by passing NULL pointers to some parameters.
        // Menu should never need those pointers in the mentioned case
        CNodeCallback* pNodeCallback = NULL;
        if ( m_pNode != NULL )
        {
            // check other required pointers
            sc = ScCheckPointers(m_pNode->GetViewData(), E_UNEXPECTED);
            if (sc)
                return NULL;

            pNodeCallback =
                dynamic_cast<CNodeCallback *>(m_pNode->GetViewData()->GetNodeCallback());
        }

        // create context menu
        CContextMenu *pContextMenu = NULL;
        sc = CContextMenu::ScCreateContextMenuForScopeNode(m_pNode, pNodeCallback, pScopeTree,
                                                           &m_spContextMenu, pContextMenu);
        if (sc)
            return NULL;

        sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
        if (sc)
            return NULL;

        return pContextMenu;
    }

    return dynamic_cast<CContextMenu *>(m_spContextMenu.GetInterfacePtr());
}


STDMETHODIMP
CNodeInitObject::AddItem(CONTEXTMENUITEM * pItem)
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::AddItem"));

    CContextMenu *pContextMenu = GetContextMenu();

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->ScAddItem(pItem, true/*bPassCommandBackToSnapin*/);

    return sc.ToHr();
}



STDMETHODIMP
CNodeInitObject::EmptyMenuList ()
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::EmptyMenuList"));

    if (m_spContextMenu == NULL)
        return S_OK;

    CContextMenu *pContextMenu = GetContextMenu();

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->EmptyMenuList();

    return sc.ToHr();
}

STDMETHODIMP
CNodeInitObject::AddThirdPartyExtensionItems(IDataObject* piDataObject )
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::AddThirdPartyExtensionItems"));

    CContextMenu *pContextMenu = GetContextMenu();

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->AddThirdPartyExtensionItems(piDataObject);

    return sc.ToHr();
}

STDMETHODIMP
CNodeInitObject::AddPrimaryExtensionItems(IUnknown* piCallback, IDataObject* piDataObject )
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::AddPrimaryExtensionItems"));

    CContextMenu *pContextMenu = GetContextMenu();

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    sc = pContextMenu->AddPrimaryExtensionItems(piCallback, piDataObject);

    return sc.ToHr();
}

STDMETHODIMP
CNodeInitObject::ShowContextMenu(HWND hwndParent, LONG xPos, LONG yPos, LONG* plSelected)
{
    DECLARE_SC(sc, TEXT("CNodeInitObject::ShowContextMenu"));

    CContextMenu *pContextMenu = GetContextMenu();

    sc = ScCheckPointers(pContextMenu, E_UNEXPECTED);
    if(sc)
        return sc.ToHr();

    pContextMenu->SetStatusBar(GetStatusBar()); // wire up the status bar.

    sc = pContextMenu->ShowContextMenu(hwndParent, xPos, yPos, plSelected);

    return sc.ToHr();
}


//############################################################################
//############################################################################
//
// Implementation of CCommandSink
//
//############################################################################
//############################################################################
/*+-------------------------------------------------------------------------*
 * class CCommandSink
 *
 *
 * PURPOSE:
 *
 *+-------------------------------------------------------------------------*/
class CCommandSink : public CWindowImpl<CCommandSink>
{
// Construction
public:
    CCommandSink( CContextMenu& nodemgr, WTL::CMenu& menu, CConsoleStatusBar * pStatusbar);
    virtual ~CCommandSink();
    BOOL Init();


    LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    BEGIN_MSG_MAP(CCommandSink)
        MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
    END_MSG_MAP()

private:
    CContextMenu& m_nodemgr;
    const WTL::CMenu& m_menu;
    CConsoleStatusBar * m_pStatusBar;
};

CCommandSink::CCommandSink( CContextMenu& nodemgr, WTL::CMenu& menu, CConsoleStatusBar * pStatusbar)
:   m_nodemgr( nodemgr ),
    m_menu( menu ),
    m_pStatusBar(pStatusbar)
{
}

CCommandSink::~CCommandSink()
{
    /*
     * clear the status bar text, if there's any there.
     */
    if (m_pStatusBar != NULL)
        m_pStatusBar->ScSetStatusText (NULL);
}

BOOL CCommandSink::Init()
{

    RECT rcPos = {0,0,0,0};

    Create(NULL, rcPos, _T("ACFx:CxtMenuSink"), WS_POPUP);

    return TRUE;
}



LRESULT CCommandSink::OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    UINT nItemID = (UINT) LOWORD(wParam);   // menu item or submenu index
    UINT nFlags = (UINT) HIWORD(wParam); // menu flags
    HMENU hSysMenu = (HMENU) lParam;          // handle of menu clicked
    TRACE(_T("CCommandSink::OnMenuSelect: nItemID=%d, nFlags=0x%X, hSysMenu=0x%X\n"), nItemID, nFlags, hSysMenu);

    if ( 0xFFFF == nFlags && NULL == hSysMenu )
        return 0; // as per Win32 ProgRef
    if ( 0 == nItemID && !(nFlags & MF_POPUP) )
        return 0; // no item selected

    CMenuItem* pmenuitem = NULL;
    if (nFlags & MF_POPUP)
    {
        if ( hSysMenu == m_menu.m_hMenu )
        {
            // We assume menu's cannot be longer than 256 chars
            TCHAR szMenu[256];
            MENUITEMINFO  menuItemInfo;
            menuItemInfo.cbSize = sizeof(MENUITEMINFO);
            menuItemInfo.fMask = MIIM_TYPE;
            menuItemInfo.fType = MFT_STRING;
            menuItemInfo.cch   = 256;
            menuItemInfo.dwTypeData = szMenu;
            ::GetMenuItemInfo(hSysMenu, nItemID, TRUE, &menuItemInfo);
            ASSERT(256 >= (menuItemInfo.cch+1));
            pmenuitem = m_nodemgr.FindNthItemInSubmenu( NULL, nItemID, szMenu );
        }
        else
            pmenuitem = m_nodemgr.FindNthItemInSubmenu( hSysMenu, nItemID, NULL );
    }
    else
        pmenuitem = m_nodemgr.FindMenuItem( nItemID );
    if ( NULL == pmenuitem )
    {
        ASSERT( FALSE );
        return 0;
    }

    if(m_pStatusBar)
        m_pStatusBar->ScSetStatusText( pmenuitem->GetMenuItemStatusBarText() );
    return 0;
}

//############################################################################
//############################################################################
//
// CContextMenu methods - continued from oncmenu.cpp
// These methods were originally in this file and I dont want to move
// them and break history - vivekj
//
//############################################################################
//############################################################################

//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::EmptyMenuList
//
//  Synopsis:    Clear the context menu.
//
//  Arguments:
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CContextMenu::EmptyMenuList ()
{
    DECLARE_SC(sc, _T("IContextMenuProvider::EmptyMenuList"));

    START_CRITSEC_BOTH

    delete m_pmenuitemRoot;
    m_pmenuitemRoot = NULL;
    m_nNextMenuItemID = MENUITEM_BASE_ID;

    ReleaseSnapinList();
    m_fAddedThirdPartyExtensions = FALSE;
    m_MaxPrimaryOwnerID = OWNERID_PRIMARY_MIN;
    m_MaxThirdPartyOwnerID = OWNERID_THIRD_PARTY_MIN;
    m_CurrentExtensionOwnerID = OWNERID_NATIVE;

    m_fPrimaryInsertionFlags = 0;
    m_fThirdPartyInsertionFlags = 0;

    END_CRITSEC_BOTH

    return sc.ToHr();
}


/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::RemoveAccelerators
 *
 * PURPOSE: Removes the accelerators from a context menu item name
 *
 * PARAMETERS:
 *    CStr & str :
 *
 * RETURNS:
 *    void
 *
 *+-------------------------------------------------------------------------*/
void
RemoveAccelerators(tstring &str)
{
    // in some locales , the accelerators appear at the end eg:  Start (&s). Therefore, remove anything after (&
    int i =  str.find(TEXT( "(&" ));

    if (i != tstring::npos)
        str.erase (i); // remove the waste left over after and including the string "(&"

    tstring::iterator itToTrim = std::remove (str.begin(), str.end(), _T('&'));

    // remove the waste left over after removing accelerator markers
    str.erase (itToTrim, str.end());
}


//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::AddItem
//
//  Synopsis:    Add a menu item to context menu.
//
//  Arguments:   CONTEXTMENUITEM*
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CContextMenu::AddItem( CONTEXTMENUITEM* pItem )
{
    DECLARE_SC(sc, _T("IContextMenuCallback::AddItem"));

    return ( sc = ScAddItem( pItem ) ).ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::ScAddItem
//
//  Synopsis:    Add a menu item to context menu.
//
//  Arguments:   CONTEXTMENUITEM*
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CContextMenu::ScAddItem( CONTEXTMENUITEM* pItem, bool bPassCommandBackToSnapin /*= false*/ )
{
    DECLARE_SC(sc, _T("IContextMenuCallback::ScAddItem"));

    if (NULL == pItem)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL CONTEXTMENUITEM ptr"), sc);
        return sc;
    }


    // added a non-langugage independent context menu item. Cook up a language independent ID.
    // get the menu text and strip out accelerator markers
    tstring strLanguageIndependentName;

    if(pItem->strName)
    {
        USES_CONVERSION;
        strLanguageIndependentName = OLE2CT(pItem->strName);
        RemoveAccelerators(strLanguageIndependentName);
    }

#ifdef DBG
    TRACE(_T("CContextMenu::AddItem name \"%ls\" statusbartext \"%ls\" commandID %ld submenuID %ld flags %ld special %ld\n"),
        SAFEDBGBSTR(pItem->strName),
        SAFEDBGBSTR(pItem->strStatusBarText),
        pItem->lCommandID,
        pItem->lInsertionPointID,
        pItem->fFlags,
        pItem->fSpecialFlags);
#endif

    // leaves critsec claim for DoAddMenuItem

    USES_CONVERSION;
    sc = DoAddMenuItem(   OLE2CT(pItem->strName),
                          OLE2CT(pItem->strStatusBarText),
                          strLanguageIndependentName.data(),
                          pItem->lCommandID,
                          pItem->lInsertionPointID,
                          pItem->fFlags,
                          pItem->fSpecialFlags,
                          m_CurrentExtensionOwnerID,
                          NULL,
                          bPassCommandBackToSnapin );

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::AddItem
//
//  Synopsis:    Add a menu item to context menu.
//
//  Arguments:   CONTEXTMENUITEM2* - includes a language independent name
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CContextMenu::AddItem( CONTEXTMENUITEM2* pItem )
{
    DECLARE_SC(sc, _T("IContextMenuCallback::AddItem"));

    if (NULL == pItem)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL CONTEXTMENUITEM ptr"), sc);
        return sc.ToHr();
    }

    // No language-independent-id ?
    if ( (pItem->strLanguageIndependentName == NULL) ||
         (wcscmp(pItem->strLanguageIndependentName, L"") == 0) )
    {
        // and it is neither a separator nor insertion point.
        if ( !(MF_SEPARATOR & pItem->fFlags) &&
             !(CCM_SPECIAL_INSERTION_POINT & pItem->fSpecialFlags) )
        {
            sc = E_INVALIDARG;
            TraceSnapinError(_T("NULL language-indexpendent-id passed"), sc);
            return sc.ToHr();
        }
    }

#ifdef DBG
    TRACE(_T("CContextMenu::AddItem name \"%ls\" statusbartext \"%ls\" languageIndependentName \"%ls\" commandID %ld submenuID %ld flags %ld special %ld\n"),
        SAFEDBGBSTR(pItem->strName),
        SAFEDBGBSTR(pItem->strStatusBarText),
        SAFEDBGBSTR(pItem->strLanguageIndependentName),
        pItem->lCommandID,
        pItem->lInsertionPointID,
        pItem->fFlags,
        pItem->fSpecialFlags
        );
#endif

    // leaves critsec claim for DoAddMenuItem

    USES_CONVERSION;
    sc = DoAddMenuItem(   OLE2CT(pItem->strName),
                          OLE2CT(pItem->strStatusBarText),
                          OLE2CT(pItem->strLanguageIndependentName),
                          pItem->lCommandID,
                          pItem->lInsertionPointID,
                          pItem->fFlags,
                          pItem->fSpecialFlags,
                          m_CurrentExtensionOwnerID );


    return sc.ToHr();
}



//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::AddPrimaryExtensionItems
//
//  Synopsis:    Ask primary snapin to add menu items.
//
//  Arguments:   [piExtension]
//               [piDataobject]
//
//  Note:        claims critsec
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CContextMenu::AddPrimaryExtensionItems (
                IUnknown*    piExtension,
                IDataObject* piDataObject )
{
    DECLARE_SC(sc, _T("IContextMenuProvider::AddPrimaryExtensionItems"));

    if (NULL == piExtension)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL IUnknown ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == piDataObject)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL IDataObject ptr"), sc);
        return sc.ToHr();
    }

    // control reentrant access to this
    if (!m_fAddingPrimaryExtensionItems)
    {
        m_fAddingPrimaryExtensionItems = true;

        //HRESULT hr = ExtractObjectTypeCStr( piDataObject, &m_strObjectGUID );
        //ASSERT( SUCCEEDED(hr) );

        START_CRITSEC_SNAPIN;
        sc = ScAddSnapinToList_IUnknown( piExtension, piDataObject, m_MaxPrimaryOwnerID++ );
        END_CRITSEC_SNAPIN;

        m_fAddingPrimaryExtensionItems = false;

        // Clear view menu allowed flag
        // A second call may be made to AddPrimaryExtensionItems to handle the other item
        // types only, so the view items must be disabled after the first call.
        m_fPrimaryInsertionFlags &= ~CCM_INSERTIONALLOWED_VIEW;
        if (sc)
            return sc.ToHr();
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:      CContextMenu::AddThirdPartyExtensionItems
//
//  Synopsis:    Ask extensions to add comtext menu items.
//
//  Arguments:   IDataObject*
//
//  Note:        claims critsec, potentially for a considerable period of time
//
//  Returns:     HRESULT
//
//--------------------------------------------------------------------
STDMETHODIMP CContextMenu::AddThirdPartyExtensionItems (
                IDataObject* piDataObject )
{
    DECLARE_SC(sc, _T("IContextMenuProvider::AddThirdPartyExtensionItems"));

    if (NULL == piDataObject)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL piDataObject"), sc);
        return sc.ToHr();
    }

    START_CRITSEC_SNAPIN;

    // Extensions may only be added once, otherwise return S_FALSE
    if (m_fAddedThirdPartyExtensions == TRUE)
    {
        sc = S_FALSE;
        TraceNodeMgrLegacy(_T("CContextMenu::AddThirdPartyExtensionItems>> Menu already extended"), sc);
        return sc.ToHr();
    }

    m_fAddedThirdPartyExtensions = TRUE;

    do // not a loop
    {
        CExtensionsIterator it;
        sc = it.ScInitialize(piDataObject, g_szContextMenu);
        if (sc)
        {
            sc = S_FALSE;
            break;
        }

        BOOL fProblem = FALSE;

        for (; it.IsEnd() == FALSE; it.Advance())
        {
            sc = ScAddSnapinToList_GUID(it.GetCLSID(), piDataObject,
                                        m_MaxThirdPartyOwnerID++);

            if (sc)
                fProblem = TRUE;    // Continue even on error.
        }

        if (fProblem == TRUE)
            sc = S_FALSE;

    } while (0);

    END_CRITSEC_SNAPIN;

    return sc.ToHr();
}


// claims critsec, potentially for a considerable period of time
STDMETHODIMP CContextMenu::AddMultiSelectExtensionItems (
                 LONG_PTR lMultiSelection)
{
    MMC_TRY

    if (lMultiSelection == 0)
        return E_INVALIDARG;

    CMultiSelection* pMS = reinterpret_cast<CMultiSelection*>(lMultiSelection);
    ASSERT(pMS != NULL);

    TRACE_METHOD(CContextMenu,AddThirdPartyExtensionItems);
    TRACE(_T("CContextMenu::AddThirdPartyExtensionItems"));

    START_CRITSEC_SNAPIN;

    // Extensions may only be added once, otherwise return S_FALSE
    if (m_fAddedThirdPartyExtensions == TRUE)
    {
        TRACE(_T("CContextMenu::AddThirdPartyExtensionItems>> Menu already extended"));
        return S_FALSE;
    }

    m_fAddedThirdPartyExtensions = TRUE;

    do // not a loop
    {
        CList<CLSID, CLSID&> snapinClsidList;
        HRESULT hr = pMS->GetExtensionSnapins(g_szContextMenu, snapinClsidList);
        BREAK_ON_FAIL(hr);

        POSITION pos = snapinClsidList.GetHeadPosition();
        if (pos == NULL)
            break;

        CLSID clsid;

        IDataObjectPtr spDataObject;
        hr = pMS->GetMultiSelDataObject(&spDataObject);
        ASSERT(SUCCEEDED(hr));
        BREAK_ON_FAIL(hr);

        BOOL fProblem = FALSE;

        while (pos)
        {
            clsid = snapinClsidList.GetNext(pos);
            hr = ScAddSnapinToList_GUID(clsid, spDataObject,
                                        m_MaxThirdPartyOwnerID++).ToHr();
            CHECK_HRESULT(hr);
            if (FAILED(hr))
                fProblem = TRUE;    // Continue even on error.
        }

        if (fProblem == TRUE)
            hr = S_FALSE;

    } while (0);

    END_CRITSEC_SNAPIN;

    return S_OK;

    MMC_CATCH
}

// Worker function, called recursively by FindMenuItem
// critsec should already be claimed
// If fFindSubmenu, then nMenuItemID is actually an HMENU
CMenuItem* FindWorker( MenuItemList& list, LONG_PTR nMenuItemID, BOOL fFindSubmenu )
{
    POSITION pos = list.GetHeadPosition();
    while(pos)
    {
        CMenuItem* pItem = list.GetNext(pos);
        if ( !fFindSubmenu && pItem->GetMenuItemID() == nMenuItemID )
        {
            // Found a match
            return pItem;
        } else
        if ( pItem->HasChildList() )
        {
            if ( fFindSubmenu &&
                 pItem->GetPopupMenuHandle() == (HMENU)nMenuItemID &&
                 !pItem->IsSpecialInsertionPoint() ) // "insertion point" is not real menu
                return pItem;
            pItem = FindWorker( pItem->GetMenuItemSubmenu(), nMenuItemID, fFindSubmenu );
            if (NULL != pItem)
                return pItem;
        }
    }

    return NULL;
}

MenuItemList* CContextMenu::GetMenuItemList()
{
    if (NULL == m_pmenuitemRoot)
        m_pmenuitemRoot = new CRootMenuItem;

    if (m_pmenuitemRoot == NULL)
    {
        return NULL;
    }

    return &m_pmenuitemRoot->GetMenuItemSubmenu();
}

// critsec should already be claimed
CMenuItem* CContextMenu::FindMenuItem( LONG_PTR nMenuItemID, BOOL fFindSubmenu )
{
	DECLARE_SC(sc, TEXT("CContextMenu::FindMenuItem"));

    if (0 == nMenuItemID || CCM_INSERTIONPOINTID_ROOT_MENU == nMenuItemID)
        return m_pmenuitemRoot;
    else
	{
		MenuItemList* plist = GetMenuItemList();
		sc = ScCheckPointers( plist );
		if (sc)
			return NULL;

        return FindWorker( *plist, nMenuItemID, fFindSubmenu );
	}
}

/*+-------------------------------------------------------------------------*
 *
 * ReverseFindWorker
 *
 * PURPOSE:  Worker function, called recursively by ReverseFindMenuItem
 *           critsec should already be claimed
 *
 * PARAMETERS:
 *    MenuItemList&  list :
 *    long           nCommandID :
 *    MENU_OWNER_ID  ownerID :
 *    CStr &         strPath :
 *
 * RETURNS:
 *    CMenuItem*
 *
 *+-------------------------------------------------------------------------*/
CMenuItem*
ReverseFindWorker( MenuItemList& list, long nCommandID, MENU_OWNER_ID ownerID, CStr &strPath, CStr &strLanguageIndependentPath )
{
    POSITION pos = list.GetHeadPosition();
    while(pos)
    {
        CMenuItem* pItem = list.GetNext(pos);
        if (    pItem->GetCommandID() == nCommandID
            &&  (    (pItem->GetMenuItemOwner() == ownerID)
                  || IsSharedInsertionPointID(nCommandID)
                )
           )
        {
            // Found a match - add it to the path and return
            strPath                     = pItem->GetPath();
            strLanguageIndependentPath  = pItem->GetLanguageIndependentPath();

            return pItem;
        }
        else if ( pItem->HasChildList() )
        {
            pItem = ReverseFindWorker( pItem->GetMenuItemSubmenu(), nCommandID, ownerID, strPath, strLanguageIndependentPath );
            if (NULL != pItem)
            {
                return pItem;
            }
        }
    }

    return NULL;
}

/*+-------------------------------------------------------------------------*
 *
 * CContextMenu::ReverseFindMenuItem
 *
 * PURPOSE: Searches for the specified menu item. Also builds up the
 *          path to the menu item in strPath.
 *
 * NOTE:    critsec should already be claimed
 *
 * PARAMETERS:
 *    long           nCommandID :
 *    MENU_OWNER_ID  ownerID :
 *    CStr &         strPath :
 *
 * RETURNS:
 *    CMenuItem*
 *
 *+-------------------------------------------------------------------------*/
CMenuItem*
CContextMenu::ReverseFindMenuItem( long nCommandID, MENU_OWNER_ID ownerID, CStr &strPath, CStr &strLanguageIndependentPath)
{
	DECLARE_SC(sc, TEXT("CContextMenu::ReverseFindMenuItem"));

    strPath = TEXT(""); // initialize

    if (CCM_INSERTIONPOINTID_ROOT_MENU == nCommandID)
        return m_pmenuitemRoot;
    else
	{
		MenuItemList* plist = GetMenuItemList();
		sc = ScCheckPointers( plist );
		if (sc)
			return NULL;

        return ReverseFindWorker( *plist, nCommandID, ownerID, strPath, strLanguageIndependentPath);
	}
}

//
// Find Nth item in specified menu/submenu
//
CMenuItem* CContextMenu::FindNthItemInSubmenu( HMENU hmenuParent, UINT iPosition, LPTSTR lpszMenuName )
{
    // locate menu/submenu
    MenuItemList* plist = GetMenuItemList();
    if ( NULL != hmenuParent )
    {
        CMenuItem* pParent = FindMenuItem( (LONG_PTR)hmenuParent, TRUE );
        if ( NULL == pParent )
        {
            ASSERT( FALSE );
            return NULL;
        }
        plist = &pParent->GetMenuItemSubmenu();
    }
    if ( NULL == plist )
    {
        ASSERT( FALSE );
        return NULL;
    }

    // find the Nth item
    POSITION pos = plist->GetHeadPosition();

    if (NULL != lpszMenuName)
    {
        while(pos)
        {
            CMenuItem* pItem = plist->GetNext(pos);
            if (! _tcscmp(lpszMenuName, pItem->GetMenuItemName() ))
            {
                // Found the match
                return pItem;
            }
        }
    }
    else
    {
        while(pos)
        {
            CMenuItem* pItem = plist->GetNext(pos);
            if ( 0 == iPosition-- )
            {
                // Found a match
                return pItem;
            }
        }
    }


    ASSERT( FALSE );
    return NULL;
}

// claims critsec
STDMETHODIMP CContextMenu::DoAddMenuItem(LPCTSTR lpszName,
                                            LPCTSTR lpszStatusBarText,
                                            LPCTSTR lpszLanguageIndependentName,
                                            LONG lCommandID,
                                            LONG lInsertionPointID,
                                            LONG fFlags,
                                            LONG fSpecialFlags,
                                            MENU_OWNER_ID ownerID,
                                            CMenuItem** ppMenuItem /* = NULL */,
                                            bool bPassCommandBackToSnapin /*= false*/ )
{
    DECLARE_SC(sc, TEXT("CContextMenu::DoAddMenuItem"));
    MMC_TRY

    // init out param
    if (ppMenuItem)
        *ppMenuItem = NULL;

    // Save test flag now because special flags are modified below
    BOOL bTestOnly = fSpecialFlags & CCM_SPECIAL_TESTONLY;

    if ( OWNERID_INVALID == ownerID )
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): invalid ownerid"));
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    if (  (CCM_SPECIAL_SEPARATOR & fSpecialFlags)?0:1
          + ((CCM_SPECIAL_SUBMENU|CCM_SPECIAL_DEFAULT_ITEM) & fSpecialFlags)?0:1
          + (CCM_SPECIAL_INSERTION_POINT & fSpecialFlags)?0:1
          > 1 )
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): invalid combination of special flags"));
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    if (CCM_SPECIAL_SEPARATOR & fSpecialFlags)
    {
        lpszName = NULL;
        lpszStatusBarText = NULL;
        lCommandID = 0;
        fFlags = MF_SEPARATOR | MF_GRAYED | MF_DISABLED;
    }
    if ( CCM_SPECIAL_INSERTION_POINT & fSpecialFlags )
    {
        fFlags = NULL; // be sure to clear MF_POPUP
        fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;
    }
    if ( (CCM_SPECIAL_SUBMENU & fSpecialFlags) && !(MF_POPUP & fFlags) )
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): CCM_SPECIAL_SUBMENU requires MF_POPUP"));
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    if ( (MF_OWNERDRAW|MF_BITMAP) & fFlags )
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): MF_OWNERDRAW and MF_BITMAP are invalid"));
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    else if ( !(MF_SEPARATOR & fFlags) &&
              !(CCM_SPECIAL_INSERTION_POINT & fSpecialFlags) &&
              NULL == lpszName )
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): invalid menuitem text\n"));
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    // note that NULL==lpszStatusBarText is permitted

    START_CRITSEC_MENU;

    //
    // An insertion point of 0 is interpreted the same as CCM_INSERTIONPOINTID_ROOT_MENU
    //
    if (0 == lInsertionPointID)
        lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU;

    //
    // Check that the insertion point ID specified is legal for this customer
    //
    do // false loop
    {
        if ( !IsSpecialInsertionPointID(lInsertionPointID) )
            break;
        if ( IsReservedInsertionPointID(lInsertionPointID) )
        {
            TRACE(_T("CContextMenu::DoAddMenuItem(): using reserved insertion point ID\n"));
            return E_INVALIDARG;
        }
        if ( !IsSharedInsertionPointID(lInsertionPointID) )
            break;
        if ( !IsAddPrimaryInsertionPointID(lInsertionPointID) )
        {
            if ( IsPrimaryOwnerID(ownerID) )
            {
                TRACE(_T("CContextMenu::DoAddMenuItem(): not addprimary insertion point ID\n"));
                return E_INVALIDARG;
            }
        }
        if ( !IsAdd3rdPartyInsertionPointID(lInsertionPointID) )
        {
            if ( IsThirdPartyOwnerID(ownerID) )
            {
                TRACE(_T("CContextMenu::DoAddMenuItem(): not add3rdpartyinsertion point ID\n"));
                return E_INVALIDARG;
            }
        }
    } while (FALSE); // false loop


    //
    // Check that the command ID specified is legal for this customer
    //
    if ( (MF_POPUP & fFlags) || (CCM_SPECIAL_INSERTION_POINT & fSpecialFlags) )
    {
        do // false loop
        {
            if ( !IsSpecialInsertionPointID(lCommandID) )
                break;
            if ( IsReservedInsertionPointID(lCommandID) )
            {
                TRACE(_T("CContextMenu::DoAddMenuItem(): adding reserved insertion point ID\n"));
                ASSERT(FALSE);
                return E_INVALIDARG;
            }
            if ( !IsSharedInsertionPointID(lCommandID) )
                break;
            if ( IsThirdPartyOwnerID(ownerID) )
            {
                TRACE(_T("CContextMenu::DoAddMenuItem(): 3rdparty cannot add shared insertion point"));
                ASSERT(FALSE);
                return E_INVALIDARG;
            }
            else if ( IsPrimaryOwnerID(ownerID) )
            {
                if ( !IsCreatePrimaryInsertionPointID(lCommandID) )
                {
                    TRACE(_T("CContextMenu::DoAddMenuItem(): only system for new !PRIMARYCREATE submenu"));
                    ASSERT(FALSE);
                    return E_INVALIDARG;
                }
            }
            else if ( IsSystemOwnerID(ownerID) )
            {
                if ( IsCreatePrimaryInsertionPointID(lCommandID) )
                {
                    TRACE(_T("CContextMenu::DoAddMenuItem(): only primary extension for new PRIMARYCREATE submenu"));
                    ASSERT(FALSE);
                    return E_INVALIDARG;
                }
            }
        } while (FALSE); // false loop
    }
    else if ( !(CCM_SPECIAL_SEPARATOR & fSpecialFlags) )
    {
        if ( IsReservedCommandID(lCommandID) )
        {
            TRACE(_T("CContextMenu::DoAddMenuItem(): no new RESERVED menu items"));
            ASSERT(FALSE);
            return E_INVALIDARG;
        }
    }

    if (NULL == m_pmenuitemRoot)
        m_pmenuitemRoot = new CRootMenuItem;

    CStr strPath, strLanguageIndependentPath; // this builds up the path of the menu item.

    CMenuItem* pParent = ReverseFindMenuItem( lInsertionPointID, ownerID, strPath, strLanguageIndependentPath);
    if (NULL == pParent)
    {
        TRACE(_T("CContextMenu::DoAddMenuItem(): submenu with command ID %ld owner %ld does not exist"), lInsertionPointID, ownerID );
        ASSERT(FALSE);
        return E_INVALIDARG;
    }
    MenuItemList& rMenuList = pParent->GetMenuItemSubmenu();

   // If this is only a test add, return with success now
   if (bTestOnly)
       return S_OK;

   // get the data object and IExtendContextMenu pointer to set in the item.
   IExtendContextMenuPtr spExtendContextMenu;
   IDataObject*          pDataObject = NULL;   // This is used JUST to hold on to the object until Command completes.

   // locate the IExtendContextMenu of the snapin.
   {
       // The selected item was added by an extension
       SnapinStruct* psnapin = FindSnapin( ownerID );

       if(psnapin != NULL)
       {
           pDataObject = psnapin->m_pIDataObject;

           spExtendContextMenu = psnapin->pIExtendContextMenu;
       }
       else
       {
           CTiedComObjectCreator<CNativeExtendContextMenu>::
                                ScCreateAndConnect(*this, spExtendContextMenu);
           // built in items are handled by CContextMenu itself.
       }
   }

    // compute the language independent and language dependent paths for the context menu item.
    CStr strLanguageIndependentName = lpszLanguageIndependentName;
    tstring tstrName                = lpszName ? lpszName : TEXT("");

    RemoveAccelerators(tstrName);

    CStr strName;

    strName = tstrName.data(); // got to standardise on either tstring or CStr

    // add a "->" separator to the path if needed
    if(!strPath.IsEmpty() && !strName.IsEmpty())
       strPath +=  _T("->");
    strPath +=  strName;

    // add a "->" separator to the language independent path if needed
    if(!strLanguageIndependentPath.IsEmpty() && !strLanguageIndependentName.IsEmpty())
       strLanguageIndependentPath +=  _T("->");
    strLanguageIndependentPath +=  strLanguageIndependentName;


    CMenuItem* pItem = new CMenuItem(
        lpszName,
        lpszStatusBarText,
        lpszLanguageIndependentName,
        (LPCTSTR)strPath,
        (LPCTSTR)strLanguageIndependentPath,
        lCommandID,
        m_nNextMenuItemID++,
        fFlags,
        ownerID,
        spExtendContextMenu,
        pDataObject,
        fSpecialFlags,
        bPassCommandBackToSnapin);
    ASSERT( pItem );
    if (pItem == NULL)
        return E_OUTOFMEMORY;

    rMenuList.AddTail(pItem);

    // If this is a system defined insertion point, update the insertion flags
    if (IsSharedInsertionPointID(lCommandID) && !IsCreatePrimaryInsertionPointID(lCommandID))
    {
        long fFlag = ( 1L << (lCommandID & CCM_INSERTIONPOINTID_MASK_FLAGINDEX));

        if (IsAddPrimaryInsertionPointID(lCommandID))
           m_fPrimaryInsertionFlags |= fFlag;

        if (IsAdd3rdPartyInsertionPointID(lCommandID))
           m_fThirdPartyInsertionFlags |= fFlag;
    }

    // return the item if required
    if (ppMenuItem)
        *ppMenuItem = pItem;

    END_CRITSEC_MENU;

    return S_OK;

    MMC_CATCH
}

// APP HACK. Workarounding dependency on older FP where they were QI'ing for IConsole from
// IContextMenuCallback, which was working in MMC 1.2, but cannot work in mmc 2.0
// See bug 200621 (Windows bugs (ntbug9) 11/15/2000)
#define WORKAROUND_FOR_FP_REQUIRED

#if defined (WORKAROUND_FOR_FP_REQUIRED)
	/***************************************************************************\
	 *
	 * CLASS:  CWorkaroundWrapperForFrontPageMenu
	 *
	 * PURPOSE: Used from subclassed MMC's IExtendContextMenu interface for FrontPage.
	 *			Contains (in com sense) IContextMenuCallback2 and IContextMenuCallback by forwarding
	 *			them to original interface, but in addition supports QI for IConsole.
	 *			This is a requirement for older FrontPage to work
	 *
	\***************************************************************************/
    class CWorkaroundWrapperForFrontPageMenu :
        public IContextMenuCallback,
        public IContextMenuCallback2,
        public IConsole2,                   // workaround for bug 200621. This is a dummy implementation of IConsole2
        public CComObjectRoot
    {
		friend class CWorkaroundMMCWrapperForFrontPageMenu;
        // pointer to context menu object
        IContextMenuCallbackPtr     m_spIContextMenuCallback;
        IContextMenuCallback2Ptr    m_spIContextMenuCallback2;
    public:

        typedef CWorkaroundWrapperForFrontPageMenu ThisClass;

        // com entry points
        BEGIN_COM_MAP(ThisClass)
            COM_INTERFACE_ENTRY(IContextMenuCallback) // the IContextMenuProvider and IContextMenu
            COM_INTERFACE_ENTRY(IContextMenuCallback2)
            COM_INTERFACE_ENTRY(IConsole)
            COM_INTERFACE_ENTRY(IConsole2)
        END_COM_MAP()

		// just forward...
        STDMETHOD(AddItem) ( CONTEXTMENUITEM* pItem )
        {
            if ( m_spIContextMenuCallback == NULL )
                return E_UNEXPECTED;

            return m_spIContextMenuCallback->AddItem( pItem );
        }

		// just forward...
        STDMETHOD(AddItem) ( CONTEXTMENUITEM2* pItem )
        {
            if ( m_spIContextMenuCallback2 == NULL )
                return E_UNEXPECTED;

            return m_spIContextMenuCallback2->AddItem( pItem );
        }

        // IConsole2 methods - DUMMY - workaround for bug 200621
        STDMETHOD(SetHeader)( LPHEADERCTRL pHeader)			                                        {return E_NOTIMPL;}
        STDMETHOD(SetToolbar)( LPTOOLBAR pToolbar)			                                        {return E_NOTIMPL;}
        STDMETHOD(QueryResultView)( LPUNKNOWN* pUnknown)			                                {return E_NOTIMPL;}
        STDMETHOD(QueryScopeImageList)( LPIMAGELIST* ppImageList)			                        {return E_NOTIMPL;}
        STDMETHOD(QueryResultImageList)( LPIMAGELIST* ppImageList)			                        {return E_NOTIMPL;}
        STDMETHOD(UpdateAllViews)( LPDATAOBJECT lpDataObject,LPARAM data,LONG_PTR hint)	            {return E_NOTIMPL;}
        STDMETHOD(MessageBox)( LPCWSTR lpszText,  LPCWSTR lpszTitle,UINT fuStyle,  int* piRetval)	{return E_NOTIMPL;}
        STDMETHOD(QueryConsoleVerb)( LPCONSOLEVERB * ppConsoleVerb)			                        {return E_NOTIMPL;}
        STDMETHOD(SelectScopeItem)( HSCOPEITEM hScopeItem)			                                {return E_NOTIMPL;}
        STDMETHOD(GetMainWindow)( HWND* phwnd)			
        {
			if (!phwnd)
				return E_INVALIDARG;
            *phwnd = (CScopeTree::GetScopeTree() ? CScopeTree::GetScopeTree()->GetMainWindow() : NULL);
            return S_OK;
        }
        STDMETHOD(NewWindow)( HSCOPEITEM hScopeItem,  unsigned long lOptions)			            {return E_NOTIMPL;}
        STDMETHOD(Expand)( HSCOPEITEM hItem,  BOOL bExpand)			                                {return E_NOTIMPL;}
        STDMETHOD(IsTaskpadViewPreferred)()			                                                {return E_NOTIMPL;}
        STDMETHOD(SetStatusText )( LPOLESTR pszStatusText)			                                {return E_NOTIMPL;}
    };

	/***************************************************************************\
	 *
	 * CLASS:  CWorkaroundMMCWrapperForFrontPageMenu
	 *
	 * PURPOSE: Subclasses MMC's IExtendContextMenu interface for FrontPage.
	 *			Contains ( in com sense) IExtendContextMenu; Forwards calls to default MMC implementation,
	 *			but for AddMenuItems gives itself as a callback interface.
	 *			[ main purpose to have this object is to avoid changing main MMC functions	]
	 *			[ to implement this workaround												]
	 *
	\***************************************************************************/
    class CWorkaroundMMCWrapperForFrontPageMenu :
        public IExtendContextMenu,
        public CComObjectRoot
    {
        // pointer to context menu object
        IExtendContextMenuPtr       m_spExtendContextMenu;
        CNode                      *m_pNode;
    public:

        typedef CWorkaroundMMCWrapperForFrontPageMenu ThisClass;

		// this method is null for all snapins, but FrontPage
		// for FrontPage it wraps and replaces spIUnknown paramter
        static SC ScSubclassFP(const CLSID& clsid,IUnknownPtr &spIUnknown)
        {
            DECLARE_SC(sc, TEXT("CWorkaroundMMCWrapperForFrontPageMenu::ScSubclassFP"));

            static const CLSID CLSID_Fpsrvmmc = { 0xFF5903A8, 0x78D6, 0x11D1,
                                                { 0x92, 0xF6, 0x00, 0x60, 0x97, 0xB0, 0x10, 0x56 } };
            // only required intercept one clsid
            if ( clsid != CLSID_Fpsrvmmc )
                return sc;

            // create self
            typedef CComObject<CWorkaroundMMCWrapperForFrontPageMenu> ThisComObj_t;

            ThisComObj_t *pObj = NULL;
            sc = ThisComObj_t::CreateInstance(&pObj);
            if (sc)
                return sc;

            // cast to avoid member access problems (workarounding compiler)
            ThisClass *pThis = pObj;

            sc = ScCheckPointers( pThis, E_UNEXPECTED );
            if (sc)
                return sc;

            // maintain the lifetime in case of accident
            IUnknownPtr spThis = pThis->GetUnknown();

            // grab on snapin's interface
            pThis->m_spExtendContextMenu = spIUnknown;
            sc = ScCheckPointers( pThis->m_spExtendContextMenu, E_UNEXPECTED );
            if (sc)
                return sc;

            // substitute the snapin (in-out parameter)
            spIUnknown = spThis;
            return sc;
        }

        // com entry points
        BEGIN_COM_MAP(ThisClass)
            COM_INTERFACE_ENTRY(IExtendContextMenu)
        END_COM_MAP()

		// AddMenuItems is the method this object exists for.
		// If we got here, mmc is about to ask FrontPage to add its items to context menu.
		// We'll wrap the callback interface given by MMC with the object implementing
		// phony IConsole - this is required for older FP to work
        STDMETHOD(AddMenuItems)( LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed )
        {
			DECLARE_SC(sc, TEXT("CWorkaroundMMCWrapperForFrontPageMenu::AddMenuItems"));

            IContextMenuCallbackPtr		spIContextMenuCallback = piCallback;
            IContextMenuCallback2Ptr	spIContextMenuCallback2 = piCallback;
            if ( m_spExtendContextMenu == NULL || spIContextMenuCallback == NULL || spIContextMenuCallback2 == NULL )
                return E_UNEXPECTED;

            // create a wrapper for FP
            typedef CComObject<CWorkaroundWrapperForFrontPageMenu> WrapperComObj_t;

            WrapperComObj_t *pObj = NULL;
            sc = WrapperComObj_t::CreateInstance(&pObj);
            if (sc)
                return sc.ToHr();

            // cast to avoid member access problems (workarounding compiler)
            CWorkaroundWrapperForFrontPageMenu *pWrapper = pObj;

            sc = ScCheckPointers( pWrapper, E_UNEXPECTED );
            if (sc)
                return sc.ToHr();

            // maintain the lifetime in case of accident
            IUnknownPtr spWrapper = pWrapper->GetUnknown();

            // grab on snapin's interface
            pWrapper->m_spIContextMenuCallback   = spIContextMenuCallback;
            pWrapper->m_spIContextMenuCallback2  = spIContextMenuCallback2;

            // call snapin on behave on mmc, but pass itself as callback
            sc = m_spExtendContextMenu->AddMenuItems( piDataObject, pWrapper, pInsertionAllowed );
			// fall thru even on error - need to release interfaces

            // reset callback interfaces - not valid after the call anyway...
			// this will let context menu go, and prevent FP from suicide (AV);
			// Following this all calls to IContextMenuCallback would fail,
			// but that's ok, since it is not legal to call them after AddMenuItems.
            pWrapper->m_spIContextMenuCallback   = NULL;
            pWrapper->m_spIContextMenuCallback2  = NULL;

            return sc.ToHr();
        }

		// simply forward....
        STDMETHOD(Command)(long lCommandID, LPDATAOBJECT piDataObject)
        {
            ASSERT( m_spExtendContextMenu != NULL );
            if ( m_spExtendContextMenu == NULL )
                return E_UNEXPECTED;

            return m_spExtendContextMenu->Command(lCommandID, piDataObject);
        }

    };
#endif // defined (WORKAROUND_FOR_FP_REQUIRED)


// critsec should already be claimed
SC CContextMenu::ScAddSnapinToList_GUID(
        const CLSID& clsid,
        IDataObject* piDataObject,
        MENU_OWNER_ID ownerID )
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddSnapinToList_GUID"));

    // cocreate extension
    IUnknownPtr spIUnknown;
    sc = ::CoCreateInstance(clsid, NULL, MMC_CLSCTX_INPROC,
                            IID_IUnknown, (LPVOID*)&spIUnknown);
    if (sc)
        return sc;

#if defined (WORKAROUND_FOR_FP_REQUIRED)
    sc = CWorkaroundMMCWrapperForFrontPageMenu::ScSubclassFP(clsid, spIUnknown);
#endif // defined (WORKAROUND_FOR_FP_REQUIRED)

    // get IExtendContextMenu interface
    IExtendContextMenuPtr spIExtendContextMenu = spIUnknown;
    sc = ScCheckPointers(spIExtendContextMenu, E_NOINTERFACE);
    if (sc)
        return sc;

    // add menu items
    sc = ScAddSnapinToList_IExtendContextMenu(spIExtendContextMenu,
                                              piDataObject, ownerID );
    if (sc)
        return sc;

    return sc;
}

// does not AddRef() or Release() interface pointer
// critsec should already be claimed
SC CContextMenu::ScAddSnapinToList_IUnknown(
        IUnknown* piExtension,
        IDataObject* piDataObject,
        MENU_OWNER_ID ownerID )
{
    DECLARE_SC(sc, TEXT("CContextMenu::AddSnapinToList_IUnknown"));

    // parameter check
    sc = ScCheckPointers(piExtension);
    if (sc)
        return sc;

    IExtendContextMenuPtr spIExtendContextMenu = piExtension;
    if (spIExtendContextMenu == NULL)
        return sc; // snapin does not extend context menus

    // add menu items
    sc =  ScAddSnapinToList_IExtendContextMenu( spIExtendContextMenu, piDataObject, ownerID );
    if (sc)
        return sc;

    return sc;
}

// Interface pointer is Release()d when menu list is emptied
// critsec should already be claimed
SC CContextMenu::ScAddSnapinToList_IExtendContextMenu(
        IExtendContextMenu* pIExtendContextMenu,
        IDataObject* piDataObject,
        MENU_OWNER_ID ownerID )
{
    DECLARE_SC(sc, TEXT("CContextMenu::ScAddSnapinToList_IExtendContextMenu"));

    // parameter check
    sc = ScCheckPointers(pIExtendContextMenu);
    if (sc)
        return sc;

    SnapinStruct* psnapstruct = new SnapinStruct( pIExtendContextMenu, piDataObject, ownerID );
    sc = ScCheckPointers(psnapstruct, E_OUTOFMEMORY);
    if (sc)
        return sc;

    m_SnapinList->AddTail(psnapstruct);

    m_CurrentExtensionOwnerID = ownerID;

    long fInsertionFlags = IsPrimaryOwnerID(ownerID) ? m_fPrimaryInsertionFlags : m_fThirdPartyInsertionFlags;

    // if view items are requested, then allow only view items
    // view item requests go to the IComponent. If other item types are allowed there
    // will be a second pass through this code directed to the IComponentData.
    long lTempFlags = fInsertionFlags;
    if ( fInsertionFlags & CCM_INSERTIONALLOWED_VIEW )
        lTempFlags = CCM_INSERTIONALLOWED_VIEW;

    try
    {
        sc = pIExtendContextMenu->AddMenuItems( piDataObject, this, &lTempFlags );
#ifdef DBG
        if (sc)
            TraceSnapinError(_T("IExtendContextMenu::AddMenuItems failed"), sc);
#endif
    }
    catch (...)
    {
        if (DOBJ_CUSTOMOCX == piDataObject)
        {
            ASSERT( FALSE && "IExtendContextMenu::AddMenuItem of IComponent is called with DOBJ_CUSTOMOCX and snapin derefed this custom data object. Please handle special dataobjects in your snapin.");
            sc = E_UNEXPECTED;
        }
        else if (DOBJ_CUSTOMWEB == piDataObject)
        {
            ASSERT( FALSE && "IExtendContextMenu::AddMenuItem of IComponent is called with DOBJ_CUSTOMWEB and snapin derefed this custom data object. Please handle special dataobjects in your snapin.");
            sc = E_UNEXPECTED;
        }
        else
        {
            ASSERT( FALSE && "IExtendContextMenu::AddMenuItem implemented by snapin has thrown an exception.");
            sc = E_UNEXPECTED;
        }
    }

    m_CurrentExtensionOwnerID = OWNERID_NATIVE;
    if (sc)
        return sc;

    // Primary snapin is allowed to clear extension snapin insertion flags
    if ( IsPrimaryOwnerID(ownerID) )
        m_fThirdPartyInsertionFlags &= fInsertionFlags;

    return sc;
}

// All snapin interface pointers are Release()d
// critsec should already be claimed
void CContextMenu::ReleaseSnapinList()
{
    ASSERT(m_SnapinList != NULL);
    if (m_SnapinList != NULL && m_SnapinList->GetCount() != 0)
    {
        POSITION pos = m_SnapinList->GetHeadPosition();

        while(pos)
        {
            SnapinStruct* pItem = (SnapinStruct*)m_SnapinList->GetNext(pos);
            ASSERT_OBJECTPTR( pItem );
            delete pItem;
        }

        m_SnapinList->RemoveAll();
    }
}

// critsec should already be claimed
SnapinStruct* CContextMenu::FindSnapin( MENU_OWNER_ID ownerID )
{
    ASSERT(m_SnapinList != NULL);
    if (m_SnapinList != NULL && m_SnapinList->GetCount() != 0)
    {
        POSITION pos = m_SnapinList->GetHeadPosition();

        while(pos)
        {
            SnapinStruct* pItem = (SnapinStruct*)m_SnapinList->GetNext(pos);
            ASSERT( NULL != pItem );
            if ( ownerID == pItem->m_OwnerID )
                return pItem;
        }
    }
    return NULL;
}

// Worker function, called recursively by ShowContextMenu
// critsec should already be claimed
HRESULT CollapseInsertionPoints( CMenuItem* pmenuitemParent )
{
    ASSERT( NULL != pmenuitemParent && !pmenuitemParent->IsSpecialInsertionPoint() );
    MenuItemList& rMenuList = pmenuitemParent->GetMenuItemSubmenu();

    POSITION pos = rMenuList.GetHeadPosition();
    while(pos)
    {
        POSITION posThisItem = pos;
        CMenuItem* pItem = (rMenuList.GetNext(pos));
        ASSERT( pItem != NULL );
        if ( pItem->IsPopupMenu() )
        {
            ASSERT( !pItem->IsSpecialInsertionPoint() );
            HRESULT hr = CollapseInsertionPoints( pItem );
            if ( FAILED(hr) )
            {
                ASSERT( FALSE );
                return hr;
            }
            continue;
        }
        if ( !pItem->IsSpecialInsertionPoint() )
            continue;

        // we found an insertion point, move its items into this list
        MenuItemList& rInsertedList = pItem->GetMenuItemSubmenu();

        POSITION posInsertAfterThis = posThisItem;
        while ( !rInsertedList.IsEmpty() )
        {
            CMenuItem* pInsertedItem = rInsertedList.RemoveHead();
            posInsertAfterThis = rMenuList.InsertAfter( posInsertAfterThis, pInsertedItem );
        }

        // delete the insertion point item
        rMenuList.RemoveAt(posThisItem);
        delete pItem;

        // restart at head of list, in case of recursive insertion points
        pos = rMenuList.GetHeadPosition();
    }

    return S_OK;
}

// Worker function, called recursively by ShowContextMenu
// critsec should already be claimed and CollapseInsertionPoints should have been called
HRESULT CollapseSpecialSeparators( CMenuItem* pmenuitemParent )
{
    ASSERT( NULL != pmenuitemParent && !pmenuitemParent->IsSpecialInsertionPoint() );
    MenuItemList& rMenuList = pmenuitemParent->GetMenuItemSubmenu();
    CMenuItem* pItem = NULL;

    BOOL fLastItemWasReal = FALSE;
    POSITION pos = rMenuList.GetHeadPosition();
    POSITION posThisItem = pos;
    while(pos)
    {
        posThisItem = pos;
        pItem = (rMenuList.GetNext(pos));
        ASSERT( pItem != NULL );
        ASSERT( !pItem->IsSpecialInsertionPoint() );
        if ( pItem->IsPopupMenu() )
        {
            ASSERT( !pItem->IsSpecialSeparator() );
            HRESULT hr = CollapseSpecialSeparators( pItem );
            if ( FAILED(hr) )
            {
                ASSERT( FALSE );
                return hr;
            }
            fLastItemWasReal = TRUE;
            continue;
        }

        if ( !pItem->IsSpecialSeparator() )
        {
            fLastItemWasReal = TRUE;
            continue;
        }
        if ( fLastItemWasReal )
        {
            fLastItemWasReal = FALSE;
            continue;
        }

        // Found two consecutive special separators, or special seperator as first item
        // delete the insertion point item
        rMenuList.RemoveAt(posThisItem);
        delete pItem;
    }

    if ( !fLastItemWasReal && !rMenuList.IsEmpty() )
    {
        // Found special separator as last item
        delete rMenuList.RemoveTail();
    }

    return S_OK;
}

// Worker function, called recursively by ShowContextMenu
// critsec should already be claimed
HRESULT BuildContextMenu(   WTL::CMenu& menu,
                            CMenuItem* pmenuitemParent )
{
    MenuItemList& rMenuList = pmenuitemParent->GetMenuItemSubmenu();

    int  nCount = 0;
    bool fInsertedItemSinceLastSeparator = false;
    POSITION pos = rMenuList.GetHeadPosition();

    while(pos)
    {
        CMenuItem* pItem = (rMenuList.GetNext(pos));
        ASSERT( pItem != NULL );
        ASSERT( !pItem->IsSpecialInsertionPoint() );

        UINT_PTR nCommandID = pItem->GetMenuItemID();
        long     nFlags     = pItem->GetMenuItemFlags();

        /*
         * special processing for submenus
         */
        if ( pItem->IsPopupMenu() )
        {
            // add items to a submenu
            WTL::CMenu submenu;
            VERIFY( submenu.CreatePopupMenu() );
            HRESULT hr = BuildContextMenu( submenu, pItem );
            if ( FAILED(hr) )
                return hr;
            HMENU hSubmenu = submenu.Detach();
            ASSERT( NULL != hSubmenu );
            nCommandID = (UINT_PTR)hSubmenu;
            pItem->SetPopupMenuHandle( hSubmenu );

            if ( pItem->IsSpecialSubmenu() )
            {
                MenuItemList& rChildMenuList = pItem->GetMenuItemSubmenu();

                if ( rChildMenuList.IsEmpty() )
                {
                    // Bug 151435: remove instead of disabling unused submenus
                    // pItem->SetMenuItemFlags(nFlags | (MF_GRAYED|MF_DISABLED));
                    ::DestroyMenu(hSubmenu);
                    continue;
                }
            }

            fInsertedItemSinceLastSeparator = true;
        }

        /*
         * special processing for separators
         */
        else if (nFlags & MF_SEPARATOR)
        {
            /*
             * if we haven't inserted an item since the last separator,
             * we don't want to insert this one or we'll have consecutive
             * separators, or an unnecessary separator at the top of the menu
             */
            if (!fInsertedItemSinceLastSeparator)
                continue;

            /*
             * if there aren't any more items after this separator,
             * we don't want to insert this one or we'll have an
             * unnecessary separator at the bottom of the menu
             */
            if (pos == NULL)
                continue;

            fInsertedItemSinceLastSeparator = false;
        }

        /*
         * just a normal menu item
         */
        else
        {
            fInsertedItemSinceLastSeparator = true;
        }

        if (!menu.AppendMenu(nFlags, nCommandID, pItem->GetMenuItemName()))
        {
#ifdef DBG
            TRACE(_T("BuildContextMenu: AppendMenu(%ld, %ld, \"%s\") reports error\n"),
                nFlags,
                nCommandID,
                SAFEDBGTCHAR(pItem->GetMenuItemName()) );
#endif

            ASSERT( FALSE );
            return E_UNEXPECTED;
        }

        if (pItem->IsSpecialItemDefault())
        {
            VERIFY( ::SetMenuDefaultItem(menu, nCount, TRUE) );
        }

        ++nCount;
    }

    return S_OK;
}


/*+-------------------------------------------------------------------------*
 * CContextMenu::BuildContextMenu
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      WTL::CMenu &  menu:
 *
 * RETURNS:
 *      HRESULT
/*+-------------------------------------------------------------------------*/
HRESULT
CContextMenu::BuildContextMenu(WTL::CMenu &menu)
{
    HRESULT hr = S_OK;

    hr = ::CollapseInsertionPoints( m_pmenuitemRoot );
    if ( FAILED(hr) )
        return hr;

    hr = ::CollapseSpecialSeparators( m_pmenuitemRoot );
    if ( FAILED(hr) )
        return hr;

    hr = ::BuildContextMenu( menu, m_pmenuitemRoot );
    if ( FAILED(hr) )
        return hr;

    UINT iItems = menu.GetMenuItemCount();
    if ((UINT)-1 == iItems)
    {
        TRACE(_T("CContextMenu::BuildContextMenu(): itemcount error"));
        ASSERT( FALSE );
        return E_UNEXPECTED;
    }
    else if (0 >= iItems)
    {
        TRACE(_T("CContextMenu::BuildContextMenu(): no items added"));
        return S_OK;
    }

    return hr;
}


/*+-------------------------------------------------------------------------*
 * CContextMenu::ShowContextMenu
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *      WND     hwndParent:
 *      LONG    xPos:
 *      LONG    yPos:
 *      LONG*   plSelected:
 *
 * RETURNS:
 *      HRESULT
/*+-------------------------------------------------------------------------*/
STDMETHODIMP
CContextMenu::ShowContextMenu(  HWND hwndParent, LONG xPos,
                                LONG yPos, LONG* plSelected)
{
	return (ShowContextMenuEx (hwndParent, xPos, yPos, NULL/*prcExclude*/,
							   true/*bAllowDefaultMenuItem*/, plSelected));
}


STDMETHODIMP
CContextMenu::ShowContextMenuEx(HWND hwndParent, LONG xPos,
                                LONG yPos, LPCRECT prcExclude,
								bool bAllowDefaultMenuItem, LONG* plSelected)
{
    DECLARE_SC(sc, _T("IContextMenuProvider::ShowContextMenuEx"));
    if (NULL == plSelected)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL selected ptr"), sc);
        return sc.ToHr();
    }

    *plSelected = 0;

    WTL::CMenu menu;
    VERIFY( menu.CreatePopupMenu() );

    START_CRITSEC_BOTH;

    if (NULL == m_pmenuitemRoot)
        return sc.ToHr();

    sc = BuildContextMenu(menu);    // build the context menu
    if (sc)
        return sc.ToHr();

    CMenuItem* pItem = NULL;
    LONG lSelected = 0;

    CConsoleStatusBar *pStatusBar = GetStatusBar();

    // At this point, pStatusBar should be non-NULL, either because
    // 1) This function was called by CNodeInitObject, which calls SetStatusBar() first,
    // or 2) by the object model, where m_pNode is always non-NULL.
    ASSERT(pStatusBar);

    // set up the menu command sink and hook up the status bar.
    CCommandSink comsink( *this, menu, pStatusBar);
    if ( !comsink.Init() )
    {
        sc = E_UNEXPECTED;
        TraceNodeMgrLegacy(_T("CContextMenu::ShowContextMenuEx(): comsink error\n"), sc);
        return sc.ToHr();
    }

	/*
	 * if we got an exclusion rectangle, set up a TPMPARAMS to specify it
	 */
	TPMPARAMS* ptpm = NULL;
	TPMPARAMS  tpm;

	if (prcExclude != NULL)
	{
		tpm.cbSize    = sizeof(tpm);
		tpm.rcExclude = *prcExclude;
		ptpm          = &tpm;
	}

	/*
	 * Bug 139708: menu bar popups shouldn't have default menu items.  If
	 * we can't have one on this popup, remove any default item now.
	 */
	if (!bAllowDefaultMenuItem)
		SetMenuDefaultItem (menu, -1, false);

    lSelected = menu.TrackPopupMenuEx(
        TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON | TPM_LEFTBUTTON | TPM_VERTICAL,
        xPos,
        yPos,
        comsink.m_hWnd, // CODEWORK can we eliminate this?
        ptpm );

    comsink.DestroyWindow();

    pItem = (0 == lSelected) ? NULL : FindMenuItem( lSelected );

    if ( pItem != NULL )
    {
        // execute the menu item
        sc = ExecuteMenuItem(pItem);
        if(sc)
            return sc.ToHr();

        // in some cases we'll need to pass command to the sanpin
        if ( pItem->NeedsToPassCommandBackToSnapin() )
            *plSelected = pItem->GetCommandID();
    }
    else
        ASSERT( 0 == lSelected ); // no items selected.

    END_CRITSEC_BOTH;

    return sc.ToHr();
}

HRESULT
CContextMenu::ExecuteMenuItem(CMenuItem *pItem)
{
    DECLARE_SC(sc, TEXT("CContextMenu::ExecuteMenuItem"));

    sc = ScCheckPointers(pItem);
    if(sc)
        return sc.ToHr();

    // execute it;
    sc = pItem->ScExecute();
    if(sc)
        return sc.ToHr();

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\coldata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      coldata.cpp
//
//  Contents:  Access Column Persistence data.
//
//  History:   25-Jan-99 AnandhaG    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "columninfo.h"
#include "colwidth.h"

CColumnData::CColumnData()
{
}

CColumnData::~CColumnData()
{
}

//+-------------------------------------------------------------------
//
//  Member:     GetColumnData
//
//  Synopsis:   Helper function to retrieve the column data for a
//              given column-id.
//
//  Arguments:  [pColID]         - Column-Set identifier.
//              [columnSetData]  - CColumnSetData, used to return the
//                                 persisted column information.
//
//  Returns:    S_OK - if data found else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
HRESULT CColumnData::GetColumnData(SColumnSetID* pColID, CColumnSetData& columnSetData)
{
    MMC_TRY
    HRESULT hr  = E_FAIL;

    do
    {
        CNodeInitObject* pNodeInit = dynamic_cast<CNodeInitObject*>(this);
        if (! pNodeInit)
            break;

        CViewData* pCV = pNodeInit->m_pNode->GetViewData();
        if (! pCV)
            break;

        CLSID clsidSnapin;
        hr = pNodeInit->GetSnapinCLSID(clsidSnapin);

        if (FAILED(hr))
        {
            ASSERT(FALSE);
            hr = E_FAIL;
            break;
        }

        // Get the persisted column data.
        BOOL bRet = pCV->RetrieveColumnData( clsidSnapin, *pColID, columnSetData);

        // No data.
        if (! bRet)
        {
            hr = S_FALSE;
            break;
        }

        hr = S_OK;

    } while ( FALSE );

    return hr;

    MMC_CATCH
}

//+-------------------------------------------------------------------
//
//  Member:     SetColumnData
//
//  Synopsis:   Helper function to set the column data for a
//              given column-id.
//
//  Arguments:  [pColID]         - Column-Set identifier.
//              [columnSetData]  - CColumnSetData, that should be
//                                 persisted.
//
//  Returns:    S_OK - if data is persisted else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
HRESULT CColumnData::SetColumnData(SColumnSetID* pColID, CColumnSetData& columnSetData)
{
    MMC_TRY

    HRESULT hr = E_FAIL;

    do
    {
        CNodeInitObject* pNodeInit = dynamic_cast<CNodeInitObject*>(this);
        if (! pNodeInit)
            break;

        CViewData* pCV = pNodeInit->m_pNode->GetViewData();
        if (! pCV)
            break;

        CLSID clsidSnapin;
        hr = pNodeInit->GetSnapinCLSID(clsidSnapin);

        if (FAILED(hr))
        {
            ASSERT(FALSE);
            hr = E_FAIL;
            break;
        }

        // Copy the data into the internal data structures.
        BOOL bRet = pCV->SaveColumnData( clsidSnapin, *pColID, columnSetData);

        if (! bRet)
        {
            hr = E_FAIL;
            break;
        }

        hr = S_OK;

    } while ( FALSE );

    return hr;

    MMC_CATCH
}

//+-------------------------------------------------------------------
//
//  Member:     SetColumnConfigData
//
//  Synopsis:   Method snapin can call to set the column data for a
//              given column-id.
//              Any sort data that was persisted will be cleared by
//              this call.
//
//  Arguments:  [pColID]       - Column-Set identifier.
//              [pcolSetData]  - Column data that should be persisted.
//
//  Returns:    S_OK - if data is persisted else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnData::SetColumnConfigData(SColumnSetID* pColID,
                                              MMC_COLUMN_SET_DATA* pColSetData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IColumnData::SetColumnConfigData"));

    if (NULL == pColID)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL SColumnSetID ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == pColSetData)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL MMC_COLUMN_SET_DATA ptr"), sc);
        return sc.ToHr();
    }

    sc = S_FALSE;

    CColumnInfoList  colInfoList;

    for (int i = 0; i < pColSetData->nNumCols; i++)
    {
		CColumnInfo      colInfo;
        MMC_COLUMN_DATA* pColData = &(pColSetData->pColData[i]);
        colInfo.SetColWidth(pColData->nWidth);
        colInfo.SetColHidden( HDI_HIDDEN & pColData->dwFlags);
        colInfo.SetColIndex(pColData->nColIndex);

        if ( (colInfo.GetColIndex() == 0) && colInfo.IsColHidden() )
            return (sc = E_INVALIDARG).ToHr();

        // Add the CColumnInfo to the list.
        colInfoList.push_back(colInfo);
    }

    CColumnSetData   columnSetData;
    columnSetData.set_ColumnInfoList(colInfoList);
    sc = SetColumnData(pColID, columnSetData);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     GetColumnConfigData
//
//  Synopsis:   Method snapin can call to retrieve the column data for a
//              given column-id.
//
//  Arguments:  [pColID]       - Column-Set identifier.
//              [ppcolSetData] - Persisted column-data that is returned.
//
//  Returns:    S_OK - if data is found else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnData::GetColumnConfigData(SColumnSetID* pColID,
                                              MMC_COLUMN_SET_DATA** ppColSetData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IColumnData::GetColumnConfigData"));

    if (NULL == pColID)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL SColumnSetID ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == ppColSetData)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL MMC_COLUMN_SET_DATA ptr"), sc);
        return sc.ToHr();
    }

    sc = S_FALSE;
    *ppColSetData = NULL;

    CColumnSetData columnSetData;
    sc = GetColumnData(pColID, columnSetData);

    if (S_OK != sc.ToHr())
        return sc.ToHr();        // data doesnt exist.

    CColumnInfoList* pColInfoList = columnSetData.get_ColumnInfoList();
    CColumnInfo      colInfo;

    int nNumCols = pColInfoList->size();

    if (nNumCols <= 0)
    {
        sc = S_FALSE;
        return sc.ToHr();
    }

    // Allocate memory, copy & return the data.
    int cb       = sizeof(MMC_COLUMN_SET_DATA) + sizeof(MMC_COLUMN_DATA) * nNumCols;
    BYTE* pb     = (BYTE*)::CoTaskMemAlloc(cb);

    if (! pb)
    {
        sc = E_OUTOFMEMORY;
        return sc.ToHr();
    }

    *ppColSetData             = (MMC_COLUMN_SET_DATA*)pb;
    (*ppColSetData)->cbSize   = sizeof(MMC_COLUMN_SET_DATA);
    (*ppColSetData)->nNumCols = nNumCols;
    (*ppColSetData)->pColData = (MMC_COLUMN_DATA*)(pb + sizeof(MMC_COLUMN_SET_DATA));

    CColumnInfoList::iterator itColInfo;

    int i = 0;
    MMC_COLUMN_DATA* pColData     = (*ppColSetData)->pColData;
    for (itColInfo = pColInfoList->begin();itColInfo != pColInfoList->end(); itColInfo++, i++)
    {
        pColData[i].nWidth    = (*itColInfo).GetColWidth();
        pColData[i].dwFlags   = (*itColInfo).IsColHidden() ? HDI_HIDDEN : 0;
        pColData[i].nColIndex = (*itColInfo).GetColIndex();
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     SetColumnSortData
//
//  Synopsis:   Method snapin can call to set the sort data for a
//              given column-id.
//              Any column config data (width, order...) that was
//              persisted will not be affected by this call.
//
//  Arguments:  [pColID]       - Column-Set identifier.
//              [pcolSorData]  - Sort data that should be persisted.
//
//  Returns:    S_OK - if data is persisted else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnData::SetColumnSortData(SColumnSetID* pColID,
                                            MMC_SORT_SET_DATA* pColSortData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IColumnData::SetColumnSortData"));

    if (NULL == pColID)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL SColumnSetID ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == pColSortData)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL MMC_COLUMN_SET_DATA ptr"), sc);
        return sc.ToHr();
    }

    sc = S_FALSE;

    // First get old data. We need to preserve the width, view info.
    CColumnSetData   columnSetData;
    sc = GetColumnData(pColID, columnSetData);

    if (sc)
        return sc.ToHr();

    CColumnSortList* pColSortList    = columnSetData.get_ColumnSortList();
    pColSortList->clear();

    // For MMC version 1.2 we do only single column sorting.
    if (pColSortData->nNumItems > 1)
    {
        sc = S_FALSE;
        return sc.ToHr();
    }

    CColumnSortInfo  colSortInfo;

    for (int i = 0; i < pColSortData->nNumItems; i++)
    {
        MMC_SORT_DATA* pSortData = &(pColSortData->pSortData[i]);
        ::ZeroMemory(&colSortInfo, sizeof(colSortInfo));
        colSortInfo.m_nCol = pSortData->nColIndex;
        colSortInfo.m_dwSortOptions = pSortData->dwSortOptions;
        colSortInfo.m_lpUserParam   = pSortData->ulReserved;

        // Add the CColumnSortInfo to the list.
        pColSortList->push_back(colSortInfo);
    }

    sc = SetColumnData(pColID, columnSetData);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     GetColumnSortData
//
//  Synopsis:   Method snapin can call to retrieve the column sort data
//              for a given column-id.
//
//  Arguments:  [pColID]        - Column-Set identifier.
//              [ppcolSortData] - Persisted column-sort-data that is returned.
//
//  Returns:    S_OK - if data is found else S_FALSE.
//
//  History:    01-25-1999   AnandhaG   Created
//              05-04-1999   AnandhaG   Changed first param to SColumnSetID.
//
//--------------------------------------------------------------------
STDMETHODIMP CColumnData::GetColumnSortData(SColumnSetID* pColID,
                                            MMC_SORT_SET_DATA** ppColSortData)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IColumnData::SetColumnSortData"));

    if (NULL == pColID)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL SColumnSetID ptr"), sc);
        return sc.ToHr();
    }

    if (NULL == ppColSortData)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("NULL MMC_COLUMN_SET_DATA ptr"), sc);
        return sc.ToHr();
    }

    sc = S_FALSE;
    *ppColSortData = NULL;

    CColumnSetData columnSetData;
    sc = GetColumnData(pColID, columnSetData);

    if (S_OK != sc.ToHr())
        return sc.ToHr();

    CColumnSortList* pColSortList    = columnSetData.get_ColumnSortList();
    CColumnSortInfo  colSortInfo;

    int nNumItems = pColSortList->size();

    if (nNumItems <= 0)
    {
        sc = S_FALSE;
        return sc.ToHr();
    }

    // For MMC 1.2 we sort on only one column.
    ASSERT(nNumItems == 1);

    int cb       = sizeof(MMC_SORT_SET_DATA) + sizeof(MMC_SORT_DATA) * nNumItems;
    BYTE* pb     = (BYTE*)::CoTaskMemAlloc(cb);

    if (! pb)
    {
        sc = E_OUTOFMEMORY;
        return sc.ToHr();
    }

    *ppColSortData              = (MMC_SORT_SET_DATA*)pb;
    (*ppColSortData)->cbSize    = sizeof(MMC_SORT_SET_DATA);
    (*ppColSortData)->nNumItems = nNumItems;
    (*ppColSortData)->pSortData = (MMC_SORT_DATA*)(pb + sizeof(MMC_SORT_SET_DATA));

    CColumnSortList::iterator itSortInfo;

    int i = 0;
    MMC_SORT_DATA* pSortData     = (*ppColSortData)->pSortData;
    for (itSortInfo = pColSortList->begin();itSortInfo != pColSortList->end(); itSortInfo++, i++)
    {
        pSortData[i].nColIndex     = (*itSortInfo).m_nCol;
        pSortData[i].dwSortOptions = (*itSortInfo).m_dwSortOptions;
        pSortData[i].ulReserved    = (*itSortInfo).m_lpUserParam;
    }

    sc = S_OK;

    return sc.ToHr();
}

HRESULT WINAPI ColumnInterfaceFunc(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw)
{
    *ppv = NULL;

    ASSERT(IID_IColumnData == riid);

    CColumnData* pColData = (CColumnData*)(pv);
    CNodeInitObject* pNodeInit = dynamic_cast<CNodeInitObject*>(pColData);

    if (pNodeInit && pNodeInit->GetComponent())
    {
        IColumnData* pIColData = dynamic_cast<IColumnData*>(pNodeInit);
        pIColData->AddRef();
        *ppv = static_cast<void*>(pIColData);

        return S_OK;
    }

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\comcat.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0101 */
/* at Fri May 24 09:43:08 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comcat_h__
#define __comcat_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumCATEGORYINFO_FWD_DEFINED__
#define __IEnumCATEGORYINFO_FWD_DEFINED__
typedef interface IEnumCATEGORYINFO IEnumCATEGORYINFO;
#endif 	/* __IEnumCATEGORYINFO_FWD_DEFINED__ */


#ifndef __ICatRegister_FWD_DEFINED__
#define __ICatRegister_FWD_DEFINED__
typedef interface ICatRegister ICatRegister;
#endif 	/* __ICatRegister_FWD_DEFINED__ */


#ifndef __ICatInformation_FWD_DEFINED__
#define __ICatInformation_FWD_DEFINED__
typedef interface ICatInformation ICatInformation;
#endif 	/* __ICatInformation_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: comcat.h
//
//--------------------------------------------------------------------------
			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */


////////////////////////////////////////////////////////////////////////////
//  Classes (link with uuid3.lib)

#pragma comment(lib,"uuid.lib")

EXTERN_C const CLSID CLSID_StdComponentCategoriesMgr;

////////////////////////////////////////////////////////////////////////////
//  Types
			/* size is 16 */
typedef GUID CATID;

			/* size is 4 */
typedef REFGUID REFCATID;

#define IID_IEnumCLSID              IID_IEnumGUID
#define IEnumCLSID                  IEnumGUID
#define LPENUMCLSID                 LPENUMGUID
#define CATID_NULL                   GUID_NULL
#define IsEqualCATID(rcatid1, rcatid2)       IsEqualGUID(rcatid1, rcatid2)
#define IID_IEnumCATID       IID_IEnumGUID
#define IEnumCATID           IEnumGUID

////////////////////////////////////////////////////////////////////////////
//  Category IDs (link to uuid3.lib)
EXTERN_C const CATID CATID_Insertable;
EXTERN_C const CATID CATID_Control;
EXTERN_C const CATID CATID_Programmable;
EXTERN_C const CATID CATID_IsShortcut;
EXTERN_C const CATID CATID_NeverShowExt;
EXTERN_C const CATID CATID_DocObject;
EXTERN_C const CATID CATID_Printable;
EXTERN_C const CATID CATID_RequiresDataPathHost;
EXTERN_C const CATID CATID_PersistsToMoniker;
EXTERN_C const CATID CATID_PersistsToStorage;
EXTERN_C const CATID CATID_PersistsToStreamInit;
EXTERN_C const CATID CATID_PersistsToStream;
EXTERN_C const CATID CATID_PersistsToMemory;
EXTERN_C const CATID CATID_PersistsToFile;
EXTERN_C const CATID CATID_PersistsToPropertyBag;
EXTERN_C const CATID CATID_InternetAware;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumGUID
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumGUID __RPC_FAR *LPENUMGUID;


EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0006
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPENUMCATEGORYINFO_DEFINED
#define _LPENUMCATEGORYINFO_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_s_ifspec;

#ifndef __IEnumCATEGORYINFO_INTERFACE_DEFINED__
#define __IEnumCATEGORYINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCATEGORYINFO
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ IEnumCATEGORYINFO __RPC_FAR *LPENUNCATEGORYINFO;

			/* size is 276 */
typedef struct  tagCATEGORYINFO
    {
    CATID catid;
    LCID lcid;
    OLECHAR szDescription[ 128 ];
    }	CATEGORYINFO;

			/* size is 4 */
typedef struct tagCATEGORYINFO __RPC_FAR *LPCATEGORYINFO;


EXTERN_C const IID IID_IEnumCATEGORYINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumCATEGORYINFO : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT __stdcall Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT __stdcall Reset( void) = 0;
        
        virtual HRESULT __stdcall Clone( 
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCATEGORYINFOVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( __stdcall __RPC_FAR *Skip )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( __stdcall __RPC_FAR *Reset )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Clone )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);
        
    } IEnumCATEGORYINFOVtbl;

    interface IEnumCATEGORYINFO
    {
        CONST_VTBL struct IEnumCATEGORYINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCATEGORYINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCATEGORYINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCATEGORYINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCATEGORYINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCATEGORYINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCATEGORYINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCATEGORYINFO_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IEnumCATEGORYINFO_Next_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCATEGORYINFO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumCATEGORYINFO_Skip_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCATEGORYINFO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumCATEGORYINFO_Reset_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This);


void __RPC_STUB IEnumCATEGORYINFO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IEnumCATEGORYINFO_Clone_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCATEGORYINFO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCATEGORYINFO_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0007
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATREGISTER_DEFINED
#define _LPCATREGISTER_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0007_v0_0_s_ifspec;

#ifndef __ICatRegister_INTERFACE_DEFINED__
#define __ICatRegister_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatRegister
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICatRegister __RPC_FAR *LPCATREGISTER;


EXTERN_C const IID IID_ICatRegister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICatRegister : public IUnknown
    {
    public:
        virtual HRESULT __stdcall RegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]) = 0;
        
        virtual HRESULT __stdcall UnRegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall RegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall UnRegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall RegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT __stdcall UnRegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatRegisterVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICatRegister __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICatRegister __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *UnRegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *UnRegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *RegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *UnRegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
    } ICatRegisterVtbl;

    interface ICatRegister
    {
        CONST_VTBL struct ICatRegisterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatRegister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatRegister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatRegister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatRegister_RegisterCategories(This,cCategories,rgCategoryInfo)	\
    (This)->lpVtbl -> RegisterCategories(This,cCategories,rgCategoryInfo)

#define ICatRegister_UnRegisterCategories(This,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterCategories(This,cCategories,rgcatid)

#define ICatRegister_RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICatRegister_RegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);


void __RPC_STUB ICatRegister_RegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_UnRegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_RegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_UnRegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_RegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatRegister_UnRegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatRegister_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0008
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATINFORMATION_DEFINED
#define _LPCATINFORMATION_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0008_v0_0_s_ifspec;

#ifndef __ICatInformation_INTERFACE_DEFINED__
#define __ICatInformation_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatInformation
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [unique][uuid][object] */ 


			/* size is 4 */
typedef /* [unique] */ ICatInformation __RPC_FAR *LPCATINFORMATION;


EXTERN_C const IID IID_ICatInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICatInformation : public IUnknown
    {
    public:
        virtual HRESULT __stdcall EnumCategories( 
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo) = 0;
        
        virtual HRESULT __stdcall GetCategoryDesc( 
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc) = 0;
        
        virtual HRESULT __stdcall EnumClassesOfCategories( 
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid) = 0;
        
        virtual HRESULT __stdcall IsClassOfCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]) = 0;
        
        virtual HRESULT __stdcall EnumImplCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
        virtual HRESULT __stdcall EnumReqCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatInformationVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ICatInformation __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ICatInformation __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *EnumCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);
        
        HRESULT ( __stdcall __RPC_FAR *GetCategoryDesc )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc);
        
        HRESULT ( __stdcall __RPC_FAR *EnumClassesOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);
        
        HRESULT ( __stdcall __RPC_FAR *IsClassOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);
        
        HRESULT ( __stdcall __RPC_FAR *EnumImplCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        HRESULT ( __stdcall __RPC_FAR *EnumReqCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
    } ICatInformationVtbl;

    interface ICatInformation
    {
        CONST_VTBL struct ICatInformationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatInformation_EnumCategories(This,lcid,ppenumCategoryInfo)	\
    (This)->lpVtbl -> EnumCategories(This,lcid,ppenumCategoryInfo)

#define ICatInformation_GetCategoryDesc(This,rcatid,lcid,pszDesc)	\
    (This)->lpVtbl -> GetCategoryDesc(This,rcatid,lcid,pszDesc)

#define ICatInformation_EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)	\
    (This)->lpVtbl -> EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)

#define ICatInformation_IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)	\
    (This)->lpVtbl -> IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)

#define ICatInformation_EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)

#define ICatInformation_EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ICatInformation_EnumCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);


void __RPC_STUB ICatInformation_EnumCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_GetCategoryDesc_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCATID rcatid,
    /* [in] */ LCID lcid,
    /* [out] */ LPWSTR __RPC_FAR *pszDesc);


void __RPC_STUB ICatInformation_GetCategoryDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


void __RPC_STUB ICatInformation_EnumClassesOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);


void __RPC_STUB ICatInformation_IsClassOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_EnumImplCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumImplCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ICatInformation_EnumReqCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumReqCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatInformation_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0009
 * at Fri May 24 09:43:08 1996
 * using MIDL 2.00.0101
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL__intf_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0009_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\compcat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       compcat.h
//
//--------------------------------------------------------------------------

// compcat.h : interfaces for the CComponentCategory class
//
/////////////////////////////////////////////////////////////////////////////
#ifndef __COMPCAT_H__
#define __COMPCAT_H__


class CComponentCategory
{
// Constructors / destructors
public:
    CComponentCategory();
    ~CComponentCategory();

//attribute
public:
    typedef struct tagComponentInfo
    {
        CLSID           m_clsid;                // Component CLSID
        UINT            m_uiBitmap;             // Bitmap ID in ImageList
        CStr            m_strName;              // Component Readable Name
        bool            m_bSelected;            // Filter selection flag
    } COMPONENTINFO;

    CArray <CATEGORYINFO*, CATEGORYINFO*>       m_arpCategoryInfo;      // Array of categories
    CArray <COMPONENTINFO*, COMPONENTINFO*>     m_arpComponentInfo;     // Array of componets
    
    WTL::CImageList     m_iml;                  // Image list of components


//Operations
public:
    void CommonStruct(void);
    BOOL ValidateInstall(void);
    void EnumComponentCategories(void);
    void EnumComponents();
    void FilterComponents(CATEGORYINFO* pCatInfo);

    HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription);
    HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid);
    HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid);

};

#endif //__COMPCAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\compcat.cpp ===
// CompCat.cpp : implementation of the CComponentCategory class
//

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      CompCat.cpp
//
//  Contents:  Enumerates the component categories
//
//  History:   01-Aug-96 WayneSc    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"         //precompiled header

#include <comcat.h>         // COM Component Categoories Manager


#include "compcat.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentCategory);

CComponentCategory::CComponentCategory()
{
    BOOL const created = m_iml.Create( IDB_IMAGELIST, 16 /*cx*/, 4 /*cGrow*/, RGB(0,255,0) /*RGBLTGREEN*/ );
    ASSERT(created);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentCategory);
}

CComponentCategory::~CComponentCategory()
{
    // delete all memory allocated for categories
    for (int i=0; i <= m_arpCategoryInfo.GetUpperBound(); i++)
        delete m_arpCategoryInfo.GetAt(i);

    m_arpCategoryInfo.RemoveAll();

    // delete all memory allocated for components
    for (i=0; i <= m_arpComponentInfo.GetUpperBound(); i++)
        delete m_arpComponentInfo.GetAt(i);

    m_arpComponentInfo.RemoveAll();

    m_iml.Destroy();

    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentCategory);
}


void CComponentCategory::EnumComponentCategories(void)
{
    ICatInformation* pci = NULL;
    HRESULT hr;
    
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC, IID_ICatInformation, (void**)&pci);
    if (SUCCEEDED(hr))
    {
        IEnumCATEGORYINFO* penum = NULL;
        if (SUCCEEDED(hr = pci->EnumCategories(GetUserDefaultLCID(), &penum)))
        {
            CATEGORYINFO* pCatInfo = new CATEGORYINFO;
            while (penum->Next(1, pCatInfo, NULL) == S_OK)
            {
                // skip unnamed categories 
                if ( pCatInfo->szDescription[0] && !IsEqualCATID(pCatInfo->catid, CATID_Control))
                {
                    m_arpCategoryInfo.Add(pCatInfo);
                    pCatInfo = new CATEGORYINFO;
                }
            }
            delete pCatInfo;
            
            penum->Release();
        }
        pci->Release();
    }
}


void CComponentCategory::EnumComponents()
{   
    ICatInformation* pci;
    HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, MMC_CLSCTX_INPROC, 
                                    IID_ICatInformation, (void**)&pci);
    if (SUCCEEDED(hr))
    {
        IEnumCLSID* penumClass;
        hr = pci->EnumClassesOfCategories(1, const_cast<GUID*>(&CATID_Control), 0, NULL, &penumClass);
        if (SUCCEEDED(hr)) 
        {
            CLSID   clsid;
            while (penumClass->Next(1, &clsid, NULL) == S_OK)
            {

                TCHAR   szCLSID [40];
#ifdef _UNICODE
                StringFromGUID2(clsid, szCLSID, countof(szCLSID));
#else
                WCHAR wszCLSID[40];
                StringFromGUID2(clsid, wszCLSID, countof(wszCLSID));
                WideCharToMultiByte(CP_ACP, 0, wszCLSID, -1, szCLSID, sizeof(szCLSID), NULL, NULL);
#endif // _UNICODE
                
                COMPONENTINFO* pComponentInfo = new COMPONENTINFO;
 
                TCHAR szName[MAX_PATH];
                szName[0] = _T('\0');

                long cb = sizeof(szName)/sizeof(TCHAR);
            
                // Get control class name
                RegQueryValue(HKEY_CLASSES_ROOT, CStr("CLSID\\") + szCLSID, szName, &cb); 
                if (szName[0] != _T('\0'))
                    pComponentInfo->m_strName = szName;
                else
                    pComponentInfo->m_strName = szCLSID;

                // set the remainder attributes
                pComponentInfo->m_clsid = clsid;
                pComponentInfo->m_uiBitmap=0; // (WayneSc) need to open up exe
                pComponentInfo->m_bSelected = TRUE;

                // Add component to array
                m_arpComponentInfo.Add(pComponentInfo);
            } 
            penumClass->Release();
        }
        pci->Release();
    }
}

void CComponentCategory::FilterComponents(CATEGORYINFO* pCatInfo)
{
    ICatInformation* pci;
    HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, MMC_CLSCTX_INPROC, 
                                    IID_ICatInformation, (void**)&pci);
    if (SUCCEEDED(hr))
    {
        for (int i=0; i <= m_arpComponentInfo.GetUpperBound(); i++)
        {
            COMPONENTINFO* pCompInfo = m_arpComponentInfo.GetAt(i);

            // if NULL categories, select all conponents
            if (pCatInfo == NULL)
            {
                pCompInfo->m_bSelected = TRUE;
            }
            else
            {
                // Query if component implements the category
                pCompInfo->m_bSelected = 
                    (pci->IsClassOfCategories(pCompInfo->m_clsid, 1, &pCatInfo->catid, 0, NULL) == S_OK);
            } 
        }
        pci->Release();
    }
}


// Helper function to create a component category and associated description
HRESULT CComponentCategory::CreateComponentCategory(CATID catid, WCHAR* catDescription)
    {

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, MMC_CLSCTX_INPROC, IID_ICatRegister, (void**)&pcr);


    if (FAILED(hr))
        return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

    // Make sure the provided description is not too long.
    // Only copy the first 127 characters if it is
    int len = wcslen(catDescription);
    if (len>127)
        len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
    // Make sure the description is null terminated
    catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
    pcr->Release();

    return hr;
    }

// Helper function to register a CLSID as belonging to a component category
HRESULT CComponentCategory::RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, MMC_CLSCTX_INPROC, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
    return hr;
    }

// Helper function to unregister a CLSID as belonging to a component category
HRESULT CComponentCategory::UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, MMC_CLSCTX_INPROC, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\colwidth.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       colwidth.h
//
//  Contents:   Classes related to column persistence.
//
//  Classes:    CColumnInfo, CColumnPersistInfo
//              CColumnsDlg.
//
//  History:    14-Oct-98 AnandhaG     Created
//
//--------------------------------------------------------------------

#ifndef COLWIDTH_H
#define COLWIDTH_H
#pragma once

#pragma warning(disable: 4503) // Disable long name limit warnings

#include "columninfo.h"

using namespace std;

class  CColumnPersistInfo;
class  CColumnsDlg;

// Column Persistence Versioning
// Version 1 has
//    "Col index (seen by snapin)" "Width" "Format" in order.
static const INT COLPersistenceVersion = 2;

// We allow the list to grow COLUMNS_MAXLIMIT times more,
// then we do garbage collection.
#define  COLUMNS_MAXLIMIT           0.4


//+-------------------------------------------------------------------
//
//  Class:      CColumnSortInfo
//
//  Purpose:    Columns sort information.
//              The column that is sorted and direction.
//
//  History:    10-27-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnSortInfo : public CSerialObject, public CXMLObject
{
public:
    friend class  CColumnPersistInfo;
    friend class  CNode;
    friend class  CColumnsDlg;
    friend struct ColPosCompare;
    friend class  CColumnData;

public:
    CColumnSortInfo () : m_nCol(-1), m_dwSortOptions(0),
                         m_lpUserParam(NULL)
        {}

    CColumnSortInfo (INT nCol, DWORD dwSortOptions)
                : m_nCol(nCol), m_dwSortOptions(dwSortOptions),
                  m_lpUserParam(NULL)
    {
    }

    CColumnSortInfo(const CColumnSortInfo& colInfo)
    {
        m_nCol = colInfo.m_nCol;
        m_dwSortOptions = colInfo.m_dwSortOptions;
        m_lpUserParam = colInfo.m_lpUserParam;
    }

    CColumnSortInfo& operator=(const CColumnSortInfo& colInfo)
    {
        if (this != &colInfo)
        {
            m_nCol = colInfo.m_nCol;
            m_dwSortOptions = colInfo.m_dwSortOptions;
            m_lpUserParam = colInfo.m_lpUserParam;
        }

        return (*this);
    }

    bool operator ==(const CColumnSortInfo &colinfo) const
    {
        return ( (m_nCol      == colinfo.m_nCol)      &&
                 (m_dwSortOptions == colinfo.m_dwSortOptions) &&
                 (m_lpUserParam == colinfo.m_lpUserParam) );
    }

    INT  getColumn() const         { return m_nCol;}
    DWORD getSortOptions() const   { return m_dwSortOptions;}
    ULONG_PTR getUserParam() const { return m_lpUserParam;}

protected:
    INT   m_nCol;                // The index supplied when snapin inserted the column.
                                 // This is not the index viewed by the user.
    DWORD     m_dwSortOptions;   // Sort flags like Ascending/Descending, Sort icon...
    ULONG_PTR m_lpUserParam;     // Snapin supplied user param.

protected:
    // CSerialObject methods
    virtual UINT    GetVersion()     {return 2;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);

protected:
    DEFINE_XML_TYPE(XML_TAG_COLUMN_SORT_INFO);
    virtual void Persist(CPersistor &persistor);
};

//+-------------------------------------------------------------------
//
//  Class:      CColumnSortList
//
//  Purpose:    linked list with CColumnInfo's.
//
//  History:    02-11-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnSortList : public list<CColumnSortInfo>, public CSerialObject
{
public:
    friend class  CColumnSetData;

public:
    CColumnSortList ()
    {
    }

    ~CColumnSortList()
    {
    }

protected:

    void PersistSortList(CPersistor& persistor);

    // CSerialObject methods
    virtual UINT    GetVersion()     {return 1;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);
};

//+-------------------------------------------------------------------
//
//  Class:      CColumnSetData
//
//  Purpose:    Data for a ColumnSetID. That is the data pertaining to
//              set of columns associated with a node. This data includes
//              column width, order, hidden/visible status. It also
//              includes the column on which we have sorted and the
//              order.
//
//  History:    01-13-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnSetData : public CSerialObject, public CXMLObject
{
public:
    friend class  CColumnPersistInfo;
    friend class  CColumnsDlg;

public:
    CColumnSetData ()
    {
        m_colInfoList.clear();
        m_colSortList.clear();

        m_dwRank = -1;
        m_bInvalid = FALSE;
    }

    ~CColumnSetData()
    {
        m_colInfoList.clear();
        m_colSortList.clear();

        m_dwRank = -1;
        m_bInvalid = FALSE;
    }

    CColumnSetData(const CColumnSetData& colSetInfo)
    {
        m_colInfoList  = colSetInfo.m_colInfoList;
        m_colSortList  = colSetInfo.m_colSortList;

        m_dwRank       = colSetInfo.m_dwRank;
        m_bInvalid     = FALSE;
    }

    CColumnSetData& operator=(const CColumnSetData& colSetInfo)
    {
        if (this != &colSetInfo)
        {
            m_colInfoList = colSetInfo.m_colInfoList;
            m_colSortList = colSetInfo.m_colSortList;

            m_dwRank      = colSetInfo.m_dwRank;
            m_bInvalid    = colSetInfo.m_bInvalid;
        }

        return (*this);
    }

    bool operator ==(const CColumnSetData &colinfo) const
    {
        return (false);
    }

    bool operator< (const CColumnSetData& colSetInfo)
    {
        return (m_dwRank < colSetInfo.m_dwRank);
    }

    CColumnInfoList*  get_ColumnInfoList()
    {
        return &m_colInfoList;
    }

    void set_ColumnInfoList(const CColumnInfoList& colInfoList)
    {
        m_colInfoList = colInfoList;
    }

    CColumnSortList*  get_ColumnSortList()
    {
        return &m_colSortList;
    }

    void set_ColumnSortList(CColumnSortList& colSortList)
    {
        m_colSortList = colSortList;
    }

protected:
    // Needed for book keeping.
    DWORD                m_dwRank;            // Usage rank.
    BOOL                 m_bInvalid;          // For garbage collection.

protected:
    // Persisted data.
    CColumnInfoList      m_colInfoList;
    CColumnSortList      m_colSortList;

protected:
    // CSerialObject methods
    // Version 2 had view settings removed. This data should be skipped while reading
    // version 1 files.
    virtual UINT    GetVersion()     {return 2;}
    virtual HRESULT ReadSerialObject (IStream &stm, UINT nVersion /*,LARGE_INTEGER nBytes*/);

protected:
    DEFINE_XML_TYPE(XML_TAG_COLUMN_SET_DATA);
    virtual void Persist(CPersistor &persistor);
};

typedef const BYTE *        LPCBYTE;
typedef std::vector<BYTE>   ByteVector;


//+-------------------------------------------------------------------
//
//  Class:      CColumnSetID
//
//  Purpose:    Identifier for a Column-Set. A a column-set is a set of
//              columns inserted by a snapin. When the user selects a
//              different node in that snapin same or different column-set
///             may be shown by the snapin.     MMC asks snapin to provide an
//              ID (either SColumnSetID or NodeTypeGuid) to uniquely identify
//              each column-set so that it can persist the column data.
//              This enables MMC to use this GUID to load and use the column
//              data across different instances,locales and systems.
//
//  History:    02-08-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnSetID : public CXMLObject
{
public:
    friend class  CColumnPersistInfo;

    friend IStream& operator>> (IStream& stm, CColumnSetID& colID);
    friend IStream& operator<< (IStream& stm, const CColumnSetID& colID);

private:
    void CommonConstruct (const SColumnSetID& refColID)
    {
        m_vID.clear();
        m_dwFlags = refColID.dwFlags;
        m_vID.insert (m_vID.begin(), refColID.id, refColID.id + refColID.cBytes);
    }

    void CommonConstruct (const CLSID& clsidNodeType)
    {
        m_dwFlags = 0;
        BYTE* pbByte = (BYTE*)&clsidNodeType;

        if (pbByte != NULL)
        {
            m_vID.clear();
            m_vID.insert (m_vID.begin(), pbByte, pbByte + sizeof(CLSID));
        }
    }

public:
    CColumnSetID() : m_dwFlags(0)
    {
    }

    ~CColumnSetID() {}

    CColumnSetID(LPCBYTE& pbInit)
    {
        // pbInit now points to a SColumnSetID; initialize from it
        const SColumnSetID*  pColID = reinterpret_cast<const SColumnSetID*>(pbInit);
        CommonConstruct (*pColID);

        // bump the input pointer to the next element
        pbInit += sizeof (pColID->cBytes) + pColID->cBytes;
    }

    CColumnSetID(const SColumnSetID& refColID)
    {
        CommonConstruct (refColID);
    }


    CColumnSetID(const CLSID& clsidNodeType)
    {
        CommonConstruct (clsidNodeType);
    }

    CColumnSetID(const CColumnSetID& colID)
    {
        m_dwFlags = colID.m_dwFlags;
        m_vID = colID.m_vID;
    }

    CColumnSetID& operator=(const CColumnSetID& colID)
    {
        if (this != &colID)
        {
            m_dwFlags = colID.m_dwFlags;
            m_vID = colID.m_vID;
        }

        return (*this);
    }

    bool operator ==(const CColumnSetID& colID) const
    {
        return (m_vID == colID.m_vID);
    }

    bool operator <(const CColumnSetID& colID) const
    {
        return (m_vID < colID.m_vID);
    }

    DWORD GetFlags() const   { return m_dwFlags; }
    int  empty ()   const    { return (m_vID.empty()); }

    DEFINE_XML_TYPE(NULL); // not to be persisted as alone element
    virtual void    Persist(CPersistor &persistor);

protected:
    DWORD       m_dwFlags;
    ByteVector  m_vID;
};


//+-------------------------------------------------------------------
//
//  Member:     operator>>
//
//  Synopsis:   Writes CColumnSetID data to stream.
//
//  Arguments:  [stm]   - The input stream.
//              [colID] - CColumnSetID structure.
//
//                          The format is :
//                              DWORD  flags
//                              ByteVector
//
//--------------------------------------------------------------------
inline IStream& operator>> (IStream& stm, CColumnSetID& colID)
{
    return (stm >> colID.m_dwFlags >> colID.m_vID);
}


//+-------------------------------------------------------------------
//
//  Member:     operator<<
//
//  Synopsis:   Reads CColumnSortInfo data from the stream.
//
//  Arguments:  [stm]   - The stream to write to.
//              [colID] - CColumnSetID structure.
//
//                          The format is :
//                              DWORD  flags
//                              ByteVector
//
//--------------------------------------------------------------------
inline IStream& operator<< (IStream& stm, const CColumnSetID& colID)
{
    return (stm << colID.m_dwFlags << colID.m_vID);
}

//+-------------------------------------------------------------------
//
//  Data structures used to persist column information:
//
// Column information is persisted as follows:
// Internally, the following data structure is used. Column information
// is recorded per snapin, per column ID, per view.
//        map               map             map
// CLSID ------> column ID ------> view ID -----> iterator to a list
// containing data.
//
// The data itself is stored in an object of type CColumnSetData.
// This has subobjects to store column width, column sorting, and view
// options.
//
// The list contains CColumnSetData to all the views, all snapins
// and all col-ids.
//
// Persistence: The information is serialized as follows:
//
// 1) Stream version
// 2) Number of snapins
// 3) For each snapin:
//    i)  snapin CLSID
//    ii) number of column IDs
//        For each column ID:
//        i)  column ID
//        ii) Number of views
//            For each view:
//            i)  View ID
//            ii) Column data (CColumnSetData).
//--------------------------------------------------------------------

//*********************************************************************
//
// Note:
//     The alpha compiler is unable to resolve long names and calls
//     wrong version of stl::map::erase (bug# 295465).
//     So we derive dummy classes like I1, V1, C1, S1 to shorten
//     those names.
//
//     To repro the problem define _ALPHA_BUG_IN_MMC and compile mmc
//
// Classes: I1, V1, C1, S1
//
//     For version 2.0 the change was undone. But the names are not
//     long anymore, since classes are derived from maps (not typedef'ed)
//
//*********************************************************************
//*********************************************************************

// A list of all ColumnSet datas.
typedef list<CColumnSetData >                       ColSetDataList;

    typedef ColSetDataList::iterator                    ItColSetDataList;

    // A one to one map from ViewID to iterator to CColumnSetData.
    class ViewToColSetDataMap : public map<int /*nViewID*/, ItColSetDataList>
    {
    };
    typedef ViewToColSetDataMap::value_type             ViewToColSetDataVal;

    // A one to one map from CColumnSetID to ViewToColSetDataMap.
    class ColSetIDToViewTableMap : public map<CColumnSetID, ViewToColSetDataMap>
    {
    };
    typedef ColSetIDToViewTableMap::value_type          ColSetIDToViewTableVal;

    // A one to one map from Snapin GUID to ColSetIDToToViewTableMap (snapins widthsets)
    class SnapinToColSetIDMap : public map<CLSID, ColSetIDToViewTableMap>
    {
    };
    typedef SnapinToColSetIDMap::value_type             SnapinToColSetIDVal;

//+-------------------------------------------------------------------
//
//  Some helper data structures that wont be persisted.
//
//--------------------------------------------------------------------
// A vector of strings to store column names
typedef vector<tstring>                     TStringVector;


//+-------------------------------------------------------------------
//
//  Class:      CColumnPersistInfo
//
//  Purpose:    This class has column persistence information for all
//              views (therefore one per instance of mmc).
//              Knows to load/save the info from streams.
//
//  History:    10-27-1998   AnandhaG   Created
//
//  Data structures used to persist column information:
//      A map from the ViewID to the CColumnSetData class.
//      A multimap from ColumnSet-ID to above map.
//      A map that maps snapin GUID to above map.
//
//--------------------------------------------------------------------
class CColumnPersistInfo : public IPersistStream, public CComObjectRoot, public CXMLObject
{
private:
    BOOL                            m_bInitialized;
    auto_ptr<ColSetDataList>        m_spColSetList;
    auto_ptr<SnapinToColSetIDMap>   m_spSnapinsMap;

    // This is the max number of items specified by user???
    // We go 40% more so that we dont do garbage collection often.
    DWORD                           m_dwMaxItems;

    BOOL                            m_bDirty;

private:
    BOOL ClearAllEntries();

public:
    /*
     * ATL COM map
     */
    BEGIN_COM_MAP (CColumnPersistInfo)
        COM_INTERFACE_ENTRY (IPersistStream)
    END_COM_MAP ()

public:
    CColumnPersistInfo();
    ~CColumnPersistInfo();

    BOOL Init();

    BOOL RetrieveColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                             INT nViewID, CColumnSetData& columnSetData);
    BOOL SaveColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                         INT nViewID, CColumnSetData& columnSetData);
    VOID DeleteColumnData( const CLSID& refSnapinCLSID, const SColumnSetID& colID,
                           INT nViewID);

    BOOL DeleteColumnDataOfSnapin( const CLSID& refSnapinCLSID);
    BOOL DeleteColumnDataOfView( int nViewID);

    VOID GarbageCollectItems();
    VOID DeleteMarkedItems();

    // IPersistStream methods
    STDMETHOD(IsDirty)(void)
    {
        if (m_bDirty)
            return S_OK;

        return S_FALSE;
    }

    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(GetClassID)(LPCLSID lpClsid)
    {
        lpClsid = NULL;
        return E_NOTIMPL;
    }

    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);

    DEFINE_XML_TYPE(XML_TAG_COLUMN_PERIST_INFO);
    virtual void    Persist(CPersistor &persistor);
};


//+-------------------------------------------------------------------
//
//  Class:      CColumnDlg
//
//  Purpose:    The column modification dialog.
//
//  History:    11-15-1998   AnandhaG   Created
//
//--------------------------------------------------------------------
class CColumnsDlg : public CDialogImpl<CColumnsDlg>
{
    typedef CColumnsDlg                ThisClass;
    typedef CDialogImpl<CColumnsDlg>   BaseClass;

// Constructor/Destrcutor
public:

    CColumnsDlg(CColumnInfoList *pColumnInfoList, TStringVector* pStringVector, CColumnInfoList& defaultColumnInfoList)
            : m_pColumnInfoList(pColumnInfoList), m_pStringVector(pStringVector), m_bDirty(false),
              m_DefaultColumnInfoList(defaultColumnInfoList), m_bUsingDefaultColumnSettings(false)
    {}


    ~CColumnsDlg()
     {}


//MSGMAP
public:
    BEGIN_MSG_MAP(ThisClass)
        MESSAGE_HANDLER    (WM_INITDIALOG,  OnInitDialog)
        CONTEXT_HELP_HANDLER()
        COMMAND_ID_HANDLER (IDOK,                   OnOK)
        COMMAND_ID_HANDLER (IDCANCEL,               OnCancel)
        COMMAND_ID_HANDLER (IDC_MOVEUP_COLUMN,      OnMoveUp)
        COMMAND_ID_HANDLER (IDC_MOVEDOWN_COLUMN ,   OnMoveDown)
        COMMAND_ID_HANDLER (IDC_ADD_COLUMNS,        OnAdd)
        COMMAND_ID_HANDLER (IDC_REMOVE_COLUMNS,     OnRemove)
        COMMAND_ID_HANDLER (IDC_RESTORE_DEFAULT_COLUMNS, OnRestoreDefaultColumns)
        COMMAND_HANDLER    (IDC_HIDDEN_COLUMNS, LBN_SELCHANGE, OnSelChange);
        COMMAND_HANDLER    (IDC_DISPLAYED_COLUMNS, LBN_SELCHANGE, OnSelChange);
        COMMAND_HANDLER    (IDC_HIDDEN_COLUMNS, LBN_DBLCLK, OnAdd);
        COMMAND_HANDLER    (IDC_DISPLAYED_COLUMNS, LBN_DBLCLK, OnRemove);
    END_MSG_MAP()

    IMPLEMENT_CONTEXT_HELP(g_aHelpIDs_IDD_COLUMNS);

public:
    // Operators
    enum { IDD = IDD_COLUMNS };

// Generated message map functions
protected:
    LRESULT OnInitDialog    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK            (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel        (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnMoveUp        (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnMoveDown      (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAdd           (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove        (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRestoreDefaultColumns (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSelChange     (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnHelp          (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    void    MoveItem        (BOOL bMoveUp);
    void    InitializeLists ();
    void    EnableUIObjects ();
    int     GetColIndex(LPCTSTR lpszColName);
    void    SetListBoxHorizontalScrollbar(WTL::CListBox& listBox);
    void    SetDirty() { m_bDirty = true; m_bUsingDefaultColumnSettings = false;}
    void    SetUsingDefaultColumnSettings() { m_bDirty = true; m_bUsingDefaultColumnSettings = true;}

    void    SetListBoxHScrollSize()
    {
        SetListBoxHorizontalScrollbar(m_DisplayedColList);
        SetListBoxHorizontalScrollbar(m_HiddenColList);

    }

private:

    WTL::CListBox           m_HiddenColList;
    WTL::CListBox           m_DisplayedColList;
    WTL::CButton            m_btnAdd;
    WTL::CButton            m_btnRemove;
    WTL::CButton            m_btnRestoreDefaultColumns;
    WTL::CButton            m_btnMoveUp;
    WTL::CButton            m_btnMoveDown;

    CColumnInfoList*        m_pColumnInfoList;
    TStringVector*          m_pStringVector;
    CColumnInfoList&        m_DefaultColumnInfoList;
    bool                    m_bDirty;
    bool                    m_bUsingDefaultColumnSettings;
};

#endif /* COLWIDTH_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\copypast.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       copypast.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "objfmts.h"
#include "copypast.h"
#include "multisel.h"
#include "dbg.h"
#include "rsltitem.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
|
| NOTE: DataObject Cleanup works by these rules (see CNode::CDataObjectCleanup):
|
|  1. Data object created for cut , copy or dragdrop registers every node added to it
|  2. Nodes are registered in the static multimap, mapping node to the data object it belongs to.
|  3. Node destructor checks the map and triggers cleanup for all affected data objects.
|  4. Data Object cleanup is: 	a) unregistering its nodes,
|  				b) release contained data objects
|  				b) entering invalid state (allowing only removal of cut objects to succeed)
|  				c) revoking itself from clipboard if it is on the clipboard.
|  It will not do any of following:	a) release references to IComponents as long as is alive
|  				b) prevent MMCN_CUTORMOVE to be send by invoking RemoveCutItems()
|
\***************************************************************************/

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject~CMMCClipBoardDataObject
 *
 * PURPOSE: Destructor. Informs CNode's that they are no longer on clipboard
 *
\***************************************************************************/
CMMCClipBoardDataObject::~CMMCClipBoardDataObject()
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::~CMMCClipBoardDataObject"));

    // inform all nodes put to clipboard about being removed from there
    // but do not ask to force clenup on itself - it is not needed (we are in desrtuctor)
    // and it is harmfull to cleanup ole in such a case (see bug #164789)
    sc = CNode::CDataObjectCleanup::ScUnadviseDataObject( this , false/*bForceDataObjectCleanup*/);
    if (sc)
        sc.TraceAndClear();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetSourceProcessId
 *
 * PURPOSE: returns process id of the source data object
 *
 * PARAMETERS:
 *    DWORD *pdwProcID - [out] id of source process
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetSourceProcessId( DWORD *pdwProcID )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetSourceProcessID"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(pdwProcID);
    if (sc)
        return sc.ToHr();

    // return the id
    *pdwProcID = ::GetCurrentProcessId();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetAction
 *
 * PURPOSE: returns ction which created the data object
 *
 * PARAMETERS:
 *    DATA_SOURCE_ACTION *peAction [out] - action
 *
 * RETURNS:
 *    HRESULT    - result code.
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetAction( DATA_SOURCE_ACTION *peAction )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::IsCreatedForCopy"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(peAction);
    if (sc)
        return sc.ToHr();

    // return the action
    *peAction = m_eOperation;

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetCount
 *
 * PURPOSE: Retuns the count of contined snapin data objects
 *
 * PARAMETERS:
 *    DWORD *pdwCount   [out] - count of objects
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetCount( DWORD *pdwCount )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetCount"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(pdwCount);
    if (sc)
        return sc.ToHr();

    *pdwCount = m_SelectionObjects.size();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetDataObject
 *
 * PURPOSE: Returns one of contained snapin data objects
 *
 * PARAMETERS:
 *    DWORD dwIndex           [in] - index of reqested object
 *    IDataObject **ppObject  [out] - requested object
 *    DWORD *pdwFlags         [out] - object flags
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetDataObject( DWORD dwIdx, IDataObject **ppObject, DWORD *pdwFlags )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetDataObject"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // check out param
    sc = ScCheckPointers(ppObject, pdwFlags);
    if (sc)
        return sc.ToHr();

    // init out param
    *ppObject = NULL;
    *pdwFlags = 0;

    // more parameter check
    if ( dwIdx >= m_SelectionObjects.size() )
        return (sc = E_INVALIDARG).ToHr();

    // return the object
    IDataObjectPtr spObject = m_SelectionObjects[dwIdx].spDataObject;
    *ppObject = spObject.Detach();
    *pdwFlags = m_SelectionObjects[dwIdx].dwSnapinOptions;

    return sc.ToHr();
}

///////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScGetSingleSnapinObject
 *
 * PURPOSE: Returns interface to data object created by the source snapin
 *          NOTE: returns S_FALSE (and NULL ptr) when snapin count is not
 *          equal to one
 *
 * PARAMETERS:
 *    IDataObject **ppDataObject [out] - interface to data object
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScGetSingleSnapinObject( IDataObject **ppDataObject )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetContainedSnapinObject"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return sc = E_UNEXPECTED;

    // parameter check
    sc = ScCheckPointers( ppDataObject );
    if (sc)
        return sc;

    // init out parameter
    *ppDataObject = NULL;

    // we can only resolve to the snapin if we have only one of them
    if ( m_SelectionObjects.size() != 1 )
        return sc = S_FALSE;

    // ask for snapins DO
    IDataObjectPtr spDataObject = m_SelectionObjects[0].spDataObject;

    // return
    *ppDataObject = spDataObject.Detach();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetDataHere
 *
 * PURPOSE: Implements IDataObject::GetDataHere. Forwards to snapin or fails
 *
 * PARAMETERS:
 *    LPFORMATETC lpFormatetc
 *    LPSTGMEDIUM lpMedium
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetDataHere"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(lpFormatetc, lpMedium);
    if (sc)
        return sc.ToHr();

    // try to get the snapin
    IDataObjectPtr spDataObject;
    sc = ScGetSingleSnapinObject( &spDataObject );
    if (sc)
        return sc.ToHr();

    // we do not support any clipboard format at all ourselves
    if (sc == S_FALSE)
        return (sc = DATA_E_FORMATETC).ToHr();

    // recheck
    sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    // forward to the snapin
    sc = spDataObject->GetDataHere(lpFormatetc, lpMedium);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetData
 *
 * PURPOSE: Implements IDataObject::GetData. Forwards to snapin or fails
 *
 * PARAMETERS:
 *    LPFORMATETC lpFormatetcIn
 *    LPSTGMEDIUM lpMedium
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::GetData"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(lpFormatetcIn, lpMedium);
    if (sc)
        return sc.ToHr();

    // try to get the snapin
    IDataObjectPtr spDataObject;
    sc = ScGetSingleSnapinObject( &spDataObject );
    if (sc)
        return sc.ToHr();

    // we do not support any clipboard format at all ourselves
    if (sc == S_FALSE)
        return (sc = DATA_E_FORMATETC).ToHr();

    // recheck
    sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    // forward to the snapin
    sc = spDataObject->GetData(lpFormatetcIn, lpMedium);
    if (sc)
    {
        HRESULT hr = sc.ToHr();
        sc.Clear(); // ignore the error
        return hr;
    }

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::EnumFormatEtc
 *
 * PURPOSE: Implements IDataObject::EnumFormatEtc. Forwards to snapin or fails
 *
 * PARAMETERS:
 *    DWORD dwDirection
 *    LPENUMFORMATETC* ppEnumFormatEtc
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::EnumFormatEtc"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(ppEnumFormatEtc);
    if (sc)
        return sc.ToHr();

    // init out parameter
    *ppEnumFormatEtc = NULL;

    IEnumFORMATETCPtr spEnum;
    std::vector<FORMATETC> vecFormats;

    // add own entry
    if (dwDirection == DATADIR_GET)
    {
        FORMATETC fmt ={GetWrapperCF(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        vecFormats.push_back( fmt );
    }

    // try to get the snapin
    IDataObjectPtr spDataObject;
    sc = ScGetSingleSnapinObject( &spDataObject );
    if (sc)
        return sc.ToHr();

    // add snapins formats (when we have one-and-only snapin)
    IEnumFORMATETCPtr spEnumSnapin;
    if (sc == S_OK)
    {
        // recheck
        sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
        if (sc)
            return sc.ToHr();

        // forward to the snapin
        sc = spDataObject->EnumFormatEtc(dwDirection, &spEnumSnapin);
        if ( !sc.IsError() )
        {
            // recheck the pointer
            sc = ScCheckPointers( spEnumSnapin );
            if (sc)
                return sc.ToHr();

            // reset the enumeration
            sc = spEnumSnapin->Reset();
            if (sc)
                return sc.ToHr();

            FORMATETC frm;
            ZeroMemory( &frm, sizeof(frm) );

            while ( (sc = spEnumSnapin->Next( 1, &frm, NULL )) == S_OK )
            {
                vecFormats.push_back( frm );
            }
            // trap the error
            if (sc)
                return sc.ToHr();


        }
        else
        {
            sc.Clear(); // ignore the error - some snapins does not implement it
        }
    }

    if ( vecFormats.size() == 0 ) // have nothing to return ?
        return (sc = E_FAIL).ToHr();

    // create the enumerator
    sc = ::GetObjFormats( vecFormats.size(), vecFormats.begin(), (void **)ppEnumFormatEtc );
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::QueryGetData
 *
 * PURPOSE: Implements IDataObject::QueryGetData. Forwards to snapin or fails
 *
 * PARAMETERS:
 *    LPFORMATETC lpFormatetc
 *
 * RETURNS:
 *    HRESULT    - result code. S_OK, or error code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::QueryGetData(LPFORMATETC lpFormatetc)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::QueryGetData"));

    // should not be called on this object (too late)
    if ( !m_bObjectValid )
        return (sc = E_UNEXPECTED).ToHr();

    // parameter check
    sc = ScCheckPointers(lpFormatetc);
    if (sc)
        return sc.ToHr();

    // try to get the snapin
    IDataObjectPtr spDataObject;
    sc = ScGetSingleSnapinObject( &spDataObject );
    if (sc)
        return sc.ToHr();

    // we do not support any clipboard format at all ourselves
    if (sc == S_FALSE)
        return DV_E_FORMATETC; // not assigning to sc - not an error

    // recheck
    sc = ScCheckPointers( spDataObject, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    // forward to the snapin
    sc = spDataObject->QueryGetData(lpFormatetc);
    if (sc)
    {
        HRESULT hr = sc.ToHr();
        sc.Clear(); // ignore the error
        return hr;
    }

    return sc.ToHr();
}


/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::RemoveCutItems
 *
 * PURPOSE: Called to remove copied objects from the source snapin
 *
 * PARAMETERS:
 *    DWORD dwIndex                 [in] snapin index
 *    IDataObject *pCutDataObject   [in] items to be removed
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
STDMETHODIMP CMMCClipBoardDataObject::RemoveCutItems( DWORD dwIndex, IDataObject *pCutDataObject )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::RemoveCutItems"));

    // this is the only method allowed to be called on invalid object

    // check param
    sc = ScCheckPointers(pCutDataObject);
    if (sc)
        return sc.ToHr();

    // more parameter check
    if ( dwIndex >= m_SelectionObjects.size() )
        return (sc = E_INVALIDARG).ToHr();


    // get to the snapin
    IComponent *pComponent = m_SelectionObjects[dwIndex].spComponent;
    sc = ScCheckPointers( pComponent, E_UNEXPECTED );
    if (sc)
        return sc.ToHr();

    sc = pComponent->Notify( NULL, MMCN_CUTORMOVE,
                             reinterpret_cast<LONG_PTR>(pCutDataObject), 0 );
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

///////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScCreateInstance
 *
 * PURPOSE: Helper method (static) to create instance of CMMCClipBoardDataObject
 *
 * PARAMETERS:
 *    DATA_SOURCE_ACTION operation          [in] why the object is created
 *    CMTNode *pTiedObj                     [in] object to trigger revoking
 *    CMMCClipBoardDataObject **ppRawObject [out] raw pointer
 *    IMMCClipboardDataObject **ppInterface [out] pointer to interface
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScCreateInstance(DATA_SOURCE_ACTION operation,
                                             CMMCClipBoardDataObject **ppRawObject,
                                             IMMCClipboardDataObject **ppInterface)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::ScCreateInstance"));

    // parameter check;
    sc = ScCheckPointers( ppRawObject, ppInterface );
    if (sc)
        return sc;

    // out param initialization
    *ppInterface = NULL;
    *ppRawObject = NULL;

    typedef CComObject<CMMCClipBoardDataObject> CreatedObj;
    CreatedObj *pCreatedObj;

    sc = CreatedObj::CreateInstance( &pCreatedObj );
    if (sc)
        return sc;

    // add first reference if non null;
    IMMCClipboardDataObjectPtr spMMCDataObject = pCreatedObj;

    // recheck
    sc = ScCheckPointers( spMMCDataObject, E_UNEXPECTED );
    if (sc)
    {
        delete pCreatedObj;
        return sc;
    }

    // init the object
    static_cast<CMMCClipBoardDataObject *>(pCreatedObj)->m_eOperation = operation;

    // return 'em
    *ppInterface = spMMCDataObject.Detach();
    *ppRawObject = pCreatedObj;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScAddSnapinDataObject
 *
 * PURPOSE: Part of creating DO for the operation
 *          Adds snapins data to be carried inside
 *
 * PARAMETERS:
 *    IComponent *pComponent   [in] - source snapin, which data id added
 *    IDataObject *pObject     [in] - data object supplied by snapin
 *    bool bCopyEnabled        [in] - if snapin allows to copy the data
 *    bool bCutEnabled         [in] - if snapin allows to move the data
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScAddSnapinDataObject( const CNodePtrArray& nodes,
                                                   IComponent *pComponent,
                                                   IDataObject *pObject,
                                                   bool bCopyEnabled, bool bCutEnabled )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::ScAddSnapinDataObject"));

    // parameter check
    sc = ScCheckPointers( pComponent, pObject );
    if (sc)
        return sc;

    // create the object;
    ObjectEntry object;
    object.dwSnapinOptions = (bCopyEnabled ? COPY_ALLOWED : 0) |
                             (bCutEnabled ? MOVE_ALLOWED : 0);
    object.spComponent = pComponent;
    object.spDataObject = pObject;

    // register the nodes to invalidate this data object on destruction
    for ( CNodePtrArray::const_iterator it = nodes.begin(); it != nodes.end(); ++it )
    {
        CNode *pNode = *it;
        sc = ScCheckPointers( pNode, E_UNEXPECTED );
        if (sc)
            return sc;

        // register node to revoke this object from destructor
        sc = CNode::CDataObjectCleanup::ScRegisterNode( pNode, this );
        if (sc)
            return sc;
    }

    // add to the array
    m_SelectionObjects.push_back(object);

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetNodeCopyAndCutVerbs
 *
 * PURPOSE: Calculates if copy and cut verb are enabled for node
 *
 * PARAMETERS:
 *    CNode* pNode              [in] node to examine
 *    IDataObject *pDataObject  [in] snapin's data object
 *    bool bScopePane           [in] Scope or result (item for which the verb states needed).
 *    LPARAM lvData             [in] If result then the LVDATA.
 *    bool *pCopyEnabled        [out] true == Copy verb enabled
 *    bool *bCutEnabled         [out] true == Cut verb enabled
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScGetNodeCopyAndCutVerbs( CNode* pNode, IDataObject *pDataObject,
                                                      bool bScopePane, LPARAM lvData,
                                                      bool *pbCopyEnabled, bool *pbCutEnabled )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::ScGetNodeCopyAndCutVerbs"));

    // paramter check
    sc = ScCheckPointers(pNode, pDataObject, pbCopyEnabled, pbCutEnabled);
    if (sc)
        return sc;

    // init out parameters
    *pbCopyEnabled = *pbCutEnabled = false;

    // Create temp verb with given context.
    CComObject<CTemporaryVerbSet> stdVerbTemp;

    sc = stdVerbTemp.ScInitialize(pDataObject, pNode, bScopePane, lvData);

    BOOL bFlag = FALSE;
    stdVerbTemp.GetVerbState(MMC_VERB_COPY, ENABLED, &bFlag);
    *pbCopyEnabled = bFlag;
    stdVerbTemp.GetVerbState(MMC_VERB_CUT, ENABLED, &bFlag);
    *pbCutEnabled = bFlag;

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScCreate
 *
 * PURPOSE: helper. Creates and initializes CMMCClipBoardDataObject
 *
 * PARAMETERS:
 *    DATA_SOURCE_ACTION operation       [in] - for which operation (d&d, cut, copy)
 *    CNode* pNode                       [in] - Node to tie to
 *    bool bScopePane                    [in] - if it is scope pane operation
 *    bool bMultiSelect                  [in] - if it is multiselection
 *    LPARAM lvData                      [in] - lvdata for result item
 *    IMMCClipboardDataObject **ppMMCDO  [out] - created data object
 *    bool& bContainsItems               [out] - If snapin does not support cut/copy then
 *                                               dataobjets will not be added and this is
 *                                               not an error
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScCreate( DATA_SOURCE_ACTION operation,
                                      CNode* pNode, bool bScopePane,
                                      bool bMultiSelect, LPARAM lvData,
                                      IMMCClipboardDataObject **ppMMCDataObject,
                                      bool& bContainsItems )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::Create"));

    bContainsItems = false;

    // parameter check
    sc = ScCheckPointers( ppMMCDataObject, pNode );
    if (sc)
        return sc;

    // init out param
    *ppMMCDataObject = NULL;

    // get MT node, view data;
    CMTNode* pMTNode = pNode->GetMTNode();
    CViewData *pViewData = pNode->GetViewData();
    sc = ScCheckPointers( pMTNode, pViewData, E_UNEXPECTED );
    if (sc)
        return sc;

    // create data object to be used for data transfer
    CMMCClipBoardDataObject    *pResultObject = NULL;
    IMMCClipboardDataObjectPtr spResultInterface;
    sc = ScCreateInstance(operation, &pResultObject, &spResultInterface);
    if (sc)
        return sc;

    // recheck pointers
    sc = ScCheckPointers( pResultObject, spResultInterface, E_UNEXPECTED );
    if (sc)
        return sc;

    // valid from the start
    pResultObject->m_bObjectValid = true;

    // add data to the object...

    if (!bMultiSelect) // single selection
    {
        // get snapins data object
        IDataObjectPtr spDataObject;
        CComponent*    pCComponent;
        bool           bScopeItem = bScopePane;
        sc = pNode->ScGetDataObject(bScopePane, lvData, bScopeItem, &spDataObject, &pCComponent);
        if (sc)
            return sc;

        // recheck data object
        if ( IS_SPECIAL_DATAOBJECT ( spDataObject.GetInterfacePtr() ) )
        {
            spDataObject.Detach();
            return sc = E_UNEXPECTED;
        }

        sc = ScCheckPointers(pCComponent, E_UNEXPECTED);
        if (sc)
            return sc;

        IComponent *pComponent = pCComponent->GetIComponent();
        sc = ScCheckPointers(pComponent, E_UNEXPECTED);
        if (sc)
            return sc;

        // add snapin's data object to transfer object
        sc = pResultObject->ScAddDataObjectForItem( pNode, bScopePane, lvData,
                                                    pComponent, spDataObject,
                                                    bContainsItems );
        if (sc)
            return sc;

        if (! bContainsItems)
            return sc;
    }
    else // result pane : multi selection
    {
        // get pointer to multiselection
        CMultiSelection *pMultiSel = pViewData->GetMultiSelection();
        sc = ScCheckPointers( pMultiSel, E_UNEXPECTED );
        if (sc)
            return sc;

        sc = pMultiSel->ScGetSnapinDataObjects(pResultObject);
        if (sc)
            return sc;
    }

    // if no items were added, something is wrong
    DWORD dwCount = 0;
    sc = pResultObject->GetCount( &dwCount );
    if (sc)
        return sc;

    if ( dwCount == 0 )
        return sc = E_UNEXPECTED;

    bContainsItems = true;

    // return interface
    *ppMMCDataObject = spResultInterface.Detach();

    return sc;
}


/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScAddDataObjectForItem
 *
 * PURPOSE: Adds data object for one item
 *
 * PARAMETERS:
 *    CNode* pNode              [in] - node to add (or one owning the item)
 *    bool bScopePane           [in] - if operation is on scope pane
 *    LPARAM lvData             [in] - if result pane the LVDATA
 *    IComponent *pComponent    [in] - snapins interface
 *    IDataObject *pDataObject  [in] - data object to add
 *    bool& bContainsItems     [out] - Are there any dataobjects added?
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScAddDataObjectForItem( CNode* pNode, bool bScopePane,
                                                    LPARAM lvData, IComponent *pComponent,
                                                    IDataObject *pDataObject ,
                                                    bool& bContainsItems)
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::ScAddDataObjectForScopeNode"));

    // Init out param.
    bContainsItems = false;

    // paramter check
    sc = ScCheckPointers( pNode, pComponent, pDataObject );
    if (sc)
        return sc;

    // get the verbs
    bool bCopyEnabled = false;
    bool bCutEnabled = false;
    sc = ScGetNodeCopyAndCutVerbs( pNode, pDataObject, bScopePane, lvData, &bCopyEnabled, &bCutEnabled);
    if (sc)
        return sc;

    // see it the data matches our criteria
    // (needs to allow something at least)
    if ( ( (m_eOperation == ACTION_COPY) && (bCopyEnabled == false) )
      || ( (m_eOperation == ACTION_CUT) && (bCutEnabled == false) )
      || ( (bCutEnabled == false)  && (bCopyEnabled == false) ) )
        return sc = S_FALSE;

    // add to the list
    sc = ScAddSnapinDataObject( CNodePtrArray(1, pNode), pComponent, pDataObject, bCopyEnabled, bCutEnabled );
    if (sc)
        return sc;

    bContainsItems = true;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::GetWrapperCF
 *
 * PURPOSE: Helper. registers and returns own clipboard format
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    CLIPFORMAT
 *
\***************************************************************************/
CLIPFORMAT CMMCClipBoardDataObject::GetWrapperCF()
{
    static CLIPFORMAT s_cf = 0;
    if (s_cf == 0)
        s_cf = (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_INTERNAL"));

    return s_cf;
}

/***************************************************************************\
 *
 * METHOD:  CMMCClipBoardDataObject::ScEnsureNotInClipboard
 *
 * PURPOSE: called to remove data from clipbord when comonent is destoyed
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCClipBoardDataObject::ScInvalidate( void )
{
    DECLARE_SC(sc, TEXT("CMMCClipBoardDataObject::ScEnsureNotInClipboard"));

    // not valid anymore
    m_bObjectValid = false;

    // release data objects
    for ( int i = 0; i< m_SelectionObjects.size(); i++)
        m_SelectionObjects[i].spDataObject = NULL;

    // check the clipboard
    sc = ::OleIsCurrentClipboard( this );
    if (sc)
        return sc;

    // it is on clipboard - remove
    if (sc == S_OK)
        OleSetClipboard(NULL);

    return sc;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\copypast.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       copypast.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7/21/1997   RaviR   Created
//____________________________________________________________________________
//

#ifndef COPYPAST_H__
#define COPYPAST_H__

/***************************************************************************\
 *
 * CLASS:  CMMCClipBoardDataObject
 *
 * PURPOSE: Implements IMMCClipboardDataObject - interface to data object
 *          added by MMC to the clipboard, or used in DragDrop operation.
 *          Also implements several methods for creating and initializing
 *          the object.
 *
 * USAGE:   Used in Cut, Copy, Paste and DragDrop operations.
 *          Static members are used to create the object, then it is passed to OLE
 *          Accessed via interface from the target ( same process or the external one)
 *
\***************************************************************************/
class CMMCClipBoardDataObject :
public IMMCClipboardDataObject,
public CComObjectRoot
{
public:

    typedef std::vector<CNode *> CNodePtrArray;


    // destructor
    ~CMMCClipBoardDataObject();

BEGIN_COM_MAP(CMMCClipBoardDataObject)
    COM_INTERFACE_ENTRY(IMMCClipboardDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

    // IMMCClipboardDataObject methods
    STDMETHOD(GetSourceProcessId)( DWORD *pdwProcID );
    STDMETHOD(GetAction)         ( DATA_SOURCE_ACTION *peAction );
    STDMETHOD(GetCount)          ( DWORD *pdwCount );
    STDMETHOD(GetDataObject)     ( DWORD dwIndex, IDataObject **ppObject, DWORD *pdwFlags );
    STDMETHOD(RemoveCutItems)    ( DWORD dwIndex, IDataObject *pCutDataObject );

    // IDataObject methods
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc);

    // Not Implemented IDataObject methods
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut) { return E_NOTIMPL; };
    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease) { return E_NOTIMPL; };
    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,LPADVISESINK pAdvSink, LPDWORD pdwConnection) { return E_NOTIMPL; };
    STDMETHOD(DUnadvise)(DWORD dwConnection) { return E_NOTIMPL; };
    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise) { return E_NOTIMPL; }

public:

    // method to add data objects
    SC ScAddSnapinDataObject( const CNodePtrArray& nodes, IComponent *pComponent, IDataObject *pDataObject,
                              bool bCopyEnabled, bool bCutEnabled );

    static SC ScCreate( DATA_SOURCE_ACTION operation,
                        CNode* pNode, bool bScope,
                        bool bMultiSelect, LPARAM lvData,
                        IMMCClipboardDataObject **ppMMCDataObject ,
                        bool& bContainsItems);

    // to remove going away snapins
    SC ScInvalidate( void );

private: // implementation helpers

    // returns DO of snapin if the object contains only one snapin
    SC ScGetSingleSnapinObject( IDataObject **ppDataObject );

    // method to create the instance
    static SC ScCreateInstance(DATA_SOURCE_ACTION operation,
                               CMMCClipBoardDataObject **ppRawObject,
                               IMMCClipboardDataObject **ppInterface);

    // helper to get node's verb state
    static SC ScGetNodeCopyAndCutVerbs( CNode* pNode, IDataObject *pDataObject,
                                      bool bScopePane, LPARAM lvData,
                                      bool *pbCopyEnabled, bool *pbCutEnabled );

    // method to add data objects for one item
    SC ScAddDataObjectForItem( CNode* pNode, bool bScopePane, LPARAM lvData,
                               IComponent *pComponent, IDataObject *pDataObject,
                               bool& bDataObjectAdded );

    CLIPFORMAT GetWrapperCF();

private: // data
    DATA_SOURCE_ACTION  m_eOperation;

    struct ObjectEntry
    {
        IDataObjectPtr  spDataObject;    // data
        IComponentPtr   spComponent;     // for Notification
        DWORD           dwSnapinOptions; // copy/cut allowed
    };

    std::vector<ObjectEntry> m_SelectionObjects;
    bool                     m_bObjectValid; // valid to access any icluded data objects
};


#endif // COPYPAST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\declspec.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       declspec.h
//
//--------------------------------------------------------------------------

// Used to import or export data in nodemgr DLL without the hassle of
// creating a .DEF file with decorated names.


#ifdef _NODEMGRDLL
    #define NM_DECLSPEC __declspec(dllexport)
#else
    #define NM_DECLSPEC __declspec(dllimport)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\ctrlbar.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctrlbar.h
//
//  Contents:   IControlbar implementation, peer of IExtendControlbar
//
//  Classes:    CControlbar
//
//  History:
//____________________________________________________________________________
//

#ifndef _CTRLBAR_H_
#define _CTRLBAR_H_

class CControlbarsCache;
class CMenuButton;
class CNode;
class CComponentPtrArray;
class CToolbar;


//+-------------------------------------------------------------------
//
//  class:     CControlbar
//
//  Purpose:   The IControlbar implementation that (equivalent
//             to IExtendControlbar). This allows manipulation
//             of toolbars & menu buttons.
//             The snapin and CSelData hold reference to this object.
//
//  History:    10-12-1999   AnandhaG   Created
//
//--------------------------------------------------------------------
class CControlbar : public IControlbar,
                    public CComObjectRoot
{
public:
    CControlbar();
    ~CControlbar();

    IMPLEMENTS_SNAPIN_NAME_FOR_DEBUG()

private:
    CControlbar(const CControlbar& controlBar);

public:
// ATL COM map
BEGIN_COM_MAP(CControlbar)
    COM_INTERFACE_ENTRY(IControlbar)
END_COM_MAP()


#ifdef DBG
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        bool b = 1;
        if (b)
            ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        bool b = 1;
        if (b)
            --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG


// IControlbar members
public:
    STDMETHOD(Create)(MMC_CONTROL_TYPE nType,
                      LPEXTENDCONTROLBAR pExtendControlbar,
                      LPUNKNOWN* ppUnknown);
    STDMETHOD(Attach)(MMC_CONTROL_TYPE nType, LPUNKNOWN  lpUnknown);
    STDMETHOD(Detach)(LPUNKNOWN lpUnknown);

public:
    HRESULT ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    SC ScCleanup();
    SC ScShowToolbars(bool bShow);

    // Toolbar button & Menu button click handler.
    SC ScNotifySnapinOfMenuBtnClick(HNODE hNode, bool bScope, LPARAM lParam, LPMENUBUTTONDATA lpmenuButtonData);
    SC ScNotifySnapinOfToolBtnClick(HNODE hNode, bool bScope, LPARAM lParam, UINT nID);

    // The CToolbar object calls this when it is being destroyed.
    // It wants Controlbar to stop referencing it.
    void DeleteFromToolbarsList(CToolbar *pToolbar)
    {
        m_ToolbarsList.remove(pToolbar);
    }

public:
    // Accessors.
    IExtendControlbar* GetExtendControlbar()
    {
        return m_spExtendControlbar;
    }
    void SetExtendControlbar(IExtendControlbar* pExtendControlbar,
                             const CLSID& clsidSnapin)
    {
        ASSERT(pExtendControlbar != NULL);
        ASSERT(m_spExtendControlbar == NULL);
        m_spExtendControlbar = pExtendControlbar;
        m_clsidSnapin = clsidSnapin;
    }
    void SetExtendControlbar(IExtendControlbar* pExtendControlbar)
    {
        ASSERT(pExtendControlbar != NULL);
        ASSERT(m_spExtendControlbar == NULL);
        m_spExtendControlbar = pExtendControlbar;
    }
    BOOL IsSameSnapin(const CLSID& clsidSnapin)
    {
        return IsEqualCLSID(m_clsidSnapin, clsidSnapin);
    }
    void SetCache(CControlbarsCache* pCache)
    {
        ASSERT(pCache != NULL);
        m_pCache = pCache;
    }

    CMenuButtonsMgr* GetMenuButtonsMgr()
    {
        CViewData* pViewData = GetViewData();
        if (NULL != pViewData)
        {
            return pViewData->GetMenuButtonsMgr();
        }

        return NULL;
    }

    CAMCViewToolbarsMgr* GetAMCViewToolbarsMgr()
    {
        CViewData* pViewData = GetViewData();
        if (NULL != pViewData)
        {
            return pViewData->GetAMCViewToolbarsMgr();
        }

        return NULL;
    }

private:
    // private methods
    CViewData* GetViewData();

    SC ScCreateToolbar(LPEXTENDCONTROLBAR pExtendControlbar, LPUNKNOWN* ppUnknown);
    SC ScCreateMenuButton(LPEXTENDCONTROLBAR pExtendControlbar, LPUNKNOWN* ppUnknown);
    SC ScAttachToolbar(LPUNKNOWN lpUnknown);
    SC ScAttachMenuButtons(LPUNKNOWN lpUnknown);
    SC ScDetachToolbars();
    SC ScDetachToolbar(LPTOOLBAR lpToolbar);
    SC ScDetachMenuButton(LPMENUBUTTON lpMenuButton);


// Implementation
private:
    IExtendControlbarPtr    m_spExtendControlbar;
    CLSID                   m_clsidSnapin;
    CControlbarsCache*      m_pCache;

    // List of IToolbar implementations (CToolbar) created.
    typedef  std::list<CToolbar*>   ToolbarsList;

    // Toolbars specific data
    ToolbarsList            m_ToolbarsList;
    CMenuButton*            m_pMenuButton; // One per IControlbar.

}; // class CControlbar


typedef CTypedPtrList<MMC::CPtrList, CControlbar*> CControlbarsList;

class CSelData
{
public:

    CSelData(bool bScopeSel, bool bSelect)
        :
        m_bScopeSel(bScopeSel), m_bSelect(bSelect), m_pNodeScope(NULL),
        m_pMS(NULL), m_pCtrlbarPrimary(NULL), m_lCookie(-1),
        m_pCompPrimary(NULL)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CSelData);
    }

    ~CSelData()
    {
        DECLARE_SC(sc, _T("CSelData::~CSelData"));
        sc = ScReset();
        DEBUG_DECREMENT_INSTANCE_COUNTER(CSelData);
    }

    SC ScReset();
    SC ScDestroyPrimaryCtrlbar();
    SC ScDestroyExtensionCtrlbars();
    SC ScShowToolbars(bool bShow);

    bool operator==(CSelData& rhs)
    {
        if (m_bScopeSel != rhs.m_bScopeSel ||
            m_bSelect != rhs.m_bSelect)
            return false;

        if (m_bScopeSel)
            return (m_pNodeScope == rhs.m_pNodeScope);
        else
            return (m_pMS == rhs.m_pMS && m_lCookie == rhs.m_lCookie);
    }

    CControlbar* GetControlbar(const CLSID& clsidSnapin);

    CControlbarsList& GetControlbarsList()
    {
        return m_listExtCBs;
    }

    bool IsScope()
    {
        return m_bScopeSel;
    }

    bool IsSelect()
    {
        return m_bSelect;
    }

// Implementation
    CComponent* m_pCompPrimary;
    CControlbar* m_pCtrlbarPrimary;
    CControlbarsList m_listExtCBs;
    IDataObjectPtr m_spDataObject;

    // data for scope sel
    CNode* m_pNodeScope;

    // data for result sel
    CMultiSelection* m_pMS;
    MMC_COOKIE m_lCookie;

    bool m_bScopeSel;
    bool m_bSelect;

}; // class CSelData


class CControlbarsCache : public IControlbarsCache,
                          public CComObjectRoot
{
public:
    CControlbarsCache() : m_pViewData(NULL), m_SelData(false, false)
    {
        DEBUG_INCREMENT_INSTANCE_COUNTER(CControlbarsCache);
    }
    ~CControlbarsCache()
    {
        DEBUG_DECREMENT_INSTANCE_COUNTER(CControlbarsCache);
    }

public:
// ATL COM map
BEGIN_COM_MAP(CControlbarsCache)
    COM_INTERFACE_ENTRY(IControlbarsCache)
END_COM_MAP()

// IControlbarsCache methods
public:
    STDMETHOD(DetachControlbars)()
    {
        DECLARE_SC(sc, _T("CControlbarsCache::DetachControlbars"));
        sc = m_SelData.ScReset();
        if (sc)
            return sc.ToHr();

        return sc.ToHr();
    }

public:
    HRESULT OnResultSelChange(CNode* pNode, MMC_COOKIE cookie, BOOL bSelected);
    HRESULT OnScopeSelChange(CNode* pNode, BOOL bSelected);
    HRESULT OnMultiSelect(CNode* pNodeScope, CMultiSelection* pMultiSelection,
                          IDataObject* pDOMultiSel, BOOL bSelect);

    void SetViewData(CViewData* pViewData);
    CViewData* GetViewData();
    SC ScShowToolbars(bool bShow)
    {
        DECLARE_SC(sc, _T("CControlbarsCache::ScShowToolbars"));
        return (sc = m_SelData.ScShowToolbars(bShow));
    }

private:
    CSelData m_SelData;
    CViewData* m_pViewData;

// private methods
    HRESULT _OnDeSelect(CSelData& selData);
    CControlbar* CreateControlbar(IExtendControlbarPtr& spECB,
                                     const CLSID& clsidSnapin);

    HRESULT _ProcessSelection(CSelData& selData,
                              CList<CLSID, CLSID&>& extnSnapins);

}; // class CControlbarsCache

#endif // _CTRLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\containr.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       Containr.h
//
//  Contents:   declarations of map and pair container classes
//
//  Classes:
//
//  Functions:
//
//  History:    10/8/98   VivekJ   Created
//
//____________________________________________________________________________




//#define MAPDBG
#pragma warning(disable : 4786)
template<typename _T1, typename _T2> class Pair
{
public:
    typedef _T1 First;
    typedef _T2 Second;
    Pair() {}
    Pair(const First& f, const Second& s) : m_First(f), m_Second(s) {}
    Pair(const Pair& p) : m_First(p.m_First), m_Second(p.m_Second) {}
    ~Pair() {}
    Pair& operator=(const Pair& p) { if (this != &p) {m_First = p.m_First; m_Second = p.m_Second; } return *this; }
    //bool operator==(const Pair& p) const { return m_First == p.m_First && m_Second == p.m_Second; }
    //bool operator!=(const Pair& p) const { return !operator==(p); }
    const First& GetFirst() const { return m_First; }
    void SetFirst(const First& f) { m_First = f; };
    const Second& GetSecond() const { return m_Second; }
    void SetSecond(const Second& s) { m_Second = s; };
    First* GetFirstPtr() { return reinterpret_cast<First*>(reinterpret_cast<char*>(this) + offsetof(Pair, m_First)); }
    Second* GetSecondPtr() { return reinterpret_cast<Second*>(reinterpret_cast<char*>(this) + offsetof(Pair, m_Second)); }
    const First* GetFirstPtr() const { return reinterpret_cast<const First*>(reinterpret_cast<const char*>(this) + offsetof(Pair, m_First)); }
    const Second* GetSecondPtr() const { return reinterpret_cast<const Second*>(reinterpret_cast<const char*>(this) + offsetof(Pair, m_Second)); }
private:
    First m_First;
    Second m_Second;
}; // class Pair

template<typename _T, typename _Key> class Map
// This is a temporary class which should be replaced by something that can
// hold smart pointers
{
public:
    typedef _T T;
    typedef _Key Key;

    typedef Pair<T, Key> Element;
    typedef Element* iterator;
    typedef const Element* const_iterator;

    explicit Map(size_t initialSize = 0)
        : m_nSize(0), m_nUsed(0), m_pMap(NULL), m_pNext(NULL)
        #ifdef MAPDBG
        , m_nFinds(0), m_nCompares(0)
        #endif //MAPDBG
    {
        const bool bAllocated = Allocate(initialSize);
        ASSERT(m_nSize == initialSize);
        ASSERT(bAllocated);
    }

    Map(const Map& m)
        : m_nSize(0), m_nUsed(0), m_pMap(NULL), m_pNext(NULL)
        #ifdef MAPDBG
        , m_nFinds(0), m_nCompares(0)
        #endif //MAPDBG
    {
        ASSERT(&m != NULL);
        if (m.m_nUsed == 0)
            return;
        const bool bAllocated = Allocate(m.m_nUsed);
        ASSERT(bAllocated);
        if (!bAllocated)
            return;
        ASSERT(m_nSize == m.m_nUsed);
        ASSERT(m_pMap != NULL);
        m_pNext = UninitializedCopy(m_pMap, m.m_pMap, m_nSize);
        m_nUsed = m_nSize;
    }

    ~Map()
    {
        Destroy();
    }

    Map& operator=(const Map& m)
    {
        ASSERT(&m != NULL);
        if (&m == this)
            return *this;

        Destroy();

        if (m.m_nUsed == 0)
            return *this;

        const bool bAllocated = Allocate(m.m_nUsed);
        ASSERT(bAllocated);
        if (!bAllocated)
            return *this;
        ASSERT(m_nSize == m.m_nUsed);
        ASSERT(m_pMap != NULL);
        m_pNext = UninitializedCopy(m_pMap, m.m_pMap, m_nSize);
        m_nUsed = m_nSize;
        return *this;
    }
    
    const_iterator GetBegin() const
    {
        return m_pMap;
    }

    size_t GetSize() const
    {
        return m_nUsed;
    }

    Element* GetPair(size_t n) const
    {
        if (n >= m_nUsed)
            return NULL;
        else
            return m_pMap + n;
    }

    const_iterator GetEnd() const
    {
        return m_pMap + m_nUsed;
    }

    bool Allocate(size_t nSize)
    {
        ASSERT(m_nSize == 0 || nSize > m_nSize);
        if (nSize <= m_nSize)
            return true;

        Element* pNewMap = reinterpret_cast<Element*>(new char[nSize * sizeof(Element)]);
        ASSERT(pNewMap != NULL);
        if (pNewMap == NULL)
            return false;

        const size_t nUsed = m_nUsed;
        Element* const pCopied = UninitializedCopy(pNewMap, m_pMap, nUsed);
        ASSERT(pCopied != NULL);
        if (pCopied == NULL)
            return false;

        Destroy();
        m_pMap = m_pNext = pNewMap;
        m_nSize = nSize;
        m_nUsed = nUsed;
        return true;
    }

    bool Insert(const T& t, const Key& key)
    {
        ASSERT(&t != NULL);
        ASSERT(&key != NULL);
        Element* const pUnique = FindElement(key, false);
        if (pUnique != NULL)
            return false;
        ASSERT(m_nUsed <= m_nSize);
        if (m_nUsed >= m_nSize)
        {
            const unsigned long nNewSize = m_nSize == 0 ? 1 : m_nSize + (m_nSize + 1) / 2;
            const bool bMoreAllocated = Allocate(nNewSize);
            ASSERT(bMoreAllocated);
            if (!bMoreAllocated)
                return false;
        }
        Element e(t, key);
        Element* const dest = m_pMap + m_nUsed++;
        m_pNext = UninitializedCopy(dest, &e, 1);
        ASSERT(m_pNext != NULL);
        return true;
    }

    bool Remove(const Key& key)
    {
        ASSERT(&key != NULL);
        Element* const e = FindElement(key);
        if (e == NULL)
            return false;
        Element* endOfUsed = m_pMap + m_nUsed--;
        ASSERT(e < endOfUsed);
        ASSERT(e >= m_pMap);
        const size_t numberToCopy = endOfUsed - (e + 1);
        Copy(const_cast<Element*>(e), e+1, numberToCopy);
        (endOfUsed - 1)->~Pair<T, Key>();
        if (m_pNext >= endOfUsed)
            m_pNext = m_pMap;
        return true;
    }
    
    T& operator[](const Key& key) const
    {
        ASSERT(&key != NULL);
        T* const t = Find(key);
        ASSERT(t != NULL);
        return *t;
    }

    T* Find(const Key& key) const
    {
        ASSERT(&key != NULL);
        Element* const e = FindElement(key);
        return e != NULL ? e->GetFirstPtr() : NULL;
    }

    size_t Size() const
    {
        return m_nUsed;
    }

    size_t MaxSize() const
    {
        return m_nSize;
    }

    bool Empty() const
    {
        return m_nUsed > 0;
    }

    void Clear()
    {
        Destroy();
    }

private:
    Element* m_pMap;
    size_t m_nSize;
    size_t m_nUsed;
    mutable Element* m_pNext;
    #ifdef MAPDBG
    mutable unsigned long m_nFinds;
    mutable unsigned long m_nCompares;
    #endif //MAPDBG

    void Destroy()
    {
        if (m_pMap == NULL)
            return;
        Element* const end = m_pMap + m_nUsed;
        Element* i = m_pMap;
        while (i != end)
            (i++)->~Pair<T, Key>();
        delete [] reinterpret_cast<char*>(m_pMap);
        m_pNext = m_pMap = NULL;
        m_nSize = 0;
        m_nUsed = 0;
    }

    Element* FindElement(const Key& key, bool bIncludeInStats = true) const
    {
        ASSERT(&key != NULL);
        #ifdef MAPDBG
        if (bIncludeInStats)
            ++m_nFinds;
        #endif //MAPDBG
        Element* const pNext = m_pNext;
        Element* const end = m_pMap + m_nUsed;
        ASSERT(pNext <= end);
        while (m_pNext != end)
        {
            if (m_pNext->GetSecond() == key)
            {
                #ifdef MAPDBG
                if (bIncludeInStats)
                    TotalStats(m_pNext - pNext);
                #endif //MAPDBG
                return m_pNext++;
            }
            ++m_pNext;
        }
        m_pNext = m_pMap;
        ASSERT(m_pNext != NULL || pNext == NULL);
        ASSERT(m_pNext <= pNext);
        while (m_pNext != pNext)
        {
            if (m_pNext->GetSecond() == key)
            {
                #ifdef MAPDBG
                if (bIncludeInStats)
                    TotalStats((m_pNext - m_pMap) + (end - pNext));
                #endif //MAPDBG
                return m_pNext++;
            }
            ++m_pNext;
        }
        #ifdef MAPDBG
        if (bIncludeInStats)
            TotalStats(m_nUsed);
        #endif //MAPDBG
        return NULL;
    }

    #ifdef MAPDBG
    void TotalStats(unsigned long nComparesPerformed) const
    {
        m_nCompares += nComparesPerformed;
        double average = double(m_nCompares) / double(m_nFinds);
        double const successRatio = nComparesPerformed == 0 ? 100.0 :
            (1.0 - (double(nComparesPerformed) / double(m_nUsed))) * 100.0;
        const size_t nOffset = m_pNext - m_pMap;
        TRACE("Map::find(%u), #%u, offset: %u, comps: %u, ave: %u, %%%u\n",
            (unsigned)(this), m_nFinds, nOffset, nComparesPerformed, (unsigned long)(average),
            (unsigned long)(successRatio));
    }
    #endif // MAPDBG

    static Element* UninitializedCopy(Element* dest, Element* src, size_t nCount)
    {
        if (nCount == 0)
            return dest;

        ASSERT(src != NULL || nCount == 0);
        ASSERT(dest != NULL);
        ASSERT(nCount > 0);
        if (nCount <= 0 || dest == NULL || src == NULL)
            return NULL;

        Element* const originalDest = dest;
        Element* const end = dest + nCount;
        while (dest != end)
            new(dest++) Element(*src++);
        return originalDest;
    }

    static void Copy(Element* dest, const Element* src, size_t nCount)
    {
        ASSERT(dest != NULL);
        ASSERT(src != NULL);
        ASSERT(static_cast<SSIZE_T>(nCount) >= 0);
        ASSERT(dest < src);
        if (nCount <= 0 || dest == NULL || src == NULL || dest >= src)
            return;

        Element* const end = dest + nCount;
        while (dest != end)
            *dest++ = *src++;
    }

}; // class Map
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\ctrlbar.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctrlbar.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//____________________________________________________________________________
//


#include "stdafx.h"
#include "menubtn.h"
#include "viewdata.h"
#include "amcmsgid.h"
#include "regutil.h"

#include "commctrl.h"
#include "multisel.h"
#include "rsltitem.h"
#include "conview.h"
#include "util.h"
#include "nodemgrdebug.h"

#ifdef _DEBUG
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Snapin name needed for debug information.
inline void Debug_SetControlbarSnapinName(const CLSID& clsidSnapin, CControlbar* pControlbar)
{
#ifdef DBG
    tstring tszSnapinName;
    bool bRet = GetSnapinNameFromCLSID(clsidSnapin, tszSnapinName);
    if (bRet)
        pControlbar->SetSnapinName(tszSnapinName.data());
#endif
}


//////////////////////////////////////////////////////////////////////////////
// IControlbar implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CControlbar);

CControlbar::CControlbar()
: m_pCache(NULL)
{
    TRACE(_T("CControlbar::CControlbar()\n"));
    DEBUG_INCREMENT_INSTANCE_COUNTER(CControlbar);
    m_pMenuButton=NULL;
    m_ToolbarsList.clear();

#ifdef DBG
    dbg_cRef = 0;
#endif
}

CControlbar::~CControlbar()
{
    DECLARE_SC(sc, _T("CControlbar::~CControlbar"));
    DEBUG_DECREMENT_INSTANCE_COUNTER(CControlbar);

    // Remove the toolbars & menubuttons references.
    sc = ScCleanup();
    // sc dtor will trace error if there is one.

    // release reference prior to m_ToolbarsList destruction
    // The destructor of CToolbar will try to remove itself from the list!
    m_spExtendControlbar = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     Create
//
//  Synopsis:   Create a toolbar or menubutton object
//
//  Arguments:
//              [nType]              - Type of object to be created (Toolbar or Menubutton).
//              [pExtendControlbar]  -  IExtendControlbar associated with this IControlbar.
//              [ppUnknown]          - IUnknown* of the object created.
//
//  Returns:    HR
//
//--------------------------------------------------------------------
STDMETHODIMP CControlbar::Create(MMC_CONTROL_TYPE nType,
                                 LPEXTENDCONTROLBAR pExtendControlbar,
                                 LPUNKNOWN* ppUnknown)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IControlbar::Create"));

    if (ppUnknown == NULL || pExtendControlbar == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Arguments"), sc);
        return sc.ToHr();
    }

    *ppUnknown = NULL;

    switch (nType)
    {
    case TOOLBAR:
        sc = ScCreateToolbar(pExtendControlbar, ppUnknown);
        break;

    case MENUBUTTON:
        sc = ScCreateMenuButton(pExtendControlbar, ppUnknown);
        break;
    default:
        sc = E_NOTIMPL;
        break;
    }
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}


HRESULT CControlbar::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_spExtendControlbar != NULL);
    if (m_spExtendControlbar == NULL)
        return E_FAIL;

    HRESULT hr;

	// Deactivate if theming (fusion or V6 common-control) context before calling snapins.
	ULONG_PTR ulpCookie;
	if (! MmcDownlevelActivateActCtx(NULL, &ulpCookie)) 
		return E_FAIL;

    __try
    {
        hr = m_spExtendControlbar->ControlbarNotify(event, arg, param);
		MmcDownlevelDeactivateActCtx(0, ulpCookie);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;
        TraceSnapinException(m_clsidSnapin, TEXT("IExtendControlbar::ControlbarNotify"), event);
		MmcDownlevelDeactivateActCtx(0, ulpCookie);
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     Attach
//
//  Synopsis:   Attach given toolbar or menubutton object
//
//  Arguments:
//              [nType]      -  Toolbar or Menubutton.
//              [lpUnknown]  -  IUnknown* of the object to be attached.
//
//  Returns:    HR
//
//--------------------------------------------------------------------
STDMETHODIMP CControlbar::Attach(MMC_CONTROL_TYPE nType, LPUNKNOWN lpUnknown)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IControlbar::Attach"));

    if (lpUnknown == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Arguments"), sc);
        return sc.ToHr();
    }

    switch (nType)
    {
    case TOOLBAR:
        sc = ScAttachToolbar(lpUnknown);
        break;
    case MENUBUTTON:
        sc = ScAttachMenuButtons(lpUnknown);
        break;
    case COMBOBOXBAR:
        sc = E_NOTIMPL;
        break;
    }
    if (sc)
        return sc.ToHr();

    return (sc.ToHr());
}

//+-------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Detach given toolbar or menubutton object
//
//  Arguments:  [lpUnknown]  -  IUnknown* of the object to be detached
//
//  Returns:    HR
//
//--------------------------------------------------------------------
STDMETHODIMP CControlbar::Detach(LPUNKNOWN lpUnknown)
{
    DECLARE_SC_FOR_PUBLIC_INTERFACE(sc, _T("IControlbar::Detach"));

    if (lpUnknown == NULL)
    {
        sc = E_INVALIDARG;
        TraceSnapinError(_T("Invalid Arguments"), sc);
        return sc.ToHr();
    }

    // Is it a toolbar
    IToolbarPtr spToolbar = lpUnknown;
    if (spToolbar != NULL)
    {
        sc = ScDetachToolbar(spToolbar);
        return sc.ToHr();
    }

    // Is it a menu button
    IMenuButtonPtr spMenuButton = lpUnknown;
    if (spMenuButton != NULL)
    {
        sc = ScDetachMenuButton(spMenuButton);
        return sc.ToHr();
    }


    // The passed lpUnknown is neither toolbar nor menubutton.
    // The Snapin has passed invalid object.
    sc = E_INVALIDARG;
    TraceSnapinError(_T("lpUnknown passed is neither toolbar nor menubutton"), sc);

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     ScDetachToolbar
//
//  Synopsis:   Detach given toolbar object
//
//  Arguments:  [lpToolbar]  -  IToolbar* of the object to be detached
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScDetachToolbar(LPTOOLBAR lpToolbar)
{
    DECLARE_SC(sc, _T("CControlbar::SCDetachToolbar"));

    if (NULL == lpToolbar)
        return (sc = E_UNEXPECTED);

    // Get the CToolbar object.
    CToolbar* pToolbar = dynamic_cast<CToolbar*>(lpToolbar);
    if (NULL == pToolbar)
        return (sc = E_UNEXPECTED);

    // Get the CMMCToolbarIntf interface.
    CMMCToolbarIntf* pToolbarIntf = pToolbar->GetMMCToolbarIntf();
    if (NULL == pToolbarIntf)
        return (sc = E_UNEXPECTED);

    // Detach the toolbar from UI.
    sc = pToolbarIntf->ScDetach(pToolbar);
    if (sc)
        return sc;

    // Remove the CControlbar reference.
    pToolbar->SetControlbar(NULL);

    // Remove the reference to the toolbar.
    m_ToolbarsList.remove(pToolbar);

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScDetachMenuButton
//
//  Synopsis:   Detach given toolbar or menubutton object
//
//  Arguments:  [lpUnknown]  -  IUnknown* of the object to be detached
//
//  Returns:    HR
//
//--------------------------------------------------------------------
SC CControlbar::ScDetachMenuButton(LPMENUBUTTON lpMenuButton)
{
    DECLARE_SC(sc, _T("CControlbar::ScDetachMenuButton"));

    if (NULL == lpMenuButton)
        return (sc = E_UNEXPECTED);

    CMenuButton* pMenuButton = dynamic_cast<CMenuButton*>(lpMenuButton);
    if (NULL == pMenuButton)
        return (sc = E_UNEXPECTED);

    sc = pMenuButton->ScDetach();
    if (sc)
        return sc;

    // If this is same as the cached menubutton object
    // then remove the (cached) ref.
    if (m_pMenuButton == pMenuButton)
        m_pMenuButton = NULL;
    else
    {
        // The IControlbar implementation is supposed to
        // have only one CMenuButton obj. How come it is
        // not same as one we have cached.
        sc = E_UNEXPECTED;
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScCreateToolbar
//
//  Synopsis:   Create a toolbar for the given snapin (IExtendControlbar).
//
//  Arguments:  [pExtendControlbar]  -  IExtendControlbar of the snapin.
//              [ppUnknown]          -  IUnknown* (IToolbar) of created toolbar.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScCreateToolbar(LPEXTENDCONTROLBAR pExtendControlbar,
                                LPUNKNOWN* ppUnknown)
{
    DECLARE_SC(sc, _T("CControlbar::ScCreateToolbar"));

    if ( (NULL == pExtendControlbar) ||
         (NULL == ppUnknown) )
        return (sc = E_INVALIDARG);

    ASSERT(m_spExtendControlbar == NULL ||
           m_spExtendControlbar == pExtendControlbar);

    // Create the new CToolbar object.
    CComObject<CToolbar>* pToolbar = NULL;
    sc = CComObject<CToolbar>::CreateInstance(&pToolbar);
    if (sc)
        return sc;

    if (NULL == pToolbar)
        return (sc = E_FAIL);

    sc = pToolbar->QueryInterface(IID_IToolbar,
                                  reinterpret_cast<void**>(ppUnknown));
    if (sc)
        return sc;

    CMMCToolbarIntf* pToolbarIntf = NULL;

    // Get the toolbars mgr.
    CAMCViewToolbarsMgr* pAMCViewToolbarsMgr = GetAMCViewToolbarsMgr();
    if (NULL == pAMCViewToolbarsMgr)
    {
        sc = E_UNEXPECTED;
        goto ToolbarUICreateError;
    }

    // Ask it to create the toolbar UI.
    sc = pAMCViewToolbarsMgr->ScCreateToolBar(&pToolbarIntf);
    if (sc)
        goto ToolbarUICreateError;

    // Let the IToolbar imp be aware of toolbar UI interface.
    pToolbar->SetMMCToolbarIntf(pToolbarIntf);

Cleanup:
    return(sc);

ToolbarUICreateError:
    // Destroy the CToolbar object created.
    if (*ppUnknown)
        (*ppUnknown)->Release();

    *ppUnknown = NULL;
    goto Cleanup;
}


//+-------------------------------------------------------------------
//
//  Member:     ScCreateMenuButton
//
//  Synopsis:   Create a menu button object.
//
//  Arguments:  [pExtendControlbar]  - IExtendControlbar of the snapin
//                                     that is creating MenuButton object.
//              [ppUnknown]          - IUnknown if MenuButton object.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScCreateMenuButton(LPEXTENDCONTROLBAR pExtendControlbar,
                                   LPUNKNOWN* ppUnknown)
{
    DECLARE_SC(sc, _T("CControlbar::ScCreateMenuButton"));

    if ( (NULL == pExtendControlbar) ||
         (NULL == ppUnknown) )
        return (sc = E_INVALIDARG);

    ASSERT(m_spExtendControlbar == NULL ||
           m_spExtendControlbar == pExtendControlbar);

    // Create the new IMenuButton object
    CComObject<CMenuButton>* pMenuButton;
    sc = CComObject<CMenuButton>::CreateInstance(&pMenuButton);
    if (sc)
        return sc;

    if (NULL == pMenuButton)
        return (sc = E_FAIL);

    sc = pMenuButton->QueryInterface(IID_IMenuButton,
                                     reinterpret_cast<void**>(ppUnknown));

    if (sc)
        return sc;

    pMenuButton->SetControlbar(this);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScNotifySnapinOfToolBtnClick
//
//  Synopsis:   Notify the snapin about a tool button is click.
//
//  Arguments:  [hNode]             - Node that owns result pane.
//              [bScopePane]        - Scope or Result.
//              [lResultItemCookie] - If Result pane is selected the item param.
//              [nID]               - Command ID of the tool button clicked.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScNotifySnapinOfToolBtnClick(HNODE hNode, bool bScopePane,
                                             LPARAM lResultItemCookie,
                                             UINT nID)
{
    DECLARE_SC(sc, _T("CControlbar::ScNotifySnapinOfToolBtnClick"));

    LPDATAOBJECT pDataObject = NULL;
    CNode* pNode = CNode::FromHandle(hNode);
    if (NULL == pNode)
        return (sc = E_UNEXPECTED);

    bool bScopeItem = bScopePane;
    // Get the data object of the currently selected item.
    sc = pNode->ScGetDataObject(bScopePane, lResultItemCookie, bScopeItem, &pDataObject);
    if (sc)
        return sc;

    ASSERT(m_spExtendControlbar != NULL);

    // Notify the snapin
    sc = ControlbarNotify(MMCN_BTN_CLICK, reinterpret_cast<LPARAM>(pDataObject),
                          static_cast<LPARAM>(nID));

    // Release the dataobject if it is not special dataobject.
    RELEASE_DATAOBJECT(pDataObject);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScNotifySnapinOfMenuBtnClick
//
//  Synopsis:   Notify the snapin about a menu button is click.
//
//  Arguments:  [hNode]             - Node that owns result pane.
//              [bScopePane]        - Scope or Result.
//              [lResultItemCookie] - If Result pane is selected the item param.
//              [lpmenuButtonData]  - MENUBUTTONDATA
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScNotifySnapinOfMenuBtnClick(HNODE hNode, bool bScopePane,
                                             LPARAM lResultItemCookie,
                                             LPMENUBUTTONDATA lpmenuButtonData)
{
    DECLARE_SC(sc, _T("CControlbar::ScNotifySnapinOfMenuBtnClick"));

    LPDATAOBJECT pDataObject = NULL;
    CNode* pNode = CNode::FromHandle(hNode);
    if (NULL == pNode)
        return (sc = E_UNEXPECTED);

    bool bScopeItem = bScopePane;
    // Get the data object of the currently selected item.
    sc = pNode->ScGetDataObject(bScopePane, lResultItemCookie, bScopeItem, &pDataObject);
    if (sc)
        return sc;

    ASSERT(m_spExtendControlbar != NULL);

    // Notify the snapin
    sc = ControlbarNotify(MMCN_MENU_BTNCLICK, reinterpret_cast<LPARAM>(pDataObject),
                          reinterpret_cast<LPARAM>(lpmenuButtonData));

    // Release the dataobject if it is not special dataobject.
    RELEASE_DATAOBJECT(pDataObject);
    if (sc)
        return sc;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScAttachToolbar
//
//  Synopsis:   Attach given toolbar object
//
//  Arguments:  [lpUnknown]  -  IUnknown* of the object to be attached
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScAttachToolbar(LPUNKNOWN lpUnknown)
{
    DECLARE_SC(sc, _T("CControlbar::ScAttachToolbar"));

    ASSERT(NULL != lpUnknown);

    IToolbarPtr spToolbar = lpUnknown;
    if (NULL == spToolbar)
        return (sc = E_UNEXPECTED);

    // Get the toolbar object (IToolbar implementation).
    CToolbar* pToolbarC = dynamic_cast<CToolbar*>(spToolbar.GetInterfacePtr());
    if (NULL == pToolbarC)
        return (sc = E_UNEXPECTED);

    // Get the toolbar UI interface.
    CMMCToolbarIntf* pToolbarIntf = pToolbarC->GetMMCToolbarIntf();
    if (NULL == pToolbarIntf)
        return (sc = E_UNEXPECTED);

    // Attach the toolbar.
    sc = pToolbarIntf->ScAttach(pToolbarC);
    if (sc)
        return sc;

    // Make the CToolbar aware of this IControlbar.
    pToolbarC->SetControlbar(this);

    // Add this CToolbar to our list of toolbars.
    ToolbarsList::iterator itToolbar = std::find(m_ToolbarsList.begin(), m_ToolbarsList.end(), pToolbarC);
    if (m_ToolbarsList.end() == itToolbar)
    {
        m_ToolbarsList.push_back(pToolbarC);
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScAttachMenuButtons
//
//  Synopsis:   Attach a menu button object.
//
//  Arguments:  [lpUnknown]  - IUnknown if MenuButton object.
//
//  Returns:    HRESULT
//
//  Note:  Only one CMenuButton object per Controlbar/snapin.
//         Snapins can create many menu buttons using a
//         single CMenuButton object.
//--------------------------------------------------------------------
SC CControlbar::ScAttachMenuButtons(LPUNKNOWN lpUnknown)
{
    DECLARE_SC(sc, _T("CControlbar::ScAttachMenuButtons"));

    ASSERT(NULL != lpUnknown);

    CMenuButton* pMenuButton = dynamic_cast<CMenuButton*>(lpUnknown);
    if (pMenuButton == NULL)
        return (sc = E_INVALIDARG);

    if (m_pMenuButton == pMenuButton)
    {
        // Already attached.
        sc = S_FALSE;
        TraceNodeMgrLegacy(_T("The menubutton is already attached"), sc);
        return sc;
    }
    else if (m_pMenuButton != NULL)
    {
        // There is already a CMenuButton object attached by this
        // Controlbar (Snapin). Detach that before attaching this
        // CMenuButton Object (See the note above).
        sc = m_pMenuButton->ScDetach();
        if (sc)
            return sc;
    }

    // Cache the ref to CMenuButton object.
    // Used when selection moves away from the snapin.
    // MMC has to remove the menubutton put by this snapin.
    m_pMenuButton = pMenuButton;

    if (pMenuButton->GetControlbar() != this)
        pMenuButton->SetControlbar(this);

    sc = pMenuButton->ScAttach();
    if (sc)
        return sc;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScCleanup
//
//  Synopsis:   Remove all the toolbars and menu buttons owned
//              by this controlbar.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScCleanup()
{
    DECLARE_SC(sc, _T("CControlbar::ScCleanup"));

    ASSERT(m_spExtendControlbar != NULL);
    if (m_spExtendControlbar != NULL)
        m_spExtendControlbar->SetControlbar(NULL);

    sc = ScDetachToolbars();
    if (sc)
        return sc;

    // If there is a menu button, detach (remove it
    // from the UI).
    if (m_pMenuButton)
    {
        sc = m_pMenuButton->ScDetach();
        m_pMenuButton = NULL;
    }

    return sc;
}



//+-------------------------------------------------------------------
//
//  Member:     ScDetachToolbars
//
//  Synopsis:   Detach all the toolbars.
//
//  Arguments:  None.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScDetachToolbars()
{
    DECLARE_SC(sc, _T("CControlbar::ScDetachToolbars"));

    ToolbarsList::iterator itToolbar = m_ToolbarsList.begin();
    while (itToolbar != m_ToolbarsList.end())
    {
        CToolbar* pToolbar = (*itToolbar);
        if (NULL == pToolbar)
            return (sc = E_UNEXPECTED);

        CMMCToolbarIntf* pToolbarIntf = pToolbar->GetMMCToolbarIntf();
        if (NULL == pToolbarIntf)
            return (sc = E_UNEXPECTED);

        // Detach the toolbar UI.
        sc = pToolbarIntf->ScDetach(pToolbar);
        if (sc)
            return sc;

        // Detach the controlbar from toolbar.
        pToolbar->SetControlbar(NULL);

        // Remove the toolbar reference from the list.
        itToolbar = m_ToolbarsList.erase(itToolbar);
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:     ScShowToolbars
//
//  Synopsis:   Show/Hide all the toolbars.
//
//  Arguments:  [bool] - Show or Hide.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CControlbar::ScShowToolbars(bool bShow)
{
    DECLARE_SC(sc, _T("CControlbar::ScShowToolbars"));

    ToolbarsList::iterator itToolbar = m_ToolbarsList.begin();
    for (; itToolbar != m_ToolbarsList.end(); ++itToolbar)
    {
        CToolbar* pToolbar = (*itToolbar);
        if (NULL == pToolbar)
            return (sc = E_UNEXPECTED);

        CMMCToolbarIntf* pToolbarIntf = pToolbar->GetMMCToolbarIntf();
        if (NULL == pToolbarIntf)
            return (sc = E_UNEXPECTED);

        sc = pToolbarIntf->ScShow(pToolbar, bShow);
        if (sc)
            return sc;
    }

    return sc;
}


CViewData* CControlbar::GetViewData()
{
    ASSERT(m_pCache != NULL);
    return m_pCache->GetViewData();
}

///////////////////////////////////////////////////////////////////////////
//
// CSelData implementation
//

DEBUG_DECLARE_INSTANCE_COUNTER(CSelData);

//+-------------------------------------------------------------------
//
//  Member:     ScReset
//
//  Synopsis:   Init all the data members.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CSelData::ScReset()
{
    DECLARE_SC(sc, _T("CSelData::ScReset"));

    if (m_pCtrlbarPrimary != NULL)
    {
        sc = ScDestroyPrimaryCtrlbar();
        if (sc)
            return sc;
    }

    sc = ScDestroyExtensionCtrlbars();
    if (sc)
        return sc;

    m_bScopeSel = false;
    m_bSelect = false;
    m_pNodeScope = NULL;
    m_pMS = NULL;
    m_pCtrlbarPrimary = NULL;
    m_lCookie = -1;
    m_pCompPrimary = NULL;
    m_spDataObject = NULL;

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:     ScShowToolbars
//
//  Synopsis:   Show/Hide primary & extension toolbars.
//
//  Arguments:  [bool] - Show/Hide.
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CSelData::ScShowToolbars(bool bShow)
{
    DECLARE_SC(sc, _T("CSelData::ScShowToolbars"));

    if (m_pCtrlbarPrimary != NULL)
    {
        sc = m_pCtrlbarPrimary->ScShowToolbars(bShow);

        if (sc)
            return sc;
    }

    POSITION pos =  m_listExtCBs.GetHeadPosition();
    bool bReturn = true;
    while (pos != NULL)
    {
        CControlbar* pControlbar =  m_listExtCBs.GetNext(pos);
        if (pControlbar)
        {
            sc = pControlbar->ScShowToolbars(bShow);
            if (sc)
                return sc;
        }
    }

    return sc;
}

CControlbar* CSelData::GetControlbar(const CLSID& clsidSnapin)
{
    POSITION pos = m_listExtCBs.GetHeadPosition();
    while (pos)
    {
        CControlbar* pControlbar = m_listExtCBs.GetNext(pos);
        if (pControlbar && pControlbar->IsSameSnapin(clsidSnapin) == TRUE)
            return pControlbar;
    }

    return NULL;
}


//+-------------------------------------------------------------------
//
//  Member:     ScDestroyPrimaryCtrlbar
//
//  Synopsis:   Ask primary controlbar to release its toolbar/menubutton
//              ref and cleanup our reference to the controlbar.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CSelData::ScDestroyPrimaryCtrlbar()
{
    DECLARE_SC(sc, _T("CSelData::ScDestroyPrimaryCtrlbar"));

    if (NULL == m_pCtrlbarPrimary)
        return (sc = E_UNEXPECTED);

    sc = m_pCtrlbarPrimary->ScCleanup();
    if (sc)
        return sc;

    /*
     * In CreateControlbar we had a ref on IControlbar
     * (detaching smart ptr). Let us now undo that ref.
     */
    m_pCtrlbarPrimary->Release();
    m_pCtrlbarPrimary = NULL;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ScDestroyExtensionCtrlbars
//
//  Synopsis:   Ask extension controlbars to release their toolbar/menubutton
//              ref and cleanup our reference to the controlbars.
//
//  Arguments:  None
//
//  Returns:    SC
//
//--------------------------------------------------------------------
SC CSelData::ScDestroyExtensionCtrlbars()
{
    DECLARE_SC(sc, _T("CSelData::ScDestroyExtensionCtrlbars"));

    POSITION pos =  m_listExtCBs.GetHeadPosition();
    while (pos != NULL)
    {
        CControlbar* pControlbar =  m_listExtCBs.GetNext(pos);
        if (pControlbar)
        {
            sc = pControlbar->ScCleanup();
            if (sc)
                return sc;

            /*
             * In CreateControlbar we had a ref on IControlbar
             * (detaching smart ptr). Let us now undo that ref.
             */
            pControlbar->Release();
        }
    }

    m_listExtCBs.RemoveAll();

    return sc;
}


///////////////////////////////////////////////////////////////////////////
//
// CControlbarsCache implementation
//

DEBUG_DECLARE_INSTANCE_COUNTER(CControlbarsCache);


void CControlbarsCache::SetViewData(CViewData* pViewData)
{
    ASSERT(pViewData != 0);
    m_pViewData = pViewData;
}

CViewData* CControlbarsCache::GetViewData()
{
    ASSERT(m_pViewData != NULL);
    return m_pViewData;
}


CControlbar* CControlbarsCache::CreateControlbar(IExtendControlbarPtr& spECB,
                                                 const CLSID& clsidSnapin)
{
    DECLARE_SC(sc, _T("CControlbarsCache::CreateControlbar"));

    CComObject<CControlbar>* pControlbar;
    sc = CComObject<CControlbar>::CreateInstance(&pControlbar);
    if (sc)
        return NULL;

    IControlbarPtr spControlbar = pControlbar;
    if (NULL == spControlbar)
    {
        ASSERT(NULL != pControlbar); // QI fails but object is created how?
        sc = E_UNEXPECTED;
        return NULL;
    }

    pControlbar->SetCache(this);
    pControlbar->SetExtendControlbar(spECB, clsidSnapin);

    sc = spECB->SetControlbar(spControlbar);
    if (sc)
        return NULL; // spControlbar smart ptr (object will be destroyed).

    // Snapin must return S_OK to be valid
    if (S_OK == sc.ToHr())
    {
        // Detach, thus hold a ref count on the Controlbar object
        // CSelData holds this reference & releases the ref in
        // ScDestroyPrimaryCtrlbar() or ScDestroyExtensionCtrlbars().
        spControlbar.Detach();

        // This is for debug info.
        Debug_SetControlbarSnapinName(clsidSnapin, pControlbar);

        return pControlbar;
    }

    return NULL;
}


HRESULT
CControlbarsCache::OnMultiSelect(
                                CNode* pNodeScope,
                                CMultiSelection* pMultiSelection,
                                IDataObject* pDOMultiSel,
                                BOOL bSelect)
{
    ASSERT(pNodeScope != NULL);
    ASSERT(pMultiSelection != NULL);
    ASSERT(pDOMultiSel != NULL);
    if (pNodeScope == NULL || pMultiSelection == NULL || pDOMultiSel == NULL)
        return E_FAIL;

    CSelData selData(false, (bool)bSelect);
    selData.m_pMS = pMultiSelection;

    if (selData == m_SelData)
        return S_FALSE;

    if (!bSelect)
        return _OnDeSelect(selData);

    selData.m_pCompPrimary = pMultiSelection->GetPrimarySnapinComponent();

    CList<GUID, GUID&> extnSnapins;
    HRESULT hr = pMultiSelection->GetExtensionSnapins(g_szToolbar, extnSnapins);
    CHECK_HRESULT(hr);

    selData.m_spDataObject.Attach(pDOMultiSel, TRUE);
    return _ProcessSelection(selData, extnSnapins);
}

HRESULT
CControlbarsCache::OnResultSelChange(
                                    CNode* pNode,
                                    MMC_COOKIE cookie,
                                    BOOL bSelected)
{
    DECLARE_SC(sc, TEXT("CControlbarsCache::OnResultSelChange"));

    sc = ScCheckPointers (pNode);
    if (sc)
        return (sc.ToHr());

    CSelData selData(false, (bool)bSelected);
    selData.m_lCookie = cookie;

    if (selData == m_SelData)
        return (sc = S_FALSE).ToHr();

    if (!bSelected)
    {
        sc = _OnDeSelect(selData);
        return sc.ToHr();
    }

    IDataObjectPtr spDataObject = NULL;
    CComponent* pCCResultItem = NULL;
    CList<CLSID, CLSID&> extnSnapins;

    BOOL bListPadItem = GetViewData()->HasListPad() && !IS_SPECIAL_LVDATA(cookie);

    if (GetViewData()->IsVirtualList())
    {
        pCCResultItem = pNode->GetPrimaryComponent();
        sc = ScCheckPointers(pCCResultItem, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        sc = pCCResultItem->QueryDataObject(cookie, CCT_RESULT, &spDataObject);
        if (sc)
            return sc.ToHr();
    }
    else if ( (GetViewData()->HasOCX()) || (GetViewData()->HasWebBrowser() && !bListPadItem) )
    {
        selData.m_pCompPrimary = pNode->GetPrimaryComponent();
        sc = _ProcessSelection(selData, extnSnapins);
        return sc.ToHr();
    }
    else
    {
        CResultItem* pri = CResultItem::FromHandle(cookie);
        sc = ScCheckPointers(pri, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        if (pri->IsScopeItem())
        {
            // Get the data object from IComponentData
            pNode = CNode::FromResultItem (pri);
            sc = ScCheckPointers(pNode, E_UNEXPECTED);
            if (sc)
                return sc.ToHr();

            if (pNode->IsInitialized() == FALSE)
            {
                sc = pNode->InitComponents();
                if (sc)
                    return sc.ToHr();
            }

            pCCResultItem = pNode->GetPrimaryComponent();
            sc = pNode->QueryDataObject(CCT_SCOPE, &spDataObject);
            if (sc)
                return sc.ToHr();
        }
        else // Must be a leaf item inserted by a snapin
        {
            pCCResultItem = pNode->GetComponent(pri->GetOwnerID());
            sc = ScCheckPointers(pCCResultItem, E_UNEXPECTED);
            if (sc)
                return sc.ToHr();

            sc = pCCResultItem->QueryDataObject(pri->GetSnapinData(), CCT_RESULT,
                                                &spDataObject);
            if (sc)
                return sc.ToHr();
        }
    }

    // Create extension snapin list
    if (spDataObject != NULL)
    {
        ASSERT(pCCResultItem != NULL);

        GUID guidObjType;
        sc = ::ExtractObjectTypeGUID(spDataObject, &guidObjType);
        if (sc)
            return sc.ToHr();

        CSnapIn* pSnapIn = pNode->GetPrimarySnapIn();

        CMTNode* pmtNode = pNode->GetMTNode();
        sc = ScCheckPointers(pmtNode, E_UNEXPECTED);
        if (sc)
            return sc.ToHr();

        CArray<GUID, GUID&> DynExtens;
        ExtractDynExtensions(spDataObject, DynExtens);

        CExtensionsIterator it;
        sc = it.ScInitialize(pSnapIn, guidObjType, g_szToolbar, DynExtens.GetData(), DynExtens.GetSize());
        if (!sc.IsError())
        {
            for (; !it.IsEnd(); it.Advance())
            {
                extnSnapins.AddHead(const_cast<GUID&>(it.GetCLSID()));
            }
        }

        selData.m_pCompPrimary = pCCResultItem;
        selData.m_spDataObject.Attach(spDataObject.Detach());
    }

    // Finally process selection
    sc = _ProcessSelection(selData, extnSnapins);
    if (sc)
        return sc.ToHr();

    return sc.ToHr();
}

HRESULT CControlbarsCache::OnScopeSelChange(CNode* pNode, BOOL bSelected)
{
    DECLARE_SC(sc, TEXT("CControlbarsCache::OnScopeSelChange"));

    CSelData selData(true, (bool)bSelected);
    selData.m_pNodeScope = pNode;
    if (selData == m_SelData)
        return S_FALSE;

    if (!bSelected)
        return _OnDeSelect(selData);

    HRESULT hr = S_OK;
    IDataObjectPtr spDataObject;
    CComponent* pCCPrimary = NULL;
    CList<CLSID, CLSID&> extnSnapins;

    hr = pNode->QueryDataObject(CCT_SCOPE, &spDataObject);
    if (FAILED(hr))
        return hr;

    pCCPrimary = pNode->GetPrimaryComponent();

    GUID guidObjType;
    hr = ::ExtractObjectTypeGUID(spDataObject, &guidObjType);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        return hr;

    CSnapIn* pSnapIn = pNode->GetPrimarySnapIn();

    CArray<GUID, GUID&> DynExtens;
    ExtractDynExtensions(spDataObject, DynExtens);

    CExtensionsIterator it;
    sc = it.ScInitialize(pSnapIn, guidObjType, g_szToolbar, DynExtens.GetData(), DynExtens.GetSize());
    if (!sc.IsError())
    {
        for (; it.IsEnd() == FALSE; it.Advance())
        {
            extnSnapins.AddHead(const_cast<GUID&>(it.GetCLSID()));
        }
    }

    // Finally process selection
    selData.m_pCompPrimary = pCCPrimary;
    selData.m_spDataObject.Attach(spDataObject.Detach());
    return _ProcessSelection(selData, extnSnapins);
}

HRESULT CControlbarsCache::_OnDeSelect(CSelData& selData)
{
    ASSERT(!selData.IsSelect());
    if (selData.m_bScopeSel != m_SelData.m_bScopeSel)
        return S_FALSE;

    if ( (m_SelData.m_pCtrlbarPrimary != NULL &&
          m_SelData.m_spDataObject == NULL) &&
         (!GetViewData()->HasOCX() ||
          !GetViewData()->HasWebBrowser()) &&
         m_SelData.IsScope())
    {
        return E_UNEXPECTED;
    }

    MMC_NOTIFY_TYPE eNotifyCode = MMCN_SELECT;
    LPARAM lDataObject;

    if (GetViewData()->IsVirtualList())
    {
        eNotifyCode = MMCN_DESELECT_ALL;

        // Must use NULL data object for MMCN_DESELECT_ALL.
        lDataObject = 0;
    }
    else if ((GetViewData()->HasOCX()) && (!m_SelData.IsScope()))
        lDataObject = reinterpret_cast<LPARAM>(DOBJ_CUSTOMOCX);
    else if ((GetViewData()->HasWebBrowser()) && (!m_SelData.IsScope()))
    {
        if (GetViewData()->HasListPad() && m_SelData.m_spDataObject != NULL)
        {
            lDataObject = reinterpret_cast<LPARAM>(
                                                  static_cast<IDataObject*>(m_SelData.m_spDataObject));
        }
        else
        {
            lDataObject = reinterpret_cast<LPARAM>(DOBJ_CUSTOMWEB);
        }
    }
    else
    {
        lDataObject = reinterpret_cast<LPARAM>(
                                              static_cast<IDataObject*>(m_SelData.m_spDataObject));
    }

    WORD wScope = static_cast<WORD>(m_SelData.IsScope());
    LPARAM arg = MAKELONG(wScope, FALSE);


    if (m_SelData.m_pCtrlbarPrimary != NULL)
    {
        m_SelData.m_pCtrlbarPrimary->ControlbarNotify(eNotifyCode, arg,
                                                      lDataObject);
    }

    POSITION pos = m_SelData.m_listExtCBs.GetHeadPosition();
    while (pos)
    {
        CControlbar* pCbar = m_SelData.m_listExtCBs.GetNext(pos);
        pCbar->ControlbarNotify(eNotifyCode, arg, lDataObject);
    }

    m_SelData.m_bSelect = false;
    m_SelData.m_spDataObject = NULL; // Release & set to NULL
    return S_OK;
}

HRESULT
CControlbarsCache::_ProcessSelection(
                                    CSelData& selData,
                                    CList<CLSID, CLSID&>& extnSnapins)
{
    LPARAM lDataObject = reinterpret_cast<LPARAM>(
                                                 static_cast<IDataObject*>(selData.m_spDataObject));

    if (NULL == lDataObject)
    {
        if ( (GetViewData()->HasOCX()) && (!selData.IsScope()) )
            lDataObject = reinterpret_cast<LPARAM>(DOBJ_CUSTOMOCX);
        else if ( (GetViewData()->HasWebBrowser()) && (!selData.IsScope()) )
            lDataObject = reinterpret_cast<LPARAM>(DOBJ_CUSTOMWEB);
    }

    WORD wScope = static_cast<WORD>(selData.IsScope());
    long arg = MAKELONG(wScope, TRUE);

    m_SelData.m_bScopeSel = selData.m_bScopeSel;
    m_SelData.m_bSelect = selData.m_bSelect;
    m_SelData.m_pNodeScope = selData.m_pNodeScope;
    m_SelData.m_lCookie = selData.m_lCookie;
    m_SelData.m_spDataObject.Attach(selData.m_spDataObject.Detach());

    // Handle primary controlbar first
    if (m_SelData.m_pCompPrimary != selData.m_pCompPrimary)
    {
        if (m_SelData.m_pCtrlbarPrimary != NULL)
        {
            // Ask controlbar to destroy its ref & destroy our ref
            // to controlbar.
            m_SelData.ScDestroyPrimaryCtrlbar();
        }

        m_SelData.m_pCompPrimary = selData.m_pCompPrimary;

        if (m_SelData.m_pCompPrimary != NULL &&
            m_SelData.m_pCtrlbarPrimary == NULL)
        {
            IExtendControlbarPtr spECBPrimary =
            m_SelData.m_pCompPrimary->GetIComponent();
            if (spECBPrimary != NULL)
            {
                m_SelData.m_pCtrlbarPrimary =
                CreateControlbar(spECBPrimary,
                                 m_SelData.m_pCompPrimary->GetCLSID());
            }
        }
    }

    if (m_SelData.m_pCtrlbarPrimary != NULL)
    {
        m_SelData.m_pCtrlbarPrimary->ControlbarNotify(MMCN_SELECT, arg,
                                                      lDataObject);
    }

    // Handle extension controlbars

    CControlbarsList newCBs;

    POSITION pos = extnSnapins.GetHeadPosition();

    while (pos)
    {
        CControlbar* pCbar = NULL;

        CLSID& clsid = extnSnapins.GetNext(pos);

        POSITION pos2 = m_SelData.m_listExtCBs.GetHeadPosition();
        POSITION pos2Prev = 0;
        while (pos2)
        {
            pos2Prev = pos2;
            pCbar = m_SelData.m_listExtCBs.GetNext(pos2);
            ASSERT(pCbar != NULL);
            if (pCbar->IsSameSnapin(clsid) == TRUE)
                break;
            pCbar = NULL;
        }

        if (pCbar != NULL)
        {
            ASSERT(pos2Prev != 0);
            m_SelData.m_listExtCBs.RemoveAt(pos2Prev);
        }
        else
        {
            IExtendControlbarPtr spECB;
            HRESULT hr = spECB.CreateInstance(clsid, NULL, MMC_CLSCTX_INPROC);
            CHECK_HRESULT(hr);
            if (SUCCEEDED(hr))
                pCbar = CreateControlbar(spECB, clsid);
        }

        if (pCbar != NULL)
            newCBs.AddHead(pCbar);
    }

    m_SelData.ScDestroyExtensionCtrlbars();

    pos = newCBs.GetHeadPosition();
    while (pos)
    {
        CControlbar* pCbar = newCBs.GetNext(pos);
        m_SelData.m_listExtCBs.AddHead(pCbar);
        pCbar->ControlbarNotify(MMCN_SELECT, arg, lDataObject);
    }
    newCBs.RemoveAll();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



#include "..\inc\StdDbg.h"

#ifdef DBG
    DECLARE_DEBUG(AMCNodeMgr)
    #define DBG_COMP    AMCNodeMgrInfoLevel
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\doccnfg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       doccnfg.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "doccnfg.h"
#include "comdbg.h"

/////////////////////////////////////////////////////////////////////////////
//
// external references
extern const wchar_t* AMCSnapInCacheStreamName;

/////////////////////////////////////////////////////////////////////////////
//
// Class CMMCDocConfig implementation

CMMCDocConfig::~CMMCDocConfig()
{
    if (IsFileOpen())
        CloseFile();
}


STDMETHODIMP CMMCDocConfig::InterfaceSupportsErrorInfo(REFIID riid)
{
    return (InlineIsEqualGUID(IID_IDocConfig, riid)) ? S_OK : S_FALSE;
}


STDMETHODIMP CMMCDocConfig::OpenFile(BSTR bstrFilePath)
{
    return ScOpenFile( bstrFilePath ).ToHr();
}


STDMETHODIMP CMMCDocConfig::CloseFile()
{
    return ScCloseFile().ToHr();
}


STDMETHODIMP CMMCDocConfig::SaveFile(BSTR bstrFilePath)
{
    return ScSaveFile(bstrFilePath).ToHr();
}


STDMETHODIMP CMMCDocConfig::EnableSnapInExtension(BSTR bstrSnapIn, BSTR bstrExt, VARIANT_BOOL bEnable)
{
    return ScEnableSnapInExtension(bstrSnapIn, bstrExt, bEnable).ToHr();
}


/*+-------------------------------------------------------------------------*
 * CMMCDocConfig::Dump
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMMCDocConfig::Dump (LPCTSTR pszDumpFilePath)
{
    return ScDump (pszDumpFilePath).ToHr();
}


/*+-------------------------------------------------------------------------*
 * CMMCDocConfig::CheckSnapinAvailability
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CMMCDocConfig::CheckSnapinAvailability (CAvailableSnapinInfo& asi)
{
    return ScCheckSnapinAvailability(asi).ToHr();
}

/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScOpenFile
 *
 * PURPOSE: Opens the specified console file and reads snapin cache from it
 *
 * PARAMETERS:
 *    BSTR bstrFilePath [in] file name to read from
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScOpenFile(BSTR bstrFilePath)
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScOpenFile"));

    // Close currently open file
    if (IsFileOpen())
    {
        sc = ScCloseFile();
        if (sc)
            sc.TraceAndClear(); // report the error and ignore
    }

    // parameter check
    if (bstrFilePath == NULL || SysStringLen(bstrFilePath) == 0)
        return sc = E_INVALIDARG;

    USES_CONVERSION;
    LPCTSTR lpstrFilePath = OLE2CT(bstrFilePath);

    // create object to load the snapins
    CAutoPtr<CSnapInsCache> spSnapInsCache( new CSnapInsCache );
    sc = ScCheckPointers( spSnapInsCache, E_OUTOFMEMORY );
    if (sc)
        return sc;

    // load the data (use bas class method)
    bool bXmlBased = false;
    CXMLDocument xmlDocument;
    IStoragePtr spStorage;
    sc = ScLoadConsole( lpstrFilePath, bXmlBased, xmlDocument, &spStorage );
    if (sc)
        return sc;

    // examine file type
    if ( !bXmlBased )
    {
        // structured storage - based console
        IStreamPtr spStream;
        sc = OpenDebugStream(spStorage, AMCSnapInCacheStreamName,
                         STGM_SHARE_EXCLUSIVE | STGM_READWRITE, L"SnapInCache", &spStream);
        if (sc)
            return sc;

        sc = spSnapInsCache->ScLoad(spStream);
        if (sc)
            return sc;

        m_spStorage = spStorage;
    }
    else
    {
        // xml - based console

        try // xml implementation throws sc's
        {
            // construct parent document
            CXMLElement elemDoc = xmlDocument;
            CPersistor persistorFile(xmlDocument, elemDoc);
            // init
            persistorFile.SetLoading(true);

            // navigate to snapin cache
            CPersistor persistorConsole ( persistorFile,    XML_TAG_MMC_CONSOLE_FILE );
            CPersistor persistorTree    ( persistorConsole, XML_TAG_SCOPE_TREE );

            // load
            persistorTree.Persist(*spSnapInsCache);

            // hold onto the persistor info
            m_XMLDocument = persistorConsole.GetDocument();
            m_XMLElemConsole = persistorConsole.GetCurrentElement();
            m_XMLElemTree = persistorTree.GetCurrentElement();
        }
        catch(SC& sc_thrown)
        {
            return (sc = sc_thrown);
        }
    }

    // keep on the pointer
    m_spCache.Attach( spSnapInsCache.Detach() );
    m_strFilePath = lpstrFilePath;

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScCloseFile
 *
 * PURPOSE: closes open file
 *
 * PARAMETERS:
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScCloseFile()
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScCloseFile"));

    if (!IsFileOpen())
        return sc = E_UNEXPECTED;

    // release everything
    m_spStorage = NULL;
    m_strFilePath.erase();
    m_spCache.Delete();
    m_XMLDocument = CXMLDocument();
    m_XMLElemConsole = CXMLElement();
    m_XMLElemTree = CXMLElement();

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  ScFindAndTruncateChild
 *
 * PURPOSE: helper; locates the element by tag and removes all element's contents
 *          Doing so instead of deleting and recreating the element preserves all
 *          the formating and tag order in xml document
 *
 * PARAMETERS:
 *    CPersistor& parent    [in] - parent persistor
 *    LPCTSTR strTag        [in] - child's tag
 *    CXMLElement& child    [out] - child's element
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC ScFindAndTruncateChild(CPersistor& parent, LPCTSTR strTag, CXMLElement& child)
{
    DECLARE_SC(sc, TEXT("ScTruncateChild"));

    try
    {
        // create persistor for the old cache tag
        parent.SetLoading(true); // we want 'loading-alike' navigation
        CPersistor persistorChild( parent, strTag );
        parent.SetLoading(false); // restore saving behavior

        // get the element
        CXMLElement elChild = persistorChild.GetCurrentElement();

        // get nodes under the element
        CXMLElementCollection colChildren;
        elChild.get_children( &colChildren );

        long count = 0;
        colChildren.get_count( &count );

        // iterate and delete all the nodes
        while (count > 0)
        {
            CXMLElement el;
            colChildren.item( 0, &el);

            elChild.removeChild(el);

            --count;
        }

        // return the element
        child = elChild;
    }
    catch(SC& sc_thrown)
    {
        return (sc = sc_thrown);
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScSaveFile
 *
 * PURPOSE: Saves file to specified location
 *
 * PARAMETERS:
 *    BSTR bstrFilePath [in] file path to save to. NULL -> same as load
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScSaveFile(BSTR bstrFilePath)
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScSaveFile"));

    if (!IsFileOpen() || m_spCache == NULL)
        return sc = E_UNEXPECTED;

    USES_CONVERSION;

    // if new path specified, save local copy as new default
    if ( bstrFilePath && SysStringLen(bstrFilePath) != 0)
        m_strFilePath = OLE2CT(bstrFilePath);

    // remove extensions marked for deletion
    m_spCache->Purge(TRUE);

    if ( m_spStorage != NULL ) // not the XML way?
    {
        // replace snapin cache stream with new cache contents
        IStreamPtr spStream;
        sc = CreateDebugStream(m_spStorage, AMCSnapInCacheStreamName,
                STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_READWRITE, L"SnapInCache", &spStream);
        if (sc)
            return sc;

        // save the cache
        sc = m_spCache->ScSave(spStream, TRUE);
        if (sc)
            return sc;

        // Create storage for the requested file
        IStoragePtr spNewStorage;
        sc = CreateDebugDocfile( T2COLE( m_strFilePath.c_str() ),
            STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE | STGM_READWRITE,
            &spNewStorage);

        if (sc)
            return sc;

        // copy the working storage to the new file
        sc = m_spStorage->CopyTo(NULL, NULL, NULL, spNewStorage);
        if (sc)
            return sc;

        // lets hold on the new one
        m_spStorage = spNewStorage;
    }
    else
    {
        try // may throw
        {
            // save the data

            CPersistor persistorTree( m_XMLDocument, m_XMLElemTree );

            // this is more tricky than loading - we want to reuse the same tag

            CXMLElement elCache;
            sc = ScFindAndTruncateChild(persistorTree, m_spCache->GetXMLType(), elCache);
            if (sc)
                return sc;

            // create persistor for the new cache tag
            CPersistor persistorCache( persistorTree, elCache );

            // now persist under the new tag
            m_spCache->Persist(persistorCache);

            // update documents guid to invalidate user data

            GUID  guidConsoleId;
            sc = CoCreateGuid(&guidConsoleId);
            if (sc)
                return sc;

            // persistor for console
            CPersistor persistorConsole ( m_XMLDocument,  m_XMLElemConsole );
            persistorConsole.SetLoading(false);

            CXMLElement elGuid;
            sc = ScFindAndTruncateChild(persistorConsole, XML_TAG_CONSOLE_FILE_UID, elGuid);
            if (sc)
                return sc;

            // create persistor for the new guid tag
            CPersistor persistorGuid( persistorConsole, elGuid );

            // now persist under the new tag
            persistorGuid.PersistContents(guidConsoleId);

            //save to file
            sc = ScSaveConsole( m_strFilePath.c_str(), true/*bForAuthorMode*/, m_XMLDocument);
            if (sc)
                return sc;
        }
        catch(SC& sc_thrown)
        {
            return (sc = sc_thrown);
        }
    }

    return sc;
}

/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScEnableSnapInExtension
 *
 * PURPOSE: Enables extension in snapin cache
 *
 * PARAMETERS:
 *    BSTR bstrSnapIn       [in] classid of the snapin
 *    BSTR bstrExt          [in] classid of extension
 *    VARIANT_BOOL bEnable  [in] enable/disable flag
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScEnableSnapInExtension(BSTR bstrSnapIn, BSTR bstrExt, VARIANT_BOOL bEnable)
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScEnableSnapInExtension"));

    CLSID SnapInCLSID;
    CLSID ExtCLSID;
    CSnapInPtr spBaseSnapIn;
    CSnapInPtr spExtSnapIn;

    // convert input strings to CLSIDs
    sc = CLSIDFromString(bstrSnapIn, &SnapInCLSID);
    if (sc)
        return sc;

    sc = CLSIDFromString( bstrExt, &ExtCLSID);
    if (sc)
        return sc;

    // Locate base snap-in in cache
    sc = m_spCache->ScFindSnapIn(SnapInCLSID, &spBaseSnapIn);
    if (sc)
        return sc = E_INVALIDARG;

    // Check if extension is enabled
    CExtSI* pExt = spBaseSnapIn->GetExtensionSnapIn();
    while (pExt != NULL)
    {
        if (pExt->GetSnapIn()->GetSnapInCLSID() == ExtCLSID)
            break;

        pExt = pExt->Next();
    }

    // if extension is present and not marked for deletion
    if (pExt != NULL && !pExt->IsMarkedForDeletion())
    {
        // If should be disabled, just mark deleted
        if (!bEnable)
            pExt->MarkDeleted(TRUE);
    }
    else
    {
        // if should be enabled
        if (bEnable)
        {
            // if extension is present, just undelete
            if (pExt != NULL)
            {
                pExt->MarkDeleted(FALSE);
            }
            else
            {
                // Find or create cache entry for extension snapin
                sc = m_spCache->ScGetSnapIn(ExtCLSID, &spExtSnapIn);
                if (sc)
                    return sc;

                // Add as extension to base snapin
                spBaseSnapIn->AddExtension(spExtSnapIn);
            }
        }
    }

    return sc;
}



/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScDump
 *
 * PURPOSE: dumps contents of snapin cache
 *
 * PARAMETERS:
 *    LPCTSTR pszDumpFilePath [in] file to dump to
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScDump (LPCTSTR pszDumpFilePath)
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScDump"));

	/*
	 * validate input
	 */
	sc = ScCheckPointers (pszDumpFilePath);
	if (sc)
		return sc;

    if (pszDumpFilePath[0] == 0)
        return sc = E_INVALIDARG;

	/*
	 * make sure a file is open
	 */
	if (!IsFileOpen())
		return ((sc = E_UNEXPECTED).ToHr());

	sc = ScCheckPointers (m_spCache, E_UNEXPECTED);
	if (sc)
		return (sc.ToHr());

    return (m_spCache->Dump (pszDumpFilePath));
}



/***************************************************************************\
 *
 * METHOD:  CMMCDocConfig::ScCheckSnapinAvailability
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *    	BOOL  f32bit            [in]    // check 32-bit (vs. 64-bit) snap-ins?
 *    	UINT& cTotalSnapins     [out]   // total number of snap-ins referenced in the console file
 *    	UINT& cAvailableSnapins [out]   // number of snap-ins available in the requested memory model
 *
 * RETURNS:
 *    SC    - result code
 *
\***************************************************************************/
SC CMMCDocConfig::ScCheckSnapinAvailability (CAvailableSnapinInfo& asi)
{
    DECLARE_SC(sc, TEXT("CMMCDocConfig::ScCheckSnapinAvailability"));

	/*
	 * make sure a file is open
	 */
	if (!IsFileOpen())
		return ((sc = E_UNEXPECTED).ToHr());

	sc = ScCheckPointers (m_spCache, E_UNEXPECTED);
	if (sc)
		return sc;

	sc = m_spCache->ScCheckSnapinAvailability (asi);
	if (sc)
		return sc;

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\doccnfg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       doccnfg.h
//
//--------------------------------------------------------------------------

// DocCnfg.h: Definition of the CMMCDocConfig class
//
//////////////////////////////////////////////////////////////////////

#ifndef _DOCCNFG_H_
#define _DOCCNFG_H_


/////////////////////////////////////////////////////////////////////////////
// CMMCDocConfig

class CMMCDocConfig :
    public CComDualImpl<IDocConfig, &IID_IDocConfig, &LIBID_NODEMGRLib>,
    //public ISupportErrorInfo,
    public CComObjectRoot,
    public IDumpSnapins,
    public CComCoClass<CMMCDocConfig, &CLSID_MMCDocConfig>,
    public CConsoleFilePersistor
{

private:
    IStoragePtr             m_spStorage;
    tstring                 m_strFilePath;
    CAutoPtr<CSnapInsCache> m_spCache;
    CXMLDocument            m_XMLDocument;
    CXMLElement             m_XMLElemConsole;
    CXMLElement             m_XMLElemTree;

public:
    ~CMMCDocConfig();

BEGIN_COM_MAP(CMMCDocConfig)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IDocConfig)
    COM_INTERFACE_ENTRY(IDumpSnapins)
    //COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_AGGREGATABLE(CMMCDocConfig)

DECLARE_MMC_OBJECT_REGISTRATION (
	g_szMmcndmgrDll,					// implementing DLL
    CLSID_MMCDocConfig,             	// CLSID
    _T("DocConfig 1.0 Object"),         // class name
    _T("NODEMGR.MMCDocConfig.1"),       // ProgID
    _T("NODEMGR.MMCDocConfig"))         // version-independent ProgID

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IDocConfig
public:
    STDMETHOD(OpenFile)(BSTR bstrFilePath);
    STDMETHOD(SaveFile)(BSTR bstrFilePath);
    STDMETHOD(CloseFile)();
    STDMETHOD(EnableSnapInExtension)(BSTR bstrSnapInCLSID, BSTR bstrExtCLSID, VARIANT_BOOL bEnable);

// IDumpSnapins
    STDMETHOD(Dump)(LPCTSTR pszDumpFilePath);
	STDMETHOD(CheckSnapinAvailability)(CAvailableSnapinInfo& asi);

private:
    BOOL IsFileOpen() { return !m_strFilePath.empty(); }

    SC ScOpenFile(BSTR bstrFilePath);
    SC ScCloseFile();
    SC ScSaveFile(BSTR bstrFilePath);
    SC ScEnableSnapInExtension(BSTR bstrSnapInCLSID, BSTR bstrExtCLSID, VARIANT_BOOL bEnable);
    SC ScDump (LPCTSTR pszDumpFilePath);
    SC ScCheckSnapinAvailability (CAvailableSnapinInfo& asi);
};

#endif // _DOCCNFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\dummysi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dummysi.cpp
//
//  Contents:  If a snapin creation fails a Dummy snapin is created,
//             this file contains the dummy snapin implementation.
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "dummysi.h"
#include "regutil.h"


const CLSID CLSID_Dummy    = {0x82c37898,0x7808,0x11d1,{0xa1,0x90,0x00,0x00,0xf8,0x75,0xb1,0x32}};
const GUID IID_CDummySnapinCD = {0xe683b257, 0x3ca9, 0x454a, {0xae, 0xb9, 0x7, 0x64, 0xdd, 0x31, 0xb1, 0xe8}};

//+-------------------------------------------------------------------
//
//  Class:      CDummySnapinCD
//
//  Purpose:    Dummy snapin's ComponentData.
//
//  Notes:      Dummy snapin should implement all 3 persist interfaces
//              or None. So let us implement none.
//
//--------------------------------------------------------------------

class CDummySnapinCD :
    public IComponentData,
    public CComObjectRoot

{
public:

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDummySnapinCD)

BEGIN_COM_MAP(CDummySnapinCD)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY_IID(IID_CDummySnapinCD, CDummySnapinCD)
END_COM_MAP()

    CDummySnapinCD() : m_eReason(eNoReason) {}
    ~CDummySnapinCD() {}

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    void  SetDummyCreateReason(EDummyCreateReason eReason) { m_eReason = eReason; }
    EDummyCreateReason GetDummyCreateReason() const { return m_eReason;}

    const CLSID& GetFailedSnapinCLSID() { return m_clsid;}
    void SetFailedSnapinCLSID(const CLSID& clsid) { m_clsid = clsid; }

private:
    EDummyCreateReason m_eReason;       // Reason for dummy creation.
    CLSID              m_clsid;         // Class ID of the snapin that could not be created.
};

DEFINE_COM_SMARTPTR(CDummySnapinCD);   // CDummySnapinCDPtr

//+-------------------------------------------------------------------
//
//  Class:      CDataObject
//
//  Purpose:    Dummy snapin's IDataObject implementation.
//
//--------------------------------------------------------------------
class CDataObject:
    public IDataObject,
    public CComObjectRoot
{
public:

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)

BEGIN_COM_MAP(CDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

    CDataObject();
    ~CDataObject() {}

// IDataObject overrides
    STDMETHOD(GetDataHere) (FORMATETC *pformatetc, STGMEDIUM *pmedium);
// Not Implemented
private:
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };
    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

public:
    static UINT s_cfInternal;      // Our custom clipboard format
    static UINT s_cfDisplayName;   // Our test for a node
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
};

//+-------------------------------------------------------------------
//
//  Class:      CDummySnapinC
//
//  Purpose:    Dummy snapin's IComponent implementation.
//
//--------------------------------------------------------------------
class CDummySnapinC:
    public IComponent,
    public CComObjectRoot
{
private:
    LPCONSOLE       m_pConsole;
    CDummySnapinCD* m_pComponentData;

public:
    void SetComponentData(CDummySnapinCD* pCompData)
    {
        m_pComponentData = pCompData;
    }

public:

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDummySnapinC)

BEGIN_COM_MAP(CDummySnapinC)
    COM_INTERFACE_ENTRY(IComponent)
END_COM_MAP()

    CDummySnapinC() :m_pConsole(NULL), m_pComponentData(NULL) {}
    ~CDummySnapinC() {}

    //
    // IComponent interface members
    //
    STDMETHOD(Initialize) (LPCONSOLE lpConsole);
    STDMETHOD(Notify) (LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy) (MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType) (MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject) (MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo) (RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects) (LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);
};

//+-------------------------------------------------------------------
//
//  Member:     ScCreateDummySnapin
//
//  Synopsis:   Create a dummy snapin.
//
//  Arguments:  [ppICD]   -  Ptr to dummy snapins IComponentData.
//              [eReason] -  Reason for creating dummy snapin.
//              [clsid]   -  Class ID of the snapin that could not be created.
//
//--------------------------------------------------------------------
SC ScCreateDummySnapin (IComponentData ** ppICD, EDummyCreateReason eReason, const CLSID& clsid)
{
    DECLARE_SC(sc, TEXT("ScCreateDummySnapin"));

    sc = ScCheckPointers(ppICD);
    if(sc)
        return sc;

    ASSERT(eNoReason != eReason);

    *ppICD = NULL;

    CComObject<CDummySnapinCD>* pDummySnapinCD;
    sc = CComObject<CDummySnapinCD>::CreateInstance (&pDummySnapinCD);
    if (sc)
        return sc;

    if (NULL == pDummySnapinCD)
        return (sc = E_UNEXPECTED);

    pDummySnapinCD->SetDummyCreateReason(eReason);
    pDummySnapinCD->SetFailedSnapinCLSID(clsid);

    IComponentDataPtr spComponentData = pDummySnapinCD;
    if(spComponentData == NULL)
    {
        delete pDummySnapinCD;
        return (sc = E_UNEXPECTED);
    }

    *ppICD = spComponentData;
    if(NULL == *ppICD)
    {
        delete pDummySnapinCD;
        return (sc = E_UNEXPECTED);
    }

    (*ppICD)->AddRef(); //addref for client

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     ReportSnapinInitFailure
//
//  Synopsis:   Get the name of the snapin provided class id.
//
//  Arguments:  [strClsid] - Class id of the snapin.
//              [szName]   - Name of the snapin.
//
//--------------------------------------------------------------------
void ReportSnapinInitFailure(const CLSID& clsid)
{
    DECLARE_SC(sc, _T("ReportSnapinInitFailure"));

    // snapin name
    CStr strMessage;
    strMessage.LoadString(GetStringModule(), IDS_SNAPIN_FAILED_INIT_NAME);

    CCoTaskMemPtr<WCHAR> spszClsid;
    sc = StringFromCLSID(clsid, &spszClsid);
    if (sc)
        return;

    USES_CONVERSION;
    tstring strSnapName;
    bool bSuccess = GetSnapinNameFromCLSID(clsid, strSnapName);
    if (false == bSuccess)
    {
        TraceError(_T("GetSnapinName call in ReportSnapinInitFailure failed."), sc);

        // signal unknown name of snapin and continue
        if ( !strSnapName.LoadString( GetStringModule(), IDS_UnknownSnapinName ) )
            strSnapName = _T("<unknown>");
    }

    strMessage += strSnapName.data();

    // clsid
    CStr strClsid2;
    strClsid2.LoadString(GetStringModule(), IDS_SNAPIN_FAILED_INIT_CLSID);
    strClsid2 += OLE2T(spszClsid);

    // construct the error message
    CStr strError;
    strError.LoadString(GetStringModule(), IDS_SNAPIN_FAILED_INIT);

    strError += strMessage;
    strError += strClsid2;

    MMCErrorBox(strError, MB_OK|MB_TASKMODAL);

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::Initialize
//
//  Synopsis:   Does nothing.
//
//  Arguments:  [pUnknown] - IConsole2 ptr.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::Initialize (LPUNKNOWN pUnknown)
{ return S_OK; }

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::CreateComponent
//
//  Synopsis:   Creates a CDummySnapinC object.
//
//  Arguments:  [ppComponent] - Ptr to created component.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::CreateComponent (LPCOMPONENT* ppComponent)
{
    SC sc = E_FAIL;

    CComObject<CDummySnapinC>* pDummySnapinC;
    sc = CComObject<CDummySnapinC>::CreateInstance (&pDummySnapinC);
    if (sc)
        goto Error;

    if (NULL == pDummySnapinC)
        goto Error;

    pDummySnapinC->SetComponentData(this);
    sc = pDummySnapinC->QueryInterface(IID_IComponent, reinterpret_cast<void**>(ppComponent));

Cleanup:
    return HrFromSc(sc);

Error:
    TraceError(TEXT("CDummySnapinCD::CreateComponent"), sc);
     goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::Notify
//
//  Synopsis:   Right now does not handle any events.
//
//  Arguments:  [lpDataObject] - Ptr to created component.
//              [event]        - Event type.
//              [arg, param)   - event specific data.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::Notify (LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::Destroy
//
//  Synopsis:   Right now does nothing to destroy.
//
//  Arguments:  None
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::Destroy ()
{ return S_OK; }

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::QuertDataObject
//
//  Synopsis:   Get IDataObject.
//
//  Arguments:  [cookie]       - Snapin specific data.
//              [type]         - data obj type, Scope/Result/Snapin mgr...
//              [ppDataObject] - IDataObject ptr.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::QueryDataObject (MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    SC sc = E_FAIL;

    CComObject<CDataObject>* pDataObject;
    sc = CComObject<CDataObject>::CreateInstance (&pDataObject);
    if (sc)
        goto Error;

    if (NULL == pDataObject)
        goto Error;

    sc = pDataObject->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(ppDataObject));

Cleanup:
    return HrFromSc(sc);

Error:
    TraceError(TEXT("CDummySnapinCD::QueryDataObject"), sc);
     goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::GetDisplayInfo
//
//  Synopsis:   Display info call back.
//              (Right now there is nothing to display, no enumerated item).
//
//  Arguments:  [pScopeDataItem] - Snapin should fill this struct for Display info.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::GetDisplayInfo (SCOPEDATAITEM* pScopeDataItem)
{ return S_OK; }

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinCD::CompareObjects
//
//  Synopsis:   Used for sort / find prop sheet...
//              (Right now do nothing as we have only one item).
//
//  Arguments:  [lpDataObjectA] - IDataObject of first item.
//              [lpDataObjectB] - IDataObject of second item.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinCD::CompareObjects (LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{ return S_OK; }

#define MY_CF_SNAPIN_INTERNAL L"DUMMY SNAPIN"

// global(s)
const GUID GUID_DummyNode = {
    0x82c37899,
    0x7808,
    0x11d1,
    {0xa1, 0x90, 0x00, 0x00, 0xf8, 0x75, 0xb1, 0x32}
};

// statics
UINT CDataObject::s_cfInternal = 0;
UINT CDataObject::s_cfDisplayName = 0;
UINT CDataObject::s_cfNodeType = 0;
UINT CDataObject::s_cfSnapinClsid = 0;

CDataObject::CDataObject()
{
    USES_CONVERSION;
    s_cfInternal    = RegisterClipboardFormat (W2T(MY_CF_SNAPIN_INTERNAL));
    s_cfDisplayName = RegisterClipboardFormat (W2T(CCF_DISPLAY_NAME));
    s_cfNodeType    = RegisterClipboardFormat (W2T(CCF_NODETYPE));
    s_cfSnapinClsid = RegisterClipboardFormat (W2T(CCF_SNAPIN_CLASSID));
}

//+-------------------------------------------------------------------
//
//  Member:     CDataObject::GetDataHere
//
//  Synopsis:   IDataObject::GetDataHere.
//
//  Arguments:  [pformatetc]
//              [pmedium]
//
//--------------------------------------------------------------------
HRESULT CDataObject::GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    SC sc = DV_E_FORMATETC;

    IStream * pstm = NULL;
    sc = CreateStreamOnHGlobal (pmedium->hGlobal, FALSE, &pstm);
    if (pstm) {

       const CLIPFORMAT cf = pformatetc->cfFormat;

       if (cf == s_cfDisplayName) {
          LPTSTR pszName = _T("Display Manager (Version 2)");
          sc = pstm->Write (pszName, sizeof(TCHAR)*(1+_tcslen (pszName)), NULL);
       } else
       if (cf == s_cfInternal) {
          CDataObject * pThis = this;
          sc = pstm->Write (pThis, sizeof(CDataObject *), NULL);
       } else
       if (cf == s_cfNodeType) {
          const GUID * pguid;
          pguid = &GUID_DummyNode;
          sc = pstm->Write ((PVOID)pguid, sizeof(GUID), NULL);
       } else
       if (cf == s_cfSnapinClsid) {
          sc = pstm->Write (&CLSID_Dummy, sizeof(CLSID_Dummy), NULL);
       } else {
          sc = DV_E_FORMATETC;
          // don't ASSERT
          // _ASSERT(hresult == S_OK);
       }
       pstm->Release();
    }

    return HrFromSc(sc);
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::Initialize
//
//  Synopsis:   Just store given ICOnsole2.
//
//  Arguments:  [lpConsole] - IConsole2 ptr.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::Initialize (LPCONSOLE lpConsole)
{
    m_pConsole = lpConsole;
    if (m_pConsole)
        m_pConsole->AddRef();

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::Notify
//
//  Synopsis:   Right now handle only MMCN_SHOW to display
//              IMessageView with failure message.
//
//  Arguments:  [lpDataObject] - Ptr to created component.
//              [event]        - Event type.
//              [arg, param)   - event specific data.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::Notify (LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    DECLARE_SC(sc, _T("CDummySnapinC::Notify"));
    sc = S_FALSE; // Default ret val.

    switch(event)
    {
    case MMCN_SHOW: // Display error message during MMCN_SHOW, TRUE.
        {
            if (FALSE == arg)
                break;

            // First get the IUnknown of Result Pane.
            LPUNKNOWN lpUnkn = NULL;
            sc = m_pConsole->QueryResultView(&lpUnkn);

            if (sc)
                return sc.ToHr();

            // Now get the message view.
            IMessageViewPtr spMessageView;
            sc = lpUnkn->QueryInterface(IID_IMessageView, reinterpret_cast<void**>(&spMessageView));
            lpUnkn->Release();

            if (sc)
                return sc.ToHr();

            // Got the message view, not set the title and text.
            CStr strTempForLoading; // Temp object for loading string from resources.

            sc = spMessageView->Clear();
            if (sc)
                return sc.ToHr();

            strTempForLoading.LoadString(GetStringModule(), IDS_SNAPIN_CREATE_FAILED);

            USES_CONVERSION;
            sc = spMessageView->SetTitleText( T2OLE((LPTSTR)(LPCTSTR)strTempForLoading));
            if (sc)
                return sc.ToHr();

            sc = spMessageView->SetIcon(Icon_Error);
            if (sc)
                return sc.ToHr();

            //////////////////////////////////
            // The body text is as follows  //
            //      Reason.                 //
            //      Snapin Name.            //
            //      Snapin Class ID.        //
            //////////////////////////////////

            tstring szBodyText;       // Body text for message view.

            if (m_pComponentData->GetDummyCreateReason() == eSnapPolicyFailed)
                strTempForLoading.LoadString(GetStringModule(), IDS_SNAPIN_POLICYFAILURE);
            else
                strTempForLoading.LoadString(GetStringModule(), IDS_SNAPIN_FAILED);

            // Reason for failure.
            szBodyText = strTempForLoading + _T('\n');

            // Snapin name.
            CStr strSnapName;
            strTempForLoading.LoadString(GetStringModule(), IDS_SNAPIN_FAILED_INIT_NAME);
            szBodyText += strTempForLoading;

            CCoTaskMemPtr<WCHAR> spszClsid;
            sc = StringFromCLSID(m_pComponentData->GetFailedSnapinCLSID(), &spszClsid);
            if (sc)
                return sc.ToHr();

            // Get the snapin name.
            tstring szSnapinName;
            bool bSucc = GetSnapinNameFromCLSID(m_pComponentData->GetFailedSnapinCLSID(), szSnapinName);
            if (false == bSucc)
            {
                sc = E_FAIL;
                TraceError(_T("GetSnapinName call in CDummySnapinC::Notify failed."), sc);
                return sc.ToHr();
            }

            szBodyText += szSnapinName;
            szBodyText += _T("\n");

            // Now add the snapin class id.
            strTempForLoading.LoadString(GetStringModule(), IDS_SNAPIN_FAILED_INIT_CLSID);
            szBodyText += strTempForLoading;
            szBodyText += OLE2T(spszClsid);

            sc = spMessageView->SetBodyText( T2COLE(szBodyText.data()));
        }
        break;

    default:
        break;
    }

    return sc.ToHr();
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::Destroy
//
//  Synopsis:   Release the cached IConsole2 ptr.
//
//  Arguments:  None
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::Destroy (MMC_COOKIE cookie)
{
    if (m_pConsole)
        m_pConsole->Release();

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::GetResultViewType
//
//  Synopsis:   Specify the message view as result view type.
//
//  Arguments:  [cookie]       - Snapin supplied param.
//              [ppViewType]   - View Name (OCX - GUID, WEB - URL name).
//              [pViewOptions] - View options
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::GetResultViewType (MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions)
{
    SC sc;

    TCHAR szBuffer[MAX_PATH * 2];

    // We want to display the error message using the message view.
    LPOLESTR lpClsid = NULL;
    sc = StringFromCLSID(CLSID_MessageView, &lpClsid);

    USES_CONVERSION;
    if (!sc.IsError())
    {
        // Use the message view to display error message.
        _tcscpy (szBuffer, OLE2T(lpClsid));
        ::CoTaskMemFree(lpClsid);
    }
    else
    {
        // Conversion failed, display default error page.
        _tcscpy (szBuffer, _T("res://"));
        ::GetModuleFileName (NULL, szBuffer + _tcslen(szBuffer), MAX_PATH);
        _tcscat (szBuffer, _T("/error.htm"));
    }

    *ppViewType = (OLECHAR *)::CoTaskMemAlloc (sizeof(OLECHAR)*(1+_tcslen(szBuffer)));
    if (!*ppViewType)
    {
        sc = E_OUTOFMEMORY;
        goto Error;
    }

    wcscpy (*ppViewType, T2OLE(szBuffer));

Cleanup:
    return HrFromSc(sc);
Error:
    TraceError(TEXT("CDummySnapinC::GetResultViewType"), sc);
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::QuertDataObject
//
//  Synopsis:   Get IDataObject.
//
//  Arguments:  [cookie]       - Snapin specific data.
//              [type]         - data obj type, Scope/Result/Snapin mgr...
//              [ppDataObject] - IDataObject ptr.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::QueryDataObject (MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    SC sc = E_FAIL;

    CComObject<CDataObject>* pDataObject;
    sc = CComObject<CDataObject>::CreateInstance (&pDataObject);
    if (sc)
        goto Error;

    if (NULL == pDataObject)
        goto Error;

    sc = pDataObject->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(ppDataObject));

Cleanup:
    return HrFromSc(sc);
Error:
    TraceError(TEXT("CDummySnapinC::QueryDataObject"), sc);
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::GetDisplayInfo
//
//  Synopsis:   Display info call back.
//              (Right now there is nothing to display, no result items).
//
//  Arguments:  [pResultDataItem] - Snapin should fill this struct for Display info.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::GetDisplayInfo (RESULTDATAITEM*  pResultDataItem)
{ return S_OK; }

//+-------------------------------------------------------------------
//
//  Member:     CDummySnapinC::CompareObjects
//
//  Synopsis:   Used for sort / find prop sheet...
//              (Right now do nothing as we dont have any result items).
//
//  Arguments:  [lpDataObjectA] - IDataObject of first item.
//              [lpDataObjectB] - IDataObject of second item.
//
//--------------------------------------------------------------------
HRESULT CDummySnapinC::CompareObjects (LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{ return S_OK; }

#include "scopndcb.h"

//+-------------------------------------------------------------------
//
//  Member:      CNodeCallback::IsDummySnapin
//
//  Synopsis:    Given the node see if it is dummy snapin.
//
//  Arguments:   [hNode]        - [in] Node selection context.
//               [bDummySnapin] - [out] Is this dummy snapin?
//
//  Returns:     SC
//
//--------------------------------------------------------------------
HRESULT CNodeCallback::IsDummySnapin (/*[in]*/HNODE hNode, /*[out]*/bool& bDummySnapin)
{
    DECLARE_SC(sc, _T("CNodeCallback::IsDummySnapin"));
    sc = ScCheckPointers( (void*) hNode);
    if (sc)
        return sc.ToHr();

    bDummySnapin = false;

    CNode *pNode = CNode::FromHandle(hNode);
    sc = ScCheckPointers(pNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CMTNode *pMTNode = pNode->GetMTNode();
    sc = ScCheckPointers(pMTNode, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CComponentData *pComponentData = pMTNode->GetPrimaryComponentData();
    sc = ScCheckPointers(pComponentData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    IComponentData* pIComponentData = pComponentData->GetIComponentData();
    sc = ScCheckPointers(pIComponentData, E_UNEXPECTED);
    if (sc)
        return sc.ToHr();

    CDummySnapinCDPtr spDummyCD = pIComponentData;
    if (spDummyCD)
        bDummySnapin = true;

    return (sc.ToHr());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\dummysi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dummysi.h
//
//--------------------------------------------------------------------------

#ifndef DUMMYSI_H
#define DUMMYSI_H
#pragma once

// Different reasons for which a dummy snapin is created.
enum EDummyCreateReason
{
    eNoReason = 0,
    eSnapPolicyFailed,
    eSnapCreateFailed,
};


SC ScCreateDummySnapin (IComponentData ** ppICD, EDummyCreateReason, const CLSID& clsid);
void ReportSnapinInitFailure(const CLSID& clsid);

extern const GUID IID_CDummySnapinCD;

#endif /* DUMMYSI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\guids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       guids.h
//
//--------------------------------------------------------------------------

// GUIDS.H

#ifndef __GUIDS_H__
#define __GUIDS_H__



//{40FC6ED4-2438-11CF-A3DB-080036F12502} - Standard windows ocx control
static const CATID CATID_OCXControl = 
    { 0x40fc6ed4, 0x2438, 0xa3db, { 0xa3, 0xdb, 0x08, 0x0, 0x36, 0xf1, 0x25, 0x02 } };

#define CONSOLECONTROLS_COMPCAT_NAME _T("Managment Console Controls")

// {B0DAE1CC-F531-11cf-AACE-00AA00BDD61E} - AMC Control category (Component Category)
static const CATID CATID_ConsoleControl = 
    { 0xb0dae1cc, 0xf531, 0x11cf, { 0xaa, 0xce, 0x0, 0xaa, 0x0, 0xbd, 0xd6, 0x1e } };

#define MONITORINGCONTROLS_COMPCAT_NAME _T("Monitoring Controls")

// {B1E09020-0105-11d0-AADA-00AA00BDD61E}
static const CATID CATID_ConsoleMonitorControl = 
{ 0xb1e09020, 0x105, 0x11d0, { 0xaa, 0xda, 0x0, 0xaa, 0x0, 0xbd, 0xd6, 0x1e } };


#endif //__GUIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\nodemgr\fldrsnap.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:       fldrsnap.h
 *
 *  Contents:   Header file for built-in snapins that implement
 *              the Folder, ActiveX Control, and Web Link nodes.
 *                  These replace earlier code that had special "built-in"
 *              nodetypes.
 *
 *  History:    23-Jul-98 vivekj     Created
 *
 *--------------------------------------------------------------------------*/
#ifndef __FOLDERSNAPIN_H_
#define __FOLDERSNAPIN_H_

extern const CLSID CLSID_FolderSnapin;
extern const CLSID CLSID_OCXSnapin;
extern const CLSID CLSID_HTMLSnapin;

extern LPCTSTR szClsid_FolderSnapin;
extern LPCTSTR szClsid_HTMLSnapin;
extern LPCTSTR szClsid_OCXSnapin;


// forward decls
class CHTMLPage1;
class CHTMLPage2;

class CActiveXPage0;
class CActiveXPage1;
class CActiveXPage2;

HRESULT WINAPI IPersistStreamFunc(void* pv, REFIID riid, LPVOID* ppv, DWORD dw);

SC ScFormatIndirectSnapInName (
	HINSTANCE	hInst,					/* I:module containing the resource	*/
	int			idNameString,			/* I:ID of name's string resource	*/
	CStr&		strName);				/* O:formatted indirect name string	*/


/*+-------------------------------------------------------------------------*
 * Class:      CSnapinDescriptor
 *
 * PURPOSE:    A class that contains information to be filled in by
 *             derived snap-ins.
 *
 *+-------------------------------------------------------------------------*/
class CSnapinDescriptor
{
private:
    UINT    m_idsName;
    UINT    m_idsDescription;
    UINT    m_idbSmallImage;
    UINT 