TocOffset),
            rbuffPLP);
}

VOID
SxspDbgPrintActivationContextData(
    ULONG Level,
    PCACTIVATION_CONTEXT_DATA Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    if (::FusionpDbgWouldPrintAtFilterLevel(Level))
    {
        ::SxsppDbgPrintActivationContextData(Level, ::FusionpDbgWouldPrintAtFilterLevel(FUSION_DBG_LEVEL_FULLACTCTX), Data, rbuffPLP);
    }
}

VOID
SxspDbgPrintActivationContextDataAssemblyRoster(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    ULONG i;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY Entry;
    CSmallStringBuffer buffFlags;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION AssemblyInformation = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgAssemblyRosterEntryFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID, "Invalid")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT, "Root")
    };

    PCWSTR PLP = rbuffPLP;

    if (fFull)
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER %p\n"
            "%S   HeaderSize = %lu (0x%lx)\n"
            "%S   EntryCount = %lu (0x%lx)\n"
            "%S   FirstEntryOffset = %ld (0x%lx)\n",
            PLP, Data,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->EntryCount, Data->EntryCount,
            PLP, Data->FirstEntryOffset, Data->FirstEntryOffset);
    else
        ::FusionpDbgPrintEx(
            Level,
            "%SAssembly Roster (%lu assemblies)\n"
            "%SIndex | Assembly Name (Flags)\n",
            PLP, Data->EntryCount - 1,
            PLP);

    for (i=0; i<Data->EntryCount; i++)
    {
        Entry = ((PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset)) + i;

        UNICODE_STRING s;

        if (Entry->AssemblyNameOffset != 0)
        {
            s.Length = (USHORT) Entry->AssemblyNameLength;
            s.MaximumLength = s.Length;
            s.Buffer = (PWSTR) (((ULONG_PTR) Base) + Entry->AssemblyNameOffset);
        }
        else
        {
            s.Length = 0;
            s.MaximumLength = 0;
            s.Buffer = NULL;
        }

        ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgAssemblyRosterEntryFlags), s_rgAssemblyRosterEntryFlags, buffFlags);

        if (Entry->AssemblyInformationOffset != NULL)
            AssemblyInformation = (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) (((ULONG_PTR) Base) + Entry->AssemblyInformationOffset);
        else
            AssemblyInformation = NULL;

        if (fFull)
        {
            ::FusionpDbgPrintEx(
                Level,
                "%S   ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY %p [#%d]\n"
                "%S      Flags = 0x%08lx (%S)\n"
                "%S      PseudoKey = %lu\n",
                PLP, Entry, i,
                PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags),
                PLP, Entry->PseudoKey);

            ::FusionpDbgPrintEx(
                Level,
                "%S      AssemblyNameOffset = %lu (0x%lx) \"%wZ\"\n"
                "%S      AssemblyNameLength = %lu (0x%lx) \n"
                "%S      AssemblyInformationOffset = %lu (0x%lx) (-> %p)\n"
                "%S      AssemblyInformationLength = %lu (0x%lx)\n",
                PLP, Entry->AssemblyNameOffset, Entry->AssemblyNameOffset, &s,
                PLP, Entry->AssemblyNameLength, Entry->AssemblyNameLength,
                PLP, Entry->AssemblyInformationOffset, Entry->AssemblyInformationOffset, AssemblyInformation,
                PLP, Entry->AssemblyInformationLength, Entry->AssemblyInformationLength);
        }
        else
        {
            if (i != 0)
                ::FusionpDbgPrintEx(
                    Level,
                    "%S%5lu | %wZ (%S)\n",
                    PLP, i, &s, static_cast<PCWSTR>(buffFlags));
        }
    }
}

VOID
SxspDbgPrintActivationContextDataTocHeader(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffFlags;
    ULONG i;
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY FirstEntry = NULL;

    if (PLP == NULL)
        PLP = L"";

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE, "Dense")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER, "Inorder")
    };

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgFlags), s_rgFlags, buffFlags);

    if (Data->FirstEntryOffset != 0)
        FirstEntry = (PCACTIVATION_CONTEXT_DATA_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_TOC_HEADER %p\n"
            "%S   HeaderSize = %d (0x%lx)\n"
            "%S   EntryCount = %d\n"
            "%S   FirstEntryOffset = %d (0x%lx) (-> %p)\n"
            "%S   Flags = 0x%08lx (%S)\n",
            PLP, Data,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->EntryCount,
            PLP, Data->FirstEntryOffset, Data->FirstEntryOffset, FirstEntry,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));
    }

    if (FirstEntry != NULL)
    {
        SIZE_T cchSave = rbuffPLP.Cch();

        rbuffPLP.Win32Append(L"   ", 3);

        for (i=0; i<Data->EntryCount; i++)
            ::SxspDbgPrintActivationContextDataTocEntry(Level, fFull, Base, &FirstEntry[i], rbuffPLP);

        rbuffPLP.Left(cchSave);
    }

}

VOID
SxspDbgPrintActivationContextDataTocSections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Data,
    const GUID *ExtensionGuid,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    SIZE_T cchPLP = rbuffPLP.Cch();

    if (Data->FirstEntryOffset != 0)
    {
        PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entries = (PCACTIVATION_CONTEXT_DATA_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
        ULONG i;

        for (i=0; i<Data->EntryCount; i++)
        {
            if (Entries[i].Offset != 0)
            {
                //
                // ISSUE: jonwis 3/7/2002
                // - Why build up the buffSectionId string if we never output it?
                //
                PVOID Section = (PVOID) (((ULONG_PTR) Base) + Entries[i].Offset);
                CSmallStringBuffer buffSectionId;
                PCSTR pszSectionName = "<untranslatable>";

                if (ExtensionGuid != NULL)
                {
                    //
                    // ISSUE: jonwis 3/7/2002
                    // - Stack-based strings are evil.  Use .Win32ResizeBuffer along with
                    //   .Win32FormatAppend to get rid of this:
                    //
                    //   buffSectionId.Win32ResizeBuffer(buffSectionId.Cch() + 1 + (sizeof(LONG)*CHAR_BIT));
                    //   buffSectionId.Win32FormatAppend(L".%u", Entries[i].Id);
                    //
                    WCHAR rgchBuff[sizeof(LONG)*CHAR_BIT];

                    ::SxspFormatGUID(*ExtensionGuid, buffSectionId);
                    buffSectionId.Win32Append(L".", 1);
                    swprintf(rgchBuff, L"%u", Entries[i].Id);
                    buffSectionId.Win32Append(rgchBuff, ::wcslen(rgchBuff));
                }
                else
                {
                    WCHAR rgchBuff[255];

#define MAP_ENTRY(_x, _y) case _x: if (fFull) pszSectionName = #_x; else pszSectionName = _y; break;

                    switch (Entries[i].Id)
                    {
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, "Assembly Information")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "DLL Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "Window Class Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION, "COM Server Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION, "COM Interface Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION, "COM Type Library Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION, "COM ProgId Redirection")
                    MAP_ENTRY(ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE, "Win32 Global Object Name Redirection")
                    }

                    //
                    // ISSUE: jonwis 3/7/2002
                    // - See above.  Use .Win32ResizeBuffer and .Win32FormatAppend
                    //
                    if (pszSectionName != NULL)
                        swprintf(rgchBuff, L"%u (%S)", Entries[i].Id, pszSectionName);
                    else
                        swprintf(rgchBuff, L"%u", Entries[i].Id);

                    buffSectionId.Win32Append(rgchBuff, ::wcslen(rgchBuff));
                }

                ::SxspDbgPrintActivationContextDataTocSection(
                    Level,
                    fFull,
                    Section,
                    Entries[i].Length,
                    ExtensionGuid,
                    Entries[i].Id,
                    pszSectionName,
                    rbuffPLP);
            }
        }
    }
}

VOID
SxspDbgPrintActivationContextDataTocSection(
    ULONG Level,
    bool fFull,
    PVOID Section,
    SIZE_T Length,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    )
{
    if (Length > sizeof(ULONG))
    {
        switch (*(ULONG *) Section)
        {
        case ACTIVATION_CONTEXT_STRING_SECTION_MAGIC:
            ::SxspDbgPrintActivationContextStringSection(
                Level,
                fFull,
                (PCACTIVATION_CONTEXT_STRING_SECTION_HEADER) Section,
                ExtensionGuid,
                SectionId,
                SectionName,
                rbuffPLP);
            break;
        case ACTIVATION_CONTEXT_GUID_SECTION_MAGIC:
            ::SxspDbgPrintActivationContextGuidSection(
                Level,
                fFull,
                (PCACTIVATION_CONTEXT_GUID_SECTION_HEADER) Section,
                ExtensionGuid,
                SectionId,
                SectionName,
                rbuffPLP);
            break;
        default:
            break;
        }
    }
    else if ( SectionId != 0 )
    {
        ::SxspDbgPrintActivationContextBinarySection(
            Level,
            fFull,
            Section,
            Length,
            rbuffPLP);
    }
}

const STRING *
SxspDbgSectionIdToNtString(
    ULONG Id
    )
{
    switch (Id)
    {
#define ENTRY(id, s) id : { const static STRING t = RTL_CONSTANT_STRING(s); return &t; }
    ENTRY(default, "<No name associated with id>");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, "Assembly Information");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "Dll Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "Window Class Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION, "COM Server Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION, "COM Interface Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION, "COM Type Library Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION, "COM ProgId Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE, "Win32 Global Object Name Redirection");
    ENTRY(case ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES, "CLR Surrogate Type Table");
#undef ENTRY
    }
}

PCSTR
SxspDbgSectionIdToString(
    ULONG Id
    )
{
    return SxspDbgSectionIdToNtString(Id)->Buffer;
}

VOID
SxspDbgPrintActivationContextDataTocEntry(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_TOC_ENTRY Entry,
    CBaseStringBuffer &rbuffPLP
    )
{
    PVOID SectionData = NULL;
    PCSTR pszFormat = "<untranslated format>";
    PCWSTR PLP = rbuffPLP;

    if (!fFull)
        return;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->Offset != 0)
        SectionData = (PVOID) (((ULONG_PTR) Base) + Entry->Offset);

#define MAP_FORMAT(_x, _sn) \
case _x: \
    if (fFull) \
        pszFormat = #_x; \
    else \
        pszFormat = _sn; \
    break;

    switch (Entry->Format)
    {
    default: break;
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_UNKNOWN, "user defined");
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE, "string table");
    MAP_FORMAT(ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE, "guid table");
    }
#undef MAP_FORMAT

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_TOC_ENTRY %p\n"
            "%S   Id = %Z (%u)\n"
            "%S   Offset = %lu (0x%lx) (-> %p)\n"
            "%S   Length = %lu (0x%lx)\n"
            "%S   Format = %lu (%s)\n",
            PLP, Entry,
            PLP, SxspDbgSectionIdToNtString(Entry->Id), Entry->Id,
            PLP, Entry->Offset, Entry->Offset, SectionData,
            PLP, Entry->Length, Entry->Length,
            PLP, Entry->Format, pszFormat);
    }
    else
    {
        ::FusionpDbgPrintEx(
            Level,
            "%S%7lu | %Z (%s)\n",
            PLP, Entry->Id, SxspDbgSectionIdToNtString(Entry->Id), pszFormat);
    }
}

VOID
SxspDbgPrintActivationContextDataExtendedTocHeader(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffNewPrefix;
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry = NULL;
    ULONG i;

    if (PLP == NULL)
        PLP = L"";

    //
    // ISSUE: jonwis 3/7/2002
    // - Again , this is really -really- poor practice.  Why make our own prefix when
    //   we can abuse the prefix buffer (stash the prefix depth, work, reset depth)
    // - And, the .Win32Append(L"", 3) pattern strikes again.
    //
    if (Data->FirstEntryOffset != NULL)
    {
        buffNewPrefix.Win32Assign(PLP, ::wcslen(PLP));
        buffNewPrefix.Win32Append(L"   ", 3);
        Entry = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
    }

    ::FusionpDbgPrintEx(
        Level,
        "%SACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER %p\n"
        "%S   HeaderSize = %d\n"
        "%S   EntryCount = %d\n"
        "%S   FirstEntryOffset = %d (->%p)\n"
        "%S   Flags = 0x%08lx\n",
        PLP, Data,
        PLP, Data->HeaderSize,
        PLP, Data->EntryCount,
        PLP, Data->FirstEntryOffset, Entry,
        PLP, Data->Flags);


    if (Entry != NULL)
    {
        for (i=0; i<Data->EntryCount; i++)
            ::SxspDbgPrintActivationContextDataExtendedTocEntry(
                Level,
                fFull,
                Base,
                &Entry[i],
                buffNewPrefix);
    }
}

VOID
SxspDbgPrintActivationContextDataExtendedTocEntry(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffNewPrefix;
    CSmallStringBuffer buffFormattedGUID;
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = NULL;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->TocOffset != 0)
    {
        buffNewPrefix.Win32Assign(PLP, ::wcslen(PLP));
        buffNewPrefix.Win32Append(L"   ", 3);
        Toc = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Base) + Entry->TocOffset);
    }

    ::SxspFormatGUID(Entry->ExtensionGuid, buffFormattedGUID);

    ::FusionpDbgPrintEx(
        Level,
        "%SACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY %p\n"
        "%S   ExtensionGuid = %S\n"
        "%S   TocOffset = %d (-> %p)\n"
        "%S   Length = %d\n",
        PLP, Entry,
        PLP, static_cast<PCWSTR>(buffFormattedGUID),
        PLP, Entry->Length);

    if (Toc != NULL)
        ::SxspDbgPrintActivationContextDataTocHeader(Level, fFull, Base, Toc, buffNewPrefix);
}

VOID
SxspDbgPrintActivationContextDataExtendedTocSections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER Data,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffNewPrefix;
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry = NULL;
    ULONG i;

    if (PLP == NULL)
        PLP = L"";

    if (Data->FirstEntryOffset != NULL)
    {
        buffNewPrefix.Win32Assign(PLP, ::wcslen(PLP));
        buffNewPrefix.Win32Append(L"   ", 3);
        Entry = (PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY) (((ULONG_PTR) Base) + Data->FirstEntryOffset);
    }

    if (Entry != NULL)
    {
        for (i=0; i<Data->EntryCount; i++)
            ::SxspDbgPrintActivationContextDataExtendedTocEntrySections(
                Level,
                fFull,
                Base,
                &Entry[i],
                buffNewPrefix);
    }
}

VOID
SxspDbgPrintActivationContextDataExtendedTocEntrySections(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_DATA Base,
    PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY Entry,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffNewPrefix;
    PCACTIVATION_CONTEXT_DATA_TOC_HEADER Toc = NULL;

    if (PLP == NULL)
        PLP = L"";

    if (Entry->TocOffset != 0)
    {
        //
        // ISSUE: jonwis 3/7/2002
        // - Sigh, again, why do this?  Why not assign from rbuffPLP, or abuse rbuffPLP?
        //
        buffNewPrefix.Win32Assign(PLP, ::wcslen(PLP));
        buffNewPrefix.Win32Append(L"   ", 3);
        Toc = (PCACTIVATION_CONTEXT_DATA_TOC_HEADER) (((ULONG_PTR) Base) + Entry->TocOffset);
    }

    if (Toc != NULL)
    {
        CSmallStringBuffer buffFormattedGUID;

        ::SxspFormatGUID(Entry->ExtensionGuid, buffFormattedGUID);
        ::FusionpDbgPrintEx(
            Level,
            "%SSections for extension GUID %S (Extended TOC entry %p)\n",
            PLP, static_cast<PCWSTR>(buffFormattedGUID), Entry);

        ::SxspDbgPrintActivationContextDataTocSections(Level, fFull, Base, Toc, &Entry->ExtensionGuid, buffNewPrefix);
    }
}

VOID
SxspDbgPrintActivationContextBinarySection(
    ULONG Level,
    bool fFull,
    PVOID Data,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    if (PLP == NULL)
        PLP = L"";

    ::FusionpDbgPrintEx(
        Level,
        "%SBinary section %p (%d bytes)\n",
        PLP, Data, Length);

    if (Length != 0)
    {
        CSmallStringBuffer buffNewPrefix;

        buffNewPrefix.Win32Assign(PLP, ::wcslen(PLP));
        buffNewPrefix.Win32Append(L"   ", 3);
        ::FusionpDbgPrintBlob(Level, Data, Length, buffNewPrefix);
    }
}

VOID
SxspDbgPrintActivationContextStringSection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    SIZE_T cchPLP = rbuffPLP.Cch();
    CSmallStringBuffer buffBriefOutput;
    CSmallStringBuffer buffFlags;
    SIZE_T cchBriefOutputKey = 3;

    PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY ElementList = NULL;
    PCACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE SearchStructure = NULL;
    PVOID UserData = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgStringSectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE, "Case Insensitive")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER, "In PseudoKey Order")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Data->ElementListOffset != 0)
        ElementList = (PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY) (((ULONG_PTR) Data) + Data->ElementListOffset);

    if (Data->SearchStructureOffset != 0)
        SearchStructure = (PCACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE) (((ULONG_PTR) Data) + Data->SearchStructureOffset);

    if (Data->UserDataOffset != 0)
        UserData = (PVOID) (((ULONG_PTR) Data) + Data->UserDataOffset);

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgStringSectionFlags), s_rgStringSectionFlags, buffFlags);

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_STRING_SECTION_HEADER %p\n"
            "%S   Magic = 0x%08lx\n"
            "%S   HeaderSize = %lu (0x%lx)\n"
            "%S   FormatVersion = %lu\n"
            "%S   DataFormatVersion = %u\n"
            "%S   Flags = 0x%08lx (%S)\n",
            PLP, Data,
            PLP, Data->Magic,
            PLP, Data->HeaderSize, Data->HeaderSize,
            PLP, Data->FormatVersion,
            PLP, Data->DataFormatVersion,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));

        ::FusionpDbgPrintEx(
            Level,
            "%S   ElementCount = %lu\n"
            "%S   ElementListOffset = %lu (0x%lx) (-> %p)\n"
            "%S   HashAlgorithm = %lu\n"
            "%S   SearchStructureOffset = %lu (0x%lx) (-> %p)\n"
            "%S   UserDataOffset = %lu (0x%lx) (-> %p)\n"
            "%S   UserDataSize = %lu (0x%lx)\n",
            PLP, Data->ElementCount,
            PLP, Data->ElementListOffset, Data->ElementListOffset, ElementList,
            PLP, Data->HashAlgorithm,
            PLP, Data->SearchStructureOffset, Data->SearchStructureOffset, SearchStructure,
            PLP, Data->UserDataOffset, Data->UserDataOffset, UserData,
            PLP, Data->UserDataSize, Data->UserDataSize);

        if (UserData != NULL)
        {
            ::FusionpDbgPrintEx(
                Level,
                "%S   User data at %p (%d bytes)\n",
                PLP, UserData, Data->UserDataSize);

            rbuffPLP.Win32Append(L"   ", 3);
            FusionpDbgPrintBlob(Level, UserData, Data->UserDataSize, rbuffPLP);
            rbuffPLP.Left(cchPLP);
            PLP = rbuffPLP;
        }
    }
    else
    {
        // let's figure out the brief output key size
        cchBriefOutputKey = 3;

        if (ElementList != NULL)
        {
            ULONG i;

            for (i=0; i<Data->ElementCount; i++)
            {
                SIZE_T cch = ElementList[i].KeyLength / sizeof(WCHAR);

                if (cch > cchBriefOutputKey)
                    cchBriefOutputKey = cch;
            }
        }

        if (cchBriefOutputKey > 64)
            cchBriefOutputKey = 64;

        // Abuse the brief output buffer temporarily...
        buffBriefOutput.Win32Assign(L"Key................................................................", // 64 dots
            cchBriefOutputKey);

        ::FusionpDbgPrintEx(
            Level,
            "%S%s string section (%lu entr%s; Flags: %S)\n"
            "%S   %S | Value\n",
            PLP, SectionName, Data->ElementCount, Data->ElementCount == 1 ? "y" : "ies", static_cast<PCWSTR>(buffFlags),
            PLP, static_cast<PCWSTR>(buffBriefOutput));
    }

    if (fFull && (SearchStructure != NULL))
    {
        PCACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET BucketTable = NULL;

        if (SearchStructure->BucketTableOffset != 0)
            BucketTable = (PCACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET) (((ULONG_PTR) Data) + SearchStructure->BucketTableOffset);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE %p\n"
            "%S      BucketTableEntryCount = %u\n"
            "%S      BucketTableOffset = %d (-> %p)\n",
            PLP, SearchStructure,
            PLP, SearchStructure->BucketTableEntryCount,
            PLP, SearchStructure->BucketTableOffset, BucketTable);

        if (BucketTable != NULL)
        {
            ULONG i;

            for (i=0; i<SearchStructure->BucketTableEntryCount; i++)
            {
                PLONG Entries = NULL;

                if (BucketTable[i].ChainOffset != 0)
                    Entries = (PLONG) (((ULONG_PTR) Data) + BucketTable[i].ChainOffset);

                ::FusionpDbgPrintEx(
                    Level,
                    "%S      ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET %p\n"
                    "%S         ChainCount = %u\n"
                    "%S         ChainOffset = %d (-> %p)\n",
                    PLP, &BucketTable[i],
                    PLP, BucketTable[i].ChainCount,
                    PLP, BucketTable[i].ChainOffset, Entries);

                if (Entries != NULL)
                {
                    ULONG j;

                    for (j=0; j<BucketTable[i].ChainCount; j++)
                    {
                        PVOID Entry = NULL;

                        if (Entries[j] != 0)
                            Entry = (PVOID) (((ULONG_PTR) Data) + Entries[j]);

                        ::FusionpDbgPrintEx(
                            Level,
                            "%S         Chain[%d] = %d (-> %p)\n",
                            PLP, j, Entries[j], Entry);
                    }
                }
            }
        }
    }

    if (ElementList != NULL)
    {
        ULONG i;

        for (i=0; i<Data->ElementCount; i++)
        {
            UNICODE_STRING s;
            PVOID EntryData = NULL;

            s.Length = static_cast<USHORT>(ElementList[i].KeyLength);
            s.MaximumLength = s.Length;
            s.Buffer = (PWSTR) (((ULONG_PTR) Data) + ElementList[i].KeyOffset);

            if (ElementList[i].Offset != 0)
                EntryData = (PVOID) (((ULONG_PTR) Data) + ElementList[i].Offset);

            if (fFull)
            {
                ::FusionpDbgPrintEx(
                    Level,
                    "%S   ACTIVATION_CONTEXT_STRING_SECTION_ENTRY #%d - %p\n"
                    "%S      AssemblyRosterIndex = %u\n"
                    "%S      PseudoKey = %u\n",
                    PLP, i, &ElementList[i],
                    PLP, ElementList[i].AssemblyRosterIndex,
                    PLP, ElementList[i].PseudoKey);

                ::FusionpDbgPrintEx(
                    Level,
                    "%S      String = \"%wZ\"\n"
                    "%S      Offset = %d (-> %p)\n"
                    "%S      Length = %u\n",
                    PLP, &s,
                    PLP, ElementList[i].Offset, EntryData,
                    PLP, ElementList[i].Length);
            }
            else
            {
                // Abuse the flags buffer so we can truncate the name as necessary...
                SIZE_T cchKey = s.Length / sizeof(WCHAR);
                PCWSTR pszKey = s.Buffer;

                if (cchKey > cchBriefOutputKey)
                {
                    pszKey += (cchKey - cchBriefOutputKey);
                    cchKey = cchBriefOutputKey;
                }

                buffFlags.Win32AssignFill(L' ', (cchBriefOutputKey - cchKey));
                buffFlags.Win32Append(pszKey, cchKey);

                buffBriefOutput.Win32ResizeBuffer(cchPLP + 3 + cchBriefOutputKey + 4, eDoNotPreserveBufferContents);

                buffBriefOutput.Win32Format(
                    L"%s   %s | ",
                    PLP, static_cast<PCWSTR>(buffFlags));
            }

            if (EntryData != NULL)
            {

                if (ExtensionGuid == NULL)
                {
                    rbuffPLP.Win32Append(L"      ", 6);

                    switch (SectionId)
                    {
                    default:
                        if (fFull)
                            ::FusionpDbgPrintBlob(Level, EntryData, ElementList[i].Length, rbuffPLP);
                        else
                            buffBriefOutput.Win32Append(
                                L"<untranslatable value>",
                                22);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION:
                        ::SxspDbgPrintAssemblyInformation(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION:
                        ::SxspDbgPrintDllRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION:
                        ::SxspDbgPrintWindowClassRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION:
                        ::SxspDbgPrintComProgIdRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;
                    }

                    rbuffPLP.Left(cchPLP);
                    PLP = rbuffPLP;
                }
            }

            if (!fFull)
                ::FusionpDbgPrintEx(Level, "%S\n", static_cast<PCWSTR>(buffBriefOutput));
        }
    }
}

VOID
SxspDbgPrintActivationContextGuidSection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Data,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    PCSTR SectionName,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    SIZE_T cchPLP = rbuffPLP.Cch();
    CSmallStringBuffer buffFlags;
    CSmallStringBuffer buffBriefOutput;

    PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY ElementList = NULL;
    PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE SearchStructure = NULL;
    PVOID UserData = NULL;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgGuidSectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER, "Inorder")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Data->ElementListOffset != 0)
        ElementList = (PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY) (((ULONG_PTR) Data) + Data->ElementListOffset);

    if (Data->SearchStructureOffset != 0)
        SearchStructure = (PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE) (((ULONG_PTR) Data) + Data->SearchStructureOffset);

    if (Data->UserDataOffset != 0)
        UserData = (PVOID) (((ULONG_PTR) Data) + Data->UserDataOffset);

    ::FusionpFormatFlags(Data->Flags, fFull, NUMBER_OF(s_rgGuidSectionFlags), s_rgGuidSectionFlags, buffFlags);

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_GUID_SECTION_HEADER %p\n"
            "%S   Magic = 0x%08lx\n"
            "%S   HeaderSize = %u\n"
            "%S   FormatVersion = %u\n"
            "%S   DataFormatVersion = %u\n"
            "%S   Flags = 0x%08lx (%S)\n",
            PLP, Data,
            PLP, Data->Magic,
            PLP, Data->HeaderSize,
            PLP, Data->FormatVersion,
            PLP, Data->DataFormatVersion,
            PLP, Data->Flags, static_cast<PCWSTR>(buffFlags));

        ::FusionpDbgPrintEx(
            Level,
            "%S   ElementCount = %u\n"
            "%S   ElementListOffset = %d (-> %p)\n"
            "%S   SearchStructureOffset = %d (-> %p)\n"
            "%S   UserDataOffset = %d (-> %p)\n"
            "%S   UserDataSize = %u\n",
            PLP, Data->ElementCount,
            PLP, Data->ElementListOffset, ElementList,
            PLP, Data->SearchStructureOffset, SearchStructure,
            PLP, Data->UserDataOffset, UserData,
            PLP, Data->UserDataSize);

        if (UserData != NULL)
        {
            ::FusionpDbgPrintEx(
                Level,
                "%S   User data at %p (%d bytes)\n",
                PLP, UserData, Data->UserDataSize);

            rbuffPLP.Win32Append(L"   ", 3);
            FusionpDbgPrintBlob(Level, UserData, Data->UserDataSize, rbuffPLP);
            rbuffPLP.Left(cchPLP);
            PLP = rbuffPLP;
        }
    }
    else
    {
        ::FusionpDbgPrintEx(
            Level,
            "%S%s guid section (%lu entr%s; Flags: %S)\n"
            "%S   Key................................... | Value\n",
            PLP, SectionName, Data->ElementCount, Data->ElementCount == 1 ? "y" : "ies", static_cast<PCWSTR>(buffFlags),
            PLP);
    }

    if (fFull && (SearchStructure != NULL))
    {
        PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET BucketTable = NULL;

        if (SearchStructure->BucketTableOffset != 0)
            BucketTable = (PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET) (((ULONG_PTR) Data) + SearchStructure->BucketTableOffset);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE %p\n"
            "%S      BucketTableEntryCount = %u\n"
            "%S      BucketTableOffset = %d (-> %p)\n",
            PLP, SearchStructure,
            PLP, SearchStructure->BucketTableEntryCount,
            PLP, SearchStructure->BucketTableOffset, BucketTable);

        if (BucketTable != NULL)
        {
            ULONG i;

            for (i=0; i<SearchStructure->BucketTableEntryCount; i++)
            {
                PLONG Entries = NULL;

                if (BucketTable[i].ChainOffset != 0)
                    Entries = (PLONG) (((ULONG_PTR) Data) + BucketTable[i].ChainOffset);

                ::FusionpDbgPrintEx(
                    Level,
                    "%S      ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET %p\n"
                    "%S         ChainCount = %u\n"
                    "%S         ChainOffset = %d (-> %p)\n",
                    PLP, &BucketTable[i],
                    PLP, BucketTable[i].ChainCount,
                    PLP, BucketTable[i].ChainOffset, Entries);

                if (Entries != NULL)
                {
                    ULONG j;

                    for (j=0; j<BucketTable[i].ChainCount; j++)
                    {
                        PVOID Entry = NULL;

                        if (Entries[j] != 0)
                            Entry = (PVOID) (((ULONG_PTR) Data) + Entries[j]);

                        ::FusionpDbgPrintEx(
                            Level,
                            "%S         Chain[%d] = %d (-> %p)\n",
                            PLP, j, Entries[j], Entry);
                    }
                }
            }
        }
    }

    if (ElementList != NULL)
    {
        ULONG i;
        CSmallStringBuffer buffFormattedGuid;

        for (i=0; i<Data->ElementCount; i++)
        {
            PVOID EntryData = NULL;

            ::SxspFormatGUID(ElementList[i].Guid, buffFormattedGuid);

            if (ElementList[i].Offset != 0)
                EntryData = (PVOID) (((ULONG_PTR) Data) + ElementList[i].Offset);

            if (fFull)
            {
                ::FusionpDbgPrintEx(
                    Level,
                    "%S   ACTIVATION_CONTEXT_GUID_SECTION_ENTRY #%d - %p\n"
                    "%S      Guid = %S\n"
                    "%S      AssemblyRosterIndex = %u\n",
                    PLP, i, &ElementList[i],
                    PLP, static_cast<PCWSTR>(buffFormattedGuid),
                    PLP, ElementList[i].AssemblyRosterIndex);

                ::FusionpDbgPrintEx(
                    Level,
                    "%S      Offset = %d (-> %p)\n"
                    "%S      Length = %u\n",
                    PLP, ElementList[i].Offset, EntryData,
                    PLP, ElementList[i].Length);
            }
            else
            {
                //
                // ISSUE: jonwis 3/7/2002
                // - Augh!  It's -like- .Win32FormatAppend, but it's NOT! %s will attempt to append
                //   ANSI charcacters, not UNICODE chars like what PLP points to!
                //
                buffBriefOutput.Win32ResizeBuffer(cchPLP + 3 + 38 + 4, eDoNotPreserveBufferContents);
                buffBriefOutput.Win32Format(L"%s   %38s | ", PLP, static_cast<PCWSTR>(buffFormattedGuid));
            }

            if (EntryData != NULL)
            {
                if (ExtensionGuid == NULL)
                {
                    //
                    // ISSUE: jonwis 3/7/2002
                    // - wcslen(L"  ") != 6
                    //
                    rbuffPLP.Win32Append(L"      ", 6);

                    switch (SectionId)
                    {
                    default:
                        ::FusionpDbgPrintBlob(Level, EntryData, ElementList[i].Length, rbuffPLP);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION:
                        ::SxspDbgPrintComServerRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION:
                        ::SxspDbgPrintComInterfaceRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION:
                        ::SxspDbgPrintTypeLibraryRedirection(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION) EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;

                    case ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES:
                        ::SxspDbgPrintCLRSurrogateTable(Level, fFull, Data, (PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE)EntryData, ElementList[i].Length, rbuffPLP, buffBriefOutput);
                        break;
                    }

                    rbuffPLP.Left(cchPLP);
                    PLP = rbuffPLP;
                }
            }

            if (!fFull)
                ::FusionpDbgPrintEx(Level, "%S\n", static_cast<PCWSTR>(buffBriefOutput));
        }
    }
}

VOID
SxspDbgPrintAssemblyInformation(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    UNICODE_STRING s2, s3, s5, strIdentity;
    CSmallStringBuffer buffManifestLastWriteTime;
    CSmallStringBuffer buffPolicyLastWriteTime;
    CSmallStringBuffer buffFlags;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgAssemblyInformationFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY, "Root Assembly")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_POLICY_APPLIED, "Policy Applied")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ASSEMBLY_POLICY_APPLIED, "Assembly Policy Applied")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_POLICY_APPLIED, "Root Policy Applied")
    };

    if (PLP == NULL)
        PLP = L"";

#define GET_STRING(_var, _elem) \
    if (Entry-> _elem ## Length != 0) \
    { \
        (_var).Length = (_var).MaximumLength = static_cast<USHORT>(Entry-> _elem ## Length); \
        (_var).Buffer = reinterpret_cast<PWSTR>(((LONG_PTR) Header) + Entry-> _elem ## Offset); \
    } \
    else \
    { \
        (_var).Length = (_var).MaximumLength = 0; \
        (_var).Buffer = NULL; \
        }

    GET_STRING(s2, ManifestPath);
    GET_STRING(s3, PolicyPath);
    GET_STRING(s5, AssemblyDirectoryName);

#undef GET_STRING

    // prepare data for print

    ::SxspFormatFileTime(Entry->ManifestLastWriteTime, buffManifestLastWriteTime);
    ::SxspFormatFileTime(Entry->PolicyLastWriteTime, buffPolicyLastWriteTime);

    ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgAssemblyInformationFlags), s_rgAssemblyInformationFlags, buffFlags);

    if (Entry->EncodedAssemblyIdentityOffset != 0)
    {
        strIdentity.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->EncodedAssemblyIdentityOffset);
        strIdentity.Length = static_cast<USHORT>(Entry->EncodedAssemblyIdentityLength);
        strIdentity.MaximumLength = static_cast<USHORT>(Entry->EncodedAssemblyIdentityLength);
    }
    else
    {
        strIdentity.Buffer = NULL;
        strIdentity.Length = 0;
        strIdentity.MaximumLength = 0;
    }

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION %p\n"
            "%S   Size = %lu\n"
            "%S   Flags = 0x%08lx (%S)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags));

        ::FusionpDbgPrintEx(
            Level,
            "%S   EncodedIdentity = %wZ\n",
            PLP, &strIdentity);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ManifestPathType = %lu\n"
            "%S   ManifestPath = \"%wZ\"\n",
            PLP, Entry->ManifestPathType,
            PLP, &s2);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ManifestLastWriteTime = %S\n",
            PLP, static_cast<PCWSTR>(buffManifestLastWriteTime));

        ::FusionpDbgPrintEx(
            Level,
            "%S   PolicyPathType = %lu\n"
            "%S   PolicyPath = \"%wZ\"\n"
            "%S   PolicyLastWriteTime = %S\n",
            PLP, Entry->PolicyPathType,
            PLP, &s3,
            PLP, static_cast<PCWSTR>(buffPolicyLastWriteTime));

        ::FusionpDbgPrintEx(
            Level,
            "%S   MetadataSatelliteRosterIndex = %lu\n"
            "%S   ManifestVersionMajor = %u\n"
            "%S   ManifestVersionMinor = %u\n",
            PLP, Entry->MetadataSatelliteRosterIndex,
            PLP, Entry->ManifestVersionMajor,
            PLP, Entry->ManifestVersionMinor);

        ::FusionpDbgPrintEx(
            Level,
            "%S   AssemblyDirectoryName = \"%wZ\"\n",
            PLP, &s5);
    }
    else
    {
        // abuse buffManifestLastWriteTime
        buffManifestLastWriteTime.Win32ResizeBuffer(((strIdentity.Length + s2.Length) / sizeof(WCHAR)) + 4, eDoNotPreserveBufferContents);
        buffManifestLastWriteTime.Win32Format(L"%wZ \"%wZ\"", &strIdentity, &s2);
        rbuffBriefOutput.Win32Append(buffManifestLastWriteTime);
    }
}

VOID
SxspDbgPrintDllRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT PathSegments = NULL;
    CSmallStringBuffer buffFlags;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgDllRedirectionFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME, "Includes Base Name")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT, "Omits Assembly Root")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND, "Req. EnvVar Expansion")
    };

    if (PLP == NULL)
        PLP = L"";

    if (Entry->PathSegmentOffset != 0)
        PathSegments = (PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT) (((ULONG_PTR) Header) + Entry->PathSegmentOffset);

    ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgDllRedirectionFlags), s_rgDllRedirectionFlags, buffFlags);

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_DLL_REDIRECTION %p\n"
            "%S   Size = %u\n"
            "%S   Flags = 0x%08lx (%S)\n"
            "%S   TotalPathLength = %u (%u chars)\n"
            "%S   PathSegmentCount = %u\n"
            "%S   PathSegmentOffset = %d (-> %p)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags),
            PLP, Entry->TotalPathLength, Entry->TotalPathLength / sizeof(WCHAR),
            PLP, Entry->PathSegmentCount,
            PLP, Entry->PathSegmentOffset, PathSegments);
    }
    else
        rbuffBriefOutput.Win32Append(L"\"", 1);

    if (PathSegments != NULL)
    {
        ULONG i;

        for (i=0; i<Entry->PathSegmentCount; i++)
        {
            PCWSTR pwch = NULL;
            UNICODE_STRING s;

            if (PathSegments[i].Offset != 0)
            {
                pwch = (PCWSTR) (((ULONG_PTR) Header) + PathSegments[i].Offset);

                s.MaximumLength = static_cast<USHORT>(PathSegments[i].Length);
                s.Length = static_cast<USHORT>(PathSegments[i].Length);
                s.Buffer = (PWSTR) pwch;
            }
            else
            {
                s.MaximumLength = 0;
                s.Length = 0;
                s.Buffer = NULL;
            }

            if (fFull)
            {
                ::FusionpDbgPrintEx(
                    Level,
                    "%S   ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT #%d - %p\n"
                    "%S      Length = %u (%u chars)\n"
                    "%S      Offset = %d (-> %p)\n"
                    "%S         \"%wZ\"\n",
                    PLP, i, &PathSegments[i],
                    PLP, PathSegments[i].Length, PathSegments[i].Length / sizeof(WCHAR),
                    PLP, PathSegments[i].Offset, pwch,
                    PLP, &s);
            }
            else
            {
                rbuffBriefOutput.Win32Append(s.Buffer, s.Length / sizeof(WCHAR));
            }
        }
    }

    if (!fFull)
    {
        rbuffBriefOutput.Win32Append(L"\" (Flags: ", 10);
        rbuffBriefOutput.Win32Append(buffFlags);
        rbuffBriefOutput.Win32Append(L")", 1);
    }
}

VOID
SxspDbgPrintWindowClassRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    UNICODE_STRING s1, s2;
    CSmallStringBuffer buffFlags;

    if (PLP == NULL)
        PLP = L"";

    //
    // ISSUE: jonwis 3/7/2002 - Ick.  Use initializers instead.  The compiler is smarter than you are.
    //
    memset(&s1, 0, sizeof(s1));
    memset(&s2, 0, sizeof(s2));

    ::FusionpFormatFlags(
        Entry->Flags,
        fFull,
        0, NULL,
        buffFlags);

    if (Entry->VersionSpecificClassNameOffset != 0)
    {
        s1.Length = static_cast<USHORT>(Entry->VersionSpecificClassNameLength);
        s1.MaximumLength = s1.Length;
        s1.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->VersionSpecificClassNameOffset);
    }

    if (Entry->DllNameOffset != 0)
    {
        s2.Length = static_cast<USHORT>(Entry->DllNameLength);
        s2.MaximumLength = s2.Length;
        s2.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->DllNameOffset);
    }

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION %p\n"
            "%S   Size = %u\n"
            "%S   Flags = 0x%08lx\n"
            "%S   VersionSpecificClassNameLength = %u (%u chars)\n"
            "%S   VersionSpecificClassNameOffset = %d (-> %p)\n"
            "%S      \"%wZ\"\n"
            "%S   DllNameLength = %u (%u chars)\n"
            "%S   DllNameOffset = %d (-> %p)\n"
            "%S      \"%wZ\"\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->VersionSpecificClassNameLength, Entry->VersionSpecificClassNameLength / sizeof(WCHAR),
            PLP, Entry->VersionSpecificClassNameOffset, s1.Buffer,
            PLP, &s1,
            PLP, Entry->DllNameLength, Entry->DllNameLength / sizeof(WCHAR),
            PLP, Entry->DllNameOffset, s2.Buffer,
            PLP, &s2);
    }
    else
    {
        // 
        // ISSUE: jonwis 3/7/2002 
        // - Use Win32FormatAppend or Win32AssignW tead. It's faster, better, cheaper.
        //
        rbuffBriefOutput.Win32Append(s1.Buffer, s1.Length / sizeof(WCHAR));
        rbuffBriefOutput.Win32Append(L" in ", 4);
        rbuffBriefOutput.Win32Append(s2.Buffer, s2.Length / sizeof(WCHAR));
        rbuffBriefOutput.Win32Append(L" (Flags: ", 9);
        rbuffBriefOutput.Win32Append(buffFlags);
        rbuffBriefOutput.Win32Append(L")", 1);
    }
}


VOID
SxspDbgPrintCLRSurrogateTable(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffGuid;
    UNICODE_STRING RuntimeVersion = RTL_CONSTANT_STRING(L"<No runtime version>");
    UNICODE_STRING TypeName = RTL_CONSTANT_STRING(L"<No type name>");

    if (PLP == NULL)
        PLP = L"";

    ::SxspFormatGUID(Entry->SurrogateIdent, buffGuid);

    if (Entry->VersionOffset != 0)
    {
        RuntimeVersion.MaximumLength = RuntimeVersion.Length = static_cast<USHORT>(Entry->VersionLength);
        RuntimeVersion.Buffer = (PWSTR)(((ULONG_PTR)Entry) + Entry->VersionOffset);
    }

    if (Entry->TypeNameOffset != 0)
    {
        TypeName.MaximumLength = TypeName.Length = static_cast<USHORT>(Entry->TypeNameLength);
        TypeName.Buffer = (PWSTR)(((ULONG_PTR)Entry) + Entry->TypeNameOffset);
    }

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_CLR_INTEROP %p\n"
            "%S   Size = %u\n"
            "%S   Flags = 0x%08lx\n"
            "%S   SurrogateIdent = %S\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, static_cast<PCWSTR>(buffGuid));

        ::FusionpDbgPrintEx(
            Level,
            "%S   Typename [Offset %u (-> %p), Length %u] = \"%wZ\"\n"
            "%S   RuntimeVersion [Offset %u (-> %p), Length %u] = \"%wZ\"\n",
            PLP, Entry->TypeNameOffset, TypeName.Buffer, Entry->TypeNameLength, &TypeName,
            PLP, Entry->VersionOffset, RuntimeVersion.Buffer, Entry->VersionLength, &RuntimeVersion
            );
    }
    else
    {
        rbuffBriefOutput.Win32Append(buffGuid);
        rbuffBriefOutput.Win32Append(L" runtime: '", NUMBER_OF(L" runtime: '")-1);
        rbuffBriefOutput.Win32Append(&RuntimeVersion);
        rbuffBriefOutput.Win32Append(L"' typename: '", NUMBER_OF(L"' typename: '")-1);
        rbuffBriefOutput.Win32Append(&TypeName);
        rbuffBriefOutput.Win32Append(L"'", 1);
    }
    
}


VOID
SxspDbgPrintComServerRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffConfiguredClsid;
    CSmallStringBuffer buffImplementedClsid;
    CSmallStringBuffer buffReferenceClsid;
    CSmallStringBuffer buffTypeLibraryId;
    CSmallStringBuffer buffThreadingModel;
    UNICODE_STRING s;
    UNICODE_STRING progid;

    if (PLP == NULL)
        PLP = L"";

    memset(&s, 0, sizeof(s));

    ::SxspFormatGUID(Entry->ReferenceClsid, buffReferenceClsid);
    ::SxspFormatGUID(Entry->ConfiguredClsid, buffConfiguredClsid);
    ::SxspFormatGUID(Entry->ImplementedClsid, buffImplementedClsid);

    if (Entry->TypeLibraryId == GUID_NULL)
        buffTypeLibraryId.Win32Assign(L"<none>", 6);
    else
        ::SxspFormatGUID(Entry->TypeLibraryId, buffTypeLibraryId);

    ::SxspFormatThreadingModel(Entry->ThreadingModel, buffThreadingModel);

    if (Entry->ModuleOffset != 0)
    {
        s.Length = static_cast<USHORT>(Entry->ModuleLength);
        s.MaximumLength = s.Length;
        s.Buffer = (PWSTR) (((ULONG_PTR) Header) + Entry->ModuleOffset);
    }

    if (Entry->ProgIdOffset != 0)
    {
        progid.Length = static_cast<USHORT>(Entry->ProgIdLength);
        progid.MaximumLength = progid.Length;
        progid.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->ProgIdOffset);
    }
    else
    {
        progid.Length = 0;
        progid.MaximumLength = 0;
        progid.Buffer = NULL;
    }

    if (fFull)
    {
        PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM ShimData = NULL;

        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION %p\n"
            "%S   Size = %u\n"
            "%S   Flags = 0x%08lx\n"
            "%S   ThreadingModel = %u (%S)\n"
            "%S   ReferenceClsid = %S\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->ThreadingModel, static_cast<PCWSTR>(buffThreadingModel),
            PLP, static_cast<PCWSTR>(buffReferenceClsid));

        ::FusionpDbgPrintEx(
            Level,
            "%S   ConfiguredClsid = %S\n"
            "%S   ImplementedClsid = %S\n"
            "%S   TypeLibraryId = %S\n"
            "%S   ModuleLength = %u (%u chars)\n"
            "%S   ModuleOffset = %d (-> %p)\n"
            "%S      \"%wZ\"\n",
            PLP, static_cast<PCWSTR>(buffConfiguredClsid),
            PLP, static_cast<PCWSTR>(buffImplementedClsid),
            PLP, static_cast<PCWSTR>(buffTypeLibraryId),
            PLP, Entry->ModuleLength, Entry->ModuleLength / sizeof(WCHAR),
            PLP, Entry->ModuleOffset, s.Buffer,
            PLP, &s);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ProgIdLength = %lu\n"
            "%S   ProgIdOffset = %ld (-> %p)\n"
            "%S      \"%wZ\"\n",
            PLP, Entry->ProgIdLength,
            PLP, Entry->ProgIdOffset, progid.Buffer,
            PLP, &progid);

        if (Entry->ShimDataOffset != 0)
            ShimData = (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM) (((ULONG_PTR) Entry) + Entry->ShimDataOffset);

        ::FusionpDbgPrintEx(
            Level,
            "%S   ShimDataLength = %lu\n"
            "%S   ShimDataOffset = %ld (-> %p)\n",
            PLP, Entry->ShimDataLength,
            PLP, Entry->ShimDataOffset, ShimData);

        if (ShimData != NULL)
        {
            ::FusionpDbgPrintEx(
                Level,
                "%S      Size = %lu\n"
                "%S      Flags = 0x%08lx\n"
                "%S      Type = %lu\n",
                PLP, ShimData->Size,
                PLP, ShimData->Flags,
                PLP, ShimData->Type);

            if (ShimData->ModuleOffset != 0)
            {
                s.Buffer = (PWSTR) (((ULONG_PTR) Header) + ShimData->ModuleOffset);
                s.Length = (USHORT) ShimData->ModuleLength;
                s.MaximumLength = (USHORT) ShimData->ModuleLength;
            }
            else
            {
                s.Buffer = NULL;
                s.Length = 0;
                s.MaximumLength = 0;
            }

            ::FusionpDbgPrintEx(
                Level,
                "%S      ModuleLength = %lu\n"
                "%S      ModuleOffset = %lu (-> %p)\n"
                "%S         \"%wZ\"\n",
                PLP, ShimData->ModuleLength,
                PLP, ShimData->ModuleOffset, s.Buffer,
                PLP, &s);

            if (ShimData->TypeOffset != 0)
            {
                s.Buffer = (PWSTR) (((ULONG_PTR) ShimData) + ShimData->TypeOffset);
                s.Length = (USHORT) ShimData->TypeLength;
                s.MaximumLength = (USHORT) ShimData->TypeLength;
            }
            else
            {
                s.Buffer = NULL;
                s.Length = 0;
                s.MaximumLength = 0;
            }

            ::FusionpDbgPrintEx(
                Level,
                "%S      TypeLength = %lu\n"
                "%S      TypeOffset = %lu (-> %p)\n"
                "%S         \"%wZ\"\n",
                PLP, ShimData->TypeLength,
                PLP, ShimData->TypeOffset, s.Buffer,
                PLP, &s);

            if (ShimData->ShimVersionOffset != 0)
            {
                s.Buffer = (PWSTR) (((ULONG_PTR) ShimData) + ShimData->ShimVersionOffset);
                s.Length = (USHORT) ShimData->ShimVersionLength;
                s.MaximumLength = (USHORT) ShimData->ShimVersionLength;
            }
            else
            {
                s.Buffer = NULL;
                s.Length = 0;
                s.MaximumLength = 0;
            }

            ::FusionpDbgPrintEx(
                Level,
                "%S      ShimVersionLength = %lu\n"
                "%S      ShimVersionOffset = %lu (-> %p)\n"
                "%S         \"%wZ\"\n",
                PLP, ShimData->ShimVersionLength,
                PLP, ShimData->ShimVersionOffset, s.Buffer,
                PLP, &s);
        }
    }
    else
    {
        rbuffBriefOutput.Win32Append(buffConfiguredClsid);

        rbuffBriefOutput.Win32Append(L" ", 1);
        rbuffBriefOutput.Win32Append(s.Buffer, s.Length / sizeof(WCHAR));
        if (progid.Length != 0)
        {
            rbuffBriefOutput.Win32Append(L" progid: ", 9);
            rbuffBriefOutput.Win32Append(progid.Buffer, progid.Length / sizeof(WCHAR));
        }
    }

}

VOID
FusionpDbgPrintStringInUntruncatedChunks(
    ULONG   Level,
    PCWSTR  String,
    SIZE_T  Length
    )
//
// in pieces so it does not get truncated by DbgPrint (or we could use OutputDebugString, which
// does this same work)
//
{
    if (!::FusionpDbgWouldPrintAtFilterLevel(Level))
        return;
    while (Length != 0)
    {
        SIZE_T ShortLength = ((Length > 128) ? 128 : Length);

        CUnicodeString UnicodeString(String, ShortLength);
        ::FusionpDbgPrintEx(Level, "%wZ", &UnicodeString);

        Length -= ShortLength;
        String += ShortLength;
    }
}

VOID
FusionpDbgPrintStringInUntruncatedChunks(
    ULONG Level,
    const CBaseStringBuffer &rbuff
    )
{
    if (!::FusionpDbgWouldPrintAtFilterLevel(Level))
        return;

    FusionpDbgPrintStringInUntruncatedChunks(Level, rbuff, rbuff.Cch());
}

VOID
SxspDbgPrintTypeLibraryRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    if (!::FusionpDbgWouldPrintAtFilterLevel(Level))
        return;

    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buff;

    UNICODE_STRING Name = RTL_CONSTANT_STRING(L"");
    UNICODE_STRING HelpDir = RTL_CONSTANT_STRING(L"");
    ACTIVATION_CONTEXT_DATA_TYPE_LIBRARY_VERSION Version = { 0 };

    if (!buff.Win32ResizeBuffer(4096, eDoNotPreserveBufferContents))
        return;

#if 1
#define GET_STRING(ntstr, struc, struc_size, offset_field, length_field, base) \
    do { if (RTL_CONTAINS_FIELD((struc), (struc_size), offset_field) \
          && RTL_CONTAINS_FIELD((struc), (struc_size), length_field) \
          && (struc)->offset_field != 0  \
          && (struc)->length_field != 0) \
    { \
        (ntstr).Length = static_cast<USHORT>(struc->length_field - sizeof((ntstr).Buffer[0])); \
        (ntstr).Buffer = const_cast<PWSTR>(reinterpret_cast<PCWSTR>(struc->offset_field + reinterpret_cast<PCBYTE>(base))); \
    } } while(0)

    GET_STRING(Name, Entry, Entry->Size, NameOffset, NameLength, Header);
    GET_STRING(HelpDir, Entry, Entry->Size, HelpDirOffset, HelpDirLength, Entry);

#undef GET_STRING

#else

    if (RTL_CONTAINS_FIELD(Entry, Entry->Size, NameLength)
        && RTL_CONTAINS_FIELD(Entry, Entry->Size, NameOffset)
        && Entry->NameOffset != 0
        )
    {
        Name.Length = static_cast<USHORT>(Entry->NameLength);
        Name.Buffer = const_cast<PWSTR>(reinterpret_cast<PCWSTR>(Entry->NameOffset + reinterpret_cast<PCBYTE>(Header)));
    }

    if (RTL_CONTAINS_FIELD(Entry, Entry->Size, HelpDirLength)
        && RTL_CONTAINS_FIELD(Entry, Entry->Size, HelpDirOffset)
        && Entry->HelpDirOffset != 0
        )
    {
        HelpDir.Length = static_cast<USHORT>(Entry->HelpDirLength);
        HelpDir.Buffer = const_cast<PWSTR>(reinterpret_cast<PCWSTR>(Entry->HelpDirOffset + reinterpret_cast<PCBYTE>(Entry)));
    }

#endif

    if (RTL_CONTAINS_FIELD(Entry, Entry->Size, Version))
        Version = Entry->Version;

    if (!buff.Win32Format(
        L"%SACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION %p\n"
        L"%S   Size = 0x%lx\n"
        L"%S   Flags = 0x%lx\n"
        L"%S   Name = %wZ (offset 0x%lx + %p = %p)\n"
        L"%S   HelpDir = %wZ (offset 0x%lx + %p = %p)\n"
        L"%S   Version = 0x%lx.%lx\n",
        PLP, Entry,
        PLP, static_cast<ULONG>(Entry->Size),
        PLP, static_cast<ULONG>(Entry->Flags),
        PLP, &Name, static_cast<ULONG>(Entry->NameOffset), static_cast<PCVOID>(Header), static_cast<PCVOID>(Name.Buffer),
        PLP, &HelpDir, static_cast<ULONG>(Entry->HelpDirOffset), static_cast<PCVOID>(Entry), static_cast<PCVOID>(HelpDir.Buffer),
        PLP, static_cast<ULONG>(Version.Major), static_cast<ULONG>(Version.Minor)
        ))
        return;

    ::FusionpDbgPrintStringInUntruncatedChunks(Level, buff);
}

VOID
SxspDbgPrintComProgIdRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_STRING_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
//    CSmallStringBuffer buffFlags;
    CSmallStringBuffer buffClsid;
    const GUID *pcguid = NULL;

    if (Entry->ConfiguredClsidOffset != 0)
    {
        pcguid = (const GUID *) (((ULONG_PTR) Header) + Entry->ConfiguredClsidOffset);
        ::SxspFormatGUID(*pcguid, buffClsid);
    }

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION %p\n"
            "%S   Size = %lu (0x%lx)\n"
            "%S   Flags = 0x%08lx\n"
            "%S   ConfiguredClsidOffset = %lu (-> %p)\n"
            "%S      %S\n",
            PLP, Entry,
            PLP, Entry->Size, Entry->Size,
            PLP, Entry->Flags,
            PLP, Entry->ConfiguredClsidOffset, pcguid,
            PLP, static_cast<PCWSTR>(buffClsid));
    }
    else
    {
        rbuffBriefOutput.Win32Append(buffClsid);
    }
}

VOID
SxspDbgPrintComInterfaceRedirection(
    ULONG Level,
    bool fFull,
    PCACTIVATION_CONTEXT_GUID_SECTION_HEADER Header,
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Entry,
    SIZE_T Length,
    CBaseStringBuffer &rbuffPLP,
    CBaseStringBuffer &rbuffBriefOutput
    )
{
    PCWSTR PLP = rbuffPLP;
    CSmallStringBuffer buffProxyStubClsid32;
    CSmallStringBuffer buffBaseInterface;
    CSmallStringBuffer buffFlags;
    CSmallStringBuffer buffTypeLibraryId;
    UNICODE_STRING s;

    static const FUSION_FLAG_FORMAT_MAP_ENTRY s_rgComInterfaceFlags[] =
    {
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_NUM_METHODS_VALID, "NumMethods Valid")
        DEFINE_FUSION_FLAG_FORMAT_MAP_ENTRY(ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_BASE_INTERFACE_VALID, "BaseInterface Valid")
    };

    if (PLP == NULL)
        PLP = L"";

    memset(&s, 0, sizeof(s));

    ::SxspFormatGUID(Entry->ProxyStubClsid32, buffProxyStubClsid32);
    ::SxspFormatGUID(Entry->BaseInterface, buffBaseInterface);

    ::FusionpFormatFlags(Entry->Flags, fFull, NUMBER_OF(s_rgComInterfaceFlags), s_rgComInterfaceFlags, buffFlags);

    if (Entry->TypeLibraryId == GUID_NULL)
        buffTypeLibraryId.Win32Assign(L"<none>", 6);
    else
        ::SxspFormatGUID(Entry->TypeLibraryId, buffTypeLibraryId);

    if (Entry->NameOffset != 0)
    {
        s.Length = static_cast<USHORT>(Entry->NameLength);
        s.MaximumLength = s.Length;
        s.Buffer = (PWSTR) (((ULONG_PTR) Entry) + Entry->NameOffset);
    }

    if (fFull)
    {
        ::FusionpDbgPrintEx(
            Level,
            "%SACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION %p\n"
            "%S   Size = %lu\n"
            "%S   Flags = 0x%08lx (%S)\n",
            PLP, Entry,
            PLP, Entry->Size,
            PLP, Entry->Flags, static_cast<PCWSTR>(buffFlags));

        ::FusionpDbgPrintEx(
            Level,
            "%S   ProxyStubClsid32 = %S\n"
            "%S   NumMethods = %lu\n"
            "%S   TypeLibraryId = %S\n",
            PLP, static_cast<PCWSTR>(buffProxyStubClsid32),
            PLP, Entry->NumMethods,
            PLP, static_cast<PCWSTR>(buffTypeLibraryId));

        ::FusionpDbgPrintEx(
            Level,
            "%S   BaseInterface = %S\n"
            "%S   NameLength = %lu (%u chars)\n"
            "%S   NameOffset = %lu (-> %p)\n",
            PLP, static_cast<PCWSTR>(buffBaseInterface),
            PLP, Entry->NameLength, (Entry->NameLength / sizeof(WCHAR)),
            PLP, Entry->NameOffset, s.Buffer);

        ::FusionpDbgPrintEx(
            Level,
            "%S      \"%wZ\"\n",
            PLP, &s);
    }
    else
    {
        rbuffBriefOutput.Win32Append(buffProxyStubClsid32);
        rbuffBriefOutput.Win32Append(L" ", 1);
        rbuffBriefOutput.Win32Append(s.Buffer, s.Length / sizeof(WCHAR));
    }
}

VOID
SxspDbgPrintInstallSourceInfo(
    ULONG Level,
    bool fFull,
    PSXS_INSTALL_SOURCE_INFO Info,
    CBaseStringBuffer &rbuffPLP
    )
{
    PCWSTR PLP = rbuffPLP;
    if ( !PLP ) PLP = L"SXS.DLL:";
    if ( !Info )
    {
        ::FusionpDbgPrintEx( Level, "%S InstallationInfo is null!\n", PLP );
    }
    else
    {
        DWORD dwFlags = Info->dwFlags;

        ::FusionpDbgPrintEx(
            Level,
            "%S InstallationInfo at 0x%08x - size = %d\n",
            "%S   Flag set: %s catalog, %s codebase, %s prompt, %s in setup mode\n"
            "%S   Codebase Name: %ls\n"
            "%S   Prompt: %ls\n",
            PLP, Info, Info->cbSize,
            PLP,
                dwFlags & SXSINSTALLSOURCE_HAS_CATALOG ? "has" : "no",
                dwFlags & SXSINSTALLSOURCE_HAS_CODEBASE ? "has" : "no",
                dwFlags & SXSINSTALLSOURCE_HAS_PROMPT ? "has" : "no",
                dwFlags & SXSINSTALLSOURCE_INSTALLING_SETUP ? "is" : "not",
            PLP, Info->pcwszCodebaseName,
            PLP, Info->pcwszPromptOnRefresh);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\dllredir.h ===
#pragma once

/*-----------------------------------------------------------------------------
Dynamic Link Library Redirection (contributor)

The dllredir contributor is unique in that it does most of the work
for installation.
-----------------------------------------------------------------------------*/

#include "fusionarray.h"
#include "fusionhandle.h"

class CDllRedir
{
public:

    CDllRedir::CDllRedir() : m_SSGenContext(NULL), m_pRunOnce(NULL) { }
    ~CDllRedir() { }

    VOID ContributorCallback(PACTCTXCTB_CALLBACK_DATA Data);

    BOOL
    BeginInstall(
        PACTCTXCTB_CALLBACK_DATA Data
        );

    BOOL
    InstallManifest(
        DWORD dwManifestOperationFlags,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
        );

    BOOL
    InstallCatalog(
        DWORD dwManifestOperationFlags,
        const CBaseStringBuffer &SourceManifest,
        const CBaseStringBuffer &DestinationManifest,
        PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
        );

    BOOL
    InstallFile(
        PACTCTXCTB_CALLBACK_DATA Data,
        const CBaseStringBuffer &FileNameBuffer
        );

    BOOL
    AttemptInstallPolicies(
        const CBaseStringBuffer &m_strTempRootSlash,
        const CBaseStringBuffer &moveDestination,
        const BOOL fReplaceExisting,
        OUT BOOL &fFoundPolicesToInstall        
        );

    BOOL
    EndInstall(
        PACTCTXCTB_CALLBACK_DATA Data
        );

    PSTRING_SECTION_GENERATION_CONTEXT m_SSGenContext;

    // these are files the callback said it would copy itself,
    // we check that this happens before EndAssemblyInstall does the
    // rest of its work
    typedef CFusionArray<CFusionFilePathAndSize> CQueuedFileCopies;
    CQueuedFileCopies m_queuedFileCopies;

    // For partial atomicity, we install everything here, which is
    // like \Winnt\SideBySide\{Guid} and then to commit we enumerate
    // it and move all the directories in it up one level, and delete it
    CStringBuffer m_strTempRootSlash;

    // This must be seperately heap allocated.
    // It should delete itself in Close or Cancel.
    CRunOnceDeleteDirectory *m_pRunOnce;

    struct _ContributorCallbackLocalsStruct
    {
        CSmallStringBuffer DllUnderSystem32;
        CSmallStringBuffer FileNameBuffer;
        CSmallStringBuffer LoadFromBuffer;
        CSmallStringBuffer HashValueBuffer;
#ifdef _WIN64
        CSmallStringBuffer DllUnderSyswow64;
#endif
    } ContributorCallbackLocals;

private:
    CDllRedir(const CDllRedir &);
    void operator =(const CDllRedir &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\dllredir.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    dllredir.cpp

Abstract:

    Activation context section contributor for the DLL Redirection section.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    Jay Krell (a-JayK, JayKrell) April 2000        install support
--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "fusioneventlog.h"
#include "sxsinstall.h"
#include "dllredir.h"
#include "cteestream.h"
#include "sxspath.h"
#include "hashfile.h"
#if FUSION_PRECOMPILED_MANIFEST
#define PRECOMPILED_MANIFEST_EXTENSION L".precompiled"
#include "pcmwriterstream.h"
#endif
#include "sxsexceptionhandling.h"
#include "strongname.h"
#include "csecuritymetadata.h"
#include "cstreamtap.h"

//
// We need to hook this up to the setuplog file functionality.
//
#define SxspInstallPrint FusionpDbgPrint

#define POST_WHISTLER_BETA1 0

//
// This is the default hash algorithm for manifests.  If no algorithm
// is specified with hashalg="foo", then it's SHA1.
//
#define FUSION_DEFAULT_HASH_ALGORITHM (CALG_SHA1)


/*-----------------------------------------------------------------------------*/
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(sourceName);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(loadFrom);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(hash);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(hashalg);

typedef struct _DLL_REDIRECTION_CONTEXT
{
    _DLL_REDIRECTION_CONTEXT() { }
} DLL_REDIRECTION_CONTEXT, *PDLL_REDIRECTION_CONTEXT;

typedef struct _DLL_REDIRECTION_ENTRY
{
    _DLL_REDIRECTION_ENTRY() :
        AssemblyPathIsLoadFrom(false),
        PathIncludesBaseName(false),
        SystemDefaultRedirectedSystem32Dll(false)
        { }
    CStringBuffer AssemblyPathBuffer;
    bool AssemblyPathIsLoadFrom;        // Set to true when a <file name="x" loadfrom="%windir%\system32\"/> is found
    bool PathIncludesBaseName;          // Set to true when a <file name="x" loadfrom="%windir%\x.dll"/> is found
    bool SystemDefaultRedirectedSystem32Dll;
    CStringBuffer FileNameBuffer;
private:
    _DLL_REDIRECTION_ENTRY(const _DLL_REDIRECTION_ENTRY &);
    void operator =(const _DLL_REDIRECTION_ENTRY &);
} DLL_REDIRECTION_ENTRY, *PDLL_REDIRECTION_ENTRY;

/*-----------------------------------------------------------------------------*/

VOID
__fastcall
SxspDllRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();
    CDllRedir* pThis = NULL;

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;
        if (Data->Header.ActCtxGenContext == NULL)
        {
            IFALLOCFAILED_EXIT(pThis = new CDllRedir);
            Data->Header.ActCtxGenContext = pThis;
        }

        // fall through
    default:
        pThis = reinterpret_cast<CDllRedir*>(Data->Header.ActCtxGenContext);
        pThis->ContributorCallback(Data);
        if (Data->Header.Reason == ACTCTXCTB_CBREASON_ACTCTXGENENDED)
            FUSION_DELETE_SINGLETON(pThis);
        break;
    }
Exit:
    ;
}

/*-----------------------------------------------------------------------------
This function is called on Win9x if we crash during an install, on the
next login. It deletes temporary files/directories.
-----------------------------------------------------------------------------*/

VOID
CALLBACK
SxspRunDllDeleteDirectory(HWND hwnd, HINSTANCE hinst, PSTR lpszCmdLine, int nCmdShow)
{
    FN_TRACE_SMART_TLS();
    CStringBuffer buffer;
    if (buffer.Win32Assign(lpszCmdLine, ::strlen(lpszCmdLine)))
    {
        SxspDeleteDirectory(buffer);
    }
}

/*-----------------------------------------------------------------------------
This function is called on Nt if we crash during an install, on the
next login. It deletes temporary files/directories.
-----------------------------------------------------------------------------*/

VOID
CALLBACK
SxspRunDllDeleteDirectoryW(HWND hwnd, HINSTANCE hinst, PWSTR lpszCmdLine, int nCmdShow)
{
    FN_TRACE_SMART_TLS();
    CSmallStringBuffer buffer;
    if (buffer.Win32Assign(lpszCmdLine, ::wcslen(lpszCmdLine)))
    {
        SxspDeleteDirectory(buffer);
    }
}


/*-----------------------------------------------------------------------------
This function sets up state for an upcoming series of installs, installs
of assemblies/files.
-----------------------------------------------------------------------------*/

BOOL
CDllRedir::BeginInstall(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    const DWORD dwManifestOperationFlags = Data->Header.ManifestOperationFlags;
    const bool fTransactional  = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL) == 0;
    CSmallStringBuffer ManifestDirectory;

    if (!fTransactional)
    {
        //
        // m_strTempRootSlash is now actually the real root
        //
        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(m_strTempRootSlash));
        IFW32FALSE_EXIT(m_strTempRootSlash.Win32RemoveTrailingPathSeparators()); // CreateDirectory doesn't like them

        // create \winnt\WinSxs, must not delete even on failure
        if (::CreateDirectoryW(m_strTempRootSlash, NULL))
        {
            // We don't care if this fails.
            ::SetFileAttributesW(m_strTempRootSlash, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
        }
        else if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
        {
            goto Exit;
        }
    }
    else
    {
        CSmallStringBuffer uidBuffer;

        // Create the directory first, not the RunOnce value, in case the directory
        // already exists; we don't want to put it in the registry, then crash,
        // then end up deleting someone else's stuff.
        //
        // If we crash between creating the directory and setting the RunOnce value,
        // we do leak the directory. Darn. (You should be able to create/open
        // with delete on close/exit, then turn that off once you get far enough,
        // or in our case, never, and it should be applicable recursively..Win32
        // is not yet sufficient.)

        IFW32FALSE_EXIT(::SxspCreateWinSxsTempDirectory(m_strTempRootSlash, NULL, &uidBuffer, NULL));

        // ok, we created the directory, now make a note in the registry to delete it
        // upon login, if we crash

        IFALLOCFAILED_EXIT(m_pRunOnce = new CRunOnceDeleteDirectory);
        IFW32FALSE_EXIT(m_pRunOnce->Initialize(m_strTempRootSlash, &uidBuffer));
    }

    // create winnt\winsxs\manifests
    IFW32FALSE_EXIT(ManifestDirectory.Win32Assign(m_strTempRootSlash, m_strTempRootSlash.Cch()));
    IFW32FALSE_EXIT(ManifestDirectory.Win32AppendPathElement(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));

    if (CreateDirectoryW(ManifestDirectory, NULL))
    {
        // We don't care if this fails.
        ::SetFileAttributesW(ManifestDirectory, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
    }
    else if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
    {
        goto Exit;
    }

    IFW32FALSE_EXIT(m_strTempRootSlash.Win32Append(L"\\", 1));

    // fix it up..not sure this accomplishes anything..
    // if (!ActCtxGenCtx->m_AssemblyRootDirectoryBuffer.Win32Assign(m_strTempRootSlash))
    // {
    //     goto Exit;
    // }
    fSuccess = TRUE;
Exit:

    if (!fSuccess && fTransactional)
    {
        // rollback, which is not coincidentally identical to EndInstall aborting,
        // except that
        //   here RemoveDirectoryW would be sufficient, there SxspDeleteDirectory is needed
        //   here, we already know there is an error, and cleanup can't produce another
        //     there, they have extra logic to progagage errors
        //     we mask that by preserve LastError since we preserve it ourselves
        //       and ignore the return value
        const DWORD dwLastError = ::FusionpGetLastWin32Error();
        const DWORD dwManifestOperationFlagsSaved = Data->Header.ManifestOperationFlags;
        Data->Header.ManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ABORT;
        this->EndInstall(Data);
        Data->Header.ManifestOperationFlags = dwManifestOperationFlagsSaved; // our caller doesn't like us changing this
        ::FusionpSetLastWin32Error(dwLastError);
    }

    return fSuccess;
}

class CDllRedirAttemptInstallPolicies
{
public:
    CDllRedirAttemptInstallPolicies() { }
    ~CDllRedirAttemptInstallPolicies() { }

    CStringBuffer PoliciesRootPath;
    CStringBuffer PoliciesDestinationPath;
    WIN32_FIND_DATAW FindPolicyData;
};

BOOL
CDllRedir::AttemptInstallPolicies(
    const CBaseStringBuffer &strTempRootSlash,
    const CBaseStringBuffer &moveDestination,
    const BOOL fReplaceExisting,
    OUT BOOL &fFoundPolicesToInstall
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CFindFile FindPolicies;
    CSmartPtr<CDllRedirAttemptInstallPolicies> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    CStringBuffer &PoliciesRootPath = Locals->PoliciesRootPath;
    CStringBuffer &PoliciesDestinationPath = Locals->PoliciesDestinationPath;
    WIN32_FIND_DATAW &FindPolicyData = Locals->FindPolicyData;
    SIZE_T cchRootBaseLength = 0;
    SIZE_T cchDestinationBaseLength = 0;

    fFoundPolicesToInstall = FALSE;

    // This is %installpath%\policies, turn it into %installpath%\policies\*
    IFW32FALSE_EXIT(PoliciesRootPath.Win32Assign(strTempRootSlash));
    IFW32FALSE_EXIT(PoliciesRootPath.Win32AppendPathElement(POLICY_ROOT_DIRECTORY_NAME, NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1));
    IFW32FALSE_EXIT(PoliciesDestinationPath.Win32Assign(moveDestination));
    IFW32FALSE_EXIT(PoliciesDestinationPath.Win32AppendPathElement(POLICY_ROOT_DIRECTORY_NAME, NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1));

    bool fExist = false;
    IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY, PoliciesRootPath, fExist));
    if (!fExist)
    {
#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INFO,
            "SXS: %s() - No policies found (%ls not there), not attempting to install\n",
            __FUNCTION__,
            static_cast<PCWSTR>(PoliciesRootPath));
#endif
        fSuccess = TRUE;
        goto Exit;
    }

    fFoundPolicesToInstall = TRUE;

    // Ensure that policies root always exists!
    IFW32FALSE_EXIT(PoliciesDestinationPath.Win32RemoveTrailingPathSeparators());
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::CreateDirectoryW(PoliciesDestinationPath, NULL) ||
        (::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS));

    cchRootBaseLength = PoliciesRootPath.Cch();
    cchDestinationBaseLength = PoliciesDestinationPath.Cch();

    IFW32FALSE_EXIT(PoliciesRootPath.Win32AppendPathElement(L"*", 1));
    IFW32FALSE_EXIT(FindPolicies.Win32FindFirstFile(PoliciesRootPath, &FindPolicyData));

    do
    {
        if (::FusionpIsDotOrDotDot(FindPolicyData.cFileName))
            continue;

        if ((FindPolicyData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            continue;

        // Generate %installtemp%\policies\{thisfoundpolicy}
        PoliciesRootPath.Left(cchRootBaseLength);
        PoliciesDestinationPath.Left(cchDestinationBaseLength);
        IFW32FALSE_EXIT(PoliciesRootPath.Win32AppendPathElement(FindPolicyData.cFileName, ::wcslen(FindPolicyData.cFileName)));
        IFW32FALSE_EXIT(PoliciesDestinationPath.Win32AppendPathElement(FindPolicyData.cFileName, ::wcslen(FindPolicyData.cFileName)));

        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INFO,
            "SXS: %s():Found policy in staging area %ls\n\tMoving to %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(PoliciesRootPath),
            static_cast<PCWSTR>(PoliciesDestinationPath));

        //
        // Ensure that the target path exists
        //
        IFW32FALSE_ORIGINATE_AND_EXIT(
            ::FusionpCreateDirectories(PoliciesDestinationPath, PoliciesDestinationPath.Cch()) ||
            (::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS));

        //
        // Go copy files from the source path that we've consed up to the
        // target path that we've also consed up.  Unfortunately, SxspMoveFilesUnderDir
        // does not actually return the buffers to the state they were in before
        // the call (they leave a trailing slash), so we have to manually use the size
        // thingy above (Left(originalsize)) to avoid this.
        //
        IFW32FALSE_EXIT(SxspMoveFilesUnderDir(
            0,
            PoliciesRootPath,
            PoliciesDestinationPath,
            fReplaceExisting ? MOVEFILE_REPLACE_EXISTING : 0));
            
    }
    while(::FindNextFileW(FindPolicies, &FindPolicyData));
    
    if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(FindNextFileW);
        goto Exit;
    }
    
    ::SetLastError(ERROR_SUCCESS); // clear LastError
    IFW32FALSE_EXIT(FindPolicies.Win32Close());

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

class CDllRedirEndInstallLocals
{
public:
    CDllRedirEndInstallLocals() { }
    ~CDllRedirEndInstallLocals() { }

    CFusionDirectoryDifference directoryDifference;
    CStringBuffer tempStar; // also used for \winnt\winsxs\guid\foo
    WIN32_FIND_DATAW findData;
    CStringBuffer moveDestination; // \winnt\winsxs\foo
};

// NTRAID#NTBUG9 - 571863 - 2002/03/26 - xiaoyuw:
// this function has two simliar blocks about moving files and moving manifest/cat,
// it maybe replaced by SxspMoveFilesUnderDir  
//
BOOL
CDllRedir::EndInstall(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    /*
    1) Make sure all the queued copies have actually been done.
    2) Enumerate \winnt\winsxs\guid
        renaming each to be in \winnt\winsxs
        upon rename conflicts
            compare all the files in each (by size)
                output debug string if mismatch
                just leave temp if mismatch (will be cleaned up in common path)
                success either way
    3) delete temp; delete runonce value
    */
    // make sure all the queued copies have actually been done    
    const DWORD dwManifestOperationFlags = Data->Header.ManifestOperationFlags;
    const BOOL  fVerify          = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NO_VERIFY) == 0;
    const BOOL  fTransactional   = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL) == 0;
    const BOOL  fReplaceExisting = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING) != 0;
    const BOOL  fAbort           = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_ABORT) != 0;
    BOOL        fPoliciesExist   = FALSE;
    HashValidateResult HashCorrect = HashValidate_OtherProblems;
    CFileStream * pLogFileStream = NULL;

    //
    // It'd be nice to skip the heap alloc in the abort case, but that
    // doesn't fit easily with our mechanical patterns..
    //
    CSmartPtr<CDllRedirEndInstallLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));

    if (fAbort)
    {
        fSuccess = TRUE;
        goto Exit;
    }

    if (fVerify)
    {

        CQueuedFileCopies::ConstIterator i;
        for (i = m_queuedFileCopies.Begin() ; i != m_queuedFileCopies.End() ; ++i)
        {
            //
            // Only bother to check this if we're not in OS-setup mode.
            //
            if (i->m_bHasHashInfo)
            {
                IFW32FALSE_EXIT(::SxspCheckHashDuringInstall(i->m_bHasHashInfo, i->m_path, i->m_HashString, i->m_HashAlgorithm, HashCorrect));

                if (HashCorrect != HashValidate_Matches)
                {
                    ::FusionpDbgPrintEx(
                            FUSION_DBG_LEVEL_ERROR,
                            "SXS: %s : SxspCheckHashDuringInstall(file=%ls)\n",
                            __FUNCTION__,
                            static_cast<PCWSTR>(i->m_path)
                            );
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(FileHashDidNotMatchManifest, ERROR_SXS_FILE_HASH_MISMATCH);
                }
            }
            //
            // Otherwise, let's do the simple thing and just make sure the file made it
            //
            else
            {
                DWORD dwAttributes = ::GetFileAttributesW(i->m_path);
                if (dwAttributes == -1)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS: %s() GetFileAttributesW(%ls)\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(i->m_path));
                    TRACE_WIN32_FAILURE_ORIGINATION(GetFileAttributesW);
                    goto Exit;
                }
            }

        }
    }

    if (fTransactional)
    {
        CFusionDirectoryDifference &directoryDifference = Locals->directoryDifference;
        CFindFile findFile;
        CStringBuffer &tempStar = Locals->tempStar; // also used for \winnt\winsxs\guid\foo
        WIN32_FIND_DATAW &findData = Locals->findData;
        SIZE_T realRootSlashLength = 0; // length of "\winnt\winsxs\"
        SIZE_T tempRootSlashLength = 0; // length of "\winnt\winxsx\guid\"
        CStringBuffer &moveDestination = Locals->moveDestination; // \winnt\winsxs\foo

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(moveDestination));
        IFW32FALSE_EXIT(moveDestination.Win32EnsureTrailingPathSeparator());
        realRootSlashLength = moveDestination.Cch();

        // move dirs from "\winnt\winsxs\InstallTemp\123456\" to \winnt\winsxs\x86_bar_1000_0409\"
        IFW32FALSE_EXIT(tempStar.Win32Assign(m_strTempRootSlash, m_strTempRootSlash.Cch()));
        tempRootSlashLength = tempStar.Cch();
        IFW32FALSE_EXIT(tempStar.Win32Append(L"*", 1));
        IFW32FALSE_EXIT(findFile.Win32FindFirstFile(tempStar, &findData));

        do
        {
            // skip . and ..
            if (::FusionpIsDotOrDotDot(findData.cFileName))
                continue;

            // there shouldn't be any files, skip them
            if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY)
                continue;
            // skip manifests dir, do it at the second pass
            if (_wcsicmp(findData.cFileName, MANIFEST_ROOT_DIRECTORY_NAME) == 0) // in-casesensitive compare
                continue;
            if (_wcsicmp(findData.cFileName, POLICY_ROOT_DIRECTORY_NAME) == 0)
                continue;

            moveDestination.Left(realRootSlashLength);
            tempStar.Left(tempRootSlashLength);
            IFW32FALSE_EXIT(moveDestination.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));
            IFW32FALSE_EXIT(tempStar.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));
            //
            // replace existing doesn't work on directories, but we'll give it a shot anyway,
            // maybe it'll work in some future better version of Windows..
            // and of course, the error when you try this is "access denied" which is
            // somewhat unexpected, you have appro access to delete the directory maybe,
            // but not replace it.. the ReplaceFile api is also explicitly described
            // as for files only
            //
            IFW32FALSE_EXIT(::SxspInstallMoveFileExW(tempStar, moveDestination, fReplaceExisting? MOVEFILE_REPLACE_EXISTING : 0, TRUE));

        } while (::FindNextFileW(findFile, &findData));
        
        if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): FindNextFile() failed:%ld\n",
                __FUNCTION__,
                ::FusionpGetLastWin32Error());
            goto Exit;
        }
        
        if (!findFile.Win32Close())
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): FindClose() failed:%ld\n",
                __FUNCTION__,
                ::FusionpGetLastWin32Error());
            goto Exit;
        }

        // Honk off and install polices - fFoundPolicesToInstall will be true if we really found any.
        moveDestination.Left(realRootSlashLength);
        IFW32FALSE_EXIT(this->AttemptInstallPolicies(m_strTempRootSlash, moveDestination, fReplaceExisting, fPoliciesExist));

        // move manifest file from "\winnt\winsxs\InstallTemp\123456\manifests\x86_cards.2000_0409.manifest" to
        // \winnt\winsxs\manifests\x86_bar_1000_0406.manifst"
        moveDestination.Left(realRootSlashLength);
        IFW32FALSE_EXIT(moveDestination.Win32Append(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));
        IFW32FALSE_EXIT(moveDestination.Win32EnsureTrailingPathSeparator()); //"winnt\winsxs\manifests\"
        realRootSlashLength = moveDestination.Cch();

        tempStar.Left(tempRootSlashLength);
        IFW32FALSE_EXIT(tempStar.Win32Append(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));
        IFW32FALSE_EXIT(tempStar.Win32EnsureTrailingPathSeparator()); //"winnt\winsxs\InstallTemp\123456\manifests\"
        tempRootSlashLength = tempStar.Cch();

        IFW32FALSE_EXIT(tempStar.Win32Append(L"*", 1));
        IFW32FALSE_EXIT(findFile.Win32FindFirstFile(tempStar, &findData));
        do
        {
            // skip . and ..
            if (FusionpIsDotOrDotDot(findData.cFileName))
                continue;
            // there shouldn't be any directories, skip them
            if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                continue;

            moveDestination.Left(realRootSlashLength);
            tempStar.Left(tempRootSlashLength);

            IFW32FALSE_EXIT(moveDestination.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));
            IFW32FALSE_EXIT(tempStar.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));
            IFW32FALSE_EXIT(::SxspInstallMoveFileExW(tempStar, moveDestination, fReplaceExisting ? MOVEFILE_REPLACE_EXISTING : 0, TRUE));
        } while (::FindNextFileW(findFile, &findData));
        
        if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): FindNextFile() failed:%ld\n",
                __FUNCTION__,
                ::FusionpGetLastWin32Error());
            goto Exit;
        }
        
        if (!findFile.Win32Close())
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): FindClose() failed:%ld\n",
                __FUNCTION__,
                ::FusionpGetLastWin32Error());
            goto Exit;
        }
    }

    fSuccess = TRUE;
Exit:

    if (pLogFileStream)
    {
        pLogFileStream->Close(); // ignore the error
        FUSION_DELETE_SINGLETON(pLogFileStream);
    }

    if (fTransactional)
    {
        DWORD dwLastError = ERROR_SUCCESS;

        if (!fSuccess)
            dwLastError = ::FusionpGetLastWin32Error();

        if (!m_strTempRootSlash.IsEmpty())
        {
            if (!SxspDeleteDirectory(m_strTempRootSlash))
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: %s(): SxspDeleteDirectory(%ls) failed:%ld\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(m_strTempRootSlash),
                    ::FusionpGetLastWin32Error());
                if (fSuccess)
                {
                    fSuccess = FALSE;
                    dwLastError = ::FusionpGetLastWin32Error();
                }
                // Close instead of Cancel so the delete wil be tried again upon reboot
                if (m_pRunOnce != NULL && !m_pRunOnce->Close() && fSuccess)
                {
                    dwLastError = ::FusionpGetLastWin32Error();
                    fSuccess = FALSE;
                }
            }
        }
        if (m_pRunOnce != NULL && !m_pRunOnce->Cancel() && fSuccess)
        {
            dwLastError = ::FusionpGetLastWin32Error();
            fSuccess = FALSE;
        }

        if (!fSuccess)
            ::FusionpSetLastWin32Error(dwLastError);
    }
    m_pRunOnce = NULL;
    return fSuccess;
}

//
// we have to do this in three places, so it is worth the reuse
//
class CMungeFileReadOnlynessAroundReplacement
{
public:
#if POST_WHISTLER_BETA1
    CMungeFileReadOnlynessAroundReplacement()
        : m_ReplaceExisting(false), m_FileAttributes(SXSP_INVALID_FILE_ATTRIBUTES)
    {
    }

    BOOL Initialize(
        const CBaseStringBuffer &rbuff,
        BOOL   ReplaceExisting
        )
    {
        BOOL Success = FALSE;
        FN_TRACE_WIN32(Success);
        IFW32FALSE_EXIT(m_FileName.Win32Assign(rbuff));
        m_ReplaceExisting = ReplaceExisting;
        // deliberately ignore failure from GetFileAttributes
        // 1) It's ok if the file doesn't exist
        // 2) If there's a more serious problem, we'll hit it again immediately, but
        //    that does lead to nested retry.
        m_FileAttributes = (ReplaceExisting ? ::GetFileAttributesW(FileName) : SXSP_INVALID_FILE_ATTRIBUTES);
        if (m_FileAttributes != SXSP_INVALID_FILE_ATTRIBUTES)
            ::SetFileAttributesW(FileName, 0);

        Success = TRUE;
    Exit:
        return Success;
    }

    ~CMungeFileReadOnlynessAroundReplacement()
    {
        if (m_ReplaceExisting && m_FileAttributes != SXSP_INVALID_FILE_ATTRIBUTES)
        {
            // error deliberately ignored
            SXSP_PRESERVE_LAST_ERROR(::SetFileAttributesW(m_FileName, m_FileAttributes));
        }
    }

    BOOL                 m_ReplaceExisting;
    CUnicodeStringBuffer m_FileName;
    DWORD                m_FileAttributes;
#else // POST_WHISTLER_BETA1
    // simpler code for beta1
    BOOL Initialize(
        PCWSTR FileName,
        BOOL   /*ReplaceExisting*/
        )
    {
        // error deliberately ignored
        ::SetFileAttributesW(FileName, 0);
        return TRUE;
    }
#endif // POST_WHISTLER_BETA1
};


class CDllRedirInstallCatalogLocals
{
public:
    CDllRedirInstallCatalogLocals() { }
    ~CDllRedirInstallCatalogLocals() { }

    CMungeFileReadOnlynessAroundReplacement MungeCatalogAttributes;
    CStringBuffer                           CatalogSourceBuffer;
    CStringBuffer                           CatalogDestinationBuffer;
    CPublicKeyInformation                   CatalogSignerInfo;
    CSmallStringBuffer                      sbStrongNameString;
    CSmallStringBuffer                      sbReferencePublicKeyToken;
    CSmallStringBuffer                      sbSignerName;
};

BOOL
CDllRedir::InstallCatalog(
    DWORD dwManifestOperationFlags,
    const CBaseStringBuffer &ManifestSourceBuffer,
    const CBaseStringBuffer &ManifestDestinationBuffer,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
    )
{
    BOOL                                    fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    bool fHasCatalog = false;
    CSmartPtr<CDllRedirInstallCatalogLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    CMungeFileReadOnlynessAroundReplacement &MungeCatalogAttributes = Locals->MungeCatalogAttributes;
    CStringBuffer                           &CatalogSourceBuffer = Locals->CatalogSourceBuffer;
    CStringBuffer                           &CatalogDestinationBuffer = Locals->CatalogDestinationBuffer;
    ManifestValidationResult                ManifestStatus = ManifestValidate_Unknown;
    BOOL                                    fAreWeInOSSetupMode = FALSE;
    BOOL                                    bInstallCatalogSuccess = FALSE;

    //
    // Determine the possible source and destination of the catalog file. This
    // needs to be done, even if we're not explicitly looking for a catalog, since
    // our heuristic still needs to check to see if there is one available.
    //    
    IFW32FALSE_EXIT(CatalogDestinationBuffer.Win32Assign(ManifestDestinationBuffer));
    IFW32FALSE_EXIT(CatalogDestinationBuffer.Win32ChangePathExtension(FILE_EXTENSION_CATALOG, FILE_EXTENSION_CATALOG_CCH, eAddIfNoExtension));

    IFW32FALSE_EXIT(CatalogSourceBuffer.Win32Assign(ManifestSourceBuffer));
    IFW32FALSE_EXIT(CatalogSourceBuffer.Win32ChangePathExtension(FILE_EXTENSION_CATALOG, FILE_EXTENSION_CATALOG_CCH, eAddIfNoExtension));

    //
    // Note: We only attempt to deal with catalogs when there is installation info.
    // Even if there was no install data, we don't bother looking to see if there's
    // a catalog.  Catalogs imply signatures and public key information, and require
    // a codebase to be reinstalled from.  If you didn't provide such to the installer,
    // shame on you.
    //
    if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_FORCE_LOOK_FOR_CATALOG) != 0)
    {
        //
        // If they insist.
        //
        IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_COMPRESSION_AWARE, CatalogSourceBuffer, fHasCatalog));
    }
    else if (AssemblyContext->InstallationInfo != NULL)
    {
        PSXS_INSTALL_SOURCE_INFO pInfo = static_cast<PSXS_INSTALL_SOURCE_INFO>(AssemblyContext->InstallationInfo);

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s() found installation info at %p\n"
            "   pInfo->dwFlags = 0x%08lx\n",
            __FUNCTION__, pInfo, (pInfo != NULL) ? pInfo->dwFlags : 0);

        //
        // Do we explicitly have a catalog?
        //
        fHasCatalog = ((pInfo->dwFlags & SXSINSTALLSOURCE_HAS_CATALOG) != 0);
        if (fHasCatalog)
        {
            FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INSTALLATION,
                "SXS.DLL: Using catalog because install source says that they're supposed to be there.\n");
        }

        //
        // Well, if we didn't, then we still should look.. maybe they forgot the flag.
        // But, only look if they don't mind us checking.
        //
        if (!(pInfo->dwFlags & SXSINSTALLSOURCE_DONT_DETECT_CATALOG) && !fHasCatalog)
            IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_COMPRESSION_AWARE, CatalogSourceBuffer, fHasCatalog));

        pInfo->dwFlags |= (fHasCatalog ? SXSINSTALLSOURCE_HAS_CATALOG : 0);
    }
    if (!fHasCatalog)
    {
        ::FusionpLogError(
            MSG_SXS_PUBLIC_ASSEMBLY_REQUIRES_CATALOG_AND_SIGNATURE,
            CEventLogString(ManifestSourceBuffer));
        ::FusionpSetLastWin32Error(ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING);
        goto Exit;
    }

    //
    // If there's no catalog present, then something bad happened
    // at some point along the way - fail the installation!
    //
    // Copyfile it over.  We do this rather than streaming because we don't
    // care about the contents of the catalog, it's binary.
    //
    IFW32FALSE_EXIT(MungeCatalogAttributes.Initialize(CatalogDestinationBuffer, TRUE));

    if (dwManifestOperationFlags &  MANIFEST_OPERATION_INSTALL_FLAG_MOVE)
    {
        bInstallCatalogSuccess = ::SxspInstallDecompressAndMoveFileExW(
                CatalogSourceBuffer,
                CatalogDestinationBuffer, 
                (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING) ? MOVEFILE_REPLACE_EXISTING : 0);
    }
    else
    {
        bInstallCatalogSuccess =
            ::SxspInstallDecompressOrCopyFileW(                
                CatalogSourceBuffer,
                CatalogDestinationBuffer, 
                (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING) ? FALSE : TRUE);     // bFailIfExist == FALSE
    }
    if (!bInstallCatalogSuccess)
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL:%s Failed DecompressOrCopying catalog file from [%ls] to [%ls] - Error was 0x%08x\n",
            __FUNCTION__,
            static_cast<PCWSTR>(CatalogSourceBuffer),
            static_cast<PCWSTR>(CatalogDestinationBuffer),
            ::FusionpGetLastWin32Error());
#endif
        TRACE_WIN32_FAILURE_ORIGINATION(SxspInstallDecompressOrCopyFileW);
        goto Exit;
    }

    //
    // If we're in OS-setup mode, then we don't bother to validate this manifest against
    // its catalog, instead assuming that the catalogs coming off the CD/installpoint
    // are golden.  This does not protect us against malicious IT managers, warezer groups
    // putting bad bits in their distros, etc.  But who cares, right?
    //
    IFW32FALSE_EXIT(::FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode));
    if (!fAreWeInOSSetupMode && fHasCatalog)
    {
        ULONG ulCatalogKeyLength = 0;
        CPublicKeyInformation &CatalogSignerInfo = Locals->CatalogSignerInfo;
        CSmallStringBuffer &sbStrongNameString = Locals->sbStrongNameString;
        CSmallStringBuffer &sbReferencePublicKeyToken = Locals->sbReferencePublicKeyToken;
        BOOL bHasPublicKeyToken = FALSE;
        BOOL bStrongNameMatches = FALSE;
        CAssemblyReference OurReference;

        IFW32FALSE_EXIT(OurReference.Initialize(AssemblyContext->AssemblyIdentity));
        IFW32FALSE_EXIT(OurReference.GetPublicKeyToken(&sbReferencePublicKeyToken, bHasPublicKeyToken));

        //
        // Validate the catalog and manifest, but don't check the strong name
        // yet - the file name isn't valid at this point.
        //
        IFW32FALSE_EXIT(::SxspValidateManifestAgainstCatalog(
            ManifestDestinationBuffer,
            CatalogDestinationBuffer,
            ManifestStatus,
            MANIFESTVALIDATE_MODE_NO_STRONGNAME));

        //
        // If there's no catalog, or there is a catalog but it's broken, then
        // we need to complain and exit.
        //
        if (ManifestStatus != ManifestValidate_IsIntact)
        {
#if DBG
            DWORD dwFileAttributes = 0;

            ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR,
                    "SXS: ManifestStatus: %s (%lu)\n",
                    SxspManifestValidationResultToString(ManifestStatus),
                    static_cast<ULONG>(ManifestStatus));

            dwFileAttributes = ::GetFileAttributesW(ManifestSourceBuffer);
            if (dwFileAttributes == INVALID_FILE_ATTRIBUTES)
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR,
                        "SXS: GetFileAttributes(%ls):0x%lx, error:%lu\n",
                        static_cast<PCWSTR>(ManifestSourceBuffer),
                        dwFileAttributes,
                        ::FusionpGetLastWin32Error());

            dwFileAttributes = ::GetFileAttributesW(CatalogDestinationBuffer);
            if (dwFileAttributes == INVALID_FILE_ATTRIBUTES)
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR,
                        "SXS: GetFileAttribtes(%ls):0x%lx, error:%lu\n",
                        static_cast<PCWSTR>(CatalogDestinationBuffer),
                        dwFileAttributes,
                        ::FusionpGetLastWin32Error());
#endif
            ::FusionpLogError(
                MSG_SXS_MANIFEST_CATALOG_VERIFY_FAILURE,
                CEventLogString(ManifestDestinationBuffer));

            ::FusionpSetLastWin32Error(ERROR_SXS_PROTECTION_CATALOG_NOT_VALID);
            goto Exit;
        }

        //
        // Get some useful information about the catalog's signer - opens the catalog
        // on the installation source.
        //
        IFW32FALSE_EXIT(CatalogSignerInfo.Initialize(CatalogDestinationBuffer));
        IFW32FALSE_EXIT(CatalogSignerInfo.GetPublicKeyBitLength(ulCatalogKeyLength));

        //
        // Minimally, we need some number of bits in the signing catalog's public key
        //
        if ((ulCatalogKeyLength < SXS_MINIMAL_SIGNING_KEY_LENGTH) || !bHasPublicKeyToken)
        {
            CSmallStringBuffer &sbSignerName = Locals->sbSignerName;
            sbSignerName.Clear();

            IFW32FALSE_EXIT(CatalogSignerInfo.GetSignerNiceName(sbSignerName));

            ::FusionpLogError(
                MSG_SXS_CATALOG_SIGNER_KEY_TOO_SHORT,
                CEventLogString(sbSignerName),
                CEventLogString(CatalogSourceBuffer));

            goto Exit;
        }

        // Now compare the public key tokens
        IFW32FALSE_EXIT(CatalogSignerInfo.DoesStrongNameMatchSigner(sbReferencePublicKeyToken, bStrongNameMatches));

        if (!bStrongNameMatches)
        {
            CSmallStringBuffer &sbSignerName = Locals->sbSignerName;
            sbSignerName.Clear();
            IFW32FALSE_EXIT(CatalogSignerInfo.GetSignerNiceName(sbSignerName));

            ::FusionpLogError(
                MSG_SXS_PUBLIC_KEY_TOKEN_AND_CATALOG_MISMATCH,
                CEventLogString(CatalogSourceBuffer),
                CEventLogString(sbSignerName),
                CEventLogString(sbReferencePublicKeyToken));

            goto Exit;
        }
    }


    fSuccess = TRUE;
Exit:
    return fSuccess;
}


class CDllRedirInstallManifestLocals
{
public:
    CDllRedirInstallManifestLocals() { }
    ~CDllRedirInstallManifestLocals() { }

    CStringBuffer ManifestSourceBuffer;
    CStringBuffer ManifestDestinationBuffer;
    CStringBuffer ManifestFileNameBuffer;
    CStringBuffer CatalogSourceBuffer;
    CStringBuffer CatalogDestinationBuffer;
};

BOOL
CDllRedir::InstallManifest(
    DWORD dwManifestOperationFlags,
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
    )
{
    FN_PROLOG_WIN32

    BOOL  fVerify = FALSE;
    BOOL  fTransactional = FALSE;
    BOOL  fReplaceExisting = FALSE;
    BOOL  fIsSetupTime = FALSE;
    DWORD OpenOrCreateManifestDestination;
    CTeeStream* TeeStreamForManifestInstall = NULL;
    CFullPathSplitPointers SplitManifestSource;
    CMungeFileReadOnlynessAroundReplacement MungeManifestAttributes;
    CAssemblyReference TempAssemblyReference;

    //
    // Windows Setup is restartable, so we must be too when it calls us.
    //   ReplaceExisting is probably enough to use CREATE_ALWAYS, but lets be safer for
    //   now and check both weakenings.
    //
    CSmartPtr<CDllRedirInstallManifestLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    CStringBuffer &ManifestSourceBuffer = Locals->ManifestSourceBuffer;
    CStringBuffer &ManifestDestinationBuffer = Locals->ManifestDestinationBuffer;
    CStringBuffer &ManifestFileNameBuffer = Locals->ManifestFileNameBuffer;
    CStringBuffer &CatalogSourceBuffer = Locals->CatalogSourceBuffer;
    CStringBuffer &CatalogDestinationBuffer = Locals->CatalogDestinationBuffer;
    fVerify          = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NO_VERIFY) == 0;
    fTransactional   = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL) == 0;
    fReplaceExisting = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING) != 0;
    OpenOrCreateManifestDestination = (fReplaceExisting && !fTransactional) ? CREATE_ALWAYS : CREATE_NEW;

    TeeStreamForManifestInstall = reinterpret_cast<CTeeStream*>(AssemblyContext->TeeStreamForManifestInstall);

    const bool fIsSystemPolicyInstallation = 
        (AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_SYSTEM_POLICY_INSTALLATION) != 0;

#if FUSION_PRECOMPILED_MANIFEST
    CMungeFileReadOnlynessAroundReplacement MungePrecompiledManifestAttributes;
    CPrecompiledManifestWriterStream * pcmWriterStream = reinterpret_cast<CPrecompiledManifestWriterStream *>(AssemblyContext->pcmWriterStream);
#endif

    PARAMETER_CHECK(AssemblyContext != NULL);
    INTERNAL_ERROR_CHECK(AssemblyContext->TeeStreamForManifestInstall != NULL);

    // Get "\windir\winsxs\install\guid\manifests" or Get "\windir\winsxs\install\guid\policies".
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH, // Flags
            fIsSystemPolicyInstallation ? SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY : SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
            m_strTempRootSlash,
            m_strTempRootSlash.Cch(),
            AssemblyContext->AssemblyIdentity,
            NULL,
            ManifestDestinationBuffer));

    // remove the trailing slash because CreateDirectory maybe sometimes doesn't like it
    IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32RemoveTrailingPathSeparators());
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::CreateDirectoryW(ManifestDestinationBuffer, NULL)
        || ::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS);

    IFW32FALSE_EXIT(ManifestSourceBuffer.Win32Assign(AssemblyContext->ManifestPath, AssemblyContext->ManifestPathCch));

    // get "x86_bar_1000_0409"
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT
                | (fIsSystemPolicyInstallation ? SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION : 0),
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            m_strTempRootSlash,
            m_strTempRootSlash.Cch(),
            AssemblyContext->AssemblyIdentity,
            NULL,
            ManifestFileNameBuffer));

    // create policies\x86_policy.6.0.Microsoft.windows.cards_pulicKeyToken_en-us_1223423423
    IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32AppendPathElement(ManifestFileNameBuffer));
    if (fIsSystemPolicyInstallation)
    {
        PCWSTR pszVersion = NULL;
        SIZE_T VersionCch = 0;
        // for policy installation, create a subdir under Policies
        IFW32FALSE_ORIGINATE_AND_EXIT(
            ::CreateDirectoryW(ManifestDestinationBuffer, NULL)
            || ::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS);

        //generate policy file name, like 1.0.0.0.policy
        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                AssemblyContext->AssemblyIdentity,
                &s_IdentityAttribute_version,
                &pszVersion,
                &VersionCch));

        INTERNAL_ERROR_CHECK(VersionCch != 0);
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32Append(pszVersion, VersionCch));
        // .policy
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32Append(ASSEMBLY_POLICY_FILE_NAME_SUFFIX_POLICY, NUMBER_OF(ASSEMBLY_POLICY_FILE_NAME_SUFFIX_POLICY) - 1));
    }
    else
    {
        // .manifest
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32RemoveTrailingPathSeparators());
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32Append(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_MANIFEST, NUMBER_OF(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_MANIFEST) - 1));
    }
    IFW32FALSE_EXIT(MungeManifestAttributes.Initialize(ManifestDestinationBuffer, fReplaceExisting));

    //
    // Set the manifest sink before trying to install the catalog, so that if the source is a binary, that is, the manifest is from 
    // a dll or exe, we could check the catalog with the manifest .
    //
    IFW32FALSE_EXIT(TeeStreamForManifestInstall->SetSink(ManifestDestinationBuffer, OpenOrCreateManifestDestination));
    IFW32FALSE_EXIT(TeeStreamForManifestInstall->Close());

    //
    // Try installing the catalog that goes with this assembly
    //
    IFW32FALSE_EXIT(
        this->InstallCatalog(
            dwManifestOperationFlags,
            ManifestSourceBuffer,
            ManifestDestinationBuffer,
            AssemblyContext));

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS.DLL: Sinking manifest to \"%S\"\n", static_cast<PCWSTR>(ManifestDestinationBuffer));


#if FUSION_PRECOMPILED_MANIFEST
    IFW32FALSE_EXIT(
        ManifestDestinationBuffer.Win32ChangePathExtension(
            PRECOMPILED_MANIFEST_EXTENSION,
            NUMBER_OF(PRECOMPILED_MANIFEST_EXTENSION) - 1,
            NULL,
            eErrorIfNoExtension));
    IFW32FALSE_EXIT(MungePrecompiledManifestAttributes.Initialize(ManifestDestinationBuffer, fReplaceExisting));
    IFW32FALSE_EXIT(pcmWriterStream->SetSink(ManifestDestinationBuffer, OpenOrCreateManifestDestination));
#endif

    //
    // Now, if we're in setup mode and we're installing a policy file, then
    // also stream the file out, then also CopyFile the file out to a SetupPolicies in the target path
    // as well.
    //
    // Side notes: We don't try to copy the catalog next to the manifest, since there's no
    // WFP happening during setup.  We can simply skip this bit.  We also don't bother
    // registering this manifest in the registry anywhere, for the same reason.  Once setup
    // completes, we'll poof the %windir%\winsxs\setuppolicies directory (and friends)
    // as part of tearing down the ~ls directory.
    // 
    IFW32FALSE_EXIT(::FusionpAreWeInOSSetupMode(&fIsSetupTime));
    if (fIsSetupTime && fIsSystemPolicyInstallation)
    {
        PCWSTR pszVersion = NULL;
        SIZE_T VersionCch = 0;

        //
        // Let's reuse the manifest destination buffer.
        //
        IFW32FALSE_EXIT(::SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH,
            SXSP_GENERATE_SXS_PATH_PATHTYPE_SETUP_POLICY,
            this->m_strTempRootSlash,
            this->m_strTempRootSlash.Cch(),
            AssemblyContext->AssemblyIdentity,
            NULL,
            ManifestDestinationBuffer));

        //
        // Ensure the destination path exists
        //
        IFW32FALSE_EXIT(::SxspCreateMultiLevelDirectory(
            this->m_strTempRootSlash,
            SETUP_POLICY_ROOT_DIRECTORY_NAME));

        //
        //generate policy file name, like 1.0.0.0.policy
        //
        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyContext->AssemblyIdentity,
            &s_IdentityAttribute_version,
            &pszVersion,
            &VersionCch));

        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32AppendPathElement(ManifestFileNameBuffer));

        //
        // Create directory
        //
        IFW32FALSE_EXIT(
            ::CreateDirectoryW(ManifestDestinationBuffer, NULL) ||
            (::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS));

        INTERNAL_ERROR_CHECK(VersionCch != 0);
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32Append(pszVersion, VersionCch));
        IFW32FALSE_EXIT(ManifestDestinationBuffer.Win32Append(ASSEMBLY_POLICY_FILE_NAME_SUFFIX_POLICY, NUMBER_OF(ASSEMBLY_POLICY_FILE_NAME_SUFFIX_POLICY) - 1));

        //
        // And copy the file over (replace an existing one, it might be bogus!)
        //
        // Attention: manifest is never been compressed, and it is easy to replace SxspCopyFile with SetupDecompressOrCopyFile
        //
        IFW32FALSE_EXIT(SxspCopyFile(
            SXSP_COPY_FILE_FLAG_REPLACE_EXISTING,
            ManifestSourceBuffer,
            ManifestDestinationBuffer));
    }

    FN_EPILOG
}

class CDllRedirInstallFileLocals
{
public:
    CDllRedirInstallFileLocals() { }
    ~CDllRedirInstallFileLocals() { }

    CStringBuffer       SourceBuffer;
    CStringBuffer       DestinationBuffer;
    CStringBuffer       SourceFileNameBuffer;
    CStringBuffer       HashDataString;
    CSmallStringBuffer  HashAlgNiceName;
    CFusionFilePathAndSize verifyQueuedFileCopy;
    CStringBuffer       DestinationDirectory;
    CMungeFileReadOnlynessAroundReplacement MungeFileAttributes;
    CStringBuffer       renameExistingAway;
    CSmallStringBuffer  uidBuffer;
};

BOOL
CDllRedir::InstallFile(
    PACTCTXCTB_CALLBACK_DATA Data,
    const CBaseStringBuffer &FileNameBuffer
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CSmartPtr<CDllRedirInstallFileLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    CStringBuffer &SourceBuffer = Locals->SourceBuffer;
    CStringBuffer &DestinationBuffer = Locals->DestinationBuffer;
    SIZE_T DirectoryLength = 0;
    CStringBuffer &SourceFileNameBuffer = Locals->SourceFileNameBuffer;
    ULONGLONG SourceFileSize = 0;
    bool fFound = false;
    SIZE_T cb = 0;
    ULONG Disposition = (Data->Header.ManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_MOVE) ? SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_MOVE : SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_COPY;
    const DWORD dwManifestOperationFlags = Data->Header.ManifestOperationFlags;
    const BOOL  fVerify          = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NO_VERIFY) == 0;
    const BOOL  fTransactional   = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL) == 0;
    const BOOL  fReplaceExisting = (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING) != 0;

    ALG_ID              HashAlgId = FUSION_DEFAULT_HASH_ALGORITHM;
    bool                fHasHashData = false;
    bool                fHasHashAlgName = false;
    HashValidateResult  HashCorrect = HashValidate_OtherProblems;
    CStringBuffer       &HashDataString = Locals->HashDataString;
    CSmallStringBuffer  &HashAlgNiceName = Locals->HashAlgNiceName;

    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            0, // Flags
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            m_strTempRootSlash,
            m_strTempRootSlash.Cch(),
            Data->ElementParsed.AssemblyContext->AssemblyIdentity,
            NULL,
            DestinationBuffer));

    IFW32FALSE_EXIT(DestinationBuffer.Win32Append(static_cast<PCWSTR>(FileNameBuffer), FileNameBuffer.Cch()));

    DirectoryLength = 1 + DestinationBuffer.CchWithoutLastPathElement();

    // Take the manifest path, trim back to the directory name and add the file...
    IFW32FALSE_EXIT(SourceBuffer.Win32Assign(Data->ElementParsed.AssemblyContext->ManifestPath, Data->ElementParsed.AssemblyContext->ManifestPathCch));

    IFW32FALSE_EXIT(SourceBuffer.Win32RemoveLastPathElement());

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_sourceName,
            &Data->ElementParsed,
            fFound,
            sizeof(SourceFileNameBuffer),
            &SourceFileNameBuffer,
            cb,
            NULL,
            0));

    PCWSTR SourceFileName;

    if (fFound)
        SourceFileName = SourceFileNameBuffer;
    else
        SourceFileName = FileNameBuffer;

    // Extract information about the hashing stuff that's included on this node
    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_hash,
            &Data->ElementParsed,
            fHasHashData,
            sizeof(HashDataString),
            &HashDataString,
            cb,
            NULL,
            0));

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_hashalg,
            &Data->ElementParsed,
            fHasHashAlgName,
            sizeof(HashAlgNiceName),
            &HashAlgNiceName,
            cb,
            NULL,
            0));

    //
    // Neat.  Find out what the hash algorithm was.
    //
    if (fHasHashAlgName)
    {
        if (!::SxspHashAlgFromString(HashAlgNiceName, HashAlgId))
        {
            ::FusionpLogError(
                MSG_SXS_INVALID_FILE_HASH_FROM_COPY_CALLBACK,
                CEventLogString(HashAlgNiceName));
            goto Exit;
        }
    }
    else
    {
        HashAlgId = FUSION_DEFAULT_HASH_ALGORITHM;
    }

    IFW32FALSE_EXIT(SourceBuffer.Win32AppendPathElement(SourceFileName, (SourceFileName != NULL) ? ::wcslen(SourceFileName) : 0));
    IFW32FALSE_EXIT(::SxspGetFileSize(SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE, SourceBuffer, SourceFileSize));

    //
    // And add the file's metadata to the currently running metadata blob
    //
    {
        CSecurityMetaData *pMetaDataObject = reinterpret_cast<CSecurityMetaData*>(Data->Header.InstallationContext->SecurityMetaData);

        if ( pMetaDataObject != NULL )
        {
            CSmallStringBuffer sbuffFileShortName;
            IFW32FALSE_EXIT(sbuffFileShortName.Win32Assign(SourceFileName, ::wcslen(SourceFileName)));
            IFW32FALSE_EXIT(pMetaDataObject->QuickAddFileHash( 
                sbuffFileShortName, 
                HashAlgId, 
                HashDataString));
        }
    }

    if ((Data->Header.InstallationContext != NULL) &&
        (Data->Header.InstallationContext->Callback != NULL))
    {
        Disposition = 0;
        SXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS parameters = {sizeof(parameters)};
        parameters.pvContext = Data->Header.InstallationContext->Context;
        parameters.dwFileFlags = 0;
        parameters.pAlternateSource = NULL; // future IStream
        parameters.pSourceFile = SourceBuffer;
        parameters.pDestinationFile = DestinationBuffer;
        parameters.nFileSize = SourceFileSize;
        parameters.nDisposition = 0;
        IFW32FALSE_EXIT((*Data->Header.InstallationContext->Callback)(&parameters));
        Disposition = parameters.nDisposition;
    }

    switch (Disposition)
    {
    default:
        ::FusionpLogError(
            MSG_SXS_INVALID_DISPOSITION_FROM_FILE_COPY_CALLBACK,
            CEventLogString(SxspInstallDispositionToStringW(Disposition)));
        goto Exit;

    case SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_COPIED:
        {
            if (fVerify)
            {
                ULONGLONG DestinationFileSize = 0;
                IFW32FALSE_EXIT(::SxspGetFileSize(0, DestinationBuffer, DestinationFileSize));
                INTERNAL_ERROR_CHECK(SourceFileSize == DestinationFileSize);

                //
                // (jonwis) Add a verification check to make sure that the file copied
                // is really the one that they wanted from the file hash information.
                // Do this only if we're not in OS-setup mode.
                //
                IFW32FALSE_EXIT(::SxspCheckHashDuringInstall(fHasHashData, DestinationBuffer, HashDataString, HashAlgId, HashCorrect));
                if (HashCorrect != HashValidate_Matches)
                {
                    ::FusionpDbgPrintEx(
                            FUSION_DBG_LEVEL_ERROR,
                            "SXS: %s : SxspCheckHashDuringInstall(file=%ls)\n",
                            __FUNCTION__,
                            static_cast<PCWSTR>(DestinationBuffer)
                            );
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(FileHashMismatch, ERROR_SXS_FILE_HASH_MISMATCH);
                }
            }
        }
        break;

    case SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_QUEUED:
        {
            if (fVerify)
            {
                CFusionFilePathAndSize &verifyQueuedFileCopy = Locals->verifyQueuedFileCopy;

                // Copy our hashing info over.  Yes, I really do mean =, not ==.
                if (verifyQueuedFileCopy.m_bHasHashInfo = fHasHashData)
                {
                    IFW32FALSE_EXIT(verifyQueuedFileCopy.m_HashString.Win32Assign(HashDataString));
                    verifyQueuedFileCopy.m_HashAlgorithm = HashAlgId;
                }

                IFW32FALSE_EXIT(verifyQueuedFileCopy.m_path.Win32Assign(DestinationBuffer));
                verifyQueuedFileCopy.m_size = SourceFileSize;
                IFW32FALSE_EXIT(m_queuedFileCopies.Win32Append(verifyQueuedFileCopy));
            }
        }
        break;

    case SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_MOVE:
    case SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_COPY:
        {
            CStringBuffer &DestinationDirectory = Locals->DestinationDirectory;
            CMungeFileReadOnlynessAroundReplacement &MungeFileAttributes = Locals->MungeFileAttributes;

            IFW32FALSE_EXIT(DestinationDirectory.Win32Assign(DestinationBuffer));
            IFW32FALSE_EXIT(DestinationDirectory.Win32RemoveLastPathElement());
            IFW32FALSE_EXIT(::FusionpCreateDirectories(DestinationDirectory, DestinationDirectory.Cch()));

            if (Disposition == SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_COPY)
            {
                DWORD dwLastError = 0;
                
                IFW32FALSE_EXIT(MungeFileAttributes.Initialize(DestinationBuffer, fReplaceExisting));
                
                fSuccess = ::SxspInstallDecompressOrCopyFileW(                    
                    SourceBuffer,
                    DestinationBuffer, 
                    !fReplaceExisting); //bFailIfExist
                    
                dwLastError = ::FusionpGetLastWin32Error();

                // If we failed because the file exists, that might be ok
                if ((!fSuccess) && (dwLastError == ERROR_FILE_EXISTS))
                {
                    ULONGLONG cbSource, cbDestination;

                    // If we got the file sizes, and they're equal, then we're reinstalling the
                    // same file again, which isn't technically an error.  Some smarter work here,
                    // like comparing file hashes or PE headers, could be done.
                    if (::SxspGetFileSize(SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE, SourceBuffer, cbSource) &&
                        ::SxspGetFileSize(0, DestinationBuffer, cbDestination) && 
                        (cbSource == cbDestination))
                    {
                        fSuccess = TRUE;
                    }
                    // Otherwise, we failed getting the sizes of those files, but we want to
                    // preserve the error from the original decompress-or-move call
                    else
                    {
                        ::FusionpSetLastWin32Error(dwLastError);
                    }
                }
            }
            else
            {
                fSuccess = ::SxspInstallMoveFileExW(
                    SourceBuffer,
                    DestinationBuffer,
                    MOVEFILE_COPY_ALLOWED | (fReplaceExisting ? MOVEFILE_REPLACE_EXISTING : 0));
                // move fails on from resource, so general idea: try copy upon move failure
                if (!fSuccess)
                {
                    DWORD dwLastError = ::FusionpGetLastWin32Error();
                    if ((dwLastError == ERROR_ACCESS_DENIED) ||
                        (dwLastError == ERROR_USER_MAPPED_FILE) ||
                        (dwLastError == ERROR_SHARING_VIOLATION))
                    {
                        fSuccess = ::SxspInstallDecompressOrCopyFileW(
                                                SourceBuffer, 
                                                DestinationBuffer, 
                                                !fReplaceExisting); // bFailIfExist
                    }
                }
            }


            if (fSuccess)
            {
                IFW32FALSE_EXIT(::SxspCheckHashDuringInstall(fHasHashData, DestinationBuffer, HashDataString, HashAlgId, HashCorrect));
                if (HashCorrect != HashValidate_Matches)
                {
                    ::FusionpDbgPrintEx(
                            FUSION_DBG_LEVEL_ERROR,
                            "SXS: %s : SxspCheckHashDuringInstall(file=%ls)\n",
                            __FUNCTION__,
                            static_cast<PCWSTR>(DestinationBuffer)
                            );
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(FileHashMismatch, ERROR_SXS_FILE_HASH_MISMATCH);
                }
                else
                    fSuccess = TRUE;
                goto Exit;
            }
            else
            {
                ULONGLONG iDupFileSize = 0;
                DWORD dwLastError = ::FusionpGetLastWin32Error();
                CStringBuffer          &renameExistingAway = Locals->renameExistingAway;
                CSmallStringBuffer     &uidBuffer = Locals->uidBuffer;
                CFullPathSplitPointers splitExisting;

                bool fFatal =
                    (
                           dwLastError != ERROR_FILE_EXISTS         // !fReplaceExisting
                        && dwLastError != ERROR_ALREADY_EXISTS      // !fReplaceExisting
                        && dwLastError != ERROR_ACCESS_DENIED
                        && dwLastError != ERROR_USER_MAPPED_FILE    //  fReplaceExisting
                        && dwLastError != ERROR_SHARING_VIOLATION); //  fReplaceExisting
                if (fFatal)
                {
                    ::SxspInstallPrint(
                        "SxsInstall: Copy/MoveFileW(%ls,%ls) failed %d, %s.\n",
                        static_cast<PCWSTR>(SourceBuffer),
                        static_cast<PCWSTR>(DestinationBuffer),
                        ::FusionpGetLastWin32Error(),
                        fFatal ? "fatal" : "not fatal");

                    ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR,
                            "%s(%d): SXS.dll: Copy/MoveFileW(%ls,%ls) failed %d, %s.\n",
                            __FILE__,
                            __LINE__,
                            static_cast<PCWSTR>(SourceBuffer),
                            static_cast<PCWSTR>(DestinationBuffer),
                            ::FusionpGetLastWin32Error(),
                            fFatal ? "fatal" : "not fatal");

                    goto Exit;
                }

                //
                // This could be winlogon (or setup) holding open comctl, so
                // try harder. Move the file away and then copy.
                // Consider ReplaceFile here for atomicity, but ReplaceFile
                // is kind of big and scary and unknown.
                //
                if (fTransactional)
                {
                    ::SxspInstallPrint("SxsInstall: Failure to copy file into temp, someone's opening temp?\n");
                }

                if (!splitExisting.Initialize(SourceBuffer))
                {
                    goto CheckSizes;
                }
                if (!::SxspCreateWinSxsTempDirectory(renameExistingAway, NULL, &uidBuffer, NULL))
                {
                    goto CheckSizes;
                }
                if (!renameExistingAway.Win32AppendPathElement(splitExisting.m_name, (splitExisting.m_name != NULL) ? ::wcslen(splitExisting.m_name) : 0))
                {
                    goto CheckSizes;
                }

                //
                // temporary file, no worry about compressed or not
                //
                if (!::MoveFileExW(DestinationBuffer, renameExistingAway, 0)) // no worry about compressed or not
                {
                    ::SxspInstallPrint(
                        "SxsInstall: MoveFileExW(%ls,%ls,0) failed %d.\n",
                        static_cast<PCWSTR>(DestinationBuffer),
                        static_cast<PCWSTR>(renameExistingAway),
                        ::FusionpGetLastWin32Error());
                    goto CheckSizes;
                }
                if (!::SxspInstallDecompressOrCopyFileW(
                            SourceBuffer,
                            DestinationBuffer,
                            FALSE))
                {
                    ::SxspInstallPrint(
                        "SxsInstall: CopyFile(%ls, %ls, TRUE) failed %d.\n",
                        static_cast<PCWSTR>(SourceBuffer),
                        static_cast<PCWSTR>(DestinationBuffer),
                        ::FusionpGetLastWin32Error());
                    // roll back
                    if (!::MoveFileExW(renameExistingAway, DestinationBuffer, 0)) // no worry about compressed or not
                    {
                        ::SxspInstallPrint(
                            "SxsInstall: Rollback MoveFileExW(%ls, %ls, 0) failed %d; this is very bad.\n",
                            static_cast<PCWSTR>(renameExistingAway),
                            static_cast<PCWSTR>(DestinationBuffer),
                            ::FusionpGetLastWin32Error()
                          );
                    }
                    goto CheckSizes;
                }
                fSuccess = TRUE;
                goto Exit;
CheckSizes:
                IFW32FALSE_EXIT(::SxspGetFileSize(0, DestinationBuffer, iDupFileSize));

                if (iDupFileSize != SourceFileSize)
                {
                    ::SxspInstallPrint("SxsInstall: " __FUNCTION__ " Error %d encountered, file sizes not the same, assumed equal, propagating error.\n", dwLastError);
                    ::FusionpSetLastWin32Error(dwLastError);
                    goto Exit;
                }
                ::SxspInstallPrint("SxsInstall: " __FUNCTION__ " Error %d encountered, file sizes the same, assumed equal, claiming success.\n", dwLastError);
            }
            break;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

VOID
CDllRedir::ContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();
    CDllRedir *pDllRedir = reinterpret_cast<CDllRedir*>(Data->Header.ActCtxGenContext);
    PSTRING_SECTION_GENERATION_CONTEXT SSGenContext = NULL;
    PDLL_REDIRECTION_CONTEXT DllRedirectionContext = NULL;
    PDLL_REDIRECTION_ENTRY Entry = NULL;
    PDLL_REDIRECTION_ENTRY SystemDefaultEntry = NULL;
    PDLL_REDIRECTION_ENTRY Syswow64DefaultEntry = NULL;

    if (pDllRedir != NULL)
        SSGenContext = pDllRedir->m_SSGenContext;

    if (SSGenContext != NULL)
        DllRedirectionContext = (PDLL_REDIRECTION_CONTEXT) ::SxsGetStringSectionGenerationContextCallbackContext(SSGenContext);

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_PARSEENDING:
        Data->ParseEnding.Success = FALSE;

        /*
        at this point we have enough information to form the install path,
        so get the TeeStream to start writing the manifest to disk
        */
        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL)
            IFW32FALSE_EXIT(InstallManifest(Data->Header.ManifestOperationFlags, Data->ParseEnding.AssemblyContext));

        Data->ParseEnding.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_PARSEENDED:
        if ( Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL )
        {
            PACTCTXCTB_CBPARSEENDED pParseEnded = reinterpret_cast<PACTCTXCTB_CBPARSEENDED>(Data);
            CSecurityMetaData *psmdSecurity =
                reinterpret_cast<CSecurityMetaData*>(pParseEnded->AssemblyContext->SecurityMetaData);
            CTeeStreamWithHash *pTeeStreamWithHash =
                reinterpret_cast<CTeeStreamWithHash*>(pParseEnded->AssemblyContext->TeeStreamForManifestInstall);
            CFusionArray<BYTE> baManifestHashBytes;

        
            if ( ( psmdSecurity != NULL ) && ( pTeeStreamWithHash != NULL ) )
            {
                IFW32FALSE_EXIT(baManifestHashBytes.Win32Initialize());
                IFW32FALSE_EXIT(pTeeStreamWithHash->GetCryptHash().Win32GetValue(baManifestHashBytes));
                IFW32FALSE_EXIT(psmdSecurity->SetManifestHash( baManifestHashBytes ));
            }
        }
        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
        {
            IFALLOCFAILED_EXIT(DllRedirectionContext = new DLL_REDIRECTION_CONTEXT);
            IFW32FALSE_EXIT(::SxsInitStringSectionGenerationContext(
                    &m_SSGenContext,
                    ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_FORMAT_WHISTLER,
                    TRUE,
                    &::SxspDllRedirectionStringSectionGenerationCallback,
                    DllRedirectionContext));
            DllRedirectionContext = NULL;
        }
        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL)
        {
            IFW32FALSE_EXIT(this->BeginInstall(Data));
        }

        Data->GenBeginning.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDING:
        Data->GenEnding.Success = FALSE;

        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL)
            IFW32FALSE_EXIT(this->EndInstall(Data));

        Data->GenEnding.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (m_SSGenContext != NULL)
            ::SxsDestroyStringSectionGenerationContext(m_SSGenContext);

        if (DllRedirectionContext != NULL)
            FUSION_DELETE_SINGLETON(DllRedirectionContext);

        m_SSGenContext = NULL;
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;

        if (SSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingStringSectionGenerationContext(SSGenContext));

        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;
        INTERNAL_ERROR_CHECK(SSGenContext);
        IFW32FALSE_EXIT(::SxsGetStringSectionGenerationContextSectionSize(SSGenContext, &Data->GetSectionSize.SectionSize));
        Data->GetSectionSize.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        {
            Data->ElementParsed.Success = FALSE;

            ULONG MappedValue = 0;
            bool fFound = false;

            enum MappedValues
            {
                eAssembly,
                eAssemblyFile,
            };

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] =
            {
                { 1, L"urn:schemas-microsoft-com:asm.v1^assembly",      NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly")      - 1, eAssembly },
                { 2, L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file", NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file") - 1, eAssemblyFile },
            };

            IFW32FALSE_EXIT(
                ::SxspProcessElementPathMap(
                    Data->ElementParsed.ParseContext,
                    s_rgEntries,
                    NUMBER_OF(s_rgEntries),
                    MappedValue,
                    fFound));

            if (fFound)
            {
                switch (MappedValue)
                {
                default:
                    INTERNAL_ERROR_CHECK2(
                        FALSE,
                        "Invalid mapped value returned from SxspProcessElementPathMap()");

                case eAssembly:
                    break;

                case eAssemblyFile:
                    {
                        CSmallStringBuffer &FileNameBuffer = this->ContributorCallbackLocals.FileNameBuffer;
                        CSmallStringBuffer &LoadFromBuffer = this->ContributorCallbackLocals.LoadFromBuffer;
                        CSmallStringBuffer &HashValueBuffer = this->ContributorCallbackLocals.HashValueBuffer;
                        SIZE_T cb = 0;
                        bool rfFileNameValid = false;

                        // We look for required attributes etc first so that if we're only parsing, it's
                        // common code.

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
                                &s_AttributeName_name,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(FileNameBuffer),
                                &FileNameBuffer,
                                cb,
                                NULL,
                                0));
                        INTERNAL_ERROR_CHECK(fFound);

                        IFW32FALSE_EXIT(::SxspIsFileNameValidForManifest(FileNameBuffer, rfFileNameValid));
                        if (!rfFileNameValid)
                        {
                            (*Data->ElementParsed.ParseContext->ErrorCallbacks.InvalidAttributeValue)(
                                Data->ElementParsed.ParseContext,
                                &s_AttributeName_name);

                            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                            goto Exit;
                        }

                        //
                        // Ensure that the hash string is valid
                        //
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_hash,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(HashValueBuffer),
                                &HashValueBuffer,
                                cb,
                                NULL,
                                0));

                        //
                        // Odd numbers of characters in the hash string will be bad later.
                        //
                        if (fFound && (HashValueBuffer.Cch() % 2))
                        {
                            (*Data->ElementParsed.ParseContext->ErrorCallbacks.InvalidAttributeValue)(
                                Data->ElementParsed.ParseContext,
                                &s_AttributeName_hash);

                            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                            goto Exit;
                        }

                        //
                        // And that the hash-alg string is valid too
                        //
                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_hashalg,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(HashValueBuffer),
                                &HashValueBuffer,
                                cb,
                                NULL,
                                0));

                        if (fFound)
                        {
                            ALG_ID aid;
                            if (!::SxspHashAlgFromString(HashValueBuffer, aid))
                            {
                                (*Data->ElementParsed.ParseContext->ErrorCallbacks.InvalidAttributeValue)(
                                    Data->ElementParsed.ParseContext,
                                    &s_AttributeName_hashalg);

                                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                                goto Exit;
                            }
                        }

                        IFW32FALSE_EXIT(
                            ::SxspGetAttributeValue(
                                0,
                                &s_AttributeName_loadFrom,
                                &Data->ElementParsed,
                                fFound,
                                sizeof(LoadFromBuffer),
                                &LoadFromBuffer,
                                cb,
                                NULL,
                                0));

                        if (fFound)
                        {
                            // We're not allowed to install assemblies that have a loadFrom= and the only
                            // manifests with them that we can activate are ones that don't live in the assembly store.
                            if ((Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL) ||
                                ((Data->ElementParsed.AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_ROOT_ASSEMBLY) == 0))
                            {
                                // You can't install an assembly with a loadfrom=foo file; it's only provided for
                                // app compat...
                                (*Data->ElementParsed.ParseContext->ErrorCallbacks.AttributeNotAllowed)(
                                    Data->ElementParsed.ParseContext,
                                    &s_AttributeName_loadFrom);

                                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                                goto Exit;
                            }
                        }


                        //
                        // Always update the file count.
                        //
                        ASSERT(Data->Header.ActCtxGenContext != NULL);
                        if (Data->Header.ActCtxGenContext)
                        {
                            Data->Header.pOriginalActCtxGenCtx->m_ulFileCount++;
                        }

                        // If we're installing, call back to the copy function
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_INSTALL)
                            IFW32FALSE_EXIT(this->InstallFile(Data, FileNameBuffer));

                        // If we are generating an activation context, add it to the context.
                        if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                        {
                            IFALLOCFAILED_EXIT(Entry = new DLL_REDIRECTION_ENTRY);

                            IFW32FALSE_EXIT(Entry->FileNameBuffer.Win32Assign(FileNameBuffer, FileNameBuffer.Cch()));

                            if (LoadFromBuffer.Cch() != 0)
                            {
                                Entry->AssemblyPathBuffer.Win32Assign(LoadFromBuffer, LoadFromBuffer.Cch());
                                Entry->AssemblyPathIsLoadFrom = true;

                                // If the value does not end in a slash, we assume it directly refers to
                                // a file.
                                if (!LoadFromBuffer.HasTrailingPathSeparator())
                                    Entry->PathIncludesBaseName = true;
                            }
                            // for system default, we have a duplicate entry if this dll also exists under %windir%\system32.
                            if (Data->Header.Flags & SXS_GENERATE_ACTCTX_SYSTEM_DEFAULT)
                            {
                                CSmallStringBuffer &DllUnderSystem32 = this->ContributorCallbackLocals.DllUnderSystem32;
                                CStringBufferAccessor sba;
                                sba.Attach(&DllUnderSystem32);

                                DWORD dwNecessary =::ExpandEnvironmentStringsW(
                                        L"%windir%\\system32\\", 
                                        sba.GetBufferPtr(), 
                                        sba.GetBufferCchAsDWORD() - 1);

                                if ((dwNecessary == 0 ) || (dwNecessary >= (sba.GetBufferCch() - 1)))
                                {
                                    // error case : it is weird for 64 bytes buffer is too small for system directory
                                   ::FusionpDbgPrintEx(
                                        FUSION_DBG_LEVEL_ERROR,
                                        "SXS.DLL: %s: ExpandEnvironmentStringsW() for %windir%\\system32 failed with lastError=%d\n",
                                        __FUNCTION__,
                                        static_cast<PCWSTR>(DllUnderSystem32),
                                        ::GetLastError()
                                        );
                                    goto Exit;
                                }
                                sba.Detach();

                                IFW32FALSE_EXIT(DllUnderSystem32.Win32Append(FileNameBuffer, FileNameBuffer.Cch()));

                                bool fExist = false;
                                //
                                // create another new entry and insert it into the section
                                //

                                IFALLOCFAILED_EXIT(SystemDefaultEntry = new DLL_REDIRECTION_ENTRY);

                                IFW32FALSE_EXIT(SystemDefaultEntry->FileNameBuffer.Win32Assign(DllUnderSystem32, DllUnderSystem32.Cch()));

                                // copy from Entry except FileNameBuffer
                                SystemDefaultEntry->AssemblyPathBuffer.Win32Assign(Entry->AssemblyPathBuffer, Entry->AssemblyPathBuffer.Cch());
                                SystemDefaultEntry->AssemblyPathIsLoadFrom = Entry->AssemblyPathIsLoadFrom;

                                SystemDefaultEntry->PathIncludesBaseName = Entry->PathIncludesBaseName;
                                SystemDefaultEntry->SystemDefaultRedirectedSystem32Dll = true;

#ifdef _WIN64
                                // check whether it is a wow64
                                const WCHAR *Value = NULL;
                                SIZE_T Cch = 0;
                                bool rfWow64 = false;
                                IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
                                    SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, 
                                    Data->ElementParsed.AssemblyContext->AssemblyIdentity, 
                                    &s_IdentityAttribute_processorArchitecture, &Value, &Cch));
                                if (Cch == 5)
                                {
                                    INTERNAL_ERROR_CHECK(Value != NULL);

                                    if (((Value[0] == L'w') || (Value[0] == L'W')) &&
                                        ((Value[1] == L'o') || (Value[1] == L'O')) &&
                                        ((Value[2] == L'w') || (Value[2] == L'W')) &&
                                        (Value[3] == L'6') &&
                                        (Value[4] == L'4'))
                                        rfWow64 = true;
                                }
                                if (!rfWow64)
                                {
                                    if (Cch == 3)
                                    {
                                        INTERNAL_ERROR_CHECK(Value != NULL);

                                        if (((Value[0] == L'X') || (Value[0] == L'x')) &&
                                            (Value[1] == L'8') &&
                                            (Value[2] == L'6'))
                                            rfWow64 = true;
                                    }
                                }
                                if (rfWow64)
                                {
                                    CSmallStringBuffer &DllUnderSyswow64 = this->ContributorCallbackLocals.DllUnderSyswow64;
                                    CStringBufferAccessor sba2;
                                    sba2.Attach(&DllUnderSyswow64);

                                    DWORD dwSyswow64 = ::GetSystemWow64DirectoryW(sba2.GetBufferPtr(), sba2.GetBufferCchAsDWORD() - 1);

                                    if ((dwSyswow64 == 0 ) || (dwSyswow64 >= (sba2.GetBufferCch() - 1)))
                                    {
                                        // error case : it is weird for 64 bytes buffer is too small for system directory
                                       ::FusionpDbgPrintEx(
                                            FUSION_DBG_LEVEL_ERROR,
                                            "SXS.DLL: %s: get %windir%\\syswow64 failed with lastError=%d\n",
                                            __FUNCTION__,
                                            static_cast<PCWSTR>(DllUnderSyswow64),
                                            ::GetLastError()
                                            );
                                        goto Exit;
                                    }
                                    sba2.Detach();

                                    IFW32FALSE_EXIT(DllUnderSyswow64.Win32EnsureTrailingPathSeparator()); // for syswow64
                                    IFW32FALSE_EXIT(DllUnderSyswow64.Win32Append(FileNameBuffer, FileNameBuffer.Cch()));
                                    
                                    IFALLOCFAILED_EXIT(Syswow64DefaultEntry = new DLL_REDIRECTION_ENTRY);

                                    IFW32FALSE_EXIT(Syswow64DefaultEntry->FileNameBuffer.Win32Assign(DllUnderSyswow64, DllUnderSyswow64.Cch()));

                                    // copy from Entry except FileNameBuffer
                                    Syswow64DefaultEntry->AssemblyPathBuffer.Win32Assign(Entry->AssemblyPathBuffer, Entry->AssemblyPathBuffer.Cch());
                                    Syswow64DefaultEntry->AssemblyPathIsLoadFrom = Entry->AssemblyPathIsLoadFrom;

                                    Syswow64DefaultEntry->PathIncludesBaseName = Entry->PathIncludesBaseName;
                                    Syswow64DefaultEntry->SystemDefaultRedirectedSystem32Dll = true;
                                    
                                }
#endif
                            }
                            if (Entry)
                            {

                                if (!::SxsAddStringToStringSectionGenerationContext(
                                            (PSTRING_SECTION_GENERATION_CONTEXT) m_SSGenContext,
                                            Entry->FileNameBuffer,
                                            Entry->FileNameBuffer.Cch(),
                                            Entry,
                                            Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                            ERROR_SXS_DUPLICATE_DLL_NAME))
                                {
                                    ::FusionpLogError(
                                        MSG_SXS_DLLREDIR_CONTRIB_ADD_FILE_MAP_ENTRY,
                                        CUnicodeString(Entry->FileNameBuffer, Entry->FileNameBuffer.Cch()),
                                        CEventLogLastError());
                                    goto Exit;
                                }
                            
                                Entry = NULL;
                            }

                            if(SystemDefaultEntry)
                            {
                                if (!::SxsAddStringToStringSectionGenerationContext(
                                            (PSTRING_SECTION_GENERATION_CONTEXT) m_SSGenContext,
                                            SystemDefaultEntry->FileNameBuffer,
                                            SystemDefaultEntry->FileNameBuffer.Cch(),
                                            SystemDefaultEntry,
                                            Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                            ERROR_SXS_DUPLICATE_DLL_NAME))
                                {
                                    ::FusionpLogError(
                                        MSG_SXS_DLLREDIR_CONTRIB_ADD_FILE_MAP_ENTRY,
                                        CUnicodeString(SystemDefaultEntry->FileNameBuffer, SystemDefaultEntry->FileNameBuffer.Cch()),
                                        CEventLogLastError());
                                    goto Exit;
                                }
                            
                                SystemDefaultEntry = NULL;                               
                            }

#ifdef _WIN64
                            if (Syswow64DefaultEntry)
                            {
                                if (!::SxsAddStringToStringSectionGenerationContext(
                                            (PSTRING_SECTION_GENERATION_CONTEXT) m_SSGenContext,
                                            Syswow64DefaultEntry->FileNameBuffer,
                                            Syswow64DefaultEntry->FileNameBuffer.Cch(),
                                            Syswow64DefaultEntry,
                                            Data->ElementParsed.AssemblyContext->AssemblyRosterIndex,
                                            ERROR_SXS_DUPLICATE_DLL_NAME))
                                {
                                    ::FusionpLogError(
                                        MSG_SXS_DLLREDIR_CONTRIB_ADD_FILE_MAP_ENTRY,
                                        CUnicodeString(Syswow64DefaultEntry->FileNameBuffer, Syswow64DefaultEntry->FileNameBuffer.Cch()),
                                        CEventLogLastError());
                                    goto Exit;
                                }                           

                                Syswow64DefaultEntry = NULL;
                            }
#endif                            
                        }
                    }
                    break;
                }
            }

        }
        // Everything's groovy!
        Data->ElementParsed.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;
        IFW32FALSE_EXIT(::SxsGetStringSectionGenerationContextSectionData(
                m_SSGenContext,
                Data->GetSectionData.SectionSize,
                Data->GetSectionData.SectionDataStart,
                NULL));
        Data->GetSectionData.Success = TRUE;
        break;
    }

Exit:
    FUSION_DELETE_SINGLETON(Entry);
    FUSION_DELETE_SINGLETON(SystemDefaultEntry);
    FUSION_DELETE_SINGLETON(Syswow64DefaultEntry);
}

BOOL
SxspDllRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;

    switch (Reason)
    {
    default:
        goto Exit;

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE:
    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA:
        // will use the user data area later to store common paths
        break;

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PDLL_REDIRECTION_ENTRY Entry = (PDLL_REDIRECTION_ENTRY) CBData->DataContext;
            FUSION_DELETE_SINGLETON(Entry);
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PDLL_REDIRECTION_ENTRY Entry = (PDLL_REDIRECTION_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION);

            if (Entry->AssemblyPathBuffer.Cch() != 0)
            {
                CBData->DataSize += sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT);
                CBData->DataSize += (Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR));
            }

            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PDLL_REDIRECTION_ENTRY Entry = (PDLL_REDIRECTION_ENTRY) CBData->DataContext;
            PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Info;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;
            PVOID Cursor;

            Info = (PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION) CBData->Buffer;
            Cursor = (PVOID) (Info + 1);

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION);
            Info->Flags = 0;
            Info->TotalPathLength = static_cast<ULONG>(Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR));

            if (Entry->PathIncludesBaseName)
                Info->Flags |= ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME;

            if (Entry->SystemDefaultRedirectedSystem32Dll)
                Info->Flags |= ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SYSTEM_DEFAULT_REDIRECTED_SYSTEM32_DLL;


            if (Entry->AssemblyPathBuffer.Cch() == 0)
            {
                // If there's no path, there's no segments!
                Info->PathSegmentCount = 0;
                Info->PathSegmentOffset = 0;
                Info->Flags |= ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT;
            }
            else
            {
                PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT Segment;

                Info->PathSegmentCount = 1;
                Info->PathSegmentOffset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) CBData->SectionHeader));

                // If this is a loadfrom="foo" file and the string contains a %, set the expand flag...
                if ((Entry->AssemblyPathIsLoadFrom) && (Entry->AssemblyPathBuffer.ContainsCharacter(L'%')))
                    Info->Flags |= ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND;

                Segment = (PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT) Cursor;
                Cursor = (PVOID) (Segment + 1);

                if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT))
                {
                    ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT);
                BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT);

                Segment->Length = Info->TotalPathLength;
                Segment->Offset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) CBData->SectionHeader));

                if (BytesLeft < (Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR)))
                {
                    ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                BytesWritten += (Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR));
                BytesLeft -= (Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR));

                memcpy(Cursor, static_cast<PCWSTR>(Entry->AssemblyPathBuffer), Entry->AssemblyPathBuffer.Cch() * sizeof(WCHAR));
            }

            CBData->BytesWritten = BytesWritten;
        }

    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\filestream.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    filestream.cpp

Abstract:

    Implementation of IStream over a win32 file.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "filestream.h"
#include "sxsexceptionhandling.h"

CFileStreamBase::CFileStreamBase() : m_cRef(0), m_hFile(INVALID_HANDLE_VALUE), m_grfMode(0)
{
}

CFileStreamBase::~CFileStreamBase()
{
    ASSERT_NTC(m_cRef == 0);

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CSxsPreserveLastError ple;
        if ((m_grfMode & STGM_WRITE) == STGM_WRITE)
            ::FlushFileBuffers(m_hFile);
        ::CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
        ple.Restore();
    }
}

BOOL
CFileStreamBase::OpenForWrite(
    PCWSTR pszPath,
    DWORD dwShareMode,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_hFile == INVALID_HANDLE_VALUE);

    PARAMETER_CHECK(pszPath != NULL);

    IFW32INVALIDHANDLE_ORIGINATE_AND_EXIT(
		m_hFile = ::CreateFileW(
			pszPath,
			GENERIC_WRITE,
			dwShareMode,
			NULL,
			dwCreationDisposition, // default value is CREATE_ALWAYS
			dwFlagsAndAttributes,
			NULL));

    m_grfMode = STGM_WRITE | STGM_CREATE;

	FN_EPILOG
}

BOOL
CFileStreamBase::OpenForRead(
    PCWSTR pszPath,
    const CImpersonationData &ImpersonationData,
    DWORD dwShareMode,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes
    )
{
    DWORD dwWin32Error;

    return 
        this->OpenForRead(
            pszPath, 
            ImpersonationData, 
            dwShareMode, 
            dwCreationDisposition, 
            dwFlagsAndAttributes,
            dwWin32Error,
            0);
}

BOOL
CFileStreamBase::OpenForRead(
    PCWSTR pszPath,
    const CImpersonationData &ImpersonationData,
    DWORD dwShareMode,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    DWORD &rdwLastError,
    SIZE_T cExceptionalLastErrors,
    ...
    )
{
    FN_PROLOG_WIN32
    DWORD dwLastError = ERROR_INTERNAL_ERROR;
    CImpersonate impersonate(ImpersonationData);

    rdwLastError = ERROR_SUCCESS;

    PARAMETER_CHECK(pszPath != NULL);
    INTERNAL_ERROR_CHECK(m_hFile == INVALID_HANDLE_VALUE);

    IFW32FALSE_EXIT(impersonate.Impersonate());

	::FusionpSetLastWin32Error(ERROR_SUCCESS);

    m_hFile = ::CreateFileW(
        pszPath,
        GENERIC_READ,
        dwShareMode,
        NULL,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        NULL);

    dwLastError = ::FusionpGetLastWin32Error();

    IFW32FALSE_EXIT(impersonate.Unimpersonate());
    m_grfMode = STGM_READ;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        va_list ap;
        SIZE_T i = 0;

        if (dwLastError == ERROR_SUCCESS) 
        {
            //
            // CreateFile always set lasterror to be 0 for an unexisted file even OPEN_EXISTING 
            // for GENERIC_READ, Fusion expect ERROR_FILE_NOT_FOUND in this case for some reason
            //
            ::FusionpSetLastWin32Error(ERROR_FILE_NOT_FOUND);
            dwLastError = ERROR_FILE_NOT_FOUND; // reset lLastError
        }

        va_start(ap, cExceptionalLastErrors);
        for (i=0; i<cExceptionalLastErrors; i++)
        {
            if (dwLastError == va_arg(ap, DWORD))
            {
                rdwLastError = dwLastError;
                break;
            }
        }
        va_end(ap);
        if (i == cExceptionalLastErrors) // This gets the cExceptionalLastErrors == 0 case too.
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(%ls) gave error %ld\n",
                __FUNCTION__,
                pszPath,
				dwLastError);
            ORIGINATE_WIN32_FAILURE_AND_EXIT(CreateFileW, dwLastError);
        }
    }

	FN_EPILOG
}

BOOL
CFileStreamBase::Close()
{
    FN_PROLOG_WIN32

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        if ((m_grfMode & STGM_WRITE) == STGM_WRITE)
        {
            if (!::FlushFileBuffers(m_hFile))
            {
                const DWORD dwLastError = ::FusionpGetLastWin32Error();
                ::CloseHandle(m_hFile);
                m_hFile = INVALID_HANDLE_VALUE;
                ORIGINATE_WIN32_FAILURE_AND_EXIT(FlushFileBuffers, dwLastError);
            }
        }

        if (!::CloseHandle(m_hFile))
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();
            m_hFile = INVALID_HANDLE_VALUE;
            ORIGINATE_WIN32_FAILURE_AND_EXIT(CloseHandle, dwLastError);
        }

        m_hFile = INVALID_HANDLE_VALUE;
    }

    FN_EPILOG
}

ULONG
CFileStreamBase::AddRef()
{
    return ::InterlockedIncrement((LONG *) &m_cRef);
}

ULONG
CFileStreamBase::Release()
{
    ULONG ulRefCount = ::InterlockedDecrement((LONG *) &m_cRef);
    if (ulRefCount == 0)
        this->OnRefCountZero();
    return ulRefCount;
}

HRESULT
CFileStreamBase::QueryInterface(
    REFIID riid,
    PVOID *ppvObj
    )
{
    FN_PROLOG_HR

    IUnknown *pIUnknown = NULL;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    if (ppvObj == NULL)
        ORIGINATE_HR_FAILURE_AND_EXIT(OutPointerWasNull, E_POINTER);

    if ((riid == IID_IUnknown) ||
        (riid == IID_ISequentialStream) ||
        (riid == IID_IStream))
        pIUnknown = static_cast<IStream *>(this);

    if (pIUnknown == NULL)
        ORIGINATE_HR_FAILURE_AND_EXIT(NoInterface, E_NOINTERFACE);

    pIUnknown->AddRef();
    *ppvObj = pIUnknown;

    FN_EPILOG
}


HRESULT
CFileStreamBase::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    ULONG cbRead = 0;

    if (pcbRead != NULL)
        *pcbRead = 0;

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);

    IFW32FALSE_ORIGINATE_AND_EXIT(::ReadFile(m_hFile, pv, cb, &cbRead, NULL));

    if (pcbRead != NULL)
        *pcbRead = cbRead;

    if (cbRead == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Write(
    void const *pv,
    ULONG cb,
    ULONG *pcbWritten
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    ULONG cbWritten = 0;

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);

    PARAMETER_CHECK((cb == 0) || (pv != NULL));

    IFW32FALSE_ORIGINATE_AND_EXIT(::WriteFile(m_hFile, pv, cb, &cbWritten, NULL));

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

    if (cbWritten == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    DWORD dwWin32Origin = 0;

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);

    switch (dwOrigin)
    {
    default:
        hr = E_INVALIDARG;
        goto Exit;

    case STREAM_SEEK_SET:
        dwWin32Origin = FILE_BEGIN;
        break;

    case STREAM_SEEK_CUR:
        dwWin32Origin = FILE_CURRENT;
        break;

    case STREAM_SEEK_END:
        dwWin32Origin = FILE_END;
        break;
    }

    if (!::SetFilePointerEx(
                m_hFile,
                dlibMove,
                (LARGE_INTEGER *) plibNewPosition,
                dwWin32Origin))
    {
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CFileStreamBase::SetSize(
    ULARGE_INTEGER libNewSize
    )
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::SetSize() !!! NOT IMPLEMENTED !!!\n");

    UNUSED(libNewSize);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten
    )
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::CopyTo() !!! NOT IMPLEMENTED !!!\n");

    if (pcbRead != NULL)
        pcbRead->QuadPart = 0;

    if (pcbWritten != NULL)
        pcbWritten->QuadPart = 0;

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Commit(
    DWORD grfCommitFlags
    )
{
    HRESULT hr = NOERROR;

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: Entered CFileStreamBase::Commit()\n");

    if (grfCommitFlags != 0)
        return E_INVALIDARG;

    if ( !Close())
        hr = HRESULT_FROM_WIN32 (::FusionpGetLastWin32Error());

    if (!SUCCEEDED(hr))
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s() failed; ::FusionpGetLastWin32Error() = %d\n", __FUNCTION__, ::FusionpGetLastWin32Error());
    else
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SXS.DLL: Leaving %s()\n", __FUNCTION__);

    return hr ;
}

HRESULT
CFileStreamBase::Revert()
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::Revert() !!! NOT IMPLEMENTED !!!\n");

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::LockRegion() !!! NOT IMPLEMENTED !!!\n");

    UNUSED(libOffset);
    UNUSED(cb);
    UNUSED(dwLockType);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::UnlockRegion() !!! NOT IMPLEMENTED !!!\n");

    UNUSED(libOffset);
    UNUSED(cb);
    UNUSED(dwLockType);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag
    )
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
    FN_TRACE_HR(hr);
    BY_HANDLE_FILE_INFORMATION bhfi;

    if (pstatstg != NULL)
        memset(pstatstg, 0, sizeof(*pstatstg));

    PARAMETER_CHECK(((grfStatFlag & ~(STATFLAG_NONAME)) == 0));
    PARAMETER_CHECK(pstatstg != NULL);

    if (!(grfStatFlag & STATFLAG_NONAME))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s() does not handle STATFLAG_NONE; returning E_NOTIMPL.\n", __FUNCTION__);
        hr = E_NOTIMPL;
        goto Exit;
    }

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);
    IFW32FALSE_ORIGINATE_AND_EXIT(::GetFileInformationByHandle(m_hFile, &bhfi));

    pstatstg->pwcsName = NULL;
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.LowPart = bhfi.nFileSizeLow;
    pstatstg->cbSize.HighPart = bhfi.nFileSizeHigh;
    pstatstg->mtime = bhfi.ftLastWriteTime;
    pstatstg->ctime = bhfi.ftCreationTime;
    pstatstg->atime = bhfi.ftLastAccessTime;
    pstatstg->grfMode = m_grfMode;
    pstatstg->grfLocksSupported = LOCK_WRITE;
    pstatstg->clsid = GUID_NULL;
    pstatstg->grfStateBits = 0;
    pstatstg->reserved = 0;

    hr = NOERROR;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Clone(
    IStream **ppIStream
    )
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS.DLL: Entered CFileStreamBase::Clone() !!! NOT IMPLEMENTED !!!\n");

    if (ppIStream != NULL)
        *ppIStream = NULL;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cteestream.h ===
#if !defined(_FUSION_SXS_CTEESTREAM_H_INCLUDED_)
#define _FUSION_SXS_CTEESTREAM_H_INCLUDED_

/*++

Copyright (c) Microsoft Corporation

Module Name:

    CTeeStream.h

Abstract:

This implementation of IStream is intended for when you want to copy the
stream you are reading to a file.

We read from a stream you specify.
We write to a file you specify.
You can delay specifying the file; we buffer anything read until you specify
a file; we actually needed this delay feature in the first client of
CTeeStream.

The Unix utility tee writes it standard input to its standard output, and
to the specified file (or files?); "tee" as in a fork in a road, or a juncture
in pipes (the input/output kind, analogous to the kind that water flows through..
ascii text is computer water..)

A simple working tee can be found at \\scratch\scratch\a-JayK\t.c

Author:

    Jay Krell (a-JayK, JayKrell) May 2000

Revision History:

--*/
#pragma once

#include "fusionhandle.h"
#include "fusionbytebuffer.h"
#include "smartref.h"
#include "sxsp.h"

class CTeeStream : public IStream
{
public:
    inline CTeeStream() : m_cRef(0), m_fBuffer(TRUE), m_hresult(NOERROR) { }
    virtual ~CTeeStream();

    VOID SetSource(IStream*);

    BOOL SetSink(
        const CImpersonationData &ImpersonationData,
        const CBaseStringBuffer &rbuff,
        DWORD openOrCreate = CREATE_NEW
        );

    BOOL SetSink(const CBaseStringBuffer &rbuff, DWORD openOrCreate = CREATE_NEW)
    {
        return this->SetSink(CImpersonationData(), rbuff, openOrCreate);
    }

    BOOL Close();

    // IUnknown methods:
    virtual ULONG __stdcall AddRef();
    virtual ULONG __stdcall Release();
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    virtual HRESULT __stdcall Read(PVOID pv, ULONG cb, ULONG *pcbRead);
    virtual HRESULT __stdcall Write(const VOID *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    virtual HRESULT __stdcall Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    virtual HRESULT __stdcall SetSize(ULARGE_INTEGER libNewSize);
    virtual HRESULT __stdcall CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    virtual HRESULT __stdcall Commit(DWORD grfCommitFlags);
    virtual HRESULT __stdcall Revert();
    virtual HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    virtual HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    virtual HRESULT __stdcall Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    virtual HRESULT __stdcall Clone(IStream **ppIStream);

protected:
    LONG                m_cRef;
    CFusionFile         m_fileSink;
    CByteBuffer         m_buffer;
    CSmartRef<IStream>  m_streamSource;
    BOOL                m_fBuffer;
    HRESULT             m_hresult;
    CStringBuffer       m_bufferSinkPath;
    CImpersonationData  m_ImpersonationData;

private: // intentionally not implemented
    CTeeStream(const CTeeStream&);
    void operator=(const CTeeStream&);
};

#endif // !defined(_FUSION_SXS_CTEESTREAM_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\cteestream.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    cteestream.cpp

Abstract:

    See cteestream.h.

Author:

    Jay Krell (a-JayK, JayKrell) May 2000

Revision History:

--*/
#include "stdinc.h"
#include "cteestream.h"
#include "sxsp.h"
#include "sxsexceptionhandling.h"

CTeeStream::~CTeeStream()
{
    FN_TRACE();
    CSxsPreserveLastError ple;

    ASSERT(m_cRef == 0);
    m_streamSource.Release();

    if (!m_fileSink.Win32Close())
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s(): m_fileSink.Close(%ls) failed: %ld\n",
            __FUNCTION__,
            static_cast<PCWSTR>(m_bufferSinkPath),
            ::FusionpGetLastWin32Error());
    }

    if (FAILED(m_hresult))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SXS.DLL: %s():deleting %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(m_bufferSinkPath));

        if (!::DeleteFileW(m_bufferSinkPath))
        {
            FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s():DeleteFileW(%ls) failed:%ld\n",
                __FUNCTION__,
                static_cast<PCWSTR>(m_bufferSinkPath),
                ::FusionpGetLastWin32Error());
        }
    }

    ple.Restore();
}

VOID
CTeeStream::SetSource(IStream *streamSource)
{
    FN_TRACE();

    m_streamSource = streamSource;
}

BOOL
CTeeStream::SetSink(
    const CImpersonationData &ImpersonationData,
    const CBaseStringBuffer &rbuff,
    DWORD openOrCreate
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    DWORD dwBytesWritten = 0;
    DWORD dwBufferSize = 0;
    BOOL fFailForCreateFile = FALSE;

    IFCOMFAILED_EXIT(m_hresult);

    IFW32FALSE_EXIT(m_bufferSinkPath.Win32Assign(rbuff));

    m_ImpersonationData = ImpersonationData;

    {
        CImpersonate impersonate(ImpersonationData);
        IFW32FALSE_EXIT(impersonate.Impersonate());
        IFW32FALSE_EXIT_UNLESS(m_fileSink.Win32CreateFile(m_bufferSinkPath, GENERIC_WRITE, 0/*share*/, openOrCreate),
            ::FusionpGetLastWin32Error() == ERROR_FILE_EXISTS,
            fFailForCreateFile);
        if (fFailForCreateFile)  // the file has existed, have to reopen in order do not break
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SOFT_VERIFY FAILURE : An Existing manifest is tried to be opened for write again, file a BUG!\n");

            IFW32FALSE_EXIT(m_fileSink.Win32CreateFile(m_bufferSinkPath, GENERIC_WRITE, 0/*share*/, CREATE_ALWAYS));
        }


        IFW32FALSE_EXIT(impersonate.Unimpersonate());
    }

    dwBufferSize = static_cast<DWORD>(m_buffer.GetCurrentCb());
    fSuccess = TRUE;
    if (dwBufferSize > 0)
    {
        fSuccess = WriteFile(m_fileSink, m_buffer, dwBufferSize, &dwBytesWritten, NULL/*overlapped*/);
        DWORD dwLastError = fSuccess ? ERROR_SUCCESS : ::FusionpGetLastWin32Error();
        // I'm not entirely sure why we mask the lasterror of the write
        // if it "succeeded" in writing the wrong number of bytes, but
        // such as it is, this is a write fault (The system cannot write
        // to the specified device.)
        if (fSuccess && dwBytesWritten != dwBufferSize)
        {
            dwLastError = ERROR_WRITE_FAULT;
            fSuccess = FALSE;
        }

		m_fBuffer = FALSE;

		if (dwLastError != ERROR_SUCCESS)
			ORIGINATE_WIN32_FAILURE_AND_EXIT(WriteFile, dwLastError);
    }
    m_fBuffer = FALSE;
Exit:
    if (!fSuccess)
    {
        DWORD dwLastError = ::FusionpGetLastWin32Error();
        m_hresult = ::FusionpHresultFromLastError();
        m_buffer.Clear(true);
        ::FusionpSetLastWin32Error(dwLastError);
    }
    else
        m_buffer.Clear(true);
    return fSuccess;
}

BOOL
CTeeStream::Close()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    IFCOMFAILED_EXIT(m_hresult);

    IFW32FALSE_EXIT(m_fileSink.Win32Close());

    // ? m_streamSource.Release();

    fSuccess = TRUE;
Exit:
    if (!fSuccess)
        m_hresult = ::FusionpHresultFromLastError();

    return fSuccess;
}

ULONG __stdcall
CTeeStream::AddRef()
{
    FN_TRACE();
    return ::InterlockedIncrement(&m_cRef);
}

ULONG __stdcall
CTeeStream::Release()
{
    FN_TRACE();

    LONG cRef;
    if ((cRef = ::InterlockedDecrement(&m_cRef)) == 0)
    {
        /*delete this*/;
    }
    return cRef;
}

HRESULT __stdcall
CTeeStream::QueryInterface(
    REFIID  iid,
    PVOID *ppvObj
    )
{
    IUnknown *punk = NULL;
    IUnknown **ppunk = reinterpret_cast<IUnknown **>(ppvObj);
    *ppunk = NULL;
    if (false) { }
#define QI(i) else if (iid == __uuidof(i)) punk = static_cast<i*>(this);
    QI(IUnknown)
    QI(ISequentialStream)
    QI(IStream)
#undef QI
    else return E_NOINTERFACE;
    AddRef();
    *ppunk = punk;
    return NOERROR;
}

HRESULT __stdcall
CTeeStream::Read(PVOID pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;

    FN_TRACE_HR(hr);

    ULONG cbRead;

    if (pcbRead != NULL)
        *pcbRead = 0;

    IFCOMFAILED_ORIGINATE_AND_EXIT(m_hresult);
    IFCOMFAILED_EXIT(m_streamSource->Read(pv, cb, &cbRead));

    if (m_fBuffer)
    {
        IFCOMFAILED_EXIT(m_buffer.Append(reinterpret_cast<const BYTE*>(pv), cbRead));
    }
    else
    {
        DWORD dwBytesWritten = 0;
        BOOL fSuccess = (cbRead == 0) || ::WriteFile(m_fileSink, pv, cbRead, &dwBytesWritten, NULL/*overlapped*/);

        if (!fSuccess)
        {
			TRACE_WIN32_FAILURE_ORIGINATION(WriteFile);

            hr = ::FusionpHresultFromLastError();
            goto Exit;
        }
        else if (dwBytesWritten != cbRead)
        {
            hr = E_FAIL;
            goto Exit;
        }
    }

    if (pcbRead != NULL)
        *pcbRead = cbRead;

    hr = NOERROR;

Exit:
    if (FAILED(hr))
        m_hresult = hr;

    return hr;
}

HRESULT __stdcall
CTeeStream::Write(
    const VOID *pv,
    ULONG cb,
    ULONG *pcbWritten
    )
{
    /*
    since this stream is really only for reading..
    */
    if (pcbWritten != NULL)
        *pcbWritten = 0;

    return E_NOTIMPL;
}

// IStream methods:
HRESULT __stdcall
CTeeStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    /*
    this messes up our ability to easily copy the stream, I think..
    */
    plibNewPosition->QuadPart = 0;
    return E_NOTIMPL;
}

HRESULT __stdcall
CTeeStream::SetSize(ULARGE_INTEGER libNewSize)
{
    /*
    this messes up our ability to easily copy the stream, I think..
    besides that, this is really a read only stream
    */
    return E_NOTIMPL;
}

HRESULT __stdcall
CTeeStream::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten)
{
    /*
    Implementing this requires getting the current seek pointer,
    call CopyTo
    seek back
    Read/Write
    seek forward
    because there is no buffer
    */
    pcbRead->QuadPart = 0;
    pcbWritten->QuadPart = 0;
    return E_NOTIMPL;
}

HRESULT __stdcall
CTeeStream::Commit(DWORD grfCommitFlags)
{
    /*
    since this stream is really only for reading..
    */
    return S_OK;
}

HRESULT __stdcall
CTeeStream::Revert()
{
    /*
    since this stream is really only for reading..
    */
    return S_OK;
}

HRESULT __stdcall
CTeeStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    /*
    since this stream is really only for reading..
    */
    return S_OK;
}

HRESULT __stdcall
CTeeStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    /*
    since this stream is really only for reading..
    */
    return S_OK;
}

HRESULT __stdcall
CTeeStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    HRESULT hr = m_streamSource->Stat(pstatstg, grfStatFlag);
    return hr;
}

HRESULT __stdcall
CTeeStream::Clone(IStream **ppIStream)
{
    *ppIStream = NULL;
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\filestream.h ===
#if !defined(_FUSION_SXS_FILESTREAM_H_INCLUDED_)
#define _FUSION_SXS_FILESTREAM_H_INCLUDED_

#pragma once

#include <objidl.h>
#include "impersonationdata.h"
#include "smartptr.h"

class CFileStreamBase : public IStream
{
public:
    CFileStreamBase();
    virtual ~CFileStreamBase();

    virtual VOID OnRefCountZero() { /* default does nothing */ }

    BOOL OpenForRead(
        PCWSTR pszPath,
        const CImpersonationData &ImpersonationData,
        DWORD dwShareMode,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes
        );

    BOOL OpenForRead(
        PCWSTR pszPath,
        const CImpersonationData &ImpersonationData,
        DWORD dwShareMode,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes,
        DWORD &rdwLastError,
        SIZE_T cExceptionalLastErrors,
        ...
        );

    BOOL OpenForWrite(
        PCWSTR pszPath,
        DWORD dwShareMode,
        DWORD dwCreationDisposition,
        DWORD dwFlagsAndAttributes
        );

    BOOL Close();

    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppIStream);

protected:
    ULONG               m_cRef;
    HANDLE              m_hFile;
    DWORD               m_grfMode;
private:
    CFileStreamBase(const CFileStreamBase &r); // intentionally not implemented
    CFileStreamBase &operator =(const CFileStreamBase &r); // intentionally not implemented
};

enum FileStreamZeroRefCountBehavior
{
    eDeleteFileStreamOnZeroRefCount,
    eDoNotDeleteFileStreamOnZeroRefCount,
};

template <FileStreamZeroRefCountBehavior ezrcb> class CFileStreamTemplate : public CFileStreamBase
{
    typedef CFileStreamBase Base;
public:
    CFileStreamTemplate() : Base() { }

    virtual VOID OnRefCountZero() {
        if (ezrcb == eDeleteFileStreamOnZeroRefCount)
            FUSION_DELETE_SINGLETON(this);
    }

private:
    CFileStreamTemplate(const CFileStreamTemplate&); // intentionally not implemented
    void operator=(const CFileStreamTemplate&); // intentionally not implemented
};

typedef CFileStreamBase CFileStream;
typedef CFileStreamTemplate<eDeleteFileStreamOnZeroRefCount> CReferenceCountedFileStream;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\guidsectgen.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "gsgenctx.h"

//
// ISSUE: jonwis 3/7/2002 - No parameter checking ANYWHERE??
// ISSUE: jonwis 3/7/2002 - Why the C-style interface to a C++ class? Remove a layer, nuke this and go C++
//

BOOL
SxsInitGuidSectionGenerationContext(
    OUT PGUID_SECTION_GENERATION_CONTEXT *GSGenContext,
    IN ULONG DataFormatVersion,
    IN GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    IN LPVOID Context
    )
{
    return CGSGenCtx::Create(
            GSGenContext,
            DataFormatVersion,
            CallbackFunction,
            Context);
}

PVOID
WINAPI
SxsGetGuidSectionGenerationContextCallbackContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext
    )
{
    return ((CGSGenCtx *) GSGenContext)->GetCallbackContext();
}

VOID
WINAPI
SxsDestroyGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext
    )
{
    if (GSGenContext != NULL)
    {
        ((CGSGenCtx *) GSGenContext)->DeleteYourself();
    }
}

BOOL
WINAPI
SxsAddGuidToGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN const GUID *Guid,
    IN PVOID DataContext,
    IN ULONG AssemblyRosterIndex,
    IN DWORD DuplicateGuidErrorCode
    )
{
    return ((CGSGenCtx *) GSGenContext)->Add(*Guid, DataContext, AssemblyRosterIndex, DuplicateGuidErrorCode);
}

BOOL
WINAPI
SxsFindStringInGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN const GUID *Guid,
    OUT PVOID *DataContext
    )
{
    return ((CGSGenCtx *) GSGenContext)->Find(*Guid, DataContext);
}

BOOL
WINAPI
SxsGetGuidSectionGenerationContextSectionSize(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    OUT PSIZE_T DataSize
    )
{
    return ((CGSGenCtx *) GSGenContext)->GetSectionSize(DataSize);
}

BOOL
WINAPI
SxsGetGuidSectionGenerationContextSectionData(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT PSIZE_T BytesWritten OPTIONAL
    )
{
    return ((CGSGenCtx *) GSGenContext)->GetSectionData(BufferSize, Buffer, BytesWritten);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\gsgenctx.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "gsgenctx.h"
#include "sxsexceptionhandling.h"

typedef struct _CALLBACKDATA
{
    union
    {
        GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE GetDataSize;
        GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA GetData;
        GUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED EntryDeleted;
        GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE GetUserDataSize;
        GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA GetUserData;
    } u;
} CALLBACKDATA, *PCALLBACKDATA;

BOOL CGSGenCtx::Create(
    PGUID_SECTION_GENERATION_CONTEXT *GSGenContext,
    ULONG DataFormatVersion,
    GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    PVOID CallbackContext
    )
{
    FN_PROLOG_WIN32

    CGSGenCtx *pGSGenCtx;

    if (GSGenContext != NULL)
        *GSGenContext = NULL;

    PARAMETER_CHECK(GSGenContext != NULL);
    PARAMETER_CHECK(CallbackFunction != NULL);

    IFALLOCFAILED_EXIT(pGSGenCtx = new CGSGenCtx);
    pGSGenCtx->m_CallbackFunction = CallbackFunction;
    pGSGenCtx->m_CallbackContext = CallbackContext;
    pGSGenCtx->m_DataFormatVersion = DataFormatVersion;

    *GSGenContext = (PGUID_SECTION_GENERATION_CONTEXT) pGSGenCtx;

    FN_EPILOG
}

CGSGenCtx::CGSGenCtx()
{
    m_HashTableSize = 0;
}

CGSGenCtx::~CGSGenCtx()
{
    CSxsPreserveLastError ple;
    CALLBACKDATA CBData;
    CGuidPtrTableIter<Entry, EntryGuidTableHelper> iter(m_Table);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        CBData.u.EntryDeleted.DataContext = iter->m_DataContext;
        (*m_CallbackFunction)(
            m_CallbackContext, 
            GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED, 
            &CBData);
        
        iter->m_DataContext = NULL;
    }

    ple.Restore();
}

void
CGSGenCtx::EntryGuidTableHelper::FinalizeValue(
    CGSGenCtx::Entry *&rpEntry
    )
{
    FUSION_DELETE_SINGLETON(rpEntry);
    rpEntry = NULL;
}

BOOL
CGSGenCtx::Add(
    const GUID &rGuid,
    PVOID DataContext,
    ULONG AssemblyRosterIndex,
    DWORD DuplicateErrorCode
    )
{
    FN_PROLOG_WIN32

    CSmartPtr<Entry> pEntry;

    PARAMETER_CHECK(DuplicateErrorCode != ERROR_SUCCESS);

    // We'll assume that duplicates are rare, so we'll allocate the entry up front.
    IFW32FALSE_EXIT(pEntry.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT(pEntry->Initialize(DataContext, AssemblyRosterIndex));
    IFW32FALSE_EXIT(m_Table.Insert(rGuid, pEntry));
    pEntry.Detach();

    FN_EPILOG
}

BOOL
CGSGenCtx::Find(
    const GUID &rGuid,
    PVOID *DataContext
    )
{
    FN_PROLOG_WIN32
    Entry *pEntry = NULL;

    if (DataContext != NULL)
        *DataContext = NULL;

    IFW32FALSE_EXIT(m_Table.Find(rGuid, pEntry));

    if (pEntry == NULL)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(GuidNotInSection, ERROR_SXS_KEY_NOT_FOUND);

    if (DataContext != NULL)
        *DataContext = pEntry->m_DataContext;

    FN_EPILOG
}

BOOL
CGSGenCtx::GetSectionSize(
    PSIZE_T SizeOut
    )
{
    FN_PROLOG_WIN32

    SIZE_T UserDataSize = 0;
    SIZE_T HeaderSize = 0;
    SIZE_T EntryListSize = 0;
    SIZE_T EntryDataSize = 0;
    CALLBACKDATA CBData;
    Entry *pEntry = NULL;
    CGuidPtrTableIter<Entry, EntryGuidTableHelper> iter(m_Table);

    if (SizeOut != NULL)
        *SizeOut = 0;

    PARAMETER_CHECK(SizeOut != NULL);

    HeaderSize = sizeof(ACTIVATION_CONTEXT_GUID_SECTION_HEADER);

    CBData.u.GetUserDataSize.DataSize = 0;
    IFW32FALSE_EXIT((*m_CallbackFunction)(m_CallbackContext, GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE, &CBData));
    UserDataSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserDataSize.DataSize);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        EntryListSize += sizeof(ACTIVATION_CONTEXT_GUID_SECTION_ENTRY);

        CBData.u.GetDataSize.DataContext = iter->m_DataContext;
        CBData.u.GetDataSize.DataSize = 0;
        (*m_CallbackFunction)(m_CallbackContext, GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE, &CBData);
        EntryDataSize += ROUND_ACTCTXDATA_SIZE(CBData.u.GetDataSize.DataSize);
    }

    *SizeOut = HeaderSize + UserDataSize + EntryListSize + EntryDataSize;

    FN_EPILOG
}

BOOL
CGSGenCtx::GetSectionData(
    SIZE_T BufferSize,
    PVOID Buffer,
    PSIZE_T BytesWritten
    )
{
    FN_PROLOG_WIN32

    SIZE_T BytesSoFar = 0;
    SIZE_T BytesLeft = BufferSize;
    SIZE_T RoundedSize;
    PACTIVATION_CONTEXT_GUID_SECTION_HEADER Header;
    CALLBACKDATA CBData;
    PVOID Cursor = NULL;
    CGuidPtrTableIter<Entry, EntryGuidTableHelper> iter(m_Table);
    SIZE_T EntryCount = m_Table.GetEntryCount();

    if (BytesWritten != NULL)
        *BytesWritten = 0;

    if (BytesLeft < sizeof(ACTIVATION_CONTEXT_GUID_SECTION_HEADER))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

    Header = (PACTIVATION_CONTEXT_GUID_SECTION_HEADER) Buffer;

    Cursor = (PVOID) (Header + 1);

    Header->Magic = ACTIVATION_CONTEXT_GUID_SECTION_MAGIC;
    Header->HeaderSize = sizeof(ACTIVATION_CONTEXT_GUID_SECTION_HEADER);
    Header->FormatVersion = ACTIVATION_CONTEXT_GUID_SECTION_FORMAT_WHISTLER;
    Header->DataFormatVersion = m_DataFormatVersion;

    Header->Flags = 0;

    Header->ElementCount = static_cast<ULONG>(EntryCount);
    Header->ElementListOffset = 0; // filled in after we figure out the user data area
    Header->SearchStructureOffset = 0;
    Header->UserDataOffset = 0; // filled in below
    Header->UserDataSize = 0;

    BytesLeft -= sizeof(*Header);
    BytesSoFar += sizeof(*Header);

    CBData.u.GetUserDataSize.DataSize = 0;

    IFW32FALSE_EXIT(
        (*m_CallbackFunction)(
            m_CallbackContext,
            GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE,
            &CBData));
    RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserDataSize.DataSize);

    if (RoundedSize != 0)
    {
        CBData.u.GetUserData.SectionHeader = Header;
        CBData.u.GetUserData.BufferSize = RoundedSize;
        CBData.u.GetUserData.Buffer = Cursor;
        CBData.u.GetUserData.BytesWritten = 0;

        IFW32FALSE_EXIT(
            (*m_CallbackFunction)(
                m_CallbackContext,
                GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA,
                &CBData));

        ASSERT(CBData.u.GetUserData.BytesWritten <= RoundedSize);

        if (CBData.u.GetUserData.BytesWritten != 0)
        {
            RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserData.BytesWritten);

            BytesLeft -= RoundedSize;
            BytesSoFar += RoundedSize;

            Header->UserDataSize = static_cast<ULONG>(CBData.u.GetUserData.BytesWritten);
            Header->UserDataOffset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) Header));

            Cursor = (PVOID) (((ULONG_PTR) Cursor) + RoundedSize);
        }
    }

    // Finally the array of entries...

    if (EntryCount != 0)
    {
        PVOID DataCursor;
        PACTIVATION_CONTEXT_GUID_SECTION_ENTRY DstEntry;
        PACTIVATION_CONTEXT_GUID_SECTION_ENTRY DstEntryArrayFirstElement;

        if (BytesLeft < (EntryCount * sizeof(ACTIVATION_CONTEXT_GUID_SECTION_ENTRY)))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

        BytesLeft -= (EntryCount * sizeof(ACTIVATION_CONTEXT_GUID_SECTION_ENTRY));
        BytesSoFar += (EntryCount * sizeof(ACTIVATION_CONTEXT_GUID_SECTION_ENTRY));

        //
        // DstEntryArrayFirstElement actually points to the first thing that we'll
        // be writing out, as DstEntry is ++'d across each of the elements as we
        // zip through the output buffer.
        //
        DstEntryArrayFirstElement = (PACTIVATION_CONTEXT_GUID_SECTION_ENTRY) Cursor;
        DstEntry = DstEntryArrayFirstElement;
        Header->ElementListOffset = static_cast<LONG>(((LONG_PTR) DstEntry) - ((LONG_PTR) Header));
        DataCursor = (PVOID) (DstEntry + EntryCount);

        for (iter.Reset(); iter.More(); iter.Next())
        {
            CBData.u.GetDataSize.DataContext = iter->m_DataContext;
            CBData.u.GetDataSize.DataSize = 0;

            IFW32FALSE_EXIT(
                (*m_CallbackFunction)(
                    m_CallbackContext,
                    GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE,
                    &CBData));

            RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetDataSize.DataSize);

#if DBG
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INFO,
                "SXS.DLL: Guid section generation callback (_GETDATASIZE) returned data size of %d (rounded to %Id)\n", CBData.u.GetDataSize.DataSize, RoundedSize);
#endif

            if (RoundedSize != 0)
            {
                if (BytesLeft < RoundedSize)
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                CBData.u.GetData.SectionHeader = Header;
                CBData.u.GetData.DataContext = iter->m_DataContext;
                CBData.u.GetData.BufferSize = RoundedSize;
                CBData.u.GetData.Buffer = DataCursor;
                CBData.u.GetData.BytesWritten = 0;

#if DBG
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_INFO,
                    "SXS.DLL: Calling guid section generation callback with reason GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA\n"
                    "    .DataContext = %p\n"
                    "    .BufferSize = %d\n"
                    "    .Buffer = %p\n",
                    CBData.u.GetData.DataContext,
                    CBData.u.GetData.BufferSize,
                    CBData.u.GetData.Buffer);
#endif

                IFW32FALSE_EXIT(
                    (*m_CallbackFunction)(
                        m_CallbackContext,
                        GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA,
                        &CBData));

                if (CBData.u.GetData.BytesWritten != 0)
                {
                    ASSERT(CBData.u.GetData.BytesWritten <= RoundedSize);
                    RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetData.BytesWritten);
                    INTERNAL_ERROR_CHECK(CBData.u.GetData.BytesWritten <= RoundedSize);

                    BytesLeft -= RoundedSize;
                    BytesSoFar += RoundedSize;

                    DstEntry->Offset = static_cast<LONG>(((LONG_PTR) DataCursor) - ((LONG_PTR) Header));
                }
                else
                    DstEntry->Offset = 0;

                DstEntry->Length = static_cast<ULONG>(CBData.u.GetData.BytesWritten);
                DstEntry->AssemblyRosterIndex = iter->m_AssemblyRosterIndex;
                DataCursor = (PVOID) (((ULONG_PTR) DataCursor) + RoundedSize);
            }
            else
            {
                DstEntry->Offset = 0;
                DstEntry->Length = 0;
                DstEntry->AssemblyRosterIndex = 0;
            }

            DstEntry->Guid = iter.GetKey();
            DstEntry++;
        }

        //
        // We compare the blobs via memcmp
        //
        if (m_HashTableSize == 0)
        {
            ::qsort(DstEntryArrayFirstElement, EntryCount, sizeof(*DstEntry), &CGSGenCtx::SortGuidSectionEntries);
            Header->Flags |= ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER;
        }
    }

    if (BytesWritten != NULL)
        *BytesWritten = BytesSoFar;

    FN_EPILOG
}

int __cdecl
CGSGenCtx::SortGuidSectionEntries(
    const void *elem1,
    const void *elem2
    )
{
    //
    // The first thing in the structure is actually the GUID itself, but
    // we'll save problems later by casting and following the Guid
    // member.
    //
    const PACTIVATION_CONTEXT_GUID_SECTION_ENTRY pLeft = (const PACTIVATION_CONTEXT_GUID_SECTION_ENTRY)elem1;
    const PACTIVATION_CONTEXT_GUID_SECTION_ENTRY pRight = (const PACTIVATION_CONTEXT_GUID_SECTION_ENTRY)elem2;

    return memcmp( (const void*)&pLeft->Guid, (const void*)&pRight->Guid, sizeof(GUID) );
}


BOOL
CGSGenCtx::Entry::Initialize(
    PVOID DataContext,
    ULONG AssemblyRosterIndex
    )
{
    m_DataContext = DataContext;
    m_AssemblyRosterIndex = AssemblyRosterIndex;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\hashfile.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "sxsp.h"
#include "imagehlp.h"
#include "windows.h"
#include "hashfile.h"
#include "wincrypt.h"
#include "winbase.h"
#include "softpub.h"
#include "strongname.h"
#include "fusioneventlog.h"
#include "sxsp.h"

BOOL SxspImageDigesterFunc(   DIGEST_HANDLE hSomething, PBYTE pbDataBlock, DWORD dwLength);
BOOL SxspSimpleHashRoutine(CFusionHash &rhHash, HANDLE hFile);
BOOL SxspImageHashRoutine(CFusionHash &rhHash, HANDLE hFile, BOOL &bInvalidImage);

CRITICAL_SECTION g_csHashFile;

struct _HASH_ALG_NAME_MAP
{
    PWSTR wsName;
    ULONG cchName;
    ALG_ID cId;
} HashAlgNameMap[] =
{
    { L"SHA1", 4,   CALG_SHA1 },
    { L"SHA", 3,    CALG_SHA },
    { L"MD5", 3,    CALG_MD5 },
    { L"MD4", 3,    CALG_MD4 },
    { L"MD2", 3,    CALG_MD2 },
    { L"MAC", 3,    CALG_MAC },
    { L"HMAC", 4,   CALG_HMAC }
};

BOOL
SxspEnumKnownHashTypes( 
    DWORD dwIndex, 
    OUT CBaseStringBuffer &rbuffHashTypeName,
    BOOL &rbNoMoreItems
    )
{
    FN_PROLOG_WIN32

    rbNoMoreItems = FALSE;

    if ( dwIndex >= NUMBER_OF( HashAlgNameMap ) )
    {
        rbNoMoreItems = TRUE;
    }
    else
    {
        IFW32FALSE_EXIT( rbuffHashTypeName.Win32Assign( 
            HashAlgNameMap[dwIndex].wsName,
            HashAlgNameMap[dwIndex].cchName ) );
    }

    FN_EPILOG
}

BOOL
SxspHashAlgFromString(
    const CBaseStringBuffer &strAlgName,
    ALG_ID &algId
    )
{
    FN_PROLOG_WIN32
    SIZE_T idx;

    for (idx = 0; idx < NUMBER_OF(HashAlgNameMap); idx++)
    {
        if (::FusionpCompareStrings(
                strAlgName, strAlgName.Cch(),
                HashAlgNameMap[idx].wsName, HashAlgNameMap[idx].cchName,
                false) == 0)
        {
            algId = HashAlgNameMap[idx].cId;
            break;
        }
    }

    if (idx == NUMBER_OF(HashAlgNameMap))
        ORIGINATE_WIN32_FAILURE_AND_EXIT(HashAlgDoesNotMatch, ERROR_SXS_MANIFEST_PARSE_ERROR);

    FN_EPILOG
}

BOOL
SxspHashStringFromAlg(
    ALG_ID algId,
    CBaseStringBuffer &strAlgName
    )
{
    FN_PROLOG_WIN32
    SIZE_T idx;

    strAlgName.Clear();

    for (idx = 0; idx < NUMBER_OF(HashAlgNameMap); idx++)
    {
        if (HashAlgNameMap[idx].cId == algId)
        {
            IFW32FALSE_EXIT(strAlgName.Win32Assign(HashAlgNameMap[idx].wsName, HashAlgNameMap[idx].cchName));
            break;
        }
    }

    PARAMETER_CHECK(idx != NUMBER_OF(HashAlgNameMap));

    FN_EPILOG
}

BOOL
SxspCheckHashDuringInstall(
    BOOL fHasHashData,
    const CBaseStringBuffer &rbuffFile,
    const CBaseStringBuffer &rbuffHashDataString,
    ALG_ID HashAlgId,
    HashValidateResult &rHashValid
    )
{
    FN_PROLOG_WIN32

    rHashValid = HashValidate_OtherProblems;

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: %s - Validating install-time hash: File=%ls tHasHash=%s tAlgId=0x%08x\n\tHash=%ls\n",
        __FUNCTION__,
        static_cast<PCWSTR>(rbuffFile),
        fHasHashData ? "yes" : "no",
        HashAlgId,
        static_cast<PCWSTR>(rbuffHashDataString));
#endif

    if (fHasHashData)
    {
        CFusionArray<BYTE> rgbHashData;

        IFW32FALSE_EXIT(rgbHashData.Win32Initialize());
        
        IFW32FALSE_EXIT(
            ::SxspHashStringToBytes(
                rbuffHashDataString,
                rbuffHashDataString.Cch(),
                rgbHashData));

        IFW32FALSE_EXIT(
            ::SxspVerifyFileHash(
                0,
                rbuffFile, 
                rgbHashData,
                HashAlgId, 
                rHashValid));
    }
    else
    {
        //
        // If there's no hash data, or we're in OS setup mode, then the hash of the
        // file is "implicitly" correct.
        //
        rHashValid = HashValidate_Matches;
    }

    FN_EPILOG
}


BOOL
SxspCreateFileHash(
    DWORD dwFlags,
    ALG_ID PreferredAlgorithm,
    const CBaseStringBuffer &pwsFileName,
    CFusionArray<BYTE> &rgbHashDestination
    )
/*++
Purpose:

Parameters:

Returns:

 --*/
{
    FN_PROLOG_WIN32

    CFusionFile     hFile;
    CFusionHash     hCurrentHash;

    // Initialization
    hFile = INVALID_HANDLE_VALUE;

    PARAMETER_CHECK((dwFlags & ~HASHFLAG_VALID_PARAMS) == 0);

    //
    // First try and open the file.  No sense in doing anything else if we
    // can't get to the data to start with.  Use a very friendly set of
    // rights to check the file.  Future users might want to be sure that
    // you're in the right security context before doing this - system
    // level to check system files, etc.
    //
    IFW32FALSE_EXIT(hFile.Win32CreateFile(pwsFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING));

    //
    // We'll be using SHA1 for the file hash
    //
    IFW32FALSE_EXIT(hCurrentHash.Win32Initialize(CALG_SHA1));

    //
    // So first try hashing it via the image, and if that fails, try the
    // normal file-reading hash routine instead.
    //
    if (dwFlags & HASHFLAG_AUTODETECT)
    {
        BOOL fInvalidImage;

        IFW32FALSE_EXIT(::SxspImageHashRoutine(hCurrentHash, hFile, fInvalidImage));
        if (fInvalidImage)
            IFW32FALSE_EXIT(::SxspSimpleHashRoutine(hCurrentHash, hFile));
    }
    else if (dwFlags & HASHFLAG_STRAIGHT_HASH)
    {
        IFW32FALSE_EXIT(::SxspSimpleHashRoutine(hCurrentHash, hFile));
    }
    else if (dwFlags & HASHFLAG_PROCESS_IMAGE)
    {
        BOOL fInvalidImage;
        
        IFW32FALSE_EXIT(::SxspImageHashRoutine(hCurrentHash, hFile, fInvalidImage));
        if (fInvalidImage)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(SxspCreateFileHash, ERROR_INVALID_PARAMETER);
    }


    //
    // We know the buffer is the right size, so we just call down to the hash parameter
    // getter, which will be smart and bop out (setting the pdwDestinationSize parameter)
    // if the user passed an incorrect parameter.
    //
    IFW32FALSE_EXIT(hCurrentHash.Win32GetValue(rgbHashDestination));

    FN_EPILOG
}

BOOL
SxspImageDigesterFunc(
    DIGEST_HANDLE hSomething,
    PBYTE pbDataBlock,
    DWORD dwLength
    )
{
    FN_PROLOG_WIN32

    CFusionHash* pHashObject = reinterpret_cast<CFusionHash*>(hSomething);

    if (pHashObject != NULL)
        IFW32FALSE_EXIT(pHashObject->Win32HashData(pbDataBlock, dwLength));

    FN_EPILOG
}


BOOL
SxspSimpleHashRoutine(
    CFusionHash &rhHash,
    HANDLE hFile
    )
{
    FN_PROLOG_WIN32
    
    DWORD dwDataRead;
    BOOL fKeepReading = TRUE;
    BOOL b = FALSE;
    CFusionArray<BYTE> srgbBuffer;

    IFW32FALSE_EXIT( srgbBuffer.Win32SetSize( 64 * 1024 ) );

    while (fKeepReading)
    {
        IFW32FALSE_ORIGINATE_AND_EXIT(::ReadFile(hFile, srgbBuffer.GetArrayPtr(), srgbBuffer.GetSizeAsDWORD(), &dwDataRead, NULL));

        //
        // if we're out of data, quit.
        //
        if (dwDataRead == 0)
        {
            fKeepReading = FALSE;
            continue;
        }

        //
        // If we've gotten this far, we need to add the data found
        // to our existing hash
        //
        IFW32FALSE_EXIT(rhHash.Win32HashData(srgbBuffer.GetArrayPtr(), dwDataRead));
    }

    FN_EPILOG
}


BOOL
SxspImageHashRoutine(
    CFusionHash &rhHash,
    HANDLE hFile,
    BOOL &rfInvalidImage
    )
{
    FN_PROLOG_WIN32
    CSxsLockCriticalSection lock(g_csHashFile);

    rfInvalidImage = FALSE;

    PARAMETER_CHECK((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE));

    // The ImageGetDigestStream() function is not thread safe, so we have to ensure that it's
    // not called by other threads while we're using it.
    IFW32FALSE_EXIT(lock.Lock());

    IFW32FALSE_EXIT_UNLESS(
        ::ImageGetDigestStream(
            hFile,
            CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO,
            &SxspImageDigesterFunc,
            (DIGEST_HANDLE)(&rhHash)),
        (::FusionpGetLastWin32Error() == ERROR_INVALID_PARAMETER),
        rfInvalidImage);

    lock.Unlock();

    FN_EPILOG
}

BOOL
SxspVerifyFileHash(
    const DWORD dwFlags,
    const CBaseStringBuffer &hsFullFilePath,
    const CFusionArray<BYTE> &rsrgbTheoreticalHash,
    ALG_ID whichAlg,
    HashValidateResult &HashValid
    )
{
    FN_PROLOG_WIN32

    CFusionArray<BYTE> bGotHash;
    HashValid = HashValidate_OtherProblems;
    BOOL fFileNotFoundError;
    LONG ulRetriesLeft = 0;
    LONG ulBackoffAmount = 1000;
    LONG ulBackoffAmountCap = 3000;
    float ulBackoffRate = 1.5f;

    PARAMETER_CHECK( (dwFlags == SVFH_DEFAULT_ACTION) || 
                     (dwFlags == SVFH_RETRY_LOGIC_SIMPLE) ||
                     (dwFlags == SVFH_RETRY_WAIT_UNTIL));

    if ( dwFlags == SVFH_RETRY_LOGIC_SIMPLE )
        ulRetriesLeft = 10;

TryAgain:

    IFW32FALSE_EXIT_UNLESS2(
        ::SxspCreateFileHash(
            HASHFLAG_AUTODETECT,
            whichAlg,
            hsFullFilePath,
            bGotHash),
            LIST_5( ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_BAD_NETPATH, ERROR_BAD_NET_NAME, ERROR_SHARING_VIOLATION),
            fFileNotFoundError);

    //
    // If this was a sharing violation and we've got retries left, then try again.
    //
    if (fFileNotFoundError && (::FusionpGetLastWin32Error() == ERROR_SHARING_VIOLATION) && (ulRetriesLeft > 0))
    {
        ulRetriesLeft--;
        ::Sleep( ulBackoffAmount );
        if (ulBackoffAmount < ulBackoffAmountCap)
            ulBackoffAmount = (ULONG)((float)ulBackoffAmount * ulBackoffRate);
        
        if (dwFlags == SVFH_RETRY_WAIT_UNTIL)
            ulRetriesLeft = 1;

        goto TryAgain;
    }

    //
    // If the file was able to be hashed, and the return error isn't "file not found",
    // then compare the hashes
    //
    if (!fFileNotFoundError &&(rsrgbTheoreticalHash.GetSize() == bGotHash.GetSize()))
    {
        HashValid = 
            (::memcmp(
                bGotHash.GetArrayPtr(),
                rsrgbTheoreticalHash.GetArrayPtr(),
                bGotHash.GetSize()) == 0) ? HashValidate_Matches : HashValidate_HashNotMatched;
    }
    else
    {
        HashValid = HashValidate_HashesCantBeMatched;
    }

    FN_EPILOG
}



BOOL
SxspGetStrongNameFromManifestName(
    PCWSTR pszManifestName,
    CBaseStringBuffer &rbuffStrongName,
    BOOL &rfHasPublicKey
    )
{
    BOOL                fSuccess = TRUE;
    FN_TRACE_WIN32(fSuccess);

    PCWSTR wsCursor;
    SIZE_T cchJump, cchPubKey;

    rfHasPublicKey = FALSE;
    rbuffStrongName.Clear();

    wsCursor = pszManifestName;

    //
    // Tricky: Zips through the name of the manifest to find the strong name string.
    //
    for (int i = 0; i < 2; i++)
    {
        cchJump = ::wcscspn(wsCursor, L"_");
        PARAMETER_CHECK(cchJump != 0);
        wsCursor += (cchJump + 1);  // x86_foo_strongname -> foo_strongname
    }

    //
    // Are we mysteriously at the end of the string?
    //
    PARAMETER_CHECK(wsCursor[0] != L'\0');

    //
    // Find the length of the public key string
    //
    cchPubKey = wcscspn(wsCursor, L"_");
    PARAMETER_CHECK(cchPubKey != 0);

    IFW32FALSE_EXIT(rbuffStrongName.Win32Assign(wsCursor, cchPubKey));

    rfHasPublicKey = (::FusionpCompareStrings(
                            rbuffStrongName,
                            rbuffStrongName.Cch(),
                            SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE,
                            NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE) - 1,
                            false) != 0);

    FN_EPILOG
}


static GUID p_WintrustVerifyGenericV2 = WINTRUST_ACTION_GENERIC_VERIFY_V2;

BOOL
SxspValidateManifestAgainstCatalog(
    const CBaseStringBuffer &rbuffManifestName, // "c:\foo\x86_comctl32_6.0.0.0_0000.manifest"
    ManifestValidationResult &rResult,
    DWORD dwOptionsFlags
    )
{
    FN_PROLOG_WIN32

    CStringBuffer sbCatalogName;

    //
    // Take the manifest name (which should be c:\foo\bar\blort.manifest) and switch
    // it to contain the catalog name instead:
    //
    // c:\foo\bar\blort.cat
    //
    IFW32FALSE_EXIT(sbCatalogName.Win32Assign(rbuffManifestName));
    IFW32FALSE_EXIT(
        sbCatalogName.Win32ChangePathExtension(
            FILE_EXTENSION_CATALOG,
            FILE_EXTENSION_CATALOG_CCH,
            eAddIfNoExtension));

    IFW32FALSE_EXIT(::SxspValidateManifestAgainstCatalog(rbuffManifestName, sbCatalogName, rResult, dwOptionsFlags));

    FN_EPILOG
}

void
SxspCertFreeCtlContext(
    PCCTL_CONTEXT CtlContext
    )
{
    if (CtlContext != NULL)
        ::CertFreeCTLContext(CtlContext);
}

void
SxspCertFreeCertContext(
    PCCERT_CONTEXT CertContext
    )
{
    if (CertContext != NULL)
        ::CertFreeCertificateContext(CertContext);
}

BOOL
SxspValidateCatalogAndFindManifestHash(
    IN HANDLE   hCatalogFile,
    IN PBYTE    prgbHash,
    IN SIZE_T   cbHash,
    OUT BOOL   &rfCatalogOk,
    OUT BOOL   &rfHashInCatalog
    )
{
    FN_PROLOG_WIN32

    CFileMapping            fmCatalogMapping;
    CMappedViewOfFile       mvCatalogView;
    LARGE_INTEGER           liCatalogFile;
    ULONGLONG               ullCatalogFile;
    PVOID                   pvCatalogData;
    CRYPT_VERIFY_MESSAGE_PARA vfmParameters;

    //
    // Default value
    //
    rfHashInCatalog = FALSE;
    rfCatalogOk = FALSE;

    //
    // Create a CTL context from the catalog file.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(::GetFileSizeEx(hCatalogFile, &liCatalogFile));
    ullCatalogFile = liCatalogFile.QuadPart;
    IFW32FALSE_EXIT(fmCatalogMapping.Win32CreateFileMapping(hCatalogFile, PAGE_READONLY, ullCatalogFile, NULL));
    IFW32FALSE_EXIT(mvCatalogView.Win32MapViewOfFile(fmCatalogMapping, FILE_MAP_READ, 0, (SIZE_T)ullCatalogFile));

    pvCatalogData = mvCatalogView;

    //
    // First, validate that the message (catalog) is OK
    //
    ZeroMemory(&vfmParameters, sizeof(vfmParameters));
    vfmParameters.cbSize = sizeof(vfmParameters);
    vfmParameters.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;

    // NTRAID#NTBUG9 - 591808 - 2002/04/01 - mgrier - Missing error check (well, missing
    //      handling of the error case).  And no, returning the "failure" via
    //      rfCatalogOk == NULL does not count.
    rfCatalogOk = ::CryptVerifyMessageSignature(
            &vfmParameters,
            0,
            static_cast<PBYTE>(pvCatalogData),
            static_cast<DWORD>(ullCatalogFile),
            NULL,
            NULL,
            NULL);
            
    if (rfCatalogOk)
    {
        CSmartPtrWithNamedDestructor<const CERT_CONTEXT, &::SxspCertFreeCertContext> pCertContext;
        CSmartPtrWithNamedDestructor<const CTL_CONTEXT, &::SxspCertFreeCtlContext> pCtlContext;
        PCTL_ENTRY              pFoundCtlEntry;
        CSmallStringBuffer      buffStringizedHash;
        CTL_ANY_SUBJECT_INFO    ctlSubjectInfo;

        //
        // The search routine needs a string to find, says the crypto guys.
        //
        IFW32FALSE_EXIT(::SxspHashBytesToString( prgbHash, cbHash, buffStringizedHash));
        IFW32FALSE_EXIT(buffStringizedHash.Win32ConvertCase(eConvertToUpperCase));

        //
        // If this failed, something bad happened with the CTL - maybe the catalog
        // was invalid, maybe something else happened.  Whatever it was, let the
        // caller decide.
        //
        // NTRAID#NTBUG9 - 591808 - 2002/04/01 - mgrier - Missing error check (well, missing
        //      handling of the error case).
        pCtlContext.AttachForDelete(
            ::CertCreateCTLContext(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                static_cast<PBYTE>(pvCatalogData),
                static_cast<DWORD>(ullCatalogFile)));

        if (pCtlContext != NULL)
        {
            //
            // Fill out this data with the string information.
            //
            CStringBufferAccessor sba;

            sba.Attach(&buffStringizedHash);

            ZeroMemory(&ctlSubjectInfo, sizeof(ctlSubjectInfo));
            ctlSubjectInfo.SubjectAlgorithm.pszObjId = NULL;
            ctlSubjectInfo.SubjectIdentifier.pbData = static_cast<PBYTE>(static_cast<PVOID>(sba.GetBufferPtr()));
            ctlSubjectInfo.SubjectIdentifier.cbData = static_cast<DWORD>((sba.Cch() + 1) * sizeof(WCHAR));
            sba.Detach();

            //
            // Look for it in the CTL
            //
            pFoundCtlEntry = CertFindSubjectInCTL(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                CTL_ANY_SUBJECT_TYPE,
                &ctlSubjectInfo,
                pCtlContext,
                0);

            rfHashInCatalog = ( pFoundCtlEntry != NULL );
            
        }
        
    }

    FN_EPILOG
}

class CSxspValidateManifestAgainstCatalogLocals
{
public:
    CSxspValidateManifestAgainstCatalogLocals() { }
    ~CSxspValidateManifestAgainstCatalogLocals() { }

    CSmallStringBuffer      rbuffStrongNameString;
    CPublicKeyInformation   pkiCatalogInfo;
};

BOOL
SxspValidateManifestAgainstCatalog(
    IN  const CBaseStringBuffer &rbuffManifestName,
    IN  const CBaseStringBuffer &rbuffCatalogName,
    OUT ManifestValidationResult &rResult,
    IN  DWORD dwOptionsFlags
    )
{
    FN_PROLOG_WIN32

    CFusionArray<BYTE>      ManifestHash;
    BOOL                    fTempFlag = FALSE;
    BOOL                    fCatalogOk = FALSE;
    BOOL                    fHashFound = FALSE;
    CFusionFile             ffCatalogFile;

    CSmartPtr<CSxspValidateManifestAgainstCatalogLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    CSmallStringBuffer      &rbuffStrongNameString = Locals->rbuffStrongNameString;
    CPublicKeyInformation   &pkiCatalogInfo = Locals->pkiCatalogInfo;

    //
    // Generate the hash of the manifest first
    //
    IFW32FALSE_EXIT_UNLESS2(
        ::SxspCreateFileHash(
            HASHFLAG_STRAIGHT_HASH,
            CALG_SHA1,
            rbuffManifestName,
            ManifestHash),
        LIST_4(ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND, ERROR_BAD_NET_NAME, ERROR_BAD_NETPATH),
        fTempFlag);

    if (fTempFlag)
    {
        rResult = ManifestValidate_ManifestMissing;
        FN_SUCCESSFUL_EXIT();
    }

    //
    // Open the catalog file for now, we'll use it later.
    //
    IFW32FALSE_EXIT_UNLESS2(
		ffCatalogFile.Win32CreateFile(
			rbuffCatalogName,
			GENERIC_READ,
			FILE_SHARE_READ,
			OPEN_EXISTING),
		LIST_4(ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND, ERROR_BAD_NET_NAME, ERROR_BAD_NETPATH),
		fTempFlag);

    if (fTempFlag)
    {
        rResult = ManifestValidate_CatalogMissing;
        FN_SUCCESSFUL_EXIT();
    }

    //
    // Now look in the file to see if the catalog contains the hash of the manifest
    // in the CTL
    //
    IFW32FALSE_EXIT(
        ::SxspValidateCatalogAndFindManifestHash(
            ffCatalogFile,
            ManifestHash.GetArrayPtr(),
            ManifestHash.GetSize(),
            fCatalogOk,
            fHashFound));

    if (!fCatalogOk)
    {
        rResult = ManifestValidate_OtherProblems;
        FN_SUCCESSFUL_EXIT();
    }
    else if (!fHashFound)
    {
        rResult = ManifestValidate_NotCertified;
        FN_SUCCESSFUL_EXIT();
    }

    //
    // Are we supposed to validate the strong name of this catalog?
    //
    if ((dwOptionsFlags & MANIFESTVALIDATE_MODE_NO_STRONGNAME) == 0)
    {
        IFW32FALSE_EXIT(::SxspGetStrongNameFromManifestName(
            rbuffManifestName,
            rbuffStrongNameString,
            fTempFlag));

        if (!fTempFlag)
        {
            rResult = ManifestValidate_OtherProblems;
            FN_SUCCESSFUL_EXIT();
        }
        
        IFW32FALSE_EXIT(pkiCatalogInfo.Initialize(rbuffCatalogName));
    }

    //
    // Huzzah!
    //
    rResult = ManifestValidate_IsIntact;

    FN_EPILOG
}

bool
SxspIsFullHexString(
    PCWSTR wsString,
    SIZE_T Cch
    )
{
    for (SIZE_T i = 0; i < Cch; i++)
    {
        WCHAR ch = wsString[i];
        if (!::SxspIsHexDigit(ch))
            return false;
    }
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\impersonationdata.h ===
#if !defined(_FUSION_SXS_IMPERSONATIONDATA_H_INCLUDED_)
#define _FUSION_SXS_IMPERSONATIONDATA_H_INCLUDED_

#pragma once

#include <sxsapi.h>

class CImpersonationData
{
public:
    CImpersonationData() : m_Callback(NULL), m_Context(NULL) { }
    CImpersonationData(PSXS_IMPERSONATION_CALLBACK Callback, PVOID Context) : m_Callback(Callback), m_Context(Context) { }
    CImpersonationData(const CImpersonationData &r) : m_Callback(r.m_Callback), m_Context(r.m_Context) { }
    void operator =(const CImpersonationData &r) { m_Callback = r.m_Callback; m_Context = r.m_Context; }
    ~CImpersonationData() { }

    enum CallType
    {
        eCallTypeImpersonate,
        eCallTypeUnimpersonate
    };

    BOOL Call(CallType ct) const { BOOL fSuccess = TRUE; if (m_Callback != NULL) { fSuccess = (*m_Callback)(m_Context, (ct == eCallTypeImpersonate) ? TRUE : FALSE); } return fSuccess; }

protected:
    PSXS_IMPERSONATION_CALLBACK m_Callback;
    PVOID m_Context;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\forwarddeclarations.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    forwarddeclarations.h

Abstract:

    Forward declare lots of struct, class, and union types,
	and pointer typedefs thereof.

Author:

    Jay Krell (a-JayK, JayKrell) December 2000

Environment:


Revision History:

--*/
#pragma once

#include "preprocessor.h"

/*-----------------------------------------------------------------------------
This forward declares NT style structs, so you can declare uses of pointers
to them in headers without including the header that defines them, and without
referring to them as "struct _FOO*" but "PFOO" or "FOO*" instead.

The header that defines them should not use this macro, but stick to the
consistent style
typedef struct _FOO
{
    ..
} FOO, *PFOO;
typedef const FOO* PCFOO;
-----------------------------------------------------------------------------*/
#define FORWARD_NT_STRUCT(x) \
    struct PASTE(_,x); \
    typedef struct PASTE(_,x) x; \
    typedef x* PASTE(P,x); \
    typedef const x* PASTE(PC,x)

#define FORWARD_NT_UNION(x) \
    union PASTE(_,x); \
    typedef union PASTE(_,x) x; \
    typedef x* PASTE(P,x); \
    typedef const x* PASTE(PC,x)

#define FORWARD_CLASS(x) \
    class x; \
    typedef x* PASTE(P,x); \
    typedef const x* PASTE(PC,x)

FORWARD_NT_UNION(ACTCTXCTB_CALLBACK_DATA);
FORWARD_NT_STRUCT(ACTCTXCTB);
FORWARD_CLASS(ACTCTXCTB_INSTALLATION_CONTEXT);
FORWARD_NT_STRUCT(ACTCTXCTB_CLSIDMAPPING_CONTEXT);
FORWARD_NT_STRUCT(ACTCTXCTB_ASSEMBLY_CONTEXT);
FORWARD_NT_STRUCT(ACTCTXCTB_PARSE_CONTEXT);
FORWARD_NT_STRUCT(SXS_NODE_INFO);
FORWARD_NT_STRUCT(ACTCTXCTB_CBHEADER);
FORWARD_NT_STRUCT(ACTCTXCTB_CBPARSEENDING);
FORWARD_NT_STRUCT(ACTCTXCTB_CBPARSEBEGINNING);
FORWARD_NT_STRUCT(ASSEMBLY_IDENTITY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\hashfile.h ===
#pragma once
#include "fusionbuffer.h"
#include "fusionarray.h"
#include "fusionsha1.h"

/*++

Hashfile.h - Inclusions for file-hashing and verification testing functionality.

--*/


#define SHA1_HASH_SIZE_BYTES    ( 160 / 8 )
#define HASHFLAG_AUTODETECT        ( 0x00000001 )
#define HASHFLAG_STRAIGHT_HASH     ( 0x00000002 )
#define HASHFLAG_PROCESS_IMAGE    ( 0x00000004 )
#define HASHFLAG_VALID_PARAMS   ( HASHFLAG_AUTODETECT | HASHFLAG_STRAIGHT_HASH | \
                                  HASHFLAG_PROCESS_IMAGE )

//
// If someone invents a hash with more than 512 bytes, I'll eat my socks.
//
#define MAX_HASH_BYTES              ( 512 )

BOOL
SxspEnumKnownHashTypes( 
    DWORD dwIndex, 
    OUT CBaseStringBuffer &rbuffHashTypeName,
    OUT BOOL &rbNoMoreItems
    );

BOOL
SxspCreateFileHash(
    DWORD dwFlags,
    ALG_ID PreferredAlgorithm,
    const CBaseStringBuffer &pwsFileName,
    CFusionArray<BYTE> &bHashDestination
    );

bool
SxspIsFullHexString(
    PCWSTR wsString,
    SIZE_T Cch
    );

typedef enum {
    HashValidate_Matches,               // Hashes are identical
    HashValidate_InvalidPassedHash,     // The hash passed in was somehow invalid
    HashValidate_InvalidAlgorithm,      // The hash algorithm is invalid
    HashValidate_HashesCantBeMatched,   // No match for another reason
    HashValidate_HashNotMatched,        // Hashes are not identical (ie: not matched)
    HashValidate_OtherProblems          // There was some other problem along the way
} HashValidateResult;



//
// Do the normal validation process - single retry
//
#define SVFH_DEFAULT_ACTION     (0x00000000)

//
// Retry this file N times until either (a) the file was unable to be
// opened or (b) the file has other errors or (c) the file was checked
// and it was ok / bad / etc.
//
#define SVFH_RETRY_LOGIC_SIMPLE (0x00000001)

//
// Wait until the file was able to be verified - spin in a backoff loop
// until the file open didn't fail with ERROR_SHARING_VIOLATION
//
#define SVFH_RETRY_WAIT_UNTIL   (0x00000002)

BOOL
SxspVerifyFileHash(
    const DWORD dwFlags,
	const CBaseStringBuffer &rhsFullFilePath,
	const CFusionArray<BYTE> &baTheorheticalHash,
	ALG_ID whichAlg,
	HashValidateResult &rHashResult
    );

BOOL
SxspHashAlgFromString(
	const CBaseStringBuffer &strAlgName,
	ALG_ID &algId
    );

BOOL
SxspHashStringFromAlg(
	ALG_ID algId,
	CBaseStringBuffer &rstrAlgName
    );

typedef enum
{
    ManifestValidate_Unknown            = 0,
    ManifestValidate_IsIntact           = 1,
    ManifestValidate_CatalogMissing     = 2,
    ManifestValidate_ManifestMissing    = 3,
    ManifestValidate_InvalidHash        = 4,
    ManifestValidate_NotCertified       = 5,
    ManifestValidate_StrongNameMismatch = 6,
    ManifestValidate_OtherProblems      = 7
} ManifestValidationResult;

class CMetaDataFileElement;

BOOL
SxspValidateAllFileHashes(
    IN const CMetaDataFileElement &rmdfeElement,
    IN const CBaseStringBuffer &rbuffFileName,
    OUT HashValidateResult &rResult
    );


#define ENUM_TO_STRING( x ) case x: return (L#x)

#if DBG
inline PCWSTR SxspManifestValidationResultToString( ManifestValidationResult r )
{
    switch ( r )
    {
        ENUM_TO_STRING( ManifestValidate_Unknown );
        ENUM_TO_STRING( ManifestValidate_IsIntact );
        ENUM_TO_STRING( ManifestValidate_CatalogMissing );
        ENUM_TO_STRING( ManifestValidate_ManifestMissing );
        ENUM_TO_STRING( ManifestValidate_InvalidHash );
        ENUM_TO_STRING( ManifestValidate_NotCertified );
        ENUM_TO_STRING( ManifestValidate_OtherProblems );
    }

    return L"Bad manifest validation value";
}

inline PCWSTR SxspHashValidateResultToString( HashValidateResult r )
{
    switch ( r )
    {
        ENUM_TO_STRING( HashValidate_Matches );
        ENUM_TO_STRING( HashValidate_InvalidPassedHash );
        ENUM_TO_STRING( HashValidate_InvalidAlgorithm );
        ENUM_TO_STRING( HashValidate_HashesCantBeMatched );
        ENUM_TO_STRING( HashValidate_HashNotMatched );
        ENUM_TO_STRING( HashValidate_OtherProblems );
    }

    return L"Bad hash validation value";
}

#endif

// Default mode
#define MANIFESTVALIDATE_OPTION_MASK                ( 0x000000FF )
#define MANIFESTVALIDATE_MODE_MASK                  ( 0x0000FF00 )

#define MANIFESTVALIDATE_MODE_COMPLETE              ( 0x00000100 )
#define MANIFESTVALIDATE_MODE_NO_STRONGNAME         ( 0x00000200 )

// The manifest has to validate against a trusted root CA to be valid.
#define MANIFESTVALIDATE_OPTION_NEEDS_ROOT_CA       ( 0x00000001 )

// The catalog gets validated first before the manifest is checked.
#define MANIFESTVALIDATE_OPTION_VALIDATE_CATALOG    ( 0x00000002 )

// If the manifest or catalog are invalid, attempt to retrieve it
#define MANIFESTVALIDATE_OPTION_ATTEMPT_RETRIEVAL   ( 0x00000004 )

#define MANIFESTVALIDATE_MOST_COMMON    ( MANIFESTVALIDATE_MODE_COMPLETE +  \
                                          ( MANIFESTVALIDATE_OPTION_NEEDS_ROOT_CA |  \
                                            MANIFESTVALIDATE_OPTION_VALIDATE_CATALOG ) )

BOOL
SxspValidateManifestAgainstCatalog(
    const CBaseStringBuffer &rbuffManifestPath,
    ManifestValidationResult &rResult,
    DWORD dwOptionsFlags
    );

BOOL
SxspValidateManifestAgainstCatalog(
    const CBaseStringBuffer &rbuffManifestPath,
    const CBaseStringBuffer &rbuffCatalogPath,
    ManifestValidationResult &rResult,
    DWORD dwOptionsFlags
    );

BOOL
SxspCheckHashDuringInstall(
    BOOL bHasHashData,
    const CBaseStringBuffer &rbuffFile,
    const CBaseStringBuffer &rbuffHashDataString,
    ALG_ID HashAlgId,
    HashValidateResult &hvr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\gsgenctx.h ===
#if !defined(_FUSION_GSGENCTX_H_INCLUDED_)
#define _FUSION_GSGENCTX_H_INCLUDED_

#pragma once

#include "fusionheap.h"

class CGSGenCtx
{
public:
    static BOOL Create(
                PGUID_SECTION_GENERATION_CONTEXT *GSGenContext,
                ULONG DataFormatVersion,
                GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
                PVOID CallbackContext
                );

    BOOL Add(const GUID &rGuid, PVOID DataContext, ULONG AssemblyRosterIndex, DWORD DuplicateErrorCode);
    BOOL Find(const GUID &rGuid, PVOID *DataContext);
    BOOL GetSectionSize(PSIZE_T SectionSize);
    BOOL GetSectionData(SIZE_T BufferSize, PVOID Buffer, SIZE_T *BytesWritten);
    PVOID GetCallbackContext() { return m_CallbackContext; }

    VOID DeleteYourself() { FUSION_DELETE_SINGLETON(this); }
    ~CGSGenCtx();

protected:
    CGSGenCtx();

    GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION m_CallbackFunction;
    PVOID m_CallbackContext;

    class Entry
    {
    public:
        Entry() : m_DataContext(NULL) { }
        ~Entry() { }

        BOOL Initialize(PVOID DataContext, ULONG AssemblyRosterIndex);
        BOOL GetEntryDataSize(CGSGenCtx *pSSGenCtx, SIZE_T &rSize);
        BOOL GetEntryData(CGSGenCtx *pSSGenCtx, SIZE_T BufferSize, PVOID Buffer, SIZE_T *BytesWritten);

        PVOID m_DataContext;
        ULONG m_AssemblyRosterIndex;
    };

    friend Entry;

    class EntryGuidTableHelper : public CGuidPtrTableHelper<Entry>
    {
    public:
        static void FinalizeValue(Entry *&rpEntry);
    };

    CGuidPtrTable<Entry, EntryGuidTableHelper> m_Table;

    static int __cdecl SortGuidSectionEntries(const void *elem1, const void *elem2);

    ULONG m_HashTableSize;
    ULONG m_DataFormatVersion;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\partialassemblyversion.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    partialassemblyversion.cpp

Abstract:

    Class describing a partial/wildcarded assembly version.

Author:

    Michael J. Grier (MGrier) 13-May-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "partialassemblyversion.h"

BOOL
CPartialAssemblyVersion::Parse(
    PCWSTR sz,
    SIZE_T Cch
    )
{
    BOOL fSuccess = FALSE;
    ULONG cDots = 0;
    PCWSTR pszTemp;
    SIZE_T CchLeft;
    USHORT usTemp;
    ASSEMBLY_VERSION avTemp;
    PCWSTR pszLast;
    BOOL MajorSpecified = FALSE;
    BOOL MinorSpecified = FALSE;
    BOOL BuildSpecified = FALSE;
    BOOL RevisionSpecified = FALSE;

    // Somehow people often leave trailing nulls; we'll just back off Cch in this case.
    while ((Cch != 0) && (sz[Cch - 1] == L'\0'))
        Cch--;

    avTemp.Major = 0;
    avTemp.Minor = 0;
    avTemp.Revision = 0;
    avTemp.Build = 0;

    // "*" means everything unspecified...
    if ((Cch == 1) && (sz[0] == L'*'))
    {
        m_MajorSpecified = FALSE;
        m_MinorSpecified = FALSE;
        m_BuildSpecified = FALSE;
        m_RevisionSpecified = FALSE;

        fSuccess = TRUE;
        goto Exit;
    }

    pszTemp = sz;
    CchLeft = Cch;

    while (CchLeft-- != 0)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'.')
        {
            cDots++;

            if (cDots >= 4)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }
        }
        else if ((wch != L'*') && ((wch < L'0') || (wch > L'9')))
        {
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }
    }

    if (cDots < 3)
    {
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    pszTemp = sz;
    pszLast = sz + Cch;

    usTemp = 0;
    for (;;)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'*')
        {
            // If there's been a previous digit, we can't then have a * (there's no matching version number "5*")
            if (MajorSpecified)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            if (*pszTemp != L'.')
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            break;
        }

        if (wch == L'.')
            break;

        usTemp = (usTemp * 10) + (wch - L'0');
        MajorSpecified = TRUE;
    }
    avTemp.Major = usTemp;

    usTemp = 0;
    for (;;)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'*')
        {
            // If there's been a previous digit, we can't then have a * (there's no matching version number "5*")
            if (MinorSpecified)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            if (*pszTemp != L'.')
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            break;
        }

        if (wch == L'.')
            break;

        usTemp = (usTemp * 10) + (wch - L'0');
        MinorSpecified = TRUE;
    }
    avTemp.Minor = usTemp;

    usTemp = 0;
    for (;;)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'*')
        {
            // If there's been a previous digit, we can't then have a * (there's no matching version number "5*")
            if (RevisionSpecified)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            if (*pszTemp != L'.')
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            break;
        }

        if (wch == L'.')
            break;

        usTemp = (usTemp * 10) + (wch - L'0');
        RevisionSpecified = TRUE;
    }
    avTemp.Revision = usTemp;

    // Now the tricky bit.  We aren't necessarily null-terminated, so we
    // have to just look for hitting the end.
    usTemp = 0;
    while (pszTemp < pszLast)
    {
        WCHAR wch = *pszTemp++;

        if (wch == L'*')
        {
            // If there's been a previous digit, we can't then have a * (there's no matching version number "5*")
            if (MajorSpecified)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            // If that wasn't the last character, it was wrong.
            if (pszTemp < pszLast)
            {
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }

            break;
        }

        usTemp = (usTemp * 10) + (wch - L'0');
        BuildSpecified = TRUE;
    }
    avTemp.Build = usTemp;

    m_AssemblyVersion = avTemp;

    m_MajorSpecified = MajorSpecified;
    m_MinorSpecified = MinorSpecified;
    m_RevisionSpecified = RevisionSpecified;
    m_BuildSpecified = BuildSpecified;

    fSuccess = TRUE;

Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\partialassemblyversion.h ===
#if !defined(_FUSION_SXS_PARTIALVERSION_H_INCLUDED_)
#define _FUSION_SXS_PARTIALVERSION_H_INCLUDED_

#pragma once

#include <sxsapi.h>
#include "fusionbuffer.h"

//
//  A CPartialAssemblyVersion is a class that wraps an inexact version
//  specification.
//
//  The initial implementation just assumes that it's basically an ASSEMBLY_VERSION,
//  but that any of the fields may be "wildcarded".
//
//  Future versions may allow for more interesting partial version specifications
//  such as "major=5; minor=1; build=2103; revision >= 100".  This is beyond the
//  bounds of the initial implementation, but forms the basis for the public
//  interface (parse, format, test match)
//

class CPartialAssemblyVersion
{
public:
    CPartialAssemblyVersion() : m_MajorSpecified(FALSE), m_MinorSpecified(FALSE), m_BuildSpecified(FALSE), m_RevisionSpecified(FALSE) { }
    ~CPartialAssemblyVersion() { }

    BOOL Parse(PCWSTR VersionString, SIZE_T VersionStringCch);
    BOOL Format(CBaseStringBuffer &rOutputBuffer, SIZE_T *CchOut) const;

    BOOL Matches(const ASSEMBLY_VERSION &rav) const;

    // Returns true of any ASSEMBLY_VERSION would match (e.g. "*" or "*.*.*.*")
    BOOL MatchesAny() const { return !(m_MajorSpecified || m_MinorSpecified || m_BuildSpecified || m_RevisionSpecified); }

protected:
    ASSEMBLY_VERSION m_AssemblyVersion;
    BOOL m_MajorSpecified, m_MinorSpecified, m_BuildSpecified, m_RevisionSpecified;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\ndpclassinfo.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    clrclassinfo.cpp

Abstract:

    CLR 'surrogate' contributor for Win32-CLR interop assemblies

Author:

    Jon Wiswall (jonwis) March, 2002 (heavily borrowed from comclass.cpp)

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(clsid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(runtimeVersion);

#define ALLOCATE_BUFFER_SPACE(_bytesNeeded, _bufferCursor, _bytesLeft, _bytesWritten, _typeName, _ptr) \
do { \
    if (_bytesLeft < (_bytesNeeded)) \
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER); \
    _bytesLeft -= (_bytesNeeded); \
    _bytesWritten += (_bytesNeeded); \
    _ptr = (_typeName) _bufferCursor; \
    _bufferCursor = (PVOID) (((ULONG_PTR) _bufferCursor) + (_bytesNeeded)); \
} while (0)

#define ALLOCATE_BUFFER_SPACE_TYPE(_typeName, _bufferCursor, _bytesLeft, _bytesWritten, _ptr) \
    ALLOCATE_BUFFER_SPACE(sizeof(_typeName), _bufferCursor, _bytesLeft, _bytesWritten, _typeName *, _ptr)

typedef struct _CLR_GLOBAL_CONTEXT *PCLR_GLOBAL_CONTEXT;
typedef struct _CLR_SURROGATE_ENTRY *PCLR_SURROGATE_ENTRY;

typedef struct _CLR_SURROGATE_ENTRY
{
public:
    _CLR_SURROGATE_ENTRY() { }

    CDequeLinkage           m_Linkage;
    GUID                    m_ReferenceClsid;
    CSmallStringBuffer      m_TypeName;
    CSmallStringBuffer      m_RuntimeVersion;
private:
    _CLR_SURROGATE_ENTRY(const _CLR_SURROGATE_ENTRY &);
    void operator =(const _CLR_SURROGATE_ENTRY &);
} CLR_SURROGATE_ENTRY;

typedef CDeque<CLR_SURROGATE_ENTRY, offsetof(CLR_SURROGATE_ENTRY, m_Linkage)> CClrSurrogateDeque;
typedef CDequeIterator<CLR_SURROGATE_ENTRY, offsetof(CLR_SURROGATE_ENTRY, m_Linkage)> CClrSurrogateDequeIterator;

typedef struct _CLR_GLOBAL_CONTEXT
{
    _CLR_GLOBAL_CONTEXT() { }

    CClrSurrogateDeque      m_SurrogateList;

private:
    _CLR_GLOBAL_CONTEXT(const _CLR_GLOBAL_CONTEXT &);
    void operator =(const _CLR_GLOBAL_CONTEXT &);
} CLR_GLOBAL_CONTEXT;

BOOL
SxspClrSurrogateAddSurrogate(
    PACTCTXCTB_CBELEMENTPARSED SurrogateParsed,
    PCLR_GLOBAL_CONTEXT pGlobalContext,
    PGUID_SECTION_GENERATION_CONTEXT pGsGenCtx
    );


VOID
__fastcall
SxspClrInteropContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();

    PGUID_SECTION_GENERATION_CONTEXT GSGenContext = (PGUID_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    CSmartPtr<CLR_GLOBAL_CONTEXT> ClrGlobalContext;

    if (GSGenContext != NULL)
        ClrGlobalContext.AttachNoDelete((PCLR_GLOBAL_CONTEXT) ::SxsGetGuidSectionGenerationContextCallbackContext(GSGenContext));

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;
        INTERNAL_ERROR_CHECK(GSGenContext != NULL);
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        IFW32FALSE_EXIT(::SxsGetGuidSectionGenerationContextSectionData(GSGenContext, Data->GetSectionData.SectionSize, Data->GetSectionData.SectionDataStart, NULL));
        Data->GetSectionData.Success = TRUE;
        break;
        
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        Data->GenBeginning.Success = FALSE;

        INTERNAL_ERROR_CHECK(ClrGlobalContext == NULL);
        INTERNAL_ERROR_CHECK(GSGenContext == NULL);

        IFW32FALSE_EXIT(ClrGlobalContext.Win32Allocate(__FILE__, __LINE__));

        IFW32FALSE_EXIT(
            ::SxsInitGuidSectionGenerationContext(
                &GSGenContext,
                ACTIVATION_CONTEXT_DATA_CLR_SURROGATE_FORMAT_WHISTLER,
                &::SxspClrInteropGuidSectionGenerationCallback,
                ClrGlobalContext));

        ClrGlobalContext.Detach();

        Data->Header.ActCtxGenContext = GSGenContext;
        Data->GenBeginning.Success = TRUE;

        break;

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:

        ::SxsDestroyGuidSectionGenerationContext(GSGenContext);
        if (ClrGlobalContext != NULL)
        {
            ClrGlobalContext->m_SurrogateList.ClearAndDeleteAll();
        }
        FUSION_DELETE_SINGLETON(ClrGlobalContext.Detach());
        
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        Data->AllParsingDone.Success = FALSE;

        if (GSGenContext != NULL)
            IFW32FALSE_EXIT(::SxsDoneModifyingGuidSectionGenerationContext(GSGenContext));

        Data->AllParsingDone.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        Data->GetSectionSize.Success = FALSE;
        INTERNAL_ERROR_CHECK(Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
        INTERNAL_ERROR_CHECK(GSGenContext != NULL);
        IFW32FALSE_EXIT(::SxsGetGuidSectionGenerationContextSectionSize(GSGenContext, &Data->GetSectionSize.SectionSize));
        Data->GetSectionSize.Success = TRUE;
        break;

    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        {
            ULONG MappedValue = 0;
            bool fFound = false;
            
            enum MappedValues {
                eClrSurrogate,
            };

            static const WCHAR ELEMENT_PATH_BUILTIN_CLR_SURROGATE[] = L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^clrSurrogate";

            static const ELEMENT_PATH_MAP_ENTRY s_rgEntries[] = 
            {
                { 2, ELEMENT_PATH_BUILTIN_CLR_SURROGATE, NUMBER_OF(ELEMENT_PATH_BUILTIN_CLR_SURROGATE)-1, eClrSurrogate },
            };

            Data->ElementParsed.Success = FALSE;
            IFW32FALSE_EXIT(::SxspProcessElementPathMap(
                Data->ElementParsed.ParseContext,
                s_rgEntries,
                NUMBER_OF(s_rgEntries),
                MappedValue,
                fFound));

            if (!fFound)
            {
                Data->ElementParsed.Success = TRUE;
                break;
            }

            switch (MappedValue) {
            case eClrSurrogate:
                if (SxspClrSurrogateAddSurrogate(&Data->ElementParsed, ClrGlobalContext, GSGenContext))
                    Data->ElementParsed.Success = TRUE;
                break;
            }
        }
    }

    FN_EPILOG
}

BOOL
SxspClrSurrogateAddSurrogate(
    PACTCTXCTB_CBELEMENTPARSED SurrogateParsed,
    PCLR_GLOBAL_CONTEXT pGlobalContext,
    PGUID_SECTION_GENERATION_CONTEXT pGsGenCtx
    )
{
    FN_PROLOG_WIN32
    CSmallStringBuffer RuntimeVersionBuffer;
    CSmallStringBuffer SurrogateClassNameBuffer;
    CSmallStringBuffer ClsidBuffer;
    GUID SurrogateIdent = GUID_NULL;
    bool fFound = false;
    SIZE_T cbWritten;
    CSmartPtr<CLR_SURROGATE_ENTRY> Entry;
    bool fFileContextSelfAllocated = false;

    INTERNAL_ERROR_CHECK(pGlobalContext);

    IFW32FALSE_EXIT(::SxspGetAttributeValue(
        0,
        &s_AttributeName_runtimeVersion,
        SurrogateParsed,
        fFound,
        sizeof(RuntimeVersionBuffer),
        &RuntimeVersionBuffer,
        cbWritten,
        NULL, 0));

    IFW32FALSE_EXIT(::SxspGetAttributeValue(
        SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
        &s_AttributeName_name,
        SurrogateParsed,
        fFound,
        sizeof(SurrogateClassNameBuffer),
        &SurrogateClassNameBuffer,
        cbWritten,
        NULL, 0));
    INTERNAL_ERROR_CHECK(fFound);

    IFW32FALSE_EXIT(::SxspGetAttributeValue(
        SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
        &s_AttributeName_clsid,
        SurrogateParsed,
        fFound,
        sizeof(ClsidBuffer),
        &ClsidBuffer,
        cbWritten,
        NULL, 0));
    INTERNAL_ERROR_CHECK(fFound);

    IFW32FALSE_EXIT(SxspParseGUID(ClsidBuffer, ClsidBuffer.Cch(), SurrogateIdent));

    //
    // If we were doing something other than generating an actctx, then we can leap out.
    //
    if (SurrogateParsed->Header.ManifestOperation != MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
        FN_SUCCESSFUL_EXIT();

    IFW32FALSE_EXIT(Entry.Win32Allocate(__FILE__, __LINE__));

    Entry->m_ReferenceClsid = SurrogateIdent;
    IFW32FALSE_EXIT(Entry->m_RuntimeVersion.Win32Assign(RuntimeVersionBuffer));
    IFW32FALSE_EXIT(Entry->m_TypeName.Win32Assign(SurrogateClassNameBuffer));

    IFW32FALSE_EXIT(::SxsAddGuidToGuidSectionGenerationContext(
        pGsGenCtx,
        &SurrogateIdent,
        Entry,
        SurrogateParsed->AssemblyContext->AssemblyRosterIndex,
        ERROR_SXS_DUPLICATE_CLSID));

    pGlobalContext->m_SurrogateList.AddToHead(Entry.Detach());
    
    FN_EPILOG
        
}

BOOL WINAPI
SxspClrInteropGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    FN_PROLOG_WIN32

    PCLR_GLOBAL_CONTEXT ClrGlobalContext = (PCLR_GLOBAL_CONTEXT) Context;
    INTERNAL_ERROR_CHECK(CallbackData != NULL);

    switch (Reason)
    {
    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            INTERNAL_ERROR_CHECK( ClrGlobalContext != NULL );

            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PCLR_SURROGATE_ENTRY Entry = (PCLR_SURROGATE_ENTRY) CBData->DataContext;

            if (Entry != NULL)
            {
                ClrGlobalContext->m_SurrogateList.Remove(Entry);
                FUSION_DELETE_SINGLETON(Entry);
            }

            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PCLR_SURROGATE_ENTRY Entry = (PCLR_SURROGATE_ENTRY) CBData->DataContext;

            INTERNAL_ERROR_CHECK(!Entry->m_TypeName.IsEmpty());

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_CLR_SURROGATE);
            CBData->DataSize += (Entry->m_RuntimeVersion.Cch() + 1) * sizeof(WCHAR);
            CBData->DataSize += (Entry->m_TypeName.Cch() + 1) * sizeof(WCHAR);
            break;
        }

    case GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PCLR_SURROGATE_ENTRY Entry = (PCLR_SURROGATE_ENTRY) CBData->DataContext;
            PACTIVATION_CONTEXT_DATA_CLR_SURROGATE Info;
            PVOID Cursor = CBData->Buffer;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;

            ALLOCATE_BUFFER_SPACE_TYPE(ACTIVATION_CONTEXT_DATA_CLR_SURROGATE, Cursor, BytesLeft, BytesWritten, Info);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_CLR_SURROGATE);
            Info->Flags = 0;
            Info->SurrogateIdent = Entry->m_ReferenceClsid;

            IFW32FALSE_EXIT(Entry->m_RuntimeVersion.Win32CopyIntoBuffer(
                (PWSTR*)&Cursor,
                &BytesLeft,
                &BytesWritten,
                Info,
                &Info->VersionOffset,
                &Info->VersionLength));

            IFW32FALSE_EXIT(Entry->m_TypeName.Win32CopyIntoBuffer(
                (PWSTR*)&Cursor,
                &BytesLeft,
                &BytesWritten,
                Info,
                &Info->TypeNameOffset,
                &Info->TypeNameLength));

            CBData->BytesWritten = BytesWritten;

            break;
        }
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\nodefactory.h ===
#if !defined(_FUSION_SXS_NODEFACTORY_H_INCLUDED_)
#define _FUSION_SXS_NODEFACTORY_H_INCLUDED_

#pragma once

#include "fusioneventlog.h"
#include <windows.h>
#include <sxsp.h>
#include <ole2.h>
#include <xmlparser.h>
#include "fusionbuffer.h"
#include "partialassemblyversion.h"
#include "xmlns.h"
#include "policystatement.h"

#define ELEMENT_LEGAL_ATTRIBUTE_FLAG_IGNORE             (0x00000001)
#define ELEMENT_LEGAL_ATTRIBUTE_FLAG_REQUIRED           (0x00000002)

typedef struct _ELEMENT_LEGAL_ATTRIBUTE
{
    DWORD m_dwFlags;
    PCATTRIBUTE_NAME_DESCRIPTOR m_pName;
    SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE m_pfnValidator;
    DWORD m_dwValidatorFlags;
} ELEMENT_LEGAL_ATTRIBUTE, PELEMENT_LEGAL_ATTRIBUTE;

typedef const struct _ELEMENT_LEGAL_ATTRIBUTE *PCELEMENT_LEGAL_ATTRIBUTE;

//
// ISSUE: jonwis 3/9/2002 - Consider reordering member data to group member data
//          together rather than interspersing it with functions.  Group larger
//          objects together at the front of the class, etc. to get a smaller
//          memory footprint
//
class __declspec(uuid("832ff3cf-05bd-4eda-962f-d0a5307d55ae"))
CNodeFactory : public IXMLNodeFactory
{
public:

    CNodeFactory();
    ~CNodeFactory();

    BOOL Initialize(
        PACTCTXGENCTX ActCtxGenCtx,
        PASSEMBLY Assembly,
        PACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
        );

    BOOL SetParseType(ULONG ParseType, ULONG PathType, const CBaseStringBuffer &buffFileName, const FILETIME &rftLastWriteTime);
    VOID ResetParseState();

    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef() { return 1; }
    STDMETHODIMP_(ULONG) Release() { return 1; }
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // IXMLNodeFactory methods:
    STDMETHODIMP NotifyEvent(IXMLNodeSource *pSource, XML_NODEFACTORY_EVENT iEvt);
    STDMETHODIMP BeginChildren(IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo);
    STDMETHODIMP EndChildren(IXMLNodeSource *pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo);
    STDMETHODIMP Error(IXMLNodeSource *pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);
    STDMETHODIMP CreateNode(IXMLNodeSource *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);

    HRESULT FirstCreateNodeCall(IXMLNodeSource *pSource, PVOID pNodeParent, USHORT NodeCount, const SXS_NODE_INFO *prgNodeInfo);

    enum
    {
        eValidateIdentity_VersionRequired       = 0x00000001,
        eValidateIdentity_PoliciesNotAllowed    = 0x00000002,
        eValidateIdentity_VersionNotAllowed     = 0x00000008,
    };

    enum
    {
        eActualParseType_Undetermined,
        eActualParseType_Manifest,
        eActualParseType_PolicyManifest
    } m_IntuitedParseType;


    BOOL ValidateIdentity(DWORD Flags, ULONG Type, PCASSEMBLY_IDENTITY AssemblyIdentity);
    BOOL ValidateElementAttributes(PCSXS_NODE_INFO prgNodes, SIZE_T cNodes, PCELEMENT_LEGAL_ATTRIBUTE prgAttributes, UCHAR cAttributes);

    PCACTCTXCTB_PARSE_CONTEXT GetParseContext() const { return &m_ParseContext; }

#if FUSION_XML_TREE
    HRESULT CreateXmlNode(PSXS_XML_NODE pParent, ULONG cNodes, XML_NODE_INFO **prgpNodes, PSXS_XML_NODE &rpNewNode);
#endif // FUSION_XML_TREE

// protected:
    PACTCTXGENCTX m_ActCtxGenCtx;
    PASSEMBLY m_Assembly;
    CXMLNamespaceManager m_XMLNamespaceManager;
    ULONG m_ParseType;

    bool m_fFirstCreateNodeCall;

    // We only track the state of the parse with respect to the tags that
    // we're interested in for metadata purposes.  This amounts to just the
    // <assembly> tag, and the dependencies.  We ignore the rest.
    enum XMLParseState
    {
        eNotParsing,
        eParsing_doc,
        eParsing_doc_assembly,
        eParsing_doc_assembly_assemblyIdentity,
        eParsing_doc_assembly_comInterfaceExternalProxyStub,
        eParsing_doc_assembly_description,
        eParsing_doc_assembly_dependency,
        eParsing_doc_assembly_dependency_dependentAssembly,
        eParsing_doc_assembly_dependency_dependentAssembly_assemblyIdentity,
        eParsing_doc_assembly_dependency_dependentAssembly_bindingRedirect,
        eParsing_doc_assembly_file,
        eParsing_doc_assembly_file_comClass,
        eParsing_doc_assembly_file_comClass_progid,
        eParsing_doc_assembly_file_comInterfaceProxyStub,
        eParsing_doc_assembly_file_typelib,
        eParsing_doc_assembly_file_windowClass,
        eParsing_doc_assembly_clrSurrogate,
        eParsing_doc_assembly_clrClass,
        eParsing_doc_assembly_clrClass_progid,
        eParsing_doc_assembly_noInherit,
        eParsing_doc_assembly_noInheritable,
        eParsing_doc_configuration,
        eParsing_doc_configuration_windows,
        eParsing_doc_configuration_windows_assemblyBinding,
        eParsing_doc_configuration_windows_assemblyBinding_publisherPolicy,
        eParsing_doc_configuration_windows_assemblyBinding_assemblyIdentity,
        eParsing_doc_configuration_windows_assemblyBinding_dependentAssembly,
        eParsing_doc_configuration_windows_assemblyBinding_dependentAssembly_assemblyIdentity,
        eParsing_doc_configuration_windows_assemblyBinding_dependentAssembly_bindingRedirect,
        eParsing_doc_configuration_windows_assemblyBinding_dependentAssembly_publisherPolicy,
        eFatalParseError,
    } m_xpsParseState;

    ULONG m_cUnknownChildDepth;
    PACTCTXCTB_ASSEMBLY_CONTEXT m_AssemblyContext;
    ACTCTXCTB_PARSE_CONTEXT m_ParseContext;
    CSmallStringBuffer m_buffElementPath;
    CStringBuffer m_buffCurrentFileName;

    PASSEMBLY_IDENTITY m_CurrentPolicyDependentAssemblyIdentity;
    CPolicyStatement *m_CurrentPolicyStatement;
    CCaseInsensitiveUnicodeStringPtrTable<CPolicyStatement> *m_pApplicationPolicyTable;
    CStringBuffer m_buffCurrentApplicationPolicyIdentityKey;

    bool m_fAssemblyFound;
    bool m_fIdentityFound;
    bool m_fIsDependencyOptional;
    bool m_fDependencyChildHit;
    bool m_fAssemblyIdentityChildOfDependenctAssemblyHit;
    bool m_fIsMetadataSatellite;
    bool m_fMetadataSatelliteAlreadyFound;
    bool m_fNoInheritableFound;

    HRESULT ConvertXMLNodeInfoToSXSNodeInfo(const XML_NODE_INFO *pNodeInfo, SXS_NODE_INFO & sxsNodeInfo);

    //
    //  XML Parsing worker functions:
    //

    typedef BOOL (CNodeFactory::*XMLParserWorkerFunctionPtr)(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);

    BOOL XMLParser_Element_doc_assembly(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_noInherit(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_noInheritable(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_assemblyIdentity(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_dependency(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_dependency_dependentAssembly(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_dependency_dependentAssembly_assemblyIdentity(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_assembly_dependency_dependentAssembly_bindingRedirect(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);

    BOOL XMLParser_Element_doc_configuration(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding_assemblyIdentity(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding_publisherPolicy(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly_assemblyIdentity(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly_bindingRedirect(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);
    BOOL XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly_publisherPolicy(USHORT cNumRecs, PCSXS_NODE_INFO prgNodeInfo);


    //
    //  Parsing helper functions:
    //

    enum XMLAttributeType
    {
        eAttributeTypeString,   // represented by a CStringBuffer
        eAttributeTypeVersion,  // represented by a ASSEMBLY_VERSION
    };

    //
    //  Parser datatype specific worker functions.  The first two parameters
    //  are combined to refer the member to actually modify.  The third is the
    //  character string to be used as the value of the attribute.
    //
    //  As an optimization, the datatype worker function may modify/destroy
    //  the value in the third parameter.  For example, the worker function
    //  which just copies a CStringBuffer to another CStringBuffer actually
    //  uses the CStringBuffer::TakeValue() member which avoids performing
    //  a dynamic allocation if the attribute value exceeded the non-dynamically
    //  allocated portion of the CStringBuffer.
    //

    typedef BOOL (CNodeFactory::*XMLParserValueParserFunctionPtr)(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);

    BOOL XMLParser_Parse_String(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_Version(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_ULARGE_INTEGER(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_FILETIME(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_GUID(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_BLOB(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_InstallAction(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_Boolean(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);
    BOOL XMLParser_Parse_PartialAssemblyVersion(LPVOID pvDatum, BOOL fAlreadyFound, CBaseStringBuffer &rbuff);

    struct AttributeMapEntry
    {
        LPCWSTR m_pszAttributeName;
        SIZE_T m_cchAttributeName;
        SIZE_T m_offsetData;
        SIZE_T m_offsetIndicator;
        XMLParserValueParserFunctionPtr m_pfn;
    };

    BOOL ParseElementAttributes(
        USHORT cNumRecs,
        XML_NODE_INFO **prgpNodeInfo,
        SIZE_T cAttributeMapEntries,
        const AttributeMapEntry *prgEntries);

    HRESULT LogParseError(
        DWORD dwLastParseError,
        const UNICODE_STRING *p1 = NULL,
        const UNICODE_STRING *p2 = NULL,
        const UNICODE_STRING *p3 = NULL,
        const UNICODE_STRING *p4 = NULL,
        const UNICODE_STRING *p5 = NULL,
        const UNICODE_STRING *p6 = NULL,
        const UNICODE_STRING *p7 = NULL,
        const UNICODE_STRING *p8 = NULL,
        const UNICODE_STRING *p9 = NULL,
        const UNICODE_STRING *p10 = NULL,
        const UNICODE_STRING *p11 = NULL,
        const UNICODE_STRING *p12 = NULL,
        const UNICODE_STRING *p13 = NULL,
        const UNICODE_STRING *p14 = NULL,
        const UNICODE_STRING *p15 = NULL,
        const UNICODE_STRING *p16 = NULL,
        const UNICODE_STRING *p17 = NULL,
        const UNICODE_STRING *p18 = NULL,
        const UNICODE_STRING *p19 = NULL,
        const UNICODE_STRING *p20 = NULL
        );

    static VOID WINAPI ParseErrorCallback_MissingRequiredAttribute(
        PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
        );

    static VOID WINAPI ParseErrorCallback_AttributeNotAllowed(
        IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
        );

    static VOID WINAPI ParseErrorCallback_InvalidAttributeValue(
        IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
        IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
        );

private:
    CNodeFactory(const CNodeFactory &);
    void operator =(const CNodeFactory &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\nodefactory.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "actctxgenctx.h"

//
// ISSUE: jonwis 3/9/2002 - This file is full of missing parameter checking.
//
// NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Parameter checking (#1)
// NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - FN_PROLOG/EPILOG (#2)

#define DEFINE_ATTRIBUTE(attributeName, attributeType, typePrefix) \
    { \
        L ## #attributeName, \
        offsetof(CNodeFactory, m_ ## typePrefix ## _ ## attributeName), \
        offsetof(CNodeFactory, m_f ## attributeName ## _ ## Present), \
        &CNodeFactory::XMLParser_Parse_ ## attributeType \
    },

const static ASSEMBLY_VERSION assemblyVersion0 = {0,0,0,0};

typedef enum _in_xml_tag_when_identity_generated_{
    SXS_IN_INVALID_XML_TAG_WHEN_ASSEMBLY_IDENTITY_GENERATED,
    SXS_IN_ASSEMBLY_TAG,
    SXS_IN_DEPENDENCY_TAG
}SXS_IN_XML_TAG_WHEN_IDENTITY_GENERATED;

VOID
SxspDbgPrintXmlNodeInfo(
    ULONG Level,
    XML_NODE_INFO *pNode
 );

PCSTR
SxspFormatXmlNodeType(
    DWORD dwType
 );

struct EventIdErrorPair
{
    DWORD   dwEventId;
    LONG    nError;
};

const static EventIdErrorPair eventIdToErrorMap[] =
{
    #include "messages.hi" // generated from .x file, like .mc
};

// deliberately no extra paranetheses here
#define NODEFACTORY_STRING_AND_LENGTH(x) x, NUMBER_OF(x) - 1

const static SXS_NAME_LENGTH_PAIR IgnoredAttributesInDependencyTagForIdentity[]={
    //maybe more later
    { NODEFACTORY_STRING_AND_LENGTH(L"Description") }
};

const DWORD IGNORED_ATTRIBUTE_NUM_IN_DEPENDENCY_TAG = NUMBER_OF(IgnoredAttributesInDependencyTagForIdentity);

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(baseInterface);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(clsid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(description);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(flags);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(hash);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(hashalg);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(helpdir);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(iid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(language);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(loadFrom);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(manifestVersion);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(metadataSatellite);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(newVersion);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(numMethods);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(oldVersion);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(optional);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(processorArchitecture);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(progid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(proxyStubClsid32);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(publicKeyToken);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(publicKey);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(resourceid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(runtimeVersion);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(size);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(threadingModel);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(tlbid);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(type);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(version);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(versioned);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(apply);

    // How to interpret the parser worker rules here:
    //
    //  First, the state of the parser must match m_xps for the rule to be considered.
    //      If the value eNotParsing is in the table, it matches any current parser
    //      state.  Use this to globally ignore some particular tag type when
    //      combined with a NULL m_pszTag and NULL m_pfn.
    //  Second, the type of the tag from the XML parser must match m_dwType.
    //  If m_pszTag is not NULL, a case-insensitive comparison is done between the
    //      string m_pszTag points to and the tag from the XML parser.  An m_pszTag
    //      value of NULL matches any tag.
    //  If the three criteria match, the worker function is called.  The worker function
    //  pointer may be NULL, in which case no action is taken.  (This is useful for
    //  callbacks from the parser about XML_WHITESPACE where we don't really have to do
    //  anything at all.)
    //

#define DEFINE_TAG_WORKER_IGNOREALLOFTYPE(dwType) { CNodeFactory::eNotParsing, (dwType), NULL, NULL, NULL, 0, 0, 0, NULL }

    //
    //  Notes on use of the DEFINE_TAG_WORKER_ELEMENT() macro:
    //
    //  The first parameter, sourceState, is part of the name of a XMLParseState
    //  enumeration value.  It is concatenated onto "eParsing" to form the name of
    //  the state which the rule will match.
    //
    //  The second parameter is both the text of the tag to match and is used to
    //  form the name of the function to invoke if the rule matches.  The tag is
    //  compared case-insensitively, and the name of the member function invoked
    //  is XMLParser_Element_ followed by the sourceState string followed by another
    //  underscore, followed by the tagName string.  So, for example, the following
    //  rule:
    //
    //  DEFINE_TAG_WORKER_ELEMENT(DepAssy, Version)
    //
    //  says that when the parser is in the eParsingDepAssy state and a "Version"
    //  tag is found, call the function CNodeFactory::XMLParser_Element_DepAssy_Version().
    //

#define DEFINE_TAG_WORKER_ELEMENT(sourceState, tagName) \
    { \
        CNodeFactory::eParsing_ ## sourceState, \
        XML_ELEMENT, \
        SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE, \
        L ## #tagName, \
        s_rg_ ## sourceState ## _ ## tagName ## _attributes, \
        NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE) - 1, \
        NUMBER_OF(L ## #tagName) - 1, \
        NUMBER_OF(s_rg_ ## sourceState ## _ ## tagName ## _attributes), \
        &CNodeFactory::XMLParser_Element_ ## sourceState ## _ ## tagName, \
        CNodeFactory::eParsing_ ## sourceState ## _ ## tagName \
    }

#define DEFINE_TAG_WORKER_ELEMENT_NOCB(sourceState, tagName) \
    { \
        CNodeFactory::eParsing_ ## sourceState, \
        XML_ELEMENT, \
        SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE, \
        L ## #tagName, \
        s_rg_ ## sourceState ## _ ## tagName ## _attributes, \
        NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE) - 1, \
        NUMBER_OF(L ## #tagName) - 1, \
        NUMBER_OF(s_rg_ ## sourceState ## _ ## tagName ## _attributes), \
        NULL, \
        CNodeFactory::eParsing_ ## sourceState ## _ ## tagName \
    }

#define DEFINE_TAG_WORKER_ELEMENT_NONS(sourceState, tagName) \
    { \
        CNodeFactory::eParsing_ ## sourceState, \
        XML_ELEMENT, \
        NULL, \
        L ## #tagName, \
        s_rg_ ## sourceState ## _ ## tagName ## _attributes, \
        0, \
        NUMBER_OF(L ## #tagName) - 1, \
        NUMBER_OF(s_rg_ ## sourceState ## _ ## tagName ## _attributes), \
        &CNodeFactory::XMLParser_Element_ ## sourceState ## _ ## tagName, \
        CNodeFactory::eParsing_ ## sourceState ## _ ## tagName \
    }

#define BEGIN_ELEMENT_LEGAL_ATTRIBUTES(_element) \
const static ELEMENT_LEGAL_ATTRIBUTE s_rg_ ## _element ## _attributes[] = { \
    { ELEMENT_LEGAL_ATTRIBUTE_FLAG_IGNORE, NULL, NULL },

#define DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(attributeName, validatorFlags, validator) { ELEMENT_LEGAL_ATTRIBUTE_FLAG_REQUIRED, &s_AttributeName_ ## attributeName, validator, validatorFlags },
#define DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(attributeName, validatorFlags, validator) { 0, &s_AttributeName_ ## attributeName, validator, validatorFlags },

#define END_ELEMENT_LEGAL_ATTRIBUTES(_element) };

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(manifestVersion, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_description)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_description)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_noInherit)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_noInherit)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_noInheritable)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_noInheritable)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_assemblyIdentity)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(version, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(type, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(processorArchitecture, SXSP_VALIDATE_PROCESSOR_ARCHITECTURE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED, &::SxspValidateProcessorArchitectureAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(publicKeyToken, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(language, 0, &::SxspValidateLanguageAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(publicKey, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_assemblyIdentity)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(optional, 0, &::SxspValidateBoolAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly_assemblyIdentity)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(type, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(version, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(processorArchitecture, SXSP_VALIDATE_PROCESSOR_ARCHITECTURE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED, &::SxspValidateProcessorArchitectureAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(publicKeyToken, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(language, SXSP_VALIDATE_LANGUAGE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED, &::SxspValidateLanguageAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly_assemblyIdentity)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly_bindingRedirect)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(oldVersion, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(newVersion, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_dependency_dependentAssembly_bindingRedirect)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(hash, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(hashalg, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(loadFrom, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(size, 0, &::SxspValidateUnsigned64Attribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comClass)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(clsid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(threadingModel, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(progid, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(tlbid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(description, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comClass)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comClass_progid)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comClass_progid)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_clrClass)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(clsid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(progid, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(tlbid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(description, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(runtimeVersion, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(threadingModel, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_clrClass)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_clrSurrogate)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(clsid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(runtimeVersion, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_clrSurrogate)


BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_clrClass_progid)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_clrClass_progid)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comInterfaceProxyStub)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(iid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(tlbid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(numMethods, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(baseInterface, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(proxyStubClsid32, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(threadingModel, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_comInterfaceProxyStub)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_typelib)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(tlbid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(version, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(helpdir, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(resourceid, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(flags, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_typelib)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_windowClass)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(versioned, 0, &::SxspValidateBoolAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_file_windowClass)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_comInterfaceExternalProxyStub)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(iid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(proxyStubClsid32, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(tlbid, 0, &::SxspValidateGuidAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(numMethods, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(baseInterface, 0, &::SxspValidateGuidAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_assembly_comInterfaceExternalProxyStub)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_assemblyIdentity)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(version, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(type, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(processorArchitecture,  0, &::SxspValidateProcessorArchitectureAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(publicKeyToken, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(language, 0, &::SxspValidateLanguageAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_assemblyIdentity)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly_publisherPolicy)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(apply, 0, &::SxspValidateBoolAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly_publisherPolicy)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_publisherPolicy)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(apply, 0, &::SxspValidateBoolAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_publisherPolicy)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly_assemblyIdentity)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(name, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(processorArchitecture,  0, &::SxspValidateProcessorArchitectureAttribute)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(type, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(publicKeyToken, 0, NULL)
    DEFINE_ELEMENT_NONS_OPTIONAL_ATTRIBUTE(language, 0, &::SxspValidateLanguageAttribute)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly_assemblyIdentity)

BEGIN_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly_bindingRedirect)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(oldVersion, 0, NULL)
    DEFINE_ELEMENT_NONS_REQUIRED_ATTRIBUTE(newVersion, 0, NULL)
END_ELEMENT_LEGAL_ATTRIBUTES(doc_configuration_windows_assemblyBinding_dependentAssembly_bindingRedirect)

static const struct
{
    CNodeFactory::XMLParseState m_xpsOld;
    DWORD m_dwType;
    PCWSTR m_pszNamespace;
    PCWSTR m_pszName;
    PCELEMENT_LEGAL_ATTRIBUTE m_prgLegalAttributes;
    UCHAR m_cchNamespace;           // We use UCHAR here just for greater data density.  Changing this and rebuilding
    UCHAR m_cchName;                // this module should work fine if you really need namespaces or names longer than
                                    // 255 characters.
    UCHAR m_cLegalAttributes;
    CNodeFactory::XMLParserWorkerFunctionPtr m_pfn;
    CNodeFactory::XMLParseState m_xpsNew;
} s_rgWorkers[] =
{
    DEFINE_TAG_WORKER_IGNOREALLOFTYPE(XML_WHITESPACE),
    DEFINE_TAG_WORKER_IGNOREALLOFTYPE(XML_COMMENT),
    DEFINE_TAG_WORKER_ELEMENT(doc, assembly),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly, assemblyIdentity),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly, description),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly, noInherit),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly, noInheritable),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly, dependency),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly_dependency, dependentAssembly),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly_dependency_dependentAssembly, assemblyIdentity),
    DEFINE_TAG_WORKER_ELEMENT(doc_assembly_dependency_dependentAssembly, bindingRedirect),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly, file),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_file, comClass),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_file_comClass, progid),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly, clrClass),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_clrClass, progid),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_file, comInterfaceProxyStub),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_file, typelib),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly_file, windowClass),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly, clrSurrogate),
    DEFINE_TAG_WORKER_ELEMENT_NOCB(doc_assembly, comInterfaceExternalProxyStub),

    // All app config productions go here, just for neatness
    DEFINE_TAG_WORKER_ELEMENT_NONS(doc, configuration),
    DEFINE_TAG_WORKER_ELEMENT_NONS(doc_configuration, windows),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows, assemblyBinding),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows_assemblyBinding, assemblyIdentity),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows_assemblyBinding, dependentAssembly),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows_assemblyBinding, publisherPolicy),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows_assemblyBinding_dependentAssembly, assemblyIdentity),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows_assemblyBinding_dependentAssembly, bindingRedirect),
    DEFINE_TAG_WORKER_ELEMENT(doc_configuration_windows_assemblyBinding_dependentAssembly, publisherPolicy),
};

BOOL
SxspIsNamespaceDeclaration(XML_NODE_INFO *pNodeInfo)
{
    FN_TRACE();
    
    ASSERT(pNodeInfo->dwType == XML_ATTRIBUTE);

    //
    // ISSUE: jonwis 3/8/2002 - Could use FusionpCompareString rather than doing it the 'hard way'
    // 
    if (pNodeInfo->ulLen >= 5)
    { // "xmlns" : prefix for namespace declaration, default ns or non-default ns
        if ((pNodeInfo->pwcText[0] == L'x') &&
            (pNodeInfo->pwcText[1] == L'm') &&
            (pNodeInfo->pwcText[2] == L'l') &&
            (pNodeInfo->pwcText[3] == L'n') &&
            (pNodeInfo->pwcText[4] == L's'))
        {
            if (pNodeInfo->ulLen == 5) // like xmlns="", default ns declaration
                return TRUE;
            else
                if (pNodeInfo->pwcText[5] == L':')
                    return TRUE;
        }
    }

    return FALSE;
}
//In this function, two tasks:
// 1) verify PublicKey and StrongName
// 2) create AssemblyIdentity based on xmlnode array
// 3) for (name, processorArchitecure, version. langid) they would be unique with SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE
// 4) if there are dup triples {nsURL, name, value), only one is count, this is done with SxsCreateAssemblyIdentity
BOOL
SxspCreateAssemblyIdentityFromIdentityElement(
    DWORD Flags,
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    ULONG Type,
    PASSEMBLY_IDENTITY *AssemblyIdentityOut,
    DWORD cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    DWORD i;
    //
    // ISSUE: 3/9/2002 - Consider using a smart pointer here for AssemblyIdentity
    //      CSxsPointerWithNamedDestructor<ASSEMBLY_IDENTITY, ::SxsDestroyAssemblyIdentity> AssemblyIdentity;
    //
    // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Leaking memory here if AssemblyIdentity isn't cleaned up (#3)
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    CStringBuffer buffValue;

    if (AssemblyIdentityOut != NULL)
         *AssemblyIdentityOut = NULL;

    PARAMETER_CHECK((Flags & ~(SXSP_CREATE_ASSEMBLY_IDENTITY_FROM_IDENTITY_TAG_FLAG_VERIFY_PUBLIC_KEY_IF_PRESENT)) == 0);
    PARAMETER_CHECK((Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) || (Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE));
    PARAMETER_CHECK(AssemblyIdentityOut != NULL);
    PARAMETER_CHECK(prgNodeInfo != NULL);
    PARAMETER_CHECK(prgNodeInfo[0].Type == XML_ELEMENT);

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, Type, &AssemblyIdentity, 0, NULL));

    // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Why not use a 'for' loop? (#4)
    i = 1;
    while (i<cNumRecs)
    {
        ULONG j;
        INTERNAL_ERROR_CHECK(prgNodeInfo[i].Type == XML_ATTRIBUTE);

        buffValue.Clear();

        //
        // ISSUE: jonwis 3/9/2002 - Consider moving this to a for() loop for optimization's sake:
        //          for (j = i + 1; ((j < cNumRec) && (prgNodeInfo[j].Type == XML_PCDATA)); j++)
        //
        j = i + 1;

        while ((j < cNumRecs) && (prgNodeInfo[j].Type == XML_PCDATA))
        {
            IFW32FALSE_EXIT(buffValue.Win32Append(prgNodeInfo[j].pszText, prgNodeInfo[j].cchText));

            j++;
        }

        // if this is a special attribute, we'll handle it ... specially.
        if ((prgNodeInfo[i].NamespaceStringBuf.Cch() == 0) &&
            (::FusionpCompareStrings(
                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY,
                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_CCH,
                prgNodeInfo[i].pszText,
                prgNodeInfo[i].cchText,
                false) == 0))
        {// ignore publicKey if it appears in assembly identity
        }
        else
        {
            //
            // ISSUE: jonwis 3/9/2002 - Consider moving this to initialization rather than assignment
            //
            // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Compiler is better than you are (#5)
            ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;

            Attribute.Flags = 0;
            Attribute.NamespaceCch  = prgNodeInfo[i].NamespaceStringBuf.Cch();
            Attribute.Namespace     = prgNodeInfo[i].NamespaceStringBuf;
            Attribute.NameCch       = prgNodeInfo[i].cchText;
            Attribute.Name          = prgNodeInfo[i].pszText;
            Attribute.ValueCch      = buffValue.Cch();
            Attribute.Value         = buffValue;

            IFW32FALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(0, AssemblyIdentity, &Attribute));
        }

        i = j;
    }

    *AssemblyIdentityOut = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;
Exit:
    if (AssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(AssemblyIdentity);
    return fSuccess;
}

//
// ISSUE: jonwis 3/9/2002 - Consider reordering initializers to read more like what's in the
//      class def for simpler reading.  Also consider using a smart-pointer object to manage
//      the m_Assembly, rather than doing our own management.  Same for the ASSEMBLY_IDENTITY
//      m_CurrentPolicyDependentAssemblyIdentity
//
// NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Odd ordering of initializers (#6)
CNodeFactory::CNodeFactory()
        : m_ActCtxGenCtx(NULL),
          m_Assembly(NULL),
          m_fFirstCreateNodeCall(true),
          m_cUnknownChildDepth(0),
          m_xpsParseState(eParsing_doc),
          m_fAssemblyFound(false),
          m_fIdentityFound(false),
          m_AssemblyContext(NULL),
          m_CurrentPolicyDependentAssemblyIdentity(NULL),
          m_CurrentPolicyStatement(NULL),
          m_IntuitedParseType(eActualParseType_Undetermined),
          m_pApplicationPolicyTable(NULL),          
          m_fNoInheritableFound(false)
{
    m_ParseContext.XMLElementDepth = 0;
    m_ParseContext.ElementPath = NULL;
    m_ParseContext.ElementPathCch = 0;
    m_ParseContext.ElementName = NULL;
    m_ParseContext.ElementPathCch = 0;
    m_ParseContext.ElementHash = 0;
}

CNodeFactory::~CNodeFactory()
{
    CSxsPreserveLastError ple;

    if ((m_CurrentPolicyStatement != NULL) &&
        (m_CurrentPolicyDependentAssemblyIdentity != NULL) &&
        (m_pApplicationPolicyTable != NULL))
    {
#if 1
        if (m_pApplicationPolicyTable->Find(m_buffCurrentApplicationPolicyIdentityKey, m_CurrentPolicyStatement))
            m_CurrentPolicyStatement = NULL;
#else
        CStringBuffer EncodedPolicyIdentity; 
        if (::SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
            SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION,
            m_CurrentPolicyDependentAssemblyIdentity,
            EncodedPolicyIdentity,
            NULL))
        {
            if (m_pApplicationPolicyTable->Find(EncodedPolicyIdentity, m_CurrentPolicyStatement))
            {
                m_CurrentPolicyStatement = NULL; // leave the cleanup work to outer destructor
            }
        }
#endif
    }

    FUSION_DELETE_SINGLETON(m_CurrentPolicyStatement);

    if (m_CurrentPolicyDependentAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(m_CurrentPolicyDependentAssemblyIdentity);

    if (m_Assembly != NULL)
    {
        m_Assembly->Release();
        m_Assembly = NULL;
    }

    ple.Restore();
}

BOOL
CNodeFactory::Initialize(
    PACTCTXGENCTX ActCtxGenCtx,
    PASSEMBLY Assembly,
    PACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(Assembly != NULL);

    IFW32FALSE_EXIT(m_XMLNamespaceManager.Initialize());

    m_ActCtxGenCtx = ActCtxGenCtx;

    Assembly->AddRef();
    if (m_Assembly != NULL)
        m_Assembly->Release();
    m_Assembly = Assembly;

    m_AssemblyContext = AssemblyContext;
    m_ParseContext.AssemblyContext = AssemblyContext;
    m_ParseContext.ErrorCallbacks.MissingRequiredAttribute = &CNodeFactory::ParseErrorCallback_MissingRequiredAttribute;
    m_ParseContext.ErrorCallbacks.AttributeNotAllowed = &CNodeFactory::ParseErrorCallback_AttributeNotAllowed;
    m_ParseContext.ErrorCallbacks.InvalidAttributeValue = &CNodeFactory::ParseErrorCallback_InvalidAttributeValue;
    m_ParseContext.SourceFilePathType = AssemblyContext->ManifestPathType;
    m_ParseContext.SourceFile = AssemblyContext->ManifestPath;
    m_ParseContext.SourceFileCch = AssemblyContext->ManifestPathCch;
    m_ParseContext.LineNumber = 0;

    FN_EPILOG
}

VOID
CNodeFactory::ResetParseState()
{
    m_fFirstCreateNodeCall = true;
    m_fAssemblyFound = false;
    m_fIdentityFound = false;
    m_fNoInheritableFound = false;

    FUSION_DELETE_SINGLETON(m_CurrentPolicyStatement);
    m_CurrentPolicyStatement = NULL;

    ::SxsDestroyAssemblyIdentity(m_CurrentPolicyDependentAssemblyIdentity);
    m_CurrentPolicyDependentAssemblyIdentity = NULL;    
}

HRESULT
CNodeFactory::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj
    )
{
    FN_PROLOG_HR
    IUnknown *pIUnknown = NULL;

    if (ppvObj != NULL)
        *ppvObj = NULL;
    else
        ORIGINATE_HR_FAILURE_AND_EXIT(CNodeFactory::QueryInterface, E_POINTER);

    if (riid == __uuidof(this))
        pIUnknown = this;
    else if ((riid == IID_IUnknown) || (riid == IID_IXMLNodeFactory))
        pIUnknown = static_cast<IXMLNodeFactory *>(this);
    else
        ORIGINATE_HR_FAILURE_AND_EXIT(CNodeFactory::QueryInterface, E_NOINTERFACE);

    pIUnknown->AddRef();
    *ppvObj = pIUnknown;

    FN_EPILOG
}

HRESULT
CNodeFactory::NotifyEvent(
    IXMLNodeSource *pSource,
    XML_NODEFACTORY_EVENT iEvt
    )
{
    return NOERROR;
}

HRESULT
CNodeFactory::ConvertXMLNodeInfoToSXSNodeInfo(
	const XML_NODE_INFO *pNodeInfo,
	SXS_NODE_INFO &rSXSNodeInfo
	)
{
    //
    // ISSUE: jonwis 3/9/2002 - Consider filling out a private SXS_NODE_INFO and assigning it to
    //          the output SXSNodeInfo on success.
    //
    // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Use a private SXS_NODE_INFO (#7)
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    INTERNAL_ERROR_CHECK(pNodeInfo != NULL);

    rSXSNodeInfo.Size = pNodeInfo->dwSize;
    rSXSNodeInfo.Type = pNodeInfo->dwType;

    switch (pNodeInfo->dwType)
    {
    case XML_ELEMENT:
        {
            SIZE_T cchNamespacePrefix;
            IFCOMFAILED_EXIT(
                m_XMLNamespaceManager.Map(
                    0,
                    pNodeInfo,
                    &rSXSNodeInfo.NamespaceStringBuf,
                    &cchNamespacePrefix));

            // +1 to skip colon
            rSXSNodeInfo.pszText = pNodeInfo->pwcText + ((cchNamespacePrefix != 0) ? (cchNamespacePrefix + 1) : 0);
            rSXSNodeInfo.cchText = pNodeInfo->ulLen - ((cchNamespacePrefix != 0) ? (cchNamespacePrefix + 1) : 0);

            break;
        }

    case XML_ATTRIBUTE:
        {
            SIZE_T cchNamespacePrefix;

            //
            // ISSUE: jonwis 3/9/2002 - I think this is questionable. Why are we allowing through
            //          attributes named "xmlns:" and "xmlns="?  Shouldn't these have been fixed earlier?
            //
            // ISSUE:2002-3-29:jonwis - I also think that this is a gross method of doing this work.  Calling
            //          wcslen on constants is a "bad thing."  There's got to be something better we
            //          could be doing here.
            // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Wierd passthroughs of xmlns variants

            // if this is a namespace definition, ignore
            const PCWSTR pwcText = pNodeInfo->pwcText;
            if ((pwcText[0] == L'x') &&
                (pwcText[1] == L'm') &&
                (pwcText[2] == L'l') &&
                (pwcText[3] == L'n') &&
                (pwcText[4] == L's') &&
                ((pwcText[5] == L':') ||
                 (pwcText[5] == L'=')))
            {
                rSXSNodeInfo.pszText = pNodeInfo->pwcText;
                rSXSNodeInfo.cchText = pNodeInfo->ulLen;
            }
            else
            {
                IFCOMFAILED_EXIT(
                    m_XMLNamespaceManager.Map(
                        CXMLNamespaceManager::eMapFlag_DoNotApplyDefaultNamespace,
                        pNodeInfo,
                        &rSXSNodeInfo.NamespaceStringBuf,
                        &cchNamespacePrefix));

                // +1 to skip colon
                rSXSNodeInfo.pszText = pNodeInfo->pwcText + ((cchNamespacePrefix != 0) ? (cchNamespacePrefix + 1) : 0);
                rSXSNodeInfo.cchText = pNodeInfo->ulLen - ((cchNamespacePrefix != 0) ? (cchNamespacePrefix + 1) : 0);
            }
            break;
        }

    default:
        // Otherwise we'll assume there's no namespace processing to do...
        rSXSNodeInfo.NamespaceStringBuf.Clear();
        rSXSNodeInfo.pszText = pNodeInfo->pwcText;
        rSXSNodeInfo.cchText = pNodeInfo->ulLen;
        break;
    }

	FN_EPILOG
}

HRESULT
CNodeFactory::BeginChildren(
    IXMLNodeSource *pSource,
    XML_NODE_INFO *pNodeInfo
    )
{
    FN_PROLOG_HR

    ULONG i = 0;
    SXS_NODE_INFO SXSNodeInfo;

    IFCOMFAILED_EXIT(m_XMLNamespaceManager.OnBeginChildren(pSource, pNodeInfo));

    IFCOMFAILED_EXIT(this->ConvertXMLNodeInfoToSXSNodeInfo(pNodeInfo, SXSNodeInfo));
    for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
    {
        IFW32FALSE_EXIT(
            m_ActCtxGenCtx->m_Contributors[i].Fire_BeginChildren(
                m_ActCtxGenCtx,
                m_AssemblyContext,
                &m_ParseContext,
                &SXSNodeInfo));
    }

    FN_EPILOG
}

HRESULT
CNodeFactory::EndChildren(
    IXMLNodeSource *pSource,
    BOOL Empty,
    XML_NODE_INFO *pNodeInfo
    )
{
    FN_PROLOG_HR
    ULONG i = 0;
    PWSTR Bang = NULL;
    SXS_NODE_INFO SXSNodeInfo;

    // Short-circuit PIs, XML-decls, whitespace and comments
    if ((pNodeInfo->dwType == XML_PI) ||
        (pNodeInfo->dwType == XML_XMLDECL) ||
        (pNodeInfo->dwType == XML_COMMENT) ||
        (pNodeInfo->dwType == XML_WHITESPACE))
    {
        FN_SUCCESSFUL_EXIT();

    }

    IFCOMFAILED_EXIT(m_XMLNamespaceManager.OnEndChildren(pSource, Empty, pNodeInfo));
    // We hit the end of something; if we're skipping stuff, we're one level back towards
    // paying attention.
    if (m_cUnknownChildDepth != 0)
    {
        m_cUnknownChildDepth--;
    }
    else
    {
        ULONG j;

        for (j=0; j<NUMBER_OF(s_rgWorkers); j++)
        {
            if (s_rgWorkers[j].m_xpsNew == m_xpsParseState)
            {
                m_xpsParseState = s_rgWorkers[j].m_xpsOld;
                break;
            }
        }

        if (j == NUMBER_OF(s_rgWorkers))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s() called when we were not expecting it.  m_xpsParseState = %d\n", __FUNCTION__, m_xpsParseState);

            INTERNAL_ERROR_CHECK(FALSE);
            // Hey, how the heck did we get here?
        }

        // One time end-of-manifest checks...
        if (m_xpsParseState == eParsing_doc)
        {
            switch (m_ParseType)
            {
            default:
                INTERNAL_ERROR_CHECK(false);
                break;

            case XML_FILE_TYPE_COMPONENT_CONFIGURATION:
            case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
                break;

            case XML_FILE_TYPE_MANIFEST:
                // If this is not the root assembly, this is not a noInherit actctx and the noInheritable
                // element was not found, issue an error.
                if (((m_AssemblyContext->Flags & ACTCTXCTB_ASSEMBLY_CONTEXT_IS_ROOT_ASSEMBLY) == 0) &&
                    m_ActCtxGenCtx->m_NoInherit &&
                    !m_fNoInheritableFound)
                {
                    this->LogParseError(MSG_SXS_NOINHERIT_REQUIRES_NOINHERITABLE);
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(NoInheritRequiresNoInheritable, ERROR_SXS_MANIFEST_PARSE_ERROR);
                }
                break;
            }
        }
    }

    if (pNodeInfo->dwType != XML_XMLDECL)
    {
        IFCOMFAILED_EXIT(this->ConvertXMLNodeInfoToSXSNodeInfo(pNodeInfo, SXSNodeInfo));

        for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
        {
            IFW32FALSE_EXIT(
                m_ActCtxGenCtx->m_Contributors[i].Fire_EndChildren(
                    m_ActCtxGenCtx,
                    m_AssemblyContext,
                    &m_ParseContext,
                    Empty,
                    &SXSNodeInfo));
        }

        INTERNAL_ERROR_CHECK(m_ParseContext.XMLElementDepth != 0);

        //
        // ISSUE: jonwis 3/9/2002 - Comment this better! It's hard to figure out what this is doing.
        //          It's apparently turning "foo!bar!bas" into "foo!bar", and "foo" into "". This
        //          could probably be done much better with some cleaning.
        //
        // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Cleanup this string-fixer code (#9)
        m_ParseContext.XMLElementDepth--;
        Bang = wcsrchr(m_buffElementPath, L'!');

        INTERNAL_ERROR_CHECK(((Bang == NULL) == (m_ParseContext.XMLElementDepth == 0)));

        if (Bang != NULL)
        {
            m_buffElementPath.Left(Bang - m_buffElementPath);
            m_ParseContext.ElementPathCch = m_buffElementPath.Cch();
            m_ParseContext.ElementPath = m_buffElementPath;
            m_ParseContext.ElementName = wcsrchr(m_buffElementPath, L'!');
            if (m_ParseContext.ElementName == NULL)
            {
                m_ParseContext.ElementName = m_buffElementPath;
                m_ParseContext.ElementNameCch = m_buffElementPath.Cch();
            }
            else
            {
                m_ParseContext.ElementName++;
                m_ParseContext.ElementNameCch = m_buffElementPath.Cch() - (m_ParseContext.ElementName - m_buffElementPath);
            }

            IFW32FALSE_ORIGINATE_AND_EXIT(
                ::SxspHashString(
                    m_buffElementPath,
                    m_ParseContext.ElementPathCch,
                    &m_ParseContext.ElementHash,
                    false));
        }
        else
        {
            m_buffElementPath.Clear();
            m_ParseContext.ElementPath = NULL;
            m_ParseContext.ElementPathCch = 0;
            m_ParseContext.ElementName = NULL;
            m_ParseContext.ElementNameCch = 0;
            m_ParseContext.ElementHash = 0;
            m_ParseContext.XMLElementDepth = 0;
        }
    }

    FN_EPILOG
}

HRESULT
CNodeFactory::Error(
    IXMLNodeSource *pSource,
    HRESULT hrErrorCode,
    USHORT cNumRecs,
    XML_NODE_INFO **apNodeInfo
    )
{
    CSxsPreserveLastError ple;
    ::FusionpConvertCOMFailure(hrErrorCode);
    ::FusionpSetLastErrorFromHRESULT(hrErrorCode);
    this->LogParseError(MSG_SXS_WIN32_ERROR_MSG_WHEN_PARSING_MANIFEST, CEventLogLastError());
    ple.Restore();
    return NOERROR;
}

HRESULT
CNodeFactory::FirstCreateNodeCall(
    IXMLNodeSource *pSource,
    PVOID pNodeParent,
    USHORT NodeCount,
    const SXS_NODE_INFO *prgNodeInfo
    )
{
    FN_PROLOG_HR
    ULONG i = 0;
    bool fGotGoodManifestVersion = false;
    bool fGotAnyManifestVersion = false;

    // It's our first IXMLNodeFactory::CreateNode() call.  This had better
    // be an <ASSEMBLY MANIFESTVERSION="1.0" ...> deal.

    for (i=0; i<NodeCount; i++)
    {
        if (prgNodeInfo[i].Type == XML_ELEMENT)
        {
            INTERNAL_ERROR_CHECK(i == 0);

            switch (m_ParseType)
            {
            default:
                INTERNAL_ERROR_CHECK(false);
                break;

                //
                // ISSUE: jonwis 3/9/2002 - My goodness, this is gross.  Use FusionEqualStrings
                //          instead.  Doing memcmps between strings is totally bogus.
                //
                // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Memcmping here is bogus
            case XML_FILE_TYPE_MANIFEST:
            case XML_FILE_TYPE_COMPONENT_CONFIGURATION:
                if ((prgNodeInfo[i].cchText != (NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY) - 1)) ||
                    (prgNodeInfo[i].NamespaceStringBuf.Cch() != (NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE) - 1)) ||
                    (memcmp(prgNodeInfo[i].pszText, SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY, prgNodeInfo[i].cchText * sizeof(WCHAR)) != 0) ||
                    (memcmp(prgNodeInfo[i].NamespaceStringBuf, SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE, prgNodeInfo[i].NamespaceStringBuf.Cch() * sizeof(WCHAR)) != 0))
                {
                    IFCOMFAILED_EXIT(this->LogParseError(MSG_SXS_MANIFEST_INCORRECT_ROOT_ELEMENT));
                }
                break;
                
                // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Memcmping here is bogus
            case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
                if ((prgNodeInfo[i].cchText != SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION_CCH) ||
                    (prgNodeInfo[i].NamespaceStringBuf.Cch() != 0) ||
                    (memcmp(prgNodeInfo[i].pszText, SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION,
                        SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION_CCH * sizeof(WCHAR)) != 0))
                {
                    IFCOMFAILED_EXIT(this->LogParseError(MSG_SXS_MANIFEST_INCORRECT_ROOT_ELEMENT));
                }
                break;
            }
        }
        else if (prgNodeInfo[i].Type == XML_ATTRIBUTE)
        {
            // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Memcmping here is bogus
            if ((prgNodeInfo[i].cchText == (NUMBER_OF(SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION) - 1)) &&
                (prgNodeInfo[i].NamespaceStringBuf.Cch() == 0) &&
                (memcmp(prgNodeInfo[i].pszText, SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION, prgNodeInfo[i].cchText * sizeof(WCHAR)) == 0))
            {
                fGotAnyManifestVersion = true;

                ULONG j = i + 1;

                //
                // ISSUE: jonwis 3/9/2002 - Any reason these can't be a single if statement?
                // - Oh, an NO MEMCMPING STRINGS
                //
                // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Memcmping here is bogus
                // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Unrolled if (a&&b) is strange, but not wrong
                if (j < NodeCount)
                {
                    if (prgNodeInfo[j].Type == XML_PCDATA)
                    {
                        if (prgNodeInfo[j].cchText == 3)
                        {
                            if (memcmp(prgNodeInfo[j].pszText, L"1.0", prgNodeInfo[j].cchText * sizeof(WCHAR)) == 0)
                            {
                                fGotGoodManifestVersion = true;
                            }
                        }
                    }
                }
            }
        }
    }

    if ((m_ParseType == XML_FILE_TYPE_MANIFEST) ||
        (m_ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION))
    {
        if (fGotAnyManifestVersion)
        {
            if (!fGotGoodManifestVersion)
                IFCOMFAILED_EXIT(this->LogParseError(MSG_SXS_MANIFEST_VERSION_ERROR));
        }
        else
            IFCOMFAILED_EXIT(this->LogParseError(MSG_SXS_MANIFEST_VERSION_MISSING));
    }

    m_Assembly->m_ManifestVersionMajor = 1;
    m_Assembly->m_ManifestVersionMinor = 0;

    FN_EPILOG
}

HRESULT
CNodeFactory::CreateNode(
    IXMLNodeSource *pSource,
    PVOID pNodeParent,
    USHORT NodeCount,
    XML_NODE_INFO **apNodeInfo
    )
{
    HRESULT hr = S_OK;
    FN_TRACE_HR(hr);

    ULONG i;
    //
    // ISSUE: jonwis 3/9/2002 - Consider making both of these smart-pointers to simplify cleanup
    //
    // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Smart pointers would make cleanup cake
    PSXS_XML_NODE pXmlNode = NULL;
    PSXS_NODE_INFO pSXSNodeInfo = NULL;
    SIZE_T cchTemp;

    m_ParseContext.LineNumber = pSource->GetLineNumber();

    INTERNAL_ERROR_CHECK(NodeCount != 0);

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_NODEFACTORY,
        "SXS.DLL: " __FUNCTION__ "() entered\n"
        "   m_ParseContext.XMLElementDepth = %lu\n",
        m_ParseContext.XMLElementDepth);

    for (i=0; i<NodeCount; i++)
        ::SxspDbgPrintXmlNodeInfo(FUSION_DBG_LEVEL_NODEFACTORY, apNodeInfo[i]);
#endif

    // Short-circuit PIs, XML-decls, whitespace and comments
    if ((apNodeInfo[0]->dwType == XML_PI) ||
        (apNodeInfo[0]->dwType == XML_XMLDECL) ||
        (apNodeInfo[0]->dwType == XML_COMMENT) ||
        (apNodeInfo[0]->dwType == XML_WHITESPACE))
    {
        FN_SUCCESSFUL_EXIT();
    }
    
    IFCOMFAILED_EXIT(m_XMLNamespaceManager.OnCreateNode(pSource, pNodeParent, NodeCount, apNodeInfo));

    IFALLOCFAILED_EXIT(pSXSNodeInfo = new SXS_NODE_INFO[NodeCount]);
    for (i=0; i<NodeCount; i++)
        IFCOMFAILED_EXIT(this->ConvertXMLNodeInfoToSXSNodeInfo(apNodeInfo[i], pSXSNodeInfo[i]));

    if (m_fFirstCreateNodeCall)
    {
        if ((apNodeInfo[0]->dwType == XML_COMMENT) ||
             (apNodeInfo[0]->dwType == XML_XMLDECL) ||
             (apNodeInfo[0]->dwType == XML_WHITESPACE))
        {
            hr = S_OK;
            goto Cont;
        }

        m_fFirstCreateNodeCall = FALSE;
        IFCOMFAILED_EXIT(this->FirstCreateNodeCall(pSource, pNodeParent, NodeCount, pSXSNodeInfo));
    }

Cont:
    if (m_cUnknownChildDepth == 0)
    {
        for (i=0; i<NUMBER_OF(s_rgWorkers); i++)
        {
            bool fTemp = false;

            if ((s_rgWorkers[i].m_xpsOld == eNotParsing) ||
                (m_xpsParseState == s_rgWorkers[i].m_xpsOld))
                fTemp = true;

            const bool fParseStateMatches = fTemp;

            fTemp = false;

            if (fParseStateMatches)
            {
                if (s_rgWorkers[i].m_dwType == apNodeInfo[0]->dwType)
                    fTemp = true;
            }

            const bool fTypeMatches = fTemp;

            fTemp = false;

            if (fTypeMatches)
            {
                if (s_rgWorkers[i].m_cchName == 0)
                    fTemp = true;
                else
                {
                    if (s_rgWorkers[i].m_cchNamespace == pSXSNodeInfo[0].NamespaceStringBuf.Cch())
                    {
                        if (s_rgWorkers[i].m_cchName == pSXSNodeInfo[0].cchText)
                        {
                            if (::FusionpCompareStrings(
                                    s_rgWorkers[i].m_pszNamespace,
                                    s_rgWorkers[i].m_cchNamespace,
                                    pSXSNodeInfo[0].NamespaceStringBuf,
                                    pSXSNodeInfo[0].NamespaceStringBuf.Cch(),
                                    false) == 0)
                            {
                                if (::FusionpCompareStrings(
                                        s_rgWorkers[i].m_pszName,
                                        s_rgWorkers[i].m_cchName,
                                        pSXSNodeInfo[0].pszText,
                                        pSXSNodeInfo[0].cchText,
                                        false) == 0)
                                {
                                    fTemp = true;
                                }
                            }
                        }
                    }
                }
            }

            if (fTemp)
            {
                m_xpsParseState = s_rgWorkers[i].m_xpsNew;

                IFW32FALSE_EXIT(
                    this->ValidateElementAttributes(
                        pSXSNodeInfo,
                        NodeCount,
                        s_rgWorkers[i].m_prgLegalAttributes,
                        s_rgWorkers[i].m_cLegalAttributes));

                if (s_rgWorkers[i].m_pfn != NULL)
                    IFW32FALSE_EXIT((this->*s_rgWorkers[i].m_pfn)(NodeCount, pSXSNodeInfo));
                break;
            }
        }

        if (i == NUMBER_OF(s_rgWorkers))
        {
            bool fEquals;

            // If we hit an unrecognized element and its namespace is the one we own, error!
            IFW32FALSE_EXIT(
                pSXSNodeInfo[0].NamespaceStringBuf.Win32Equals(
                    SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE,
                    SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE_CCH,
                    fEquals,
                    false));

            if (fEquals)
            {
                this->LogParseError(
                    MSG_SXS_MANIFEST_ELEMENT_USED_IN_INVALID_CONTEXT,
                    CUnicodeString(apNodeInfo[0]->pwcText, apNodeInfo[0]->ulLen),
                    CUnicodeString(m_ParseContext.ElementName, m_ParseContext.ElementNameCch));

                ORIGINATE_WIN32_FAILURE_AND_EXIT(ElementInInvalidContext, ERROR_SXS_MANIFEST_PARSE_ERROR);
            }

            // For an unknown child element, the built-in XML parsing should start to ignore the subtree at this point.
            if (apNodeInfo[0]->dwType == XML_ELEMENT)
                m_cUnknownChildDepth = 1;
        }
    }
    else
    {
        if ((NodeCount != 0) &&
            (apNodeInfo[0]->dwType == XML_ELEMENT))
        {
            // We're handling an unknown series of elements; increment the depth.
            m_cUnknownChildDepth++;
        }
    }

    // Fire the right callbacks for XML_ELEMENT, XML_PCDATA and XML_CDATA nodes:
    switch (apNodeInfo[0]->dwType)
    {
    case XML_ELEMENT:
#if defined(MSG_SXS_MANIFEST_PARSE_NO_INHERIT_CHILDREN_NOT_ALLOWED)
        if (m_cUnknownChildDepth != 0 && m_xpsParseState == eParsing_doc_assembly_noInherit)
        {
            ORIGINATE_HR_FAILURE_AND_EXIT(CNodeFactory::CreateNode, this->LogParseError(MSG_SXS_MANIFEST_PARSE_NO_INHERIT_CHILDREN_NOT_ALLOWED));
        }
#endif

        if (m_buffElementPath.Cch() != 0)
            IFW32FALSE_EXIT(m_buffElementPath.Win32Append(L"!", 1));

        cchTemp = m_buffElementPath.Cch();

        //
        // ISSUE: jonwis 3/9/2002 - Use mutli-append here, maybe?
        //
        // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - A multi-append here will frobble the heap less
        if (pSXSNodeInfo[0].NamespaceStringBuf.Cch() != 0)
        {
            IFW32FALSE_EXIT(m_buffElementPath.Win32Append(pSXSNodeInfo[0].NamespaceStringBuf));
            IFW32FALSE_EXIT(m_buffElementPath.Win32Append(L"^", 1));
        }

        IFW32FALSE_EXIT(m_buffElementPath.Win32Append(pSXSNodeInfo[0].pszText, pSXSNodeInfo[0].cchText));

        m_ParseContext.ElementPathCch = m_buffElementPath.Cch();
        m_ParseContext.ElementPath = m_buffElementPath;
        m_ParseContext.ElementName = static_cast<PCWSTR>(m_buffElementPath) + cchTemp;
        m_ParseContext.ElementNameCch = m_buffElementPath.Cch() - cchTemp;

        IFW32FALSE_EXIT(::SxspHashString(m_buffElementPath, m_buffElementPath.Cch(), &m_ParseContext.ElementHash, true));

        m_ParseContext.XMLElementDepth++;

        //
        // ISSUE: jonwis 3/9/2002 - Maybe there needs to be a more general way of dispatching
        //          this sort of stuff off to the contributors, rather than having embedded
        //          loops everywhere.  Easier to read, easier to maintain (esp. if we end up
        //          doing some sort of filtering later.        
        //
        // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Lots of places seem to do something similar, consider collapsing
        for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
        {
            IFW32FALSE_EXIT(
                m_ActCtxGenCtx->m_Contributors[i].Fire_ElementParsed(
                        m_ActCtxGenCtx,
                        m_AssemblyContext,
                        &m_ParseContext,
                        NodeCount,
                        pSXSNodeInfo));
        }

        break;

    case XML_PCDATA:
        for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
        {
            IFW32FALSE_EXIT(
                m_ActCtxGenCtx->m_Contributors[i].Fire_PCDATAParsed(
                        m_ActCtxGenCtx,
                        m_AssemblyContext,
                        &m_ParseContext,
                        apNodeInfo[0]->pwcText,
                        apNodeInfo[0]->ulLen));
        }

        break;

    case XML_CDATA:
        for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
        {
            IFW32FALSE_EXIT(
                m_ActCtxGenCtx->m_Contributors[i].Fire_CDATAParsed(
                        m_ActCtxGenCtx,
                        m_AssemblyContext,
                        &m_ParseContext,
                        apNodeInfo[0]->pwcText,
                        apNodeInfo[0]->ulLen));
        }

        break;


    }

    hr = NOERROR;
Exit:
    if (pSXSNodeInfo != NULL)
        FUSION_DELETE_ARRAY(pSXSNodeInfo);

    if (pXmlNode != NULL)
        FUSION_DELETE_SINGLETON(pXmlNode);

    return hr;
}

BOOL
CNodeFactory::SetParseType(
    ULONG ParseType,
    ULONG PathType,
    const CBaseStringBuffer &Path,
    const FILETIME &rftLastWriteTime
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(
        (ParseType == XML_FILE_TYPE_MANIFEST) ||
        (ParseType == XML_FILE_TYPE_APPLICATION_CONFIGURATION) ||
        (ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION));

    PARAMETER_CHECK(PathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);

    IFW32FALSE_EXIT(m_buffCurrentFileName.Win32Assign(Path));

    m_ParseContext.SourceFilePathType = PathType;
    m_ParseContext.SourceFile = m_buffCurrentFileName;
    m_ParseContext.SourceFileCch = m_buffCurrentFileName.Cch();
    m_ParseContext.SourceFileLastWriteTime = rftLastWriteTime;

    m_ParseType = ParseType;

    FN_EPILOG
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    FN_PROLOG_WIN32
    ULONG i;

    ASSERT(cNumRecs != 0);
    ASSERT(prgNodeInfo != NULL);

    if (m_fAssemblyFound)
    {
        CUnicodeString s;
        PCWSTR ManifestPath;
        IFW32FALSE_EXIT(m_Assembly->GetManifestPath(&ManifestPath, NULL));
        s = ManifestPath;
        ORIGINATE_HR_FAILURE_AND_EXIT(CNodeFactory::XMLParser_Element_doc_assembly, this->LogParseError(MSG_SXS_MANIFEST_MULTIPLE_TOP_ASSEMBLY, &s));
    }

    m_fAssemblyFound = true;
    m_fMetadataSatelliteAlreadyFound = false;

    // Now let's tell all the contributors that we're about to begin a parsing session.
    for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
    {
        IFW32FALSE_EXIT(m_ActCtxGenCtx->m_Contributors[i].Fire_ParseBeginning(
                    m_ActCtxGenCtx,
                    m_AssemblyContext,
                    0, // FileFlags
                    m_ParseType,
                    m_ParseContext.SourceFilePathType,
                    m_ParseContext.SourceFile,
                    m_ParseContext.SourceFileCch,
                    m_ParseContext.SourceFileLastWriteTime,
                    m_Assembly->m_ManifestVersionMajor,
                    m_Assembly->m_ManifestVersionMinor,
                    m_Assembly->m_MetadataSatelliteRosterIndex));
    }

    FN_EPILOG
}



BOOL
CNodeFactory::XMLParser_Element_doc_assembly_assemblyIdentity(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Better cleanup in general here with smart pointers
    PASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    const BOOL fGeneratingActCtx = (m_ActCtxGenCtx->m_ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT);
    ULONG i;
    DWORD dwValidateFlags = 0;

    if (m_fIdentityFound)
    {
        this->LogParseError(MSG_SXS_MULTIPLE_IDENTITY, CEventLogString(prgNodeInfo[0].pszText, prgNodeInfo[0].cchText));

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Manifest %ls has multiple identities\n", static_cast<PCWSTR>(m_buffCurrentFileName));
        ORIGINATE_WIN32_FAILURE_AND_EXIT(
            MultipleIdentities,
            ERROR_SXS_MANIFEST_PARSE_ERROR);
    }

    m_fIdentityFound = true;

    IFW32FALSE_EXIT(
        ::SxspCreateAssemblyIdentityFromIdentityElement(
            0,                                  // DWORD Flags,
            &m_ParseContext,
            ASSEMBLY_IDENTITY_TYPE_DEFINITION,  // ULONG Type,
            &AssemblyIdentity,                  // PASSEMBLY_IDENTITY *AssemblyIdentityOut,
            cNumRecs,
            prgNodeInfo));

    // If the identity that was created is a policy statement, then we
    // set the internal parse type to our special 'intuited' parse type
    // for later checks of missing attributes and whatnot.  This does
    // duplicate work in ValidateAssembly that does the same thing, but
    // we need to preemptively set this parse type before we go validating.
    
    // if (m_IntuitedParseType == eActualParseType_Undetermined)
    {
        BOOL fIsPolicy = FALSE;
        IFW32FALSE_EXIT(::SxspDetermineAssemblyType(AssemblyIdentity, fIsPolicy));

        if (fIsPolicy)
            m_IntuitedParseType = eActualParseType_PolicyManifest;
        else
            m_IntuitedParseType = eActualParseType_Undetermined;
    }

    if ((m_IntuitedParseType == eActualParseType_Manifest) ||
        (m_IntuitedParseType == eActualParseType_PolicyManifest) ||
        (m_ParseType == XML_FILE_TYPE_MANIFEST) ||
        (m_ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION))
    {
        dwValidateFlags = eValidateIdentity_VersionRequired;
    }

    IFW32FALSE_EXIT(
        this->ValidateIdentity(
            dwValidateFlags,
            ASSEMBLY_IDENTITY_TYPE_DEFINITION,
            AssemblyIdentity));

    if (fGeneratingActCtx)
    {
        if (m_Assembly->IsRoot())
        {
            // If we're generating the actctx and this is the root assembly, it's possible
            // that we got to it by a filesystem path (e.g. private assembly) rather than 
            // an actual reference, so we need to fix up the assembly's identity information
            // appropriately.
            IFW32FALSE_EXIT(m_Assembly->m_ProbedAssemblyInformation.SetProbedIdentity(AssemblyIdentity));            
        }
        else
        {
            // If we're generating the actctx and this isn't the root assembly, we need to verify
            // that it's the right one.
            BOOL fEqual;
            IFW32FALSE_EXIT(
                ::SxsAreAssemblyIdentitiesEqual(
                    SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF,
                    m_Assembly->GetAssemblyIdentity(),
                    AssemblyIdentity,
                    &fEqual));

            if (!fEqual)
            {
                ORIGINATE_HR_FAILURE_AND_EXIT(
                    CNodeFactory::XMLParser_Element_doc_assembly_assemblyIdentity,
                    this->LogParseError(MSG_SXS_COMPONENT_MANIFEST_PROBED_IDENTITY_MISMATCH));
                // LogParseError sets the last error appropriate to the message logged
            }
        }
    }

    if (m_IntuitedParseType == eActualParseType_PolicyManifest)
    {
        //
        // ISSUE: jonwis 3/11/2002 - Stomps on m_CurrentPolicyStatement if it was non-null.  Consider
        //          using INTERNAL_ERROR_CHECK to make sure it's NULL first.
        //
        // NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Track possible leaks here better
        IFALLOCFAILED_EXIT(m_CurrentPolicyStatement = new CPolicyStatement);
        IFW32FALSE_EXIT(m_CurrentPolicyStatement->Initialize());
    }

    // Tell everyone that we're sure who we are...
    for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
    {
        IFW32FALSE_EXIT(
            m_ActCtxGenCtx->m_Contributors[i].Fire_IdentityDetermined(
                    m_ActCtxGenCtx,
                    m_AssemblyContext,
                    &m_ParseContext,
                    AssemblyIdentity));
    }

    // fix up assembly and assembly context so we know where to copy to
    // also save the manifest
    IFW32FALSE_EXIT(m_Assembly->m_ProbedAssemblyInformation.SetAssemblyIdentity(AssemblyIdentity));
    if (m_AssemblyContext->AssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(m_AssemblyContext->AssemblyIdentity));

    m_AssemblyContext->AssemblyIdentity = AssemblyIdentity;
    AssemblyIdentity = NULL;

    fSuccess = TRUE;

Exit:
    if (AssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(AssemblyIdentity);

    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_noInherit(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(
        (m_ParseType == XML_FILE_TYPE_MANIFEST) ||
        (m_ParseType == XML_FILE_TYPE_APPLICATION_CONFIGURATION) ||
        (m_ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION));

    switch (m_ParseType)
    {
    case XML_FILE_TYPE_MANIFEST:
        if (cNumRecs != 1)
        {
            ORIGINATE_HR_FAILURE_AND_EXIT(
                CNodeFactory::XMLParser_Element_doc_assembly_noInherit,
                this->LogParseError(MSG_SXS_MANIFEST_PARSE_NO_INHERIT_ATTRIBUTES_NOT_ALLOWED));
        }
        
        if (m_ActCtxGenCtx->m_NoInherit)
        {
            ORIGINATE_HR_FAILURE_AND_EXIT(
                CNodeFactory::XMLParser_Element_doc_assembly_noInherit,
                this->LogParseError(MSG_SXS_MANIFEST_PARSE_MULTIPLE_NO_INHERIT));
        }

        if (m_fIdentityFound)
        {
            ORIGINATE_HR_FAILURE_AND_EXIT(
                CNodeFactory::XMLParser_Element_doc_assembly_noInherit,
                this->LogParseError(
                    MSG_SXS_MANIFEST_ELEMENT_MUST_OCCUR_BEFORE,
                    CEventLogString(L"noInherit"),
                    CEventLogString(L"assemblyIdentity")));
        }

        m_ActCtxGenCtx->m_NoInherit = true;
        break;

    case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
        ORIGINATE_HR_FAILURE_AND_EXIT(
            CNodeFactory::XMLParser_Element_doc_assembly_noInherit, 
            this->LogParseError(MSG_SXS_POLICY_PARSE_NO_INHERIT_NOT_ALLOWED));
        break;

    default:
        INTERNAL_ERROR_CHECK(FALSE);
        break;
    }

    FN_EPILOG
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_noInheritable(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(
        (m_ParseType == XML_FILE_TYPE_MANIFEST) ||
        (m_ParseType == XML_FILE_TYPE_APPLICATION_CONFIGURATION) ||
        (m_ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION));

    switch (m_ParseType)
    {
    case XML_FILE_TYPE_MANIFEST:
        if (cNumRecs != 1)
        {
            this->LogParseError(MSG_SXS_MANIFEST_PARSE_NO_INHERIT_ATTRIBUTES_NOT_ALLOWED);
            goto Exit;
        }

        if (m_fNoInheritableFound)
        {
            this->LogParseError(MSG_SXS_MANIFEST_PARSE_MULTIPLE_NOINHERITABLE);
            goto Exit;
        }
        if (m_fIdentityFound)
        {
            this->LogParseError(
                MSG_SXS_MANIFEST_ELEMENT_MUST_OCCUR_BEFORE,
                CEventLogString(L"noInheritable"),
                CEventLogString(L"assemblyIdentity"));
            goto Exit;
        }


        m_fNoInheritableFound = true;

        break;

    case XML_FILE_TYPE_APPLICATION_CONFIGURATION:
    case XML_FILE_TYPE_COMPONENT_CONFIGURATION:
        this->LogParseError(MSG_SXS_POLICY_PARSE_NO_INHERIT_NOT_ALLOWED);
        goto Exit;

    default:
        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_dependency(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    FN_PROLOG_WIN32
    bool fFound;
    SIZE_T cb;

    m_fIsDependencyOptional = false;
    m_fDependencyChildHit = false;
    m_fIsMetadataSatellite = false;

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_optional,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(m_fIsDependencyOptional),
            &m_fIsDependencyOptional,
            cb,
            &::SxspValidateBoolAttribute,
            0));

    if (!fFound)
        m_fIsDependencyOptional = false;

    FN_EPILOG
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_dependency_dependentAssembly(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    FN_PROLOG_WIN32
    bool fFound;
    SIZE_T cb;

    if (m_fDependencyChildHit == false)
    {
        m_fDependencyChildHit = true;
    }
    else
    {
        ORIGINATE_HR_FAILURE_AND_EXIT(
            CNodeFactory::XMLParser_Element_doc_assembly_dependency_dependentAssembly, 
            this->LogParseError(MSG_SXS_MANIFEST_MULTIPLE_DEPENDENTASSEMBLY_IN_DEPENDENCY));
    }

    m_fAssemblyIdentityChildOfDependenctAssemblyHit = false;

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_metadataSatellite,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(m_fIsMetadataSatellite),
            &m_fIsMetadataSatellite,
            cb,
            &::SxspValidateBoolAttribute,
            0));

    if (!fFound)
        m_fIsMetadataSatellite = false;

    FN_EPILOG
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_dependency_dependentAssembly_bindingRedirect(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    bool fFound;
    bool fValid;
    SIZE_T cb;
    CSmallStringBuffer buffOldVersion;
    CSmallStringBuffer buffNewVersion;

    INTERNAL_ERROR_CHECK(m_CurrentPolicyStatement != NULL);

    if (m_IntuitedParseType != eActualParseType_PolicyManifest)
    {
        this->LogParseError(MSG_SXS_BINDING_REDIRECTS_ONLY_IN_COMPONENT_CONFIGURATION);
        goto Exit;
    }

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
            &s_AttributeName_oldVersion,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(buffOldVersion),
            &buffOldVersion,
            cb,
            NULL,
            0));
    INTERNAL_ERROR_CHECK(fFound);

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
            &s_AttributeName_newVersion,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(buffNewVersion),
            &buffNewVersion,
            cb,
            NULL,
            0));
    INTERNAL_ERROR_CHECK(fFound);

    IFW32FALSE_EXIT(m_CurrentPolicyStatement->AddRedirect(buffOldVersion, buffNewVersion, fValid));

    if (!fValid)
    {
        this->LogParseError(MSG_SXS_BINDING_REDIRECT_MISSING_REQUIRED_ATTRIBUTES);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_assembly_dependency_dependentAssembly_assemblyIdentity(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    FN_PROLOG_WIN32
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, ::SxsDestroyAssemblyIdentity> pAssemblyIdentity;
    ULONG ParseType;

    ASSERT(cNumRecs != 0);
    ASSERT(prgNodeInfo != NULL);

    // We're either parsing a manifest or a policy file; what else??
    INTERNAL_ERROR_CHECK(
            (m_ParseType == XML_FILE_TYPE_MANIFEST) ||
            (m_ParseType == XML_FILE_TYPE_APPLICATION_CONFIGURATION) ||
            (m_ParseType == XML_FILE_TYPE_COMPONENT_CONFIGURATION));
    
    if (m_fAssemblyIdentityChildOfDependenctAssemblyHit == false)
        m_fAssemblyIdentityChildOfDependenctAssemblyHit = true;
    else
    {
        this->LogParseError(MSG_SXS_MANIFEST_MULTIPLE_ASSEMBLYIDENTITY_IN_DEPENDENCYASSEMBLY);
        goto Exit;
    }

    switch (m_IntuitedParseType)
    {
    case eActualParseType_Undetermined:
        ParseType = m_ParseType;
        break;
    case eActualParseType_PolicyManifest:
        ParseType = XML_FILE_TYPE_COMPONENT_CONFIGURATION;
        break;
    case eActualParseType_Manifest:
        ParseType = XML_FILE_TYPE_MANIFEST;
        break;
    default:
        INTERNAL_ERROR_CHECK(FALSE);
        ParseType = m_ParseType;
        break;
    }
    switch (ParseType)
    {
    case XML_FILE_TYPE_MANIFEST:
        IFW32FALSE_EXIT(
            ::SxspCreateAssemblyIdentityFromIdentityElement(
                0,
                &m_ParseContext,
                ASSEMBLY_IDENTITY_TYPE_REFERENCE,
                &pAssemblyIdentity,
                cNumRecs,
                prgNodeInfo));

        IFW32FALSE_EXIT(
            this->ValidateIdentity(
                eValidateIdentity_PoliciesNotAllowed| eValidateIdentity_VersionRequired,
                ASSEMBLY_IDENTITY_TYPE_REFERENCE,
                pAssemblyIdentity));

        //
        // If we're not installing, process the identity...
        //
        // Note that in a strange twist on refcounting, SxspEnqueueAssemblyReference does not
        // hold the reference, it clones it.  That's why we don't .Detach from the pAssemblyIdentity
        // smart pointer here.
        //
        if (m_ActCtxGenCtx->m_ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            IFW32FALSE_EXIT(::SxspEnqueueAssemblyReference(m_ActCtxGenCtx, m_Assembly, pAssemblyIdentity, m_fIsDependencyOptional, m_fIsMetadataSatellite));

        break;

    case XML_FILE_TYPE_COMPONENT_CONFIGURATION:
        {
        BOOL fValidDependencyAssemblyIdentity = FALSE;
        PCWSTR pszName1 = NULL, pszName2 = NULL;
        SIZE_T cchName1 = 0, cchName2 = 0;

        if (m_CurrentPolicyDependentAssemblyIdentity != NULL)
        {
            this->LogParseError(MSG_SXS_COMPONENT_CONFIGURATION_MANIFESTS_MAY_ONLY_HAVE_ONE_DEPENDENCY);
            goto Exit;
        }

        IFW32FALSE_EXIT(
            ::SxspCreateAssemblyIdentityFromIdentityElement(
                0,
                &m_ParseContext,
                ASSEMBLY_IDENTITY_TYPE_REFERENCE,
                &pAssemblyIdentity,
                cNumRecs,
                prgNodeInfo));
        // check the name in dependency-assemblyidentity match with the name in assembly-assemblyidentity        
        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                m_Assembly->GetAssemblyIdentity(),
                &s_IdentityAttribute_name,
                &pszName1,          // something in a format of "Policy.1212.1221.assemblyname"
                &cchName1));

        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                pAssemblyIdentity,
                &s_IdentityAttribute_name,
                &pszName2,          // would be something as "assemblyname"
                &cchName2));

        if ((cchName1 > cchName2) && (cchName2 !=0))
        {
            if ( (*(pszName1 + (cchName1 - cchName2 -1)) == L'.') && (::FusionpCompareStrings(
                            pszName1 + (cchName1 - cchName2), cchName2,
                            pszName2, cchName2, FALSE // must be case-sensitive for values
                            ) == 0 ))  
            {                
                fValidDependencyAssemblyIdentity = TRUE;
            }
        }
    
        if (fValidDependencyAssemblyIdentity) 
        {
            IFW32FALSE_EXIT(
                this->ValidateIdentity(
                    eValidateIdentity_PoliciesNotAllowed | eValidateIdentity_VersionNotAllowed,
                    ASSEMBLY_IDENTITY_TYPE_REFERENCE,
                    pAssemblyIdentity));

            // We'll keep track of this so that we can recognize multiple dependentAssembly elements on installation
            // of policies.
            INTERNAL_ERROR_CHECK(m_CurrentPolicyDependentAssemblyIdentity == NULL);
            m_CurrentPolicyDependentAssemblyIdentity = pAssemblyIdentity.Detach();
        }
        else // print a message and ignore this entry
        {           
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_POLICY | FUSION_DBG_LEVEL_INFO,
                "SXS.DLL: unexpected assemblyidentity within dependency tag in component policy \"%ls\"\n",                
                m_buffCurrentFileName
                );
        }
        } // end of this case   

        break;

    default:
        // Internal error!
        INTERNAL_ERROR_CHECK(FALSE);
    }

    FN_EPILOG
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i;

    ASSERT(cNumRecs != 0);
    ASSERT(prgNodeInfo != NULL);

    if (m_fAssemblyFound)
    {
        CUnicodeString s;
        PCWSTR ManifestPath;
        IFW32FALSE_EXIT(m_Assembly->GetManifestPath(&ManifestPath, NULL));
        s = ManifestPath;
        this->LogParseError(MSG_SXS_MANIFEST_MULTIPLE_TOP_ASSEMBLY, &s);
        goto Exit;
    }

    m_fAssemblyFound = true;

    m_fMetadataSatelliteAlreadyFound = false;

    // Now let's tell all the contributors that we're about to begin a parsing session.
    for (i=0; i<m_ActCtxGenCtx->m_ContributorCount; i++)
    {
        IFW32FALSE_EXIT(
            m_ActCtxGenCtx->m_Contributors[i].Fire_ParseBeginning(
                m_ActCtxGenCtx,
                m_AssemblyContext,
                0, // FileFlags
                m_ParseType,
                m_ParseContext.SourceFilePathType,
                m_ParseContext.SourceFile,
                m_ParseContext.SourceFileCch,
                m_ParseContext.SourceFileLastWriteTime,
                m_Assembly->m_ManifestVersionMajor,
                m_Assembly->m_ManifestVersionMinor,
                m_Assembly->m_MetadataSatelliteRosterIndex));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    fSuccess = TRUE;
    // Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    fSuccess = TRUE;
    // Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding_assemblyIdentity(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    FN_PROLOG_WIN32;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, ::SxsDestroyAssemblyIdentity> pAssemblyIdentity;

    IFW32FALSE_EXIT(
        ::SxspCreateAssemblyIdentityFromIdentityElement(
            0,
            &m_ParseContext,
            ASSEMBLY_IDENTITY_TYPE_REFERENCE,
            &pAssemblyIdentity,
            cNumRecs,
            prgNodeInfo));

    IFW32FALSE_EXIT(
        this->ValidateIdentity(
            eValidateIdentity_PoliciesNotAllowed | eValidateIdentity_VersionRequired,
            ASSEMBLY_IDENTITY_TYPE_REFERENCE,
            pAssemblyIdentity));

    FN_EPILOG;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    fSuccess = TRUE;
    // Exit:
    return fSuccess;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly_assemblyIdentity(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    FN_PROLOG_WIN32;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, ::SxsDestroyAssemblyIdentity> pAssemblyIdentity;
    CSmartPtr<CPolicyStatement> pPolicyStatement;
    CPolicyStatement *pFoundPolicyStatement = NULL;

    IFW32FALSE_EXIT(
        ::SxspCreateAssemblyIdentityFromIdentityElement(
            0,
            &m_ParseContext,
            ASSEMBLY_IDENTITY_TYPE_REFERENCE,
            &pAssemblyIdentity,
            cNumRecs,
            prgNodeInfo));

    IFW32FALSE_EXIT(
        this->ValidateIdentity(
            eValidateIdentity_PoliciesNotAllowed | eValidateIdentity_VersionNotAllowed,
            ASSEMBLY_IDENTITY_TYPE_REFERENCE,
            pAssemblyIdentity));

    IFW32FALSE_EXIT(
        ::SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
            SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION,
            pAssemblyIdentity,
            m_buffCurrentApplicationPolicyIdentityKey,
            NULL));

    IFW32FALSE_EXIT(m_ActCtxGenCtx->m_ApplicationPolicyTable.Find(m_buffCurrentApplicationPolicyIdentityKey, pFoundPolicyStatement));
    if (pFoundPolicyStatement != NULL)
    {
        this->LogParseError(MSG_SXS_APPLICATION_CONFIGURATION_MANIFEST_MAY_ONLY_HAVE_ONE_DEPENDENTASSEMBLY_PER_IDENTITY);
        goto Exit;
    }


    IFALLOCFAILED_EXIT(pPolicyStatement.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT(pPolicyStatement->Initialize());
    IFW32FALSE_EXIT(m_ActCtxGenCtx->m_ApplicationPolicyTable.Insert(m_buffCurrentApplicationPolicyIdentityKey, pPolicyStatement));

    // preset it to be global value about m_fApplyPublisherPolicy, 
    // and be reset in dependentAssembly_publisherPolicy function if present
    if ((this->m_ActCtxGenCtx->m_fAppApplyPublisherPolicy == SXS_PUBLISHER_POLICY_APPLY_YES) || (this->m_ActCtxGenCtx->m_fAppApplyPublisherPolicy == SXS_PUBLISHER_POLICY_APPLY_DEFAULT))
        pPolicyStatement->m_fApplyPublisherPolicy = true;
    else
        pPolicyStatement->m_fApplyPublisherPolicy = false;

    m_CurrentPolicyStatement = pPolicyStatement.Detach();

    if (m_CurrentPolicyDependentAssemblyIdentity != NULL)
    {
        ::SxsDestroyAssemblyIdentity(m_CurrentPolicyDependentAssemblyIdentity);
        m_CurrentPolicyDependentAssemblyIdentity = NULL;
    }

    m_CurrentPolicyDependentAssemblyIdentity = pAssemblyIdentity.Detach();

    FN_EPILOG;
}



BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly_publisherPolicy(
    USHORT cNumRecs, 
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    FN_PROLOG_WIN32;
    
    if (m_CurrentPolicyStatement == NULL)
    {
        this->LogParseError(MSG_SXS_APPLICATION_CONFIGURATION_MANIFEST_DEPENDENTASSEMBLY_MISSING_IDENTITY);
        goto Exit;
    }

    if (this->m_ActCtxGenCtx->m_fAppApplyPublisherPolicy == SXS_PUBLISHER_POLICY_APPLY_NO)
        m_CurrentPolicyStatement->m_fApplyPublisherPolicy = false;
    else
    {
        bool fFound, fApplyPolicy;
        SIZE_T cb;

        IFW32FALSE_EXIT(
            ::SxspGetAttributeValue(
                0,
                &s_AttributeName_apply,
                prgNodeInfo,
                cNumRecs,
                &m_ParseContext,
                fFound,
                sizeof(fApplyPolicy),
                &fApplyPolicy,
                cb,
                SxspValidateBoolAttribute,
                0));

        INTERNAL_ERROR_CHECK(fFound); // if not found, syntax error in the manifest               
        
        if (fApplyPolicy == false)
        {
            //
            // if this tag appears, appcompat flags must be set, otherwise it is an error
            //
            if (!(this->m_ActCtxGenCtx->m_Flags & SXS_GENERATE_ACTCTX_APP_RUNNING_IN_SAFEMODE))
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: %s() app-level PublisherPolicy try to be set but there is no appcompat flags been set.\n", __FUNCTION__);
                ::SetLastError(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }
        }
        m_CurrentPolicyStatement->m_fApplyPublisherPolicy = fApplyPolicy;
    }

    FN_EPILOG;
}


BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding_publisherPolicy(
    USHORT cNumRecs, 
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    FN_PROLOG_WIN32;

    bool fFound, fApplyPolicy;
    SIZE_T cb;

    if (this->m_ActCtxGenCtx->m_fAppApplyPublisherPolicy != SXS_PUBLISHER_POLICY_APPLY_DEFAULT)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s() called but app-level PublisherPolicy has already been set.\n", __FUNCTION__);
        ::SetLastError(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            0,
            &s_AttributeName_apply,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(fApplyPolicy),
            &fApplyPolicy,
            cb,
            SxspValidateBoolAttribute,
            0));

    INTERNAL_ERROR_CHECK(fFound);
    
    if (!fApplyPolicy)
    {
        //
        // if this tag set to be "no", appcompat flags must be set, otherwise it is an error
        //
        if (!(this->m_ActCtxGenCtx->m_Flags & SXS_GENERATE_ACTCTX_APP_RUNNING_IN_SAFEMODE))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s() app-level PublisherPolicy try to be set but there is no appcompat flags been set.\n", __FUNCTION__);
            ::SetLastError(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }

        this->m_ActCtxGenCtx->m_fAppApplyPublisherPolicy = SXS_PUBLISHER_POLICY_APPLY_NO;
    }
    else
        this->m_ActCtxGenCtx->m_fAppApplyPublisherPolicy = SXS_PUBLISHER_POLICY_APPLY_YES;    

    FN_EPILOG;
}

BOOL
CNodeFactory::XMLParser_Element_doc_configuration_windows_assemblyBinding_dependentAssembly_bindingRedirect(
    USHORT cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CSmallStringBuffer buffOldVersion;
    CSmallStringBuffer buffNewVersion;
    bool fFound;
    bool fValid;
    SIZE_T cb;

    if (m_CurrentPolicyStatement == NULL)
    {
        this->LogParseError(MSG_SXS_APPLICATION_CONFIGURATION_MANIFEST_DEPENDENTASSEMBLY_MISSING_IDENTITY);
        goto Exit;
    }

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
            &s_AttributeName_oldVersion,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(buffOldVersion),
            &buffOldVersion,
            cb,
            NULL,
            0));
    INTERNAL_ERROR_CHECK(fFound);

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE,
            &s_AttributeName_newVersion,
            prgNodeInfo,
            cNumRecs,
            &m_ParseContext,
            fFound,
            sizeof(buffNewVersion),
            &buffNewVersion,
            cb,
            NULL,
            0));
    INTERNAL_ERROR_CHECK(fFound);

    // If either are not found, log an error
    if (!fFound)
    {
        this->LogParseError(MSG_SXS_BINDING_REDIRECT_MISSING_REQUIRED_ATTRIBUTES);
        goto Exit;
    }

    IFW32FALSE_EXIT(m_CurrentPolicyStatement->AddRedirect(buffOldVersion, buffNewVersion, fValid));
    if (! fValid)
    {       
        // log an error
        ::FusionpLogError(
            MSG_SXS_POLICY_VERSION_OVERLAP,
            CEventLogString(m_AssemblyContext->PolicyPath),
            CEventLogString(buffOldVersion),
            CEventLogString(buffNewVersion));

        ORIGINATE_WIN32_FAILURE_AND_EXIT(PolicyVersionOverlap, ERROR_SXS_MANIFEST_PARSE_ERROR);
    }


    fSuccess = TRUE;
Exit:
    return fSuccess;
}


//
// ISSUE: jonwis 3/11/2002 - Smells like dead code.  CPartialAssemblyVersion isn't constrcted anywhere,
//          and this function isn't called by anyone.
//
// NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Dead code, probably
BOOL
CNodeFactory::XMLParser_Parse_PartialAssemblyVersion(
    PVOID pvDatum,
    BOOL fAlreadyFound,
    CBaseStringBuffer &rbuff
    )
{
    return reinterpret_cast<CPartialAssemblyVersion *>(pvDatum)->Parse(rbuff, rbuff.Cch());
}


//
// ISSUE: jonwis 3/11/2002 - Same here... never called anywhere, dead code.
//
// NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Dead code, probably
BOOL
CNodeFactory::XMLParser_Parse_String(
    LPVOID pvDatum,
    BOOL fAlreadyFound,
    CBaseStringBuffer &rbuff)
{
    return ((CBaseStringBuffer *) pvDatum)->Win32Assign(rbuff);
}

//
// ISSUE: jonwis 3/11/2002 - More dead code.  Will the madness ever end??
//
// NTRAID#NTBUG9 - 572507 - jonwis - 2002/04/25 - Dead code probably
BOOL
CNodeFactory::ParseElementAttributes(
    USHORT cNumRecs,
    XML_NODE_INFO **prgpNodeInfo,
    SIZE_T cEntries,
    const AttributeMapEntry *prgEntries
    )
{
    FN_PROLOG_WIN32

    ULONG i, j;

    for (i=1; i<cNumRecs; i++)
    {
        // Skip things we don't understand.
        if (prgpNodeInfo[i]->dwType != XML_ATTRIBUTE)
            continue;

        for (j=0; j<cEntries; j++)
        {
            if (::FusionpEqualStrings(
                    prgEntries[j].m_pszAttributeName,
                    prgEntries[j].m_cchAttributeName,
                    prgpNodeInfo[i]->pwcText,
                    prgpNodeInfo[i]->ulLen,
                    false))
            {
                // Because attribute values may be multipart due to entity references,
                // we accumulate the attibute value into buffTemp to start, and then do
                // the parsing/whatever afterwards.
                CStringBuffer buffTemp;
                BOOL *pfIndicator = (BOOL *) (((ULONG_PTR) this) + prgEntries[j].m_offsetIndicator);

                while ((++i < cNumRecs) &&
                       (prgpNodeInfo[i]->dwType == XML_PCDATA))
                {
                    IFW32FALSE_EXIT(buffTemp.Win32Append(prgpNodeInfo[i]->pwcText, prgpNodeInfo[i]->ulLen));
                }

                // The outer for(;;) loop is going to increment i, so we need to back it up one
                // place...
                i--;

                // Call the appropriate value type handler function...
                if (prgEntries[j].m_pfn != NULL)
                {
                    IFW32FALSE_EXIT((this->*(prgEntries[j].m_pfn))(((LPBYTE) this) + prgEntries[j].m_offsetData, *pfIndicator, buffTemp));
                }

                *pfIndicator = TRUE;

                break;
            }
        }
    }

    FN_EPILOG
}

HRESULT
CNodeFactory::LogParseError(
    DWORD dwLastParseError,
    const UNICODE_STRING *p1,
    const UNICODE_STRING *p2,
    const UNICODE_STRING *p3,
    const UNICODE_STRING *p4,
    const UNICODE_STRING *p5,
    const UNICODE_STRING *p6,
    const UNICODE_STRING *p7,
    const UNICODE_STRING *p8,
    const UNICODE_STRING *p9,
    const UNICODE_STRING *p10,
    const UNICODE_STRING *p11,
    const UNICODE_STRING *p12,
    const UNICODE_STRING *p13,
    const UNICODE_STRING *p14,
    const UNICODE_STRING *p15,
    const UNICODE_STRING *p16,
    const UNICODE_STRING *p17,
    const UNICODE_STRING *p18,
    const UNICODE_STRING *p19,
    const UNICODE_STRING *p20
    )
{
    return
        ::FusionpLogParseError(
            m_ParseContext.SourceFile,
            m_ParseContext.SourceFileCch,
            m_ParseContext.LineNumber,
            dwLastParseError,
            p1, p2, p3, p4, p5,
            p6, p7, p8, p9, p10,
            p11, p12, p13, p14, p15,
            p16, p17, p18, p19, p20);
}

VOID
CNodeFactory::ParseErrorCallback_MissingRequiredAttribute(
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    )
{
    // CNodeFactory *pThis = (CNodeFactory *) ErrorContext;

    ::FusionpLogRequiredAttributeMissingParseError(
        ParseContext->SourceFile,
        ParseContext->SourceFileCch,
        ParseContext->LineNumber,
        ParseContext->ElementName,
        ParseContext->ElementNameCch,
        AttributeName->Name,
        AttributeName->NameCch);
}

VOID
CNodeFactory::ParseErrorCallback_InvalidAttributeValue(
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    )
{
    // CNodeFactory *pThis = (CNodeFactory *) ErrorContext;

    ::FusionpLogInvalidAttributeValueParseError(
        ParseContext->SourceFile,
        ParseContext->SourceFileCch,
        ParseContext->LineNumber,
        ParseContext->ElementName,
        ParseContext->ElementNameCch,
        AttributeName->Name,
        AttributeName->NameCch);
}

VOID
CNodeFactory::ParseErrorCallback_AttributeNotAllowed(
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    )
{
    // CNodeFactory *pThis = (CNodeFactory *) ErrorContext;

    ::FusionpLogAttributeNotAllowedParseError(
        ParseContext->SourceFile,
        ParseContext->SourceFileCch,
        ParseContext->LineNumber,
        ParseContext->ElementName,
        ParseContext->ElementNameCch,
        AttributeName->Name,
        AttributeName->NameCch);
}

VOID
SxspDbgPrintXmlNodeInfo(
    ULONG Level,
    XML_NODE_INFO *pNode
    )
{
    CUnicodeString s(pNode->pwcText, pNode->ulLen);

#if DBG_SXS
    ::FusionpDbgPrintEx(Level, "SXS.DLL: XML_NODE_INFO at %p\n", pNode);
    ::FusionpDbgPrintEx(Level, "    dwSize = %d\n", pNode->dwSize);
    ::FusionpDbgPrintEx(Level, "    dwType = %d (%s)\n", pNode->dwType, SxspFormatXmlNodeType(pNode->dwType));
    ::FusionpDbgPrintEx(Level, "    dwSubType = %d\n", pNode->dwSubType);
    ::FusionpDbgPrintEx(Level, "    fTerminal = %d\n", pNode->fTerminal);

    ::FusionpDbgPrintEx(Level, "    pwcText = %p (\"%wZ\")\n", pNode->pwcText, &s);
    ::FusionpDbgPrintEx(Level, "    ulLen = %d\n", pNode->ulLen);
    ::FusionpDbgPrintEx(Level, "    ulNsPrefixLen = %d\n", pNode->ulNsPrefixLen);
    ::FusionpDbgPrintEx(Level, "    pNode = %p\n", pNode->pNode);
    ::FusionpDbgPrintEx(Level, "    pReserved = %p\n", pNode->pReserved);
#else
    ::FusionpDbgPrintEx(Level, "SXS.DLL: XML_NODE_INFO at %p: \"%wZ\"\n", pNode, &s);
#endif
}


PCSTR
SxspFormatXmlNodeType(
    DWORD dwType
    )
{
    PCSTR Result = "Unknown";

#define HANDLE_NODE_TYPE(x) case static_cast<DWORD>(x): Result = #x; break;

    switch (dwType)
    {
        HANDLE_NODE_TYPE(XML_ELEMENT)
        HANDLE_NODE_TYPE(XML_ATTRIBUTE)
        HANDLE_NODE_TYPE(XML_PI)
        HANDLE_NODE_TYPE(XML_XMLDECL)
        HANDLE_NODE_TYPE(XML_DOCTYPE)
        HANDLE_NODE_TYPE(XML_DTDATTRIBUTE)
        HANDLE_NODE_TYPE(XML_ENTITYDECL)
        HANDLE_NODE_TYPE(XML_ELEMENTDECL)
        HANDLE_NODE_TYPE(XML_ATTLISTDECL)
        HANDLE_NODE_TYPE(XML_NOTATION)
        HANDLE_NODE_TYPE(XML_GROUP)
        HANDLE_NODE_TYPE(XML_INCLUDESECT)
        HANDLE_NODE_TYPE(XML_PCDATA)
        HANDLE_NODE_TYPE(XML_CDATA)
        HANDLE_NODE_TYPE(XML_IGNORESECT)
        HANDLE_NODE_TYPE(XML_COMMENT)
        HANDLE_NODE_TYPE(XML_ENTITYREF)
        HANDLE_NODE_TYPE(XML_WHITESPACE)
        HANDLE_NODE_TYPE(XML_NAME)
        HANDLE_NODE_TYPE(XML_NMTOKEN)
        HANDLE_NODE_TYPE(XML_STRING)
        HANDLE_NODE_TYPE(XML_PEREF)
        HANDLE_NODE_TYPE(XML_MODEL)
        HANDLE_NODE_TYPE(XML_ATTDEF)
        HANDLE_NODE_TYPE(XML_ATTTYPE)
        HANDLE_NODE_TYPE(XML_ATTPRESENCE)
        HANDLE_NODE_TYPE(XML_DTDSUBSET)
    }

    return Result;
}

BOOL
CNodeFactory::ValidateIdentity(
    DWORD Flags,
    ULONG Type,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    FN_PROLOG_WIN32
    PCWSTR pszTemp = NULL;
    SIZE_T cchTemp = 0;
    bool fSyntaxValid = false;
    bool fError = false;
    BOOL fIsPolicy;

    PARAMETER_CHECK((Flags & ~(
                            eValidateIdentity_VersionRequired |
                            eValidateIdentity_PoliciesNotAllowed |
                            eValidateIdentity_VersionNotAllowed)) == 0);
    PARAMETER_CHECK((Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) || (Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE));
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    //
    // only one of these flags is allowed
    //
    PARAMETER_CHECK(
        (Flags & (eValidateIdentity_VersionRequired | eValidateIdentity_VersionNotAllowed)) !=
                 (eValidateIdentity_VersionRequired | eValidateIdentity_VersionNotAllowed));

    //
    // Get the type of this assembly
    //
    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(AssemblyIdentity, fIsPolicy));

    //
    // If it's policy, then make sure that policies are allowed.  Otherwise, fail out.
    //
    if (fIsPolicy)
    {
        m_AssemblyContext->Flags |= ACTCTXCTB_ASSEMBLY_CONTEXT_IS_SYSTEM_POLICY_INSTALLATION;

        if (Flags & eValidateIdentity_PoliciesNotAllowed)
        {
            CUnicodeString usType(pszTemp, cchTemp);

            fError = true;
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Manifest \"%ls\" (line %d) has invalid type attribute \"%wZ\"; report to owner of \"%ls\"\n",
                m_ParseContext.SourceFile,
                m_ParseContext.LineNumber,
                &usType,
                m_ParseContext.SourceFile);
        }
    }

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_name,
            &pszTemp,
            &cchTemp));

    if (cchTemp == 0)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Manifest \"%ls\" (line %d) is missing name attribute; report to owner of \"%ls\"\n",
            m_ParseContext.SourceFile,
            m_ParseContext.LineNumber,
            m_ParseContext.SourceFile);

        fError = true;
    }

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_processorArchitecture,
            &pszTemp,
            &cchTemp));

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_version,
            &pszTemp,
            &cchTemp));

    if (cchTemp != 0)
    {
        ASSEMBLY_VERSION av;

        IFW32FALSE_EXIT(CFusionParser::ParseVersion(av, pszTemp, cchTemp, fSyntaxValid));

        if (!fSyntaxValid)
        {
            ::FusionpLogInvalidAttributeValueParseError(
                m_ParseContext.SourceFile,
                m_ParseContext.SourceFileCch,
                m_ParseContext.LineNumber,
                m_ParseContext.ElementName,
                m_ParseContext.ElementNameCch,
                s_IdentityAttribute_version);

            ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidVersionNumber, ERROR_SXS_MANIFEST_PARSE_ERROR);
        }
    }

    if ((Flags & (eValidateIdentity_VersionNotAllowed | eValidateIdentity_VersionRequired)) != 0)
    {
        if ((Flags & eValidateIdentity_VersionNotAllowed) != 0 && cchTemp != 0)
        {
            fError = true;
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Manifest \"%ls\" (line %d) has a version attribute where it may not appear; report to owner of \"%ls\"\n",
                m_ParseContext.SourceFile,
                m_ParseContext.LineNumber,
                m_ParseContext.SourceFile);
        }
        else if ((Flags & eValidateIdentity_VersionRequired) != 0 && cchTemp == 0)
        {
            fError = true;
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Manifest \"%ls\" (line %d) is missing version attribute; report to owner of \"%ls\"\n",
                m_ParseContext.SourceFile,
                m_ParseContext.LineNumber,
                m_ParseContext.SourceFile);
        }
    }

    if (fError)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Manifest \"%ls\" is missing required attribute or contains disallowed attribute; report to owner of \"%ls\"\n",
            m_ParseContext.SourceFile,
            m_ParseContext.SourceFile);

        ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidIdentity, ERROR_SXS_MANIFEST_PARSE_ERROR);
    }

    FN_EPILOG
}

BOOL
CNodeFactory::ValidateElementAttributes(
    PCSXS_NODE_INFO prgNodes,
    SIZE_T cNodes,
    PCELEMENT_LEGAL_ATTRIBUTE prgAttributes,
    UCHAR cAttributes
    )
{
    FN_PROLOG_WIN32

    SIZE_T i;
    UCHAR j;
    UCHAR cRequiredAttributes, cRequiredAttributesFound;
    UCHAR rgRequiredAttributeFoundBitMask[8]; // 8 * 32 = 256
    BOOL fParseFailed = FALSE;

    PARAMETER_CHECK((cNodes == 0) || (prgNodes != NULL));
    PARAMETER_CHECK((cAttributes == 0) || (prgAttributes != NULL));

    cRequiredAttributes = 0;
    cRequiredAttributesFound = 0;

    for (i=0; i<cAttributes; i++)
        if (prgAttributes[i].m_dwFlags & ELEMENT_LEGAL_ATTRIBUTE_FLAG_REQUIRED)
            cRequiredAttributes++;

    rgRequiredAttributeFoundBitMask[0] = 0;
    rgRequiredAttributeFoundBitMask[1] = 0;
    rgRequiredAttributeFoundBitMask[2] = 0;
    rgRequiredAttributeFoundBitMask[3] = 0;
    rgRequiredAttributeFoundBitMask[4] = 0;
    rgRequiredAttributeFoundBitMask[5] = 0;
    rgRequiredAttributeFoundBitMask[6] = 0;
    rgRequiredAttributeFoundBitMask[7] = 0;

    for (i=0; i<cNodes; i++)
    {
        if (prgNodes[i].Type == SXS_ATTRIBUTE)
        {
            const SIZE_T cchText = prgNodes[i].cchText;
            const SIZE_T cchNamespace = prgNodes[i].NamespaceStringBuf.Cch();
            const PCWSTR pszText = prgNodes[i].pszText;

            // Ignore any attributes that start with xml
            if ((cchText >= 3) &&
                ((pszText[0] == L'x') || (pszText[0] == L'X')) &&
                ((pszText[1] == L'm') || (pszText[1] == L'M')) &&
                ((pszText[2] == L'l') || (pszText[2] == L'L')))
            {
                continue;
            }
            if (cchNamespace != 0 )
            {
                continue;
            }

            for (j=0; j<cAttributes; j++)
            {
                if ((prgAttributes[j].m_pName != NULL) &&
                    ::FusionpEqualStrings(prgNodes[i].NamespaceStringBuf, cchNamespace, prgAttributes[j].m_pName->Namespace, prgAttributes[j].m_pName->NamespaceCch, false) &&
                    ::FusionpEqualStrings(pszText, cchText, prgAttributes[j].m_pName->Name, prgAttributes[j].m_pName->NameCch, false))
                {
                    if (prgAttributes[j].m_pfnValidator != NULL)
                    {
                        CSmallStringBuffer buffValue;
                        bool fValid = false;
                        SIZE_T cb;
                        SIZE_T i2;

                        for (i2=i+1; i2<cNodes; i2++)
                        {
                            if (prgNodes[i2].Type == SXS_PCDATA)
                                IFW32FALSE_EXIT(buffValue.Win32Append(prgNodes[i2].pszText, prgNodes[i2].cchText));
                            else
                                break;
                        }

                        IFW32FALSE_EXIT(
                            (*prgAttributes[j].m_pfnValidator)(
                                prgAttributes[j].m_dwValidatorFlags,
                                buffValue,
                                fValid,
                                0,
                                NULL,
                                cb));

                        if (!fValid)
                        {
                            ::FusionpLogInvalidAttributeValueParseError(
                                m_ParseContext.SourceFile,
                                m_ParseContext.SourceFileCch,
                                m_ParseContext.LineNumber,
                                m_ParseContext.ElementName,
                                m_ParseContext.ElementNameCch,
                                prgAttributes[j].m_pName->Name,
                                prgAttributes[j].m_pName->NameCch);
                            
                            ORIGINATE_WIN32_FAILURE_AND_EXIT(InvalidAttributeValue, ERROR_SXS_MANIFEST_PARSE_ERROR);
                        }
                    }

                    if (prgAttributes[j].m_dwFlags & ELEMENT_LEGAL_ATTRIBUTE_FLAG_REQUIRED)
                    {
                        rgRequiredAttributeFoundBitMask[(j / 32)] |= (1 << (j % 32));
                        cRequiredAttributesFound++;
                    }

                    break;
                }
            }

            if (j == cAttributes)
            {
                // We found an illegal attribute!!
                ::FusionpLogAttributeNotAllowedParseError(
                    m_ParseContext.SourceFile,
                    m_ParseContext.SourceFileCch,
                    m_ParseContext.LineNumber,
                    prgNodes[0].pszText,
                    prgNodes[0].cchText,
                    prgNodes[i].pszText,
                    prgNodes[i].cchText);

                // We don't just go to exit here because we want to report all the bad attributes and missing attributes...
                fParseFailed = TRUE;
            }
        }
    }

    if (cRequiredAttributesFound != cRequiredAttributes)
    {
        for (j=0; j<cAttributes; j++)
        {
            if (prgAttributes[j].m_dwFlags & ELEMENT_LEGAL_ATTRIBUTE_FLAG_REQUIRED)
            {
                if ((rgRequiredAttributeFoundBitMask[(j / 32)] & (1 << (j % 32))) == 0)
                {
                    ::FusionpLogRequiredAttributeMissingParseError(
                        m_ParseContext.SourceFile,
                        m_ParseContext.SourceFileCch,
                        m_ParseContext.LineNumber,
                        prgNodes[0].pszText,
                        prgNodes[0].cchText,
                        prgAttributes[j].m_pName->Name,
                        prgAttributes[j].m_pName->NameCch);

                    fParseFailed = TRUE;
                }
            }
        }
    }

    if (fParseFailed)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(ParseError, ERROR_SXS_MANIFEST_PARSE_ERROR);

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\parsepolicy.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    parsepolicy.cpp

Abstract:

    Functions to parse configuration (policy) manifests.

Author:

    Michael J. Grier (MGrier) January 12, 2001

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "probedassemblyinformation.h"
#include "fusionparser.h"
#include "cteestream.h"
#include "cresourcestream.h"
#include "nodefactory.h"
#include "fusioneventlog.h"
#include "actctxgenctx.h"



SxspComponentParsePolicyCore(
    ULONG Flags,
    PACTCTXGENCTX pGenContext,
    const CProbedAssemblyInformation &PolicyAssemblyInformation,
    CPolicyStatement *&rpPolicyStatement,
    IStream *pSourceStream,
    ACTCTXCTB_ASSEMBLY_CONTEXT *pAssemblyContext = NULL
    )
{
    BOOL                        fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    
    CSmartPtr<CNodeFactory>     NodeFactory;
    CSmartRef<IXMLParser>       pIXmlParser;
    PASSEMBLY                   Assembly = NULL;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> AssemblyIdentity;
    ACTCTXCTB_ASSEMBLY_CONTEXT  LocalAssemblyContext;
    STATSTG                     Stats;
    ULONG                       i;

    rpPolicyStatement = NULL;

    PARAMETER_CHECK(pGenContext != NULL);
    PARAMETER_CHECK(pSourceStream != NULL);
    if (pAssemblyContext == NULL)
    {
        pAssemblyContext = &LocalAssemblyContext;
    }

    IFW32FALSE_EXIT(Assembly = new ASSEMBLY);
    IFW32FALSE_EXIT(Assembly->m_ProbedAssemblyInformation.Initialize(PolicyAssemblyInformation));

    //
    // Copy the assembly identity, stick it into the callback structure
    //
    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            0, 
            PolicyAssemblyInformation.GetAssemblyIdentity(), 
            &AssemblyIdentity));

    //
    // Set up the structure in general
    //
    pAssemblyContext->AssemblyIdentity = AssemblyIdentity.DetachAndHold();
    
    IFW32FALSE_EXIT(
        PolicyAssemblyInformation.GetManifestPath(
            &pAssemblyContext->ManifestPath, 
            &pAssemblyContext->ManifestPathCch));

    IFCOMFAILED_ORIGINATE_AND_EXIT(pSourceStream->Stat(&Stats, STATFLAG_NONAME));

    //
    // Set up the node factory
    //
    IFW32FALSE_EXIT(NodeFactory.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT(NodeFactory->Initialize(pGenContext, Assembly, pAssemblyContext));
    IFW32FALSE_EXIT(NodeFactory->SetParseType(
        XML_FILE_TYPE_COMPONENT_CONFIGURATION,
        PolicyAssemblyInformation.GetManifestPathType(),
        PolicyAssemblyInformation.GetManifestPath(),
        Stats.mtime));
    
    //
    // Obtain the parser
    //
    IFW32FALSE_EXIT(::SxspGetXMLParser(IID_IXMLParser, (PVOID*)&pIXmlParser));
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXmlParser->SetFactory(NodeFactory));
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXmlParser->SetInput(pSourceStream));

    //
    // And they're off!
    //
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXmlParser->Run(-1));
    
    //
    // Tell the contributors we want to be done with this file...
    //
    for (i = 0; i < pGenContext->m_ContributorCount; i++)
    {
        IFW32FALSE_EXIT(pGenContext->m_Contributors[i].Fire_ParseEnding(pGenContext, pAssemblyContext));
    }

    rpPolicyStatement = NodeFactory->m_CurrentPolicyStatement;
    NodeFactory->m_CurrentPolicyStatement = NULL;

    fSuccess = TRUE;
Exit:
    {
        CSxsPreserveLastError ple;

        for (i = 0; i < pGenContext->m_ContributorCount; i++)
        {
            pGenContext->m_Contributors[i].Fire_ParseEnded(pGenContext, pAssemblyContext);
        }

        if (Assembly != NULL)
            Assembly->Release();

        ple.Restore();
    }

    return fSuccess;
}
    




BOOL
SxspParseNdpGacComponentPolicy(
    ULONG Flags,
    PACTCTXGENCTX pGenContext,
    const CProbedAssemblyInformation &PolicyAssemblyInformation,
    CPolicyStatement *&rpPolicyStatement
    )
{
    FN_PROLOG_WIN32
    CResourceStream DllStream;

    IFW32FALSE_EXIT(
        DllStream.Initialize(
            PolicyAssemblyInformation.GetManifestPath(), 
            MAKEINTRESOURCEW(RT_MANIFEST)));
    
    IFW32FALSE_EXIT(SxspComponentParsePolicyCore(
        Flags, 
        pGenContext, 
        PolicyAssemblyInformation, 
        rpPolicyStatement, 
        &DllStream));
    
    FN_EPILOG
}


BOOL
SxspParseComponentPolicy(
    DWORD Flags,
    PACTCTXGENCTX pActCtxGenCtx,
    const CProbedAssemblyInformation &PolicyAssemblyInformation,
    CPolicyStatement *&rpPolicyStatement
    )
{
    FN_PROLOG_WIN32
    CFileStream FileStream;

    IFW32FALSE_EXIT(
        FileStream.OpenForRead(
            PolicyAssemblyInformation.GetManifestPath(),
            CImpersonationData(),
            FILE_SHARE_READ,
            OPEN_EXISTING,
            FILE_FLAG_SEQUENTIAL_SCAN));

    IFW32FALSE_EXIT(SxspComponentParsePolicyCore(
        Flags,
        pActCtxGenCtx,
        PolicyAssemblyInformation,
        rpPolicyStatement,
        &FileStream));

    FN_EPILOG
}


BOOL
SxspParseApplicationPolicy(
    DWORD Flags,
    PACTCTXGENCTX pActCtxGenCtx,
    ULONG ulPolicyPathType,
    PCWSTR pszPolicyPath,
    SIZE_T cchPolicyPath,
    IStream *pIStream
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    // declaration order here is partially deliberate, to control cleanup order.
    // normally, declaration order is determined by not declaring until you have
    // the data to initialize with the ctor, but the use of goto messes that up
    CSmartPtr<CNodeFactory> NodeFactory;
    CSmartRef<IXMLParser> pIXMLParser;
    ACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    ULONG i;
    PASSEMBLY Assembly = NULL;
    CStringBuffer buffPath;
    STATSTG statstg;

    PARAMETER_CHECK(pIStream != NULL);
    PARAMETER_CHECK(Flags == 0);
    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    PARAMETER_CHECK(ulPolicyPathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);

    IFALLOCFAILED_EXIT(Assembly = new ASSEMBLY);

    IFW32FALSE_EXIT(buffPath.Win32Assign(pszPolicyPath, cchPolicyPath));

    IFW32FALSE_EXIT(Assembly->m_ProbedAssemblyInformation.Initialize(pActCtxGenCtx));

    AssemblyContext.AssemblyIdentity = NULL;

    AssemblyContext.Flags = 0;
    AssemblyContext.AssemblyRosterIndex = 1; // hack alert
    AssemblyContext.PolicyPathType = ulPolicyPathType;
    AssemblyContext.PolicyPath = pszPolicyPath;
    AssemblyContext.PolicyPathCch = cchPolicyPath;
    AssemblyContext.ManifestPathType = ACTIVATION_CONTEXT_PATH_TYPE_NONE;
    AssemblyContext.ManifestPath = NULL;
    AssemblyContext.ManifestPathCch = 0;
    AssemblyContext.TeeStreamForManifestInstall = NULL;
    AssemblyContext.pcmWriterStream = NULL;
    AssemblyContext.InstallationInfo = NULL;
    AssemblyContext.AssemblySecurityContext = NULL;
    AssemblyContext.TextuallyEncodedIdentity = NULL;
    AssemblyContext.TextuallyEncodedIdentityCch = 0;

    //
    // Allocate the smart pointer
    //
    IFW32FALSE_EXIT(NodeFactory.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT(NodeFactory->Initialize(pActCtxGenCtx, Assembly, &AssemblyContext));

    NodeFactory->m_pApplicationPolicyTable = &pActCtxGenCtx->m_ApplicationPolicyTable;

    // Everyone's ready; let's get the XML parser:
    IFW32FALSE_EXIT(::SxspGetXMLParser(IID_IXMLParser, (LPVOID *) &pIXMLParser));
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXMLParser->SetFactory(NodeFactory));

    IFCOMFAILED_EXIT(pIStream->Stat(&statstg, STATFLAG_NONAME));

    // Open up the policy file and try parsing it...
    IFW32FALSE_EXIT(
        NodeFactory->SetParseType(
            XML_FILE_TYPE_APPLICATION_CONFIGURATION,
            ulPolicyPathType,
            buffPath,
            statstg.mtime));
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXMLParser->SetInput(pIStream));
    IFCOMFAILED_ORIGINATE_AND_EXIT(pIXMLParser->Run(-1));

    NodeFactory->m_CurrentPolicyStatement = NULL;

    // Tell the contributors we want to be done with this file...
    for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        IFW32FALSE_EXIT(pActCtxGenCtx->m_Contributors[i].Fire_ParseEnding(pActCtxGenCtx, &AssemblyContext));

    fSuccess = TRUE;

Exit:
    CSxsPreserveLastError ple;

    // And tell them we're done.
    for (i=0; i<pActCtxGenCtx->m_ContributorCount; i++)
        pActCtxGenCtx->m_Contributors[i].Fire_ParseEnded(pActCtxGenCtx, &AssemblyContext);

    if ( ple.LastError() == ERROR_SXS_MANIFEST_PARSE_ERROR || ple.LastError() == ERROR_SXS_MANIFEST_FORMAT_ERROR)
    { // log a general failure eventlog
        ::FusionpLogError(MSG_SXS_PARSE_MANIFEST_FAILED);
    }

    if (Assembly != NULL)
        Assembly->Release();

    ple.Restore();

    return fSuccess;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\pcm.h ===
/*++                                                                                                          /*++

Copyright (c) Microsoft Corporation

Module Name:

    pcm.h

Abstract:
    Define common data structure for precompiled-manifest Writer and Reader
    and class definition of PrecompiledManifetWriter and
    PrecompiledManifestReader

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/
#if !defined(_FUSION_SXS_PCM_H_INCLUDED_)
#define _FUSION_SXS_PCM_H_INCLUDED_

#pragma once

#include <ole2.h>
#include <xmlparser.h>
#include "nodefactory.h"
#include "pcmwriterstream.h"

// pcm structure shared between PCMWriter and PCMReader
typedef enum _RECORD_TYPE_PRECOMP_MANIFEST{
    CREATENODE_PRECOMP_MANIFEST     = 1,
    BEGINCHILDREN_PRECOMP_MANIFEST  = CREATENODE_PRECOMP_MANIFEST + 1,
    ENDCHILDREN_PRECOMP_MANIFEST    = BEGINCHILDREN_PRECOMP_MANIFEST + 1
} RECORD_TYPE_PRECOMP_MANIFEST;

typedef struct _PCM_Header{
    int     iVersion;
    ULONG   ulRecordCount;
    USHORT  usMaxNodeCount;
}PCMHeader;

typedef struct _PCM_RecordHeader{
    int     typeID ;
    ULONG   RecordSize;
    ULONG   NodeCount;
}PCM_RecordHeader;

typedef struct _PCM_XML_NODE_INFO{
    DWORD           dwSize;
    DWORD           dwType;
    DWORD           dwSubType;
    BOOL            fTerminal;
    ULONG           offset;
    ULONG           ulLen;
    ULONG           ulNsPrefixLen;
}PCM_XML_NODE_INFO;

class __declspec(uuid("6745d578-5d84-4890-aa6a-bd794ea50421"))
CPrecompiledManifestReader : public IXMLNodeSource, public IStream {
public :
    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // IXMLNodeSource methods, only GetLineNumber is implemented got PCM purpose
    STDMETHODIMP SetFactory(IXMLNodeFactory __RPC_FAR *pNodeFactory);
    STDMETHODIMP GetFactory(IXMLNodeFactory** ppNodeFactory);
    STDMETHODIMP Abort(BSTR bstrErrorInfo);
    STDMETHODIMP_(ULONG) GetLineNumber(void);
    STDMETHODIMP_(ULONG) GetLinePosition(void);
    STDMETHODIMP_(ULONG) GetAbsolutePosition(void);
    STDMETHODIMP GetLineBuffer(const WCHAR  **ppwcBuf, ULONG  *pulLen, ULONG  *pulStartPos);
    STDMETHODIMP GetLastError(void);
    STDMETHODIMP GetErrorInfo(BSTR  *pbstrErrorInfo);
    STDMETHODIMP_(ULONG) GetFlags();
    STDMETHODIMP GetURL(const WCHAR  **ppwcBuf);

    // IStream methods:
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppIStream);


    CPrecompiledManifestReader():m_hFile(INVALID_HANDLE_VALUE),
                            m_hFileMapping(INVALID_HANDLE_VALUE), m_lpMapAddress(NULL),
                            m_ulLineNumberFromCreateNodeRecord(ULONG(-1)),
                            m_dwFilePointer(0), m_dwFileSize(0),
                            m_cRef(0) { }

    ~CPrecompiledManifestReader() { CSxsPreserveLastError ple; this->Close(); ple.Restore(); }

    HRESULT InvokeNodeFactory(PCWSTR pcmFileName, IXMLNodeFactory *pNodeFactory);
    VOID Reset();

protected:
    HANDLE                  m_hFile;
    HANDLE                  m_hFileMapping;
    LPVOID                  m_lpMapAddress;
    ULONG                   m_ulLineNumberFromCreateNodeRecord;
    DWORD                   m_dwFilePointer; // should we limit the size of pcm file? Since manifest file is not very huge...
    DWORD                   m_dwFileSize;

    ULONG                   m_cRef;

    HRESULT Close(
        );

    HRESULT OpenForRead(
        IN PCWSTR pszPCMFileName,
        IN DWORD dwShareMode = FILE_SHARE_READ,                        // share mode
        IN DWORD dwCreationDisposition = OPEN_EXISTING,                // how to create
        IN DWORD dwFlagsAndAttributes = FILE_FLAG_SEQUENTIAL_SCAN      // file attributes
        );

    HRESULT ReadPCMHeader(
        OUT PCMHeader* pHeader
        );
    HRESULT ReadPCMRecordHeader(
        OUT PCM_RecordHeader * pHeader
        );

    HRESULT ReadPCMRecord(
        OUT XML_NODE_INFO ** ppNodes,
        OUT PCM_RecordHeader * pRecordHeader,
        OUT PVOID param
        );
};

class __declspec(uuid("1b345c93-eb16-4d07-b366-81e8a2b88414"))
CPrecompiledManifestWriter : public IXMLNodeFactory {
public :
    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // IXMLNodeFactory methods:
    STDMETHODIMP NotifyEvent(IXMLNodeSource *pSource, XML_NODEFACTORY_EVENT iEvt);
    STDMETHODIMP BeginChildren(IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo);
    STDMETHODIMP EndChildren(IXMLNodeSource *pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo);
    STDMETHODIMP Error(IXMLNodeSource *pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);
    STDMETHODIMP CreateNode(IXMLNodeSource *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);

    // constructor and destructor
    CPrecompiledManifestWriter() : m_cRef(0), m_ulRecordCount(0), m_usMaxNodeCount(0) { }

    ~CPrecompiledManifestWriter() { }

    // write APIs

    HRESULT Initialize(
        PACTCTXGENCTX ActCtxGenCtx,
        PASSEMBLY Assembly,
        PACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext);

    HRESULT SetWriterStream(CPrecompiledManifestWriterStream * pSinkedStream); // usually, filename of PCM is not available when
                                                             // the stream is opened. and stream is inited by caller
    HRESULT Initialize(PCWSTR pcmFileName);
    HRESULT WritePrecompiledManifestRecord(
        IN RECORD_TYPE_PRECOMP_MANIFEST typeID,
        IN PVOID    pData,
        IN USHORT   NodeCount,
        IN PVOID    param = NULL
        );
    HRESULT SetFactory(IXMLNodeFactory *pNodeFactory);
    HRESULT Close();

protected:
    CSmartRef<IXMLNodeFactory>          m_pNodeFactory;
    CSmartRef<CPrecompiledManifestWriterStream> m_pFileStream;
    ULONG                               m_ulRecordCount;
    USHORT                              m_usMaxNodeCount;
    ULONG                               m_cRef;

    HRESULT GetPCMRecordSize(
        IN XML_NODE_INFO ** ppNodeInfo,
        IN USHORT iNodeCount,
        IN ULONG * pSize
        );

    HRESULT WritePCMHeader( // version is forced to be 1, and the recordCount is forced to be 0;
        );

    HRESULT WritePCMRecordHeader(
        IN PCM_RecordHeader * pHeader
        );

    HRESULT WritePCMXmlNodeInfo(
        IN XML_NODE_INFO ** ppNodeInfo,
        IN USHORT iNodeCount,
        IN RECORD_TYPE_PRECOMP_MANIFEST typeID,
        IN PVOID param
        );
};

#endif // _FUSION_SXS_PRECOMPILED_MANIFEST_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\pcmtestfactory.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    pcmtestfactory.h

Abstract:
    definition of a nodefactory for Precompiled manifest testing

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/
#pragma once

#if SXS_PRECOMPILED_MANIFESTS_ENABLED

#include <stdio.h>
#include <windows.h>
#include <ole2.h>
#include <xmlparser.h>
#include "simplefp.h"

class __declspec(uuid("79fd77ad-f467-44ad-8cf9-2f259eeb3878"))
PCMTestFactory : public IXMLNodeFactory
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IXMLNodeFactory
    STDMETHODIMP NotifyEvent(IXMLNodeSource __RPC_FAR *pSource, XML_NODEFACTORY_EVENT iEvt);
    STDMETHODIMP BeginChildren(IXMLNodeSource __RPC_FAR *pSource, XML_NODE_INFO* __RPC_FAR pNodeInfo);
    STDMETHODIMP EndChildren(IXMLNodeSource __RPC_FAR *pSource, BOOL fEmptyNode, XML_NODE_INFO* __RPC_FAR pNodeInfo);
    STDMETHODIMP Error(IXMLNodeSource __RPC_FAR *pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
    {
        return hrErrorCode;
    }
    STDMETHODIMP CreateNode(IXMLNodeSource __RPC_FAR *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

    PCMTestFactory(PCWSTR pFileName = NULL) : m_cRef(0)
    {
        m_pFileStream = new CSimpleFileStream(pFileName);
    }

    ~PCMTestFactory()
    {
        CSxsPreserveLastError ple;
        ASSERT(m_cRef == 0);
        FUSION_DELETE_SINGLETON(m_pFileStream);

        ple.Restore();
    }

private :
    VOID PrintSingleXMLNode(XML_NODE_INFO * pNode);
    VOID PrintXMLNodeType(DWORD dwType);

    ULONG                   m_cRef;
    CSimpleFileStream* m_pFileStream;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\pcmtestfactory.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    pcmtestfactory.cpp

Abstract:
    implementation of a nodefactory for Precompiled manifest testing

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/

#include "stdinc.h"
#if SXS_PRECOMPILED_MANIFESTS_ENABLED
#include "fusioneventlog.h"
#include "pcmtestfactory.h"
#include "stdio.h"
#include "fusioneventlog.h"
#include <ole2.h>
#include "xmlparser.hxx"
#include "xmlparsertest.hxx"

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE PCMTestFactory::NotifyEvent(
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt)
{
    UNUSED(pSource);
    UNUSED(iEvt);

    // do nothing because PCM does not contain NotifyEvent record
    return NOERROR;
}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE PCMTestFactory::BeginChildren(
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
    HRESULT hr = NOERROR;
    UNUSED(pSource);
    UNUSED(pNodeInfo);

    m_pFileStream->fprintf("BeginChildren\n");
    return hr;

}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE PCMTestFactory::EndChildren(
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmptyNode,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
    HRESULT hr = NOERROR ;

    UNUSED(pSource);
    UNUSED(fEmptyNode);
    UNUSED(pNodeInfo);

    m_pFileStream->fprintf("EndChildren");
    if ( fEmptyNode ) {
        m_pFileStream->fprintf("(fEmpty=TRUE)\n");
    }else
        m_pFileStream->fprintf("(fEmpty=FALSE)\n");

    return hr;
}

VOID PCMTestFactory::PrintXMLNodeType(DWORD dwType)
{
    m_pFileStream->fprintf("\t\tdwType           = ");

    switch(dwType) {
        case XML_CDATA:
            m_pFileStream->fprintf("XML_CDATA\n");
            break;
        case XML_COMMENT :
            m_pFileStream->fprintf("XML_COMMENT\n");
            break ;
        case XML_WHITESPACE :
            m_pFileStream->fprintf("XML_WHITESPACE\n");
            break ;
        case XML_ELEMENT :
            m_pFileStream->fprintf("XML_ELEMENT\n");
            break ;
        case XML_ATTRIBUTE :
            m_pFileStream->fprintf("XML_ATTRIBUTE\n");
            break ;
        case XML_PCDATA :
            m_pFileStream->fprintf("XML_PCDATA\n");
            break ;
        case XML_PI:
            m_pFileStream->fprintf("XML_PI\n");
            break;
        case XML_XMLDECL :
            m_pFileStream->fprintf("XML_XMLDECL\n");
            break;
        case XML_DOCTYPE :
            m_pFileStream->fprintf("XML_DOCTYPE\n");
            break;
        case XML_ENTITYDECL :
            m_pFileStream->fprintf("XML_ENTITYDECL\n");
            break;
        case XML_ELEMENTDECL :
            m_pFileStream->fprintf("XML_ELEMENTDECL\n");
            break;
        case XML_ATTLISTDECL :
            m_pFileStream->fprintf("XML_ATTLISTDECL\n");
            break;
        case XML_NOTATION :
            m_pFileStream->fprintf("XML_NOTATION\n");
            break;
        case XML_ENTITYREF :
            m_pFileStream->fprintf("XML_ENTITYREF\n");
            break;
        case XML_DTDATTRIBUTE:
            m_pFileStream->fprintf("XML_DTDATTRIBUTE\n");
            break;
        case XML_GROUP :
            m_pFileStream->fprintf("XML_GROUP\n");
            break;
        case XML_INCLUDESECT :
            m_pFileStream->fprintf("XML_INCLUDESECT\n");
            break;
        case XML_NAME :
            m_pFileStream->fprintf("XML_NAME\n");
            break;
        case XML_NMTOKEN :
            m_pFileStream->fprintf("XML_NMTOKEN\n");
            break;
        case XML_STRING :
            m_pFileStream->fprintf("XML_STRING\n");
            break;
        case XML_PEREF :
            m_pFileStream->fprintf("XML_PEREF\n");
            break;
        case XML_MODEL :
            m_pFileStream->fprintf("XML_MODEL\n");
            break;
        case XML_ATTDEF :
            m_pFileStream->fprintf("XML_ATTDEF\n");
            break;
        case XML_ATTTYPE :
            m_pFileStream->fprintf("XML_ATTTYPE\n");
            break;
        case XML_ATTPRESENCE :
            m_pFileStream->fprintf("XML_ATTPRESENCE\n");
            break;
        case XML_DTDSUBSET :
            m_pFileStream->fprintf("XML_DTDSUBSET\n");
            break;
        case XML_LASTNODETYPE :
            m_pFileStream->fprintf("XML_LASTNODETYPE\n");
            break;
        default :
            m_pFileStream->fprintf(" NOT KNOWN TYPE! ERROR!!\n");
    } // end of switch

}

//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE PCMTestFactory::CreateNode(
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
{
    HRESULT hr = NOERROR;
    DWORD i;

    UNUSED(pSource);
    UNUSED(pNode);
    UNUSED(apNodeInfo);
    UNUSED(cNumRecs);

    m_pFileStream->fprintf("CreateNode\n");
    for( i = 0; i < cNumRecs; i++)
        PrintSingleXMLNode(apNodeInfo[i]);
    return hr;
}

VOID PCMTestFactory::PrintSingleXMLNode(XML_NODE_INFO * pNode)
{
    m_pFileStream->fprintf("\tXML_NODE_INFO: \n");
    m_pFileStream->fprintf("\t\tdwSize           = %d \n", pNode->dwSize);
    PrintXMLNodeType(pNode->dwType);
    m_pFileStream->fprintf("\t\tdwSubType        = %d \n", pNode->dwSubType);
    m_pFileStream->fprintf("\t\tfTerminal        = %d \n", pNode->fTerminal);
    m_pFileStream->fwrite((PVOID)(pNode->pwcText), sizeof(WCHAR), pNode->ulLen);
    m_pFileStream->fprintf("\t\tulLen            = %d \n", pNode->ulLen);
    m_pFileStream->fprintf("\t\tulNsPrefixLen    = %d \n", pNode->ulNsPrefixLen);
    m_pFileStream->fprintf("\t\tpNode            = NULL\n");
    m_pFileStream->fprintf("\t\tpReserved        = NULL \n\n");
}

STDMETHODIMP_(ULONG)
PCMTestFactory::AddRef()
{
    return ::SxpInterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
PCMTestFactory::Release()
{
    ULONG lRet = ::SxspInterlockedDecrement(&m_cRef);
    if (!lRet)
        FUSION_DELETE_SINGLETON(this);

    return lRet;
}

STDMETHODIMP
PCMTestFactory::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == __uuidof(this))
    {
        *ppv = this;
    }
    else if (riid == IID_IUnknown
        || riid == IID_IXMLNodeFactory)
    {
        *ppv = static_cast<IXMLNodeFactory*> (this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\pcmreader.cpp ===
/*++                                                                                                          /*++

Copyright (c) Microsoft Corporation

Module Name:

    pcmreader.cpp

Abstract:
    implementation of PrecompiledManifestReader

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/

#include "stdinc.h"
#include "pcm.h"


/* main function of this class
pwcText in XML_NODE_INFO is not allocated in the code because we use file mapping
*/
HRESULT
CPrecompiledManifestReader::InvokeNodeFactory(PCWSTR pcmFileName, IXMLNodeFactory * pXMLNodeFactory)
{
    HRESULT                 hr = NOERROR;
    PCMHeader               pcmHeader;
    PCM_RecordHeader        pcmRecordHeader;
    typedef XML_NODE_INFO*  PXML_NODE_INFO;
    PXML_NODE_INFO*         ppNodes = NULL;  // array of PXML_NODE_INFO
    XML_NODE_INFO*          pXMLData = NULL;

    ULONG                   i, j;
    BOOL                    fEmpty = FALSE;

    if ((!pcmFileName)  || (!pXMLNodeFactory))
        return E_INVALIDARG;

    hr = OpenForRead(pcmFileName);
    if (FAILED(hr))
        goto Exit;

    hr = ReadPCMHeader(&pcmHeader);
    if (FAILED(hr))
        goto Exit;

    if ( pcmHeader.iVersion != 1) { // wrong version number
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Wrong Version of Precompiled manifest file %S in %S()\n", pcmFileName, __FUNCTION__);

        hr = E_FAIL;
        goto Exit;
    }

    // by allocate the maximum PXML_NODE_INFO, this space would be reused
    ppNodes = FUSION_NEW_ARRAY(PXML_NODE_INFO, pcmHeader.usMaxNodeCount);
    if (!ppNodes) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pXMLData = FUSION_NEW_ARRAY(XML_NODE_INFO, pcmHeader.usMaxNodeCount);
    if (!pXMLData){
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    memset(pXMLData, 0, sizeof(XML_NODE_INFO)*pcmHeader.usMaxNodeCount);

    // setup the pointer array and data
    for (i=0;i<pcmHeader.usMaxNodeCount; i++)
        ppNodes[i] = &pXMLData[i];

    for ( i=0; i<pcmHeader.ulRecordCount; i++) {
        hr = ReadPCMRecordHeader(&pcmRecordHeader);
        if (FAILED(hr))
            goto Exit;

        switch(pcmRecordHeader.typeID) {
            case ENDCHILDREN_PRECOMP_MANIFEST :
                hr = ReadPCMRecord(ppNodes, &pcmRecordHeader, &fEmpty); // fEmpty would be set
                break;
            case CREATENODE_PRECOMP_MANIFEST :
                hr = ReadPCMRecord(ppNodes, &pcmRecordHeader, NULL);    // m_ulLineNumber would be Set
                break;
            case BEGINCHILDREN_PRECOMP_MANIFEST :
                hr = ReadPCMRecord(ppNodes, &pcmRecordHeader, NULL);
                break;
            default:
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: %S() failed for invalid typeID in PCM Record", __FUNCTION__);

                hr = E_UNEXPECTED;
        } // end of swtich

        if (FAILED(hr))
            goto Exit;

        switch (pcmRecordHeader.typeID){
            case CREATENODE_PRECOMP_MANIFEST:
                hr = pXMLNodeFactory->CreateNode(this, NULL, (USHORT)(pcmRecordHeader.NodeCount), ppNodes);
                // "this" is passed in CreateNode because it has implemented IXMLNodeSource
            break;
            case BEGINCHILDREN_PRECOMP_MANIFEST:
                hr = pXMLNodeFactory->BeginChildren(NULL, *ppNodes);
            break;
            case ENDCHILDREN_PRECOMP_MANIFEST :
                hr = pXMLNodeFactory->EndChildren(NULL, fEmpty, *ppNodes);
            break;
            default:
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: %S() failed for invalid typeID in PCM Record", __FUNCTION__);

                hr = E_UNEXPECTED;
            break;
        }// end of switch
        if ( FAILED(hr))
            goto Exit;


    } // end of for

    hr = Close();
    if ( FAILED(hr))
        goto Exit;

    hr = NOERROR;
Exit:

    if (pXMLData)
    {
        FUSION_DELETE_ARRAY(pXMLData);
        pXMLData = NULL;
    }

    if (ppNodes)
    {
        FUSION_DELETE_ARRAY(ppNodes);
        ppNodes = NULL;
    }

    return hr;
}

// helper functions
HRESULT
CPrecompiledManifestReader::ReadPCMHeader(PCMHeader* pHeader)
{
    HRESULT hr = NOERROR;

    if ( ! pHeader )
        return E_INVALIDARG;

    ASSERT(m_lpMapAddress);

    hr = this->Read((PVOID)pHeader, sizeof(PCMHeader), NULL);
    if ( FAILED(hr))
        goto Exit;

    if ( pHeader->iVersion != 1 ){ // wrong file header, stop
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Wrong Version of Precompiled manifest file in %S()\n", __FUNCTION__);

        hr = E_UNEXPECTED;
        goto Exit;
    }
    hr = NOERROR;

Exit:
    return hr;
}

HRESULT
CPrecompiledManifestReader::ReadPCMRecordHeader(PCM_RecordHeader * pHeader)
{
    HRESULT hr = NOERROR;
    if (!pHeader)
        return E_INVALIDARG;

    ASSERT(m_lpMapAddress);
    return this->Read((PVOID)pHeader, sizeof(PCM_RecordHeader), NULL);
}

inline void FromPCMXMLNodeToXMLNode(XML_NODE_INFO * pNode, PCM_XML_NODE_INFO * pPCMNode)
{
    ASSERT(pNode && pPCMNode);

    pNode->dwSize       = pPCMNode->dwSize;
    pNode->dwType       = pPCMNode->dwType;
    pNode->dwSubType    = pPCMNode->dwSubType;
    pNode->fTerminal    = pPCMNode->fTerminal;
    pNode->ulLen        = pPCMNode->ulLen;
    pNode->ulNsPrefixLen= pPCMNode->ulNsPrefixLen;

    pNode->pwcText      = NULL;

    return;
}

HRESULT
CPrecompiledManifestReader::ReadPCMRecord(XML_NODE_INFO ** ppNodes,
        PCM_RecordHeader * pRecordHeader, PVOID param)
{
    HRESULT hr = NOERROR;
    ULONG i, strOffset;
    PVOID pData, ptr;
    PCM_XML_NODE_INFO pcmNode;

    if ( !ppNodes || !pRecordHeader)
        return E_INVALIDARG;

    // point to the data in the mapped file
    pData = (BYTE *)m_lpMapAddress + m_dwFilePointer;

    switch (pRecordHeader->typeID){
        default:
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %S() failed for invalid typeID in PCM Record", __FUNCTION__);

            hr = E_UNEXPECTED;
            goto Exit;
        break;
        case CREATENODE_PRECOMP_MANIFEST:
            memcpy(PVOID(&m_ulLineNumberFromCreateNodeRecord), (BYTE *)pData + pRecordHeader->NodeCount * sizeof(PCM_XML_NODE_INFO), sizeof(ULONG));
            break;
        case BEGINCHILDREN_PRECOMP_MANIFEST:
            break;
        case ENDCHILDREN_PRECOMP_MANIFEST :
            ASSERT(param);
            memcpy(param, (BYTE *)pData + pRecordHeader->NodeCount * sizeof(PCM_XML_NODE_INFO), sizeof(BOOL));
            break;
    } // end of switch

    ptr = pData;
    for (i=0; i< pRecordHeader->NodeCount; i++) {
        //memcpy((PVOID)ppNodes[i], ptr, sizeof(PCM_XML_NODE_INFO));
        memcpy((PVOID)&pcmNode, ptr, sizeof(PCM_XML_NODE_INFO));
        FromPCMXMLNodeToXMLNode(ppNodes[i], &pcmNode); // void func

        // reset pwcText
        strOffset=pcmNode.offset;
        ppNodes[i]->pwcText = (WCHAR*)((BYTE *)pData + strOffset);

        ppNodes[i]->pNode = NULL;
        ppNodes[i]->pReserved = NULL;
        ptr = (BYTE *)ptr + sizeof(PCM_XML_NODE_INFO);
    }

    // reset the pointer of file
    m_dwFilePointer += pRecordHeader->RecordSize;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CPrecompiledManifestReader::Close()
{
    HRESULT hr = NOERROR;

    if (m_lpMapAddress)
        if ( ! ::UnmapViewOfFile(m_lpMapAddress)) {
            // continue the close process even hr is not NOERROR
            hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        }

    if (m_hFileMapping != INVALID_HANDLE_VALUE)
        if ( ! ::CloseHandle(m_hFileMapping)) {
            // UnmapViewOfFile is done successfully
            if ( hr == NOERROR )
                hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        }

    if (m_hFile != INVALID_HANDLE_VALUE)
        if ( ! ::CloseHandle(m_hFile)) {
            // UnmapViewOfFile and CloseHandle(filemapping) is done successfully
            if ( hr == NOERROR )
                hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        }

    if ( FAILED(hr))
        goto Exit;

    this->Reset();

    hr = NOERROR;
Exit:
    return hr;
}

VOID CPrecompiledManifestReader::Reset()
{
    m_lpMapAddress = NULL;
    m_hFileMapping = INVALID_HANDLE_VALUE;
    m_hFile = INVALID_HANDLE_VALUE;
    m_dwFilePointer = 0;

    return;
}

HRESULT
CPrecompiledManifestReader::OpenForRead(
    PCWSTR pszPath,
    DWORD dwShareMode,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes
    )
{
    HRESULT hr = NOERROR;

    if (pszPath == NULL)
        return E_INVALIDARG;

    if (m_hFile != INVALID_HANDLE_VALUE){
        hr = E_UNEXPECTED;
        goto Exit;
    }

    m_hFile = ::CreateFileW(
        pszPath,
        GENERIC_READ,
        dwShareMode,
        NULL,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        NULL);

    if (m_hFile == INVALID_HANDLE_VALUE){
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %S() failed; GetLastError() = %d\n", __FUNCTION__, ::FusionpGetLastWin32Error());

        hr = E_UNEXPECTED;
        goto Exit;
    }


    m_dwFileSize = GetFileSize(m_hFile, NULL);
    if ( m_dwFileSize== INVALID_FILE_SIZE ) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %S() call GetFileSize failed, GetLastError() = %d\n", __FUNCTION__, ::FusionpGetLastWin32Error());

        hr = E_UNEXPECTED;
        goto Exit;
    }

    // open filemapping
    ASSERT(m_hFileMapping == INVALID_HANDLE_VALUE);
    if (m_hFileMapping != INVALID_HANDLE_VALUE){
        hr = E_UNEXPECTED;
        goto Exit;
    }

    m_hFileMapping = ::CreateFileMappingW(m_hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (m_hFileMapping == INVALID_HANDLE_VALUE){
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    // map view of file
    ASSERT(m_lpMapAddress == NULL);
    if ( m_lpMapAddress ) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    m_lpMapAddress = MapViewOfFile(m_hFileMapping, FILE_MAP_READ, 0, 0, 0); // mpa the whole file
    if (!m_lpMapAddress) {
        hr = E_FAIL;
        goto Exit;
    }

    hr = NOERROR;
Exit:
    if ( FAILED(hr))
        Close();

    return hr;
}
// IStream methods:
HRESULT
CPrecompiledManifestReader::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    DWORD dwData;
    ULONG cbRead;

    if (pcbRead)
        *pcbRead = 0;

    if (!pv)
        return E_INVALIDARG;

    if ( m_dwFilePointer >= m_dwFileSize )  // read at the file end
        return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);

    dwData = m_dwFileSize - m_dwFilePointer;

    cbRead = (cb <= dwData) ? cb : dwData;
    memcpy(pv, (BYTE *)m_lpMapAddress + m_dwFilePointer, cbRead);

    m_dwFilePointer += cbRead;

    if (pcbRead)
        *pcbRead = cbRead;

    return NOERROR;
}
HRESULT
CPrecompiledManifestReader::Write(void const *pv, ULONG cb, ULONG *pcbWritten)
{
    if (pcbWritten)
        *pcbWritten = 0;

    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    if (plibNewPosition)
        plibNewPosition->QuadPart = 0;

    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::SetSize(ULARGE_INTEGER libNewSize)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    if (pcbWritten)
        pcbWritten->QuadPart = 0;

    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Commit(DWORD grfCommitFlags)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Revert()
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Clone(IStream **ppIStream)
{
    if ( ppIStream )
        *ppIStream = NULL;
    ASSERT(FALSE);
    return E_NOTIMPL;
}

// IXMLNodeSource methods, only GetLineNumber are implemented got PCM purpose
HRESULT
CPrecompiledManifestReader::SetFactory(IXMLNodeFactory *pNodeFactory)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::GetFactory(IXMLNodeFactory** ppNodeFactory)
{
    if (ppNodeFactory)
        *ppNodeFactory = NULL;
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::Abort(BSTR bstrErrorInfo)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
ULONG
CPrecompiledManifestReader::GetLineNumber(void)
{
    ASSERT(m_ulLineNumberFromCreateNodeRecord != (ULONG)-1);
    ULONG tmp = m_ulLineNumberFromCreateNodeRecord;
    // do not reset it to be (-1) because the caller may call this function more than once
    //m_ulLineNumberFromCreateNodeRecord = (ULONG)-1;
    return tmp;
}
ULONG
CPrecompiledManifestReader::GetLinePosition(void)
{
    ASSERT(FALSE);
    return ULONG(-1);
}
ULONG
CPrecompiledManifestReader::GetAbsolutePosition(void)
{
    ASSERT(FALSE);
    return ULONG(-1);
}
HRESULT
CPrecompiledManifestReader::GetLineBuffer(const WCHAR  **ppwcBuf, ULONG  *pulLen, ULONG  *pulStartPos)
{
    if (ppwcBuf)
        *ppwcBuf = NULL;
    if (pulLen)
        * pulLen = 0;
    if (pulStartPos)
        *pulStartPos = NULL;

    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::GetLastError(void)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
HRESULT
CPrecompiledManifestReader::GetErrorInfo(BSTR  *pbstrErrorInfo)
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}
ULONG
CPrecompiledManifestReader::GetFlags()
{
    ASSERT(FALSE);
    return ULONG(-1);
}
HRESULT
CPrecompiledManifestReader::GetURL(const WCHAR  **ppwcBuf)
{
    if (ppwcBuf)
        *ppwcBuf = NULL;

    ASSERT(FALSE);
    return E_NOTIMPL;
}

// IUnknown method implementation
ULONG
CPrecompiledManifestReader::AddRef()
{
    ULONG ulResult = ::SxspInterlockedIncrement(&m_cRef);
    return ulResult;
}

ULONG
CPrecompiledManifestReader::Release()
{
    ULONG ulResult = ::SxspInterlockedDecrement(&m_cRef);
    if (ulResult == 0 )
    {
        FUSION_DELETE_SINGLETON(this);
    }
    return ulResult;
}

HRESULT
CPrecompiledManifestReader::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = NOERROR;
    IUnknown *pIUnknown = NULL;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    if (ppvObj == NULL){
        hr = E_POINTER;
        goto Exit;
    }

    if (riid == __uuidof(this))
        *ppvObj = this;
    else if ((riid == IID_IUnknown) ||
        (riid == IID_ISequentialStream) ||
        (riid == IID_IStream))
        pIUnknown = static_cast<IStream *>(this);
    else if ( riid == IID_IXMLNodeSource )
        pIUnknown = static_cast<IXMLNodeSource *>(this);
    else
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    AddRef();
    if (pIUnknown != NULL)
        *ppvObj = pIUnknown;

    hr = NOERROR;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\pcmwriter.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    pcmwriter.cpp

Abstract:
    implementation of Precompiled manifest writer

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/

#include "stdinc.h"
#include "pcm.h"
#include "nodefactory.h"
//helper APIs
HRESULT CPrecompiledManifestWriter::SetFactory(IXMLNodeFactory *pNodeFactory)
{
    if (! pNodeFactory)
        return E_INVALIDARG;

    m_pNodeFactory = pNodeFactory;

    return NOERROR;
}

HRESULT CPrecompiledManifestWriter::Close()
{
    HRESULT hr = NOERROR;

    if (m_pFileStream)
        hr = m_pFileStream->Close(m_ulRecordCount, m_usMaxNodeCount);

    return hr;
}
HRESULT CPrecompiledManifestWriter::Initialize(PCWSTR pcmFileName)
{
    HRESULT hr = NOERROR;
    CStringBuffer buffFileName;

    if ( ! pcmFileName )
        return E_INVALIDARG;

    hr = buffFileName.Assign(pcmFileName, ::wcslen(pcmFileName));
    if (FAILED(hr))
        return hr;

    // Initialize() is assumed to be called only once
    if (m_pFileStream != NULL){
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %S is called more than once\n", __FUNCTION__);

        return E_UNEXPECTED;
    }

    m_pFileStream = new CPrecompiledManifestWriterStream;
    if ( !m_pFileStream )
        return E_OUTOFMEMORY;

    hr = m_pFileStream->SetSink(buffFileName);
    if (FAILED(hr))
        goto Exit;

    hr = WritePCMHeader();
    if ( FAILED(hr))
        goto Exit;

    hr= NOERROR;

Exit:
    return hr;

}

// we assume that this pStream is initialized by using SetSink....
HRESULT CPrecompiledManifestWriter::SetWriterStream(CPrecompiledManifestWriterStream * pSinkedStream)
{
    if ( ! pSinkedStream )
        return E_INVALIDARG;

    ASSERT(pSinkedStream->IsSinkedStream() == TRUE);

    m_pFileStream = pSinkedStream;

    return NOERROR;
}

// write helper APIs
HRESULT CPrecompiledManifestWriter::GetPCMRecordSize(XML_NODE_INFO ** ppNodeInfo, USHORT iNodeCount, ULONG * pSize)
{
    ULONG ulSize = 0 ;
    XML_NODE_INFO *pNode = NULL;
    USHORT i = 0 ;
    ULONG ulSingleRecordSize = offsetof(XML_NODE_INFO, pNode);
    HRESULT hr = NOERROR;

    if ( pSize)
        *pSize = 0 ;

    if ((!pSize) || (!ppNodeInfo) || (!*ppNodeInfo))
       return E_INVALIDARG;
    // validate ppNodeInfo
    for (i=0;i<iNodeCount;i++)
        if (!ppNodeInfo[i])
            return E_INVALIDARG;

    *pSize = 0;
    for ( i=0; i < iNodeCount; i++){
        pNode = ppNodeInfo[i];
        ASSERT(pNode);
        //ulSize += ulSingleRecordSize = sizeof(XML_NODE_INFO)- sizeof(PVOID) - sizeof(PVOID);
        ulSize += ulSingleRecordSize = offsetof(XML_NODE_INFO, pNode);
        ulSize += pNode->ulLen * sizeof(WCHAR);
    }
    if ( pSize)
    *pSize = ulSize;

    return hr;
}

HRESULT CPrecompiledManifestWriter::WritePCMHeader()
{
    HRESULT hr = NOERROR;
    PCMHeader pcmHeader;

    pcmHeader.iVersion = 1;
    pcmHeader.ulRecordCount = 0 ;
    pcmHeader.usMaxNodeCount = 0 ;

    hr = m_pFileStream->WriteWithDelay((PVOID)&(pcmHeader), sizeof(PCMHeader), NULL);
    if (FAILED(hr))
        goto Exit;
    hr = NOERROR;

Exit:
    return hr;
}

HRESULT CPrecompiledManifestWriter::WritePCMRecordHeader(PCM_RecordHeader * pHeader)
{
    HRESULT hr = NOERROR;

    ASSERT(m_pFileStream);
    if ( ! pHeader)
        return E_INVALIDARG;

    hr = m_pFileStream->WriteWithDelay((PVOID)(pHeader), sizeof(PCM_RecordHeader), NULL);
    if ( FAILED(hr))
        goto Exit;

    hr = NOERROR;
Exit:
    return hr;
}

inline void FromXMLNodeToPCMXMLNode(PCM_XML_NODE_INFO *pPCMNode, XML_NODE_INFO *pNode)
{
    ASSERT(pPCMNode && pNode);

    pPCMNode->dwSize    = pNode->dwSize;
    pPCMNode->dwType    = pNode->dwType ;
    pPCMNode->dwSubType = pNode->dwSubType ;
    pPCMNode->fTerminal = pNode->fTerminal ;
    pPCMNode->ulLen     = pNode->ulLen ;
    pPCMNode->ulNsPrefixLen = pNode->ulNsPrefixLen ;
    pPCMNode->offset    = 0 ;

    return;

}
HRESULT CPrecompiledManifestWriter::WritePCMXmlNodeInfo(XML_NODE_INFO ** ppNodeInfo, USHORT iNodeCount, RECORD_TYPE_PRECOMP_MANIFEST typeID, PVOID param)
{
    HRESULT hr = NOERROR;
    ULONG offset ;
    USHORT i;
    PCM_XML_NODE_INFO pcmNode;
    XML_NODE_INFO * pNode = NULL ;
    USHORT  uTextAddr;
    USHORT  uTextOffset;
    ULONG   cbWritten;
    LPWSTR *ppText = NULL;
    ULONG  *pcbLen = NULL;
    LPWSTR pstr;
    ULONG  ulLen;

    if ((!ppNodeInfo) || (!*ppNodeInfo))
        return E_INVALIDARG;
    if (!((typeID == ENDCHILDREN_PRECOMP_MANIFEST) || (typeID == BEGINCHILDREN_PRECOMP_MANIFEST) ||
        (typeID == CREATENODE_PRECOMP_MANIFEST)))
        return E_INVALIDARG;

    if (!m_pFileStream)
        return E_UNEXPECTED;

    //uTextAddr = sizeof(PCM_RecordHeader) + NodeCount * sizeof(PCM_XML_NODE_INFO);
    // RecordHeader is read before the boby(XML_NODE_INFO) is read
    uTextAddr = iNodeCount * sizeof(PCM_XML_NODE_INFO);
    uTextOffset = 0;


    if (typeID ==  ENDCHILDREN_PRECOMP_MANIFEST) // param1 is fEmpty;
        uTextAddr += sizeof(BOOL);
    else if (typeID ==  CREATENODE_PRECOMP_MANIFEST) // param1 = linenumber
        uTextAddr += sizeof(ULONG);

    if ( iNodeCount == 1) { // for BeginChildren and EndChildren
        ppText = &pstr;
        pcbLen = &ulLen;
    }
    else
    {
        ppText = FUSION_NEW_ARRAY(LPWSTR, iNodeCount);
        if (!ppText) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pcbLen = FUSION_NEW_ARRAY(ULONG, iNodeCount);
        if (!pcbLen ){
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    // write all records
    for (i=0; i<iNodeCount; i++) {
        pNode = ppNodeInfo[i];
        if (!pNode) {
            hr = E_FAIL;
            goto Exit;
        }
        ppText[i] = (LPWSTR)(pNode->pwcText) ;
        pcbLen[i] = pNode->ulLen * sizeof(WCHAR);

        //pPCMNode = static_cast<PCM_XML_NODE_INFO *>(pNode);
        FromXMLNodeToPCMXMLNode(&pcmNode, pNode);  // void function
        pcmNode.offset = uTextAddr + uTextOffset;
        uTextAddr = uTextAddr + uTextOffset;
        uTextOffset = (USHORT)pcmNode.ulLen * sizeof(WCHAR) ;

        hr = m_pFileStream->WriteWithDelay((PVOID)&pcmNode, sizeof(PCM_XML_NODE_INFO), &cbWritten);
        if ( FAILED(hr))
            goto Exit;
    }

    if ( typeID == ENDCHILDREN_PRECOMP_MANIFEST)  // write fEmpty into the file
        hr = m_pFileStream->WriteWithDelay(param, sizeof(BOOL), &cbWritten);
    else if ( typeID == CREATENODE_PRECOMP_MANIFEST)
        hr = m_pFileStream->WriteWithDelay(param, sizeof(ULONG), &cbWritten);

    // write texts in all records
    for (i=0; i<iNodeCount; i++) {
        hr = m_pFileStream->WriteWithDelay((PVOID)ppText[i], (ULONG)pcbLen[i], &cbWritten);
        if ( FAILED(hr))
            goto Exit;
    }

Exit :

    if ((ppText) && (ppText != &pstr))
        FUSION_DELETE_ARRAY(ppText);

    if ( (pcbLen) && ( pcbLen != &ulLen))
        FUSION_DELETE_ARRAY(pcbLen);

    return hr;
}

// write APIs
HRESULT CPrecompiledManifestWriter::WritePrecompiledManifestRecord(RECORD_TYPE_PRECOMP_MANIFEST typeID,
                                                            PVOID pData, USHORT NodeCount, PVOID param)
{
    HRESULT hr=NOERROR;
    PCM_RecordHeader pcmHeader;
    XML_NODE_INFO ** apNodeInfo = NULL ;


    if (!pData)
        return E_INVALIDARG;

    // validate typeID and param
    if ((typeID ==  ENDCHILDREN_PRECOMP_MANIFEST) || (typeID ==  CREATENODE_PRECOMP_MANIFEST)){
        if (!param)
            return E_INVALIDARG;
    }else if (typeID !=  BEGINCHILDREN_PRECOMP_MANIFEST)
        return E_INVALIDARG;

    apNodeInfo = (XML_NODE_INFO **)pData;

    pcmHeader.typeID = typeID;
    hr = GetPCMRecordSize(apNodeInfo, NodeCount, &pcmHeader.RecordSize) ;  // the size contains each string's length
    if (FAILED(hr))
        goto Exit;

    if (typeID ==  ENDCHILDREN_PRECOMP_MANIFEST)  // param1 is fEmpty;
        pcmHeader.RecordSize += sizeof(BOOL);
    else if (typeID ==  CREATENODE_PRECOMP_MANIFEST)  // param1 is Current Line number
        pcmHeader.RecordSize += sizeof(ULONG);

    pcmHeader.NodeCount = NodeCount;

    hr = WritePCMRecordHeader(&pcmHeader);
    if (FAILED(hr))
        goto Exit;

    hr = WritePCMXmlNodeInfo(apNodeInfo, NodeCount, typeID, param);
    if (FAILED(hr))
        goto Exit;

    m_ulRecordCount ++ ;
    if ( NodeCount > m_usMaxNodeCount )
        m_usMaxNodeCount = NodeCount;

    hr = NOERROR;
Exit:
    return hr;
}


// IUnknown
ULONG CPrecompiledManifestWriter::AddRef()
{
    return ::SxspInterlockedIncrement(&m_cRef);
}

ULONG CPrecompiledManifestWriter::Release()
{
    ULONG lRet = ::SxspInterlockedDecrement(&m_cRef);
    if (!lRet)
        FUSION_DELETE_SINGLETON(this);
    return lRet;
}

HRESULT CPrecompiledManifestWriter::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (riid == __uuidof(this))
    {
        *ppv = this;
    }
    else if (riid ==  IID_IUnknown
        || riid == IID_IXMLNodeFactory)
    {
        *ppv = static_cast<IXMLNodeFactory*> (this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

// IXMLNodeFactory methods:
HRESULT CPrecompiledManifestWriter::NotifyEvent(IXMLNodeSource *pSource, XML_NODEFACTORY_EVENT iEvt)
{
    ASSERT(m_pNodeFactory);
    // no hr-canonicalization is needed because these two nodefactories are supposed to return the correct range of values
    return m_pNodeFactory->NotifyEvent(pSource, iEvt);
}

HRESULT CPrecompiledManifestWriter::BeginChildren(IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo)
{
    HRESULT hr = NOERROR;
    ASSERT(m_pNodeFactory);
    hr = m_pNodeFactory->BeginChildren(pSource, pNodeInfo);
    if ( FAILED(hr))
        goto Exit;

    // write pcm file
    hr = WritePrecompiledManifestRecord(BEGINCHILDREN_PRECOMP_MANIFEST,
                                            &pNodeInfo, 1, NULL);
    if ( FAILED(hr))
        goto Exit;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT CPrecompiledManifestWriter::EndChildren(IXMLNodeSource *pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo)
{
    HRESULT hr = NOERROR;
    ASSERT(m_pNodeFactory);
    hr = m_pNodeFactory->EndChildren(pSource, fEmpty, pNodeInfo);
    if ( FAILED(hr))
        goto Exit;

    // write pcm file
    hr = WritePrecompiledManifestRecord(ENDCHILDREN_PRECOMP_MANIFEST, &pNodeInfo, 1, &fEmpty);
    if ( FAILED(hr))
        goto Exit;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT CPrecompiledManifestWriter::Error(IXMLNodeSource *pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo)
{
    ASSERT(m_pNodeFactory);
    // no hr-canonicalization is needed because these two nodefactories are supposed to return the correct range of values
    return m_pNodeFactory->Error(pSource, hrErrorCode, cNumRecs, apNodeInfo);
}

HRESULT CPrecompiledManifestWriter::CreateNode(IXMLNodeSource *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO **apNodeInfo)
{
    ULONG ulLineNumber ;
    HRESULT hr = NOERROR;

    ASSERT(m_pNodeFactory);
    if ( ! m_pNodeFactory)
        return E_UNEXPECTED;

    hr = m_pNodeFactory->CreateNode(pSource, pNodeParent, cNumRecs, apNodeInfo);
    if ( FAILED(hr))
        goto Exit;

    ulLineNumber = pSource->GetLineNumber();
    hr = WritePrecompiledManifestRecord(CREATENODE_PRECOMP_MANIFEST,
                                            apNodeInfo, cNumRecs, &ulLineNumber);
    if ( FAILED(hr))
        goto Exit;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT CPrecompiledManifestWriter::Initialize(PACTCTXGENCTX ActCtxGenCtx, PASSEMBLY Assembly,
                                    PACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    CSmartRef<CNodeFactory> pNodeFactory;

    if (! m_pNodeFactory) {
        pNodeFactory = new CNodeFactory;
        if (!pNodeFactory) {
            return E_OUTOFMEMORY;
        }
        m_pNodeFactory = pNodeFactory;
    }
    else {
        hr = pNodeFactory.QueryInterfaceFrom(m_pNodeFactory);
        ASSERT(SUCCEEDED(hr));
    }

    IFW32FALSE_EXIT(pNodeFactory->Initialize(ActCtxGenCtx, Assembly, AssemblyContext));

    IFCOMFAILED_EXIT(this->SetWriterStream(reinterpret_cast<CPrecompiledManifestWriterStream*>(AssemblyContext->pcmWriterStream));

    // this must be called in order for later use
    IFCOMFAILED_EXIT(this->WritePCMHeader());

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\pcmwriterstream.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    pcmWriterStream.cpp

Abstract:
    implementation of a filestream for Precompiled manifest writer

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/

#include "stdinc.h"
#include "pcm.h"
#include "pcmwriterstream.h"

// NTRAID#NTBUG9 - 587991 - 2002/03/26 - xiaoyuw:
// (1) currently not in the build
// (2) no fusion tracing macros used
//

HRESULT CPrecompiledManifestWriterStream::WriteWithDelay(void const *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hr=NOERROR;

    if (pcbWritten)
        *pcbWritten = 0 ;

    if (m_fBuffer)
    {
        if (FAILED(hr = m_buffer.Append(reinterpret_cast<const BYTE*>(pv), cb)))
            goto Exit;
        if ( pcbWritten)
            *pcbWritten = cb;
    }
    else
    {
        DWORD dwBytesWritten = 0;

        ASSERT(m_hFile != INVALID_HANDLE_VALUE);

        BOOL fSuccess = (cb == 0) || WriteFile(m_hFile, pv, cb, &dwBytesWritten, NULL);
        if (!fSuccess)
            // NTRAID#NTBUG9 - 587991 - 2002/03/26 - xiaoyuw:
            // in the case of (cb ==0), no LastError is set, and hr would be S_OK;
            hr = ::FusionpHresultFromLastError();   
        else if (dwBytesWritten != cb)
            hr = E_FAIL;
        if ( pcbWritten)
            *pcbWritten = dwBytesWritten;
    }

    // NTRAID#NTBUG9 - 587991 - 2002/03/26 - xiaoyuw:
    // NOERROR would overwrite all hr error code ever set.
    hr = NOERROR;
Exit:
    return hr;

}

BOOL
CPrecompiledManifestWriterStream::SetSink(
    const CBaseStringBuffer &rbuff,
    DWORD   openOrCreate
    )
{
    BOOL fSuccess = FALSE;
    DWORD dwBytesWritten = 0;
    DWORD dwBufferSize = 0;

    //
    // NTRAID#NTBUG9-164736-2000/8/17-a-JayK,JayKrell share should be 0
    //
    if (!Base::OpenForWrite(rbuff, FILE_SHARE_WRITE, openOrCreate))
        goto Exit;

    dwBufferSize = static_cast<DWORD>(m_buffer.GetCurrentCb());
    fSuccess = TRUE;
    if (dwBufferSize > 0){
        // NTRAID#NTBUG9 - 587991 - 2002/03/26 - xiaoyuw:
        // change assert to INTERNAL_ERROR_CHECK
        ASSERT ( m_hFile != INVALID_HANDLE_VALUE );
        fSuccess = WriteFile(m_hFile, m_buffer, dwBufferSize, &dwBytesWritten, NULL/*overlapped*/);

        if (fSuccess && dwBytesWritten != dwBufferSize){
            ::FusionpSetLastWin32Error(ERROR_WRITE_FAULT);
            fSuccess = FALSE;
        }
    }
    m_fBuffer = FALSE;

Exit:
    if (!fSuccess){
        // NTRAID#NTBUG9 - 587991 - 2002/03/26 - xiaoyuw:
        // CSxsPreserveLastError should be used here to make the code cleaner.
        //
        DWORD dwLastError = ::FusionpGetLastWin32Error();
        m_buffer.Clear(true);
        ::FusionpSetLastWin32Error(dwLastError);
    }
    else
        m_buffer.Clear(true);

    return fSuccess;
}

//besides close, rewrite MaxNodeCount, RecordCount into the header of the file
HRESULT CPrecompiledManifestWriterStream::Close(ULONG ulRecordCount, DWORD dwMaxNodeCount)
{
    HRESULT hr = NOERROR;
    LARGE_INTEGER liMove ;

    ASSERT(m_hFile != INVALID_HANDLE_VALUE);

    // write RecordCount;
    liMove.LowPart = offsetof(PCMHeader, ulRecordCount);
    liMove.HighPart = 0 ;

    hr = Base::Seek(liMove, FILE_BEGIN, NULL);
    if ( FAILED(hr))
        goto Exit;

    hr = WriteWithDelay((PVOID)&ulRecordCount, sizeof(ULONG), NULL);
    if ( FAILED(hr))
        goto Exit;

    // write MaxNodeCount;
    liMove.LowPart = offsetof(PCMHeader, usMaxNodeCount);
    liMove.HighPart = 0 ;

    hr = Base::Seek(liMove, FILE_BEGIN, NULL);
    if ( FAILED(hr))
        goto Exit;

    hr = WriteWithDelay((PVOID)&dwMaxNodeCount, sizeof(ULONG), NULL);
    if ( FAILED(hr))
        goto Exit;

    if ( ! Base::Close()) {
        hr = HRESULT_FROM_WIN32(::FusionpGetLastWin32Error());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;

}

BOOL CPrecompiledManifestWriterStream::IsSinkedStream()
{
    if ((m_fBuffer == FALSE) && (m_hFile != INVALID_HANDLE_VALUE))
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\pcmwriterstream.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    CPrecompiledManifestWriterStream.h

Abstract:
    Like a CFileStream (its base) but also implements Commit over
      associated PCMWriter. This functionality was
      moved out of CFileStream.

Author:

    Xiaoyu Wu (xiaoyuw) June 2000

Revision History:

--*/
#if !defined(_FUSION_SXS_PCMWriterStream_H_INCLUDED_)
#define _FUSION_SXS_PCMWriterStream_H_INCLUDED_
#pragma once

#include "filestream.h"
#include "smartref.h"

class CPrecompiledManifestWriterStream : public CReferenceCountedFileStream
//class CPrecompiledManifestWriterStream : public CFileStreamBase // not delete 
{
private:
    typedef CReferenceCountedFileStream Base;
    //typedef CFileStreamBase Base;

public:
    CPrecompiledManifestWriterStream() : Base(), m_fBuffer(TRUE) { }
    ~CPrecompiledManifestWriterStream() {}

    HRESULT     WriteWithDelay(void const *pv, ULONG cb, ULONG *pcbWritten);

    // NTRAID#NTBUG9-164736-2000/8/17-a-JayK,JayKrell openOrCreate should probably default
    // default to safer CREATE_NEW but I'm preserving existing behavior where
    // it doesn't hurt me.
    BOOL        SetSink(const CBaseStringBuffer &rbuff, DWORD openOrCreate = CREATE_ALWAYS);
    HRESULT     Close(ULONG, DWORD);     //besides close, rewrite MaxNodeCount, RecordCount into the header of the file
    BOOL        IsSinkedStream(void);

protected:
    CByteBuffer         m_buffer;
    BOOL                m_fBuffer;

private:
    CPrecompiledManifestWriterStream(const CPrecompiledManifestWriterStream &);
    void operator =(const CPrecompiledManifestWriterStream &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\pendingassembly.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    pendingassembly.cpp

Abstract:

    Sources for the CPendingAssembly class

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    xiaoyuw     09/2000         replace attributes with assembly identity
--*/

#include "stdinc.h"
#include "pendingassembly.h"

CPendingAssembly::CPendingAssembly() :
    m_SourceAssembly(NULL),
    m_Identity(NULL),
    m_Optional(false),
    m_MetadataSatellite(false)
{
}

CPendingAssembly::~CPendingAssembly()
{
    if (m_Identity != NULL)
    {
        ::SxsDestroyAssemblyIdentity(m_Identity);
        m_Identity = NULL;
    }
}

BOOL
CPendingAssembly::Initialize(
    PASSEMBLY Assembly,
    PCASSEMBLY_IDENTITY Identity,
    bool Optional,
    bool MetadataSatellite
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    INTERNAL_ERROR_CHECK(m_Identity == NULL);

    PARAMETER_CHECK(Identity != NULL);

    IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(0, Identity, &m_Identity));
    m_SourceAssembly = Assembly;
    m_Optional = Optional;
    m_MetadataSatellite = MetadataSatellite;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\pendingassembly.h ===
#if !defined(_FUSION_SXS_PENDINGASSEMBLY_H_INCLUDED_)
#define _FUSION_SXS_PENDINGASSEMBLY_H_INCLUDED_

#pragma once

/*++

Copyright (c) Microsoft Corporation

Module Name:

    pendingassembly.h

Abstract:

    Sources for the CPendingAssembly class

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:
    xiaoyuw     09/2000         replace attributes with assembly identity
--*/

class CPendingAssembly
{
public:
    CPendingAssembly();
    ~CPendingAssembly();

    BOOL Initialize(PASSEMBLY SourceAssembly, PCASSEMBLY_IDENTITY Identity, bool Optional, bool IsMetadataSatellite);
    PASSEMBLY SourceAssembly() const { return m_SourceAssembly; }
    PCASSEMBLY_IDENTITY GetIdentity() const { return m_Identity; }
    bool IsOptional() const { return m_Optional; }
    bool IsMetadataSatellite() const { return m_MetadataSatellite; }
    void DeleteYourself() { delete this; }

    CDequeLinkage m_Linkage;
protected:
    PASSEMBLY m_SourceAssembly;
    PASSEMBLY_IDENTITY m_Identity;
    bool m_Optional;
    bool m_MetadataSatellite;

private:
    CPendingAssembly(const CPendingAssembly &);
    void operator =(const CPendingAssembly &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\policystatement.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "fusionparser.h"
#include "policystatement.h"
#include "sxsid.h"

BOOL
CPolicyStatementRedirect::Initialize(
    const CBaseStringBuffer &rbuffFromVersionRange,
    const CBaseStringBuffer &rbuffToVersion,
    bool &rfValid
    )
{
    FN_PROLOG_WIN32

    PCWSTR pszDash;
    CStringBuffer buffTemp;
    ASSEMBLY_VERSION avFromMin = { 0 };
    ASSEMBLY_VERSION avFromMax = { 0 };
    ASSEMBLY_VERSION avTo = { 0 };
    bool fValid;

    rfValid = false;

    // let's see if we have a singleton or a range...
    pszDash = ::wcschr(rbuffFromVersionRange, L'-');

    if (pszDash == NULL)
    {
        // It must be a singleton.  Parse it.
        IFW32FALSE_EXIT(CFusionParser::ParseVersion(avFromMin, rbuffFromVersionRange, rbuffFromVersionRange.Cch(), fValid));

        if (fValid)
            avFromMax = avFromMin;
    }
    else
    {
        SIZE_T cchFirstSegment = static_cast<SIZE_T>(pszDash - rbuffFromVersionRange);

        IFW32FALSE_EXIT(CFusionParser::ParseVersion(avFromMin, rbuffFromVersionRange, cchFirstSegment, fValid));

        if (fValid)
        {
            IFW32FALSE_EXIT(CFusionParser::ParseVersion(avFromMax, pszDash + 1, rbuffFromVersionRange.Cch() - (cchFirstSegment + 1), fValid));

            if (avFromMin > avFromMax)
                fValid = false;
        }
    }

    if (fValid)
        IFW32FALSE_EXIT(CFusionParser::ParseVersion(avTo, rbuffToVersion, rbuffToVersion.Cch(), fValid));

    if (fValid)
    {
        // Everything parsed OK.  We keep the binary/numeric form of the from range so that we can do
        // fast comparisons, but we keep the string of the to version because assembly identity attributes
        // are stored as strings.

        IFW32FALSE_EXIT(m_NewVersion.Win32Assign(rbuffToVersion));

        m_avFromMin = avFromMin;
        m_avFromMax = avFromMax;

        rfValid = true;
    }

#if DBG
    if (rfValid)
    {
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_BINDING,
            "SXS: %s New redirection found: %d.%d.%d.%d-%d.%d.%d.%d to %ls\n",
            __FUNCTION__,
            m_avFromMin.Major, m_avFromMin.Minor, m_avFromMin.Revision, m_avFromMin.Build,
            m_avFromMax.Major, m_avFromMax.Minor, m_avFromMax.Revision, m_avFromMax.Build,
            static_cast<PCWSTR>(m_NewVersion));
    }
    else
    {
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_BINDING,
            "SXS: %s Rejecting redirection strings '%ls' -> '%ls'\n",
            static_cast<PCWSTR>(rbuffFromVersionRange),
            static_cast<PCWSTR>(rbuffToVersion));
    }
#endif

    FN_EPILOG
}

BOOL
CPolicyStatementRedirect::TryMap(
    const ASSEMBLY_VERSION &rav,
    CBaseStringBuffer &TargetVersion,
    bool &rfMapped
    )
{
    FN_PROLOG_WIN32

    rfMapped = false;

    if ((rav >= m_avFromMin) &&
        (rav <= m_avFromMax))
    {
        IFW32FALSE_EXIT(TargetVersion.Win32Assign(m_NewVersion));
        rfMapped = true;
    }

    FN_EPILOG
}

BOOL
CPolicyStatementRedirect::CheckForOverlap(
    const CPolicyStatementRedirect &rRedirect,
    bool &rfOverlaps
    )
{
    FN_PROLOG_WIN32

    rfOverlaps = false;

    // we can assume that the other redirect is well formed (min <= max)

    if (((rRedirect.m_avFromMax >= m_avFromMin) &&
         (rRedirect.m_avFromMax <= m_avFromMax)) ||
        ((rRedirect.m_avFromMin <= m_avFromMax) &&
         (rRedirect.m_avFromMin >= m_avFromMin)))
    {
        rfOverlaps = true;
    }

    FN_EPILOG
}

//
//  Implementation of CPolicyStatement
//

BOOL
CPolicyStatement::Initialize()
{
    return TRUE;
}

BOOL
CPolicyStatement::AddRedirect(
    const CBaseStringBuffer &rbuffFromVersion,
    const CBaseStringBuffer &rbuffToVersion,
    bool &rfValid
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CPolicyStatementRedirect *Redirect = NULL;
    CDequeIterator<CPolicyStatementRedirect, FIELD_OFFSET(CPolicyStatementRedirect, m_leLinks)> iter;
    bool fOverlaps;
    bool fValid = false;

    rfValid = false;

    // NTRAID#NTBUG9 - 591010 - 2002/03/30 - mgrier - switch to using smart pointer
    IFALLOCFAILED_EXIT(Redirect = new CPolicyStatementRedirect);

    IFW32FALSE_EXIT(Redirect->Initialize(rbuffFromVersion, rbuffToVersion, fValid));

    if (fValid)
    {
        iter.Rebind(&m_Redirects);

        for (iter.Reset(); iter.More(); iter.Next())
        {
            IFW32FALSE_EXIT(iter->CheckForOverlap(*Redirect, fOverlaps));

            if (fOverlaps)
            {
                fValid = false;
                break;
            }
        }

        iter.Unbind();
    }

    if (fValid)
    {
        // Looks good; add it!

        m_Redirects.AddToTail(Redirect);
        Redirect = NULL;

        rfValid = true;
    }

    // NTRAID#NTBUG9 - 591010 - 2002/03/30 - mgrier - Once Redirect is a smart pointer, switch
    //      the function epilog to FN_EPILOG

    fSuccess = TRUE;
Exit:
    if (Redirect != NULL)
        FUSION_DELETE_SINGLETON(Redirect);

    return fSuccess;
}

BOOL
CPolicyStatement::ApplyPolicy(
    PASSEMBLY_IDENTITY AssemblyIdentity,
    bool &rfPolicyApplied
    )
{
    FN_PROLOG_WIN32
    PCWSTR Version = NULL;
    SIZE_T VersionCch = 0;
    CSmallStringBuffer VersionBuffer;
    SIZE_T cchWritten = 0;
    CDequeIterator<CPolicyStatementRedirect, FIELD_OFFSET(CPolicyStatementRedirect, m_leLinks)> iter;
    ASSEMBLY_VERSION av;
    bool fSyntaxValid;
    bool fMapped = false;
#if DBG    
    PCWSTR Name = NULL;
    SIZE_T NameCch = 0;
#endif

    rfPolicyApplied = false;

    PARAMETER_CHECK(AssemblyIdentity != NULL);

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            0,
            AssemblyIdentity,
            &s_IdentityAttribute_version,
            &Version,
            &VersionCch));

#if DBG
    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            0,
            AssemblyIdentity,
            &s_IdentityAttribute_name,
            &Name,
            &NameCch));
#endif

    IFW32FALSE_EXIT(CFusionParser::ParseVersion(av, Version, VersionCch, fSyntaxValid));

    // An invalid version number should have been caught earlier.
    INTERNAL_ERROR_CHECK(fSyntaxValid);

    iter.Rebind(&m_Redirects);

    for (iter.Reset(); iter.More(); iter.Next())
    {
        IFW32FALSE_EXIT(iter->TryMap(av, VersionBuffer, fMapped));

        if (fMapped)
        {
            FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_BINDING, 
                "SXS: %s Intermediate redirection : %d.%d.%d.%d to %ls\n",
                __FUNCTION__,
                av.Major, av.Minor, av.Revision, av.Build,
                static_cast<PCWSTR>(VersionBuffer));
            break;
        }
    }

    if (fMapped)
    {
#if DBG
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_BINDING,
            "SXS: %s Final version redirection for %.*ls was from '%.*ls' to '%ls'\n",
            __FUNCTION__,
            NameCch, Name,
            VersionCch, Version,
            static_cast<PCWSTR>(VersionBuffer));
#endif        
        IFW32FALSE_EXIT(
            ::SxspSetAssemblyIdentityAttributeValue(
                SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                AssemblyIdentity,
                &s_IdentityAttribute_version,
                VersionBuffer,
                VersionBuffer.Cch()));

        rfPolicyApplied = true;
    }
#if DBG    
    else
    {
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_BINDING,
            "SXS: %s No redirections for '%.*ls' found\n",
            __FUNCTION__,
            NameCch, Name);
    }
#endif

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\protectionui.h ===
#pragma once
#include "fusionbuffer.h"

class CAssemblyRecoveryInfo;

class CSXSMediaPromptDialog
{
public:
    enum DialogResults
    {
        DialogCancelled = 1,
        DialogMediaFound = 2,
        DialogUnknown = 3
    };

private:
    const CCodebaseInformation* m_CodebaseInfo;

    bool m_fIsCDROM;
    CStringBuffer m_buffCodebaseInfo;
    HWND m_hOurWnd;
    PVOID m_pvDeviceChange;
    UINT m_uiAutoRunMsg;
    DWORD m_DeviceChangeMask;
    DWORD m_DeviceChangeFlags;

    BOOL DisplayMessage(HWND hw, UINT uContentText, UINT uDialogFlags, int &riResult);

    static
    INT_PTR
    CALLBACK
    OurDialogProc(
        HWND hDlg,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        );

public:

    CSXSMediaPromptDialog();
    ~CSXSMediaPromptDialog();

    BOOL Initialize(
        const CCodebaseInformation* CodebaseInfo
        );

    BOOL ShowSelf(DialogResults &rResultsOut);

private:
    CSXSMediaPromptDialog(const CSXSMediaPromptDialog &);
    void operator =(const CSXSMediaPromptDialog &);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\preprocessor.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    preprocessor.h

Abstract:

    Standard C/C++ Preprocessor magic.

Author:

    Jay Krell (a-JayK, JayKrell) December 2000

Environment:


Revision History:

--*/
#pragma once

#define PASTE_(x,y) x##y
#define PASTE(x,y)  PASTE_(x,y)

#define STRINGIZE_(x) # x
#define STRINGIZE(x) STRINGIZE_(x)
#define STRINGIZEW(x) PASTE(L, STRINGIZE_(x))

/* Visual C++ extension, rarely needed, useful in preprocessing .rgs files */
#define CHARIZE_(x) #@ x
#define CHARIZE(x) CHARIZE_(x)
#define CHARIZEW(x) PASTE(L, CHARIZE_(x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\policystatement.h ===
#if !defined(_FUSION_DLL_WHISTLER_POLICYSTATEMENT_H_INCLUDED_)
#define _FUSION_DLL_WHISTLER_POLICYSTATEMENT_H_INCLUDED_

#pragma once

#include "fusionbuffer.h"
#include "fusiondequelinkage.h"
#include "fusiondeque.h"
#include <sxsapi.h>

class CPolicyStatementRedirect
{
public:
    inline CPolicyStatementRedirect() { }
    inline ~CPolicyStatementRedirect() { }


    BOOL Initialize(
        const CBaseStringBuffer &rbuffFromVersionRange,
        const CBaseStringBuffer &rbuffToVersion,
        bool &rfValid
        );

    BOOL TryMap(
        const ASSEMBLY_VERSION &rav,
        CBaseStringBuffer &VersionBuffer,
        bool &rfMapped
        );

    BOOL CheckForOverlap(
        const CPolicyStatementRedirect &rRedirect,
        bool &rfOverlaps
        );

    CDequeLinkage m_leLinks;
    ASSEMBLY_VERSION m_avFromMin;
    ASSEMBLY_VERSION m_avFromMax;
    CMediumStringBuffer m_NewVersion;

private:
    CPolicyStatementRedirect(const CPolicyStatementRedirect &r);
    void operator =(const CPolicyStatementRedirect &r);
};

class CPolicyStatement
{
public:
    inline CPolicyStatement() : m_fApplyPublisherPolicy(true) { }
    inline ~CPolicyStatement() { m_Redirects.Clear<CPolicyStatement>(this, &CPolicyStatement::ClearDequeEntry); }

    BOOL Initialize();

    BOOL AddRedirect(
        const CBaseStringBuffer &rbuffFromVersion,
        const CBaseStringBuffer &rbuffToVersion,
        bool &rfValid
        );

    BOOL ApplyPolicy(
        PASSEMBLY_IDENTITY AssemblyIdentity,
        bool &rfPolicyApplied
        );

    VOID ClearDequeEntry(CPolicyStatementRedirect *p) const { FUSION_DELETE_SINGLETON(p); }    
    CDeque<CPolicyStatementRedirect, FIELD_OFFSET(CPolicyStatementRedirect, m_leLinks)> m_Redirects;
    bool m_fApplyPublisherPolicy;

private:
    
    CPolicyStatement(const CPolicyStatement &r);
    void operator =(const CPolicyStatement &r);
};

#endif // !defined(_FUSION_DLL_WHISTLER_POLICYSTATEMENT_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\probedassemblyinformation.h ===
#if !defined(_FUSION_SXS_PROBEDASSEMBLYINFORMATION_H_INCLUDED_)
#define _FUSION_SXS_PROBEDASSEMBLYINFORMATION_H_INCLUDED_

#pragma once

#include "sxsp.h"
#include "assemblyreference.h"
#include "impersonationdata.h"
#include <sxsapi.h>

class CProbedAssemblyInformation : protected CAssemblyReference
{
    typedef CAssemblyReference Base;

protected:
public:
    CProbedAssemblyInformation() { Construct(); }
    ~CProbedAssemblyInformation() { }

    void Reinitialize() { Destroy(); Construct(); }

    void Destroy()
    {
        m_ManifestPathBuffer.Clear();
        m_PolicyPathBuffer.Clear();
        m_PolicyStream.Release();
        m_ManifestStream.Release();
        Base::Destroy();
    }

    void Construct()
    {
        FILETIME ZeroFileTime = { 0 };

        Base::Construct();

        m_ManifestLastWriteTime = ZeroFileTime;
        m_ManifestFlags = ASSEMBLY_MANIFEST_FILETYPE_AUTO_DETECT;
        m_ManifestPathType = ACTIVATION_CONTEXT_PATH_TYPE_NONE;

        m_PolicyPathType = ACTIVATION_CONTEXT_PATH_TYPE_NONE;
        m_PolicyLastWriteTime = ZeroFileTime;
        m_PolicySource = SXS_POLICY_UNSPECIFIED;

        m_SystemPolicyGuid = GUID_NULL;
        m_PolicyFlags = 0;
        m_pActCtxGenCtx = NULL;
    }

    BOOL Initialize(PCACTCTXGENCTX pGenCtx);
    BOOL Initialize(const CAssemblyReference &r, PCACTCTXGENCTX pGenCtx = NULL);
    BOOL Initialize(const CProbedAssemblyInformation &r);
    BOOL InitializeTakeValue(CProbedAssemblyInformation &r);

    using CAssemblyReference::GetAssemblyIdentity;
    using CAssemblyReference::GetAssemblyName;
    using CAssemblyReference::GetPublicKeyToken;
    using CAssemblyReference::SetAssemblyIdentity;
    using CAssemblyReference::SetLanguage;
    using CAssemblyReference::SetProcessorArchitecture;
    using CAssemblyReference::SetPublicKeyToken;
    using CAssemblyReference::ClearLanguage;

    enum LanguageProbeType
    {
        eExplicitBind,
        eLanguageNeutral,
        eSpecificLanguage,
        eGenericLanguage,
        eSpecificSystemLanguage,
        eGenericSystemLanguage
    };

    enum ProbeAssemblyFlags
    {
        ProbeAssembly_SkipPrivateAssemblies = 0x00000001,
    };

    BOOL ProbeAssembly(DWORD dwFlags, PACTCTXGENCTX pActCtxGenCtx, LanguageProbeType lpt, bool &rfFound);

    BOOL Assign(const CProbedAssemblyInformation &r);
    BOOL TakeValue(CProbedAssemblyInformation &r);

    BOOL SetProbedIdentity(PCASSEMBLY_IDENTITY AssemblyIdentity);

    // manifest
    BOOL SetManifestPath(ULONG ulPathType, const CBaseStringBuffer &rbuff);
    BOOL SetManifestPath(ULONG ulPathType, PCWSTR Path, SIZE_T PathCch);
    BOOL GetManifestPath(PCWSTR *Path, SIZE_T *PathCch) const;
    const CBaseStringBuffer &GetManifestPath() const { return m_ManifestPathBuffer; }
    ULONG GetManifestPathType() const { return m_ManifestPathType; }
    ULONG GetManifestFlags() const;
    BOOL SetManifestFlags(ULONG Flags);
    BOOL SetManifestLastWriteTime(const FILETIME &LastWriteTime);
    const FILETIME &GetManifestLastWriteTime() const;
    BOOL SetManifestLastWriteTime(const CImpersonationData &ImpersonationData, BOOL fDuringBindingAndProbingPrivateManifest = FALSE);
    BOOL SetManifestStream(IStream* Stream);
    IStream* GetManifestStream() const;

    BOOL ProbeManifestExistence(
        const CImpersonationData &ImpersonationData, 
        BOOL fIsPrivateAssembly, 
        bool &rfManifestExists, 
        bool &rfPrivateAssemblyManifestInResource) const;

    // APPLICATION policy, not component policy...
    ULONG GetPolicyFlags() const;
    BOOL SetPolicyFlags(ULONG Flags);
    BOOL GetPolicyPath(PCWSTR &rPath, SIZE_T &rPathCch) const;
    const FILETIME &GetPolicyLastWriteTime() const;
    BOOL SetPolicyPath(ULONG PathType, PCWSTR Path, SIZE_T PathCch);
    const CBaseStringBuffer &GetPolicyPath() const { return m_PolicyPathBuffer; }
    ULONG GetPolicyPathType() const { return m_PolicyPathType; }
    BOOL SetPolicyStream(IStream* Stream);

    BOOL IsPrivateAssembly() const;
    SXS_POLICY_SOURCE GetPolicySource() const;
    void SetPolicySource(SXS_POLICY_SOURCE ps);
    BOOL ApplyPolicyDestination(const CAssemblyReference &r, SXS_POLICY_SOURCE s, const GUID &g);

protected:
    BOOL LookForAppPolicy(PACTCTXGENCTX pActCtxGenCtx, bool &rfApplied, bool &rfAppRunningInSafeMode, bool &rfComponentRunningInSafeMode);
    BOOL LookForSxsWin32Policy(PACTCTXGENCTX   pActCtxGenCtx, bool fAppPolicyApplied, bool &rfPolicyApplied);   
    BOOL LookForNDPWin32Policy(PACTCTXGENCTX pActCtxGenCtx, bool &rfApplied);

    BOOL ProbeLanguageDir(CBaseStringBuffer &rbuffApplicationDirectory, const CBaseStringBuffer &rbuffLanguage, bool &rfFound);

    // manifest
    ULONG m_ManifestPathType;
    CStringBuffer m_ManifestPathBuffer;
    FILETIME m_ManifestLastWriteTime;
    CSmartRef<IStream> m_ManifestStream;
    ULONG  m_ManifestFlags;

    // policy
    ULONG m_PolicyPathType;
    CSmallStringBuffer m_PolicyPathBuffer; // only used when policy is present
    FILETIME m_PolicyLastWriteTime;
    SXS_POLICY_SOURCE m_PolicySource;
    GUID    m_SystemPolicyGuid;
    CSmartRef<IStream> m_PolicyStream;
    ULONG  m_PolicyFlags;
    PCACTCTXGENCTX m_pActCtxGenCtx;

private: // deliberately not implemented
    CProbedAssemblyInformation(const CProbedAssemblyInformation&);
    void operator=(const CProbedAssemblyInformation&);
};

inline BOOL CProbedAssemblyInformation::GetManifestPath(PCWSTR *Path, SIZE_T *PathCch) const
{
    if (Path != NULL)
        *Path = m_ManifestPathBuffer;

    if (PathCch != NULL)
        *PathCch = m_ManifestPathBuffer.Cch();

    return TRUE;
}

inline BOOL CProbedAssemblyInformation::SetManifestLastWriteTime(const FILETIME &LastWriteTime)
{
    m_ManifestLastWriteTime = LastWriteTime;
    return TRUE;
}

inline const FILETIME& CProbedAssemblyInformation::GetManifestLastWriteTime() const
{
    return m_ManifestLastWriteTime;
}

inline BOOL
CProbedAssemblyInformation::GetPolicyPath(
    PCWSTR &rPath,
    SIZE_T &rPathCch
    ) const
{
    rPath = static_cast<PCWSTR>(m_PolicyPathBuffer);
    rPathCch = m_PolicyPathBuffer.Cch();

    return TRUE;
}

inline ULONG CProbedAssemblyInformation::GetPolicyFlags() const
{
    return m_PolicyFlags;
}

inline BOOL CProbedAssemblyInformation::SetPolicyFlags(ULONG Flags)
{
    m_PolicyFlags = Flags;
    return TRUE;
}

inline const FILETIME& CProbedAssemblyInformation::GetPolicyLastWriteTime() const
{
    return m_PolicyLastWriteTime;
}

inline ULONG CProbedAssemblyInformation::GetManifestFlags() const
{
    return m_ManifestFlags;
}

inline BOOL CProbedAssemblyInformation::SetManifestFlags(ULONG Flags)
{
    m_ManifestFlags = Flags;
    return TRUE;
}

inline BOOL CProbedAssemblyInformation::SetManifestStream(IStream* Stream)
{
    m_ManifestStream = Stream;
    return TRUE;
}

inline BOOL CProbedAssemblyInformation::SetPolicyStream(IStream* Stream)
{
    m_PolicyStream = Stream;
    return TRUE;
}

inline IStream* CProbedAssemblyInformation::GetManifestStream() const
{
    return m_ManifestStream;
}

inline BOOL CProbedAssemblyInformation::IsPrivateAssembly() const
{
    return ((m_ManifestFlags & ASSEMBLY_PRIVATE_MANIFEST) ? TRUE : FALSE);
}

inline SXS_POLICY_SOURCE CProbedAssemblyInformation::GetPolicySource() const
{
    return m_PolicySource;
}

inline void CProbedAssemblyInformation::SetPolicySource(SXS_POLICY_SOURCE ps)
{
    m_PolicySource = ps;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\protectionui.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "dbt.h"
#include "devguid.h"
#include "dialogs.h"
#include "cassemblyrecoveryinfo.h"
#include "protectionui.h"
#include "recover.h"
#include "sxsexceptionhandling.h"

//
// FAKERY
//
extern HINSTANCE g_hInstance;
extern HANDLE g_hSxsLoginEvent;
HDESK   g_hDesktop = NULL;

BOOL
SxspSpinUntilValidDesktop()
{
    FN_PROLOG_WIN32

    //
    // NTRAID#NTBUG9-219455-2000/12/13-MGrier Postponed to Blackcomb; the
    //   current code does the same thing that WFP is doing; it's just that
    //   we should really have them pass us the desktop.
    //
    // We should be relying on what WFP has already
    // found to be the 'proper' input desktop. Doing so, however requires a
    // change to the interface between SXS and SFC to pass along a pointer to
    // the WFP desktop handle.  Not a bad thing, just .. not implemented yet.
    //
    while (g_hDesktop == NULL)
    {
        DWORD dwResult = ::WaitForSingleObject(g_hSxsLoginEvent, INFINITE);

        if (dwResult == WAIT_OBJECT_0)
            IFW32NULL_ORIGINATE_AND_EXIT(g_hDesktop = ::OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED));
        else if (dwResult == WAIT_FAILED)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(WaitForSingleObject, ::FusionpGetLastWin32Error());
    }

    FN_EPILOG
}

CSXSMediaPromptDialog::CSXSMediaPromptDialog()
    : m_hOurWnd((HWND)INVALID_HANDLE_VALUE),
      m_pvDeviceChange(NULL),
      m_uiAutoRunMsg(0),
      m_DeviceChangeMask(0),
      m_DeviceChangeFlags(0),
      m_fIsCDROM(false),
      m_CodebaseInfo(NULL)
{
}

CSXSMediaPromptDialog::~CSXSMediaPromptDialog()
{
}

BOOL
CSXSMediaPromptDialog::Initialize(
    const CCodebaseInformation* CodebaseInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(CodebaseInfo != NULL);

    SxsWFPResolveCodebase CodebaseType;

    IFW32FALSE_EXIT(CodebaseInfo->Win32GetType(CodebaseType));

    PARAMETER_CHECK(
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_FILE) ||
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_WINSOURCE) ||
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_CDROM));

    m_CodebaseInfo = CodebaseInfo;
    switch (CodebaseType)
    {
    case CODEBASE_RESOLVED_URLHEAD_CDROM:
        m_fIsCDROM = true;
        break;

    case CODEBASE_RESOLVED_URLHEAD_WINSOURCE:
        {
            CFusionRegKey hkSetupInfo;
            DWORD dwWasFromCDRom;

            IFREGFAILED_ORIGINATE_AND_EXIT(
                ::RegOpenKeyExW(
			        HKEY_LOCAL_MACHINE,
			        WINSXS_INSTALL_SOURCE_BASEDIR,
			        0,
			        KEY_READ | FUSIONP_KEY_WOW64_64KEY,
			        &hkSetupInfo));

            // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - If the key isn't there, it's ok to assume not
            //      from a CDROM but if it was out of resources etc. this should propagate an error.
            if (!::FusionpRegQueryDwordValueEx(
                    0,
                    hkSetupInfo,
                    WINSXS_INSTALL_SOURCE_IS_CDROM,
                    &dwWasFromCDRom))
            {
                dwWasFromCDRom = 0;
            }

            m_fIsCDROM = (dwWasFromCDRom != 0);
            break;
        }

    case CODEBASE_RESOLVED_URLHEAD_FILE:
        {
            CSmallStringBuffer buffVolumePathName;

            IFW32FALSE_EXIT(
                ::SxspGetVolumePathName(
                    0,
                    CodebaseInfo->GetCodebase(),
                    buffVolumePathName));

            if (::GetDriveTypeW(buffVolumePathName) == DRIVE_CDROM)
            {
                m_fIsCDROM = true;
            }

            break;
        }
    }

    FN_EPILOG
}

BOOL
CSXSMediaPromptDialog::DisplayMessage(
    HWND hDlg,
    UINT uContentText,
    UINT uDialogFlags,
    int &riResult
    )
{
    FN_PROLOG_WIN32

    const SIZE_T BufferSize = (MAX_PATH * 2);

    CTinyStringBuffer wcTitle;
    CTinyStringBuffer wcContent;
    int iResult = 0;


    if (wcContent.Win32ResizeBuffer(BufferSize + 1, eDoNotPreserveBufferContents))
    {
        CStringBufferAccessor Accessor(&wcContent);
        IFW32ZERO_ORIGINATE_AND_EXIT(::LoadStringW(g_hInstance, uContentText, Accessor, BufferSize));
    }
    if (wcTitle.Win32ResizeBuffer(BufferSize, eDoNotPreserveBufferContents))
    {
        CStringBufferAccessor Accessor(&wcTitle);
        IFW32ZERO_ORIGINATE_AND_EXIT(::LoadStringW(g_hInstance, IDS_TITLE, Accessor, BufferSize));
    }
    IFW32ZERO_ORIGINATE_AND_EXIT(iResult = ::MessageBoxW(hDlg, wcContent, wcTitle, uDialogFlags));

    riResult = iResult;

    FN_EPILOG
}

BOOL
CSXSMediaPromptDialog::ShowSelf(
    CSXSMediaPromptDialog::DialogResults &rResult
    )
{
    FN_PROLOG_WIN32

    INT_PTR i;

    IFW32FALSE_EXIT(::SxspSpinUntilValidDesktop());
    IFW32FALSE_ORIGINATE_AND_EXIT(::SetThreadDesktop(g_hDesktop));

    i = ::DialogBoxParamW(
            g_hInstance,
            MAKEINTRESOURCEW(
                m_fIsCDROM ? 
                    IDD_SFC_CD_PROMPT :
                    IDD_SFC_NETWORK_PROMPT),
            NULL,
            &CSXSMediaPromptDialog::OurDialogProc,
            (LPARAM)this);

    if (i == -1)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(DialogBoxParamW, ::FusionpGetLastWin32Error());

    rResult = static_cast<DialogResults>(i);

    FN_EPILOG
}


BOOL
SxspFindInstallWindowsSourcePath(
    OUT CBaseStringBuffer &rbuffTempStringBuffer
    )
{
    FN_PROLOG_WIN32

    CFusionRegKey rhkInstallSource;
    
    rbuffTempStringBuffer.Clear();

    IFREGFAILED_ORIGINATE_AND_EXIT(
        ::RegOpenKeyExW(
            HKEY_LOCAL_MACHINE, 
            WINSXS_INSTALL_SOURCE_BASEDIR,
            0,
            KEY_READ | FUSIONP_KEY_WOW64_64KEY,
            &rhkInstallSource));

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
            rhkInstallSource,
            WINSXS_INSTALL_SOURCEPATH_REGKEY,
            rbuffTempStringBuffer));

    //
    // Now let's be really cheesy and find the fourth slash (\\foo\bar\), and
    // clip everything after that.
    //
    PCWSTR cursor = rbuffTempStringBuffer;
    ULONG ulSlashCount = 0;
    while ( *cursor && ulSlashCount < 4 )
    {
        // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Should handle both slashes.  I think we have
        //          a macro for this.
        if (*cursor == L'\\')
            ulSlashCount++;

        cursor++;
    }

    //
    // If we got 3 or less, then it's \\foo\bar or \\foo, which should be
    // illegal.  Otherwise, clip everything off past this point.
    //
    if (ulSlashCount > 3)
    {
        rbuffTempStringBuffer.Left(cursor - rbuffTempStringBuffer);
        IFW32FALSE_EXIT(rbuffTempStringBuffer.Win32RemoveTrailingPathSeparators());
    }

    FN_EPILOG
}

INT_PTR
CALLBACK
CSXSMediaPromptDialog::OurDialogProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    FN_TRACE();
    INT_PTR iResult = 0;
    int iMessageBoxResult = 0;

#define WM_TRYAGAIN (WM_USER + 1)

    static CSXSMediaPromptDialog    *pThis = NULL;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pThis = reinterpret_cast<CSXSMediaPromptDialog *>(lParam);

            FLASHWINFO winfo;

            // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Shouldn't these be INTERNAL_ERROR_CHECKs?
            ASSERT(pThis != NULL);
            ASSERT(pThis->m_hOurWnd == INVALID_HANDLE_VALUE);
            pThis->m_hOurWnd = hDlg;

            //
            // Center the window, bring it forward
            //
            {
                RECT rcWindow;
                LONG x, y, w, h;

                // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                ::GetWindowRect(hDlg, &rcWindow);  // error check?

                w = rcWindow.right - rcWindow.left + 1;
                h = rcWindow.bottom - rcWindow.top + 1;
                x = (::GetSystemMetrics(SM_CXSCREEN) - w) / 2;  // error check?
                y = (::GetSystemMetrics(SM_CYSCREEN) - h) / 2;  // error check?

                // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                ::MoveWindow(hDlg, x, y, w, h, FALSE);  // error check?

                winfo.cbSize = sizeof(winfo);
                winfo.hwnd = hDlg;
                winfo.dwFlags = FLASHW_ALL;
                winfo.uCount = 3;
                winfo.dwTimeout = 0;
                // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                ::SetForegroundWindow(hDlg); // error check?
                // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                ::FlashWindowEx(&winfo);     // error check?
            }

            //
            // Create the device-change notification
            //
            if (pThis->m_pvDeviceChange == NULL)
            {
                DEV_BROADCAST_DEVICEINTERFACE_W FilterData = { 0 };

                FilterData.dbcc_size       = sizeof(FilterData);
                FilterData.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
                FilterData.dbcc_classguid  = GUID_DEVCLASS_CDROM;

                IFW32NULL_ORIGINATE_AND_EXIT(
                    pThis->m_pvDeviceChange = ::RegisterDeviceNotificationW(
                        hDlg,
                        &FilterData,
                        DEVICE_NOTIFY_WINDOW_HANDLE));
            }

            //
            // Turn off autorun
            //
            IFW32ZERO_ORIGINATE_AND_EXIT(pThis->m_uiAutoRunMsg = ::RegisterWindowMessageW(L"QueryCancelAutoPlay"));

            //
            // Fidget with the text in the popup dialog now
            //
            {
                CSmallStringBuffer sbFormatter;
                CSmallStringBuffer buffFormattedText;
                CStringBufferAccessor acc;

                //
                // It is ok if these memory allocations fail, the ui will degrade.
                // As well, that's a reason to leave the buffers "small" and not "tiny".
                // ?
                //
                sbFormatter.Win32ResizeBuffer(512, eDoNotPreserveBufferContents);
                buffFormattedText.Win32ResizeBuffer(512, eDoNotPreserveBufferContents);

                //
                // Set the "Insert your .... now"
                //
                sbFormatter.Clear();
                acc.Attach(&sbFormatter);
                // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                ::GetDlgItemTextW( // error check?
                    hDlg,
                    IDC_MEDIA_NAME,
                    acc,
                    static_cast<DWORD>(sbFormatter.GetBufferCch()));
                acc.Detach();

                if (pThis->m_CodebaseInfo->GetPromptText().Cch() != 0)
                {
                    IFW32FALSE_EXIT(buffFormattedText.Win32Format(
                        sbFormatter,
                        static_cast<PCWSTR>(pThis->m_CodebaseInfo->GetPromptText())));
                    // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                    ::SetDlgItemTextW(hDlg, IDC_MEDIA_NAME, static_cast<PCWSTR>(buffFormattedText)); // error check?
                }
                else
                {
#if DBG
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP,
                        "SXS: %s - setting IDC_MEDIA_NAME to empty\n", __FUNCTION__);
#endif
                    // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                    ::SetDlgItemTextW(hDlg, IDC_MEDIA_NAME, L""); // error check?
                }

                //
                // Now, depending on what kind of box this is..
                //
                if (!pThis->m_fIsCDROM)
                {
                    CSmallStringBuffer buffTempStringBuffer;
                    SxsWFPResolveCodebase CodebaseType;
                    
                    sbFormatter.Clear();
                    acc.Attach(&sbFormatter);

                    // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                    ::GetDlgItemTextW( // error check?
                        hDlg,
                        IDC_NET_NAME,
                        acc,
                        static_cast<DWORD>(sbFormatter.GetBufferCch()));

                    acc.Detach();

                    IFW32FALSE_EXIT(pThis->m_CodebaseInfo->Win32GetType(CodebaseType));

                    //
                    // If this is the Windows install media, display something
                    // pleasant to the user - \\server\share only!
                    //
                    if (CodebaseType == CODEBASE_RESOLVED_URLHEAD_WINSOURCE)
                    {
                        IFW32FALSE_EXIT(::SxspFindInstallWindowsSourcePath(buffTempStringBuffer));
                    }
                    else
                    {

                        IFW32FALSE_EXIT(buffTempStringBuffer.Win32Assign(pThis->m_CodebaseInfo->GetCodebase()));
                    }

                    if (buffTempStringBuffer.Cch() != 0)
                    {
                        IFW32FALSE_EXIT(buffFormattedText.Win32Format(sbFormatter, static_cast<PCWSTR>(buffTempStringBuffer)));
                        IFW32FALSE_EXIT(::SetDlgItemTextW(hDlg, IDC_NET_NAME, buffFormattedText));
                    }
                    else
                    {
#if DBG
                        ::FusionpDbgPrintEx(
                            FUSION_DBG_LEVEL_WFP,
                            "SXS: %s - setting IDC_NET_NAME to empty\n", __FUNCTION__);
#endif
                        IFW32FALSE_EXIT(::SetDlgItemTextW(hDlg, IDC_NET_NAME, L""));
                    }
                }
                else
                {
                    //
                    // TODO (jonwis) : This is a CD-rom based install, so we should do
                    // something sane about prompting for the windows CD.
                    //
                }



                //
                // Now get the prompt from the resources.. we only have one, really.
                //
                sbFormatter.Clear();
                acc.Attach(&sbFormatter);

                // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                ::LoadStringW(  // error check?
                    g_hInstance,
                    IDS_RESTORE_TEXT,
                    acc.GetBufferPtr(),
                    acc.GetBufferCchAsDWORD());

                acc.Detach();

                // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                ::SetDlgItemTextW(hDlg, IDC_PROMPT_TEXT, sbFormatter); // error check?
            }
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_RETRY:
            pThis->m_DeviceChangeMask = static_cast<DWORD>(-1);
            pThis->m_DeviceChangeFlags = DBTF_MEDIA;
            IFW32FALSE_ORIGINATE_AND_EXIT(::PostMessageW(hDlg, WM_TRYAGAIN, 0, 0));
            break;

        case IDC_INFO:
            IFW32FALSE_EXIT(
                pThis->DisplayMessage(
                    NULL,
                    pThis->m_fIsCDROM ? IDS_MORE_INFORMATION_CD : IDS_MORE_INFORMATION_NET,
                    MB_ICONINFORMATION | MB_SERVICE_NOTIFICATION | MB_OK,
                    iMessageBoxResult));
			
            break;

        case IDCANCEL:
            IFW32FALSE_EXIT(
                pThis->DisplayMessage(
                    hDlg,
                    IDS_CANCEL_CONFIRM,
                    MB_APPLMODAL | MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING,
                    iMessageBoxResult));

            if (iMessageBoxResult == IDYES)
            {
                // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                ::UnregisterDeviceNotification(pThis->m_pvDeviceChange); // error check?
                // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                ::EndDialog(hDlg, CSXSMediaPromptDialog::DialogCancelled); // error check?
            }

            break;
        }

        break;  // WM_COMMAND

    case WM_DEVICECHANGE:

        if (wParam == DBT_DEVICEARRIVAL)
        {
            DEV_BROADCAST_VOLUME *dbv = reinterpret_cast<DEV_BROADCAST_VOLUME*>(lParam);
            ASSERT(dbv != NULL);

            if (dbv->dbcv_devicetype == DBT_DEVTYP_VOLUME)
            {
                pThis->m_DeviceChangeMask = dbv->dbcv_unitmask;
                pThis->m_DeviceChangeFlags = dbv->dbcv_flags;
                // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
                ::PostMessageW(hDlg, WM_TRYAGAIN, 0, 0); // error check?
            }
        }

        break;

    case WM_TRYAGAIN:
        // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
        ::UnregisterDeviceNotification(pThis->m_pvDeviceChange); // error check?
        // NTRAID#NTBUG9 - 591839 - 2002/04/01 - mgrier - Missing error check
        ::EndDialog(hDlg, CSXSMediaPromptDialog::DialogMediaFound); // error check?
        break;
    }

Exit:

    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\purevirt.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    purevirt.cpp

Abstract:

    Implementation of _purecall to eliminate msvcrt.dll dependency
        in sxs.dll / csrss.exe.

Author:

    Jay Krell (a-JayK, JayKrell) July 2000

Revision History:

--*/
/*
see \nt\base\crts\crtw32\misc\purevirt.c
    \nt\base\crts\crtw32\hack\stubs.c
*/

#include "stdinc.h"
#include "debmacro.h"
#include "fusiontrace.h"

/***
*void _purecall(void) -
*
*Purpose:
*
*Entry:
*	No arguments
*
*Exit:
*	Never returns
*
*Exceptions:
*
*******************************************************************************/

extern "C" int __cdecl _purecall(
	void
	)
{
    ::RaiseException((DWORD) STATUS_NOT_IMPLEMENTED, EXCEPTION_NONCONTINUABLE, 0, NULL);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\probedassemblyinformation.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    probedassemblyinformation.cpp

Abstract:

    Class that contains all the relevant information about an assembly
    that has been found in the assembly store.

Author:

    Michael J. Grier (MGrier) 11-May-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "probedassemblyinformation.h"
#include "fusionparser.h"

#define POLICY_FILE_EXTENSION L".policy"

bool IsNtDosPath(PCWSTR s)
{
    return (s[0] == L'\\' && s[1] == L'?' && s[2] == L'?' && s[3] == '\\');
}

//
// before calls to this function, the caller has checked that the ext of this file is .dll or .exe
//
BOOL IsBinaryFileContainManifestInResource(PCWSTR ManifestPath, bool & rfManifestInResource)
{
    FN_PROLOG_WIN32
            
    bool fFailedToFindManifestInResource = FALSE;
    rfManifestInResource = false;
    
    // NTRAID#NTBUG9 - 573793 - jonwis - 2002/04/25 - Use impersonation here!
    CSmartPtr<CResourceStream> ResourceStream;
    IFW32FALSE_EXIT(ResourceStream.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT_UNLESS2(ResourceStream->Initialize(ManifestPath, MAKEINTRESOURCEW(RT_MANIFEST)), 
        LIST_2(ERROR_RESOURCE_TYPE_NOT_FOUND, ERROR_RESOURCE_DATA_NOT_FOUND),
        fFailedToFindManifestInResource);

    rfManifestInResource = !fFailedToFindManifestInResource;

    FN_EPILOG
}

//
// ISSUE: jonwis 3/11/2002 - Should these reinitialize their member variables?  Or at least error
//          if they're being reinitialized?
//
BOOL
CProbedAssemblyInformation::Initialize(PCACTCTXGENCTX pGenCtx)
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(Base::Initialize());
    this->m_pActCtxGenCtx = pGenCtx;

    FN_EPILOG
}

BOOL
CProbedAssemblyInformation::Initialize(
    const CAssemblyReference &r,
    PCACTCTXGENCTX pGenCtx
    )
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(Base::Initialize(r));
    m_pActCtxGenCtx = pGenCtx;
    
    FN_EPILOG
}

// "copy initializer"
BOOL
CProbedAssemblyInformation::Initialize(
    const CProbedAssemblyInformation &r
    )
{
    FN_PROLOG_WIN32
    
    IFW32FALSE_EXIT(this->Assign(r));
    
    FN_EPILOG
}

// "copy initializer"
BOOL
CProbedAssemblyInformation::InitializeTakeValue(
    CProbedAssemblyInformation &r
    )
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(this->TakeValue(r));

    FN_EPILOG
}

BOOL
CProbedAssemblyInformation::Assign(
    const CProbedAssemblyInformation &r
    )
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(Base::Assign(r));

    // manifest
    IFW32FALSE_EXIT(m_ManifestPathBuffer.Win32Assign(r.m_ManifestPathBuffer));
    m_ManifestPathType = r.m_ManifestPathType;
    m_ManifestLastWriteTime = r.m_ManifestLastWriteTime;
    m_ManifestStream = r.m_ManifestStream;
    m_ManifestFlags = r.m_ManifestFlags;

    // policy
    IFW32FALSE_EXIT(m_PolicyPathBuffer.Win32Assign(r.m_PolicyPathBuffer));
    m_PolicyPathType = r.m_PolicyPathType;
    m_PolicyLastWriteTime = r.m_PolicyLastWriteTime;
    m_PolicyStream = r.m_PolicyStream;
    m_PolicyFlags = r.m_PolicyFlags;
    m_PolicySource = r.m_PolicySource;

    m_pActCtxGenCtx = r.m_pActCtxGenCtx;

    FN_EPILOG
}

BOOL
CProbedAssemblyInformation::TakeValue(
    CProbedAssemblyInformation &r
    )
{
    FN_PROLOG_WIN32

    IFW32FALSE_EXIT(Base::TakeValue(r));

    // manifest
    IFW32FALSE_EXIT(m_ManifestPathBuffer.Win32Assign(r.m_ManifestPathBuffer));
    m_ManifestPathType = r.m_ManifestPathType;
    m_ManifestLastWriteTime = r.m_ManifestLastWriteTime;
    m_ManifestStream = r.m_ManifestStream;
    m_ManifestFlags = r.m_ManifestFlags;

    // policy
    IFW32FALSE_EXIT(m_PolicyPathBuffer.Win32Assign(r.m_PolicyPathBuffer));
    m_PolicyPathType = r.m_PolicyPathType;
    m_PolicyLastWriteTime = r.m_PolicyLastWriteTime;
    m_PolicyStream = r.m_PolicyStream;
    m_PolicyFlags = r.m_PolicyFlags;
    m_PolicySource = r.m_PolicySource;

    m_pActCtxGenCtx = r.m_pActCtxGenCtx;

    FN_EPILOG
}

BOOL
CProbedAssemblyInformation::SetPolicyPath(
    ULONG PathType,
    PCWSTR  Path,
    SIZE_T PathCch
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(PathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    IFW32FALSE_EXIT(m_PolicyPathBuffer.Win32Assign(Path, PathCch));
    m_PolicyPathType = PathType;

    FN_EPILOG
}

BOOL
CProbedAssemblyInformation::SetManifestPath(
    ULONG PathType,
    const CBaseStringBuffer &rbuff
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(PathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    IFW32FALSE_EXIT(this->SetManifestPath(PathType, rbuff, rbuff.Cch()));

    FN_EPILOG
}


//
// ISSUE: jonwis 3/11/2002 - Consider redoing the class hierarchy here and making all the things
//          that take/return PCWSTR/SIZE_T or PCWSTR&/SIZE_T and have them actually use stringbuffers
//          properly.  It'd be cheap/free, and you'd shrink stack sizes as well as (potentially)
//          speeding up assignments if/when we ever do things like combining string buffers under
//          the hood.
//
BOOL
CProbedAssemblyInformation::SetManifestPath(
    ULONG PathType,
    PCWSTR path,
    SIZE_T path_t
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(PathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE);
    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);
    IFW32FALSE_EXIT(m_ManifestPathBuffer.Win32Assign(path, path_t));
    m_ManifestPathType = PathType;

    FN_EPILOG
}

BOOL
CProbedAssemblyInformation::ProbeManifestExistence(
    const CImpersonationData &ImpersonationData,
    BOOL fIsPrivateAssembly, // [in]
    bool &rfManifestExistsOut, // [out]    
    bool &rfPrivateAssemblyManifestInResource // [out]
    ) const
{
    FN_PROLOG_WIN32
    
    WIN32_FILE_ATTRIBUTE_DATA wfad;
    CImpersonate impersonate(ImpersonationData);
    bool ManifestExistsTemp = false; // used to hold eventual value to pass out
    bool fPrivateAssemblyManifestInResourceTemp = false;
    bool fNotFound = false;

    rfManifestExistsOut = false;
    rfPrivateAssemblyManifestInResource = false;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    //
    // if we have a stream that implements Stat, use that
    // also, if we have a nonzero time and the stream doesn't implement Stat,
    // just stick with the nonzero time we already have
    //
    if (m_ManifestStream != NULL)
    {
        ManifestExistsTemp = true;
    }
    else
    {
        PCWSTR ManifestPath = m_ManifestPathBuffer;
        PARAMETER_CHECK(!IsNtDosPath(ManifestPath));

        IFW32FALSE_EXIT(impersonate.Impersonate());
        IFW32FALSE_EXIT_UNLESS2(
            ::GetFileAttributesExW(m_ManifestPathBuffer, GetFileExInfoStandard, &wfad),
            LIST_2(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND),
            fNotFound);

        if (!fNotFound)
        {
            ManifestExistsTemp = true;
            if (fIsPrivateAssembly)
            {
                //
                // check the probed private assembly filename is a binary file(.dll or .mui), 
                // if so, open the dll and check whether it has manifest resource inside
                //
                // ISSUE: jonwis 3/11/2002 - Consider using sbFileExtension.Win32Equals here
                //          instead, as it will do a "better thing" going forward.
                //
                CSmallStringBuffer sbFileExtension;

                IFW32FALSE_EXIT(m_ManifestPathBuffer.Win32GetPathExtension(sbFileExtension));
                if (::FusionpEqualStrings(
                        sbFileExtension, sbFileExtension.Cch(),
                        L"DLL", NUMBER_OF(L"DLL") -1,
                        TRUE // case-insensitive
                        ) ||
                        ::FusionpEqualStrings(   // this depends on our private-assembly probing alg, otherwise, it is not enough to check "mui" ,we need check "mui.dll", xiaoyuw@11/22/2000
                        sbFileExtension, sbFileExtension.Cch(),
                        L"MUI", NUMBER_OF(L"MUI") -1,
                        TRUE // case-insensitive
                        ))
                {
                    //
                    // check the resource of this binary
                    //                    
                    IFW32FALSE_EXIT(IsBinaryFileContainManifestInResource(m_ManifestPathBuffer, fPrivateAssemblyManifestInResourceTemp));
                    ManifestExistsTemp = fPrivateAssemblyManifestInResourceTemp;
                }                
            }
        }        
    }

    rfManifestExistsOut = ManifestExistsTemp;
    rfPrivateAssemblyManifestInResource = fPrivateAssemblyManifestInResourceTemp;

    IFW32FALSE_EXIT(impersonate.Unimpersonate());

    FN_EPILOG
}

BOOL
CProbedAssemblyInformation::SetManifestLastWriteTime(
    const CImpersonationData &ImpersonationData,
    BOOL fDuringBindingAndProbingPrivateManifest)
{
    FN_PROLOG_WIN32
    WIN32_FILE_ATTRIBUTE_DATA wfad;
    CImpersonate impersonate(ImpersonationData);    

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    PARAMETER_CHECK(!IsNtDosPath(m_ManifestPathBuffer));

    //
    // if we have a stream that implements Stat, use that
    // also, if we have a nonzero time and the stream doesn't implement Stat,
    // just stick with the nonzero time we already have
    //
    if (m_ManifestStream != NULL)
    {
        STATSTG stat;
        HRESULT hr;

        hr = m_ManifestStream->Stat(&stat, STATFLAG_NONAME);
        if (hr == E_NOTIMPL && m_ManifestLastWriteTime != 0)
        {
            FN_SUCCESSFUL_EXIT();
        }
        if (hr != E_NOTIMPL)
        {
            IFCOMFAILED_EXIT(hr);
            m_ManifestLastWriteTime = stat.mtime;
            FN_SUCCESSFUL_EXIT();
        }
    }

    IFW32FALSE_EXIT(impersonate.Impersonate());

    PARAMETER_CHECK(!IsNtDosPath(m_ManifestPathBuffer));

    if (fDuringBindingAndProbingPrivateManifest)
    {
        //check whether there is a reparse point cross the path
        BOOL CrossesReparsePoint = FALSE;
        IFW32FALSE_EXIT(
            ::SxspDoesPathCrossReparsePoint(
                m_pActCtxGenCtx ? static_cast<PCWSTR>(m_pActCtxGenCtx->m_ApplicationDirectoryBuffer) : NULL,
                m_pActCtxGenCtx ? m_pActCtxGenCtx->m_ApplicationDirectoryBuffer.Cch() : 0,
                m_ManifestPathBuffer,
                m_ManifestPathBuffer.Cch(),
                CrossesReparsePoint));

        if (CrossesReparsePoint) // report error instead of ignore and continue
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(CProbedAssemblyInformation::SetManifestLastWriteTime, ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT);
        }
    }

    // BUGBUGBUG!
    //
    // ISSUE: jonwis 3/11/2002 - I think the logic for guarding against reparse points should be done
    //          in all cases, not just when we're probing for private manifests.  What if someone does
    //          a dastardly thing and makes WinSxS a hard link to somewhere else in the tree?  We'll spin
    //          forever trying to access it (if the object is gone) or otherwise do something bad to
    //          the user.  I'm pretty sure the 'does path cross reparse point' logic runs all the way
    //          through to to the end, so maybe we should use it instead.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(::GetFileAttributesExW(m_ManifestPathBuffer, GetFileExInfoStandard, &wfad));
    if( wfad.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(CProbedAssemblyInformation::SetManifestLastWriteTime, ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT);
    }

    m_ManifestLastWriteTime = wfad.ftLastWriteTime;
    IFW32FALSE_EXIT(impersonate.Unimpersonate());

    FN_EPILOG
}

BOOL
CProbedAssemblyInformation::ProbeAssembly(
    DWORD dwFlags,
    PACTCTXGENCTX pActCtxGenCtx,
    LanguageProbeType lpt,
    bool &rfFound
    )
{
    FN_PROLOG_WIN32

    PCWSTR Slash = 0;
    ULONG index = 0;
    BOOL fPrivateAssembly = false;
    bool fManifestExists = false;
    bool fDone = false;
    bool fAppPolicyApplied = false;
    bool fPublisherPolicyApplied = false;
    bool fPolicyApplied = false;
    ULONG ApplicationDirectoryPathType;
    DWORD dwGenerateManifestPathFlags = 0;
    bool fPrivateAssemblyManifestInResource = false;
    PROBING_ATTRIBUTE_CACHE pac = { 0 };

    rfFound = false;
    bool fAppRunningInSafeMode = false;
    bool fComponentRunningInSafeMode = false;

    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    PARAMETER_CHECK((dwFlags & ~(ProbeAssembly_SkipPrivateAssemblies)) == 0);

    //
    // Policy from the win32 gac -always- wins over the NDP gac, period.
    //
    IFW32FALSE_EXIT(this->LookForAppPolicy(pActCtxGenCtx, fAppPolicyApplied, fAppRunningInSafeMode, fComponentRunningInSafeMode));

#if DBG
    {
        CStringBuffer sbTextualIdentity;

        IFW32FALSE_EXIT(SxspGenerateTextualIdentity(
            0,
            m_pAssemblyIdentity,
            sbTextualIdentity));

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_SAFEMODE,
            "SXS.DLL: the current App is %s running in SafeMode, for assembly, %S, there is %s policy applied\n",
            fAppRunningInSafeMode? "truely" : "not",
            static_cast<PCWSTR>(sbTextualIdentity),
            fAppPolicyApplied? "truly" : "no");
    }
#endif    

    //
    // if not found in app config or found but app is running in non-safemode, continue 
    // searching policy from winsxs and NDP policy
    //    
    if (!fAppRunningInSafeMode && !fComponentRunningInSafeMode)
    {
        IFW32FALSE_EXIT(this->LookForSxsWin32Policy(pActCtxGenCtx, fAppPolicyApplied, fPublisherPolicyApplied));
        if (!fPublisherPolicyApplied)
        {
            IFW32FALSE_EXIT(this->LookForNDPWin32Policy(pActCtxGenCtx, fPublisherPolicyApplied));
        }
    }

    fPolicyApplied = (fAppPolicyApplied || fPublisherPolicyApplied);

    if (pActCtxGenCtx->m_ManifestOperation == MANIFEST_OPERATION_INSTALL)
        dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_NO_APPLICATION_ROOT_PATH_REQUIRED;

    if (dwFlags & ProbeAssembly_SkipPrivateAssemblies)
        dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_PRIVATE_ASSEMBLIES;

    ApplicationDirectoryPathType = pActCtxGenCtx->m_ApplicationDirectoryPathType;

    if ((lpt != eExplicitBind) && (lpt != eLanguageNeutral))
    {
        if (!pActCtxGenCtx->m_ApplicationDirectoryHasBeenProbedForLanguageSubdirs)
        {
            SIZE_T cch = 0;
            CSmallStringBuffer buffTemp;

            IFW32FALSE_EXIT(buffTemp.Win32Assign(pActCtxGenCtx->m_ApplicationDirectoryBuffer));
            cch = buffTemp.Cch();

            // Ok, let's see what's there.
            IFW32FALSE_EXIT(this->ProbeLanguageDir(buffTemp, pActCtxGenCtx->m_SpecificLanguage, pActCtxGenCtx->m_ApplicationDirectoryHasSpecificLanguageSubdir));
            buffTemp.Left(cch);

            IFW32FALSE_EXIT(this->ProbeLanguageDir(buffTemp, pActCtxGenCtx->m_GenericLanguage, pActCtxGenCtx->m_ApplicationDirectoryHasGenericLanguageSubdir));
            buffTemp.Left(cch);

            IFW32FALSE_EXIT(this->ProbeLanguageDir(buffTemp, pActCtxGenCtx->m_SpecificSystemLanguage, pActCtxGenCtx->m_ApplicationDirectoryHasSpecificSystemLanguageSubdir));
            buffTemp.Left(cch);

            IFW32FALSE_EXIT(this->ProbeLanguageDir(buffTemp, pActCtxGenCtx->m_GenericSystemLanguage, pActCtxGenCtx->m_ApplicationDirectoryHasGenericSystemLanguageSubdir));

            pActCtxGenCtx->m_ApplicationDirectoryHasBeenProbedForLanguageSubdirs = true;
        }

        switch (lpt)
        {
        case eSpecificLanguage:
            if (!pActCtxGenCtx->m_ApplicationDirectoryHasSpecificLanguageSubdir)
                dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS;
            break;

        case eGenericLanguage:
            if (!pActCtxGenCtx->m_ApplicationDirectoryHasGenericLanguageSubdir)
                dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS;
            break;

        case eSpecificSystemLanguage:
            if (!pActCtxGenCtx->m_ApplicationDirectoryHasSpecificSystemLanguageSubdir)
                dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS;
            break;

        case eGenericSystemLanguage:
            if (!pActCtxGenCtx->m_ApplicationDirectoryHasGenericSystemLanguageSubdir)
                dwGenerateManifestPathFlags |= SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS;
            break;
        }
    }

    for (index=0; !fDone; index++)
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateManifestPathForProbing(
                index,
                dwGenerateManifestPathFlags,
                pActCtxGenCtx->m_AssemblyRootDirectoryBuffer,
                pActCtxGenCtx->m_AssemblyRootDirectoryBuffer.Cch(),
                ApplicationDirectoryPathType,
                pActCtxGenCtx->m_ApplicationDirectoryBuffer,
                pActCtxGenCtx->m_ApplicationDirectoryBuffer.Cch(),
                m_pAssemblyIdentity,
                &pac,
                m_ManifestPathBuffer,
                &fPrivateAssembly,
                fDone));

        // The SxspGenerateManifestPathForProbing() call might not have generated a candidate; only probe for the manifest
        // if it makes sense.
        if (m_ManifestPathBuffer.Cch() != 0)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_PROBING,
                "SXS.DLL: Probing for manifest: %S\n", static_cast<PCWSTR>(m_ManifestPathBuffer));

            /*
            verify minimal access, and get last write time in
            case caller asked for it
            */

            IFW32FALSE_EXIT(this->ProbeManifestExistence(pActCtxGenCtx->m_ImpersonationData, fPrivateAssembly, fManifestExists, fPrivateAssemblyManifestInResource));
            if (fManifestExists)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_PROBING,
                    "SXS.DLL: Probed manifest: %S is FOUND !!!\n", static_cast<PCWSTR>(m_ManifestPathBuffer));

                break;
            }
        }
    }

    if (fManifestExists)
    {
        m_ManifestPathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;
        m_ManifestFlags = ASSEMBLY_MANIFEST_FILETYPE_AUTO_DETECT;

        IFW32FALSE_EXIT(this->SetManifestLastWriteTime(pActCtxGenCtx->m_ImpersonationData, fPrivateAssembly));
        INTERNAL_ERROR_CHECK(m_ManifestPathBuffer.ContainsCharacter(L'\\'));

        if (fPrivateAssemblyManifestInResource) // only private manifest has such problem : manifst type could be FILE or RESOURCE        
            m_ManifestFlags = ASSEMBLY_MANIFEST_FILETYPE_RESOURCE;

        if (fPrivateAssembly)
        { // manifest file is found from private dirs
            m_ManifestFlags |= ASSEMBLY_PRIVATE_MANIFEST;
        }
    }

    rfFound = fManifestExists;

    FN_EPILOG
}

#define GENERATE_NDP_PATH_NO_ROOT               (0x00000001)
#define GENERATE_NDP_PATH_WILDCARD_VERSION      (0x00000002)
#define GENERATE_NDP_PATH_PATH_ONLY             (0x00000004)
#define GENERATE_NDP_PATH_IS_POLICY             (0x00000008)
#define GENERATE_NDP_PATH_ASSEMBLY_NAME_ONLY    (0x00000010)

BOOL
SxspGenerateNDPGacPath(
    ULONG               ulFlags,
    PCASSEMBLY_IDENTITY pAsmIdent,
    CBaseStringBuffer  *psbAssemblyRoot,
    CBaseStringBuffer  &rsbOutput
    )
{
    FN_PROLOG_WIN32

    typedef struct _STRING_AND_LENGTH {

        _STRING_AND_LENGTH() : pcwsz(NULL), cch(0) { }
        ~_STRING_AND_LENGTH() { }

        PCWSTR pcwsz;
        SIZE_T cch;
    } STRING_AND_LENGTH;

    CSmallStringBuffer  GlobalGacPath;
    SIZE_T              cchRequired = 0;
    STRING_AND_LENGTH   Name;
    STRING_AND_LENGTH   Version;
    STRING_AND_LENGTH   Language;
    STRING_AND_LENGTH   PublicKeyToken;
    STRING_AND_LENGTH   AssemblyRoot;
    bool                fRootNeedsSlash = false;

    rsbOutput.Clear();

    if ((psbAssemblyRoot == NULL) && ((ulFlags & GENERATE_NDP_PATH_NO_ROOT) == 0))
    {
        IFW32FALSE_EXIT(SxspGetNDPGacRootDirectory(GlobalGacPath));
        psbAssemblyRoot = &GlobalGacPath;
    }

    if (psbAssemblyRoot)
    {
        AssemblyRoot.pcwsz = *psbAssemblyRoot;
        AssemblyRoot.cch = psbAssemblyRoot->Cch();
        fRootNeedsSlash = !psbAssemblyRoot->HasTrailingPathSeparator();
    }
    else
    {
        AssemblyRoot.pcwsz = NULL;
        AssemblyRoot.cch = 0;
    }

        
    
    IFW32FALSE_EXIT(SxspGetAssemblyIdentityAttributeValue(
        0, 
        pAsmIdent, 
        &s_IdentityAttribute_name, 
        &Name.pcwsz, &Name.cch));

    if ((ulFlags & GENERATE_NDP_PATH_WILDCARD_VERSION) == 0)
    {
        IFW32FALSE_EXIT(SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, 
            pAsmIdent, 
            &s_IdentityAttribute_version, 
            &Version.pcwsz, &Version.cch));
    }
    else
    {
        Version.pcwsz = L"*";
        Version.cch = 1;            
    }

    //
    // Allow for international language - in the NDP, this is the "blank" value.
    //
    IFW32FALSE_EXIT(SxspGetAssemblyIdentityAttributeValue(
        SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, 
        pAsmIdent, 
        &s_IdentityAttribute_language, 
        &Language.pcwsz, &Language.cch));

    //
    // If we got back "international", use the blank string instead.
    //
    if (::FusionpEqualStringsI(Language.pcwsz, Language.cch, SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE, NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE) - 1))
    {
        Language.pcwsz = 0;
        Language.cch = 0;
    }

    IFW32FALSE_EXIT(SxspGetAssemblyIdentityAttributeValue(
        SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
        pAsmIdent,
        &s_IdentityAttribute_publicKeyToken,
        &PublicKeyToken.pcwsz, &PublicKeyToken.cch));

    if (PublicKeyToken.pcwsz == NULL)
    {
        PublicKeyToken.pcwsz = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE;
        PublicKeyToken.cch = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE) - 1;
    }

    //
    // Calcuate the required length: 
    // %gacpath%\{name}\{version}_{language}_{pkt}\{name}.dll
    //
    cchRequired = (AssemblyRoot.cch + 1) +  (Name.cch + 1 + Version.cch + 1 + PublicKeyToken.cch);

    //
    // They want the whole path to the DLL
    //
    if ((ulFlags & GENERATE_NDP_PATH_PATH_ONLY) == 0)
    {
        cchRequired += (Name.cch + 1 + (NUMBER_OF(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_DLL) - 1));
    }

    //
    // Build the string
    //
    IFW32FALSE_EXIT(rsbOutput.Win32ResizeBuffer(cchRequired, eDoNotPreserveBufferContents));


    //
    // If they want the full path, that's 12 components.  Otherwise, just 9.
    //
    IFW32FALSE_EXIT(rsbOutput.Win32AssignW(
        ((ulFlags & GENERATE_NDP_PATH_PATH_ONLY) ? ((ulFlags & GENERATE_NDP_PATH_ASSEMBLY_NAME_ONLY) ? 3 : 9) : 12),
        AssemblyRoot.pcwsz, AssemblyRoot.cch,           // Root path
        L"\\", (fRootNeedsSlash ? 1 : 0),               // Slash
        Name.pcwsz, Name.cch,
        L"\\", 1,
        Version.pcwsz, Version.cch,
        L"_", 1,
        Language.pcwsz, Language.cch,
        L"_", 1,
        PublicKeyToken.pcwsz, PublicKeyToken.cch,
        L"\\", 1,
        Name.pcwsz, Name.cch,
        ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_DLL, NUMBER_OF(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_DLL)-1));

    FN_EPILOG
}


BOOL
CProbedAssemblyInformation::LookForNDPWin32Policy(
    PACTCTXGENCTX       pActCtxGenCtx,
    bool               &rfPolicyApplied
    )
/*++

Purpose:
    1. Get the location of the GAC
    2. Create a path of the form %gac%\Policy.Vmajor.Vminor.AssemblyName\*_{language}_{pubkeytoken}
    3. Find all directories that match the wildcard, find the version with the highest value
    4. Find %thatpath%\Policy.VMajor.VMinor.AssemblyName.Dll
    5. Look for a win32 policy manifest in resource ID 1, type RT_MANIFEST
--*/
{
    FN_PROLOG_WIN32

    CPolicyStatement   *pFoundPolicyStatement = NULL;
    CSmallStringBuffer  Prober;
    CStringBuffer &EncodedPolicyIdentity = pActCtxGenCtx->CProbedAssemblyInformationLookForPolicy.EncodedPolicyIdentity;
    CFindFile           FindFiles;
    ASSEMBLY_VERSION    HighestAssemblyVersion = {0};
    WIN32_FIND_DATAW    FindData;
    bool                fNotFound = false;
    bool                fPolicyFound = false;
    bool                fFound = false;
    BOOL                fCrossesReparse = FALSE;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> PolicyIdentity;
    CProbedAssemblyInformation ProbedAssembly;

    rfPolicyApplied = false;


    //
    // Generate the textual and non-textual policy identity from the actual identity.  This
    // does the thing twice, but because they're different identities (one to probe for
    // app policy and one for actual policy to probe) that's ok.  Ordering is important -
    // we don't really want the first (policy.1.0.foo) encoded identity, we want the second
    // encoding (Policy.foo)
    //
    IFW32FALSE_EXIT(SxspMapAssemblyIdentityToPolicyIdentity(0, m_pAssemblyIdentity, &PolicyIdentity));

    //
    // EncodedPolicyIdentity must be calculated during LookForAppPolicy and updated during LookForSxsWin32Policy
    //
    ASSERT(!EncodedPolicyIdentity.IsEmpty());
    
    //
    // See if the base path to the pattern-matcher contains reparse points
    //
    IFW32FALSE_EXIT(SxspGenerateNDPGacPath(
        GENERATE_NDP_PATH_ASSEMBLY_NAME_ONLY,
        PolicyIdentity,
        NULL,
        Prober));

    //
    // See if the generated path actually exists first.
    //
    IFW32FALSE_EXIT(SxspDoesFileExist(0, Prober, fFound));
    if (!fFound)
    {
#if DBG
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_PROBING, 
            "Sxs.dll: %s could not locate path %ls, bailing on probe.\n",
            __FUNCTION__,
            static_cast<PCWSTR>(Prober));
#endif
        FN_SUCCESSFUL_EXIT();
    }
    
    
    IFW32FALSE_EXIT_UNLESS2(
        SxspDoesPathCrossReparsePoint(NULL, 0, Prober, Prober.Cch(), fCrossesReparse),
        LIST_4(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_BAD_NETPATH, ERROR_BAD_NET_NAME),
        fNotFound
        );
    
    if (fCrossesReparse || !fNotFound)
    {
#if DBG
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_PROBING, 
            "Sxs.dll: %s path %ls crosses a reparse point, can't use it, bailing out.\n",
            __FUNCTION__,
            static_cast<PCWSTR>(Prober));
#endif
        FN_SUCCESSFUL_EXIT();
    }

    //
    // Otherwise, we have to go look in the GAC for a policy for this assembly
    //
    IFW32FALSE_EXIT(SxspGenerateNDPGacPath(
        GENERATE_NDP_PATH_WILDCARD_VERSION | GENERATE_NDP_PATH_PATH_ONLY,
        PolicyIdentity,
        NULL,
        Prober));

    //
    // Now let's find all the directories in the GAC that match this wildcard
    //
    IFW32FALSE_EXIT_UNLESS2(
        FindFiles.Win32FindFirstFile(Prober, &FindData),
        LIST_2(ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND),
        fNotFound);

    if (!fNotFound) do
    {
        ASSEMBLY_VERSION ThisVersion;
        bool fValid = false;
        
        //
        // Skip non-directories and dot/dotdot
        //
        if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            continue;
        else if (FusionpIsDotOrDotDot(FindData.cFileName))
            continue;
        
        //
        // Neat, found a match to that pattern. Tease apart the "version" part of the directory - should
        // be everything up to the first underscore in the path
        //       
        PCWSTR pcwszFirstUnderscore = StringFindChar(FindData.cFileName, L'_');

        //
        // Oops, that wasn't a valid path, we'll ignore it quietly
        //
        if (pcwszFirstUnderscore == NULL)
            continue;

        IFW32FALSE_EXIT(CFusionParser::ParseVersion(
            ThisVersion, 
            FindData.cFileName,
            pcwszFirstUnderscore - FindData.cFileName,
            fValid));

        //
        // Sneaky buggers, putting something that's not a version up front.
        //
        if (!fValid)
            continue;

        //
        // Spiffy, we found something that's a version number - is it what we're looking
        // for?
        //
        if (!fPolicyFound || (ThisVersion > HighestAssemblyVersion))
        {
            HighestAssemblyVersion = ThisVersion;
            fPolicyFound = true;
        }
    } while (::FindNextFileW(FindFiles, &FindData));

    //
    // Make sure that we quit out nicely here
    //
    if (!fNotFound && (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES))
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(FindNextFile, ::FusionpGetLastWin32Error());
    }

    //
    // Otherwise, let's parse the statement we found, if there was one.
    //
    if (fPolicyFound)
    {
        //
        // Ensure we have space for 65535.65535.65535.65535
        //
        IFW32FALSE_EXIT(Prober.Win32ResizeBuffer((5 * 4) + 3, eDoNotPreserveBufferContents));
        IFW32FALSE_EXIT(Prober.Win32Format(L"%u.%u.%u.%u", 
            HighestAssemblyVersion.Major,
            HighestAssemblyVersion.Minor,
            HighestAssemblyVersion.Revision,
            HighestAssemblyVersion.Build));
            
        //
        // Ok, now we have the 'highest version' available for the policy.  Let's go swizzle the
        // policy identity and re-generate the path with that new version
        //
        IFW32FALSE_EXIT(ProbedAssembly.Initialize(pActCtxGenCtx));
        IFW32FALSE_EXIT(SxspSetAssemblyIdentityAttributeValue(
            SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
            PolicyIdentity,
            &s_IdentityAttribute_version,
            static_cast<PCWSTR>(Prober),
            Prober.Cch()));

#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_POLICY, 
            "%s(%d) : Should find this policy identity in the GAC\n",
            __FILE__,
            __LINE__);
        SxspDbgPrintAssemblyIdentity(FUSION_DBG_LEVEL_POLICY, PolicyIdentity);
#endif

        //
        // Now regenerate the path, set it into the actual prober
        //
        IFW32FALSE_EXIT(SxspGenerateNDPGacPath(0, PolicyIdentity, NULL, Prober));

        //
        // Caution! If this path crosses a reparse point, we could really ham up the
        // system while it tries to get to the file, or we could have a security hole
        // where someone has created a reparse point to somewhere untrusted in the
        // filesystem.  Disallow this here.
        //
        IFW32FALSE_EXIT(SxspDoesPathCrossReparsePoint(NULL, 0, Prober, Prober.Cch(), fCrossesReparse));
        if (fCrossesReparse)
        {
            FN_SUCCESSFUL_EXIT();
        }
            
        
        IFW32FALSE_EXIT(ProbedAssembly.SetManifestPath(ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE, Prober));
        IFW32FALSE_EXIT(ProbedAssembly.SetProbedIdentity(PolicyIdentity));
        IFW32FALSE_EXIT(SxspParseNdpGacComponentPolicy(0, pActCtxGenCtx, ProbedAssembly, pFoundPolicyStatement));

        IFW32FALSE_EXIT(pFoundPolicyStatement->ApplyPolicy(m_pAssemblyIdentity, rfPolicyApplied));
        IFW32FALSE_EXIT(pActCtxGenCtx->m_ComponentPolicyTable.Insert(EncodedPolicyIdentity, pFoundPolicyStatement));
        
    }

    // pActCtxGenCtx->m_ComponentPolicyTable owns pFoundPolicyStatement
    pFoundPolicyStatement = NULL;
    
    FN_EPILOG
}
 
BOOL
CProbedAssemblyInformation::LookForAppPolicy(
    PACTCTXGENCTX  pActCtxGenCtx,
    bool          &rfPolicyApplied,
    bool          &fAppRunningInSafeMode,
    bool          &fComponentRunningInSafeMode
    )
{
    FN_PROLOG_WIN32

    CStringBuffer &EncodedPolicyIdentity = pActCtxGenCtx->CProbedAssemblyInformationLookForPolicy.EncodedPolicyIdentity;
    EncodedPolicyIdentity.Clear();
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> PolicyIdentity;
    CPolicyStatement *pPolicyStatement = NULL;
    
    PARAMETER_CHECK(pActCtxGenCtx != NULL);
    fAppRunningInSafeMode = false;
    rfPolicyApplied = false;

    //
    // Get the policy identity to probe for
    //
    IFW32FALSE_EXIT(::SxspMapAssemblyIdentityToPolicyIdentity(0, m_pAssemblyIdentity, &PolicyIdentity));

    //
    // Get the key that we should find in the app policy table
    //
    IFW32FALSE_EXIT(
        ::SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
            SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION,
            m_pAssemblyIdentity,
            EncodedPolicyIdentity,
            NULL));

    IFW32FALSE_EXIT(pActCtxGenCtx->m_ApplicationPolicyTable.Find(EncodedPolicyIdentity, pPolicyStatement));

    if (pPolicyStatement != NULL)
    {
        IFW32FALSE_EXIT(pPolicyStatement->ApplyPolicy(m_pAssemblyIdentity, rfPolicyApplied));
    }

    if (pActCtxGenCtx->m_fAppApplyPublisherPolicy == SXS_PUBLISHER_POLICY_APPLY_NO)
    {
        fAppRunningInSafeMode = true;
    }else 
    {

        if (rfPolicyApplied)
        {
            if (pPolicyStatement->m_fApplyPublisherPolicy == false)
            {
                //app is running in safemode, no further looking for publisher policy
                fComponentRunningInSafeMode = true;            
            }
        }
    }

    FN_EPILOG
}  


BOOL
CProbedAssemblyInformation::LookForSxsWin32Policy(
    PACTCTXGENCTX   pActCtxGenCtx,
    bool            fAppPolicyApplied, 
    bool           &rfPolicyApplied
    )
{
    FN_PROLOG_WIN32
    
    CStringBuffer &EncodedPolicyIdentity = pActCtxGenCtx->CProbedAssemblyInformationLookForPolicy.EncodedPolicyIdentity;    
    CFindFile hFind;
    SIZE_T CandidatePolicyDirectoryCch = 0;
    CPolicyStatement *pPolicyStatement = NULL;
    bool fAnyPoliciesFound = false;
    bool fAnyFilesFound = false;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, SxsDestroyAssemblyIdentity> PolicyIdentity;
    BOOL fAreWeInOSSetupMode = FALSE;

    rfPolicyApplied = false;
    //
    // app policy, foo.exe.config
    //
    PARAMETER_CHECK(pActCtxGenCtx != NULL);

    //
    // Get the policy identity to probe for
    //
    IFW32FALSE_EXIT(::SxspMapAssemblyIdentityToPolicyIdentity(0, m_pAssemblyIdentity, &PolicyIdentity));

    if (fAppPolicyApplied)
    {
        //
        // must to recalculate EncodedPolicyIdentity because app policy applied,
        // otherwise, LookforAppPolicy has calculated this value 
        //
        EncodedPolicyIdentity.Clear();
        IFW32FALSE_EXIT(
            ::SxspGenerateTextuallyEncodedPolicyIdentityFromAssemblyIdentity(
                SXSP_GENERATE_TEXTUALLY_ENCODED_POLICY_IDENTITY_FROM_ASSEMBLY_IDENTITY_FLAG_OMIT_ENTIRE_VERSION,
                m_pAssemblyIdentity,
                EncodedPolicyIdentity,
                NULL));
    }

    //
    // search winsxs policies
    //

    //
    // We probe only in SetupPolicies if we're in setup.
    // But not if we are in MiniSetup.
    //
    IFW32FALSE_EXIT(::FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode));
    if (fAreWeInOSSetupMode)
    {
        BOOL fAreWeInMiniSetupMode = FALSE;
        IFW32FALSE_EXIT(::FusionpAreWeInMiniSetupMode(&fAreWeInMiniSetupMode));
        if (fAreWeInMiniSetupMode)
        {
            fAreWeInOSSetupMode = FALSE;
        }
    }

    // See if there's a policy statement already available for this...
    IFW32FALSE_EXIT(pActCtxGenCtx->m_ComponentPolicyTable.Find(EncodedPolicyIdentity, pPolicyStatement));

    if (pPolicyStatement == NULL)
    {
        CStringBuffer &CandidatePolicyDirectory = pActCtxGenCtx->CProbedAssemblyInformationLookForPolicy.CandidatePolicyDirectory;
        CandidatePolicyDirectory.Clear();

        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                0,
                fAreWeInOSSetupMode ? SXSP_GENERATE_SXS_PATH_PATHTYPE_SETUP_POLICY : SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY,
                pActCtxGenCtx->m_AssemblyRootDirectoryBuffer,
                pActCtxGenCtx->m_AssemblyRootDirectoryBuffer.Cch(),
                PolicyIdentity,
                NULL,
                CandidatePolicyDirectory));

        // Save the number of characters up through and including the slash so that
        // we can repeatedly append and then call .Left() on the string buffer.
        CandidatePolicyDirectoryCch = CandidatePolicyDirectory.Cch();

        IFW32FALSE_EXIT(CandidatePolicyDirectory.Win32Append(L"*" POLICY_FILE_EXTENSION, 1 + (NUMBER_OF(POLICY_FILE_EXTENSION) - 1)));

        {
            WIN32_FIND_DATAW wfd;
            CFindFile hFind;

            // NTRAID#NTBUG9 - 531507 - jonwis - 2002/04/25 - Impersonate before findfirstfile
            hFind = ::FindFirstFileW(CandidatePolicyDirectory, &wfd);
            if (!hFind.IsValid())
            {
                const DWORD dwLastError = ::FusionpGetLastWin32Error();

                if ((dwLastError != ERROR_PATH_NOT_FOUND) && (dwLastError != ERROR_FILE_NOT_FOUND))
                {
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(FindFirstFileW, dwLastError);
                }

                ::FusionpSetLastWin32Error(ERROR_NO_MORE_FILES);
            }
            else
            {
                fAnyFilesFound = true;
            }

            ASSEMBLY_VERSION avHighestVersionFound = { 0, 0, 0, 0 };

            if (hFind.IsValid())
            {
				for (;;)
				{
					// Skip any directories we find; this will skip "." and ".."
					if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
					{
						ASSEMBLY_VERSION avTemp;
						bool fValid = false;
						SIZE_T cchFileName = ::wcslen(wfd.cFileName);

						if (cchFileName > NUMBER_OF(POLICY_FILE_EXTENSION))
						{
							IFW32FALSE_EXIT(
								CFusionParser::ParseVersion(
									avTemp,
									wfd.cFileName,
									cchFileName - (NUMBER_OF(POLICY_FILE_EXTENSION) - 1),
									fValid));

							// If there are randomly named files in the directory, we just skip them.
							if (fValid)
							{
								if ((!fAnyPoliciesFound) ||
									(avTemp > avHighestVersionFound))
								{
									fAnyPoliciesFound = true;
									CandidatePolicyDirectory.Left(CandidatePolicyDirectoryCch);
									IFW32FALSE_EXIT(CandidatePolicyDirectory.Win32Append(wfd.cFileName, cchFileName));
									avHighestVersionFound = avTemp;
								}
							}
						}
					}
					if (!::FindNextFileW(hFind, &wfd))
					{
						const DWORD dwLastError = ::FusionpGetLastWin32Error();

						if (dwLastError != ERROR_NO_MORE_FILES)
						{
							TRACE_WIN32_FAILURE_ORIGINATION(FindNextFileW);
							goto Exit;
						}

						IFW32FALSE_EXIT(hFind.Win32Close());
						break;
					}
                }
            }
        }

        if (fAnyFilesFound)
        {
            if (fAnyPoliciesFound)
            {
                CProbedAssemblyInformation PolicyAssemblyInformation;

                IFW32FALSE_EXIT(PolicyAssemblyInformation.Initialize(pActCtxGenCtx));
                IFW32FALSE_EXIT(PolicyAssemblyInformation.SetManifestPath(ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE, CandidatePolicyDirectory));

                // For one thing, let's set the version number...
                IFW32FALSE_EXIT(
                    ::SxspSetAssemblyIdentityAttributeValue(
                        SXSP_SET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_OVERWRITE_EXISTING,
                        PolicyIdentity,
                        &s_IdentityAttribute_version,
                        static_cast<PCWSTR>(CandidatePolicyDirectory) + CandidatePolicyDirectoryCch,
                        CandidatePolicyDirectory.Cch() - CandidatePolicyDirectoryCch - (NUMBER_OF(POLICY_FILE_EXTENSION) - 1)));

                IFW32FALSE_EXIT(PolicyAssemblyInformation.SetProbedIdentity(PolicyIdentity));

                // We found one!  Let's parse it, looking for a remapping of our identity.
                IFW32FALSE_EXIT(
                    ::SxspParseComponentPolicy(
                        0,
                        pActCtxGenCtx,
                        PolicyAssemblyInformation,
                        pPolicyStatement));

                IFW32FALSE_EXIT(pActCtxGenCtx->m_ComponentPolicyTable.Insert(EncodedPolicyIdentity, pPolicyStatement, ERROR_SXS_DUPLICATE_ASSEMBLY_NAME));
            }
        }
    }

    // If there was a component policy statement, let's try it out!
    if (pPolicyStatement != NULL)
        IFW32FALSE_EXIT(pPolicyStatement->ApplyPolicy(m_pAssemblyIdentity, rfPolicyApplied));
    
    IFW32FALSE_EXIT(hFind.Win32Close());

    FN_EPILOG
}

BOOL
CProbedAssemblyInformation::SetProbedIdentity(
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(AssemblyIdentity != NULL);
    IFW32FALSE_EXIT(Base::SetAssemblyIdentity(AssemblyIdentity));

    FN_EPILOG
}

BOOL
CProbedAssemblyInformation::ApplyPolicyDestination(
    const CAssemblyReference    &r,
    SXS_POLICY_SOURCE           s,
    const GUID &                g
    )
{
    FN_PROLOG_WIN32

    PCASSEMBLY_IDENTITY OldIdentity = m_pAssemblyIdentity;

    INTERNAL_ERROR_CHECK(this->IsInitialized());
    INTERNAL_ERROR_CHECK(r.IsInitialized());

    // Simply put, take anything in r that's specified and override our settings with it.
    IFW32FALSE_EXIT(
        ::SxsDuplicateAssemblyIdentity(
            0,
            r.GetAssemblyIdentity(),
            &m_pAssemblyIdentity));

    m_PolicySource = s;
    m_SystemPolicyGuid = g;
    ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(OldIdentity));

    if (OldIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(OldIdentity));

    FN_EPILOG
}


//
// ISSUE: jonwis 3/11/2002 - This function should know about cleaning up its parameter,
//          rather than assuming the caller will know about removing what it added.  Seems
//          like there's no explicit contract here in the interface, so it's not so bad.
//          Just seems like either a) we should use our own stringbuffer and twiddle it
//          or b) we should be the ones cleaning it up.
//
BOOL
CProbedAssemblyInformation::ProbeLanguageDir(
    CBaseStringBuffer &rbuffApplicationDirectory,
    const CBaseStringBuffer &rbuffLanguage,
    bool &rfFound
    )
{
    FN_PROLOG_WIN32

    DWORD dwFileAttributes = 0;

    rfFound = false;

    IFW32FALSE_EXIT(rbuffApplicationDirectory.Win32Append(rbuffLanguage));

    //
    // ISSUE: jonwis 3/11/2002 - Ick.  Use SxspGetFileAttributes instead, don't compare against -1.
    //
    // NTRAID#NTBUG9 - 531507 - jonwis - 2002/04/25 - Use existing function to do this
    // NTRAID#NTBUG9 - 531507 - jonwis - 2002/04/25 - Use impersonation when making this determination
    dwFileAttributes = ::GetFileAttributesW(rbuffApplicationDirectory);
    if (dwFileAttributes == ((DWORD) -1))
    {
        const DWORD dwLastError = ::FusionpGetLastWin32Error();

        if (dwLastError != ERROR_FILE_NOT_FOUND)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFileAttributes, dwLastError);
    }
    else
    {
        if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            rfFound = true;
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

SOURCES_USED=$(SOURCES_USED) ..\sources.inc
SOURCES_USED=$(SOURCES_USED) ..\sources_$(FUSION_BUILD_HALF_NUMBER).inc

TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)
TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)sxs$(FUSION_BUILD_HALF_NUMBER)

INCLUDES= \
 ..; \
 $(FUSION_INC_PATH); \
 $(FUSION_PATH)\xmlparser; \
 $(FUSION_PATH)\id; \
 $(FUSION_PATH)\inc; \
 $(FUSION_PATH)\eventlog\$(FUSION_BUILD_LEAF_DIRECTORY)\$(O); \
 $(FUSION_PATH)\idl\$(O); \
 $(INCLUDES); \
 $(COM_INC_PATH); \
 $(ADMIN_INC_PATH)

C_DEFINES = $(C_DEFINES) -D_SXSDLLBUILD_

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdinc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sources_1.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

FUSION_BUILD_HALF_NUMBER=1
!include ..\sources.inc

SOURCES=\
 ..\actctxctb.cpp \
 ..\actctxgen.cpp \
 ..\actctxgenctxctb.cpp \
 ..\asmmetadata.cpp \
 ..\assemblyreference.cpp \
 ..\cassemblyrecoveryinfo.cpp \
 ..\cmemorystream.cpp \
 ..\comclass.cpp \
 ..\comclsidmap.cpp \
 ..\comgoop.cpp \
 ..\cominterface.cpp \
 ..\comprogid.cpp \
 ..\comtypelib.cpp \
 ..\cresourcestream.cpp \
 ..\csecuritymetadata.cpp \
 ..\cstreamtap.cpp \
 ..\cteestream.cpp \
 ..\dllredir.cpp \
 ..\dumpers.cpp \
 ..\fileoper.cpp \
 ..\filestream.cpp \
 ..\gsgenctx.cpp \
 ..\guidsectgen.cpp \
 ..\sxsuninstall.cpp \
 ..\hashfile.cpp \
 ..\sxscabinet.cpp \
 ..\sxsclrhelpers.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\recover.h ===
#pragma once

#include "fusionarray.h"
#include "sxsapi.h"
#include "csecuritymetadata.h"

#define SXSRECOVER_MODE_MASK        ( 0x0000000F )
#define SXSRECOVER_NOTHING          ( 0x00000000 )
#define SXSRECOVER_MANIFEST         ( 0x00000001 )
#define SXSRECOVER_ASSEMBLYMEMBER   ( 0x00000002 )
#define SXSRECOVER_FULL_ASSEMBLY    ( SXSRECOVER_ASSEMBLYMEMBER | SXSRECOVER_MANIFEST )

enum SxsRecoveryResult
{
    Recover_OK,
    Recover_ManifestMissing,
    Recover_CatalogInvalid,
    Recover_OneOrMoreFailed,
    Recover_SourceMissing,
    Recover_Unknown
};

#if DBG
#define ENUM_TO_STRING( x ) case x: return (L#x)

inline PCWSTR SxspRecoveryResultToString( const SxsRecoveryResult r )
{
    switch ( r )
    {
        ENUM_TO_STRING( Recover_OK );
        ENUM_TO_STRING( Recover_ManifestMissing );
        ENUM_TO_STRING( Recover_CatalogInvalid );
        ENUM_TO_STRING( Recover_OneOrMoreFailed );
        ENUM_TO_STRING( Recover_SourceMissing );
        ENUM_TO_STRING( Recover_Unknown );
    }

    return L"Bad SxsRecoveryResult value";
}
#undef ENUM_TO_STRING
#endif

class CAssemblyRecoveryInfo;


BOOL
SxspOpenAssemblyInstallationKey(
    DWORD dwFlags,
    DWORD dwAccess,
    CRegKey &rhkAssemblyInstallation
    );

BOOL
SxspRecoverAssembly(
    IN          const CAssemblyRecoveryInfo &AsmRecoverInfo,
    OUT         SxsRecoveryResult &rStatus
    );


#define SXSP_ADD_ASSEMBLY_INSTALLATION_INFO_FLAG_REFRESH (0x00000001)
BOOL
SxspAddAssemblyInstallationInfo(
    DWORD dwFlags,
    IN CAssemblyRecoveryInfo& rcAssemblyInfo,
    IN const CCodebaseInformation& rcCodebaeInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\query.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    query.cpp

Abstract:

    Information querying functions for sxs.dll

Author:

    Michael J. Grier (MGrier) 22-May-2001

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"

BOOL
SxspQueryManifestInformationBasic(
    IN DWORD dwFlags,
    IN PCWSTR pszSource,
    IN DWORD dwInfoClassSpecificFlags,
    IN SIZE_T cbBuffer,
    OUT PVOID lpBuffer,
    OUT PSIZE_T cbWrittenOrRequired OPTIONAL
    );

BOOL
SxsQueryManifestInformation(
    IN DWORD dwFlags,
    IN PCWSTR pszSource,
    IN ULONG ulInfoClass,
    IN DWORD dwInfoClassSpecificFlags,
    IN SIZE_T cbBuffer,
    OUT PVOID lpBuffer,
    OUT PSIZE_T pcbWrittenOrRequired OPTIONAL
    )
{
    FN_PROLOG_WIN32

    if (pcbWrittenOrRequired != NULL)
        *pcbWrittenOrRequired = 0;

    PARAMETER_CHECK((dwFlags & ~SXS_QUERY_MANIFEST_INFORMATION_FLAG_SOURCE_IS_DLL) == 0);
    PARAMETER_CHECK(pszSource != NULL);
    PARAMETER_CHECK(ulInfoClass == SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC);
    // ignore infoclass specific flags
    PARAMETER_CHECK((cbBuffer == 0) || (lpBuffer != NULL)); // can't have a nonzero-sized buffer with a NULL pointer to it
    PARAMETER_CHECK((cbBuffer != 0) || (pcbWrittenOrRequired != NULL));

    switch (ulInfoClass)
    {
    default:
        INTERNAL_ERROR_CHECK(
            (ulInfoClass == SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC)
            );
        ORIGINATE_WIN32_FAILURE_AND_EXIT(InternalErrorNoCaseForInfoClass, ERROR_INTERNAL_ERROR);
        break;

    case SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC:
        IFW32FALSE_EXIT(
            ::SxspQueryManifestInformationBasic(
                dwFlags,
                pszSource,
                dwInfoClassSpecificFlags,
                cbBuffer,
                lpBuffer,
                pcbWrittenOrRequired));
        break;
    }

    FN_EPILOG
}

BOOL
SxspQueryManifestInformationBasic(
    IN DWORD dwFlags,
    IN PCWSTR pszSource,
    IN DWORD dwInfoClassSpecificFlags,
    IN SIZE_T cbBuffer,
    OUT PVOID lpBuffer,
    OUT PSIZE_T pcbWrittenOrRequired OPTIONAL
    )
{
    FN_PROLOG_WIN32

    ACTCTXGENCTX ActCtxGenCtx;
    ULONG ManifestFlags;
    CImpersonationData ImpersonationData;
    PCWSTR Slash = NULL;
    CSmartRef<ASSEMBLY> Asm;
    CStringBuffer buffManifestPath;
    USHORT ProcessorArchitecture = ::SxspGetSystemProcessorArchitecture();
    LANGID LangId = ::GetUserDefaultUILanguage();
    SIZE_T cch, cchRequired;
    SIZE_T cbRequired, cbLeft, cbWritten;
    PCASSEMBLY_IDENTITY AssemblyIdentity = NULL;
    CStringBuffer buffShortName;
    PWSTR Cursor;
    PSXS_MANIFEST_INFORMATION_BASIC psmib;
    CResourceStream DllStream;
    CFileStream FileStream;
    IStream* pStream = NULL;

    if (pcbWrittenOrRequired != NULL)
        *pcbWrittenOrRequired = 0;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(pszSource != NULL);
    PARAMETER_CHECK((dwInfoClassSpecificFlags & ~(
        SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_IDENTITY |
        SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME)) == 0);
    PARAMETER_CHECK((cbBuffer == 0) || (lpBuffer != NULL));
    PARAMETER_CHECK((cbBuffer != 0) || (pcbWrittenOrRequired != NULL));

    //
    // If this is a DLL source, then ensure that the flags are zero (in this rev, that's all that's allowed).
    //
    if (dwFlags & SXS_QUERY_MANIFEST_INFORMATION_FLAG_SOURCE_IS_DLL)
    {
        PCSXS_MANIFEST_INFORMATION_SOURCE_DLL pDllSource = (PCSXS_MANIFEST_INFORMATION_SOURCE_DLL)pszSource;
        const DWORD dwValidFlags = 
            SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_LANGUAGE_VALID | 
            SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_TYPE_VALID |
            SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_ID_VALID;

        PARAMETER_CHECK((pDllSource->dwFlags & ~dwValidFlags) == 0);
        PARAMETER_CHECK(pDllSource->pcwszDllPath != NULL);
        PARAMETER_CHECK(((pDllSource->dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_LANGUAGE_VALID) == 0) || (pDllSource->Language != 0));
        PARAMETER_CHECK(((pDllSource->dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_TYPE_VALID) == 0) || (pDllSource->pcwszResourceType != NULL));
        PARAMETER_CHECK(((pDllSource->dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_ID_VALID) == 0) || (pDllSource->pcwszResourceName != NULL));
    }

    //
    // Smarter than the average bear - knows how to handle string buffers and full
    // paths.
    //
    IFW32FALSE_EXIT(::SxspGetFullPathName(pszSource, buffManifestPath, NULL));

    IFW32FALSE_EXIT(
        ::SxspInitActCtxGenCtx(
                &ActCtxGenCtx,         // context out
                MANIFEST_OPERATION_VALIDATE_SYNTAX,
                0,
                0,
                ImpersonationData,
                ProcessorArchitecture,
                LangId,
                ACTIVATION_CONTEXT_PATH_TYPE_NONE,
                0,
                NULL));

    IFALLOCFAILED_EXIT(Asm = new ASSEMBLY);

    {
        CProbedAssemblyInformation AssemblyInformation;

        //
        // For DLL sources, tease apart the version and whatnot from the
        // structure passed in.
        //
        if (dwFlags & SXS_QUERY_MANIFEST_INFORMATION_FLAG_SOURCE_IS_DLL)
        {
            PCSXS_MANIFEST_INFORMATION_SOURCE_DLL pcSourceInfo = (PCSXS_MANIFEST_INFORMATION_SOURCE_DLL)pszSource;
            IFW32FALSE_EXIT(SxspGetFullPathName(pcSourceInfo->pcwszDllPath, buffManifestPath, NULL));

            //
            // Default action... just go use the normal "find the first in the dll" thing
            //
            if (pcSourceInfo->dwFlags == 0)
            {
                IFW32FALSE_EXIT(DllStream.Initialize(buffManifestPath, (PCWSTR)RT_MANIFEST));
            }
            else
            {
                IFW32FALSE_EXIT(
                    DllStream.Initialize(
                        buffManifestPath, 
                        ((pcSourceInfo->dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_TYPE_VALID) ? pcSourceInfo->pcwszResourceType : (PCWSTR)RT_MANIFEST),
                        ((pcSourceInfo->dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_ID_VALID) ? pcSourceInfo->pcwszResourceName :  NULL),
                        ((pcSourceInfo->dwFlags & SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_LANGUAGE_VALID) ? (WORD)pcSourceInfo->Language : (WORD)MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))));
            }
              
            pStream = &DllStream;
        }
        //
        // Otherwise, dumb file.
        //
        else
        {
            IFW32FALSE_EXIT(SxspGetFullPathName(pszSource, buffManifestPath, NULL));
            IFW32FALSE_EXIT(
                FileStream.OpenForRead(
                    buffManifestPath, 
                    CImpersonationData(),
                    FILE_SHARE_READ,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL));
            pStream = &FileStream;
        }

        ManifestFlags = ASSEMBLY_MANIFEST_FILETYPE_STREAM;            
        IFW32FALSE_EXIT(AssemblyInformation.Initialize(&ActCtxGenCtx));
        IFW32FALSE_EXIT(AssemblyInformation.SetManifestFlags(ManifestFlags));
        IFW32FALSE_EXIT(AssemblyInformation.SetManifestStream(pStream));
        IFW32FALSE_EXIT(AssemblyInformation.SetManifestPath(ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE, buffManifestPath));
        IFW32FALSE_EXIT(AssemblyInformation.SetManifestLastWriteTime(ImpersonationData));
        IFW32FALSE_EXIT(SxspInitAssembly(Asm, AssemblyInformation));

        //
        // The assembly information now owns the stream
        //
        pStream->Release();
    }

    Asm->m_AssemblyRosterIndex = 1; // set it to be the root...
    IFW32FALSE_EXIT(::SxspIncorporateAssembly(&ActCtxGenCtx, Asm));
    IFW32FALSE_EXIT(::SxspFireActCtxGenEnding(&ActCtxGenCtx));

    AssemblyIdentity = Asm->m_ProbedAssemblyInformation.GetAssemblyIdentity();

    cchRequired = 0;

    if ((dwInfoClassSpecificFlags & SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_IDENTITY) == 0)
    {
        SIZE_T TextuallyEncodedIdentityBufferBytes = 0;

        IFW32FALSE_EXIT(
            ::SxsComputeAssemblyIdentityEncodedSize(
                0,
                AssemblyIdentity,
                NULL,
                SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
                &TextuallyEncodedIdentityBufferBytes));
        INTERNAL_ERROR_CHECK((TextuallyEncodedIdentityBufferBytes % sizeof(WCHAR)) == 0);

        cchRequired += ((TextuallyEncodedIdentityBufferBytes / sizeof(WCHAR)) + 1);
    }

    if ((dwInfoClassSpecificFlags & SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME) == 0)
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                NULL, 0,
                AssemblyIdentity,
                NULL,
                buffShortName));

        cchRequired += (buffShortName.Cch() + 1);
    }

    // GENERAL REVIEW: What does this do with alignment on ia64?  Shouldn't we pad out to
    // the next N bytes?
    //
    cbRequired = sizeof(SXS_MANIFEST_INFORMATION_BASIC) + (cchRequired * sizeof(WCHAR));

    if (cbRequired > cbBuffer)
    {
		if (pcbWrittenOrRequired != NULL)
			*pcbWrittenOrRequired = cbRequired;

        ORIGINATE_WIN32_FAILURE_AND_EXIT(BufferTooSmall, ERROR_INSUFFICIENT_BUFFER);
    }

    psmib = (PSXS_MANIFEST_INFORMATION_BASIC) lpBuffer;

    psmib->lpIdentity = NULL;
    psmib->lpShortName = NULL;
    psmib->ulFileCount = ActCtxGenCtx.m_ulFileCount;

    Cursor = (PWSTR) (psmib + 1);
    cbLeft = (cbBuffer - sizeof(SXS_MANIFEST_INFORMATION_BASIC));
    cbWritten = sizeof(SXS_MANIFEST_INFORMATION_BASIC);

    if ((dwInfoClassSpecificFlags & SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_IDENTITY) == 0)
    {
        SIZE_T cbActual;

        IFW32FALSE_EXIT(
            ::SxsEncodeAssemblyIdentity(
                0,
                AssemblyIdentity,
                NULL,
                SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
                cbLeft,
                Cursor,
                &cbActual));

        INTERNAL_ERROR_CHECK((cbActual % sizeof(WCHAR)) == 0);
        INTERNAL_ERROR_CHECK(cbLeft >= cbActual);

        psmib->lpIdentity = Cursor;

        cbLeft -= cbActual;
        cbWritten += cbActual;

        Cursor = (PWSTR) (((ULONG_PTR) Cursor) + cbActual);

        INTERNAL_ERROR_CHECK(cbLeft >= sizeof(WCHAR));

        *Cursor++ = L'\0';
        cbLeft -= sizeof(WCHAR);
        cbWritten += sizeof(WCHAR);
    }

    if ((dwInfoClassSpecificFlags & SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME) == 0)
    {
        cch = buffShortName.Cch();

        INTERNAL_ERROR_CHECK(cbLeft >= ((cch + 1) * sizeof(WCHAR)));

        memcpy(Cursor, static_cast<PCWSTR>(buffShortName), (cch + 1) * sizeof(WCHAR));
        psmib->lpShortName = Cursor;

        cbLeft -= ((cch + 1) * sizeof(WCHAR));
        cbWritten += ((cch + 1) * sizeof(WCHAR));

        Cursor += (cch + 1);
    }

    if (pcbWrittenOrRequired != NULL)
        *pcbWrittenOrRequired = cbWritten;

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\simplefp.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    SimpleFp.h

Abstract:

    simple FILE*, instead of msvcrt.dll

Author:

    Xiaoyu Wu(xiaoyuw) July 2000

Revision History:

--*/
#pragma once

#if SXS_PRECOMPILED_MANIFESTS_ENABLED

#include <stdio.h>

class CSimpleFileStream
{
public:
    HRESULT fopen(PCWSTR pFileName); // can be a file name, "stderr", "stdout"
    HRESULT fclose();
    static HRESULT printf(const WCHAR *format, ...)
    {
        HRESULT hr = NOERROR;
        va_list ap;
        WCHAR rgchBuffer[2048];
        int cch;
        DWORD cchWritten;

        va_start(ap, format);
        cch = ::_vsnwprintf(rgchBuffer, NUMBER_OF(rgchBuffer), format, ap);
        rgchBuffer[NUMBER_OF(rgchBuffer) - 1] = 0;
        va_end(ap);
        if (cch < 0) {// error case
            // NTRAID#NTBUG9 - 591008 - 2002/03/30 - mgrier - error code should have something
            //      to do with the errno value
            hr = E_UNEXPECTED;
            goto Exit;
        }

        // NTRAID#NTBUG9 - 591008 - 2002/03/30 - mgrier - Missing error check from GetStdHandle call
        if( !::WriteConsole(::GetStdHandle(STD_ERROR_HANDLE), rgchBuffer, cch, &cchWritten, NULL))
        {
            DWORD dwError = ::FusionpGetLastWin32Error();
            hr = HRESULT_FROM_WIN32(dwError);
            goto Exit;
        }

        hr = NOERROR;
Exit :
        return hr;
     }

    HRESULT fprintf(const char *format, ...);
    HRESULT fwrite(const VOID*, SIZE_T, SIZE_T);

    CSimpleFileStream(PCWSTR pFileName);
    ~CSimpleFileStream();

private:
    HANDLE m_hFile;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\simplefp.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    SimpleFp.cpp

Abstract:

    simple file pointer, to replace msvcrt.dll

Author:

    Xiaoyu Wu(xiaoyuw) July 2000

Revision History:

--*/
#include "stdinc.h"
#if SXS_PRECOMPILED_MANIFESTS_ENABLED
#include "simplefp.h"
#include "fusiontrace.h"
#include "csxspreservelasterror.h"
#include "util.h"

// NTRAID#NTBUG9 - 591005 - 2002/03/30 - mgrier - Operations which may fail may not be in a constructor
CSimpleFileStream::CSimpleFileStream(PCWSTR pFileName)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (!pFileName)
    {
        // duplicate it so we can close it like normal
        // NTRAID#NTBUG9 - 591005 - 2002/03/30 - mgrier - Missing error check from GetStdHandle
        HANDLE hFile = ::GetStdHandle(STD_ERROR_HANDLE);
        IFW32FALSE_ORIGINATE_AND_EXIT(::DuplicateHandle(::GetCurrentProcess(), hFile, ::GetCurrentProcess(), &m_hFile, 0, FALSE, DUPLICATE_SAME_ACCESS));
    }
    else
    {
        IFCOMFAILED_EXIT(this->fopen(pFileName));
    }
    fSuccess = FALSE;
Exit:
    ;
}

CSimpleFileStream::~CSimpleFileStream()
{
    if ( m_hFile != INVALID_HANDLE_VALUE) // if it is GetStdHandle, Could I close the handle?
    {
        CSxsPreserveLastError ple;
        this->fclose();
        ple.Restore();
    }
}

HRESULT
CSimpleFileStream::fopen(
    PCWSTR pFileName
    )
{
    FN_PROLOG_HR

    if (m_hFile != INVALID_HANDLE_VALUE)
        IFCOMFAILED_EXIT(this->fclose());

    INTERNAL_ERROR_CHECK(m_hFile == INVALID_HANDLE_VALUE);

    IFW32INVALIDHANDLE_ORIGINATE_AND_EXIT(
        m_hFile = ::CreateFileW(
            pFileName,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            0,
            NULL));

    FN_EPILOG
}

HRESULT
CSimpleFileStream::fclose()
{
    FN_PROLOG_HR
    HANDLE hFile;

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);

    hFile = m_hFile;
    m_hFile = INVALID_HANDLE_VALUE;
    IFW32FALSE_ORIGINATE_AND_EXIT(::CloseHandle(hFile));

    FN_EPILOG
}

HRESULT
CSimpleFileStream::fprintf(
    const char *format,
    ...
    )
{
    FN_PROLOG_HR
    va_list ap;
    char rgchBuffer[2048];
    int cchIn = 0;
    DWORD cchWritten = 0;

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);

    va_start(ap, format);

    cchIn = _vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer) - 1, format, ap);
    rgchBuffer[NUMBER_OF(rgchBuffer) - 1] = 0;
    va_end(ap);
    // NTRAID#NTBUG9 - 591005 - 2002/03/30 - mgrier - this should be an origination and we should
    //      probably use errno to generate a more useful error code.
    if (cchIn < 0)
        IFCOMFAILED_EXIT(E_UNEXPECTED);

    IFW32FALSE_ORIGINATE_AND_EXIT(::WriteFile(m_hFile, rgchBuffer, cchIn, &cchWritten, NULL));

    FN_EPILOG
}

HRESULT CSimpleFileStream::fwrite(const VOID* pData, SIZE_T itemsize, SIZE_T itemcount)
{
    FN_PROLOG_HR
    SIZE_T count = 0;
    DWORD ByteWritten = 0;

    INTERNAL_ERROR_CHECK(m_hFile != INVALID_HANDLE_VALUE);

    count = itemsize * itemcount;

    while (count > ULONG_MAX)
    {
        IFW32FALSE_ORIGINATE_AND_EXIT(::WriteFile(m_hFile, pData, ULONG_MAX, &ByteWritten, NULL));
        count -= ULONG_MAX;
        pData = (const void *) (((ULONG_PTR) pData) + ULONG_MAX);
    }

    if (count != 0)
    {
        IFW32FALSE_ORIGINATE_AND_EXIT(::WriteFile(m_hFile, pData, static_cast<DWORD>(count), &ByteWritten, NULL));
    }

    FN_EPILOG
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\recover.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "xmlparser.hxx"
#include "fusioneventlog.h"
#include "hashfile.h"
#include "cassemblyrecoveryinfo.h"
#include "recover.h"
#include "sxsprotect.h"
#include "fusionheap.h"
#include "fusionparser.h"
#include "protectionui.h"
#include "msi.h"
#include "sxsp.h"
#include "sxscabinet.h"

class CSetErrorMode
{
public:
    CSetErrorMode(UINT uMode) { m_uiPreviousMode = ::SetErrorMode(uMode); }
    ~CSetErrorMode() { ::SetErrorMode(m_uiPreviousMode); }

private:
    UINT m_uiPreviousMode;

    CSetErrorMode();
    CSetErrorMode(const CSetErrorMode &r);
    void operator =(const CSetErrorMode &r);
};

BOOL
SxspOpenAssemblyInstallationKey(
    DWORD dwFlags,
    DWORD dwAccess,
    CRegKey &rhkAssemblyInstallation
    )
{
    FN_PROLOG_WIN32

    rhkAssemblyInstallation = CRegKey::GetInvalidValue();

    PARAMETER_CHECK(dwFlags == 0);

    IFREGFAILED_ORIGINATE_AND_EXIT(
        ::RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            WINSXS_INSTALLATION_INFO_REGKEY,
            0, NULL,
            0,
            dwAccess | FUSIONP_KEY_WOW64_64KEY,
            NULL,
            &rhkAssemblyInstallation ,
            NULL));

    FN_EPILOG
    
}

//
// BUGBUG: The BBT folk need the 'codebase' key to be at the top level.
//   Why we're shipping metadata that's only required for an internal
//   build tool is beyond my meager understanding.
//   - jonwis 07/11/2002
//
#define SXS_BBT_REG_HACK (TRUE)


BOOL
SxspAddAssemblyInstallationInfo(
    DWORD dwFlags, 
    IN CAssemblyRecoveryInfo& AssemblyInfo,
    IN const CCodebaseInformation& rcCodebase
    )
/*++

Called by SxsInstallAssemblyW to add the codebase and prompt information to the
registry for future use with SxspGetAssemblyInstallationInfoW.

--*/
{
    FN_PROLOG_WIN32

    CFusionRegKey   hkAllInstallationInfo;
    CFusionRegKey   hkSingleAssemblyInfo;
    CStringBuffer   buffRegKeyName;
    const CSecurityMetaData &rcsmdAssemblySecurityData = AssemblyInfo.GetSecurityInformation();
    const CBaseStringBuffer &rcbuffAssemblyIdentity = rcsmdAssemblySecurityData.GetTextualIdentity();
    ULONG WriteRegFlags = 0;
    DWORD dwDisposition = 0;

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS: %s - starting\n", __FUNCTION__);

    PARAMETER_CHECK((dwFlags & ~(SXSP_ADD_ASSEMBLY_INSTALLATION_INFO_FLAG_REFRESH)) == 0);

    if (SXS_AVOID_WRITING_REGISTRY)
        FN_SUCCESSFUL_EXIT();

    //
    // Create or open the top-level key - take our name and append the
    // key to it.
    //
    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(0, KEY_CREATE_SUB_KEY, hkAllInstallationInfo));

    //
    // Convert back to an identity so we can figure out where to install this data to
    //
    IFW32FALSE_EXIT(::SxspGenerateAssemblyNameInRegistry(rcbuffAssemblyIdentity, buffRegKeyName));

    IFW32FALSE_EXIT(
        hkAllInstallationInfo.OpenOrCreateSubKey(
            hkSingleAssemblyInfo,
            buffRegKeyName,
            KEY_WRITE | KEY_READ | FUSIONP_KEY_WOW64_64KEY,
            0,
            &dwDisposition));

    if (dwFlags & SXSP_ADD_ASSEMBLY_INSTALLATION_INFO_FLAG_REFRESH)
    {
        WriteRegFlags |= SXSP_WRITE_PRIMARY_ASSEMBLY_INFO_TO_REGISTRY_KEY_FLAG_REFRESH;
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s - propping recovery flag to WritePrimaryAssemblyInfoToRegistryKey\n",
            __FUNCTION__);
#endif
    }

    IFW32FALSE_EXIT(AssemblyInfo.PrepareForWriting());
    // NTRAID#NTBUG9 - 589798 - 2002/03/26 - xiaoyuw:
    // there is no reason to make two functions(Primary Secondary)    
    IFW32FALSE_EXIT(AssemblyInfo.WritePrimaryAssemblyInfoToRegistryKey(WriteRegFlags, hkSingleAssemblyInfo));    
    IFW32FALSE_EXIT(AssemblyInfo.WriteSecondaryAssemblyInfoIntoRegistryKey( hkSingleAssemblyInfo ) );

    //
    // If we got this far, then we've got all the right moves.
    //

//
// Are we still being broken for BBT?  If so, then write the codebase generated for this
// installation back into the "Codebase" value of the single-assembly-info key.  This
// ensures last-installer-wins semantic.
//
#if SXS_BBT_REG_HACK
    if ((dwFlags & SXSP_ADD_ASSEMBLY_INSTALLATION_INFO_FLAG_REFRESH) == 0)
    {
        IFW32FALSE_EXIT(hkSingleAssemblyInfo.SetValue(
            CSMD_TOPLEVEL_CODEBASE,
            rcCodebase.GetCodebase()));
    }
    else
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s - refresh/wfp/sfc not writing top level codebase\n",
            __FUNCTION__);
#endif
    }
#endif

    FN_EPILOG
}

BOOL
SxspLookForCDROMLocalPathForURL(
    IN const CBaseStringBuffer &rbuffURL,
    OUT CBaseStringBuffer &rbuffLocalPath
    )
{
    FN_PROLOG_WIN32

    BOOL fFoundMedia = FALSE;
    CSmallStringBuffer sbIdentData1;
    CSmallStringBuffer sbIdentData2;
    CSmallStringBuffer buffDriveStrings;
    CSmallStringBuffer buffTemp;
    CStringBufferAccessor acc;
    SIZE_T HeadLength = 0;
    PCWSTR wcsCursor = NULL;
    ULONG ulSerialNumber = 0;
    WCHAR rgchVolumeName[MAX_PATH];
    rgchVolumeName[0] = 0;
    SIZE_T i = 0;
    PCWSTR pszSource = rbuffURL;
    SIZE_T cchTemp = 0;

    enum CDRomSearchType
    {
        CDRST_Tagfile,
        CDRST_SerialNumber,
        CDRST_VolumeName
    } SearchType;


    rbuffLocalPath.Clear();

#define ENTRY(_x, _st) { _x, NUMBER_OF(_x) - 1, _st },

    const static struct
    {
        PCWSTR pszPrefix;
        SIZE_T cchPrefix;
        CDRomSearchType SearchType;
    } s_rgMap[] =
    {
        ENTRY(L"tagfile", CDRST_Tagfile)
        ENTRY(L"serialnumber", CDRST_SerialNumber)
        ENTRY(L"volumename", CDRST_VolumeName)
    };

#undef ENTRY

    SearchType = CDRST_Tagfile; // arbitrary initialization to make compiler happy about init only
                                // occurring in the for loop

    for (i=0; i<NUMBER_OF(s_rgMap); i++)
    {
        if (::_wcsnicmp(s_rgMap[i].pszPrefix, rbuffURL, s_rgMap[i].cchPrefix) == 0)
        {
            HeadLength = s_rgMap[i].cchPrefix;
            SearchType = s_rgMap[i].SearchType;
            break;
        }
    }

    // If it wasn't in the map, it's a bogus cdrom: url so we just skip it.
    if (i == NUMBER_OF(s_rgMap))
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS.DLL: %s() - no prefix found, skipping CDROM Drive %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(rbuffURL));
#endif
        FN_SUCCESSFUL_EXIT();
    }

    //
    // Get the type of identifier here, and then move the cursor past them and
    // the slashes in the url.
    //
    pszSource += HeadLength;
    pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());

    //
    // Spin past slashes, assign chunklets
    //
    IFW32FALSE_EXIT(sbIdentData1.Win32Assign(pszSource, wcscspn(pszSource, CUnicodeCharTraits::PathSeparators())));
    pszSource += sbIdentData1.Cch();
    pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());

    //
    // If this is a tagfile, also get another blobbet of data off the string
    //
    if (SearchType == CDRST_Tagfile)
    {
        IFW32FALSE_EXIT(sbIdentData2.Win32Assign(pszSource, wcscspn(pszSource, CUnicodeCharTraits::PathSeparators())));
        pszSource += sbIdentData2.Cch();
        pszSource += wcsspn(pszSource, CUnicodeCharTraits::PathSeparators());
    }
    else if (SearchType == CDRST_SerialNumber)
    {
        IFW32FALSE_EXIT(CFusionParser::ParseULONG(
            ulSerialNumber,
            sbIdentData1,
            sbIdentData1.Cch(),
            16));
    }

    // Find the CDROM drives...

    IFW32ZERO_ORIGINATE_AND_EXIT(cchTemp = ::GetLogicalDriveStringsW(0, NULL));
    IFW32FALSE_EXIT(buffDriveStrings.Win32ResizeBuffer(cchTemp + 1, eDoNotPreserveBufferContents));

    acc.Attach(&buffDriveStrings);

    IFW32ZERO_ORIGINATE_AND_EXIT(
        ::GetLogicalDriveStringsW(
            acc.GetBufferCchAsDWORD(),
            acc));

    acc.Detach();

    wcsCursor = buffDriveStrings;

    //
    // Look at all the found drive letters
    //
    while ((wcsCursor != NULL) &&
           (wcsCursor[0] != L'\0') &&
           !fFoundMedia)
    {
        DWORD dwSerialNumber = 0;
        const UINT uiDriveType = ::GetDriveTypeW(wcsCursor);

        if (uiDriveType != DRIVE_CDROM)
        {
            wcsCursor += (::wcslen(wcsCursor) + 1);
            continue;
        }

        CSetErrorMode sem(SEM_FAILCRITICALERRORS);
        bool fNotReady = false;

        IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS2(
            ::GetVolumeInformationW(
                wcsCursor,
                rgchVolumeName,
                NUMBER_OF(rgchVolumeName),
                &dwSerialNumber,
                NULL,
                NULL,
                NULL,
                0),
            LIST_2(ERROR_NOT_READY, ERROR_CRC),
            fNotReady);

        if (fNotReady)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS.DLL: %s() - CDROM Drive %ls has no media present or had read errors; skipping\n",
                __FUNCTION__,
                wcsCursor);

            // skip past this drive
            wcsCursor += (::wcslen(wcsCursor) + 1);
            continue;
        }

        switch (SearchType)
        {
        case CDRST_Tagfile:
            {
                CFusionFile     FileHandle;
                CStringBufferAccessor acc;
                DWORD           dwTextLength = 0;
                bool fNoFile = false;
                CHAR rgchBuffer[32];
                rgchBuffer[0] = 0;

                IFW32FALSE_EXIT_UNLESS2(
                    FileHandle.Win32CreateFile(
                        sbIdentData1,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        OPEN_EXISTING),
                    LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_NOT_READY),
                    fNoFile);

                if (fNoFile)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP,
                        "SXS.DLL: %s() - CDROM Drive %ls could not open tag file \"%ls\"; skipping\n",
                        __FUNCTION__,
                        wcsCursor,
                        static_cast<PCWSTR>(sbIdentData1));

                    // skip past this drive
                    wcsCursor += (::wcslen(wcsCursor) + 1);
                    continue;
                }

                buffTemp.Clear();

                for (;;)
                {
                    IFW32FALSE_ORIGINATE_AND_EXIT(
                        ::ReadFile(
                            FileHandle,
                            rgchBuffer,
                            sizeof(rgchBuffer),
                            &dwTextLength,
                            NULL));

                    IFW32FALSE_EXIT(buffTemp.Win32Append(rgchBuffer, dwTextLength));

                    if ((dwTextLength != sizeof(rgchBuffer)) ||
                        (buffTemp.Cch() > sbIdentData2.Cch()))
                        break;
                }

                fFoundMedia = (::FusionpCompareStrings(buffTemp, sbIdentData2, true) == 0);

                break;
            }
        case CDRST_SerialNumber:
            fFoundMedia = (dwSerialNumber == ulSerialNumber);
            break;

        case CDRST_VolumeName:
            fFoundMedia = (::FusionpCompareStrings(rgchVolumeName, ::wcslen(rgchVolumeName), sbIdentData1, true) == 0);
            break;

        default:
            INTERNAL_ERROR_CHECK(false);
            break;
        }

        if (!fFoundMedia)
            wcsCursor += ::wcslen(wcsCursor) + 1;
    }

    if (fFoundMedia)
    {
        IFW32FALSE_EXIT(buffTemp.Win32Assign(wcsCursor, ::wcslen(wcsCursor)));
        IFW32FALSE_EXIT(buffTemp.Win32AppendPathElement(pszSource, ::wcslen(pszSource)));
        IFW32FALSE_EXIT(rbuffLocalPath.Win32Assign(buffTemp));
    }

    FN_EPILOG
}

BOOL
SxspResolveWinSourceMediaURL(
    const CBaseStringBuffer &rbuffCodebaseInfo,
    CBaseStringBuffer &rbuffLocalPath
    )
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffWindowsInstallSource;
    CSmallStringBuffer buffLocalPathTemp;
#if DBG
    CSmallStringBuffer buffLocalPathCodebasePrefix;
#endif
    DWORD dwWin32Error = 0;
    DWORD dwFileAttributes = 0;

    const static PCWSTR AssemblySourceStrings[] = {
        WINSXS_INSTALL_SVCPACK_REGKEY,
        WINSXS_INSTALL_SOURCEPATH_REGKEY
    };

    SIZE_T iWhichSource = 0;
    bool fFoundCodebase = false;
    CFusionRegKey hkSetupInfo;
    DWORD dwWasFromCDRom = 0;

    rbuffLocalPath.Clear();

    IFREGFAILED_ORIGINATE_AND_EXIT(
        ::RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            WINSXS_INSTALL_SOURCE_BASEDIR,
            0,
            KEY_READ | FUSIONP_KEY_WOW64_64KEY,
            &hkSetupInfo));

    if (!::FusionpRegQueryDwordValueEx(
            0,
            hkSetupInfo,
            WINSXS_INSTALL_SOURCE_IS_CDROM,
            &dwWasFromCDRom))
    {
        dwWasFromCDRom = 0;
    }

    for (iWhichSource = 0; (!fFoundCodebase) && iWhichSource < NUMBER_OF(AssemblySourceStrings); iWhichSource++)
    {
        IFW32FALSE_EXIT(
            ::FusionpRegQuerySzValueEx(
                FUSIONP_REG_QUERY_SZ_VALUE_EX_MISSING_GIVES_NULL_STRING,
                hkSetupInfo,
                AssemblySourceStrings[iWhichSource],
                buffWindowsInstallSource));

        //
        // This really _really_ should not be empty.  If it is, then someone
        // went and fiddled with the registry on us.
        //
        if (buffWindowsInstallSource.Cch() == 0)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - skipping use of source string \"%ls\" in registry because either missing or null value\n",
                __FUNCTION__,
                AssemblySourceStrings[iWhichSource]);

            continue;
        }

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS: %s - WFP probing windows source location \"%ls\"\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffWindowsInstallSource));

        //
        // If this was from a CD, then spin through the list of CD's in the system
        // and see if we can match the codebase against the root dir of the CD
        //
        if (dwWasFromCDRom)
        {
            CSmallStringBuffer buffDriveStrings;
            CStringBufferAccessor acc;
            PCWSTR pszCursor = NULL;
            SIZE_T cchTemp = 0;

            IFW32ZERO_EXIT(cchTemp = ::GetLogicalDriveStringsW(0, NULL));
            IFW32FALSE_EXIT(buffDriveStrings.Win32ResizeBuffer(cchTemp + 1, eDoNotPreserveBufferContents));

            acc.Attach(&buffDriveStrings);

            IFW32ZERO_EXIT(
                ::GetLogicalDriveStringsW(
                    acc.GetBufferCchAsDWORD(),
                    acc.GetBufferPtr()));

            acc.Detach();

            pszCursor = buffDriveStrings;

            while (pszCursor[0] != L'\0')
            {
                if (::GetDriveTypeW(pszCursor) == DRIVE_CDROM)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP,
                        "SXS: %s - Scanning CDROM drive \"%ls\" for windows source media\n",
                        __FUNCTION__,
                        pszCursor);

                    IFW32FALSE_EXIT(buffLocalPathTemp.Win32Assign(pszCursor, ::wcslen(pszCursor)));
                    IFW32FALSE_EXIT(buffLocalPathTemp.Win32AppendPathElement(rbuffCodebaseInfo));

                    IFW32FALSE_EXIT(
                        ::SxspGetFileAttributesW(
                            buffLocalPathTemp,
                            dwFileAttributes,
                            dwWin32Error,
                            4,
                            ERROR_FILE_NOT_FOUND,
                            ERROR_PATH_NOT_FOUND,
                            ERROR_NOT_READY,
                            ERROR_ACCESS_DENIED));

                    if (dwWin32Error == ERROR_SUCCESS)
                    {
#if DBG
                        buffLocalPathCodebasePrefix.Win32Assign(pszCursor, ::wcslen(pszCursor));
#endif
                        fFoundCodebase = true;
                        break;
                    }

                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP,
                        "SXS: %s - Could not find key file \"%ls\"; moving on to next drive\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(buffLocalPathTemp));
                }

                pszCursor += ::wcslen(pszCursor) + 1;
            }

            if (fFoundCodebase)
                break;

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - Could not find any CDROMs with key file \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(rbuffCodebaseInfo));

            buffLocalPathTemp.Clear();
        }
        else
        {
            //
            // This wasn't a CD-rom installation, so prepend the install source path to
            // the string that was passed in.
            //

            IFW32FALSE_EXIT(buffLocalPathTemp.Win32Assign(buffWindowsInstallSource));
            IFW32FALSE_EXIT(buffLocalPathTemp.Win32AppendPathElement(rbuffCodebaseInfo));

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - trying to access windows source file \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffLocalPathTemp));

            IFW32FALSE_EXIT(
                ::SxspGetFileAttributesW(
                    buffLocalPathTemp,
                    dwFileAttributes,
                    dwWin32Error,
                    4,
                    ERROR_FILE_NOT_FOUND,
                    ERROR_PATH_NOT_FOUND,
                    ERROR_NOT_READY,
                    ERROR_ACCESS_DENIED));

            if (dwWin32Error == ERROR_SUCCESS)
            {
#if DBG
                buffLocalPathCodebasePrefix.Win32Assign(buffWindowsInstallSource);
#endif
                fFoundCodebase = true;
                break;
            }

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - Unable to find key file \"%ls\"; win32 status = %lu\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffLocalPathTemp),
                dwWin32Error);

            buffLocalPathTemp.Clear();
        }
        if (fFoundCodebase)
            break;
    }

    IFW32FALSE_EXIT(rbuffLocalPath.Win32Assign(buffLocalPathTemp));

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS: %s - buffLocalPathCodebasePrefix \"%ls\" and returning rbuffLocalPath \"%ls\"\n",
        __FUNCTION__,
        static_cast<PCWSTR>(buffLocalPathCodebasePrefix),
        static_cast<PCWSTR>(rbuffLocalPath)
        );
#endif

    FN_EPILOG
}


#define SXSP_REPEAT_UNTIL_LOCAL_PATH_AVAILABLE_FLAG_UI (0x00000001)

BOOL
SxspRepeatUntilLocalPathAvailable(
    IN ULONG Flags,
    IN const CAssemblyRecoveryInfo &rRecoveryInfo,
    IN const CCodebaseInformation  *pCodeBaseIn,
    IN SxsWFPResolveCodebase CodebaseType,
    IN const CBaseStringBuffer &rbuffCodebaseInfo,
    OUT CBaseStringBuffer &rbuffLocalPath,
    OUT BOOL              &fRetryPressed
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    BOOL fCodebaseOk = FALSE;
    CSmallStringBuffer buffFinalLocalPath;
    DWORD dwAttributes = 0;

    PARAMETER_CHECK(pCodeBaseIn != NULL);

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS: %s - got codebase \"%ls\"\n",
        __FUNCTION__,
        static_cast<PCWSTR>(pCodeBaseIn->GetCodebase()));

    rbuffLocalPath.Clear();
    fRetryPressed = FALSE;


    PARAMETER_CHECK(
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_FILE) ||
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_WINSOURCE) ||
        (CodebaseType == CODEBASE_RESOLVED_URLHEAD_CDROM));

    PARAMETER_CHECK((Flags & ~(SXSP_REPEAT_UNTIL_LOCAL_PATH_AVAILABLE_FLAG_UI)) == 0);

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS: %s() CodebaseType : %s (0x%lx)\n",
            __FUNCTION__,
            (CodebaseType == CODEBASE_RESOLVED_URLHEAD_FILE) ? "file"
            : (CodebaseType == CODEBASE_RESOLVED_URLHEAD_WINSOURCE) ? "winsource"
            : (CodebaseType == CODEBASE_RESOLVED_URLHEAD_CDROM) ? "cdrom"
            : "",
            static_cast<ULONG>(CodebaseType)
        );
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS: %s() rbuffCodebaseInfo : %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(rbuffCodebaseInfo)
        );
#endif

    for (;;)
    {
        bool fNotFound = true;

        // First, let's see if we have to do any trickery.
        switch (CodebaseType)
        {
        case CODEBASE_RESOLVED_URLHEAD_CDROM:
            IFW32FALSE_EXIT(
                ::SxspLookForCDROMLocalPathForURL(
                    rbuffCodebaseInfo,
                    buffFinalLocalPath));

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - cdrom: URL resolved to \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffFinalLocalPath));

            break;

        case CODEBASE_RESOLVED_URLHEAD_WINSOURCE:
            IFW32FALSE_EXIT(
                ::SxspResolveWinSourceMediaURL(
                    rbuffCodebaseInfo,
                    buffFinalLocalPath));

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - windows source URL resolved to \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffFinalLocalPath));

            break;

        case CODEBASE_RESOLVED_URLHEAD_FILE:
            IFW32FALSE_EXIT(buffFinalLocalPath.Win32Assign(rbuffCodebaseInfo));

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - file: URL resolved to \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(buffFinalLocalPath));

            break;
        }

        if (buffFinalLocalPath.Cch() != 0)
        {
            DWORD dwWin32Error = NO_ERROR;

            IFW32FALSE_EXIT(
                ::SxspGetFileAttributesW(
                    buffFinalLocalPath,
                    dwAttributes,
                    dwWin32Error,
                    5,
                        ERROR_PATH_NOT_FOUND,
                        ERROR_FILE_NOT_FOUND,
                        ERROR_BAD_NET_NAME,
                        ERROR_BAD_NETPATH,
                        ERROR_ACCESS_DENIED));

            if (dwWin32Error == ERROR_SUCCESS)
                break;
        }

        if ((Flags & SXSP_REPEAT_UNTIL_LOCAL_PATH_AVAILABLE_FLAG_UI) == 0)
        {
            buffFinalLocalPath.Clear();
            break;
        }

        //
        // Nope, didn't find it (or the codebase specified is gone.  Ask the user
        // to insert media or whatnot so we can find it again.
        //
        if (fNotFound)
        {
            CSXSMediaPromptDialog PromptBox;
            CSXSMediaPromptDialog::DialogResults result;

            IFW32FALSE_EXIT(PromptBox.Initialize(pCodeBaseIn));

            IFW32FALSE_EXIT(PromptBox.ShowSelf(result));

            if (result == CSXSMediaPromptDialog::DialogCancelled)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS: %s - user cancelled media prompt dialog\n",
                    __FUNCTION__);

                buffFinalLocalPath.Clear();
                break;
            }

            // Otherwise, try again!
            fRetryPressed = TRUE;
            break;
        }
    }

    IFW32FALSE_EXIT(rbuffLocalPath.Win32Assign(buffFinalLocalPath));

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS: %s - returning rbuffLocalPath \"%ls\"\n",
        __FUNCTION__,
        static_cast<PCWSTR>(rbuffLocalPath)
        );
#endif

    FN_EPILOG
}

BOOL
SxspAskDarwinDoReinstall(
    IN PCWSTR buffLocalPath)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    UINT (WINAPI * pfnMsiProvideAssemblyW)(
        LPCWSTR wzAssemblyName,
        LPCWSTR szAppContext,
        DWORD dwInstallMode,
        DWORD dwUnused,
        LPWSTR lpPathBuf,
        DWORD *pcchPathBuf) = NULL;

    INSTALLUILEVEL (WINAPI * pfnMsiSetInternalUI)(
        INSTALLUILEVEL  dwUILevel,     // UI level
        HWND  *phWnd)                   // handle of owner window
         = NULL;

    INSTALLUILEVEL OldInstallUILevel;
    CDynamicLinkLibrary hMSIDll;

    //
    // We should hoist the load/unload out of the loop.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(hMSIDll.Win32LoadLibrary(L"msi.dll"));
    IFW32NULL_ORIGINATE_AND_EXIT(hMSIDll.Win32GetProcAddress("MsiProvideAssemblyW", &pfnMsiProvideAssemblyW));
    IFW32NULL_ORIGINATE_AND_EXIT(hMSIDll.Win32GetProcAddress("MsiSetInternalUI", &pfnMsiSetInternalUI));

    // No real failure from this API...
    OldInstallUILevel = (*pfnMsiSetInternalUI)(INSTALLUILEVEL_NONE, NULL);
    IFREGFAILED_ORIGINATE_AND_EXIT((*pfnMsiProvideAssemblyW)(buffLocalPath, NULL, REINSTALLMODE_FILEREPLACE, MSIASSEMBLYINFO_WIN32ASSEMBLY, NULL, NULL));
    // and restore it
    (*pfnMsiSetInternalUI)(OldInstallUILevel, NULL);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxspRecoverAssembly(
    IN const CAssemblyRecoveryInfo &AsmRecoveryInfo,
    OUT SxsRecoveryResult &rStatus
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CSmallStringBuffer sbPerTypeCodebaseString;
    SxsWFPResolveCodebase CodebaseType;
    SXS_INSTALLW Install = { sizeof(SXS_INSTALLW) };
    Install.dwFlags |= SXS_INSTALL_FLAG_REPLACE_EXISTING;
    bool fNotFound = false;
    CCodebaseInformationList::ConstIterator CodebaseIterator;
    const CCodebaseInformationList& CodebaseList = AsmRecoveryInfo.GetCodeBaseList();
    ULONG RetryNumber = 0;
    BOOL  fRetryPressed = FALSE;
    ULONG RetryPressedCount = 0;

    rStatus = Recover_Unknown;

    //
    // As long as they hit retry, keep putting up the ui, cycling through the paths.
    //
    for (RetryNumber = 0 ; (rStatus != Recover_OK) && RetryNumber != 3 ; RetryNumber += (fRetryPressed ? 0 : 1))
    {
        for (CodebaseIterator = CodebaseList.Begin() ; (rStatus != Recover_OK) && CodebaseIterator != CodebaseList.End() ; ++CodebaseIterator)
        {
            fRetryPressed = FALSE;

            //
            // eg:
            // xcopy /fiver \\winbuilds\release\main\usa\latest.idw\x86fre\pro\i386 x:\blah\blah\i386
            //
            //  buffLocalPath                    x:\blah\blah\i386\asms\1000\msft\windows\gdiplus\gdiplus.man
            //  buffLocalPathCodebasePrefix      x:\blah\blah
            //  buffCodebaseMetaPrefix           x-ms-windows://
            //  buffCodebaseTail                 \i386\asms\1000\msft\windows\gdiplus\gdiplus.man.
            //
            //  Install.lpCodeBaseUrl            x:\blah\blah
            //  Install.lpManifestPath           x:\blah\blah\i386\asms\1000\msft\windows\gdiplus\gdiplus.man
            //

            CSmallStringBuffer buffLocalPath;
            CSmallStringBuffer buffCodebaseTail;
            CTinyStringBuffer buffExtension;
            const static UNICODE_STRING UnicodeString_dot_cab = RTL_CONSTANT_STRING(L".cab");
            const static UNICODE_STRING UnicodeString_cab = RTL_CONSTANT_STRING(L"cab");

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS: %s - beginning recovery of assembly directory \"%ls\"\n",
                __FUNCTION__,
                static_cast<PCWSTR>(AsmRecoveryInfo.GetAssemblyDirectoryName()));

            //
            // Go try and get the codebase resolved
            //

            rStatus = Recover_Unknown;

            IFW32FALSE_EXIT(
                ::SxspDetermineCodebaseType(
                    // this should be cached in m_CodebaseInfo.
                    CodebaseIterator->GetCodebase(),
                    CodebaseType,
                    &buffCodebaseTail));
                    
            if (CodebaseType == CODEBASE_RESOLVED_URLHEAD_UNKNOWN)
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS: %s - Couldn't figure out what to do with codebase \"%ls\"; skipping\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(CodebaseIterator->GetCodebase()));

                rStatus = Recover_SourceMissing;
                continue;
            }

            if (!::SxspRepeatUntilLocalPathAvailable(
                    (RetryNumber == 2 && (CodebaseIterator == (CodebaseList.Begin() + (RetryPressedCount % CodebaseList.GetSize()))))
                        ? SXSP_REPEAT_UNTIL_LOCAL_PATH_AVAILABLE_FLAG_UI : 0,
                    AsmRecoveryInfo, &*CodebaseIterator, CodebaseType, buffCodebaseTail, buffLocalPath, fRetryPressed))
            {
                continue;
            }
            if (fRetryPressed)
                RetryPressedCount += 1;

            if (buffLocalPath.Cch() == 0 )
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS: %s - unable to resolve codebase \"%ls\" to a local path\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(CodebaseIterator->GetCodebase()));

                rStatus = Recover_ManifestMissing;
                continue;
            }

            Install.dwFlags |= SXS_INSTALL_FLAG_REFRESH;

            IFW32FALSE_EXIT(buffLocalPath.Win32GetPathExtension(buffExtension));
            if (::FusionpEqualStringsI(buffExtension, &UnicodeString_cab)
                || ::FusionpEqualStringsI(buffExtension, &UnicodeString_dot_cab)
                )
            {

                IFW32FALSE_EXIT_UNLESS2(::SxspRecoverAssemblyFromCabinet(
                    buffLocalPath,
                    AsmRecoveryInfo.GetSecurityInformation().GetTextualIdentity(),
                    &Install),
                    LIST_2(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND),
                    fNotFound);
            }
            else
            {
                Install.lpManifestPath = buffLocalPath;

                IFW32FALSE_EXIT_UNLESS2(
                    ::SxsInstallW(&Install),
                    LIST_2(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND),
                    fNotFound);
            }


            if (fNotFound)
            {
                rStatus = Recover_ManifestMissing; // may also be a file in the assembly missing

                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS: %s - installation from %ls failed with win32 last error = %ld\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(buffLocalPath),
                    ::FusionpGetLastWin32Error());
                continue;
            }
            else
            {
                rStatus = Recover_OK;
                break;
            }
        }

        //
        // Last chance - try MSI reinstallation
        //
        if ( rStatus != Recover_OK )
        {
            BOOL fMsiKnowsAssembly = FALSE;
            const CBaseStringBuffer &rcbuffIdentity = AsmRecoveryInfo.GetSecurityInformation().GetTextualIdentity();
            
            IFW32FALSE_EXIT(::SxspDoesMSIStillNeedAssembly( rcbuffIdentity, fMsiKnowsAssembly));

            if ( fMsiKnowsAssembly && ::SxspAskDarwinDoReinstall(rcbuffIdentity))
            {
                rStatus = Recover_OK;
                break;
            }
        }
        
    }
    fSuccess = TRUE;
Exit:
    CSxsPreserveLastError ple;

    //
    // Here we have to check something.  If the assembly wasn't able to be reinstalled,
    // then we do the following:
    //
    // 1. Rename away old assembly directory to .old or similar
    // 2. Log a message to the event log
    //

    DWORD dwMessageToPrint = 0;

    if (rStatus != Recover_OK)
    {
        dwMessageToPrint = MSG_SXS_SFC_ASSEMBLY_RESTORE_FAILED;
    }
    else
    {
        dwMessageToPrint = MSG_SXS_SFC_ASSEMBLY_RESTORE_SUCCESS;
    }

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS.DLL: %s: Recovery of assembly \"%ls\" resulted in fSuccess=%d rStatus=%d\n",
        __FUNCTION__,
        static_cast<PCWSTR>(AsmRecoveryInfo.GetAssemblyDirectoryName()),
        fSuccess,
        rStatus);

    ::FusionpLogError(
        dwMessageToPrint,
        CUnicodeString(AsmRecoveryInfo.GetAssemblyDirectoryName()));

    ple.Restore();

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sources_2.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

FUSION_BUILD_HALF_NUMBER=2
!include ..\sources.inc

SOURCES=\
 ..\nodefactory.cpp \
 ..\ndpclassinfo.cpp \
 ..\recover.cpp \
 ..\parsepolicy.cpp \
 ..\partialassemblyversion.cpp \
 ..\pendingassembly.cpp \
 ..\policystatement.cpp \
 ..\probedassemblyinformation.cpp \
 ..\protectionui.cpp \
 ..\purevirt.cpp \
 ..\query.cpp \
 ..\simplefp.cpp \
 ..\ssgenctx.cpp \
 ..\strongname.cpp \
 ..\strsectgen.cpp \
 ..\sxsactctx.cpp \
 ..\sxsasmcache.cpp \
 ..\sxsasmname.cpp \
 ..\sxsasmitem.cpp \
 ..\sxsdebug.cpp \
 ..\sxsinstall.cpp \
 ..\sxsntrtl.cpp \
 ..\sxspath.cpp \
 ..\sxsprobe.cpp \
 ..\sxsprotect.cpp \
 ..\sxssfcscan.cpp \
 ..\sxssfc_repairshortnames.cpp \
 ..\sxsxmltree.cpp \
 ..\util.cpp \
 ..\windowclass.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\ssgenctx.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ssgenctx.h

Abstract:

    Class definition for the string section generation context object.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#if !defined(_FUSION_SSGENCTX_H_INCLUDED_)
#define _FUSION_SSGENCTX_H_INCLUDED_

#pragma once

class CSSGenCtx
{
public:
    static BOOL Create(
                PSTRING_SECTION_GENERATION_CONTEXT *SSGenContext,
                ULONG DataFormatVersion,
                BOOL CaseInSensitive,
                STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
                PVOID CallbackContext
                );

    BOOL Add(PCWSTR String, SIZE_T Cch, PVOID DataContext, ULONG AssemblyRosterIndex, DWORD DuplicateErrorCode);
    BOOL Find(PCWSTR String, SIZE_T Cch, PVOID *DataContext, BOOL *Found);
    BOOL DoneAdding();
    BOOL GetSectionSize(PSIZE_T SectionSize);
    BOOL GetSectionData(SIZE_T BufferSize, PVOID Buffer, SIZE_T *BytesWritten);
    PVOID GetCallbackContext() { return m_CallbackContext; }

    VOID DeleteYourself() { FUSION_DELETE_SINGLETON(this); }

    ~CSSGenCtx();
protected:
    CSSGenCtx();

    static int __cdecl CompareStringSectionEntries(const void *elem1, const void *elem2);

    STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION m_CallbackFunction;
    PVOID m_CallbackContext;

    class Entry
    {
    public:
        Entry() : m_PseudoKey(0), m_DataContext(NULL), m_Next(NULL) { }
        ~Entry() { }

        BOOL Initialize(PCWSTR String, SIZE_T Cch, ULONG PseudoKey, PVOID DataContext, ULONG AssemblyRosterIndex);
        BOOL GetEntryDataSize(CSSGenCtx *pSSGenCtx, SIZE_T &rSize);
        BOOL GetEntryData(CSSGenCtx *pSSGenCtx, SIZE_T BufferSize, PVOID Buffer, SIZE_T *BytesWritten);

        CStringBuffer m_StringBuffer;
        ULONG m_PseudoKey;
        ULONG m_HashBucketIndex;
        LONG m_EntryOffset;
        PVOID m_DataContext;
        Entry *m_Next;
        ULONG m_AssemblyRosterIndex;
    private:
        Entry(const Entry &);
        void operator =(const Entry &);
    };

    friend Entry;

    ULONG m_EntryCount;
    Entry *m_FirstEntry;
    Entry *m_LastEntry;
    ULONG m_DataFormatVersion;
    bool m_CaseInSensitive;
    ULONG m_HashTableSize;
    bool m_DoneAdding;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\ssgenctx.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ssgenctx.cpp

Abstract:

    String section generation context object implementation.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "ssgenctx.h"

typedef struct _CALLBACKDATA
{
    union
    {
        STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE GetDataSize;
        STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA GetData;
        STRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED EntryDeleted;
        STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE GetUserDataSize;
        STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA GetUserData;
    } u;
} CALLBACKDATA, *PCALLBACKDATA;

BOOL CSSGenCtx::Create(
    PSTRING_SECTION_GENERATION_CONTEXT *SSGenContext,
    ULONG DataFormatVersion,
    BOOL CaseInSensitive,
    STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    PVOID CallbackContext
    )
{
    FN_PROLOG_WIN32
    CSSGenCtx *pSSGenCtx;

    // NTRAID#NTBUG9 - 591680 - 2002/04/01 - mgrier - use smart pointer and Win32Allocate here for better leak tracking
    IFALLOCFAILED_EXIT(pSSGenCtx = new CSSGenCtx);
    pSSGenCtx->m_CallbackFunction = CallbackFunction;
    pSSGenCtx->m_CallbackContext = CallbackContext;
    pSSGenCtx->m_CaseInSensitive = (CaseInSensitive != FALSE);
    pSSGenCtx->m_DataFormatVersion = DataFormatVersion;

    *SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT) pSSGenCtx;

    FN_EPILOG
}

CSSGenCtx::CSSGenCtx() : m_DoneAdding(false)
{
    m_FirstEntry = NULL;
    m_LastEntry = NULL;
    m_EntryCount = 0;
    m_HashTableSize = 0;
}

CSSGenCtx::~CSSGenCtx()
{
    CSxsPreserveLastError ple;
    CALLBACKDATA CBData;
    SIZE_T n;

    Entry *pEntry = m_FirstEntry;

    n = 0;
    while (pEntry != NULL)
    {
        Entry *pNext = pEntry->m_Next;

        n++;

        ASSERT_NTC(n <= m_EntryCount);
        if (n > m_EntryCount)
            break;

        CBData.u.EntryDeleted.DataContext = pEntry->m_DataContext;
        (*m_CallbackFunction)(
            m_CallbackContext,
            STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED,
            &CBData);

        FUSION_DELETE_SINGLETON(pEntry);
        pEntry = pNext;
    }

    ASSERT_NTC(n == m_EntryCount);

    ple.Restore();
}

BOOL
CSSGenCtx::Add(
    PCWSTR String,
    SIZE_T Cch,
    PVOID DataContext,
    ULONG AssemblyRosterIndex,
    DWORD DuplicateErrorCode
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG PseudoKey = 0;
    Entry *pEntry = NULL;

    INTERNAL_ERROR_CHECK(!m_DoneAdding);

    PARAMETER_CHECK(DuplicateErrorCode != ERROR_SUCCESS);

    if ((String != NULL) && (String[0] == L'\0'))
        String = NULL;

    IFW32FALSE_EXIT(::SxspHashString(String, Cch, &PseudoKey, m_CaseInSensitive));

    for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
    {
        if ((pEntry->m_PseudoKey == PseudoKey) &&
            (pEntry->m_StringBuffer.Cch() == Cch) &&
            (::FusionpCompareStrings(
                String,
                Cch,
                pEntry->m_StringBuffer,
                Cch,
                m_CaseInSensitive) == 0))
        {
            pEntry = NULL;
            ORIGINATE_WIN32_FAILURE_AND_EXIT(DuplicateString, DuplicateErrorCode);
        }
    }

    // NTRAID#NTBUG9 - 591680 - 2002/04/01 - mgrier - use smart pointer and Win32Allocate here for better leak tracking
    IFALLOCFAILED_EXIT(pEntry = new Entry);

    IFW32FALSE_EXIT(pEntry->Initialize(String, Cch, PseudoKey, DataContext, AssemblyRosterIndex));

    if (m_LastEntry == NULL)
        m_FirstEntry = pEntry;
    else
        m_LastEntry->m_Next = pEntry;

    m_LastEntry = pEntry;

    pEntry = NULL;

    m_EntryCount++;

    FN_EPILOG
}

BOOL
CSSGenCtx::Find(
    PCWSTR String,
    SIZE_T Cch,
    PVOID *DataContext,
    BOOL *Found
    )
{
    FN_PROLOG_WIN32
    ULONG PseudoKey = 0;
    Entry *pEntry = NULL;

    if (DataContext != NULL)
        *DataContext = NULL;

    if (Found != NULL)
        *Found = FALSE;

    if ((String != NULL) && (String[0] == L'\0'))
        String = NULL;

    PARAMETER_CHECK(Found != NULL);
    PARAMETER_CHECK((Cch == 0) || (String != NULL));

    IFW32FALSE_EXIT(::SxspHashString(String, Cch, &PseudoKey, m_CaseInSensitive));

    for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
    {
        if ((pEntry->m_PseudoKey == PseudoKey) &&
            (pEntry->m_StringBuffer.Cch() == Cch) &&
            (::FusionpCompareStrings(
                String,
                Cch,
                pEntry->m_StringBuffer,
                Cch,
                m_CaseInSensitive) == 0))
            break;
    }

    if (pEntry != NULL)
    {
        *Found = TRUE;

        if (DataContext != NULL)
            *DataContext = pEntry->m_DataContext;
    }

    FN_EPILOG
}

BOOL
CSSGenCtx::DoneAdding()
{
    if (!m_DoneAdding)
    {
        // This is where to really figure out the optimal hash table size

        // first level guess...
        if (m_EntryCount < 3)
            m_HashTableSize = 0;
        else if (m_EntryCount < 15)
            m_HashTableSize = 3;
        else if (m_EntryCount < 100)
            m_HashTableSize = 11;
        else
            m_HashTableSize = 101;

        m_DoneAdding = true;
    }

    return TRUE;
}

BOOL
CSSGenCtx::GetSectionSize(
    PSIZE_T SizeOut
    )
{
    FN_PROLOG_WIN32
    SIZE_T UserDataSize = 0;
    SIZE_T HeaderSize = 0;
    SIZE_T EntryListSize = 0;
    SIZE_T EntryDataSize = 0;
    SIZE_T StringsSize = 0;
    SIZE_T HashTableSize = 0;
    CALLBACKDATA CBData;
    Entry *pEntry = NULL;

    if (SizeOut != NULL)
        *SizeOut = 0;

    PARAMETER_CHECK(SizeOut != NULL);

    HeaderSize = sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER);

    if (m_HashTableSize != 0)
    {
        //
        // The data for the hash table includes:
        //
        //  1. a small fixed sized struct representing the metadata for the hash
        //      table (ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE)
        //
        //  2. For each table bucket, a small struct pointing to the beginning of
        //      the collision chain and the length of said chain
        //      (ACTIVATION_CONTEXT_SECTION_STRING_HASH_BUCKET)
        //
        //  3. One entry in a collision chain per entry in the table.  The entry
        //      is a LONG offset from the beginning of the section.
        //

        HashTableSize = sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE) +
            (m_HashTableSize * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET)) +
            (m_EntryCount * sizeof(LONG));
    }

    CBData.u.GetUserDataSize.DataSize = 0;
    IFW32FALSE_EXIT((*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE, &CBData));
    UserDataSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserDataSize.DataSize);

    EntryListSize = m_EntryCount * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_ENTRY);

    for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
    {
        CBData.u.GetDataSize.DataContext = pEntry->m_DataContext;
        CBData.u.GetDataSize.DataSize = 0;
        IFW32FALSE_EXIT((*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE, &CBData));
        EntryDataSize += ROUND_ACTCTXDATA_SIZE(CBData.u.GetDataSize.DataSize);

        // Only allocate space for non-null strings.  If the null string is a key in the table,
        // it takes up 0 bytes.
        if (pEntry->m_StringBuffer.Cch() != 0)
            StringsSize += ROUND_ACTCTXDATA_SIZE((pEntry->m_StringBuffer.Cch() + 1) * sizeof(WCHAR));
    }

    // If there's nothing to contain, don't even ask for space for the header.
    if ((UserDataSize == 0) && (m_EntryCount == 0))
        *SizeOut = 0;
    else
        *SizeOut = HeaderSize + UserDataSize + EntryListSize + EntryDataSize + StringsSize + HashTableSize;

    FN_EPILOG
}

BOOL
CSSGenCtx::GetSectionData(
    SIZE_T BufferSize,
    PVOID Buffer,
    PSIZE_T BytesWritten
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    SIZE_T BytesSoFar = 0;
    SIZE_T BytesLeft = BufferSize;
    PACTIVATION_CONTEXT_STRING_SECTION_HEADER Header;
    PACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE HashTable = NULL;
    PACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET HashBucket = NULL;
    PLONG HashCollisionChain = NULL;
    CALLBACKDATA CBData;
    PVOID Cursor = NULL;
    SIZE_T RoundedSize;

    if (BytesWritten != NULL)
        *BytesWritten = 0;

    if (BytesLeft < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER))
    {
        ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    Header = (PACTIVATION_CONTEXT_STRING_SECTION_HEADER) Buffer;

    Cursor = (PVOID) (Header + 1);

    Header->Magic = ACTIVATION_CONTEXT_STRING_SECTION_MAGIC;
    Header->HeaderSize = sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HEADER);
    Header->FormatVersion = ACTIVATION_CONTEXT_STRING_SECTION_FORMAT_WHISTLER;
    Header->DataFormatVersion = m_DataFormatVersion;

    Header->Flags = 0;
    if (m_CaseInSensitive)
        Header->Flags |= ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE;

    Header->ElementCount = m_EntryCount;
    Header->ElementListOffset = 0; // filled in after we figure out the user data area
    Header->HashAlgorithm = SxspGetHashAlgorithm();
    Header->SearchStructureOffset = 0;
    Header->UserDataOffset = 0; // filled in below
    Header->UserDataSize = 0;

    BytesLeft -= sizeof(*Header);
    BytesSoFar += sizeof(*Header);

    CBData.u.GetUserDataSize.DataSize = 0;
    IFW32FALSE_EXIT((*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE, &CBData));

    RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserDataSize.DataSize);

    if (RoundedSize > BytesLeft)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

    if (RoundedSize != 0)
    {
        CBData.u.GetUserData.SectionHeader = Header;
        CBData.u.GetUserData.BufferSize = RoundedSize;
        CBData.u.GetUserData.Buffer = Cursor;
        CBData.u.GetUserData.BytesWritten = 0;

        IFW32FALSE_EXIT((*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA, &CBData));

        ASSERT(CBData.u.GetUserData.BytesWritten <= RoundedSize);

        RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetUserData.BytesWritten);

        if (RoundedSize != 0)
        {
            BytesLeft -= RoundedSize;
            BytesSoFar += RoundedSize;

            Header->UserDataSize = static_cast<ULONG>(CBData.u.GetUserData.BytesWritten);
            Header->UserDataOffset = static_cast<LONG>(((LONG_PTR) Cursor) - ((LONG_PTR) Header));
            Cursor = (PVOID) (((ULONG_PTR) Cursor) + RoundedSize);
        }
    }

    // Finally the array of entries...

    if (m_EntryCount != 0)
    {
        PVOID DataCursor;
        PACTIVATION_CONTEXT_STRING_SECTION_ENTRY EntryArray;
        ULONG iEntry;
        Entry *SrcEntry;

        if (BytesLeft < (m_EntryCount * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_ENTRY)))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

        BytesLeft -= (m_EntryCount * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_ENTRY));
        BytesSoFar += (m_EntryCount * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_ENTRY));

        EntryArray = (PACTIVATION_CONTEXT_STRING_SECTION_ENTRY) Cursor;
        Header->ElementListOffset = static_cast<LONG>(((LONG_PTR) EntryArray) - ((LONG_PTR) Header));
        DataCursor = (PVOID) (EntryArray + m_EntryCount);
        SrcEntry = m_FirstEntry;

        iEntry = 0;

        while (SrcEntry != NULL)
        {
            // Record the offset to this entry; we use it later during hash table population
            SrcEntry->m_EntryOffset = static_cast<LONG>(((LONG_PTR) &EntryArray[iEntry]) - ((LONG_PTR) Header));

            EntryArray[iEntry].PseudoKey = SrcEntry->m_PseudoKey;
            EntryArray[iEntry].AssemblyRosterIndex = SrcEntry->m_AssemblyRosterIndex;

            if (SrcEntry->m_StringBuffer.Cch() != 0)
            {
                const USHORT Cb = static_cast<USHORT>((SrcEntry->m_StringBuffer.Cch() + 1) * sizeof(WCHAR));
                RoundedSize = ROUND_ACTCTXDATA_SIZE(Cb);

                if (BytesLeft < RoundedSize)
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                EntryArray[iEntry].KeyLength = Cb - sizeof(WCHAR);
                EntryArray[iEntry].KeyOffset = static_cast<LONG>(((LONG_PTR) DataCursor) - ((LONG_PTR) Header));

                ::memcpy(
                    DataCursor,
                    static_cast<PCWSTR>(SrcEntry->m_StringBuffer),
                    Cb);

                DataCursor = (PVOID) (((ULONG_PTR) DataCursor) + RoundedSize);

                BytesLeft -= Cb;
                BytesSoFar += Cb;
            }
            else
            {
                EntryArray[iEntry].KeyLength = 0;
                EntryArray[iEntry].KeyOffset = 0;
            }

            CBData.u.GetDataSize.DataContext = SrcEntry->m_DataContext;
            CBData.u.GetDataSize.DataSize = 0;

            IFW32FALSE_EXIT((*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE, &CBData));

            if (CBData.u.GetDataSize.DataSize != 0)
            {
                RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetDataSize.DataSize);

                if (BytesLeft < RoundedSize)
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

                CBData.u.GetData.SectionHeader = Header;
                CBData.u.GetData.DataContext = SrcEntry->m_DataContext;
                CBData.u.GetData.BufferSize = RoundedSize;
                CBData.u.GetData.Buffer = DataCursor;
                CBData.u.GetData.BytesWritten = 0;

                IFW32FALSE_EXIT((*m_CallbackFunction)(m_CallbackContext, STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA, &CBData));

                if (CBData.u.GetData.BytesWritten != 0)
                {
                    // If this assert fires, a contributor wrote past the bounds they
                    // were given.
                    INTERNAL_ERROR_CHECK(CBData.u.GetData.BytesWritten <= RoundedSize);
                    if (CBData.u.GetData.BytesWritten > RoundedSize)
                    {
                        // Probably we have memory corruption, but at least we'll bail and
                        // avoid further scribbling on memory.
                        ::FusionpDbgPrintEx(
                            FUSION_DBG_LEVEL_ERROR,
                            "SXS.DLL: String section data generation callback wrote more bytes than it should have.  Bailing out and hoping memory isn't trashed.\n");

                        ::FusionpSetLastWin32Error(ERROR_INTERNAL_ERROR);
                        goto Exit;
                    }

                    RoundedSize = ROUND_ACTCTXDATA_SIZE(CBData.u.GetData.BytesWritten);

                    BytesLeft -= RoundedSize;
                    BytesSoFar += RoundedSize;

                    EntryArray[iEntry].Offset = static_cast<LONG>(((LONG_PTR) DataCursor) - ((LONG_PTR) Header));
                    EntryArray[iEntry].Length = static_cast<ULONG>(CBData.u.GetData.BytesWritten);

                    DataCursor = (PVOID) (((ULONG_PTR) DataCursor) + RoundedSize);
                }
                else
                {
                    EntryArray[iEntry].Offset = 0;
                    EntryArray[iEntry].Length = 0;
                }
            }
            else
            {
                EntryArray[iEntry].Offset = 0;
                EntryArray[iEntry].Length = 0;
            }

            SrcEntry = SrcEntry->m_Next;
            iEntry++;
        }

        INTERNAL_ERROR_CHECK(iEntry == m_EntryCount);

        // If we're not generating a hash table, let's sort 'em.
        if (m_HashTableSize == 0)
        {
            ::qsort(EntryArray, m_EntryCount, sizeof(ACTIVATION_CONTEXT_STRING_SECTION_ENTRY), &CSSGenCtx::CompareStringSectionEntries);
            Header->Flags |= ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER;
        }

        Cursor = (PVOID) DataCursor;
    }

    // Write the hash table at the end.  We do it here so that the placement of everything else is
    // already worked out.
    if (m_HashTableSize != 0)
    {
        ULONG iBucket;
        Entry *pEntry;
        ULONG cCollisions;

        if (BytesLeft < sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

        HashTable = (PACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE) Cursor;
        Cursor = (PVOID) (HashTable + 1);

        BytesLeft -= sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE);
        BytesSoFar += sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE);

        if (BytesLeft < (m_HashTableSize * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET)))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

        HashBucket = (PACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET) Cursor;
        Cursor = (PVOID) (HashBucket + m_HashTableSize);

        BytesLeft -= (m_HashTableSize * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET));
        BytesSoFar += (m_HashTableSize * sizeof(ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET));

        Header->SearchStructureOffset = static_cast<LONG>(((LONG_PTR) HashTable) - ((LONG_PTR) Header));
        HashTable->BucketTableEntryCount = m_HashTableSize;
        HashTable->BucketTableOffset = static_cast<LONG>(((LONG_PTR) HashBucket) - ((LONG_PTR) Header));

        if (BytesLeft < (m_EntryCount * sizeof(LONG)))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);

        HashCollisionChain = (PLONG) Cursor;
        Cursor = (PVOID) (HashCollisionChain + m_EntryCount);

        BytesLeft -= (m_EntryCount * sizeof(LONG));
        BytesSoFar += (m_EntryCount * sizeof(LONG));

        // In a disgusting move, we need to iterate over the hash buckets (not elements)
        // finding which entries would go into the bucket so that we can build up the
        // collision chain.

        for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
            pEntry->m_HashBucketIndex = pEntry->m_PseudoKey % m_HashTableSize;

        cCollisions = 0;

        for (iBucket=0; iBucket<m_HashTableSize; iBucket++)
        {
            bool fFirstForThisBucket = true;

            HashBucket[iBucket].ChainCount = 0;
            HashBucket[iBucket].ChainOffset = 0;

            for (pEntry = m_FirstEntry; pEntry != NULL; pEntry = pEntry->m_Next)
            {
                if (pEntry->m_HashBucketIndex == iBucket)
                {
                    if (fFirstForThisBucket)
                    {
                        HashBucket[iBucket].ChainOffset = static_cast<LONG>(((LONG_PTR) &HashCollisionChain[cCollisions]) - ((LONG_PTR) Header));
                        fFirstForThisBucket = false;
                    }
                    HashBucket[iBucket].ChainCount++;
                    HashCollisionChain[cCollisions++] = pEntry->m_EntryOffset;
                }
            }
        }
    }

    if (BytesWritten != NULL)
        *BytesWritten = BytesSoFar;

    FN_EPILOG
}

int
__cdecl
CSSGenCtx::CompareStringSectionEntries(
    const void *elem1,
    const void *elem2
    )
{
    PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY pEntry1 = reinterpret_cast<PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY>(elem1);
    PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY pEntry2 = reinterpret_cast<PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY>(elem2);

    if (pEntry1->PseudoKey < pEntry2->PseudoKey)
        return -1;
    else if (pEntry1->PseudoKey == pEntry2->PseudoKey)
        return 0;

    return 1;
}


BOOL
CSSGenCtx::Entry::Initialize(
    PCWSTR String,
    SIZE_T Cch,
    ULONG PseudoKey,
    PVOID DataContext,
    ULONG AssemblyRosterIndex
    )
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT(m_StringBuffer.Win32Assign(String, Cch));
    m_DataContext = DataContext;
    m_PseudoKey = PseudoKey;
    m_AssemblyRosterIndex = AssemblyRosterIndex;
    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\strongname.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    strongname.cpp

Abstract:

    Fusion Win32 implementation of the Fusion URT strong-name stuff

Author:

    Jon Wiswall (jonwis) 11-October-2000

Revision History:

    jonwis/7-November-2000: Added ability to find a strong name from a
        certificate context structure, as well as the ability to scan
        a catalog for strong names.  Also changed the way strong names
        are generated from a public key to be identically in-line with
        Fusion URT.

--*/

#include "stdinc.h"
#include "wincrypt.h"
#include "fusionbuffer.h"
#include "strongname.h"
#include "hashfile.h"
#include "sxsp.h"

BOOL
SxspHashStringToBytes(
    PCWSTR hsHashString,
    SIZE_T cchHashString,
    CFusionArray<BYTE> &OutputBuffer
    )
{
    //
    // 2 here is not sizeof(WCHAR) it is how many digits a byte takes to print (or be scanned from,
    // as is actually happening here)
    //
    DWORD dwByteCount = static_cast<DWORD>(cchHashString) / 2;
    DWORD dwIdx = 0;
    int  iHi, iLo;
    BOOL bSuccess = FALSE;

    FN_TRACE_WIN32(bSuccess);

    //
    // We look on odd numbers with disdain.
    //
    PARAMETER_CHECK((cchHashString % 2) == 0);
    if ( OutputBuffer.GetSize() != dwByteCount )
    {
        IFW32FALSE_EXIT(OutputBuffer.Win32SetSize(dwByteCount, CFusionArray<BYTE>::eSetSizeModeExact));
    }

    //
    // Sneak through the list of characters and turn them into the
    // hi and lo nibbles per byte position, then write them into the
    // output buffer.
    //
    for (DWORD i = 0; (i < cchHashString) && (dwIdx < OutputBuffer.GetSize()); i += 2)
    {
        if (((iHi = SxspHexDigitToValue(hsHashString[i])) >= 0) &&
             ((iLo = SxspHexDigitToValue(hsHashString[i+1])) >= 0))
        {
            OutputBuffer[dwIdx++] = static_cast<BYTE>(((iHi & 0xF) << 4) | (iLo & 0xF));
        }
        else
        {
            // Something bad happened while trying to read from the string,
            // maybe it contained invalid values?
            goto Exit;
        }
    }

    bSuccess = TRUE;

Exit:
    return bSuccess;
}


inline VOID
pReverseByteString(PBYTE pbBytes, SIZE_T cbBytes)
{
    SIZE_T  index = 0;

    if (cbBytes-- == 0) return;

    while (index < cbBytes)
    {
        BYTE bLeft = pbBytes[index];
        BYTE bRight = pbBytes[cbBytes];
        pbBytes[index++] = bRight;
        pbBytes[cbBytes--] = bLeft;
    }
}

BOOL
SxspHashBytesToString(
    IN const BYTE*    pbSource,
    IN SIZE_T   cbSource,
    OUT CBaseStringBuffer &sbDestination
    )
{
    BOOL bSuccess = FALSE;
    DWORD i;
    PWSTR pwsCursor;
    const static WCHAR HexCharList[] = L"0123456789abcdef";

    CStringBufferAccessor Accessor;

    FN_TRACE_WIN32(bSuccess);

    sbDestination.Clear();

    IFW32FALSE_EXIT(sbDestination.Win32ResizeBuffer((cbSource + 1) * 2, eDoNotPreserveBufferContents));

    Accessor.Attach(&sbDestination);
    pwsCursor = Accessor;
    for (i = 0; i < cbSource; i++)
    {
        pwsCursor[i*2]      = HexCharList[ (pbSource[i] >> 4) & 0x0F ];
        pwsCursor[i*2+1]    = HexCharList[ pbSource[i] & 0x0F ];
    }
    //
    // Because of the way string accessors and clear works, we have to clip off
    // the rest by a null character.  Odd, but it works.
    //
    pwsCursor[i*2] = L'\0';

    bSuccess = TRUE;
Exit:
    return bSuccess;
}

BOOL
SxspGetStrongNameOfKey(
    IN const CFusionArray<BYTE> &PublicKeyBits,
    OUT CFusionArray<BYTE> &StrongNameBits
    )
/*++

Note to posterity:

This implementation has been blessed by the Fusion URT people to be identically
in synch with their implementation.  Do _not_ change anything here unless you're
really sure there's a bug or there's a change in spec.  The basic operation of this
is as follows:

- Get crypto provider
- Create a SHA1 hash object from the crypto stuff
- Hash the data
- Extract the hash data into the output buffer
- Move the low order 8-bytes of the hash (bytes 11 through 19) down to 0-7
- Reverse the bytes to obtain a "network ordered" 64-bit string

The last two steps are the important thing - work with Rudi Martin (Fusion URT)
if you think there's a better way.

--*/
{
    FN_PROLOG_WIN32
    
    CFusionHash             hHash;
    PSXS_PUBLIC_KEY_INFO    pPubKeyInfo;

    PARAMETER_CHECK(PublicKeyBits.GetSize() >= sizeof(*pPubKeyInfo));

    if (StrongNameBits.GetSize() < STRONG_NAME_BYTE_LENGTH)
    {
        IFW32FALSE_EXIT(StrongNameBits.Win32SetSize(STRONG_NAME_BYTE_LENGTH, CFusionArray<BYTE>::eSetSizeModeExact));
    }

    //
    // Convert our pointer back for a second - it's a persisted version of this
    // structure anyhow.
    //
    pPubKeyInfo = (PSXS_PUBLIC_KEY_INFO)PublicKeyBits.GetArrayPtr();

    //
    // Make ourselves a hash object.
    //
    IFW32FALSE_EXIT(hHash.Win32Initialize(CALG_SHA1));

    //
    // Hash the actual data that we were passed in to generate the strong name.
    //
    IFW32FALSE_EXIT(
        hHash.Win32HashData(
            PublicKeyBits.GetArrayPtr(), 
            PublicKeyBits.GetSize()));

    //
    // Find out how big the hash data really is from what was hashed.
    //
    IFW32FALSE_EXIT(hHash.Win32GetValue(StrongNameBits));

    // NTRAID#NTBUG9 - 587802 - 2002/03/26 - xiaoyuw:
    //  I think we need add one line, 
    //  StrongNameBits.GetSize() > STRONG_NAME_BYTE_LENGTH) 
    //  before calling into the following code. although rtlMoveMemory dealt with overlap, 
    //  it does not make sense if there is really an overlap.

    //
    // Move the last eight bytes of the hash downwards using memmove, because
    // it knows about things like overlapping blocks.
    //
    PBYTE pbBits = static_cast<PBYTE>(StrongNameBits.GetArrayPtr());
    INTERNAL_ERROR_CHECK(StrongNameBits.GetSize() >= STRONG_NAME_BYTE_LENGTH);
    ::RtlMoveMemory(
        pbBits,
        pbBits + (StrongNameBits.GetSize() - STRONG_NAME_BYTE_LENGTH),
        STRONG_NAME_BYTE_LENGTH);
    pReverseByteString(pbBits, STRONG_NAME_BYTE_LENGTH);

    IFW32FALSE_EXIT(StrongNameBits.Win32SetSize(STRONG_NAME_BYTE_LENGTH, CFusionArray<BYTE>::eSetSizeModeExact));

    FN_EPILOG
}



BOOL
SxspDoesStrongNameMatchKey(
    IN  const CBaseStringBuffer &rbuffKeyString,
    IN  const CBaseStringBuffer &rbuffStrongNameString,
    OUT BOOL                    &rfKeyMatchesStrongName
    )
{
    FN_PROLOG_WIN32

    CSmallStringBuffer  buffStrongNameCandidate;

    PARAMETER_CHECK(::SxspIsFullHexString(rbuffKeyString, rbuffKeyString.Cch()));
    PARAMETER_CHECK(::SxspIsFullHexString(rbuffStrongNameString, rbuffStrongNameString.Cch()));

    //
    // Convert the key over to its corresponding strong name
    //
    IFW32FALSE_EXIT(::SxspGetStrongNameOfKey(rbuffKeyString, buffStrongNameCandidate));

    //
    // And compare what the caller thinks it should be.
    //
    rfKeyMatchesStrongName = (::FusionpCompareStrings(
        rbuffStrongNameString,
        rbuffStrongNameString.Cch(),
        buffStrongNameCandidate,
        buffStrongNameCandidate.Cch(),
        false) == 0);


    FN_EPILOG
}



BOOL
SxspGetStrongNameOfKey(
    IN const CBaseStringBuffer &rbuffKeyString,
    OUT CBaseStringBuffer &sbStrongName
    )
{
    CFusionArray<BYTE> KeyBytes, StrongNameBytes;
    BOOL        bSuccess = FALSE;

    FN_TRACE_WIN32(bSuccess);

    //
    // Convert the string to bytes, generate the strong name, convert back to
    // a string.
    //
    IFW32FALSE_EXIT(::SxspHashStringToBytes(rbuffKeyString, rbuffKeyString.Cch(), KeyBytes));
    IFW32FALSE_EXIT(::SxspGetStrongNameOfKey(KeyBytes, StrongNameBytes));
    IFW32FALSE_EXIT(::SxspHashBytesToString(StrongNameBytes.GetArrayPtr(), StrongNameBytes.GetSize(), sbStrongName));

    bSuccess = TRUE;
Exit:
    return bSuccess;
}

BOOL
SxspAcquireStrongNameFromCertContext(
    CBaseStringBuffer &rbuffStrongNameString,
    CBaseStringBuffer &sbPublicKeyString,
    PCCERT_CONTEXT pCertContext
    )
/*++

Note to posterity:

This is the other "black magic" of the strong-name stuff.  Fusion URT takes whatever
CryptExportKey blops out, tacks on a magic header of their design (which I have
copied into SXS_PUBLIC_KEY_INFO), then hashes the whole thing.  This routine knows
how to interact with a pCertContext object (like one you'd get from a certificate
file or by walking through a catalog) and turn the certificate into a strong name
and public key blob.  The public key blob is returned in a hex string, and can
be converted back to bytes (for whatever purpose) via SxspHashStringToBytes.

Don't change anything you see below, unless there's a bug or there's been a spec
change.  If you've got problems with this file, please notify Jon Wiswall (jonwis)
and he'll be able to better help you with debugging or whatnot.

--*/
{
    BOOL                    bSuccess = FALSE;
    HCRYPTPROV              hCryptProv = NULL;
    HCRYPTHASH              hCryptHash = NULL;
    HCRYPTKEY               hCryptKey = NULL;
    const SIZE_T            KeyInfoBufferSize = 2048;
    CFusionArray<BYTE>      bKeyInfo;
    PSXS_PUBLIC_KEY_INFO    pKeyWrapping = NULL;
    DWORD                   dwDump = 0;
    CFusionArray<BYTE>      bPublicKeyContainer;
    CFusionArray<BYTE>      bStrongNameContainer;

    FN_TRACE_WIN32(bSuccess);

    PARAMETER_CHECK(pCertContext != NULL);
    PARAMETER_CHECK(pCertContext->pCertInfo != NULL);

    // NTRAID#NTBUG9 - 623698 - 2002/05/15 - jonwis - This is broken, use a growable buffer here
    //      rather than a stack blob. This isn't future proof when people start using 16384-bit
    //      keys.
    IFW32FALSE_EXIT(bKeyInfo.Win32SetSize(KeyInfoBufferSize));
    pKeyWrapping = reinterpret_cast<PSXS_PUBLIC_KEY_INFO>(bKeyInfo.GetArrayPtr());

    rbuffStrongNameString.Clear();
    sbPublicKeyString.Clear();

    //
    // Get a crypto context that only does RSA verification - ie, doesn't use private keys
    //
    IFW32FALSE_EXIT(::SxspAcquireGlobalCryptContext(&hCryptProv));

    //
    // Take the public key info that we found on this certificate context and blop it back
    // into a real internal crypto key.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::CryptImportPublicKeyInfoEx(
            hCryptProv,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            &(pCertContext->pCertInfo->SubjectPublicKeyInfo),
            CALG_RSA_SIGN,
            0,
            NULL,
            &hCryptKey));

    //
    // The stuff we swizzle will be about 200 bytes, so this is serious overkill
    // until such time as people start using 16384-bit keys.
    //
    pKeyWrapping->KeyLength =
        KeyInfoBufferSize - offsetof(SXS_PUBLIC_KEY_INFO, pbKeyInfo);

    //
    // Extract the key data from the crypto key back into a byte stream. This seems to
    // be what the fusion-urt people do, in order to get a byte string to hash.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(
        CryptExportKey(
            hCryptKey,
            NULL,
            PUBLICKEYBLOB,
            0,
            pKeyWrapping->pbKeyInfo,
            &pKeyWrapping->KeyLength));

    //
    // Sacred values from the fusion-urt people
    //
    pKeyWrapping->SigAlgID = CALG_RSA_SIGN;
    pKeyWrapping->HashAlgID = CALG_SHA1;

    dwDump = pKeyWrapping->KeyLength + offsetof(SXS_PUBLIC_KEY_INFO, pbKeyInfo);

    IFW32FALSE_EXIT(
        ::SxspHashBytesToString(
            reinterpret_cast<const BYTE*>(pKeyWrapping),
            dwDump,
            sbPublicKeyString));

    IFW32FALSE_EXIT(bPublicKeyContainer.Win32Assign(dwDump, bKeyInfo.GetArrayPtr()));

    IFW32FALSE_EXIT(
        ::SxspGetStrongNameOfKey(
            bPublicKeyContainer,
            bStrongNameContainer));

    INTERNAL_ERROR_CHECK(bStrongNameContainer.GetSize() == STRONG_NAME_BYTE_LENGTH);

    //
    // Great - this is the official strong name of the 2000 Fusolympics.
    //
    IFW32FALSE_EXIT(
        ::SxspHashBytesToString(
            bStrongNameContainer.GetArrayPtr(),
            STRONG_NAME_BYTE_LENGTH,
            rbuffStrongNameString));

    bSuccess = TRUE;

Exit:

    if (hCryptKey != NULL)        CryptDestroyKey(hCryptKey);
    if (hCryptHash != NULL)       CryptDestroyHash(hCryptHash);

    return bSuccess;
}



inline BOOL
SxspAreStrongNamesAllowedToNotMatchCatalogs(BOOL &bAllowed)
{
    //
    // This function is our back-door past the strong-name system while
    // Whistler is still in beta/rtm.  The test certificate, if installed,
    // indicates that it's ok to let strong names not match catalogs.
    //
    // The certificate data here is from \nt\admin\ntsetup\syssetup\crypto.c in
    // SetupAddOrRemoveTestCertificate.  Please ensure that this gets updated.
    //
    BOOL            fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CRYPT_HASH_BLOB HashBlob;
    HCERTSTORE      hSystemStore = NULL;
    PCCERT_CONTEXT  pCertContext = NULL;

    BYTE bTestRootHashList[][20] = {
        {0x2B, 0xD6, 0x3D, 0x28, 0xD7, 0xBC, 0xD0, 0xE2, 0x51, 0x19, 0x5A, 0xEB, 0x51, 0x92, 0x43, 0xC1, 0x31, 0x42, 0xEB, 0xC3}
    };

    bAllowed = FALSE;

    //
    // Cause the root store to be opened on the local machine.
    //
    IFW32NULL_ORIGINATE_AND_EXIT(
        hSystemStore = ::CertOpenStore(
            CERT_STORE_PROV_SYSTEM,
            0, 
            (HCRYPTPROV)NULL,
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            L"ROOT"));

    for (int i = 0; i < NUMBER_OF(bTestRootHashList); i++)
    {
        bool fNotFound;

        HashBlob.cbData = sizeof(bTestRootHashList[i]);
        HashBlob.pbData = bTestRootHashList[i];

        IFW32NULL_ORIGINATE_AND_EXIT_UNLESS2(
            pCertContext = ::CertFindCertificateInStore(
                hSystemStore,                
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,             
                0,
                CERT_FIND_HASH,
                &HashBlob,
                NULL),
            LIST_1(static_cast<DWORD>(CRYPT_E_NOT_FOUND)),
            fNotFound);

        if (pCertContext != NULL)
        {
            bAllowed = TRUE;
            break;
        }
    }

    if (!bAllowed)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO | FUSION_DBG_LEVEL_INSTALLATION,
            "SXS: %s - no test certificate installed on machine\n",
            __FUNCTION__);
    }

    fSuccess = TRUE;
Exit:
    CSxsPreserveLastError ple;

    if (pCertContext) ::CertFreeCertificateContext(pCertContext);
    if (hSystemStore) ::CertCloseStore(hSystemStore, CERT_CLOSE_STORE_FORCE_FLAG);

    ple.Restore();

    return fSuccess;
}




CPublicKeyInformation::CPublicKeyInformation()
    : m_fInitialized(false)
{
}

CPublicKeyInformation::~CPublicKeyInformation()
{
}

BOOL
CPublicKeyInformation::GetStrongNameBytes(
    OUT CFusionArray<BYTE> & cbStrongNameBytes
) const
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_fInitialized);
    IFW32FALSE_EXIT(m_StrongNameBytes.Win32Clone(cbStrongNameBytes));

    FN_EPILOG
}

BOOL
CPublicKeyInformation::GetStrongNameString(
    OUT CBaseStringBuffer &rbuffStrongNameString
   ) const
{
    FN_PROLOG_WIN32

    rbuffStrongNameString.Clear();
    INTERNAL_ERROR_CHECK(m_fInitialized);
    IFW32FALSE_EXIT(rbuffStrongNameString.Win32Assign(m_StrongNameString));

    FN_EPILOG
}

BOOL
CPublicKeyInformation::GetPublicKeyBitLength(
    OUT ULONG &ulKeyLength
) const
{
    BOOL fSuccess = FALSE;
    BOOL fLieAboutPublicKeyBitLength = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ulKeyLength = 0;

    INTERNAL_ERROR_CHECK(m_fInitialized);
    IFW32FALSE_EXIT(::SxspAreStrongNamesAllowedToNotMatchCatalogs(fLieAboutPublicKeyBitLength));

    if (fLieAboutPublicKeyBitLength)
    {
#if DBG
        FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INFO,
            "SXS: %s() - Lying about key length because we're still in test mode (%lu actual, %lu spoofed.)\n",
            __FUNCTION__,
            m_KeyLength,
            SXS_MINIMAL_SIGNING_KEY_LENGTH);
#endif
        ulKeyLength = SXS_MINIMAL_SIGNING_KEY_LENGTH;
    }
    else
    {
        ulKeyLength = m_KeyLength;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
CPublicKeyInformation::GetWrappedPublicKeyBytes(
    OUT CFusionArray<BYTE> &bPublicKeybytes
) const
{
    FN_PROLOG_WIN32
    INTERNAL_ERROR_CHECK(m_fInitialized);
    IFW32FALSE_EXIT(m_PublicKeyBytes.Win32Clone(bPublicKeybytes));
    FN_EPILOG
}

BOOL
CPublicKeyInformation::Initialize(
    IN const CBaseStringBuffer &rsbCatalogFile
    )
{
    BOOL        fSuccess = FALSE;
    CFusionFile       CatalogFile;

    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(m_CatalogSourceFileName.Win32Assign(rsbCatalogFile));

    IFW32FALSE_EXIT(
		CatalogFile.Win32CreateFile(
			rsbCatalogFile,
			GENERIC_READ,
			FILE_SHARE_READ,
			OPEN_EXISTING));

    IFW32FALSE_EXIT(this->Initialize(CatalogFile));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CPublicKeyInformation::Initialize(
    IN PCWSTR pszCatalogFile
    )
{
    BOOL fSuccess = FALSE;
    CFusionFile CatalogFile;

    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(m_CatalogSourceFileName.Win32Assign(pszCatalogFile, wcslen(pszCatalogFile)));

    IFW32FALSE_EXIT(
		CatalogFile.Win32CreateFile(
			pszCatalogFile,
			GENERIC_READ,
			FILE_SHARE_READ,
			OPEN_EXISTING));

    IFW32FALSE_EXIT(this->Initialize(CatalogFile));

    fSuccess = TRUE;
Exit:

    return fSuccess;
}

BOOL
CPublicKeyInformation::Initialize(
    IN CFusionFile& CatalogFileHandle
)
{
    BOOL                fSuccess = FALSE;
    CFileMapping        FileMapping;
    CMappedViewOfFile   MappedFileView;
    ULONGLONG           cbCatalogFile = 0;
    HCERTSTORE          hTempStore = NULL;
    PCCERT_CONTEXT      pSignerContext = NULL;
    PCCTL_CONTEXT       pContext = NULL;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(CatalogFileHandle != INVALID_HANDLE_VALUE);

    IFW32FALSE_EXIT(CatalogFileHandle.Win32GetSize(cbCatalogFile));
    IFW32FALSE_EXIT(FileMapping.Win32CreateFileMapping(CatalogFileHandle, PAGE_READONLY, cbCatalogFile, NULL));
    IFW32FALSE_EXIT(MappedFileView.Win32MapViewOfFile(FileMapping, FILE_MAP_READ, 0, (SIZE_T)cbCatalogFile));

    IFW32NULL_EXIT(pContext = (PCCTL_CONTEXT)CertCreateCTLContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        static_cast<const BYTE*>(static_cast<void*>(MappedFileView)),
        static_cast<DWORD>(cbCatalogFile)));

    hTempStore = pContext->hCertStore;
    IFW32FALSE_ORIGINATE_AND_EXIT(::CryptMsgGetAndVerifySigner(
        pContext->hCryptMsg,
        1,
        &hTempStore,
        0,
        &pSignerContext,
        NULL));

    // BUGBUG
    IFW32NULL_EXIT(pSignerContext);

    IFW32FALSE_EXIT(this->Initialize(pSignerContext));

    fSuccess = TRUE;
Exit:

    return fSuccess;
}



BOOL
CPublicKeyInformation::Initialize(IN PCCERT_CONTEXT pCertContext)
{
    BOOL                    fSuccess = FALSE;
    DWORD                   dwNameStringLength;
    CStringBufferAccessor   Access;
    FN_TRACE_WIN32(fSuccess);
    PARAMETER_CHECK(pCertContext != NULL);

    IFW32FALSE_EXIT(
        ::SxspAcquireStrongNameFromCertContext(
            m_StrongNameString,
            m_PublicKeyByteString,
            pCertContext));

    IFW32FALSE_EXIT(::SxspHashStringToBytes(m_StrongNameString, m_StrongNameString.Cch(), m_StrongNameBytes));
    IFW32FALSE_EXIT(::SxspHashStringToBytes(m_PublicKeyByteString, m_PublicKeyByteString.Cch(), m_PublicKeyBytes));
    IFW32ZERO_EXIT(m_KeyLength = CertGetPublicKeyLength(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        &pCertContext->pCertInfo->SubjectPublicKeyInfo));

    Access.Attach(&m_SignerDisplayName);

    dwNameStringLength = ::CertGetNameStringW(
        pCertContext,
        CERT_NAME_FRIENDLY_DISPLAY_TYPE,
        0,
        NULL,
        Access.GetBufferPtr(),
        static_cast<DWORD>(Access.GetBufferCch()));

    if (dwNameStringLength == 0)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(CertGetNameString);
        goto Exit;
    }

    if (dwNameStringLength > Access.GetBufferCch())
    {
        Access.Detach();
        IFW32FALSE_EXIT(m_SignerDisplayName.Win32ResizeBuffer(dwNameStringLength, eDoNotPreserveBufferContents));
        Access.Attach(&m_SignerDisplayName);

        dwNameStringLength = ::CertGetNameStringW(
            pCertContext,
            CERT_NAME_FRIENDLY_DISPLAY_TYPE,
            0,
            NULL,
            Access.GetBufferPtr(),
            static_cast<DWORD>(Access.GetBufferCch()));
    }

    Access.Detach();

    m_fInitialized = true;
    fSuccess = TRUE;
Exit:
    {
        CSxsPreserveLastError ple;
        if (pCertContext != NULL)
            ::CertFreeCertificateContext(pCertContext);

        ple.Restore();
    }
    return fSuccess;
}


BOOL
CPublicKeyInformation::GetSignerNiceName(
    OUT CBaseStringBuffer &rbuffName
    )
{
    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(m_fInitialized);
    IFW32FALSE_EXIT(rbuffName.Win32Assign(m_SignerDisplayName));

    FN_EPILOG
}



BOOL
CPublicKeyInformation::DoesStrongNameMatchSigner(
    IN const CBaseStringBuffer &rbuffTestStrongName,
    OUT BOOL &rfStrongNameMatchesSigner
   ) const
{
    BOOL    fSuccess = FALSE;
    BOOL    fCanStrongNameMismatch = FALSE;
    FN_TRACE_WIN32(fSuccess);

    rfStrongNameMatchesSigner = (::FusionpCompareStrings(
        rbuffTestStrongName,
        rbuffTestStrongName.Cch(),
        m_StrongNameString,
        m_StrongNameString.Cch(),
        false) == 0);

    if (!rfStrongNameMatchesSigner)
    {
        IFW32FALSE_EXIT(::SxspAreStrongNamesAllowedToNotMatchCatalogs(fCanStrongNameMismatch));

        if (fCanStrongNameMismatch)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS.DLL: %s - !!notice!! Strong name %ls not in catalog %ls, test code allows this\n"
                "                         Please make sure that you have tested with realsigned catalogs.\n",
                __FUNCTION__,
                static_cast<PCWSTR>(rbuffTestStrongName),
                static_cast<PCWSTR>(m_CatalogSourceFileName));

            rfStrongNameMatchesSigner = TRUE;
        }
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\stdinc.h ===
#pragma once
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "ntrtlmmapio.h"
#if FUSION_WIN2000
typedef unsigned short WORD;
typedef unsigned long DWORD;
#define _NTSLIST_DIRECT_ 1
#define NTSLIST_ASSERT(x) /* empty */
#include <ntslist.h>
#endif // FUSION_WIN2000
#include <windows.h>
#include <stdio.h>
#include <limits.h>
#include "fusionlastwin32error.h"
#include "fusionntdll.h"
#include "fusionunused.h"
#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#endif
#if !defined(MAXDWORD)
#define MAXDWORD (~(DWORD)0)
#endif

#include "sxsp.h"
#include "nodefactory.h"
#include "fusionbuffer.h"
#include "fusionhash.h"
#include "sxspath.h"
#include "probedassemblyinformation.h"

#include <ole2.h>
#include <xmlparser.h>
#include <wchar.h>
#include "filestream.h"
#include "fusionhandle.h"
#include "cteestream.h"
#include "cresourcestream.h"
#include "fusionxml.h"
#include "util.h"
#include "sxsexceptionhandling.h"
#include "csxspreservelasterror.h"
#include "smartptr.h"
#include "fusioneventlog.h"
#include "fusionstring.h"
#include "fusionparser.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "policystatement.h"
#include "smartptr.h"
#include "actctxgenctx.h"

#include <sxstypes.h>
#include <sxsapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\strongname.h ===
#pragma once

#include "wincrypt.h"
#include "fusionarray.h"
#include "fusionhandle.h"

//
// If someone invents a hash with more than 512 bytes, ?JonWis will eat his socks.
//
#define MAX_HASH_BYTES              ( 512 )
#define STRONG_NAME_BYTE_LENGTH     ( 8 )


BOOL
SxspHashStringToBytes(
    IN  PCWSTR pszHashString,
    IN  SIZE_T cchHashString,
    OUT CFusionArray<BYTE> &dest
    );

BOOL
SxspHashBytesToString(
    IN const BYTE*    pbSource,
    IN SIZE_T   cbSource,
    OUT CBaseStringBuffer &sbDestination
    );

BOOL
SxspHashBytesToString(
    IN const BYTE*    pbSource,
    IN SIZE_T   cbSource,
    OUT CBaseStringBuffer &rsbDestination
    );

BOOL
SxspGetStrongNameOfKey(
    IN const CFusionArray<BYTE>& PublicKeyBits,
    OUT CFusionArray<BYTE>& StrongNameBits
    );

BOOL
SxspDoesStrongNameMatchKey(
    IN  const CBaseStringBuffer &rsbKeyString,
    IN  const CBaseStringBuffer &rsbStrongNameString,
    OUT BOOL                    &rfKeyMatchesStrongName
    );

BOOL
SxspGetStrongNameOfKey(
    IN const CBaseStringBuffer &sbKeyString,
    OUT CBaseStringBuffer &sbStrongNameOutput
    );

BOOL
SxspAcquireStrongNameFromCertContext(
    CBaseStringBuffer &rbuffStrongNameString,
    CBaseStringBuffer &rbuffPublicKeyString,
    PCCERT_CONTEXT pCertContext
    );

typedef struct _SXS_PUBLIC_KEY_INFO
{
    unsigned int SigAlgID;
    unsigned int HashAlgID;
    ULONG KeyLength;
    BYTE pbKeyInfo[1];
} SXS_PUBLIC_KEY_INFO, *PSXS_PUBLIC_KEY_INFO;


class CPublicKeyInformation
{
private:
    CFusionArray<BYTE>  m_StrongNameBytes;
    CSmallStringBuffer  m_StrongNameString;
    CFusionArray<BYTE>  m_PublicKeyBytes;
    CSmallStringBuffer  m_PublicKeyByteString;
    CStringBuffer       m_SignerDisplayName;
    CStringBuffer       m_CatalogSourceFileName;
    bool                m_fInitialized;
    ULONG               m_KeyLength;

public:
    BOOL GetStrongNameString(OUT CBaseStringBuffer &rsbStrongNameString ) const;
    BOOL GetStrongNameBytes(OUT CFusionArray<BYTE> &cbStrongNameBytes ) const;
    BOOL GetPublicKeyBitLength(OUT ULONG& ulKeyLength ) const;
    BOOL GetWrappedPublicKeyBytes(OUT CFusionArray<BYTE> &cbPublicKeyBytes ) const;
    BOOL GetSignerNiceName(OUT CBaseStringBuffer &rsbSignerNameString );
    BOOL DoesStrongNameMatchSigner( IN const CBaseStringBuffer &rsbToTest, OUT BOOL &rfFoundInCatalog ) const;

    CPublicKeyInformation();
    ~CPublicKeyInformation();

    BOOL Initialize(IN const CBaseStringBuffer &rsbCatalogName);
    BOOL Initialize(IN PCWSTR pszCatalogName);
    BOOL Initialize(IN CFusionFile &rFileHandle);
    BOOL Initialize(IN const PCCERT_CONTEXT pContext);

private:
    CPublicKeyInformation( const CPublicKeyInformation &);
    CPublicKeyInformation& operator=( const CPublicKeyInformation & );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsactctx.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsactctx.cpp

Abstract:

    Implement SxsGenerateActivationContext, called from csrss.exe.

Author:

    Michael J. Grier (MGrier)

Revision History:

    Jay Krell (a-JayK, JayKrell) June 2000
        moved file opening from here (sxs.dll) to csrss.exe client process,
            pass ISequentialStreams to sxs.dll.

    Xiaoyu Wu (xiaoyuw) Nov 2001
        enable logfile for actctx gen
        

--*/
#include "stdinc.h"
#include <windows.h>
#include "sxsapi.h"
#include "sxsp.h"
#include "fusioneventlog.h"
#include "filestream.h"
#include "fusionprintf.h"

// temporary dbprint reduction until we fix setup/comctl
ULONG DbgPrintReduceLevel(ULONG FilterLevel)
{
    if (FilterLevel != FUSION_DBG_LEVEL_ERROR)
        return FilterLevel;
    LONG Error = ::FusionpGetLastWin32Error();
    if (Error == ERROR_FILE_NOT_FOUND || Error == ERROR_PATH_NOT_FOUND)
        return FUSION_DBG_LEVEL_ENTEREXIT;
    return FilterLevel;
}

VOID
DbgPrintSxsGenerateActivationContextParameters(
    ULONG FilterLevel,
    PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters,
    PCSTR Function
    )
{
    FilterLevel = DbgPrintReduceLevel(FilterLevel);
#if !DBG
    if (FilterLevel != FUSION_DBG_LEVEL_ERROR)
        return;
#endif
    //
    // AssemblyDirectory deliberately not being printed
    // because it's garbage sometimes.
    //
    FusionpDbgPrintEx(
        FilterLevel,
        "SXS: %s() Input Parameters %p{\n"
        "SXS:   Flags:                 0x%lx\n"
        "SXS:   ProcessorArchitecture: 0x%lx\n"
        "SXS:   LangId:                0x%lx\n"
        "SXS:   TextualIdentity:       %ls\n"
        "SXS:   Manifest:              { %p, %ls }\n"
        "SXS:   Policy:                { %p, %ls }\n"
        "SXS: }\n",
        Function,
        Parameters,
        (Parameters != NULL) ? ULONG(Parameters->Flags) : 0,
        (Parameters != NULL) ? ULONG(Parameters->ProcessorArchitecture) : NULL,
        (Parameters != NULL) ? ULONG(Parameters->LangId) : NULL,
        (Parameters != NULL) ? Parameters->TextualAssemblyIdentity : NULL,
        (Parameters != NULL) ? Parameters->Manifest.Stream : NULL,
        (Parameters != NULL) ? Parameters->Manifest.Path : NULL,
        (Parameters != NULL) ? Parameters->Policy.Stream : NULL,
        (Parameters != NULL) ? Parameters->Policy.Path : NULL);
}

#define IF_FUSION_LOG_ACTCTX 0 && defined(_X86_)

#if IF_FUSION_LOG_ACTCTX_ACTION

extern HANDLE g_hActCtxLog;

__inline
ULONGLONG
GetCycleCount(void)
{
    __asm
    {
        RDTSC
    }
}

BOOL 
SxspWriteUnicodeStringToFileAsAnsi(
  HANDLE hFile,        // handle to file
  PCWSTR pszBuffer,    // data buffer
  DWORD dwCchBuffer,   // number of unicode characters to write
  LPDWORD pdwWritten   // number of bytes written
  )
{
    BOOL    bRet = FALSE;        
    PSTR    pszAnsiStr = NULL;
    int     nErr = 0;    

    if (pdwWritten == NULL)
    {
        ::SetLastError(ERROR_INVALID_PARAMETER); // should never happen
        return FALSE;
    }

    if (dwCchBuffer == 0)
        return TRUE;
            
    pszAnsiStr = reinterpret_cast<PSTR>(malloc(dwCchBuffer * 2 + 1));

    if (pszAnsiStr == NULL)
    {
        FusionpSetLastWin32Error(FUSION_WIN32_ALLOCFAILED_ERROR);
        goto Exit;
    }

    nErr = WideCharToMultiByte(CP_ACP,
                               WC_COMPOSITECHECK,
                               pszBuffer,
                               dwCchBuffer,
                               pszAnsiStr,
                               dwCchBuffer,
                               NULL,
                               NULL );
    if (nErr == 0)    
        goto Exit;    

    bRet = WriteFile( hFile,
                      pszAnsiStr,
                      dwCchBuffer, 
                      pdwWritten,
                      NULL);
    if (!bRet)
    {
        goto Exit;
    }

    bRet = TRUE;
Exit:
    if (pszAnsiStr != NULL)
    {
        CSxsPreserveLastError ple;
        free(pszAnsiStr);
        ple.Restore();
    }
    return bRet;
}

VOID 
SxspLogActCtxAction(ULONGLONG & ts, PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters)
{
    if ((g_hActCtxLog == INVALID_HANDLE_VALUE) || (!::FusionpDbgWouldPrintAtFilterLevel(FUSION_DBG_LEVEL_LOG_ACTCTX)))
    {
        ts = 0;
        return;
    }

    ULONGLONG cts = GetCycleCount() - ts;
    
    CStringBuffer sbLogText;
    SYSTEMTIME st;

    GetSystemTime(&st);

    if (!sbLogText.Win32Format(L"%4d.%02d.%02d-%#08x%08x, ", 
                        st.wYear, st.wMonth, st.wDay, 
                        (ULONG)(ts >> 32), (ULONG)(ts & 0x00000000FFFFFFFF)))
    {
        goto Exit;
    }

#define SB_APPEND(sb, x) do \
    { if ((x) != NULL && (x)[0] != L'\0') \
        { \
            if (sb.Win32Append(x, wcslen(x)) == FALSE) \
                    goto Exit; \
        }  \
    } while (0)

        
    SB_APPEND(sbLogText, (Parameters != NULL) ? Parameters->AssemblyDirectory : L"NULL");
    SB_APPEND(sbLogText, L", ");

    SB_APPEND(sbLogText, (Parameters != NULL) ? Parameters->Manifest.Path) : L"NULL");
    SB_APPEND(sbLogText, L", ");

    SB_APPEND(sbLogText, (Parameters != NULL) ? Parameters->TextualAssemblyIdentity : L"NULL");
    SB_APPEND(sbLogText, L", ");

    SB_APPEND(sbLogText, (Parameters != NULL) ? Parameters->Policy.Path : L"NULL");
    SB_APPEND(sbLogText, L", ");

    HANDLE ActCtxSection = (HANDLE)(Parameters->SectionObjectHandle);

    if (ActCtxSection == NULL || ActCtxSection == INVALID_HANDLE_VALUE)
    {
        SB_APPEND(sbLogText, L"FAILED, ");
        WCHAR buf[sizeof(ULONG) * 8 + 1];
        FusionpFormatStringW(buf, NUMBER_OF(buf), L"%#08x", ::GetLastError());
        SB_APPEND(sbLogText, buf);
    }
    else
    {
        //
        // set status
        //
        SB_APPEND(sbLogText, L"SUCCESS, ");

        //
        // set ActCtx Size
        //
        PACTIVATION_CONTEXT_DATA ActCtxData = (PACTIVATION_CONTEXT_DATA )MapViewOfFile(ActCtxSection, FILE_MAP_READ, 0, 0, 0);
        WCHAR buf[sizeof(ULONG) * 8 + 1];
        FusionpFormatStringW(buf, NUMBER_OF(buf), L"%#08x, ", ActCtxData->TotalSize);
        SB_APPEND(sbLogText, buf);

        //
        // set time cost
        //
        
        FusionpFormatStringW(buf, NUMBER_OF(buf), L"%#08x, ", (ULONG)(cts & 0x00000000FFFFFFFF));
        SB_APPEND(sbLogText, buf);

        //
        // set gen rate
        //
        FusionpFormatStringW(buf, NUMBER_OF(buf), L"%#08x", cts / ActCtxData->TotalSize);            
        SB_APPEND(sbLogText, buf);            

        UnmapViewOfFile((LPVOID)ActCtxData);
    }

    SB_APPEND(sbLogText, L";\n");
    DWORD dwBytesWritten;    
    if (!SxspWriteUnicodeStringToFileAsAnsi(g_hActCtxLog, sbLogText, sbLogText.GetCchAsDWORD(), &dwBytesWritten))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS: Logging actctx failed. Data string: %S\n", 
            sbLogText);
    }

Exit:

#undef SB_APPEND
    return;
}
#endif /* IF_FUSION_LOG_ACTCTX_ACTION */

extern "C"
BOOL
WINAPI
SxsGenerateActivationContext(
    PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters
    )
{
#if IF_FUSION_LOG_ACTCTX_ACTION
    ULONGLONG ts = GetCycleCount();    
#endif
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    RTL_PATH_TYPE PathType = static_cast<RTL_PATH_TYPE>(0);
    BOOL fSxspCloseManifestGraph = FALSE;
    CSmartPtr<CFileStream> SystemDefaultManifestFileStream;
    ACTCTXGENCTX *pActCtxGenCtx = NULL;
    DWORD dwWin32Error = 0;

#define IS_NT_DOS_PATH(_x) (((_x)[0] == L'\\') && ((_x)[1] == L'?') && ((_x)[2] == L'?') && ((_x)[3] == L'\\'))

    ::DbgPrintSxsGenerateActivationContextParameters(
        FUSION_DBG_LEVEL_ENTEREXIT,
        Parameters,
        __FUNCTION__);

    if (Parameters != NULL)
    {
        Parameters->SystemDefaultActCxtGenerationResult = NO_ERROR;
        Parameters->SectionObjectHandle = NULL;
    }

    PARAMETER_CHECK(Parameters != NULL);
    IFINVALID_FLAGS_EXIT_WIN32(Parameters->Flags,
                                SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY |
                                SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY | 
                                SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_APP_RUNNING_IN_SAFEMODE);
    PARAMETER_CHECK(Parameters->AssemblyDirectory != NULL);

    if (Parameters->Flags &
        (SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY
        | SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY))
    {
        PARAMETER_CHECK(Parameters->TextualAssemblyIdentity != NULL);
        PARAMETER_CHECK(Parameters->Manifest.Stream == NULL);
        PARAMETER_CHECK(Parameters->Policy.Stream == NULL);
    }
    else
    {
        PARAMETER_CHECK(Parameters->Manifest.Stream != NULL);
    }

    ASSERT(!IS_NT_DOS_PATH(Parameters->AssemblyDirectory));

    if (Parameters->Manifest.Path != NULL)
        ASSERT(!IS_NT_DOS_PATH(Parameters->Manifest.Path));

    if (Parameters->Policy.Path != NULL)
        ASSERT(!IS_NT_DOS_PATH(Parameters->Policy.Path));

    PathType = ::SxspDetermineDosPathNameType(Parameters->AssemblyDirectory);
    PARAMETER_CHECK((PathType == RtlPathTypeUncAbsolute) ||
                            (PathType == RtlPathTypeLocalDevice) ||
                            (PathType == RtlPathTypeDriveAbsolute) ||
                            (PathType == RtlPathTypeDriveRelative));

    // Fast out if there was not actually any manifest.
    if ((Parameters->Flags &
            (SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY |
             SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY)) == 0)
    {
        if (Parameters->Manifest.Stream == NULL)
        {
            // No stream means no activation context.
            FN_SUCCESSFUL_EXIT();
        }
        else
        {
            STATSTG statstg;

            IFCOMFAILED_EXIT(Parameters->Manifest.Stream->Stat(&statstg, STATFLAG_NONAME));
            if (statstg.cbSize.QuadPart <= 4)
            {
                FN_SUCCESSFUL_EXIT();
            }
        }
    }

    IFALLOCFAILED_EXIT(pActCtxGenCtx = new ACTCTXGENCTX);

    CStringBuffer &sbAssemblyDirectory = pActCtxGenCtx->SxsGenerateActivationContextLocals.sbAssemblyDirectory;

    // rarely used, mainly for system compatible assembly
    CSmallStringBuffer &sbManifestFileName = pActCtxGenCtx->SxsGenerateActivationContextLocals.sbManifestFileName;

    {
        CImpersonationData ImpersonationData(Parameters->ImpersonationCallback, Parameters->ImpersonationContext);
        Parameters->SectionObjectHandle = NULL;

        if (Parameters->Flags &
            (SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY
            | SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY))
        {
            //
            // If basesrv passes in a textual assembly identity, we have to create stream for manifest from here !
            //
            BOOL fOpenManifestFailed = FALSE;

            IFW32FALSE_EXIT(sbAssemblyDirectory.Win32Assign(Parameters->AssemblyDirectory, ::wcslen(Parameters->AssemblyDirectory)));

            IFW32FALSE_EXIT(::SxspCreateManifestFileNameFromTextualString(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
                sbAssemblyDirectory,
                Parameters->TextualAssemblyIdentity,
                sbManifestFileName));
            IFW32FALSE_EXIT(SystemDefaultManifestFileStream.Win32Allocate(__FILE__, __LINE__));

            IFW32FALSE_EXIT(SystemDefaultManifestFileStream->OpenForRead(
                sbManifestFileName,               
                CImpersonationData(),FILE_SHARE_READ, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, // default value for parameters
                dwWin32Error,
                4, 
                ERROR_FILE_NOT_FOUND, 
                ERROR_PATH_NOT_FOUND,
                ERROR_BAD_NETPATH,
                ERROR_BAD_NET_NAME));

            if (dwWin32Error != ERROR_SUCCESS)
            {
                Parameters->SystemDefaultActCxtGenerationResult = BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_NOT_FOUND;
                FN_SUCCESSFUL_EXIT();
            }

            if (Parameters->Manifest.Path == NULL)
                Parameters->Manifest.Path = sbManifestFileName;

            Parameters->Manifest.Stream = SystemDefaultManifestFileStream;
        }

        // Ensure that there's a trailing slash...
        IFW32FALSE_EXIT(sbAssemblyDirectory.Win32Assign(Parameters->AssemblyDirectory, ::wcslen(Parameters->AssemblyDirectory)));
        IFW32FALSE_EXIT(sbAssemblyDirectory.Win32EnsureTrailingPathSeparator());

        Parameters->AssemblyDirectory = sbAssemblyDirectory;
        DWORD dwFlags = 0;
        if (Parameters->Flags & SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY)
            dwFlags |= SXS_GENERATE_ACTCTX_SYSTEM_DEFAULT;
        if(Parameters->Flags & SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_APP_RUNNING_IN_SAFEMODE)
        {
            ASSERT(dwFlags == 0);
            dwFlags |= SXS_GENERATE_ACTCTX_APP_RUNNING_IN_SAFEMODE;
        }

        // Allocate and initialize the activation context generation context
        IFW32FALSE_EXIT(
            ::SxspInitActCtxGenCtx(
                pActCtxGenCtx,                  // context out
                MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT,
                dwFlags,
                0,                              // operation-specific flags
                ImpersonationData,
                Parameters->ProcessorArchitecture,
                Parameters->LangId,
                ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE,
                ::wcslen(Parameters->AssemblyDirectory),
                Parameters->AssemblyDirectory));

        if (Parameters->Policy.Stream != NULL)
        {
            SIZE_T cchPolicyPath = (Parameters->Policy.Path != NULL) ? ::wcslen(Parameters->Policy.Path): 0;

            // Do the policy thing...
            IFW32FALSE_EXIT(
                ::SxspParseApplicationPolicy(
                    0,
                    pActCtxGenCtx,
                    ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE,
                    Parameters->Policy.Path,
                    cchPolicyPath,
                    Parameters->Policy.Stream));
        }

        // Add this manifest (and its policy file) to the context
        IFW32FALSE_EXIT(
            ::SxspAddRootManifestToActCtxGenCtx(
                pActCtxGenCtx,
                Parameters));

        // Add its dependencies, and their dependencies, etc. until there's nothing more to add
        IFW32FALSE_EXIT_UNLESS(
            ::SxspCloseManifestGraph(pActCtxGenCtx),
                ((Parameters->Flags & SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY) && (::FusionpGetLastWin32Error() == ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED)),
                fSxspCloseManifestGraph);

        if (fSxspCloseManifestGraph)
        {
            Parameters->SystemDefaultActCxtGenerationResult |= BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_DEPENDENCY_ASSEMBLY_NOT_FOUND;
            fSuccess = TRUE;
            goto Exit;
        }

        // Build the activation context data blob.
        IFW32FALSE_EXIT(::SxspBuildActCtxData(pActCtxGenCtx, &Parameters->SectionObjectHandle));
        fSuccess = TRUE;
    }

Exit:
#if IF_FUSION_LOG_ACTCTX_ACTION
    SxspLogActCtxAction(ts, Parameters);
#endif // defined(_X86_)

#undef IS_NT_DOS_PATH

    // for system default stream,
    if  (Parameters->Manifest.Stream == SystemDefaultManifestFileStream)
        Parameters->Manifest.Stream  = NULL;

    if (pActCtxGenCtx)
        FUSION_DELETE_SINGLETON(pActCtxGenCtx);



    if (!fSuccess) // put a win32-error-message into eventlog
    {
        CSxsPreserveLastError ple;
#if !DBG
        BOOL fAreWeInOSSetupMode = FALSE;
        //
        // If we can't determine this, then let the first error through.
        //
        if (!::FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode) || !fAreWeInOSSetupMode)
#endif
        {
            ::FusionpLogError(
                MSG_SXS_FUNCTION_CALL_FAIL,
                CEventLogString(L"Generate Activation Context"),
                (Parameters->Manifest.Path != NULL) ? CEventLogString(static_cast<PCWSTR>(Parameters->Manifest.Path)) : CEventLogString(L"Manifest Filename Unknown"),
                CEventLogLastError(ple.LastError()));
#if DBG
            ::DbgPrintSxsGenerateActivationContextParameters(
                FUSION_DBG_LEVEL_ERROR,
                Parameters,
                __FUNCTION__);
#endif
        }
        ple.Restore();
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\strsectgen.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    strsectgen.cpp

Abstract:

    C-ish wrapper around CSSGenCtx object used to generate a string section.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "ssgenctx.h"

BOOL
SxsInitStringSectionGenerationContext(
    OUT PSTRING_SECTION_GENERATION_CONTEXT *SSGenContext,
    IN ULONG DataFormatVersion,
    IN BOOL CaseInSensitive,
    IN STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    IN LPVOID Context
    )
{
    return CSSGenCtx::Create(
            SSGenContext,
            DataFormatVersion,
            CaseInSensitive,
            CallbackFunction,
            Context);
}

PVOID
WINAPI
SxsGetStringSectionGenerationContextCallbackContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    )
{
    return reinterpret_cast<CSSGenCtx *>(SSGenContext)->GetCallbackContext();
}

VOID
WINAPI
SxsDestroyStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    )
{
    if (SSGenContext != NULL)
    {
        reinterpret_cast<CSSGenCtx *>(SSGenContext)->DeleteYourself();
    }
}

BOOL
WINAPI
SxsAddStringToStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN PCWSTR String,
    IN SIZE_T StringCch,
    IN PVOID DataContext,
    IN ULONG AssemblyRosterIndex,
    IN DWORD DuplicateErrorCode
    )
{
    return reinterpret_cast<CSSGenCtx *>(SSGenContext)->Add(String, StringCch, DataContext, AssemblyRosterIndex, DuplicateErrorCode);
}

BOOL
WINAPI
SxsFindStringInStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN PCWSTR String,
    IN SIZE_T Cch,
    OUT PVOID *DataContext,
    OUT BOOL *Found
    )
{
    return reinterpret_cast<CSSGenCtx *>(SSGenContext)->Find(String, Cch, DataContext, Found);
}

BOOL
WINAPI
SxsDoneModifyingStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    )
{
    return reinterpret_cast<CSSGenCtx *>(SSGenContext)->DoneAdding();
}

BOOL
WINAPI
SxsGetStringSectionGenerationContextSectionSize(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    OUT PSIZE_T DataSize
    )
{
    return reinterpret_cast<CSSGenCtx *>(SSGenContext)->GetSectionSize(DataSize);
}

BOOL
WINAPI
SxsGetStringSectionGenerationContextSectionData(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT PSIZE_T BytesWritten OPTIONAL
    )
{
    return reinterpret_cast<CSSGenCtx *>(SSGenContext)->GetSectionData(BufferSize, Buffer, BytesWritten);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsasmcache.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsasmcache.h

Abstract:

    CAssemblyCache implementation for installation

Author:

    Xiaoyu Wu (xiaoyuw) April 2000

Revision History:

--*/
#if !defined(_FUSION_SXS_ASMCACHE_H_INCLUDED_)
#define _FUSION_SXS_ASMCACHE_H_INCLUDED_

#pragma once

#include "fusion.h"

// CAssemblyCache declaration.
class CAssemblyCache : public IAssemblyCache
{
public:

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IAssemblyCache methods
    STDMETHOD (UninstallAssembly)(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszAssemblyName, // uncanonicalized, comma separted name=value pairs.
        /* [in] */ LPCFUSION_INSTALL_REFERENCE lpReference,
        /* [out, optional] */ ULONG *pulDisposition
        );

    STDMETHOD (QueryAssemblyInfo)(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszAssemblyName,
        /* [in, out] */ ASSEMBLY_INFO *pAsmInfo
        );

    STDMETHOD (CreateAssemblyCacheItem)(
        /* [in] */ DWORD dwFlags,
        /* [in] */ PVOID pvReserved,
        /* [out] */ IAssemblyCacheItem **ppAsmItem,
        /* [in, optional] */ LPCWSTR pszAssemblyName  // uncanonicalized, comma separted name=value pairs.
        );

    STDMETHOD (InstallAssembly)( // if you use this, fusion will do the streaming & commit.
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszManifestFilePath,
        /* [in] */ LPCFUSION_INSTALL_REFERENCE lpReference
        );

    STDMETHOD(CreateAssemblyScavenger) (
        /* [out] */ IAssemblyScavenger **ppAsmScavenger
        );

    CAssemblyCache():m_cRef(0)
    {
    }

    ~CAssemblyCache()
    {
        ASSERT_NTC(m_cRef == 0);
    }

private :
    ULONG               m_cRef;
};

#endif // _FUSION_SXS_ASMCACHE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsasmname.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsname.h

Abstract:

    IAssemblyName implementation for MSI

Author:

    Xiaoyu Wu (xiaoyuw) May 2000

Revision History:
    xiaoyuw     09/29//2000     replace attributes with AssemblyIdentity

--*/
#if !defined(_FUSION_SXS_ASMNAME_H_INCLUDED_)
#define _FUSION_SXS_ASMNAME_H_INCLUDED_

#pragma once

#include "fusion.h"
#include "forwarddeclarations.h"
#include "fusionbuffer.h"

typedef
enum _SXS_ASSEMBLY_NAME_PROPERTY
    {
    SXS_ASM_NAME_NAME                   = 0,
    SXS_ASM_NAME_VERSION                = SXS_ASM_NAME_NAME+ 1,
    SXS_ASM_NAME_PROCESSORARCHITECTURE  = SXS_ASM_NAME_VERSION+ 1,
    SXS_ASM_NAME_LANGUAGE               = SXS_ASM_NAME_PROCESSORARCHITECTURE + 1,
    SXS_ASM_NAME_TYPE                   = SXS_ASM_NAME_LANGUAGE + 1,
    SXS_ASM_NAME_PUBLICKEYTOKEN         = SXS_ASM_NAME_TYPE + 1
}SXS_ASSEMBLY_NAME_PROPERTY;

class CAssemblyName : public IAssemblyName
{
private:
    DWORD               m_cRef;

    PASSEMBLY_IDENTITY  m_pAssemblyIdentity;
    BOOL                m_fIsFinalized;

public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IAssemblyName methods
    STDMETHOD(SetProperty)(
        /* in */ DWORD  PropertyId,
        /* in */ LPVOID pvProperty,
        /* in */ DWORD  cbProperty);

    STDMETHOD(GetProperty)(
        /* in      */  DWORD    PropertyId,
        /*     out */  LPVOID   pvProperty,
        /* in  out */  LPDWORD  pcbProperty);

    STDMETHOD(Finalize)();

    STDMETHOD(GetDisplayName)(
        /* [out]   */   LPOLESTR  szDisplayName,
        /* in  out */   LPDWORD   pcbDisplayName,
        /* [in]    */   DWORD     dwDisplayFlags);

    STDMETHOD(GetName)(
        /* [out][in] */ LPDWORD lpcbBuffer,
        /* [out] */ WCHAR  __RPC_FAR *pwzName);

    STDMETHOD(GetVersion)(
        /* [out] */ LPDWORD pwVersionHi,
        /* [out] */ LPDWORD pwVersionLow);

    STDMETHOD (IsEqual)(
        /* [in] */ LPASSEMBLYNAME pName,
        /* [in] */ DWORD dwCmpFlags);

    STDMETHOD(BindToObject)(
        /* in      */  REFIID               refIID,
        /* in      */  IAssemblyBindSink   *pAsmBindSink,
        /* in      */  IApplicationContext *pAppCtx,
        /* in      */  LPCOLESTR            szCodebase,
        /* in      */  LONGLONG             llFlags,
        /* in      */  LPVOID               pvReserved,
        /* in      */  DWORD                cbReserved,
        /*     out */  VOID                 **ppv);

    STDMETHODIMP Clone(IAssemblyName **ppName);
    HRESULT Parse(LPCWSTR szDisplayName);

    CAssemblyName();
    ~CAssemblyName();

    HRESULT Init(LPCWSTR szDisplayName, PVOID pData);
    HRESULT GetInstalledAssemblyName(DWORD Flags, ULONG PathType, CBaseStringBuffer &rbuffPath);
    HRESULT DetermineAssemblyType( BOOL &fIsPolicy );
    HRESULT IsAssemblyInstalled(BOOL & fInstalled);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsasmcache.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsasmcache.cpp

Abstract:

    CAssemblyCache implementation for installation

Author:

    Xiaoyu Wu (xiaoyuw) April 2000

Revision History:
    xiaoyuw     10/26/2000      revise during Bate2 code review period
    xiaoyuw     12/21/2000      using new API

--*/

#include "stdinc.h"
#include "fusionbuffer.h"
#include "sxsp.h"
#include "sxsasmitem.h"
#include "sxsasmcache.h"
#include "sxsasmname.h"
#include "fusiontrace.h"


STDAPI
CreateAssemblyCache(IAssemblyCache **ppAsmCache, DWORD dwReserved)
{
    HRESULT  hr = NOERROR;
    FN_TRACE_HR(hr);
    CSmartPtr<CAssemblyCache> pAsmCache;

    if (ppAsmCache != NULL)
        *ppAsmCache = NULL;

    PARAMETER_CHECK(ppAsmCache != NULL);

    IFW32FALSE_EXIT(pAsmCache.Win32Allocate(__FILE__, __LINE__));
    IFCOMFAILED_EXIT(pAsmCache->QueryInterface(IID_IAssemblyCache, (PVOID*)ppAsmCache));
    pAsmCache.Detach();

    hr = NOERROR;
Exit:
    return hr;
}


// Fusion -> Sxs
BOOL
SxspTranslateReferenceFrom( 
    IN LPCFUSION_INSTALL_REFERENCE pFusionReference, 
    OUT SXS_INSTALL_REFERENCEW &SxsReference
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(pFusionReference != NULL);
    PARAMETER_CHECK(pFusionReference->cbSize <= SxsReference.cbSize);

    if (RTL_CONTAINS_FIELD(pFusionReference, pFusionReference->cbSize, guidScheme) &&
        RTL_CONTAINS_FIELD(&SxsReference, SxsReference.cbSize, guidScheme))
            SxsReference.guidScheme = pFusionReference->guidScheme;

    if (RTL_CONTAINS_FIELD(pFusionReference, pFusionReference->cbSize, szIdentifier) &&
        RTL_CONTAINS_FIELD(&SxsReference, SxsReference.cbSize, lpIdentifier))
            SxsReference.lpIdentifier = pFusionReference->szIdentifier;

    if (RTL_CONTAINS_FIELD(pFusionReference, pFusionReference->cbSize, szNonCannonicalData) &&
        RTL_CONTAINS_FIELD(&SxsReference, SxsReference.cbSize, lpNonCanonicalData))
            SxsReference.lpNonCanonicalData = pFusionReference->szNonCannonicalData;

    FN_EPILOG
}

// Sxs -> Fusion
BOOL
SxspTranslateReferenceFrom(
    IN PCSXS_INSTALL_REFERENCEW pSxsReference,
    OUT FUSION_INSTALL_REFERENCE &FusionReference
    )
{
    FN_PROLOG_WIN32

    //
    // Pointer must be non-null, and the SXS structure must be either
    // the same size or smaller than the equivalent Fusion structure.
    //
    PARAMETER_CHECK(pSxsReference);

    //
    // Assume size has been set by caller.
    //
    PARAMETER_CHECK(pSxsReference->cbSize <= FusionReference.cbSize);

    if (RTL_CONTAINS_FIELD(&FusionReference, FusionReference.cbSize, guidScheme) &&
        RTL_CONTAINS_FIELD(pSxsReference, pSxsReference->cbSize, guidScheme))
            FusionReference.guidScheme = pSxsReference->guidScheme;

    if (RTL_CONTAINS_FIELD(&FusionReference, FusionReference.cbSize, szIdentifier) &&
        RTL_CONTAINS_FIELD(pSxsReference, pSxsReference->cbSize, lpIdentifier))
            FusionReference.szIdentifier = pSxsReference->lpIdentifier;

    if (RTL_CONTAINS_FIELD(&FusionReference, FusionReference.cbSize, szNonCannonicalData) &&
        RTL_CONTAINS_FIELD(pSxsReference, pSxsReference->cbSize, lpNonCanonicalData))
            FusionReference.szNonCannonicalData = pSxsReference->lpNonCanonicalData;

    FN_EPILOG
}


STDMETHODIMP
CAssemblyCache::UninstallAssembly(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszAssemblyName,
        /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
        /* [out, optional] */ ULONG *pulDisposition)
{
    HRESULT hr=S_OK;
    FN_TRACE_HR(hr);

    SXS_UNINSTALLW Uninstall;
    SXS_INSTALL_REFERENCEW Reference = { sizeof(Reference) };
    DWORD dwDisposition;

    if (pulDisposition != NULL)
        *pulDisposition = 0;

    PARAMETER_CHECK((pszAssemblyName!= NULL) && (dwFlags ==0));

    ZeroMemory(&Uninstall, sizeof(Uninstall));
    Uninstall.cbSize = sizeof(Uninstall);
    Uninstall.lpAssemblyIdentity = pszAssemblyName;

    if (pRefData != NULL)
    {
        IFW32FALSE_EXIT(::SxspTranslateReferenceFrom(pRefData, Reference));
        Uninstall.lpInstallReference = &Reference;
        Uninstall.dwFlags |= SXS_UNINSTALL_FLAG_REFERENCE_VALID;
    }

    IFW32FALSE_EXIT(::SxsUninstallW(&Uninstall, &dwDisposition));

    if (pulDisposition != NULL)
        *pulDisposition = static_cast<DWORD>(dwDisposition);
    
    FN_EPILOG
}

STDMETHODIMP CAssemblyCache::QueryAssemblyInfo(
        /* [in] */  DWORD dwFlags,
        /* [in] */  LPCWSTR pwzTextualAssembly,
        /* [in, out] */ ASSEMBLY_INFO *pAsmInfo)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PARAMETER_CHECK(((dwFlags == 0) && (pwzTextualAssembly !=NULL)));
    IFW32FALSE_EXIT(::SxsQueryAssemblyInfo(dwFlags, pwzTextualAssembly, pAsmInfo));
    hr = NOERROR;
Exit:
    return hr;
}

STDMETHODIMP
CAssemblyCache::CreateAssemblyCacheItem(
        /* [in] */ DWORD dwFlags,
        /* [in] */ PVOID pvReserved,
        /* [out] */ IAssemblyCacheItem **ppAsmItem,
        /* [in, optional] */ LPCWSTR pszAssemblyName)  // uncanonicalized, comma separted name=value pairs.
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    CSmartPtr<CAssemblyCacheItem> pAsmItem;

    if (ppAsmItem != NULL)
        *ppAsmItem = NULL;

    PARAMETER_CHECK((ppAsmItem != NULL) && (dwFlags == 0) && (pvReserved == NULL));

    IFW32FALSE_EXIT(pAsmItem.Win32Allocate(__FILE__, __LINE__));
    IFCOMFAILED_EXIT(pAsmItem->Initialize());
    IFCOMFAILED_EXIT(pAsmItem->QueryInterface(IID_IAssemblyCacheItem, (PVOID*)ppAsmItem));

    pAsmItem.Detach(); // void

    hr = NOERROR;
Exit:
    return hr;
}

STDMETHODIMP
CAssemblyCache::InstallAssembly(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszManifestPath,
        /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    SXS_INSTALLW Install = { sizeof(SXS_INSTALLW) };
    SXS_INSTALL_REFERENCEW Reference = { sizeof(Reference) };

    PARAMETER_CHECK((pszManifestPath != NULL) && (dwFlags == 0));

    Install.lpManifestPath = pszManifestPath;


    if ( pRefData == NULL )
    {
        Install.dwFlags = SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN;
    }
    else
    {
        //
        // Otherwise, the pvReserved is really a "reference"
        //
        Install.dwFlags |= SXS_INSTALL_FLAG_REFERENCE_VALID;
        IFW32FALSE_EXIT(::SxspTranslateReferenceFrom(pRefData, Reference));
        Install.lpReference = &Reference;
    }
    
    IFW32FALSE_EXIT(::SxsInstallW(&Install));

    FN_EPILOG
}



STDMETHODIMP
CAssemblyCache::CreateAssemblyScavenger(
    IAssemblyScavenger **ppAsmScavenger )
{
    return E_NOTIMPL;
}

//
// IUnknown boilerplate...
//

STDMETHODIMP
CAssemblyCache::QueryInterface(REFIID riid, void** ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IAssemblyCache))
    {
        *ppvObj = static_cast<IAssemblyCache*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CAssemblyCache::AddRef()
{
    return ::SxspInterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CAssemblyCache::Release()
{
    ULONG lRet = ::SxspInterlockedDecrement(&m_cRef);
    if (!lRet)
        FUSION_DELETE_SINGLETON(this);
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsasmname.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsasmname.cpp

Abstract:

    CAssemblyName implementation for installation

Author:

    Xiaoyu Wu (xiaoyuw) May 2000

Revision History:
    xiaoyuw        09/20000    rewrite the code to use Assembly Identity
--*/

#include "stdinc.h"
#include "sxsasmname.h"
#include "fusionparser.h"
#include "sxsp.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "sxsapi.h"
#include "fusiontrace.h"

// ---------------------------------------------------------------------------
// CreateAssemblyNameObject
// ---------------------------------------------------------------------------
STDAPI
CreateAssemblyNameObject(
    LPASSEMBLYNAME    *ppAssemblyName,
    LPCOLESTR          szAssemblyName,
    DWORD              dwFlags,
    LPVOID             pvReserved
    )
{
    FN_PROLOG_HR
    CSmartPtr<CAssemblyName> pName;

    if (ppAssemblyName)
        *ppAssemblyName = NULL ;

    // validate dwFlags
    // BUGBUG : the valid value of dwFlags are CANOF_PARSE_DISPLAY_NAME and CANOF_SET_DEFAULT_VALUES, but  CANOF_SET_DEFAULT_VALUES
    // is never used...
    // xiaoyuw@10/02/2000
    //
    PARAMETER_CHECK(dwFlags == CANOF_PARSE_DISPLAY_NAME);
    PARAMETER_CHECK(ppAssemblyName != NULL);
    PARAMETER_CHECK(pvReserved == NULL);    
    IFW32FALSE_EXIT(pName.Win32Allocate(__FILE__, __LINE__));

    if (dwFlags & CANOF_PARSE_DISPLAY_NAME)
        IFCOMFAILED_EXIT(pName->Parse((LPWSTR)szAssemblyName));

    IFCOMFAILED_EXIT(pName->QueryInterface(IID_IAssemblyName, (PVOID*)ppAssemblyName));
    pName.Detach();

    FN_EPILOG
}
STDMETHODIMP
CAssemblyName::SetProperty(DWORD PropertyId,
    LPVOID pvProperty, DWORD cbProperty)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE Attribute = NULL;

    // this function is only called inside fusion, so this fucntion has no impact on Darwin
    // maybe more should be added for Assembly Identity, such as StrongName, or random policies
    //
    if ((!pvProperty) || ((PropertyId != SXS_ASM_NAME_NAME) &&
                          (PropertyId != SXS_ASM_NAME_VERSION) &&
                          (PropertyId != SXS_ASM_NAME_TYPE) &&
                          (PropertyId != SXS_ASM_NAME_PUBLICKEYTOKEN) &&
                          (PropertyId != SXS_ASM_NAME_PROCESSORARCHITECTURE) &&
                          (PropertyId != SXS_ASM_NAME_LANGUAGE))){
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Fail if finalized.
    if (m_fIsFinalized){
        hr = E_UNEXPECTED;
        goto Exit;
    }

    switch (PropertyId)
    {
    case SXS_ASM_NAME_NAME:                     Attribute = &s_IdentityAttribute_name; break;
    case SXS_ASM_NAME_VERSION:                  Attribute = &s_IdentityAttribute_version; break;
    case SXS_ASM_NAME_PROCESSORARCHITECTURE:    Attribute = &s_IdentityAttribute_processorArchitecture; break;
    case SXS_ASM_NAME_LANGUAGE:                 Attribute = &s_IdentityAttribute_language; break;
    case SXS_ASM_NAME_TYPE:                        Attribute = &s_IdentityAttribute_type; break;
    case SXS_ASM_NAME_PUBLICKEYTOKEN:            Attribute = &s_IdentityAttribute_publicKeyToken; break;

    }

    INTERNAL_ERROR_CHECK(Attribute != NULL);
    IFW32FALSE_EXIT(::SxspSetAssemblyIdentityAttributeValue(0, m_pAssemblyIdentity, Attribute, (PCWSTR) pvProperty, cbProperty / sizeof(WCHAR)));

    hr = NOERROR;

Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::GetProperty
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetProperty(DWORD PropertyId,
    /* [in] */        LPVOID pvProperty,
    /* [out][in] */ LPDWORD pcbProperty)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PCWSTR pszAttributeValue = NULL;
    SIZE_T CchAttributeValue = 0;
    PCSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE Attribute = NULL;

    if ((!pvProperty) || (!pcbProperty) || ((PropertyId != SXS_ASM_NAME_NAME) &&
                          (PropertyId != SXS_ASM_NAME_VERSION) &&
                          (PropertyId != SXS_ASM_NAME_TYPE) &&
                          (PropertyId != SXS_ASM_NAME_PUBLICKEYTOKEN) &&
                          (PropertyId != SXS_ASM_NAME_PROCESSORARCHITECTURE) &&
                          (PropertyId != SXS_ASM_NAME_LANGUAGE))){
        hr = E_INVALIDARG;
        goto Exit;
    }

    switch (PropertyId)
    {
    case SXS_ASM_NAME_NAME:                     Attribute = &s_IdentityAttribute_name; break;
    case SXS_ASM_NAME_VERSION:                  Attribute = &s_IdentityAttribute_version; break;
    case SXS_ASM_NAME_PROCESSORARCHITECTURE:    Attribute = &s_IdentityAttribute_processorArchitecture; break;
    case SXS_ASM_NAME_LANGUAGE:                 Attribute = &s_IdentityAttribute_language; break;
    case SXS_ASM_NAME_TYPE:                     Attribute = &s_IdentityAttribute_type; break;
    case SXS_ASM_NAME_PUBLICKEYTOKEN:           Attribute = &s_IdentityAttribute_publicKeyToken; break;
    }

    INTERNAL_ERROR_CHECK(Attribute != NULL);

    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, m_pAssemblyIdentity, Attribute, &pszAttributeValue, &CchAttributeValue));

    // check whether we have valid attributes
    if (pszAttributeValue == NULL){ // attributes not set yet
        hr = E_UNEXPECTED;
        goto Exit;
    }
    if (CchAttributeValue * sizeof(WCHAR) > *pcbProperty) { // buffer size is not big enough
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        *pcbProperty = static_cast<DWORD>(CchAttributeValue * sizeof(WCHAR));
        goto Exit;
    }

    // copy the string into the output buffer
    memcpy(pvProperty, pszAttributeValue, CchAttributeValue *sizeof(WCHAR));
    if (pcbProperty)
        *pcbProperty = static_cast<DWORD>(CchAttributeValue * sizeof(WCHAR));

    hr = NOERROR;
Exit:
    return hr;
}
// ---------------------------------------------------------------------------
// CAssemblyName::GetName
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetName(
        /* [out][in] */ LPDWORD lpcwBuffer,
        /* [out] */     WCHAR   *pwzName)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    if (!lpcwBuffer || !pwzName){
        hr = E_INVALIDARG;
        goto Exit;
    }

    IFCOMFAILED_EXIT(this->GetProperty(SXS_ASM_NAME_NAME, pwzName, lpcwBuffer));

    FN_EPILOG
}
// ---------------------------------------------------------------------------
// CAssemblyName::GetVersion
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetVersion(
        /* [out] */ LPDWORD pdwVersionHi,
        /* [out] */ LPDWORD pdwVersionLow)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PCWSTR pszAttributeValue = NULL;
    SIZE_T CchAttributeValue = 0;
    ASSEMBLY_VERSION ver;
    bool fSyntaxValid = false;

    if ((!pdwVersionHi) || (!pdwVersionLow)){
        hr = E_INVALIDARG;
        goto Exit;
    }

    IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, m_pAssemblyIdentity, &s_IdentityAttribute_version, &pszAttributeValue, &CchAttributeValue));
    if (pszAttributeValue == NULL)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    IFW32FALSE_EXIT(CFusionParser::ParseVersion(ver, pszAttributeValue, CchAttributeValue, fSyntaxValid));
    if (!fSyntaxValid)
    {
        hr = HRESULT_FROM_WIN32(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    *pdwVersionHi  = MAKELONG(ver.Minor, ver.Major);
    *pdwVersionLow = MAKELONG(ver.Build, ver.Revision);

    FN_EPILOG
}

// ---------------------------------------------------------------------------
// CAssemblyName::IsEqual
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::IsEqual(LPASSEMBLYNAME pName, DWORD dwCmpFlags)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    BOOL fEqual = FALSE;

    PARAMETER_CHECK(pName != NULL);
    IFW32FALSE_EXIT(::SxsAreAssemblyIdentitiesEqual(0, m_pAssemblyIdentity, static_cast<CAssemblyName *>(pName)->m_pAssemblyIdentity, &fEqual));
    if (fEqual)
        hr = S_OK;
    else
        hr = E_FAIL; // not acurrate, however, it depends on Darwin caller.
Exit:
    return hr;

}
// ---------------------------------------------------------------------------
// CAssemblyName constructor
// ---------------------------------------------------------------------------
CAssemblyName::CAssemblyName():m_cRef(0),
        m_fIsFinalized(FALSE),
        m_pAssemblyIdentity(NULL)
{
}

// ---------------------------------------------------------------------------
// CAssemblyName destructor
// ---------------------------------------------------------------------------
CAssemblyName::~CAssemblyName()
{
    ASSERT_NTC(m_cRef == 0 );
    if (m_pAssemblyIdentity)
    {
        CSxsPreserveLastError ple;
        ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);
        ple.Restore();
    }
}
// ---------------------------------------------------------------------------
// CAssemblyName::Init
// ---------------------------------------------------------------------------
HRESULT
CAssemblyName::Init(LPCWSTR pszAssemblyName, PVOID pamd)
{
    HRESULT hr = S_OK;
    FN_TRACE_HR(hr);
    SIZE_T CchAssemblyName = 0;

    UNUSED(pamd);
    //ASSERT(m_pAssemblyIdentity == NULL);
    if (m_pAssemblyIdentity)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &m_pAssemblyIdentity, 0, NULL));

    // set name if present
    if (pszAssemblyName != NULL)
    {
        CchAssemblyName = wcslen(pszAssemblyName);
        IFW32FALSE_EXIT(::SxspSetAssemblyIdentityAttributeValue(0, m_pAssemblyIdentity, &s_IdentityAttribute_name, pszAssemblyName, wcslen(pszAssemblyName)));
    }

    hr = NOERROR;
Exit:
    return hr;
}
// ---------------------------------------------------------------------------
// CAssemblyName::Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyName::Clone(IAssemblyName **ppName)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    CAssemblyName *pName= NULL;

    if (ppName)
        *ppName = NULL;

    if (!ppName){
        hr = E_INVALIDARG ;
        goto Exit;
    }

    if (m_pAssemblyIdentity)
    {
        IFW32FALSE_EXIT(
            ::SxsDuplicateAssemblyIdentity(
                0,                        // DWORD Flags,
                m_pAssemblyIdentity,      // PCASSEMBLY_IDENTITY Source,
                &pAssemblyIdentity));     // PASSEMBLY_IDENTITY *Destination
    }

    IFALLOCFAILED_EXIT(pName = new CAssemblyName);
    pName->m_pAssemblyIdentity = pAssemblyIdentity;
    pAssemblyIdentity = NULL;
    *ppName = pName;
    pName = NULL;

    hr = NOERROR;
Exit:
    if (pAssemblyIdentity)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);
    if (pName)
        FUSION_DELETE_SINGLETON(pName);

    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyName::BindToObject
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::BindToObject(
        /* in      */  REFIID               refIID,
        /* in      */  IAssemblyBindSink   *pAsmBindSink,
        /* in      */  IApplicationContext *pAppCtx,
        /* in      */  LPCOLESTR            szCodebase,
        /* in      */  LONGLONG             llFlags,
        /* in      */  LPVOID               pvReserved,
        /* in      */  DWORD                cbReserved,
        /*     out */  VOID               **ppv)

{
    if (!ppv)
        return E_INVALIDARG ;

    *ppv = NULL;
    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// CAssemblyName::Finalize
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::Finalize()
{
    m_fIsFinalized = TRUE;
    return NOERROR;
}
//-----------------------------------------------------------------------------------
// CAssemblyName::GetDisplayName
// it would be name,ns1:n1="v1",ns2:n2="v2",ns3:n3="v3",ns4:n4="v4"
// I have to put name first in order not to change Darwin's code
//
// xiaoyuw@09/29/2000
//-----------------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::GetDisplayName(LPOLESTR szDisplayName,
    LPDWORD pccDisplayName, DWORD dwDisplayFlags)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    SIZE_T BufferSize;
    SIZE_T BytesWrittenOrRequired = 0;

    PARAMETER_CHECK(pccDisplayName != NULL);
    PARAMETER_CHECK((szDisplayName != NULL) || (*pccDisplayName == 0));
    PARAMETER_CHECK(dwDisplayFlags == 0);

    // Need buffer size in bytes...
    BufferSize = (*pccDisplayName) * sizeof(WCHAR);

    IFW32FALSE_EXIT(
        ::SxsEncodeAssemblyIdentity(
            0,
            m_pAssemblyIdentity,
            NULL,
            SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL,
            BufferSize,
            szDisplayName,
            &BytesWrittenOrRequired));

    if ((BufferSize - BytesWrittenOrRequired) < sizeof(WCHAR))
    {
        // We actually could fit everything but the trailing null character...
        // the BytesWrittenOrRequired actually has the right value for the exit path below;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }else // add the trailing NULL
    {
        szDisplayName[BytesWrittenOrRequired / sizeof (*szDisplayName)] = L'\0';
    }


    hr = NOERROR;

Exit:
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        *pccDisplayName = static_cast<DWORD>((BytesWrittenOrRequired / sizeof(WCHAR)) + 1);

    return hr;
}

HRESULT CAssemblyName::Parse(LPCWSTR szDisplayName)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;

    // Verify display name passed in.
    PARAMETER_CHECK(szDisplayName != NULL);
    PARAMETER_CHECK(szDisplayName[0] != L'\0');

    IFW32FALSE_EXIT(
        ::SxspCreateAssemblyIdentityFromTextualString(
            szDisplayName,
            &pAssemblyIdentity));

    if (m_pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(m_pAssemblyIdentity);

    m_pAssemblyIdentity = pAssemblyIdentity;
    pAssemblyIdentity = NULL;

    hr = NOERROR;
Exit:
    if (pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    return hr;
}
// ---------------------------------------------------------------------------
// CAssemblyName::GetInstalledAssemblyName
// ---------------------------------------------------------------------------
HRESULT
CAssemblyName::GetInstalledAssemblyName(
    IN DWORD Flags,
    IN ULONG PathType,
    CBaseStringBuffer &rBufInstallPath
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    if (Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT)
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                Flags,
                PathType,
                NULL,
                0,  
                m_pAssemblyIdentity,
                NULL,
                rBufInstallPath));

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_MSI_INSTALL,
            "SXS: %s - Generated %Iu character (root omitted) installation path:\n"
            "   \"%ls\"\n",
            __FUNCTION__, rBufInstallPath.Cch(),
            static_cast<PCWSTR>(rBufInstallPath));
    }
    else
    {
        CStringBuffer bufRootDir;

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(bufRootDir));
        IFW32FALSE_EXIT(bufRootDir.Win32EnsureTrailingPathSeparator());

        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                Flags,
                PathType,
                bufRootDir,
                bufRootDir.Cch(),
                m_pAssemblyIdentity,
                NULL,
                rBufInstallPath));

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_MSI_INSTALL,
            "SXS: %s - Generated %Iu character installation path:\n"
            "   \"%ls\"\n",
            __FUNCTION__, rBufInstallPath.Cch(),
            static_cast<PCWSTR>(rBufInstallPath));
    }

    FN_EPILOG
}


//
// this function calls SxsProbeAssemblyInstallation to decide whether an assembly installed or not.
// and fInstalled set to be TRUE only if the assembly is both INSTALLed and RESIDENT
// 
HRESULT
CAssemblyName::IsAssemblyInstalled(
    BOOL &fInstalled)
{
    FN_PROLOG_HR
    DWORD dwDisposition;

    INTERNAL_ERROR_CHECK(m_pAssemblyIdentity != NULL);

    //
    // SxsProbeAssemblyInstallation knows that if you passed the "precomposed" flag, then
    // lpAsmIdentSource really points at a PCASSEMBLY_IDENTITY structure.
    //
    IFW32FALSE_EXIT(
        SxsProbeAssemblyInstallation(
            SXS_PROBE_ASSEMBLY_INSTALLATION_IDENTITY_PRECOMPOSED,
            reinterpret_cast<PCWSTR>(static_cast<PCASSEMBLY_IDENTITY>(m_pAssemblyIdentity)),
            &dwDisposition));

    if ((dwDisposition & SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_INSTALLED) && 
        (dwDisposition & SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_RESIDENT))
    {
        fInstalled = TRUE;
    }else
    {
        fInstalled = FALSE;
    }

    FN_EPILOG
}

// IUnknown methods
// ---------------------------------------------------------------------------
// CAssemblyName::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyName::AddRef()
{
    return ::SxspInterlockedIncrement(&m_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyName::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyName::Release()
{
    ULONG lRet = ::SxspInterlockedDecrement(&m_cRef);
    if (!lRet)
        FUSION_DELETE_SINGLETON(this);
    return lRet;
}

// ---------------------------------------------------------------------------
// CAssemblyName::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyName::QueryInterface(REFIID riid, void** ppv)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyName)){
        *ppv = static_cast<IAssemblyName*> (this);
        AddRef();
        return S_OK;
    }
    else{
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


HRESULT
CAssemblyName::DetermineAssemblyType(BOOL &fIsPolicy)
{
    HRESULT hr = E_FAIL;
    FN_TRACE_HR(hr);

    INTERNAL_ERROR_CHECK( m_pAssemblyIdentity != NULL );
    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(m_pAssemblyIdentity, fIsPolicy));

    hr = S_OK;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxscabinet.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "sxsp.h"
#include "nodefactory.h"
#include "fusionarray.h"
#include "sxsinstall.h"
#include "sxspath.h"
#include "recover.h"
#include "cassemblyrecoveryinfo.h"
#include "sxsexceptionhandling.h"
#include "npapi.h"
#include "util.h"
#include "idp.h"
#include "sxscabinet.h"
#include "setupapi.h"
#include "fcntl.h"
#include "fdi.h"
#include "patchapi.h"

BOOL
SxspSimpleAnsiToStringBuffer(CHAR* pszString, UINT uiLength, CBaseStringBuffer &tgt, bool fIsUtf8)
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(pszString != NULL);

    //
    // The string buffer classes know all about converting ANSI to UNICODE strings
    //
    if (!fIsUtf8)
    {
        IFW32FALSE_EXIT(tgt.Win32Assign(pszString, uiLength));
    }
    else
    {
        CStringBufferAccessor Acc;
        int iRequired1 = 0;
        int iRequired2 = 0;

        tgt.Clear();

        Acc.Attach(&tgt);


        //
        // Attempt in-place conversion
        //
        iRequired1 = ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, pszString, uiLength, Acc, Acc.GetBufferCchAsINT());

        //
        // Zero required, and nonzero last error?  Problems, quit
        //
        if (iRequired1 == 0)
        {
            const DWORD dwWin32Error = ::FusionpGetLastWin32Error();
            if (dwWin32Error != ERROR_SUCCESS)
            {
                ORIGINATE_WIN32_FAILURE_AND_EXIT(MultiByteToWideChar, dwWin32Error);
            }
        }
        //
        // If the required chars are more than the buffer has?  Enlarge, try again
        //
        else if (iRequired1 >= Acc.GetBufferCchAsINT())
        {
            Acc.Detach();
            IFW32FALSE_EXIT(tgt.Win32ResizeBuffer(iRequired1 + 1, eDoNotPreserveBufferContents));

            Acc.Attach(&tgt);
            iRequired2 = ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, pszString, uiLength, Acc, Acc.GetBufferCchAsINT());

            //
            // If the second time around we still require more characters, someone's pulling
            // our leg, stop.
            //
            if (iRequired2 > tgt.GetBufferCchAsINT()) {
                ORIGINATE_WIN32_FAILURE_AND_EXIT(MultiByteToWideChar, ERROR_MORE_DATA);
            }
        }
    }
    //
    // Accessor will autodetach and return to the caller
    //

    FN_EPILOG

}

//
// File decompression interface helper functions
//
INT_PTR
DIAMONDAPI
sxs_FdiOpen(
    IN char* szFileName,
    IN int oFlags,
    IN int pMode)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    INT_PTR ipResult = 0;
    CMediumStringBuffer sbFileName;
    bool fValidName = false;
    bool fSuccess = false;
    CSxsPreserveLastError  ple;

    if ((oFlags & ~(_A_NAME_IS_UTF | _O_BINARY)) != 0)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR, "SXS: %s(%s, 0x%x, 0x%x) - invalid flags\n",
            __FUNCTION__,
            szFileName,
            oFlags,
            pMode);
        ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        ipResult = -1;
        goto Exit;
    }

    if (!::SxspSimpleAnsiToStringBuffer(szFileName, (UINT)strlen(szFileName), sbFileName, (oFlags & _A_NAME_IS_UTF) != 0))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR,
            "SXS: %s failed converting %s to unicode, lasterror=0x%08lx\n",
            __FUNCTION__,
            szFileName,
            ::FusionpGetLastWin32Error());

        ipResult = -1;
        goto Exit;
    }

    hFile = ::CreateFileW(
        sbFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        INVALID_HANDLE_VALUE);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR,
            "SXS: %s failed opening file %ls, lasterror=0x%08lx\n",
            __FUNCTION__,
            static_cast<PCWSTR>(sbFileName),
            ::FusionpGetLastWin32Error());

        ipResult = -1;
        goto Exit;
    }
    else
    {
        ipResult = reinterpret_cast<INT_PTR>(hFile);
    }
    
    fSuccess = true;
Exit:
    if (fSuccess)
    {
        ple.Restore();
    }
    return ipResult;
}


//
// Thin shim around ReadFile for the Diamond APIs
//
UINT
DIAMONDAPI
sxs_FdiRead(
    INT_PTR hf,
    void* pv,
    UINT cb)
{
    DWORD dwRetVal = 0;
    UINT uiResult = 0;
    CSxsPreserveLastError ple;

    if (::ReadFile(reinterpret_cast<HANDLE>(hf), pv, cb, &dwRetVal, NULL))
    {
        uiResult = (UINT)dwRetVal;
        ple.Restore();
    }
    else
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR,
            "SXS: %s failed reading %d bytes from handle %p, error 0x%08lx\n",
            __FUNCTION__,
            cb,
            hf,
            ::FusionpGetLastWin32Error());

        uiResult = (UINT)-1;
    }

    return uiResult;
}


//
// Thin shim around WriteFile for the Diamond APIs
//
UINT
DIAMONDAPI
sxs_FdiWrite(
    INT_PTR hf,
    void* pv,
    UINT cb)
{
    DWORD dwRetVal = 0;
    UINT uiResult = 0;
    CSxsPreserveLastError ple;

    if (::WriteFile(reinterpret_cast<HANDLE>(hf), pv, cb, &dwRetVal, NULL))
    {
        uiResult = (UINT)dwRetVal;
        ple.Restore();
    }
    else
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR,
            "SXS: %s failed reading %d bytes to handle %p, error 0x%08lx\n",
            __FUNCTION__,
            cb,
            hf,
            ::FusionpGetLastWin32Error());

        uiResult = (UINT)-1;
    }

    return uiResult;
}

//
// Thin shim around CloseHandle for the Diamond APIs
//
INT
DIAMONDAPI
sxs_FdiClose(
    INT_PTR hr)
{
    INT iResult;
    CSxsPreserveLastError ple;

    if (::CloseHandle(reinterpret_cast<HANDLE>(hr)))
    {
        iResult = 0;
        ple.Restore();
    }
    else
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR,
            "SXS: %s failed closing handle %p, error 0x%08lx\n",
            __FUNCTION__,
            hr,
            ::FusionpGetLastWin32Error());

        iResult = -1;
    }

    return iResult;
}

//
// Thin shim around SetFilePos for the Diamond APIs
//
long
DIAMONDAPI
sxs_FdiSeek(
    INT_PTR hf,
    long dist,
    int seekType)
{
    DWORD dwSeekType = 0;
    DWORD dwResult = 0;
    long lResult = 0;
    CSxsPreserveLastError ple;
    bool fSuccess = false;

    switch(seekType)
    {
    case SEEK_SET:
        dwSeekType = FILE_BEGIN;
        break;
    case SEEK_END:
        dwSeekType = FILE_END;
        break;
    case SEEK_CUR:
        dwSeekType = FILE_CURRENT;
        break;
    default:
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR,
            "SXS: %s invalid seek type %d\n",
            seekType,
            ::FusionpGetLastWin32Error());
        ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    dwResult = ::SetFilePointer(reinterpret_cast<HANDLE>(hf), dist, NULL, dwSeekType);
    if (dwResult == 0xFFFFFFFF)
    {
        lResult = -1;

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR,
            "SXS: %s seek type %d, offset %l, handle %p, error 0x%08lx\n",
            __FUNCTION__,
            seekType, dist, hf,
            ::FusionpGetLastWin32Error());
        goto Exit;
    }
    else
    {
        lResult = dwResult;
    }

    fSuccess = true;
Exit:
    if (fSuccess)
    {
        ple.Restore();
    }

    return lResult;
}

FNALLOC(sxs_FdiAlloc)
{
    PVOID pv;
    CSxsPreserveLastError ple;

    pv = FUSION_RAW_ALLOC(cb, __FUNCTION__);

    if (pv != NULL)
    {
        ple.Restore();
    }

    return pv;
}

FNFREE(sxs_FdiFree)
{
    CSxsPreserveLastError ple;

    if (FUSION_RAW_DEALLOC(pv))
    {
        ple.Restore();
    }
}


BOOL
SxspShouldExtractThisFileFromCab(
    CCabinetData *pState,
    const CBaseStringBuffer &FilePathInCab,
    bool &rfShouldExtract)
{
    FN_PROLOG_WIN32

    rfShouldExtract = false;
    if (pState->m_pfnShouldExtractThisFileFromCabCallback == NULL)
    {
        rfShouldExtract = true;
    }
    else
    {
        IFW32FALSE_EXIT((*pState->m_pfnShouldExtractThisFileFromCabCallback)(
            FilePathInCab,
            rfShouldExtract,
            pState->m_pvShouldExtractThisFileFromCabCallbackContext));
    }
    FN_EPILOG
}

BOOL
sxs_Win32FdiExtractionNotify(
    FDINOTIFICATIONTYPE NotifyType,
    PFDINOTIFICATION    NotifyData,
    INT_PTR             &ripResult)
{
    FN_PROLOG_WIN32
    CCabinetData* const pState = reinterpret_cast<CCabinetData*>(NotifyData->pv);

    ripResult = 0;

    switch (NotifyType)
    {
    case fdintCABINET_INFO: // FALLTHROUGH
    case fdintENUMERATE:
        ripResult = 0; // ignore, success
        break;

    case fdintNEXT_CABINET: // FALLTHROUGH
    case fdintPARTIAL_FILE:
        //
        // we don't handle files split across multiple .cabs
        //
        ripResult = -1;
        INTERNAL_ERROR_CHECK(FALSE);
        break;

    case fdintCOPY_FILE:
        ripResult = -1; // assume failure
        {
            SIZE_T c = 0;
            bool fValidPath = false;
            bool fShouldExtract = false;

            PARAMETER_CHECK(pState != NULL);

            pState->sxs_FdiExtractionNotify_fdintCOPY_FILE.Clear();

            CFusionFile hNewFile;
            CStringBuffer &TempBuffer = pState->sxs_FdiExtractionNotify_fdintCOPY_FILE.TempBuffer;
            CStringBuffer &TempBuffer2 = pState->sxs_FdiExtractionNotify_fdintCOPY_FILE.TempBuffer2;

            //
            // Add this assembly to those being extracted
            //
            IFW32FALSE_EXIT(
                ::SxspSimpleAnsiToStringBuffer(
                    NotifyData->psz1,
                    (UINT)strlen(NotifyData->psz1),
                    TempBuffer2,
                    ((NotifyData->attribs & _A_NAME_IS_UTF) != 0)));

            IFW32FALSE_EXIT(::SxspIsFileNameValidForManifest(TempBuffer2, fValidPath));
            PARAMETER_CHECK(fValidPath);

            IFW32FALSE_EXIT(TempBuffer2.Win32GetFirstPathElement(TempBuffer));

            //
            // But only if it's not there already
            //
            for (c = 0; c < pState->m_AssembliesExtracted.GetSize(); c++)
            {
                const CStringBuffer &sb = pState->m_AssembliesExtracted[c];
                bool fMatches = false;

                IFW32FALSE_EXIT(sb.Win32Equals(TempBuffer, fMatches, true));

                if (fMatches) break;
            }

            // Ran off end w/o finding means add it to the list.
            if (c == pState->m_AssembliesExtracted.GetSize())
            {
                IFW32FALSE_EXIT(pState->m_AssembliesExtracted.Win32Append(TempBuffer));
            }

            if (!pState->IsExtracting())
            {
                ripResult = 0; // skip file, but no error
                FN_SUCCESSFUL_EXIT();
            }

            IFW32FALSE_EXIT(::SxspShouldExtractThisFileFromCab(pState, TempBuffer2, fShouldExtract));
            if (!fShouldExtract)
            {
                ripResult = 0; // skip file, but no error
                FN_SUCCESSFUL_EXIT();
            }
            //
            // Ensure that {base extract path}\{path in cab} exists.
            //
            IFW32FALSE_EXIT(::SxspCreateMultiLevelDirectory(
                pState->BasePath(),
                TempBuffer));

            //
            // Blob together {base extract path}\{path in cab}\{filename}
            //
            IFW32FALSE_EXIT(TempBuffer.Win32Assign(pState->BasePath()));
            IFW32FALSE_EXIT(TempBuffer.Win32AppendPathElement(TempBuffer2));

            //
            // And away we go!
            //
            IFW32FALSE_EXIT(hNewFile.Win32CreateFile(
                TempBuffer,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                (pState->GetReplaceExisting() ? CREATE_ALWAYS : CREATE_NEW)));

            ripResult = reinterpret_cast<INT_PTR>(hNewFile.Detach());
        }
        break;

    case fdintCLOSE_FILE_INFO:
        ripResult = FALSE; // assume failure
        {
            const HANDLE hFileToClose = reinterpret_cast<HANDLE>(NotifyData->hf);
            if ((hFileToClose != NULL) && (hFileToClose != INVALID_HANDLE_VALUE))
                IFW32FALSE_ORIGINATE_AND_EXIT(::CloseHandle(hFileToClose));
        }
        ripResult = TRUE;
        break;
    }
    FN_EPILOG
}

FNFDINOTIFY(sxs_FdiExtractionNotify)
{
    INT_PTR ipResult = 0;
    CSxsPreserveLastError ple;

    if (sxs_Win32FdiExtractionNotify(fdint, pfdin, ipResult))
    {
        ple.Restore();
    }
    return ipResult;
}

BOOL
SxspExpandCabinetIntoTemp(
    DWORD dwFlags,
    const CBaseStringBuffer &buffCabinetPath,
    CImpersonationData &ImpersonateData,
    CCabinetData* pCabinetData)
{
    FN_PROLOG_WIN32

    CImpersonate impersonate(ImpersonateData);
    CFileStreamBase fsb;
    static const BYTE s_CabSignature[] = { 'M', 'S', 'C', 'F' };
    BYTE SignatureBuffer[NUMBER_OF(s_CabSignature)] = {0};
    ULONG ulReadCount = 0;
    CFusionArray<CHAR> CabinetPathConverted;
    HFDI hCabinet = NULL;
    ERF ErfObject = { 0 };
    DWORD dwFailureCode = 0;

    CDynamicLinkLibrary SetupApi;
    BOOL (DIAMONDAPI *pfnFDICopy)(HFDI, char *, char *, int, PFNFDINOTIFY, PFNFDIDECRYPT, void *) = NULL;
    HFDI (DIAMONDAPI *pfnFDICreate)(PFNALLOC, PFNFREE, PFNOPEN, PFNREAD, PFNWRITE, PFNCLOSE, PFNSEEK, int, PERF) = NULL;
    BOOL (DIAMONDAPI *pfnFDIDestroy)(HFDI) = NULL;

    PARAMETER_CHECK(pCabinetData != NULL);
    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(!buffCabinetPath.IsEmpty());

    //
    // Sniff the cabinet for the 'mscf' compressed-file marker
    //
    {
        //
        // Need to be in user's context when doing this.
        //
        IFW32FALSE_EXIT(impersonate.Impersonate());

        //
        // Open the cabinet for streaming
        //
        IFW32FALSE_EXIT(fsb.OpenForRead(
            buffCabinetPath,
            ImpersonateData,
            FILE_SHARE_READ,
            OPEN_EXISTING,
            0));

        IFCOMFAILED_EXIT(fsb.Read(SignatureBuffer, sizeof(SignatureBuffer), &ulReadCount));

        if (ulReadCount >= 4)
        {
            if (memcmp(SignatureBuffer, s_CabSignature, sizeof(SignatureBuffer)) != 0)
            {
                // Can't use this catalog file!
                ORIGINATE_WIN32_FAILURE_AND_EXIT(SxspExpandCabinetIntoTemp, ERROR_INVALID_PARAMETER);
            }
        }

        IFW32FALSE_EXIT(fsb.Close());
        IFW32FALSE_EXIT(impersonate.Unimpersonate());
    }

    IFW32FALSE_EXIT(SetupApi.Win32LoadLibrary(L"cabinet.dll"));
    IFW32FALSE_EXIT(SetupApi.Win32GetProcAddress("FDICreate", &pfnFDICreate));
    IFW32FALSE_EXIT(SetupApi.Win32GetProcAddress("FDICopy", &pfnFDICopy));
    IFW32FALSE_EXIT(SetupApi.Win32GetProcAddress("FDIDestroy", &pfnFDIDestroy));
    //
    // Now create the FDI cabinet object
    //
    hCabinet = (*pfnFDICreate)(
        &sxs_FdiAlloc,
        &sxs_FdiFree,
        &sxs_FdiOpen,
        &sxs_FdiRead,
        &sxs_FdiWrite,
        &sxs_FdiClose,
        &sxs_FdiSeek,
        cpuUNKNOWN,
        &ErfObject);

    //
    // Convert string.
    //
    {
        SIZE_T iSize = ::WideCharToMultiByte(
            CP_ACP,
            WC_NO_BEST_FIT_CHARS,
            buffCabinetPath,
            buffCabinetPath.GetCchAsINT(),
            NULL,
            0,
            NULL,
            NULL);

        if (iSize >= CabinetPathConverted.GetSize())
        {
            IFW32FALSE_EXIT(CabinetPathConverted.Win32SetSize(
                iSize + 2,
                CFusionArray<CHAR>::eSetSizeModeExact));
        }
        else if (iSize == 0)
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(WideCharToMultiByte, ::FusionpGetLastWin32Error());
        }

        iSize = ::WideCharToMultiByte(
            CP_ACP,
            WC_NO_BEST_FIT_CHARS,
            buffCabinetPath,
            buffCabinetPath.GetCchAsINT(),
            CabinetPathConverted.GetArrayPtr(),
            (int)CabinetPathConverted.GetSize(),
            NULL,
            NULL);

        if (iSize == 0)
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(WideCharToMultiByte, ::FusionpGetLastWin32Error());
        }
        (CabinetPathConverted.GetArrayPtr())[iSize] = 0;
    }

    ::FusionpSetLastWin32Error(NO_ERROR);

    //
    // Do the extraction
    //
    const BOOL fResult = (*pfnFDICopy)(
        hCabinet,
        CabinetPathConverted.GetArrayPtr(),
        "",
        0,
        sxs_FdiExtractionNotify,
        NULL,
        static_cast<PVOID>(pCabinetData));
    dwFailureCode = ::FusionpGetLastWin32Error();

    //
    // Ignore errors here like setupapi.dll does.
    //
    IFW32FALSE_EXIT((*pfnFDIDestroy)(hCabinet));

    //
    // Failure?  Luckily, we went to great lengths to ensure that lasterror is maintained, so
    // this should just be derivable from the last win32 error.
    //
    if (!fResult)
    {
        //
        // But, if something inside the cab code itself failed, then we should do something
        // about mapping the error result.
        //
        if (dwFailureCode == ERROR_SUCCESS)
        {
            switch (ErfObject.erfOper)
            {
                // Should never get these back if the lasterror was success.
            case FDIERROR_TARGET_FILE:
            case FDIERROR_USER_ABORT:
            case FDIERROR_NONE:
                ASSERT(FALSE && "Some internal cabinet problem");
                dwFailureCode = ERROR_INTERNAL_ERROR;
                break;

            case FDIERROR_NOT_A_CABINET:
            case FDIERROR_UNKNOWN_CABINET_VERSION:
            case FDIERROR_BAD_COMPR_TYPE:
            case FDIERROR_MDI_FAIL:
            case FDIERROR_RESERVE_MISMATCH:
            case FDIERROR_WRONG_CABINET:
                dwFailureCode = ERROR_INVALID_DATA;
                break;
                
            case FDIERROR_CABINET_NOT_FOUND:
                dwFailureCode = ERROR_FILE_NOT_FOUND;
                break;

            case FDIERROR_ALLOC_FAIL:
                dwFailureCode = ERROR_NOT_ENOUGH_MEMORY;
                break;

                break;
                
            }
            
            ASSERT(dwFailureCode != ERROR_SUCCESS);
            if (dwFailureCode == ERROR_SUCCESS)
            {
                dwFailureCode = ERROR_INTERNAL_ERROR;
            }
        }

        //
        // Now that we've mapped it, originate it.
        //
        ORIGINATE_WIN32_FAILURE_AND_EXIT(FDICopy, dwFailureCode);
    }

    FN_EPILOG
}

class CSxspFindManifestInCabinetPathLocals
{
public:
    CSxspFindManifestInCabinetPathLocals() { }
    ~CSxspFindManifestInCabinetPathLocals() { }

    void Clear()
    //
    // Clear is how you deal with the fact that some function calls were in loops
    // and/or some local variables were in loops.
    //
    // In "lifting up" the variables, we lose the repeated constructor/destructor calls.
    //
    {
    }

    WIN32_FIND_DATAW FindData;
};

BOOL
SxspFindManifestInCabinetPath(
    const CBaseStringBuffer &rcsBasePath,
    const CBaseStringBuffer &rcsSubPath,
    CBaseStringBuffer &ManifestPath,
    bool &rfFound,
    CSxspFindManifestInCabinetPathLocals &Locals)
/*++
    Given a 'base path' of where to look for a manifest, this looks for the candidate manifest
    in there.

    Example 1:
        foo\bar\x86_bink_{...}\x86_bink_{...}.man
        foo\bar\x86_bink_{...}\bop.man

        base path = foo\bar\x86_bink_{...}
        found manifest: foo\bar\x86_bink_{...}\x86_bink_{...}.man

    Example 2:
        foo\bar\x86_bink_{...}\bop.manifest

        base path = foo\bar\x86_bink_{...}
        found manifest = foo\bar\x86_bink_{...}\bop.manifest

    Priority:
        {basepath}\{subpath}\{subpath}.manifest
        {basepath}\{subpath}\{subpath}.man
        {basepath}\{subpath}\*.manifest
        {basepath}\{subpath}\*.man

--*/
{
    FN_PROLOG_WIN32

    Locals.Clear();

#define ENTRY(_x) { _x, NUMBER_OF(_x) - 1 }

    const static struct {
        PCWSTR pcwsz;
        SIZE_T cch;
    } s_rgsExtensions[] = {
        ENTRY(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_MAN),
        ENTRY(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_MANIFEST),
    };

#undef ENTRY

    struct {
        PCWSTR pcwsz;
        SIZE_T cch;
    } s_rgsNamePatterns[] = {
        { rcsSubPath, rcsSubPath.Cch() },
        { L"*", 1 }
    };

    SIZE_T cchBeforePatterns = 0;
    rfFound = false;

    //
    // Create the {basepath}\{subpath} search "root" path
    //
    IFW32FALSE_EXIT(ManifestPath.Win32Assign(rcsBasePath));
    IFW32FALSE_EXIT(ManifestPath.Win32AppendPathElement(rcsSubPath));
    cchBeforePatterns = ManifestPath.Cch();

    //
    // For each name pattern ({basepath} or *), look to see if there's a file with that
    // name present
    //
    for (SIZE_T cNamePattern = 0; cNamePattern < NUMBER_OF(s_rgsNamePatterns); cNamePattern++)
    {
        IFW32FALSE_EXIT(ManifestPath.Win32AppendPathElement(
            s_rgsNamePatterns[cNamePattern].pcwsz,
            s_rgsNamePatterns[cNamePattern].cch));

        //
        // Probe - look for .manifest/.man/.whatever based on the extension list above.
        //
        for (SIZE_T cExtension = 0; cExtension < NUMBER_OF(s_rgsExtensions); cExtension++)
        {
            CFindFile Finder;
            WIN32_FIND_DATAW &FindData = Locals.FindData;

            IFW32FALSE_EXIT(ManifestPath.Win32Append(
                s_rgsExtensions[cExtension].pcwsz,
                s_rgsExtensions[cExtension].cch));

            //
            // Find the first one of this name
            //
            Finder = FindFirstFileW(ManifestPath, &FindData);
            ManifestPath.Left(cchBeforePatterns);

            if (Finder.IsValid())
            {
                IFW32FALSE_EXIT(ManifestPath.Win32AppendPathElement(
                    FindData.cFileName,
                    ::wcslen(FindData.cFileName)));

                //
                // If we found one, then report it and stop trying.
                //
                rfFound = true;
                FN_SUCCESSFUL_EXIT();
            }
        }

        ManifestPath.Left(cchBeforePatterns);
    }

    FN_EPILOG
}




class CSxspDetectAndInstallFromPathLocals
{
public:
    CSxspDetectAndInstallFromPathLocals() { }
    ~CSxspDetectAndInstallFromPathLocals() { }

    void Clear()
    //
    // Clear is how you deal with the fact that some function calls were in loops
    // and/or some local variables were in loops.
    //
    // In "lifting up" the variables, we lose the repeated constructor/destructor calls.
    //
    {
        this->LocalPathWorker.Clear();
        this->SxspFindManifestInCabinetPath.Clear();
    }

    CStringBuffer LocalPathWorker;
    CSxspFindManifestInCabinetPathLocals SxspFindManifestInCabinetPath;
};

BOOL
SxspDetectAndInstallFromPath(
    CAssemblyInstall &AssemblyContext,
    const CBaseStringBuffer &rcsbRelativeCodebasePath,
    const CBaseStringBuffer &rcsbCabinetExtractionPath,
    const CBaseStringBuffer &rcsbAssemblySubpath,
    CSxspDetectAndInstallFromPathLocals &Locals)
{

    FN_PROLOG_WIN32

    bool fFoundSomething = false;

    Locals.Clear();
    CStringBuffer &LocalPathWorker = Locals.LocalPathWorker;

    IFW32FALSE_EXIT(::SxspFindManifestInCabinetPath(
        rcsbCabinetExtractionPath,
        rcsbAssemblySubpath,
        LocalPathWorker,
        fFoundSomething,
        Locals.SxspFindManifestInCabinetPath));

    if (fFoundSomething)
    {
        IFW32FALSE_EXIT(AssemblyContext.InstallFile(
            LocalPathWorker,
            rcsbRelativeCodebasePath));
    }

#if DBG
    if (!fFoundSomething)
    {
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_INSTALLATION,
            "sxs.dll: %s - Failed finding something to install in path %ls, skipping\n",
            __FUNCTION__,
            static_cast<PCWSTR>(LocalPathWorker));
    }
#endif
    FN_EPILOG
}






BOOL
SxspReadEntireFile(
    CFusionArray<BYTE> &rbBuffer,
    const CBaseStringBuffer &rcsbPath)
{
    FN_PROLOG_WIN32

    CFusionFile File;
    CFileMapping FileMapping;
    CMappedViewOfFile MappedView;
    ULONGLONG ullFileSize = 0;
    ULONGLONG ullOffset = 0;
    DWORD dwReadSize = 0;


    IFW32FALSE_EXIT(File.Win32CreateFile(rcsbPath, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING));
    IFW32FALSE_EXIT(File.Win32GetSize(ullFileSize));

    //
    // If the file is more than 4gb long, we'll have problems reading it.  Don't bother trying.
    // On ia64, we could readin 4gb, but it seems like any file that's 4gb or more in this context
    // is either an erroneous file or a filesystem bug.
    //
    PARAMETER_CHECK(ullFileSize < MAXDWORD);

    //
    // Set the size of the output buffer to be exactly as big as we need.
    //
    if (rbBuffer.GetSize() != ullFileSize)
    {
        IFW32FALSE_EXIT(rbBuffer.Win32SetSize((SIZE_T)ullFileSize, CFusionArray<BYTE>::eSetSizeModeExact));
    }

    //
    // Read MAXDWORD chunks (or smaller) at a time to flesh out the entire thing in memory
    //
    while (ullFileSize) {
        IFW32FALSE_ORIGINATE_AND_EXIT(::ReadFile(
            File,
            rbBuffer.GetArrayPtr() + ullOffset,
            (DWORD)((ullFileSize > MAXDWORD) ? MAXDWORD : ullFileSize),
            &dwReadSize,
            NULL));

        //
        // We can't have read more than the bytes remaining in the file.
        //
        INTERNAL_ERROR_CHECK(dwReadSize <= (ullFileSize - ullOffset));

        ullFileSize -= dwReadSize;

        //
        // If somehow we sized the file upwards (not strictly possible b/c we set this to
        // only allow read sharing) or otherwise got back zero bytes read, we stop
        // before looping infinitely.
        //
        if (dwReadSize == 0)
            break;

    }

    FN_EPILOG
}

const static UNICODE_STRING assembly_dot_patch = RTL_CONSTANT_STRING(L"assembly.patch");

class CSxspDeterminePatchSourceFromLocals
{
public:
    CSxspDeterminePatchSourceFromLocals() { }
    ~CSxspDeterminePatchSourceFromLocals() { }

    void Clear()
    //
    // Clear is how you deal with the fact that some function calls were in loops
    // and/or some local variables were in loops.
    //
    // In "lifting up" the variables, we lose the repeated constructor/destructor calls.
    //
    {
        this->sbBuffTemp.Clear();
    }

    CStringBuffer sbBuffTemp;
};

BOOL
SxspDeterminePatchSourceFrom(
    const CBaseStringBuffer &rcsbBasePath,
    const CBaseStringBuffer &rcsbPath,
    CBaseStringBuffer &rsbPatchSourceName,
    BOOL &fFoundPatchBase,
    CSxspDeterminePatchSourceFromLocals &Locals)
{
    FN_PROLOG_WIN32

    Locals.Clear();
    CStringBuffer &sbBuffTemp = Locals.sbBuffTemp;
    CFusionArray<BYTE> rgbFileContents;
    BOOL fNotFound = FALSE;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> pAsmIdentity;
    PBYTE pbStarting = NULL;
    PBYTE pbEnding = NULL;
    bool fIsUnicode = false;
    SIZE_T cchBeforeEOLN = 0;

    fFoundPatchBase = FALSE;

    IFW32FALSE_EXIT(sbBuffTemp.Win32Assign(rcsbBasePath));
    IFW32FALSE_EXIT(sbBuffTemp.Win32AppendPathElement(rcsbPath));
    IFW32FALSE_EXIT(sbBuffTemp.Win32AppendPathElement(&assembly_dot_patch));
    IFW32FALSE_EXIT(rgbFileContents.Win32Initialize());

    IFW32FALSE_EXIT_UNLESS2(
        ::SxspReadEntireFile(rgbFileContents, sbBuffTemp),
        LIST_2( ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND ),
        fNotFound);

    if (fNotFound || (rgbFileContents.GetSize() == 0))
    {
        FN_SUCCESSFUL_EXIT();
    }

    pbStarting = rgbFileContents.GetArrayPtr();
    pbEnding = pbStarting + rgbFileContents.GetSize();

    //
    // Is this UNICODE?
    //
    fIsUnicode =
        (rgbFileContents.GetSize() > sizeof(WCHAR)) &&
        (((PWCHAR)pbStarting)[0] == 0xFEFF);

    if (fIsUnicode)
    {
        pbStarting += sizeof(WCHAR);
        PARAMETER_CHECK(((pbEnding - pbStarting) % sizeof(WCHAR)) == 0);
        IFW32FALSE_EXIT(sbBuffTemp.Win32Assign(
            reinterpret_cast<PCWSTR>(pbStarting),
            (pbEnding - pbStarting) / sizeof(WCHAR)));
    }
    else
    {
        IFW32FALSE_EXIT(
            sbBuffTemp.Win32Assign(
                reinterpret_cast<PCSTR>(pbStarting),
                pbEnding - pbStarting));
    }

    //
    // Because this string should be "solid" ie: no \r\n in it,
    // we can whack everything after the first \r\n.
    //
    cchBeforeEOLN = wcscspn(sbBuffTemp, L"\r\n");

    if (cchBeforeEOLN != 0)
    {
        sbBuffTemp.Left(cchBeforeEOLN);
    }

    //
    // Convert back to an identity, then convert -that- back to
    // an installation path.
    //
    IFW32FALSE_EXIT(
        ::SxspCreateAssemblyIdentityFromTextualString(
            sbBuffTemp,
            &pAsmIdentity));

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            0,
            pAsmIdentity,
            &s_IdentityAttribute_type,
            sbBuffTemp));

    if (::FusionpEqualStringsI(
        ASSEMBLY_TYPE_WIN32_POLICY, NUMBER_OF(ASSEMBLY_TYPE_WIN32_POLICY) - 1,
        sbBuffTemp))
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(bad_type_of_patch_source_identity, ERROR_INTERNAL_ERROR);
    }

    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            NULL,
            0,
            pAsmIdentity,
            NULL,
            rsbPatchSourceName));

    fFoundPatchBase = TRUE;

    FN_EPILOG
}

class CSxspApplyPatchesForLocals
{
public:
    CSxspApplyPatchesForLocals() { }
    ~CSxspApplyPatchesForLocals() { }

    void Clear()
    //
    // Clear is how you deal with the fact that some function calls were in loops
    // and/or some local variables were in loops.
    //
    // In "lifting up" the variables, we lose the repeated constructor/destructor calls.
    //
    {
        this->sbTempBuffer.Clear();
        this->SourceAssemblyPath.Clear();
        this->TargetAssemblyPath.Clear();
        this->SxspDeterminePatchSourceFrom.Clear();
    }

    CSmallStringBuffer sbTempBuffer;
    CStringBuffer SourceAssemblyPath;
    CStringBuffer TargetAssemblyPath;
    WIN32_FIND_DATAW FindData;
    CSxspDeterminePatchSourceFromLocals SxspDeterminePatchSourceFrom;
};

BOOL
SxspApplyPatchesFor(
    const CBaseStringBuffer &rcsbBasePath,
    const CBaseStringBuffer &rcsbPath,
    CSxspApplyPatchesForLocals &Locals)
/*++

    Given a path, this function will look for the patch source description file
    which indicates what base assembly this assembly is patched from.  It will then
    look through all the .patch files, and assume that (once the .patch is removed)
    that they map to files originally in the source assembly.

--*/
{
    FN_PROLOG_WIN32

    const static UNICODE_STRING dot_patch = RTL_CONSTANT_STRING(L".patch");
    const static UNICODE_STRING star_dot_patch = RTL_CONSTANT_STRING(L"*.patch");

    Locals.Clear();
    CSmallStringBuffer &sbTempBuffer = Locals.sbTempBuffer;
    CStringBuffer &SourceAssemblyPath = Locals.SourceAssemblyPath;
    CStringBuffer &TargetAssemblyPath = Locals.TargetAssemblyPath;
    CDynamicLinkLibrary PatchDll;
    CFindFile Finder;
    WIN32_FIND_DATAW &FindData = Locals.FindData;
    BOOL fError = FALSE;
    BOOL fFoundPatchBase = FALSE;
    SIZE_T cchTargetPathBase = 0;
    SIZE_T cchSourcePathBase = 0;
    BOOL (WINAPI *pfnApplyPatchToFileExW)(LPCWSTR, LPCWSTR, LPCWSTR, ULONG, PPATCH_PROGRESS_CALLBACK, PVOID) = NULL;
    BOOL (WINAPI *pfnGetPatchSignatureW)(LPCWSTR, ULONG, PVOID, ULONG, PPATCH_IGNORE_RANGE, ULONG, PPATCH_RETAIN_RANGE, ULONG, PVOID) = NULL;

    IFW32FALSE_EXIT(PatchDll.Win32LoadLibrary(L"mspatcha.dll"));
    IFW32FALSE_EXIT(PatchDll.Win32GetProcAddress("ApplyPatchToFileExW", &pfnApplyPatchToFileExW));
    IFW32FALSE_EXIT(PatchDll.Win32GetProcAddress("GetFilePatchSignatureW", &pfnGetPatchSignatureW));

    //
    // Where are we patching from?
    //
    IFW32FALSE_EXIT(::SxspDeterminePatchSourceFrom(
        rcsbBasePath,
        rcsbPath,
        sbTempBuffer,
        fFoundPatchBase,
        Locals.SxspDeterminePatchSourceFrom));

    //
    // Hmm - no patch source, so we can't think about applying patches.  Hope
    // there's no *.patch
    //
    if (!fFoundPatchBase)
    {
#if DBG
        FusionpDbgPrintEx(FUSION_DBG_LEVEL_INSTALLATION,
            "SXS: %s(%d) - No patches found in path %ls\\%ls, not applying any\n",
            __FILE__,
            __LINE__,
            static_cast<PCWSTR>(rcsbBasePath),
            static_cast<PCWSTR>(rcsbPath));
#endif
        FN_SUCCESSFUL_EXIT();
    }

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(SourceAssemblyPath));
    IFW32FALSE_EXIT(SourceAssemblyPath.Win32AppendPathElement(sbTempBuffer));
    cchSourcePathBase = SourceAssemblyPath.Cch();

    IFW32FALSE_EXIT(TargetAssemblyPath.Win32Assign(rcsbBasePath));
    IFW32FALSE_EXIT(TargetAssemblyPath.Win32AppendPathElement(rcsbPath));
    cchTargetPathBase = TargetAssemblyPath.Cch();

    //
    // First, let's look for *.patch and apply them all
    //
    IFW32FALSE_EXIT(TargetAssemblyPath.Win32AppendPathElement(&star_dot_patch));
    IFW32FALSE_EXIT_UNLESS2(Finder.Win32FindFirstFile(TargetAssemblyPath, &FindData),
        LIST_3( ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND, ERROR_NO_MORE_FILES ),
        fError);

    TargetAssemblyPath.Left(cchTargetPathBase);


    if (!fError) do
    {
        SIZE_T cFileName_Length = ::wcslen(FindData.cFileName);

        //
        // Skip 'assembly.patch'
        //
        if (::FusionpEqualStringsI(
                FindData.cFileName,
                cFileName_Length,
                &assembly_dot_patch))
        {
            continue;
        }

        IFW32FALSE_EXIT(sbTempBuffer.Win32Assign(
            FindData.cFileName,
            cFileName_Length));

        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(patch_has_dot_patch_directory, ERROR_INTERNAL_ERROR);
        }

        //
        // Pull off the .patch part
        //
        sbTempBuffer.Left(sbTempBuffer.Cch() - RTL_STRING_GET_LENGTH_CHARS(&dot_patch));

        IFW32FALSE_EXIT(SourceAssemblyPath.Win32AppendPathElement(sbTempBuffer));
        IFW32FALSE_EXIT(TargetAssemblyPath.Win32AppendPathElement(sbTempBuffer));
        IFW32FALSE_EXIT(sbTempBuffer.Win32Assign(TargetAssemblyPath));
        IFW32FALSE_EXIT(sbTempBuffer.Win32Append(&dot_patch));

#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS: %s(%d) - Patching:\n"
            "\tPatch:   %ls\n"
            "\tSource:  %ls\n"
            "\tTarget:  %ls\n",
            __FILE__, __LINE__,
            static_cast<PCWSTR>(sbTempBuffer),
            static_cast<PCWSTR>(SourceAssemblyPath),
            static_cast<PCWSTR>(TargetAssemblyPath));
#endif

        IFW32FALSE_EXIT((*pfnApplyPatchToFileExW)(
            sbTempBuffer,
            SourceAssemblyPath,
            TargetAssemblyPath,
            0, NULL, NULL));

        //
        // Next?
        //
        SourceAssemblyPath.Left(cchSourcePathBase);
        TargetAssemblyPath.Left(cchTargetPathBase);
    }
    while (FindNextFileW(Finder, &FindData));

    FN_EPILOG
}


class CDirectoryDeleter
{
    PRIVATIZE_COPY_CONSTRUCTORS(CDirectoryDeleter);
    CStringBuffer m_OurDir;
    bool m_fDoDelete;
public:
    CDirectoryDeleter() : m_fDoDelete(false) { }
    BOOL SetDelete(bool fDelete) { m_fDoDelete = fDelete; return TRUE; }
    BOOL SetPath(const CBaseStringBuffer &path) { return m_OurDir.Win32Assign(path); }
    ~CDirectoryDeleter()
    {
        if (m_fDoDelete)
        {
            CSxsPreserveLastError ple;
            ::SxspDeleteDirectory(m_OurDir);
            m_fDoDelete = false;
            ple.Restore();
        }
    }
};

int
__cdecl
StringBufferCompareStrings(
    const void* pLeft,
    const void* pRight)
{
    const CStringBuffer * pStrLeft = *reinterpret_cast<CStringBuffer const * const * >(pLeft);
    const CStringBuffer * pStrRight = *reinterpret_cast<CStringBuffer const * const * >(pRight);
    StringComparisonResult Result = eLessThan;

    //
    // On failure, leave in place
    //
    if (!pStrLeft->Win32Compare(*pStrRight, pStrRight->Cch(), Result, true))
    {
        Result = eLessThan;
    }

    switch (Result)
    {
    case eLessThan: return -1;
    case eGreaterThan: return 1;
    default: return 0;
    }
}

class CSxspGatherCabinetsToInstallLocals
{
public:
    CSxspGatherCabinetsToInstallLocals() { }
    ~CSxspGatherCabinetsToInstallLocals() { }

    void Clear()
    //
    // Clear is how you deal with the fact that some function calls were in loops
    // and/or some local variables were in loops.
    //
    // In "lifting up" the variables, we lose the repeated constructor/destructor calls.
    //
    {
        this->PathScan.Clear();
        this->Temp.Clear();
    }

    CMediumStringBuffer PathScan;
    WIN32_FIND_DATAW FindData;
    CStringBuffer Temp;
};

BOOL
SxspGatherCabinetsToInstall(
    const CBaseStringBuffer &CabinetBasePath,
    CFusionArray<CStringBuffer> &CabinetNames_StringBuffers,
    CFusionArray<CStringBuffer*> &CabinetNames_StringBufferPointers,
    SIZE_T &CabCount,
    CSxspGatherCabinetsToInstallLocals &Locals)
{
    FN_PROLOG_WIN32

    CFindFile Finder;
    BOOL fNoFilesMatch = FALSE;
    const static UNICODE_STRING asms_star_dot_cab = RTL_CONSTANT_STRING(L"asms*.cab");
    DWORD dwWin32Error = 0;

    Locals.Clear();
    CMediumStringBuffer &PathScan = Locals.PathScan;
    WIN32_FIND_DATAW &FindData = Locals.FindData;

    CabCount = 0;

    IFW32FALSE_EXIT(PathScan.Win32Assign(CabinetBasePath));
    IFW32FALSE_EXIT(PathScan.Win32EnsureTrailingPathSeparator());
    IFW32FALSE_EXIT(PathScan.Win32Append(&asms_star_dot_cab));

    IFW32FALSE_EXIT_UNLESS2(
        Finder.Win32FindFirstFile(PathScan, &FindData),
        LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_NO_MORE_FILES),
        fNoFilesMatch);

    //
    // Nothing found, quit looking
    //
    if (fNoFilesMatch)
    {
        FN_SUCCESSFUL_EXIT();
    }

    //
    // Zip through files
    //
    do
    {
        if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            CStringBuffer &Temp = Locals.Temp;
            IFW32FALSE_EXIT(Temp.Win32Assign(FindData.cFileName, lstrlenW(FindData.cFileName)));
            IFW32FALSE_EXIT(CabinetNames_StringBuffers.Win32Append(Temp));
            CabCount++;
        }
    }
    while (FindNextFileW(Finder, &FindData));

    //
    // If we failed somehow
    //
    dwWin32Error = ::FusionpGetLastWin32Error();
    if (dwWin32Error != ERROR_NO_MORE_FILES && dwWin32Error != ERROR_SUCCESS)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(FindNextFileW, dwWin32Error);
    }

    //
    // CStringBuffers cannot be sorted by qsort because it copies
    // array elements as if by memcpy, which is wrong for CStringBuffers.
    // std::sort does the right thing, but it cannot be used here.
    //
    SIZE_T i = 0;
    for ( i = 0 ; i != CabCount ; ++i )
    {
        IFW32FALSE_EXIT(CabinetNames_StringBufferPointers.Win32Append(&CabinetNames_StringBuffers[i]));
    }
    qsort(
        CabinetNames_StringBufferPointers.GetArrayPtr(),
        CabCount,
        sizeof(CFusionArray<CStringBuffer*>::ValueType),
        StringBufferCompareStrings);

    FN_EPILOG
}

class CSxspInstallAsmsDotCabEtAlLocals
{
public:
    CSxspInstallAsmsDotCabEtAlLocals() { }
    ~CSxspInstallAsmsDotCabEtAlLocals() { }

    void Clear()
    //
    // Clear is how you deal with the fact that some function calls were in loops
    // and/or some local variables were in loops.
    //
    // In "lifting up" the variables, we lose the repeated constructor/destructor calls.
    //
    {
        this->buffCabinetPath.Clear();
        this->buffTempPath.Clear();
        this->buffRelativePath.Clear();
        this->SxspApplyPatchesFor.Clear();
        this->SxspGatherCabinetsToInstall.Clear();
        this->SxspDetectAndInstallFromPath.Clear();
    }

    CCabinetData    CabData;
    CStringBuffer   buffCabinetPath;
    CStringBuffer   buffTempPath;
    CStringBuffer   buffRelativePath;

    CSxspApplyPatchesForLocals SxspApplyPatchesFor;
    CSxspGatherCabinetsToInstallLocals SxspGatherCabinetsToInstall;
    CSxspDetectAndInstallFromPathLocals SxspDetectAndInstallFromPath;
};

BOOL
SxspInstallAsmsDotCabEtAl(
    DWORD dwFlags,
    CAssemblyInstall &AssemblyContext,
    const CBaseStringBuffer &CabinetBasePath,
    CFusionArray<CStringBuffer> *pAssembliesToInstall)
{
    FN_PROLOG_WIN32

    CSmartPtr<CSxspInstallAsmsDotCabEtAlLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));

    IFW32FALSE_EXIT(SxspInstallAsmsDotCabEtAl(
        dwFlags,
        AssemblyContext,
        CabinetBasePath,
        pAssembliesToInstall,
        *Locals));

    FN_EPILOG
}

BOOL
SxspInstallAsmsDotCabEtAl(
    DWORD dwFlags,
    CAssemblyInstall &AssemblyContext,
    const CBaseStringBuffer &CabinetBasePath,
    CFusionArray<CStringBuffer> *pAssembliesToInstall,
    CSxspInstallAsmsDotCabEtAlLocals &Locals)
{
    FN_PROLOG_WIN32

    CFusionArray<CStringBuffer> Cabinets_StringBuffers;
    CFusionArray<CStringBuffer*> Cabinets_StringBufferPointers;
    SIZE_T cchBasePath = 0;
    SIZE_T CabinetCount = 0;

    Locals.Clear();
    CCabinetData &CabData = Locals.CabData;
    CStringBuffer &buffCabinetPath = Locals.buffCabinetPath;
    CStringBuffer &buffTempPath = Locals.buffTempPath;
    CDirectoryDeleter Deleter;

    //
    // Go find the list (and ordering) of cabinets to install
    //
    IFW32FALSE_EXIT(Cabinets_StringBuffers.Win32Initialize(0));
    IFW32FALSE_EXIT(Cabinets_StringBufferPointers.Win32Initialize(0));
    IFW32FALSE_EXIT(::SxspGatherCabinetsToInstall(
        CabinetBasePath,
        Cabinets_StringBuffers,
        Cabinets_StringBufferPointers,
        CabinetCount,
        Locals.SxspGatherCabinetsToInstall));

    //
    // Stash this, we'll need it - also create a temp directory for our use in
    // uncompressing things.  Ensure that it goes away after installation.
    //
    IFW32FALSE_EXIT(buffCabinetPath.Win32Assign(CabinetBasePath));
    IFW32FALSE_EXIT(::SxspCreateWinSxsTempDirectory(buffTempPath, NULL, NULL, NULL));
    IFW32FALSE_EXIT(Deleter.SetPath(buffTempPath));
    IFW32FALSE_EXIT(Deleter.SetDelete(true));

    //
    // We'll be reusing this, so store the base length
    //
    cchBasePath = buffCabinetPath.Cch();

    //
    // Now for all the items we found:
    // 1. Expand to the temporary directory
    // 2. Apply patches
    // 3. Install
    //
    for (SIZE_T cab = 0; cab < CabinetCount; cab++)
    {
        CabData.Initialize();

        //
        // If there's stuff at the end of the cabinet path, trim it.
        //
        if (buffCabinetPath.Cch() != cchBasePath)
        {
            buffCabinetPath.Left(cchBasePath);
        }

        //
        // Set up the cabinet data object, create the cabinet path, and then really
        // do the extraction
        //
        IFW32FALSE_EXIT(CabData.Initialize(buffTempPath, true));
        IFW32FALSE_EXIT(buffCabinetPath.Win32AppendPathElement(*Cabinets_StringBufferPointers[cab]));
        IFW32FALSE_EXIT(::SxspExpandCabinetIntoTemp(
            0,
            buffCabinetPath,
            AssemblyContext.m_ImpersonationData,
            &CabData));

        //
        // For each assembly extracted, apply patches
        //
        for (SIZE_T a = 0; a < CabData.m_AssembliesExtracted.GetSize(); a++)
        {
            CBaseStringBuffer &buffRelativePath = Locals.buffRelativePath;
            buffRelativePath.Clear();

            //
            // Patchy patchy
            //
            IFW32FALSE_EXIT(::SxspApplyPatchesFor(
                CabData.BasePath(),
                CabData.m_AssembliesExtracted[a],
                Locals.SxspApplyPatchesFor));

            //
            // Find the portion of this path that's relative to the base path
            //
            IFW32FALSE_EXIT(buffRelativePath.Win32Assign(buffCabinetPath));
            buffRelativePath.Right(buffRelativePath.Cch() - CabinetBasePath.Cch() - 1);

            //
            // If we're doing this during OS-setup, we need to crop off the first
            // path piece
            //
            if (AssemblyContext.m_ActCtxGenCtx.m_ManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_OSSETUP)
            {
                CTinyStringBuffer tsb;

                IFW32FALSE_EXIT(CabinetBasePath.Win32GetLastPathElement(tsb));
                IFW32FALSE_EXIT(tsb.Win32AppendPathElement(buffRelativePath));
                IFW32FALSE_EXIT(buffRelativePath.Win32Assign(tsb));
            }

            //
            // Did the user provide a 'filter' to do installations?  If so, compare the
            // assembly that we just patched to all those in the list.  If we were good
            // citizens, if we found a match we'd remove it from the list of those
            // found, but ... we're lousy and don't want to incur the overhead of sloshing
            // array entries around.
            //
            if (pAssembliesToInstall != NULL)
            {
                bool fMatched = false;

                for (SIZE_T idx = 0; !fMatched && (idx < pAssembliesToInstall->GetSize()); idx++)
                {
                    IFW32FALSE_EXIT(CabData.m_AssembliesExtracted[a].Win32Equals(
                        (*pAssembliesToInstall)[idx],
                        fMatched,
                        true));
                }

                //
                // No match, but they had a filter, so go do the next assembly, we don't care
                // about this one.
                //
                if (!fMatched)
                    continue;
            }

            //
            // Goody! Go do the installation
            //
            IFW32FALSE_EXIT(::SxspDetectAndInstallFromPath(
                AssemblyContext,
                buffRelativePath,
                CabData.BasePath(),
                CabData.m_AssembliesExtracted[a],
                Locals.SxspDetectAndInstallFromPath));

        }
    }


    FN_EPILOG
}






BOOL
SxspMapInstallFlagsToManifestOpFlags(
    DWORD dwSourceFlags,
    DWORD &dwTargetFlags)
{
    FN_PROLOG_WIN32

    dwTargetFlags = 0;

#define MAP_FLAG(x) do { if (dwSourceFlags & SXS_INSTALL_FLAG_ ## x) dwTargetFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ ## x; } while (0)

    MAP_FLAG(MOVE);
    MAP_FLAG(FROM_RESOURCE);
    MAP_FLAG(NO_VERIFY);
    MAP_FLAG(NOT_TRANSACTIONAL);
    MAP_FLAG(REPLACE_EXISTING);
    MAP_FLAG(FROM_DIRECTORY);
    MAP_FLAG(FROM_DIRECTORY_RECURSIVE);
    MAP_FLAG(INSTALLED_BY_DARWIN);
    MAP_FLAG(INSTALLED_BY_OSSETUP);
    MAP_FLAG(REFERENCE_VALID);
    MAP_FLAG(REFRESH);
    MAP_FLAG(FROM_CABINET);
#undef MAP_FLAG

    FN_EPILOG
}


class CSxspRecoverAssemblyFromCabinetLocals
{
public:
    CSxspRecoverAssemblyFromCabinetLocals() { }
    ~CSxspRecoverAssemblyFromCabinetLocals() { }

    void Clear()
    //
    // Clear is how you deal with the fact that some function calls were in loops
    // and/or some local variables were in loops.
    //
    // In "lifting up" the variables, we lose the repeated constructor/destructor calls.
    //
    {
        ::ZeroMemory(&this->AttributeCache, sizeof(this->AttributeCache));
        this->CabData.Clear();
        this->buffTempPath.Clear();
        this->buffRelativePathToManifestFile.Clear();
        this->buffRelativePathToCatalogFile.Clear();
        this->buffRelativePathPayloadDirectory.Clear();
        this->buffAssemblyRootDirectory.Clear();
        this->buffManifestOrCatalogFileFullTempManifestsPath.Clear();
        this->buffManifestOrCatalogFileFullTempPayloadPath.Clear();
        this->buffManifestOrCatalogLeafPath.Clear();
        this->buffRelativeCodebasePathIgnoredDueToRefreshFlagRegistryNotTouched.Clear();
    }

    PROBING_ATTRIBUTE_CACHE AttributeCache;
    CCabinetData    CabData;
    CStringBuffer   buffTempPath;
    CStringBuffer   buffRelativePathToManifestFile;
    CStringBuffer   buffRelativePathToCatalogFile;
    CStringBuffer   buffRelativePathPayloadDirectory;
    CStringBuffer   buffAssemblyRootDirectory;
    CStringBuffer   buffManifestOrCatalogFileFullTempManifestsPath;
    CStringBuffer   buffManifestOrCatalogFileFullTempPayloadPath;
    CStringBuffer   buffManifestOrCatalogLeafPath;
    CStringBuffer   buffRelativeCodebasePathIgnoredDueToRefreshFlagRegistryNotTouched;
    CAssemblyInstall Installer;
};

BOOL
SxspRecoverAssemblyFromCabinet_ShouldExtractFileFromCab(
    const CBaseStringBuffer &rbuffPathInCab,
    bool &rfShouldExtract,
    PVOID VoidContext)
{
    FN_PROLOG_WIN32

    const CSxspRecoverAssemblyFromCabinetLocals * Context = reinterpret_cast<CSxspRecoverAssemblyFromCabinetLocals*>(VoidContext);

    INTERNAL_ERROR_CHECK(Context != NULL);
    INTERNAL_ERROR_CHECK(&rfShouldExtract != NULL);
    INTERNAL_ERROR_CHECK(&rbuffPathInCab != NULL);

    rfShouldExtract = false;

    if (::FusionpEqualStringsI(rbuffPathInCab, Context->buffRelativePathToManifestFile))
    {
        rfShouldExtract = true;
        FN_SUCCESSFUL_EXIT();
    }
    else if (::FusionpEqualStringsI(rbuffPathInCab, Context->buffRelativePathToCatalogFile))
    {
        rfShouldExtract = true;
        FN_SUCCESSFUL_EXIT();
    }
    else
    {
        const SIZE_T cch = Context->buffRelativePathPayloadDirectory.Cch();
        INTERNAL_ERROR_CHECK(cch != 0);
        INTERNAL_ERROR_CHECK(::FusionpIsPathSeparator(Context->buffRelativePathPayloadDirectory[cch - 1]));
        if (rbuffPathInCab.Cch() >= cch)
        {
            if (::FusionpEqualStringsI(
                static_cast<PCWSTR>(rbuffPathInCab),
                cch,
                Context->buffRelativePathPayloadDirectory,
                cch))
            {
                rfShouldExtract = true;
                FN_SUCCESSFUL_EXIT();
            }
        }
    }
    rfShouldExtract = false;
    FN_SUCCESSFUL_EXIT();

    FN_EPILOG
}

BOOL
SxspDeleteFileOrEmptyDirectoryIfExists(
    CBaseStringBuffer &buff)
{
    FN_PROLOG_WIN32

    DWORD dwFileOrDirectoryExists = 0;
    IFW32FALSE_EXIT(SxspDoesFileOrDirectoryExist(0, buff, dwFileOrDirectoryExists));
    switch (dwFileOrDirectoryExists)
    {
    case SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_FILE_EXISTS:
        IFW32FALSE_ORIGINATE_AND_EXIT(::DeleteFileW(buff));
        break;
    case SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_DIRECTORY_EXISTS:
        IFW32FALSE_ORIGINATE_AND_EXIT(::RemoveDirectoryW(buff));
        break;
    case SXSP_DOES_FILE_OR_DIRECTORY_EXIST_DISPOSITION_NEITHER_EXISTS:
        // do nothing
        break;
    }

    FN_EPILOG
}

BOOL
SxspRecoverAssemblyFromCabinet(
    const CBaseStringBuffer &buffCabinetPath,
    const CBaseStringBuffer &AssemblyIdentity,
    PSXS_INSTALLW pInstall)
{
    FN_PROLOG_WIN32

    CSmartAssemblyIdentity pAssemblyIdentity;
    CDirectoryDeleter Deleter;
    CImpersonationData ImpersonationData;
    DWORD dwFlags = 0;

    CSmartPtr<CSxspRecoverAssemblyFromCabinetLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));

    CCabinetData &CabData = Locals->CabData;
    ::ZeroMemory(&Locals->AttributeCache, sizeof(Locals->AttributeCache));

    //
    // First get the identity back to a real thing we can use
    //
    IFW32FALSE_EXIT(::SxspCreateAssemblyIdentityFromTextualString(
        AssemblyIdentity,
        &pAssemblyIdentity));

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(Locals->buffAssemblyRootDirectory));

    //
    // And then turn that into paths
    //
    IFW32FALSE_EXIT(::SxspGenerateSxsPath_RelativePathToManifestOrPolicyFile(
        Locals->buffAssemblyRootDirectory,
        pAssemblyIdentity,
        &Locals->AttributeCache,
        Locals->buffRelativePathToManifestFile));

    IFW32FALSE_EXIT(::SxspGenerateSxsPath_RelativePathToCatalogFile(
        Locals->buffAssemblyRootDirectory,
        pAssemblyIdentity,
        &Locals->AttributeCache,
        Locals->buffRelativePathToCatalogFile));

    IFW32FALSE_EXIT(::SxspGenerateSxsPath_RelativePathToPayloadOrPolicyDirectory(
        Locals->buffAssemblyRootDirectory,
        pAssemblyIdentity,
        &Locals->AttributeCache,
        Locals->buffRelativePathPayloadDirectory));
    IFW32FALSE_EXIT(Locals->buffRelativePathPayloadDirectory.Win32EnsureTrailingPathSeparator());

    IFW32FALSE_EXIT(::SxspCreateWinSxsTempDirectory(Locals->buffTempPath, NULL, NULL, NULL));
    IFW32FALSE_EXIT(Deleter.SetPath(Locals->buffTempPath));
    IFW32FALSE_EXIT(Deleter.SetDelete(true));

    IFW32FALSE_EXIT(CabData.Initialize(Locals->buffTempPath, true));

    CabData.m_pfnShouldExtractThisFileFromCabCallback = &SxspRecoverAssemblyFromCabinet_ShouldExtractFileFromCab;
    CabData.m_pvShouldExtractThisFileFromCabCallbackContext = static_cast<CSxspRecoverAssemblyFromCabinetLocals*>(Locals);

    IFW32FALSE_EXIT(::SxspExpandCabinetIntoTemp(
        0,
        buffCabinetPath,
        ImpersonationData,
        &CabData));

    //
    // now move temp\manifests\blah.manifest and temp\manifests\blah.cat into temp\blah
    // so that existing code shared with sxsinstall works
    //
    {
        const CBaseStringBuffer * FilesToMove[] =
        { 
            &Locals->buffRelativePathToCatalogFile,
            &Locals->buffRelativePathToManifestFile // manifest must be last, as we use the value
                                                    // outside the loop
        };
        SIZE_T i = 0;
        for ( i = 0 ; i != NUMBER_OF(FilesToMove) ; ++i )
        {
            IFW32FALSE_EXIT(Locals->buffManifestOrCatalogFileFullTempManifestsPath.Win32Assign(Locals->buffTempPath));
            IFW32FALSE_EXIT(Locals->buffManifestOrCatalogFileFullTempManifestsPath.Win32AppendPathElement(*FilesToMove[i]));

            IFW32FALSE_EXIT(Locals->buffManifestOrCatalogFileFullTempManifestsPath.Win32GetLastPathElement(Locals->buffManifestOrCatalogLeafPath));

            IFW32FALSE_EXIT(Locals->buffManifestOrCatalogFileFullTempPayloadPath.Win32Assign(Locals->buffTempPath));
            IFW32FALSE_EXIT(Locals->buffManifestOrCatalogFileFullTempPayloadPath.Win32AppendPathElement(Locals->buffRelativePathPayloadDirectory));
            IFW32FALSE_EXIT(Locals->buffManifestOrCatalogFileFullTempPayloadPath.Win32AppendPathElement(Locals->buffManifestOrCatalogLeafPath));

            IFW32FALSE_EXIT(::SxspDeleteFileOrEmptyDirectoryIfExists(Locals->buffManifestOrCatalogFileFullTempPayloadPath));

            IFW32FALSE_EXIT(::SxspInstallMoveFileExW(
                Locals->buffManifestOrCatalogFileFullTempManifestsPath,
                Locals->buffManifestOrCatalogFileFullTempPayloadPath,
                MOVEFILE_REPLACE_EXISTING,
                FALSE));
        }
    }

    //
    // Start up the installation
    //
    IFW32FALSE_EXIT(::SxspMapInstallFlagsToManifestOpFlags(pInstall->dwFlags, dwFlags));
    IFW32FALSE_EXIT(Locals->Installer.BeginAssemblyInstall(
        dwFlags | MANIFEST_OPERATION_INSTALL_FLAG_FORCE_LOOK_FOR_CATALOG,
        NULL,
        NULL,
        ImpersonationData));

    //
    // Do the install directly.
    //
    // This circumventing SxsInstallW is consistent with what the
    // code used to do (circa Jan. - June 2002), though it
    // apparently did not actually work in that period.
    //
    BOOL fResult =
        Locals->Installer.InstallFile(
            Locals->buffManifestOrCatalogFileFullTempPayloadPath, // manifest file
            Locals->buffRelativeCodebasePathIgnoredDueToRefreshFlagRegistryNotTouched);

    //
    // Now we have to end the installation, whether it worked or not.
    //
    if (fResult)
    {
        IFW32FALSE_EXIT(
            Locals->Installer.EndAssemblyInstall(
                    MANIFEST_OPERATION_INSTALL_FLAG_COMMIT
                    | MANIFEST_OPERATION_INSTALL_FLAG_REFRESH,
                    NULL));
    }
    else
    {
        const DWORD dwWin32Error = ::FusionpGetLastWin32Error();
        if (!Locals->Installer.EndAssemblyInstall(
            MANIFEST_OPERATION_INSTALL_FLAG_ABORT
            | MANIFEST_OPERATION_INSTALL_FLAG_REFRESH,
            NULL))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR,
                "SXS: %s failure %lu in abort ignored\n",
                __FUNCTION__,
                ::FusionpGetLastWin32Error());
        }
        ::FusionpSetLastWin32Error(dwWin32Error);
        ORIGINATE_WIN32_FAILURE_AND_EXIT(SxspRecoverAssemblyFromCabinet.InstallFile, dwWin32Error);
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsasmitem.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsasmitem.h

Abstract:

    CAssemblyCacheItem implementation for installation

Author:

    Xiaoyu Wu (xiaoyuw) April 2000

Revision History:
    xiaoyuw     10/26/2000      revise during Beta2 code-review period
--*/
#if !defined(_FUSION_SXS_ASMITEM_H_INCLUDED_)
#define _FUSION_SXS_ASMITEM_H_INCLUDED_

#pragma once

#include <windows.h>
#include <winerror.h>
#include "fusion.h"
#include "sxsinstall.h"

class CAssemblyCacheItem : public IAssemblyCacheItem
{
public:

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IAssemblyCacheItem methods
    STDMETHOD(CreateStream)(
        /* [in]  */ DWORD dwFlags,
        /* [in]  */ LPCWSTR pszName,
        /* [in]  */ DWORD dwFormat,
        /* [in]  */ DWORD dwFormatFlags,
        /* [out] */ IStream** ppStream,
		/* [in, optional] */ ULARGE_INTEGER *puliMaxSize);

    STDMETHOD(Commit)(
        /* [in] */ DWORD dwFlags,
		/* [out, optional] */ ULONG *pulDisposition);
    STDMETHOD(AbortItem)();

    // Constructor and Destructor
    CAssemblyCacheItem();
    ~CAssemblyCacheItem();

    HRESULT Initialize();

private:

    ULONG                       m_cRef;                // refcount
    BOOL                        m_fCommit;             // whether this asmcache has been commit or not
    BOOL                        m_fManifest;           // whether a manifest has been submit before commit or more than once
    ULONG                       m_cStream;             // stream count for an AssemblyCacheItem
    CStringBuffer               m_strTempDir;          // temporary directory for this assembly
    CSmallStringBuffer          m_strUidBuf;           // used in SxsCreateWinSxsTempDirectory

    CStringBuffer               m_strManifestFileName; // full-path manifest filename for Jay's API
    CRunOnceDeleteDirectory     *m_pRunOnceCookie;     // not the cookie to create the temporary directory
    CAssemblyInstall*           m_pInstallCookie;
private:
    CAssemblyCacheItem(const CAssemblyCacheItem &r); // intentionally not implemented
    CAssemblyCacheItem &operator =(const CAssemblyCacheItem &r); // intentionally not implemented

};

#endif // _FUSION_SXS_ASMITEM_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxscabinet.h ===
#pragma once


class CCabinetData
{
    PRIVATIZE_COPY_CONSTRUCTORS(CCabinetData);
    bool m_fDoExtraction;
    CStringBuffer m_sbBaseExpansionPath;
    BOOL m_fReplaceExisting;

public:
    CCabinetData() { Initialize(); }
    ~CCabinetData() { }

    bool IsExtracting() { return m_fDoExtraction; }

    //
    // Array of assemblies extracted
    //
    CFusionArray<CStringBuffer> m_AssembliesExtracted;
    const CBaseStringBuffer& BasePath() const { return m_sbBaseExpansionPath; }

    void SetReplaceExisting(BOOL fReplaceExisting)
    {
        this->m_fReplaceExisting = fReplaceExisting;
    }

    BOOL GetReplaceExisting() const
    {
        return this->m_fReplaceExisting;
    }

    void Initialize()
    {
        this->m_fReplaceExisting = FALSE;
        this->m_pfnShouldExtractThisFileFromCabCallback = NULL;
        this->m_pvShouldExtractThisFileFromCabCallbackContext = NULL;
        this->m_fDoExtraction = false;
        this->m_sbBaseExpansionPath.Clear();
        this->sxs_FdiExtractionNotify_fdintCOPY_FILE.Clear();
    }

    BOOL Initialize(const CBaseStringBuffer& strBasePath, bool fActuallyExtract = false)
    {
        FN_PROLOG_WIN32
        IFW32FALSE_EXIT(m_AssembliesExtracted.Win32Reset(CFusionArray<CStringBuffer>::eResetModeZeroSize));
        IFW32FALSE_EXIT(m_sbBaseExpansionPath.Win32Assign(strBasePath));
        m_fDoExtraction = fActuallyExtract;
        FN_EPILOG
    }

    struct _CopyFileLocalsStruct
    {
        void Clear()
        {
            TempBuffer.Clear();
            TempBuffer2.Clear();
        }

        CStringBuffer TempBuffer;
        CStringBuffer TempBuffer2;
    } sxs_FdiExtractionNotify_fdintCOPY_FILE;

    void Clear()
    {
        Initialize();
    }

    typedef
    BOOL (*SXSP_PFN_SHOULD_EXTRACT_THIS_FILE_FROM_CAB_CALLBACK)(
        const CBaseStringBuffer &PathInCab,
        bool &rfShouldExtract,
        PVOID Context
        );

    SXSP_PFN_SHOULD_EXTRACT_THIS_FILE_FROM_CAB_CALLBACK m_pfnShouldExtractThisFileFromCabCallback;
    PVOID m_pvShouldExtractThisFileFromCabCallbackContext;
};


BOOL
SxspRecoverAssemblyFromCabinet(
    const CBaseStringBuffer &CabinetPath,
    const CBaseStringBuffer &AssemblyIdentity,
    PSXS_INSTALLW pInstall);


BOOL
SxspExpandCabinetIntoTemp(
    DWORD dwFlags, 
    const CBaseStringBuffer& CabinetPath,
    CImpersonationData& ImpersonateData,
    CCabinetData* pCabinetData = NULL
    );


class CAssemblyInstall;

BOOL
SxspInstallAsmsDotCabEtAl(
    DWORD dwFlags,
    CAssemblyInstall &AssemblyContext,
    const CBaseStringBuffer &CabinetBasePath,
    CFusionArray<CStringBuffer> *pAssembliesToInstall
    );

class CSxspInstallAsmsDotCabEtAlLocals;

BOOL
SxspInstallAsmsDotCabEtAl(
    DWORD dwFlags,
    CAssemblyInstall &AssemblyContext,
    const CBaseStringBuffer &CabinetBasePath,
    CFusionArray<CStringBuffer> *pAssembliesToInstall,
    CSxspInstallAsmsDotCabEtAlLocals & Locals
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsasmitem.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsasmitem.cpp

Abstract:

    CAssemblyCacheItem implementation for installation

Author:

    Xiaoyu Wu (xiaoyuw) April 2000

Revision History:
    xiaoyuw     10/26/2000      revise during beta2 code review period

--*/
#include "stdinc.h"
#include "sxsp.h"
#include "fusionbuffer.h"
#include "fusion.h"
#include "sxsasmitem.h"
#include "cassemblycacheitemstream.h"
#include "util.h"
#include "fusiontrace.h"
#include "sxsapi.h"

CAssemblyCacheItem::CAssemblyCacheItem() : m_cRef(0),
                    m_pRunOnceCookie(NULL), m_pInstallCookie(NULL),
                    m_fCommit(FALSE), m_fManifest(FALSE)
{
}

CAssemblyCacheItem::~CAssemblyCacheItem()
{
    CSxsPreserveLastError ple;

    ASSERT_NTC(m_cRef == 0);

    if (m_pRunOnceCookie)
    {
        if (!::SxspCancelRunOnceDeleteDirectory(m_pRunOnceCookie))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspCancelRunOnceDeleteDirectory returns FALSE, file a BUG\n");
        }
    }

    if (!m_strTempDir.IsEmpty())
    {
        if (!::SxspDeleteDirectory(m_strTempDir))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspDeleteDirectory returns FALSE, file a BUG\n");
        }
    }

    ple.Restore();
}

HRESULT
CAssemblyCacheItem::Initialize()
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

    //create temporary directory for this assembly
    IFW32FALSE_EXIT(::SxspCreateWinSxsTempDirectory(m_strTempDir, NULL, &m_strUidBuf, NULL));
    IFW32FALSE_EXIT(::SxspCreateRunOnceDeleteDirectory(m_strTempDir, &m_strUidBuf, (PVOID *)&m_pRunOnceCookie));

    hr = NOERROR;
Exit:
    return hr ;
}


// ---------------------------------------------------------------------------
// CAssemblyCacheItem::CreateStream
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyCacheItem::CreateStream(
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwFormat,
    /* [in] */ DWORD dwFormatFlags,
    /* [out] */ IStream** ppStream,
	/* [in, optional] */ ULARGE_INTEGER *puliMaxSize)  // ????? in or OUT ?????
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    CStringBuffer FullPathFileNameBuf;
    CStringBuffer FullPathSubDirBuf;
    CSmartPtr<CAssemblyCacheItemStream> pStream;
    const static WCHAR szTemp[] = L"..";

    // The puliMaxSize is intended to be a hint for preallocation of the temporary storage for the stream.  We just don't
    // use it.
    UNUSED(puliMaxSize);
    
    if (ppStream != NULL)
        *ppStream = NULL;

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS: %s called with:\n"
        "   dwFlags = 0x%08lx\n"
        "   pszName = \"%ls\"\n"
        "   dwFormat = %lu\n"
        "   dwFormatFlags = %lu\n"
        "   ppStream = %p\n"
        "   puliMaxSize = %p\n",
        __FUNCTION__,
        dwFlags,
        pszName,
        dwFormat,
        dwFormatFlags,
        ppStream,
        puliMaxSize);

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(pszName != NULL);
    PARAMETER_CHECK(ppStream != NULL);

    //Darwin should clean their code about this : use _WIN32_ flags only
    PARAMETER_CHECK(
        (dwFormat == STREAM_FORMAT_COMPLIB_MANIFEST) ||
        (dwFormat == STREAM_FORMAT_WIN32_MANIFEST) ||
        (dwFormat == STREAM_FORMAT_COMPLIB_MODULE) ||
        (dwFormat == STREAM_FORMAT_WIN32_MODULE));

    PARAMETER_CHECK(dwFormatFlags == 0);

    // It's illegal to have more than one manifest in the assembly...
    PARAMETER_CHECK((!m_fManifest) || ((dwFormat != STREAM_FORMAT_COMPLIB_MANIFEST) && (dwFormat != STREAM_FORMAT_WIN32_MANIFEST)));
    
    *ppStream = NULL;

    // one and only one manifest stream for each assembly item.....
    if ((dwFormat == STREAM_FORMAT_COMPLIB_MANIFEST) || (dwFormat == STREAM_FORMAT_WIN32_MANIFEST))
    {
        PARAMETER_CHECK(m_fManifest == FALSE);
        m_fManifest = TRUE;
    }

    INTERNAL_ERROR_CHECK(!m_strTempDir.IsEmpty()); // temporary directory must be there !
    IFW32FALSE_EXIT(FullPathFileNameBuf.Win32Assign(m_strTempDir));

    IFW32FALSE_EXIT(FullPathFileNameBuf.Win32EnsureTrailingPathSeparator());
    IFW32FALSE_EXIT(FullPathFileNameBuf.Win32Append(pszName, ::wcslen(pszName)));

    // xiaoyuw@ : below wcsstr() is from old code : not sure whether we need do it
    // Do not allow path hackery.
    // need to validate this will result in a relative path within asmcache dir.
    // For now don't allow ".." in path; collapse the path before doing this.

    PARAMETER_CHECK(wcsstr(pszName, szTemp) == NULL);

    if (wcscspn(pszName, CUnicodeCharTraits::PathSeparators()) != wcslen(pszName))
    {
        // before file-copying, create subdirectory if needed
        // check backslash and forword-slash

        // the filename contains path info inside, such as "abc\a.dll", so we have to create "abc" subdirectory 
        // under the temporary directory
        CStringBuffer sbRelativeFilePath;
        IFW32FALSE_EXIT(sbRelativeFilePath.Win32Assign(pszName, wcslen(pszName)));
        IFW32FALSE_EXIT(sbRelativeFilePath.Win32RemoveLastPathElement());

        IFW32FALSE_EXIT(::SxspCreateMultiLevelDirectory(m_strTempDir, sbRelativeFilePath));
    }    
    IFW32FALSE_EXIT(pStream.Win32Allocate(__FILE__, __LINE__));
    IFW32FALSE_EXIT(
        pStream->OpenForWrite(
            FullPathFileNameBuf,
            0,
            CREATE_NEW,
            FILE_FLAG_SEQUENTIAL_SCAN));

    if ((dwFormat == STREAM_FORMAT_COMPLIB_MANIFEST) || (dwFormat == STREAM_FORMAT_WIN32_MANIFEST)) // but should not be set both bits
        IFW32FALSE_EXIT(m_strManifestFileName.Win32Assign(FullPathFileNameBuf)); // record manifest filename

    //
    // By COM rules, this does the addref.  Then we have to detach from this
    // instance so that we don't delete it
    //
    IFCOMFAILED_EXIT(pStream->QueryInterface(IID_IStream, (PVOID*)ppStream));
    pStream.Detach();

    hr = NOERROR;
Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::Commit
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyCacheItem::Commit(
    DWORD dwFlags,
    ULONG *pulDisposition
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    ULONG ulDisposition;
    SXS_INSTALLW Install = { sizeof(Install) };

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS: %s called:\n"
        "   dwFlags = 0x%08lx\n"
        "   pulDisposition = %p\n",
        __FUNCTION__,
        dwFlags,
        pulDisposition);

    if (pulDisposition)
        *pulDisposition = 0;

    PARAMETER_CHECK((dwFlags & ~(IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH)) == 0);

    // check internal error whether it is ready to commit
    PARAMETER_CHECK(m_fManifest);
    INTERNAL_ERROR_CHECK(!m_strManifestFileName.IsEmpty()); //m_pRunOnceCookie here should be NULL...

    // commit here
    if ((!m_fCommit) || (dwFlags & IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH))
    {
        Install.dwFlags = SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN |
            ((dwFlags & IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH) ? SXS_INSTALL_FLAG_REPLACE_EXISTING : 0);

        if (m_pInstallCookie != NULL)
        {
            Install.dwFlags |= SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID;
            Install.pvInstallCookie = m_pInstallCookie;
        }

        Install.lpManifestPath = m_strManifestFileName;

        IFW32FALSE_EXIT(::SxsInstallW(&Install));

        if ((dwFlags & IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH) && (m_fCommit))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INSTALLATION,
                "SXS: %s - setting disposition to IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED\n",
                __FUNCTION__);
            ulDisposition = IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED;
        }
        else
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INSTALLATION,
                "SXS: %s - setting disposition to IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED\n",
                __FUNCTION__);

            ulDisposition = IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED;
        }

        m_fCommit = TRUE; // committed successfully
    }
    else
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS: %s - setting disposition to IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED\n",
            __FUNCTION__);

        ulDisposition = IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED;
    }

    if (pulDisposition)
        *pulDisposition = ulDisposition;

    hr = NOERROR;

Exit :
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::AbortItem
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyCacheItem::AbortItem()
{
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS: %s called; returning E_NOTIMPL\n",
        __FUNCTION__);

    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyCacheItem::QueryInterface(REFIID riid, void** ppvObj)
{
    if ((riid == IID_IUnknown) ||
        (riid == IID_IAssemblyCacheItem))
    {
        *ppvObj = static_cast<IAssemblyCacheItem*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCacheItem::AddRef()
{
    return ::SxspInterlockedIncrement (&m_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCacheItem::Release()
{
    ULONG lRet = ::SxspInterlockedDecrement (&m_cRef);
    if (!lRet)
        FUSION_DELETE_SINGLETON(this);
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsidp.h ===
#if !defined(_FUSION_SXS_ASSEMBLY_IDENTITY_H_INCLUDED_)
#define _FUSION_SXS_ASSEMBLY_IDENTITY_H_INCLUDED_

#pragma once

#include "sxsid.h"

#endif // _FUSION_SXS_ASSEMBLY_IDENTITY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsdebug.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsdebug.cpp

Abstract:

    testing API for sxstest

Author:

    Xiaoyu Wu (xiaoyuw) April 2000

Revision History:

--*/
#include "stdinc.h"
#include "xmlparser.hxx"
#include "xmlparsertest.hxx"
#include "sxsinstall.h"
#include "sxsprotect.h"
#include <sxsapi.h>
#include "fusiontrace.h"
#include "sxsasmname.h"
#include "strongname.h"
#include "cassemblyrecoveryinfo.h"
#include "protectionui.h"
#include "sxscabinet.h"

#define CONFIG_FILE_EXTENSION L".config"

BOOL TestExpandCabinetFileToTemp(PCWSTR pcwszCabinetPath, PCWSTR pcwszTargetPath)
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
large frame
*/
    FN_PROLOG_WIN32
#if 0

    CStringBuffer buffCabinet;
    CStringBuffer buffTarget;
    CCabinetData cabData;
    CImpersonationData impData;

    IFW32FALSE_EXIT(buffCabinet.Win32Assign(pcwszCabinetPath, ::wcslen(pcwszCabinetPath)));
    IFW32FALSE_EXIT(buffTarget.Win32Assign(pcwszTargetPath, ::wcslen(pcwszTargetPath)));
    IFW32FALSE_EXIT(cabData.Initialize(buffTarget, true));

    IFW32FALSE_EXIT(::SxspExpandCabinetIntoTemp(
        0,
        buffCabinet,
        impData,
        &cabData));

#endif
    FN_EPILOG
}

BOOL TestReparsePointOnFullQualifiedPath(PCWSTR basePath, PCWSTR fullPath)
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
*/
    FN_PROLOG_WIN32
#if 0

    BOOL CrossesReparsePoint = FALSE;
    IFW32FALSE_EXIT(
        ::SxspDoesPathCrossReparsePoint(
            basePath,
            wcslen(basePath),
            fullPath,
            wcslen(fullPath),
            CrossesReparsePoint));

#endif
    FN_EPILOG
}


HRESULT TestAssemblyNameQueryAssemblyInfo()
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
it is bad to have these hard coded strings in shipping files
*/
    HRESULT hr = S_OK;
    FN_TRACE_HR(hr);
#if 0
    PCWSTR manifest_files[] = {
        L"Z:\\tests\\footest\\cdfiles\\cards_0001\\cards.manifest",
        L"Z:\\tests\\footest\\cdfiles\\policy\\policy1\\asmpol.MANIFEST"
    };

    PCWSTR pwszAssemblyIdentity[] = {
        L"Cards_0000,language=\"en-us\",processorArchitecture=\"X86\",publicKeyToken=\"6595b64144ccf1df\",type=\"win32\",version=\"1.0.0.0\"",
        L"policy.1.0.dynamicdll,processorArchitecture=\"x86\",publicKeyToken=\"75e377300ab7b886\",type=\"win32-policy\",version=\"1.1.1.1\""
    };

    SXS_UNINSTALLW Uninstall = {sizeof(Uninstall)};
    DWORD dwDisposition = 0;

    //
    // install
    //
    for (DWORD i = 0; i < NUMBER_OF(manifest_files); i++)
    {
        SXS_INSTALLW Info = {sizeof(Info)};
        SXS_INSTALL_REFERENCEW Reference = {sizeof(Reference)};

        Info.dwFlags = SXS_INSTALL_FLAG_REPLACE_EXISTING |
                        SXS_INSTALL_FLAG_REFERENCE_VALID |
                        SXS_INSTALL_FLAG_CODEBASE_URL_VALID |
                        SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID;
        Info.lpManifestPath = manifest_files[i];
        Info.lpCodebaseURL = Info.lpManifestPath;
        Info.lpReference = &Reference;
        Info.lpLogFileName = L"c:\\thelogfile";


        Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;
        Reference.lpIdentifier = L"Sxs installation";

        IFW32FALSE_EXIT(::SxsInstallW(&Info));
    }

    //
    // QueryInfo
    //
    for ( i =0; i < NUMBER_OF(manifest_files); i++)
    {
        IAssemblyCache * pCache = NULL;
        WCHAR buf[MAX_PATH];
        ASSEMBLY_INFO iasm;

        //IFCOMFAILED_EXIT(GetTextualAssemblyIdentityFromManifest(&sbTextualAssembly, manifest_files[i]));
        IFCOMFAILED_EXIT(::CreateAssemblyCache(&pCache, 0));
        ZeroMemory(&iasm, sizeof(iasm));
        iasm.cchBuf = MAX_PATH;
        iasm.pszCurrentAssemblyPathBuf = buf;
        IFCOMFAILED_EXIT(pCache->QueryAssemblyInfo(0, pwszAssemblyIdentity[i], &iasm));
    }

    //
    // Uninstall
    //
    Uninstall.dwFlags = SXS_UNINSTALL_FLAG_USE_INSTALL_LOG;
    Uninstall.lpInstallLogFile = L"c:\\thelogfile";

    if (!(*SxsUninstallW)(&Uninstall, &dwDisposition))
    {
        goto Exit;
    }


#endif
    FN_EPILOG
}

HRESULT TestAssemblyName()
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
it is bad to have these hard coded strings in shipping files
*/
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);

#if 0

    //const WCHAR super_simple_inputstring[] = L"cards,version=\"1.0.0.0\",processorArchitecture=\"x86\",language=\"0409\",whatever=\"whatever\"";
    const WCHAR super_simple_inputstring[] = L"cards,version=\"1.0.0.0\",processorArchitecture=\"x86\",language=\"0409\"";
    //const WCHAR super_simple_inputstring[] = L"cards,,,,,";
//    const WCHAR simple_inputstring[] = L"ca&#x2c;r&#x2c;d&#x22;s,http://fusion:whatever=\"&#x22;&#x2c;0&#x2c;&#x22;\",http://fusion:processorarchitecture=\"x86\",http://neptune:language=\"0409\"";
//    const WCHAR complex_inputstring[] = L"firstcards&#x22;secondcards,http://fusion:version=\"1.0.0.0\",http://www.shuku.net/novels/prose/zxfjdsw:whatever=\"what&#x2c;ever\"";
    CAssemblyName * pAsmName = NULL;
    IAssemblyName * pIAsmName = NULL;
    LPWSTR szDisplayName = NULL ;
    ULONG ccDisplayName = 0;
    LPWSTR psz = NULL;
    CSmartRef<IAssemblyCache> pCache;
    CStringBuffer bufPath;
    PCWSTR szAssemblyStr = super_simple_inputstring;

    IFCOMFAILED_EXIT(::CreateAssemblyCache(&pCache, 0));
    // parse : convert string from Darwin to Fusion
    IFCOMFAILED_EXIT(::CreateAssemblyNameObject(&pIAsmName, szAssemblyStr, CANOF_PARSE_DISPLAY_NAME, NULL));
    pAsmName = reinterpret_cast<CAssemblyName*>(pIAsmName);
    ccDisplayName = static_cast<ULONG>(wcslen(szAssemblyStr));
    ccDisplayName ++;    // for worst case
    szDisplayName = NEW (WCHAR[ccDisplayName]);

    if (!szDisplayName)
        goto Exit;
    // GetDisplayName: convert string from Fusion to Darwin
    IFCOMFAILED_EXIT(pAsmName->GetDisplayName(szDisplayName, &ccDisplayName, 0));
    //ASSERT(wcscmp(szDisplayName, szAssemblyStr) == 0);
    IFCOMFAILED_EXIT(pAsmName->GetInstalledAssemblyName(0, SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY, bufPath));
    hr = NOERROR;
Exit:
    if (pAsmName)
        pAsmName->Release();

    delete[] szDisplayName;
    delete[] psz ;
#endif
    return hr;
}

BOOL
SxspManifestSchemaCheck(
    PCWSTR  parameterstring // this must be a full-qualified filename of a manifest file
    )
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
#if 0
    ACTCTXGENCTX ActCtxGenCtx;
    ULONG ManifestFlags = 0;
    CProbedAssemblyInformation AssemblyInformation;
    CImpersonationData ImpersonationData;
    PCWSTR Slash = NULL;
    PASSEMBLY Asm = NULL;
    CStringBuffer buffManifestPath;
    USHORT ProcessorArchitecture = ::SxspGetSystemProcessorArchitecture();
    LANGID LangId = ::GetUserDefaultLangID();
// BUGBUG xiaoyuw@09/17/00 : disable to set Name and version from the command line for simplicity
    PARAMETER_CHECK(parameterstring != NULL);

    IFW32FALSE_EXIT(AssemblyInformation.Initialize(&ActCtxGenCtx));

    IFW32FALSE_EXIT(buffManifestPath.Win32Assign(parameterstring, ::wcslen(parameterstring)));

    IFW32FALSE_EXIT(
        ::SxspInitActCtxGenCtx(
                &ActCtxGenCtx,         // context out
                MANIFEST_OPERATION_VALIDATE_SYNTAX,
                0,
                0,
                ImpersonationData,
                ProcessorArchitecture,
                LangId,
                ACTIVATION_CONTEXT_PATH_TYPE_NONE,
                0,
                NULL));
    // get manifestpath, manifestName, manifestVersion
    Slash = wcsrchr(buffManifestPath, L'\\');
    PARAMETER_CHECK(Slash != NULL);

    IFALLOCFAILED_EXIT(Asm = new ASSEMBLY);

    ManifestFlags = ASSEMBLY_MANIFEST_FILETYPE_FILE;

    IFW32FALSE_EXIT(AssemblyInformation.SetManifestPath(ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE, buffManifestPath));

    IFW32FALSE_EXIT(AssemblyInformation.SetManifestFlags(ManifestFlags));
    IFW32FALSE_EXIT(AssemblyInformation.SetManifestLastWriteTime(ImpersonationData)); // using default parameter-value

    IFW32FALSE_EXIT(::SxspInitAssembly(Asm, AssemblyInformation));
    IFW32FALSE_EXIT(::SxspIncorporateAssembly(&ActCtxGenCtx, Asm));
    IFW32FALSE_EXIT(::SxspFireActCtxGenEnding(&ActCtxGenCtx));

    fSuccess = TRUE;
Exit:
    if (Asm != NULL)
        Asm->Release();
#endif
    return fSuccess;
}

#if SXS_PRECOMPILED_MANIFESTS_ENABLED

HRESULT
GetPCMWorkingTime(PCWSTR filename, LARGE_INTEGER* pcmtime)
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
*/
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
#if 0
    CStringBuffer buf;
    CSmartRef<XMLParserTestFactory>    factory;
    CSmartRef<CPrecompiledManifestReader> pPCMReader;
    LARGE_INTEGER timestart = {0};
    ULONG i = 0;
    ULONG j = 0;

    buf.Assign(filename, ::wcslen(filename));
    buf.Append(L".pcm", 4);

    factory = new XMLParserTestFactory;
    if (! factory) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFactory, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pPCMReader = new CPrecompiledManifestReader);
    if (! pPCMReader) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    for (j=0; j<10; j++) {
        ::QueryPerformanceCounter(&timestart);
        for (i = 0 ; i < 10; i++) {
            hr = pPCMReader->InvokeNodeFactory(buf, factory);
            if (FAILED(hr))
                goto Exit;
        }
         ::QueryPerformanceCounter(&pcmtime[j]);
         pcmtime[j].QuadPart -= timestart.QuadPart;
    }

    hr = NOERROR;
Exit:
#endif
    return hr;
}

#endif // SXS_PRECOMPILED_MANIFESTS_ENABLED

HRESULT GetParserWorkingTime(PCWSTR filename, LARGE_INTEGER* parsertime)
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
*/
    HRESULT                 hr = S_OK;
    FN_TRACE_HR(hr);
#if 0
    LARGE_INTEGER t1[10], t2[10];
    LARGE_INTEGER timestart;
    ULONG i = 0;
    ULONG j = 0;
    CSmartRef<IXMLParser>    pIXMLParser;
    XMLParser *              pXMLParser;
    CSmartRef<XMLParserTestFactory> factory;
    CSmartRef<XMLParserTestFileStream> filestream;

    filestream = NEW (XMLParserTestFileStream());
    if (!filestream) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFileStream, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;

    }

    if (! filestream->open(filename))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to call XMLParserTestFileStream::open\n");

        hr = E_UNEXPECTED;
        goto Exit;
    }

    factory = new XMLParserTestFactory;
    if (! factory) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFactory, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pXMLParser = NEW(XMLParser);
    pIXMLParser = pXMLParser;
    if (pIXMLParser == NULL)
    {
        hr = E_OUTOFMEMORY;
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Attempt to instantiate XML parser failed\n");
        goto Exit;
    }
    if (FAILED(hr = pXMLParser->HrInitialize()))
        goto Exit;

    hr = pIXMLParser->SetInput(filestream); // filestream's RefCount=2
    if (! SUCCEEDED(hr))
        goto Exit;

    hr = pIXMLParser->SetFactory(factory); // factory's RefCount=2
    if (! SUCCEEDED(hr))
        goto Exit;

    for (j =0; j<10; j++) {
        ::QueryPerformanceCounter(&timestart);
        for (i = 0 ; i< 10; i++) {
           hr = pIXMLParser->Run(-1);
           if (FAILED(hr))
               goto Exit;
           pIXMLParser->Reset();
           pIXMLParser->SetFactory(factory);
           filestream->close();
           filestream->open(filename);
           pIXMLParser->SetInput(filestream);
        }
        ::QueryPerformanceCounter(&t1[j]);
        t1[j].QuadPart -= timestart.QuadPart;

        ::QueryPerformanceCounter(&timestart);
        for (i = 0 ; i< 10; i++) {
           hr = NOERROR;
           if (FAILED(hr))
               goto Exit;
           pIXMLParser->Reset();
           pIXMLParser->SetFactory(factory);
           filestream->close();
           filestream->open(filename);
           pIXMLParser->SetInput(filestream);
        }
        ::QueryPerformanceCounter(&t2[j]);
        t2[j].QuadPart -= timestart.QuadPart;

        parsertime[j].QuadPart = t1[j].QuadPart - t2[j].QuadPart;
    }

    hr = NOERROR;
Exit:
#endif
    return hr;
}

#if SXS_PRECOMPILED_MANIFESTS_ENABLED

HRESULT TestPCMTime(PCWSTR manifestfilename)
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
*/
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    LARGE_INTEGER tmp1 = {0};
    LARGE_INTEGER tmp2 = {0};
    LARGE_INTEGER parsertime[10] = {0}, pcmtime[10] = {0};
    ULONG i = 0;

    hr = GetParserWorkingTime(manifestfilename, parsertime);
    if (FAILED(hr))
        goto Exit;

    hr = GetPCMWorkingTime(manifestfilename, pcmtime);
    if (FAILED(hr))
        goto Exit;

    for (i= 0 ; i < 10; i ++){
        tmp1.QuadPart = tmp1.QuadPart + parsertime[i].QuadPart;
        tmp2.QuadPart = tmp2.QuadPart + pcmtime[i].QuadPart;
    }
    tmp1.QuadPart = tmp1.QuadPart/10;
    tmp2.QuadPart = tmp2.QuadPart/10;

    ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_INFO,
                    "SxsDebug::TestPCMTime Result:\n\tXMLParser uses %d,\n\tPCM uses %d,\n\tthe difference is %d.\n",
                    tmp1.QuadPart, tmp2.QuadPart, tmp1.QuadPart-tmp2.QuadPart);

    hr = NOERROR;
Exit:
    return hr;
}

/* ---------------------------------------------------------------------------
 Two steps :
   1. paring the manifest file,
        generate the NodeFactory print-out file1,
        generate the precompiled-manifest
   2. using precompiled-manifest and call NodeFactory to generate pcm-printout file2
   3. Compare file1 and file2

--------------------------------------------------------------------------- */
HRESULT
PrecompiledManifestTest(PCWSTR filename) // this is a manifest file name
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
*/
    HRESULT                     hr = S_OK;
    FN_TRACE_HR(hr);
#if 0
    CSmartRef<IXMLParser>       pIXMLParser;
    CSmartRef<PCMTestFactory>   wfactory;
    CSmartRef<PCMTestFactory>   rfactory;
    CSmartRef<XMLParserTestFileStream> filestream;
    CStringBuffer               buf;
    CSmartRef<CPrecompiledManifestWriter> pPCMWriter;
    CSmartRef<CPrecompiledManifestReader> pPCMReader;
    FILE                        *fp = NULL;

    if (!filename) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    buf.Assign(filename, ::wcslen(filename));
    buf.Append(L".pcm", 4);

    // create filestream for xmlparser ...
    filestream = NEW (XMLParserTestFileStream());
    if (!filestream) {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFileStream, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;

    }
    if (! filestream->open(filename))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to call XMLParserTestFileStream::open\n");

        hr = E_UNEXPECTED;
        goto Exit;
    }

    // create PCMWriter for xmlparser
    wfactory = new PCMTestFactory(L"e:\\manifest.out"));
    if (wfactory == NULL)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFactory, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pPCMWriter = new CPrecompiledManifestWriter);
    if (! pPCMWriter)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    pPCMWriter->Initialize(buf);
    pPCMWriter->SetFactory(wfactory);

    // Create XMLParser
    pIXMLParser = NEW(XMLParser);
    if (pIXMLParser == NULL){
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Attempt to instantiate XML parser failed\n");
        goto Exit;
    }
    if (FAILED(hr = pIXMLParser->HrInitialize()))
        goto Exit;

    hr = pIXMLParser->SetInput(filestream); // filestream's RefCount=2
    if (! SUCCEEDED(hr))
        goto Exit;

    hr = pIXMLParser->SetFactory(pPCMWriter); // wfactory's RefCount=2
    if (! SUCCEEDED(hr))
        goto Exit;

    hr = pIXMLParser->Run(-1);
    if (FAILED(hr))
        goto Exit;

    hr = pPCMWriter->Close();
    if (FAILED(hr))
        goto Exit;

    CSimpleFileStream::printf(L"PCM has been generated!!!\n\n");

    // PCM Reader
    pPCMReader = new CPrecompiledManifestReader);
    if (pPCMReader == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    rfactory = new PCMTestFactory(L"e:\\pcm.out"));
    if (rfactory == NULL)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INFO,
            "SxsDebug:: fail to new XMLParserTestFactory, out of memory\n");

        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pPCMReader->InvokeNodeFactory(buf, rfactory);
    if (FAILED(hr))
        goto Exit;
    hr = NOERROR;
Exit:
#endif
    return hr;
}

#endif // SXS_PRECOMPILED_MANIFESTS_ENABLED

BOOL CreateMultiLevelDirectoryTest(PCWSTR pwszNewDirs)
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
*/
    BOOL fSuccess = TRUE;
    FN_TRACE_WIN32(fSuccess);
#if 0
    const static WCHAR CurrentDirectory[]=L"e:\\tmp\\tmp";

    IFW32FALSE_EXIT(::SxspCreateMultiLevelDirectory(CurrentDirectory, pwszNewDirs));
    fSuccess = TRUE;
Exit:
#endif
    return fSuccess;
}

BOOL TestCopyDirectory()
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
large frame
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
#if 0
    CSmallStringBuffer m1;
    CSmallStringBuffer m2;

    IFW32FALSE_EXIT(m1.Win32Assign(L"Z:\\tmp\\tmp", NUMBER_OF(L"Z:\\tmp\\tmp")-1));
    IFW32FALSE_EXIT(m2.Win32Assign(L"Z:\\tests\\tmp", NUMBER_OF(L"Z:\\tests\\tmp")-1));

    IFW32FALSE_EXIT(::SxspInstallMoveFileExW(m1, m2, MOVEFILE_REPLACE_EXISTING));
    fSuccess = TRUE;
Exit:
#endif
    return fSuccess;
}

BOOL TestSxsGeneratePath()
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
large frame
it is bad to have these hard coded strings in shipping files
*/
    //
    // the result is as below
    //
    //path is c:\winnt\winsxs\Manifests\x86_dynamicdll_b54bc117ce08a1e8_1.1.0.0_en-us_fb8e827d.Manifest
    //path is Manifests\x86_dynamicdll_b54bc117ce08a1e8_1.1.0.0_en-us_fb8e827d.Manifest
    //path is c:\winnt\winsxs\Manifests\
    //path is Manifests\x86_dynamicdll_b54bc117ce08a1e8_en-us_2ffeb063.Manifest
    //---------------------------------------
    //path is c:\winnt\winsxs\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_1.1.0.0_en-us_d51541cb\
    //path is x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_1.1.0.0_en-us_d51541cb\
    //path is c:\winnt\winsxs\
    //path is x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95\
    //---------------------------------------
    //path is c:\winnt\winsxs\Policies\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95\1.1.0.0.Policy
    //path is Policies\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95\1.1.0.0.Policy
    //path is c:\winnt\winsxs\Policies\
    //path is Policies\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95\1.1.0.0.Policy

    // if the assembly does not have version, flag=0 and pathType=policy would generate "policy store"
    //       c:\winnt\winsxs\Policies\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95
    //

    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
#if 0
    CTinyStringBuffer PathBuffer;
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    //WCHAR szDisplayName[]=L"policy.1.0.dynamicdll,type=\"win32-policy\",publicKeyToken=\"b54bc117ce08a1e8\",version=\"1.1.0.0\",language=\"en-us\",processorArchitecture=\"x86\"";
    PWSTR szDisplayName[]= {
        L"dynamicdll,type=\"win32\",publicKeyToken=\"b54bc117ce08a1e8\",version=\"1.1.0.0\",language=\"en-us\",processorArchitecture=\"x86\"",
        L"policy.1.0.dynamicdll,type=\"win32-policy\",publicKeyToken=\"b54bc117ce08a1e8\",version=\"1.1.0.0\",language=\"en-us\",processorArchitecture=\"x86\"",
        L"policy.1.0.dynamicdll,type=\"win32-policy\",publicKeyToken=\"b54bc117ce08a1e8\",version=\"1.1.0.0\",language=\"en-us\",processorArchitecture=\"x86\""
    };

    DWORD j, dwPathType;

    DWORD flags[]={
        0,
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
        SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH,
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION};


    printf("---------------------------------------\n");
    for (dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST; dwPathType <= SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY; dwPathType++)
    //for (dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY; dwPathType <= SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY; dwPathType++)
    {
        IFW32FALSE_EXIT(::SxspCreateAssemblyIdentityFromTextualString(
                szDisplayName[dwPathType - 1],
                &pAssemblyIdentity));

        for (j = 0 ; j < NUMBER_OF(flags); j++)
        {
            IFW32FALSE_EXIT(::SxspGenerateSxsPath(
                flags[j],
                dwPathType,
                L"c:\\winnt\\winsxs",
                wcslen(L"c:\\winnt\\winsxs"),
                pAssemblyIdentity,
                NULL,
                PathBuffer));
            printf("path is %S\n", static_cast<PCWSTR>(PathBuffer));
        }
        printf("---------------------------------------\n");
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);
        pAssemblyIdentity = NULL;
    }
    fSuccess = TRUE;
Exit:
    if (pAssemblyIdentity)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

#endif
    return fSuccess;
}

BOOL ManifestProbeTest()
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
it is bad to have these hard coded strings in shipping files
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
#if 0
    DWORD index = 0;
    CTinyStringBuffer PathBuffer;
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    PROBING_ATTRIBUTE_CACHE pac = { 0 };

    ASSEMBLY_IDENTITY_ATTRIBUTE AttributeName;
    ASSEMBLY_IDENTITY_ATTRIBUTE AttributeVersion;
    ASSEMBLY_IDENTITY_ATTRIBUTE AttributeLangID;
    ASSEMBLY_IDENTITY_ATTRIBUTE AttributeProcessorArchitecture;
    PASSEMBLY_IDENTITY_ATTRIBUTE Attributes[] = {
            &AttributeName, &AttributeVersion,
            &AttributeLangID, &AttributeProcessorArchitecture};


    AttributeName.Flags         = 0; // reserved flags : must be 0;
    AttributeName.NamespaceCch  = 0;
    AttributeName.NameCch       = 4;
    AttributeName.ValueCch      = 7;
    AttributeName.Namespace     = NULL;
    AttributeName.Name          = L"name";
    AttributeName.Value         = L"foo.mui";

    AttributeVersion.Flags         = 0; // reserved flags : must be 0;
    AttributeVersion.NamespaceCch  = 0;
    AttributeVersion.NameCch       = 7;
    AttributeVersion.ValueCch      = 7;
    AttributeVersion.Namespace     = NULL;
    AttributeVersion.Name          = L"version";
    AttributeVersion.Value         = L"1.1.1.1";

    AttributeLangID.Flags         = 0; // reserved flags : must be 0;
    AttributeLangID.NamespaceCch  = 0;
    AttributeLangID.NameCch       = 8;
    AttributeLangID.ValueCch      = 5;
    AttributeLangID.Namespace     = NULL;
    AttributeLangID.Name          = L"language";
    AttributeLangID.Value         = L"en-us";

    AttributeProcessorArchitecture .Flags         = 0; // reserved flags : must be 0;
    AttributeProcessorArchitecture .NamespaceCch  = 0;
    AttributeProcessorArchitecture .NameCch       = 21;
    AttributeProcessorArchitecture .ValueCch      = 3;
    AttributeProcessorArchitecture .Namespace     = NULL;
    AttributeProcessorArchitecture .Name          = L"processorArchitecture";
    AttributeProcessorArchitecture .Value         = L"x86";

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(
        0,                                      // DWORD Flags,
        ASSEMBLY_IDENTITY_TYPE_DEFINITION,      // ULONG Type,
        &pAssemblyIdentity,
        4,                                      // ULONG AttributeCount,
        Attributes));                           // PCASSEMBLY_IDENTITY_ATTRIBUTE const *Attributes


    while(1) {// run until we run out of probing-path
        bool fDone = false;
        if (!::SxspGenerateManifestPathForProbing(
                index,
                0,
                NULL,
                0,
                ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE,
                L"E:\\APPBASE\\",
                11,
                pAssemblyIdentity,
                &pac,
                PathBuffer,
                NULL,
                fDone))
        {
            goto Exit;
        }

        if (fDone)
            break;

        PathBuffer.Clear();
        index ++;
    }

    fSuccess = TRUE;

Exit:
    if (pAssemblyIdentity)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);
    if (!fSuccess) {
        DWORD dwLastError = ::FusionpGetLastWin32Error();
        if (dwLastError == BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_DEPENDENCY_ASSEMBLY_NOT_FOUND){
            ::FusionpSetLastWin32Error(0);
            fSuccess = TRUE;
        }
    }
#endif
    return fSuccess;
}


#define WATCHBUCKET_NOTIFYSIZE (1024)
typedef struct _tWATCH_BUCKET
{
    HANDLE                  hFile;
    HANDLE                  hCompleteEvent;
    PCSXS_PROTECT_DIRECTORY pProtectInfo;
    OVERLAPPED              olapInfo;
    BYTE                    NotifyInfo[WATCHBUCKET_NOTIFYSIZE];
    DWORD                   dwBytesBack;
}
WATCH_BUCKET, *PWATCH_BUCKET;


HRESULT
TryWatchingDirectories()
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
*/
    HRESULT hrSuccess = E_FAIL;
    FN_TRACE_HR(hrSuccess);
#if 0
    PCSXS_PROTECT_DIRECTORY pWatchList;
    SIZE_T cWatchList = 0;
    DWORD dwWhichSignalled = 0;
    DWORD dw = 0;
    PWATCH_BUCKET pWatchBuckets = 0;
    HANDLE* pHandleList = 0;

    IFW32FALSE_EXIT(::SxsProtectionGatherEntriesW(&pWatchList, &cWatchList));
    pWatchBuckets = FUSION_NEW_ARRAY(WATCH_BUCKET, cWatchList);
    pHandleList = FUSION_NEW_ARRAY(HANDLE, cWatchList);

    //
    // Fill in the list with handles to directories
    //
    for (dw = 0; dw < cWatchList; dw++)
    {
        PWATCH_BUCKET pbTemp = pWatchBuckets + dw;
        ZeroMemory(pbTemp, sizeof(*pbTemp));

        pbTemp->pProtectInfo = pWatchList + dw;
        pbTemp->hFile = ::CreateFileW(
            pWatchList[dw].pwszDirectory,
            FILE_LIST_DIRECTORY,
            FILE_SHARE_READ | FILE_SHARE_DELETE | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
            NULL);

        pHandleList[dw] = CreateEventW(NULL, FALSE, FALSE, NULL);
        pbTemp->hCompleteEvent = pHandleList[dw];
        pbTemp->olapInfo.hEvent = pHandleList[dw];

        ::ReadDirectoryChangesW(
            pbTemp->hFile,
            (PVOID)(&pbTemp->NotifyInfo),
            WATCHBUCKET_NOTIFYSIZE,
            pbTemp->pProtectInfo->ulRecursiveFlag & SXS_PROTECT_RECURSIVE,
            SXS_PROTECT_FILTER_DEFAULT,
            &pbTemp->dwBytesBack,
            &pbTemp->olapInfo,
            NULL);
    }

    //
    // We now have a list of directories that we need to watch for changes.
    //
    while (true)
    {
        dwWhichSignalled = WaitForMultipleObjects(static_cast<DWORD>(cWatchList), pHandleList, FALSE, INFINITE);
        dwWhichSignalled -= WAIT_OBJECT_0;

        if (dwWhichSignalled < cWatchList)
        {
            //
            // Somebody went and fiddled with a directory!
            //
            dwWhichSignalled -= WAIT_OBJECT_0;
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INFO,
                "Someone changed: %ls\n",
                pWatchBuckets[dwWhichSignalled].pProtectInfo->pwszDirectory);

            ResetEvent(pHandleList[dwWhichSignalled]);

            PFILE_NOTIFY_INFORMATION pCursor;

            pCursor = (PFILE_NOTIFY_INFORMATION) pWatchBuckets[dwWhichSignalled].NotifyInfo;
            while (true)
            {
                ::SxsProtectionNotifyW(
                    (PVOID)pWatchBuckets[dwWhichSignalled].pProtectInfo,
                    pCursor->FileName,
                    pCursor->FileNameLength / sizeof(pCursor->FileName[0]),
                    pCursor->Action);

                if (pCursor->NextEntryOffset)
                    pCursor = (PFILE_NOTIFY_INFORMATION)(((PBYTE)pCursor) + pCursor->NextEntryOffset);
                else
                    break;
            }

            ::ReadDirectoryChangesW(
                pWatchBuckets[dwWhichSignalled].hFile,
                (PVOID)(&pWatchBuckets[dwWhichSignalled].NotifyInfo),
                WATCHBUCKET_NOTIFYSIZE,
                pWatchBuckets[dwWhichSignalled].pProtectInfo->ulRecursiveFlag & SXS_PROTECT_RECURSIVE,
                SXS_PROTECT_FILTER_DEFAULT,
                &pWatchBuckets[dwWhichSignalled].dwBytesBack,
                &pWatchBuckets[dwWhichSignalled].olapInfo,
                NULL);
        }
    }

    hrSuccess = S_OK;
Exit:
#endif
    return hrSuccess;
}

BOOL
DllRedirectionTest(
    PCWSTR manifestFileName
    )
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CFileStream manifestFileStream;
    CResourceStream ResourceStream;
    CFileStream policyFileStream;
    SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS parameters = {0};
    CTinyStringBuffer assemblyDirectory;
    CTinyStringBuffer CandidatePolicyPathBuffer;
    BOOL fPolicyExist = FALSE;
    PWSTR p = NULL;

    p = wcsrchr(manifestFileName, L'.');
    if (p && ((_wcsicmp(p, L".dll") ==0) || (_wcsicmp(p, L".exe") ==0))) // manifest is from a resource of a DLL or EXE
    {
        IFW32FALSE_EXIT(ResourceStream.Initialize(manifestFileName, MAKEINTRESOURCEW(RT_MANIFEST)));
        parameters.Manifest.Path = manifestFileName;
        parameters.Manifest.Stream = &ResourceStream;
        parameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;

        IFW32FALSE_EXIT(assemblyDirectory.Win32Assign(manifestFileName, ::wcslen(manifestFileName)));
        IFW32FALSE_EXIT(assemblyDirectory.Win32RemoveLastPathElement());
        parameters.AssemblyDirectory = assemblyDirectory;
    }
    else
    {
        IFW32FALSE_EXIT(
            manifestFileStream.OpenForRead(
                manifestFileName,
                CImpersonationData(),
                FILE_SHARE_READ,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN));
        parameters.Manifest.Path = manifestFileName;
        parameters.Manifest.Stream = &manifestFileStream;
        parameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;

        IFW32FALSE_EXIT(assemblyDirectory.Win32Assign(manifestFileName, ::wcslen(manifestFileName)));
        IFW32FALSE_EXIT(assemblyDirectory.Win32RemoveLastPathElement());
        parameters.AssemblyDirectory = assemblyDirectory;
    }

    // look for policy file in the same dir as the manifest path
    IFW32FALSE_EXIT(CandidatePolicyPathBuffer.Win32Assign(manifestFileName, ::wcslen(manifestFileName)));
    IFW32FALSE_EXIT(CandidatePolicyPathBuffer.Win32ChangePathExtension(CONFIG_FILE_EXTENSION, NUMBER_OF(CONFIG_FILE_EXTENSION) - 1, eErrorIfNoExtension));
    if (::GetFileAttributesW(CandidatePolicyPathBuffer) != -1) { // policy file exists
        fPolicyExist = TRUE;
        IFW32FALSE_EXIT(
            policyFileStream.OpenForRead(
                CandidatePolicyPathBuffer,
                CImpersonationData(),
                FILE_SHARE_READ,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN));

        parameters.Policy.Path = CandidatePolicyPathBuffer;
        parameters.Policy.Stream = &policyFileStream;
    }

    parameters.ProcessorArchitecture = 0 ;
    parameters.LangId = GetUserDefaultUILanguage();
    parameters.Flags = SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_APP_RUNNING_IN_SAFEMODE;

    IFW32FALSE_EXIT(::SxsGenerateActivationContext(&parameters));
    fSuccess = TRUE;
Exit:
    CSxsPreserveLastError ple;

    ::CloseHandle(parameters.SectionObjectHandle);

    ple.Restore();

    return fSuccess;
}

BOOL SxspDebugTestFusionArray(PCWSTR dir1, PCWSTR dir2)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

#if 0

    CTinyStringBuffer sbDir1;
    CTinyStringBuffer sbDir2;
    CFusionDirectoryDifference dirResult;

    IFW32FALSE_EXIT(sbDir1.Win32Assign(dir1, wcslen(dir1)));
    IFW32FALSE_EXIT(sbDir2.Win32Assign(dir2, wcslen(dir2)));
    IFW32FALSE_EXIT(
        ::FusionpCompareDirectoriesSizewiseRecursively(
            &dirResult,
            sbDir1,
            sbDir2));

    fSuccess = TRUE;
Exit:
#endif
    return fSuccess;
}

//
// this function is written for Testing team to generate pAssemblyIdentity
// there are two ways to generate assemblyIdentity, one is insert one attribute each time,
// another way is to make all attributes to be inserted ready in an array and call
// SxsCreateAssemblyIdentity. The con and pro for both approaches are obvious,
// the input string must be in a format as "ns1:n1=v1;ns2:n2=v2;",
// the whole string ending with a trailing ";", ns could be NULL
// this fucntion does not deal with complicate case such as ns/name/value string contains
// special chars. let me know if you do need deal with it...
//
// xiaoyuw@09/26/2000
//
BOOL
SxspGenerateManifestPathOnAssemblyIdentity(
    PCWSTR str,
    PWSTR pszOut,
    ULONG *pCchstr,
    PASSEMBLY_IDENTITY *ppAssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    CStringBuffer PathBuffer;

    if (ppAssemblyIdentity)
        *ppAssemblyIdentity = NULL;

    PARAMETER_CHECK(str != NULL);
    PARAMETER_CHECK(pCchstr != NULL);

    IFW32FALSE_EXIT(
    ::SxspCreateAssemblyIdentityFromTextualString(
        str,
        &pAssemblyIdentity));

    // AssemblyIdentity is created, now generate the path
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            NULL,
            0,
            pAssemblyIdentity,
            NULL,
            PathBuffer));

    IFW32FALSE_EXIT(PathBuffer.Win32CopyStringOut(pszOut, pCchstr));

    if (ppAssemblyIdentity != NULL)
    {
        *ppAssemblyIdentity = pAssemblyIdentity ;
        pAssemblyIdentity = NULL;
    }

    fSuccess = TRUE;

Exit:
    if (pAssemblyIdentity != NULL)
        SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    return fSuccess ;
}

/* --------------------------------------------------------------------------------
POLICY_PATH_FLAG_POLICY_IDENTITY_TEXTUAL_FORMAT  : x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_d51541cb
POLICY_PATH_FLAG_FULL_QUALIFIED_POLICIES_DIR     : c:\winnt\winsxs\policies
POLICY_PATH_FLAG_FULL_QUALIFIED_POLICY_FILE_NAME : c:\winnt\winsxs\policies\x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_d51541cb\1.1.0.0.policy, for .cat, you have to replace it manually
-------------------------------------------------------------------------------- */
BOOL
SxspGeneratePolicyPathOnAssemblyIdentity(
    DWORD  dwFlag,
    PCWSTR str,
    PWSTR pszOut,
    ULONG *pCchstr,
    PASSEMBLY_IDENTITY *ppAssemblyIdentity
    )
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PASSEMBLY_IDENTITY pAssemblyIdentity;
    DWORD dwPathType = 0;
    DWORD dwGenerateFlag = 0;
    CTinyStringBuffer PathBuffer;
    CTinyStringBuffer bufAssemblyRootDirectory;

    IFW32FALSE_EXIT(
    ::SxspCreateAssemblyIdentityFromTextualString(
        str,
        &pAssemblyIdentity));

    switch (dwFlag)
    {
    case POLICY_PATH_FLAG_POLICY_IDENTITY_TEXTUAL_FORMAT:
        dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY;
        dwGenerateFlag = SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION;
        break;
    case POLICY_PATH_FLAG_FULL_QUALIFIED_POLICIES_DIR:
        {
        IFW32FALSE_EXIT(SxspGetAssemblyRootDirectory(bufAssemblyRootDirectory));
        dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY;
        dwGenerateFlag = SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH;
        }
        break;
    case POLICY_PATH_FLAG_FULL_QUALIFIED_POLICY_FILE_NAME:
        {
        IFW32FALSE_EXIT(SxspGetAssemblyRootDirectory(bufAssemblyRootDirectory));
        dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY;
        dwGenerateFlag = 0;
        }
        break;
    default:
        ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        goto Exit;
    }


    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            dwGenerateFlag,
            dwPathType,
            bufAssemblyRootDirectory,
            bufAssemblyRootDirectory.Cch(),
            pAssemblyIdentity,
            NULL,
            PathBuffer));

    IFW32FALSE_EXIT(PathBuffer.Win32CopyStringOut(pszOut, pCchstr));

    if (ppAssemblyIdentity != NULL)
    {
        *ppAssemblyIdentity = pAssemblyIdentity ;
        pAssemblyIdentity = NULL;
    }
    fSuccess = TRUE;

Exit:
    if (pAssemblyIdentity != NULL)
        SxsDestroyAssemblyIdentity(pAssemblyIdentity);
    return fSuccess ;
}

BOOL SxspDebugTestAssemblyIdentityHash()
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
it is bad to have these hard coded strings in shipping files
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

#if 0
    ULONG hash1 = 0;
    ULONG hash2 = 0;
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;
    ASSEMBLY_IDENTITY_ATTRIBUTE Attribute;

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &pAssemblyIdentity, 0, NULL));

    Attribute.Flags         = 0;
    Attribute.NamespaceCch  = 18;
    Attribute.Namespace     = L"http://interesting";
    Attribute.NameCch       = 8;
    Attribute.Name          = L"whatever";
    Attribute.ValueCch      = 32;
    Attribute.Value         = L"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";

    IFW32FALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(0, pAssemblyIdentity, &Attribute));
    IFW32FALSE_EXIT(SxsHashAssemblyIdentity(0, pAssemblyIdentity, &hash1));
    ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    // create second assembly identity

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &pAssemblyIdentity, 0, NULL));

    Attribute.Flags         = 0;
    Attribute.NamespaceCch  = 18;
    Attribute.Namespace     = L"http://interesting";
    Attribute.NameCch       = 8;
    Attribute.Name          = L"whatever";
    Attribute.ValueCch      = 32;
    Attribute.Value         = L"/>BABCDGHGHKLMNMNOPSTUVUVYZYZ[\\_`";

    IFW32FALSE_EXIT(::SxsInsertAssemblyIdentityAttribute(0, pAssemblyIdentity, &Attribute));
    IFW32FALSE_EXIT(SxsHashAssemblyIdentity(0, pAssemblyIdentity, &hash2));
    ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    fSuccess = TRUE;
Exit:
    if (pAssemblyIdentity)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);
#endif
    return fSuccess;
}

BOOL
SxspDebugTestNewCatalogSignerThingy(
    PCWSTR pcwszCatalog
    )
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
*/
    BOOL fSuccess = FALSE;
    ULONG ulKeyLength = 0;
    CPublicKeyInformation CatalogInformation;
    CTinyStringBuffer sbSignerString;
    CTinyStringBuffer sbCatalogName;
    FN_TRACE_WIN32(fSuccess);

    IFW32FALSE_EXIT(sbCatalogName.Win32Assign(pcwszCatalog, ::wcslen(pcwszCatalog)));
    IFW32FALSE_EXIT(CatalogInformation.Initialize(sbCatalogName));
    IFW32FALSE_EXIT(CatalogInformation.GetStrongNameString(sbSignerString));
    IFW32FALSE_EXIT(CatalogInformation.GetPublicKeyBitLength(ulKeyLength));

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "Strong name of catalog signer: %ls\n"
        "Key: %ls (length %ld)\n",
        static_cast<PCWSTR>(sbSignerString),
        ulKeyLength);

    fSuccess = TRUE;
Exit:
    return fSuccess;
};



BOOL TestSystemDefaultActCtxGeneration()
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
large frame
it is bad to have these hard coded strings in shipping files
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

#if 0

    SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameter = {0};
    WCHAR pszTextualAssemblyIdentity[] =
        L"Microsoft.Windows.SystemCompatible,publicKeyToken=\"6595b64144ccf1df\",version=\"5.1.1.0\",type=\"win32\",processorArchitecture=\"x86\"\0";
    CStringBuffer AssemblyDirectory;

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(AssemblyDirectory));
    IFW32FALSE_EXIT(AssemblyDirectory.Win32EnsureTrailingPathSeparator());

    Parameter.ProcessorArchitecture = 0 ;
    Parameter.LangId = 0x0409;
    Parameter.Flags = SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY;
    Parameter.TextualAssemblyIdentity = pszTextualAssemblyIdentity;
    Parameter.AssemblyDirectory = AssemblyDirectory;

    IFW32FALSE_EXIT(SxsGenerateActivationContext(&Parameter));

    fSuccess = TRUE;
Exit:
    // check LastError
    if (Parameter.SectionObjectHandle != NULL)
        ::CloseHandle(Parameter.SectionObjectHandle);

    if (Parameter.Manifest.Stream)
        Parameter.Manifest.Stream->Release();

#endif
    return fSuccess;
}

BOOL
TestSfcUIPopup()
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
large frame
it is bad to have these hard coded strings in shipping files
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
#if 0
    CAssemblyRecoveryInfo RecoverInfo;
    CSXSMediaPromptDialog PromptDialog;
    CTinyStringBuffer sbAssemblyName;
    const static WCHAR wchTestName[] = L"x86_Microsoft.Tools.VisualCPlusPlus.Runtime-Libraries_6595b64144ccf1df_6.0.0.0_x-ww_ff9986d7";
    bool fNoAssembly = false;

    IFW32FALSE_EXIT(RecoverInfo.Initialize());
    IFW32FALSE_EXIT(sbAssemblyName.Win32Assign(wchTestName, NUMBER_OF(wchTestName) - 1));
    IFW32FALSE_EXIT(RecoverInfo.AssociateWithAssembly(sbAssemblyName, fNoAssembly));

    fSuccess = TRUE;
Exit:
#endif
    return fSuccess;
}

BOOL
TestPolicyPathGeneration()
{
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
remove this from sxs.dll, statically link sxstest.exe instead
it is bad to have these hard coded strings in shipping files
*/
#if 0
    WCHAR str[] = L"policy.1.0.ms-sxstest-folder1,processorArchitecture=\"x86\",type=\"win32-policy\",language=\"en\",version=\"2.2.2.2\",publicKeyToken=\"75e377300ab7b886\"";
    WCHAR pszOut[1024];
    ULONG Cchstr = 0;
    for (DWORD dwFlag=0; dwFlag<3; dwFlag++)
    {
        SxspGeneratePolicyPathOnAssemblyIdentity(
            dwFlag,
            str,
            pszOut,
            &Cchstr,
            NULL);
    };
#endif
    return TRUE;
}


BOOL
SxspDebug(
    ULONG iOperation,
    DWORD dwFlags,
    PCWSTR pszParameter1,
    PVOID pvParameter2)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    switch (iOperation)
    {
    case SXS_DEBUG_SYSTEM_DEFAULT_ACTCTX_GENERATION:
        IFW32FALSE_EXIT(::TestSystemDefaultActCtxGeneration());
        break;
    case SXS_DEBUG_SFC_UI_TEST:
        IFW32FALSE_EXIT( TestSfcUIPopup() );
        break;
    case SXS_DEBUG_CATALOG_SIGNER_CHECK:
        IFW32FALSE_EXIT(::SxspDebugTestNewCatalogSignerThingy(pszParameter1));
        break;
    case SXS_DEBUG_ASSEMBLY_IDENTITY_HASH:
        IFW32FALSE_EXIT(::SxspDebugTestAssemblyIdentityHash());
        break;
    case SXS_DEBUG_ASSEMBLYNAME_CONVERSION:
        //IFCOMFAILED_EXIT(TestAssemblyName());
        //IFCOMFAILED_EXIT(::TestDeleteInstalledAssemblyBasedOnAssemblyName());
        //IFW32FALSE_EXIT(::TestPolicyPathGeneration());
        IFCOMFAILED_EXIT(TestAssemblyNameQueryAssemblyInfo());

        break;
    case SXS_DEBUG_GET_STRONGNAME:
    {
        CPublicKeyInformation pkInfo;
        CFusionArray<BYTE> PublicKeyBytes;
        CStringBuffer *pStringBuffers = (CStringBuffer*) pvParameter2;
        PCCERT_CONTEXT pContext = (PCCERT_CONTEXT) pszParameter1;

        PARAMETER_CHECK(pszParameter1 != NULL);
        PARAMETER_CHECK(pvParameter2 != NULL);

        IFW32FALSE_EXIT(pkInfo.Initialize(pContext));
        IFW32FALSE_EXIT(pkInfo.GetSignerNiceName(pStringBuffers[0]));
        IFW32FALSE_EXIT(pkInfo.GetStrongNameString(pStringBuffers[1]));
        IFW32FALSE_EXIT(pkInfo.GetWrappedPublicKeyBytes(PublicKeyBytes));
        IFW32FALSE_EXIT(::SxspHashBytesToString(PublicKeyBytes.GetArrayPtr(), PublicKeyBytes.GetSize(), pStringBuffers[2]));
        break;
    }

    case SXS_DEBUG_FUSION_REPARSEPOINT:
        PARAMETER_CHECK(pszParameter1 != NULL);
        PARAMETER_CHECK(pvParameter2 != NULL);
        IFW32FALSE_EXIT(::TestReparsePointOnFullQualifiedPath(pszParameter1, (PCWSTR)pvParameter2));
        break;

    case SXS_DEBUG_FOLDERNAME_FROM_ASSEMBLYIDENTITY_GENERATION:
        {
            WCHAR pstr[1024];
            ULONG cch = NUMBER_OF(pstr);
            PARAMETER_CHECK(pszParameter1 != NULL);
            IFW32FALSE_EXIT(SxspGenerateManifestPathOnAssemblyIdentity(pszParameter1, pstr, &cch, NULL));
        }
        break;
    case SXS_DEBUG_FUSION_ARRAY:
        PARAMETER_CHECK(pszParameter1 != NULL);
        PARAMETER_CHECK(pvParameter2 != NULL);
        IFW32FALSE_EXIT(SxspDebugTestFusionArray(pszParameter1, reinterpret_cast<PCWSTR>(pvParameter2)));
        break;
    case SXS_DEBUG_FORCE_LEAK:
    {
        //
        // Leaking memory intentionally - do not fix!
        // - if pvParameter2 is NULL, then leaks one byte
        // - Otherwise, assumes pvParameter2 is a PDWORD that is now many bytes
        //   should be leaked.
        //
        // Uses new[] to interact with the heap; might want to use the flags to
        //   indicate use of the Fusion heap or whatnot.
        //
        DWORD dwLeakCount = pvParameter2 ? *((PDWORD)pvParameter2) : 1;
        PCHAR pLeaked = NEW(CHAR[ dwLeakCount ]);

        if (pLeaked)
        {
            ::FusionpDbgPrintEx(
              FUSION_DBG_LEVEL_INFO,
              "SxsDebug::ForceLeak allocates %d bytes\n",
              dwLeakCount);
            fSuccess = TRUE;
        }
        else
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INFO,
                "SxsDebug::ForceLeak didn't allocate anything, new failed\n");
        }
        break;
    }

    case SXS_DEBUG_EXPAND_CAB_FILE:
        IFW32FALSE_EXIT(TestExpandCabinetFileToTemp(pszParameter1, static_cast<PCWSTR>(pvParameter2)));
        break;

    case SXS_DEBUG_SFC_SCANNER:
        IFW32FALSE_EXIT(SxsProtectionPerformScanNow(NULL, TRUE, TRUE));
        break;

    case SXS_DEBUG_DLL_REDIRECTION:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFW32FALSE_EXIT(::DllRedirectionTest(pszParameter1));
        break;
    case SXS_DEBUG_DIRECTORY_WATCHER:
        IFCOMFAILED_EXIT(TryWatchingDirectories());
        break;
    case SXS_DEBUG_CREAT_MULTILEVEL_DIRECTORY:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFW32FALSE_EXIT(CreateMultiLevelDirectoryTest(pszParameter1));
        break;
    case SXS_DEBUG_PROBE_MANIFST:
        //IFW32FALSE_EXIT(ManifestProbeTest());
        //IFW32FALSE_EXIT(TestSxsGeneratePath());
        IFW32FALSE_EXIT(TestCopyDirectory());
        break;
    case SXS_DEBUG_XML_PARSER:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFCOMFAILED_EXIT(::XMLParserTest(pszParameter1));
        break;
    case SXS_DEBUG_CHECK_MANIFEST_SCHEMA:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFW32FALSE_EXIT(::SxspManifestSchemaCheck(pszParameter1));
        break;
#if SXS_PRECOMPILED_MANIFESTS_ENABLED
    case SXS_DEBUG_PRECOMPILED_MANIFEST:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFCOMFAILED_EXIT(::PrecompiledManifestTest(pszParameter1));
        break;
    case SXS_DEBUG_TIME_PCM:
        PARAMETER_CHECK(pszParameter1 != NULL);
        IFCOMFAILED_EXIT(::TestPCMTime(const_cast<LPWSTR>(pszParameter1)));
        break;
#endif // SXS_PRECOMPILED_MANIFESTS_ENABLED
    case SXS_DEBUG_SET_ASSEMBLY_STORE_ROOT:
        {
            PWSTR pszTemp = NULL;
            PCWSTR pszTemp2 = NULL;

            PARAMETER_CHECK(pszParameter1 != NULL);

            // Make a copy of the input string
            IFW32FALSE_EXIT(::FusionDupString(&pszTemp, pszParameter1, ::wcslen(pszParameter1)));

            pszTemp2 = ::SxspInterlockedExchange(&g_AlternateAssemblyStoreRoot, (PCWSTR)pszTemp);
            if (pszTemp2 != NULL)
                FUSION_DELETE_ARRAY(pszTemp2);

            break;
        }
    case SXS_DEBUG_EXIT_PROCESS:
        ExitProcess(123);
        break;
    case SXS_DEBUG_TERMINATE_PROCESS:
        TerminateProcess(GetCurrentProcess(), 456);
        break;
    } // end of switch

    fSuccess = TRUE;
Exit:
    return fSuccess;
}// end of SxspDebug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsntrtl.inl ===
#pragma once

#define IS_PATH_SEPARATOR_U(ch) ((ch == L'\\') || (ch == L'/'))

inline BOOL
SxspIsSListEmpty(
    IN const SLIST_HEADER* ListHead
    )
{
#if _NTSLIST_DIRECT_
    return FirstEntrySList(ListHead) == NULL;
#else
    return RtlFirstEntrySList(ListHead) == NULL;
#endif
}

inline VOID
SxspInitializeSListHead(
    IN PSLIST_HEADER ListHead
    )
{
    RtlInitializeSListHead(ListHead);
}

inline PSLIST_ENTRY
SxspPopEntrySList(
    IN PSLIST_HEADER ListHead
    )
{
    return RtlInterlockedPopEntrySList(ListHead);
}

inline PSLIST_ENTRY
SxspInterlockedPopEntrySList(
    IN PSLIST_HEADER ListHead
    )
{
    return RtlInterlockedPopEntrySList(ListHead);
}

inline PSLIST_ENTRY
SxspInterlockedPushEntrySList(
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry
    )
{
    return RtlInterlockedPushEntrySList(ListHead, ListEntry);
}

inline RTL_PATH_TYPE
SxspDetermineDosPathNameType(
    PCWSTR DosFileName
    )
// RtlDetermineDosPathNameType_U is a bit wacky..
{
    if (   DosFileName[0] == '\\'
        && DosFileName[1] == '\\'
        && DosFileName[2] == '?'
        && DosFileName[3] == '\\'
        )
    {
/*
NTRAID#NTBUG9-591192-2002/03/31-JayKrell
path parsing issues, case mapping of "unc"
*/
        if (   (DosFileName[4] == 'u' || DosFileName[4] == 'U')
            && (DosFileName[5] == 'n' || DosFileName[5] == 'N')
            && (DosFileName[6] == 'c' || DosFileName[6] == 'C')
            &&  DosFileName[7] == '\\'
            )
        {
            return RtlPathTypeUncAbsolute;
        }
        if (DosFileName[4] != 0
            && DosFileName[5] == ':'
            && DosFileName[6] == '\\'
            )
        {
            return RtlPathTypeDriveAbsolute;
        }
    }
#if FUSION_WIN
    return RtlDetermineDosPathNameType_U(DosFileName);
#else
/*
NTRAID#NTBUG9-591192-2002/03/31-JayKrell
path parsing issues, I'm pretty sure when this code was in
unconditionally, that the FUSION_WIN build was busted..but maybe
it's actually ok now...of course this code gets no testing..
*/
    if (   IS_PATH_SEPARATOR_U(DosFileName[0])
        && IS_PATH_SEPARATOR_U(DosFileName[1])
        )
    {
        return RtlPathTypeUncAbsolute;
    }
    if (DosFileName[0] != 0
        && DosFileName[1] == ':'
        && IS_PATH_SEPARATOR_U(DosFileName[2])
        )
    {
        return RtlPathTypeDriveAbsolute;
    }
    return RtlPathTypeRelative;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsclrhelpers.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"

//
// ISSUE - 2002/05/20 - jonwis - SxsLookupClrGuid could be a little smarter - if you
//      don't pass either of the "look for class" or "look for guid" flags, it simply
//      returns NOT_FOUND, rather than INVALID_PARAMETER.  PaulKe pointed this out,
//      but notes that it doesn't really matter.  The reason it's an issue is that
//      SxsFindClrClassInformation has a similar pattern, but requires you to set
//      exactly one of its "look for" flags, and fails if none of them are set.
//

typedef CFusionArray<BYTE> CStackBackingBuffer;

#define WRITE_INTO_BUFFER(cursor, target, length, source, leftover) \
    (target) = (cursor); \
    RtlCopyMemory(cursor, source, length); \
    leftover -= (length); \
    INTERNAL_ERROR_CHECK((length % sizeof(WCHAR) == 0)); \
    (cursor) = (PWSTR)(((ULONG_PTR)(cursor)) + length); \
    *(cursor)++ = UNICODE_NULL;


BOOL
SxspLookupAssemblyIdentityInActCtx(
    HANDLE              hActCtx,
    ULONG               ulRosterIndex,
    CStringBuffer       &TargetString
    )
{
    FN_PROLOG_WIN32

    SIZE_T cbRequired = 0;
    bool fMoreSpaceRequired = false;
    CStackBackingBuffer TargetRegion;
    PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION pDetailedInfo = NULL;

    TargetString.Clear();

    IFW32FALSE_EXIT_UNLESS2(
        QueryActCtxW(
            0, 
            hActCtx, 
            (PVOID)&ulRosterIndex, 
            AssemblyDetailedInformationInActivationContext, 
            TargetRegion.GetArrayPtr(), 
            TargetRegion.GetSize(), 
            &cbRequired),
        LIST_1(ERROR_INSUFFICIENT_BUFFER),
        fMoreSpaceRequired);

    if (fMoreSpaceRequired)
    {
        IFW32FALSE_EXIT(TargetRegion.Win32SetSize(cbRequired, CStackBackingBuffer::eSetSizeModeExact));

        IFW32FALSE_EXIT(
            QueryActCtxW(
                0,
                hActCtx,
                (PVOID)&ulRosterIndex,
                AssemblyDetailedInformationInActivationContext,
                TargetRegion.GetArrayPtr(),
                TargetRegion.GetSize(),
                &cbRequired));
    }

    pDetailedInfo = (PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)TargetRegion.GetArrayPtr();
    IFW32FALSE_EXIT(TargetString.Win32Assign(
        pDetailedInfo->lpAssemblyEncodedAssemblyIdentity,
        pDetailedInfo->ulEncodedAssemblyIdentityLength / sizeof(WCHAR)));

    FN_EPILOG
}




BOOL
WINAPI
SxsFindClrClassInformation(
    DWORD       dwFlags,
    PVOID       pvSearchData,
    HANDLE      hActivationContext,
    PVOID       pvDataBuffer,
    SIZE_T      cbDataBuffer,
    PSIZE_T     pcbDataBufferWrittenOrRequired
    )
{
    FN_PROLOG_WIN32

    SIZE_T                      cbRequired = 0;
    CStringBuffer               AssemblyIdentity;
    CFusionActCtxScope          ActivationScope;
    CFusionActCtxHandle         UsedHandleDuringSearch;
    GUID                        GuidToSearch;
    ACTCTX_SECTION_KEYED_DATA   KeyedData = {sizeof(KeyedData)};
    PSXS_CLR_CLASS_INFORMATION  pOutputStruct = NULL;
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION pComServerRedirect = NULL;
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM pClrShim = NULL;
        
    if (pcbDataBufferWrittenOrRequired)
        *pcbDataBufferWrittenOrRequired = 0;

    PARAMETER_CHECK(pvSearchData != NULL);
    PARAMETER_CHECK(pvDataBuffer || (cbDataBuffer == 0));
    IFINVALID_FLAGS_EXIT_WIN32(dwFlags,
        SXS_FIND_CLR_CLASS_SEARCH_PROGID |
        SXS_FIND_CLR_CLASS_SEARCH_GUID |
        SXS_FIND_CLR_CLASS_ACTIVATE_ACTCTX |
        SXS_FIND_CLR_CLASS_GET_IDENTITY |
        SXS_FIND_CLR_CLASS_GET_PROGID |
        SXS_FIND_CLR_CLASS_GET_RUNTIME_VERSION |
        SXS_FIND_CLR_CLASS_GET_TYPE_NAME);

    //
    // Can't be both... I'm sure there's a logic thing I could do smarter here, but ohwell.
    //
    if ((dwFlags & SXS_FIND_CLR_CLASS_SEARCH_PROGID) && (dwFlags & SXS_FIND_CLR_CLASS_SEARCH_GUID))
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(CantSearchBothProgidAndGuid, ERROR_INVALID_PARAMETER);
    }
    // But it has to be at least one of these.
    //
    else if ((dwFlags & (SXS_FIND_CLR_CLASS_SEARCH_PROGID | SXS_FIND_CLR_CLASS_SEARCH_GUID)) == 0)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(MustHaveAtLeastOneSearchTypeSet, ERROR_INVALID_PARAMETER);
    }

    //

    //
    // Activate if necessary
    //
    if (dwFlags & SXS_FIND_CLR_CLASS_ACTIVATE_ACTCTX)
    {
        IFW32FALSE_EXIT(ActivationScope.Win32Activate(hActivationContext));
        AddRefActCtx(hActivationContext);
        UsedHandleDuringSearch = hActivationContext;
    }
    else
    {
        IFW32FALSE_EXIT(GetCurrentActCtx(&UsedHandleDuringSearch));
    }

    //
    // Aha, they wanted a progid search
    //
    if (dwFlags & SXS_FIND_CLR_CLASS_SEARCH_PROGID)
    {
        PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION pProgidFound = NULL;
        
        IFW32FALSE_EXIT(
            FindActCtxSectionStringW(
                0, 
                NULL, 
                ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION, 
                (LPCWSTR)pvSearchData, 
                &KeyedData));

        pProgidFound = (PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION)KeyedData.lpData;
        GuidToSearch = *(LPGUID)(((ULONG_PTR)KeyedData.lpSectionBase) + pProgidFound->ConfiguredClsidOffset);
    }
    //
    // They handed us a GUID instead
    //
    else if (dwFlags & SXS_FIND_CLR_CLASS_SEARCH_GUID)
    {
        GuidToSearch = *(LPGUID)pvSearchData;
    }
    // Hmm.. we validated these flags above, how could we possibly get here?
    //
    else
    {
        INTERNAL_ERROR_CHECK(FALSE);
    }

    //

    //
    // Now that we've got the guids, let's look in the GUID clr class table for more information
    //
    RtlZeroMemory(&KeyedData, sizeof(KeyedData));
    KeyedData.cbSize = sizeof(KeyedData);
    IFW32FALSE_EXIT(
        FindActCtxSectionGuid(
            0,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION,
            &GuidToSearch,
            &KeyedData));

    pComServerRedirect = (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)KeyedData.lpData;

    //
    // What do we want to do here if you've asked for a CLR class and yet there's no surrogate
    // information??
    //
    if (pComServerRedirect->ShimDataOffset == 0)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(ThisGuidIsNotAClrClass, ERROR_SXS_KEY_NOT_FOUND);
    }

    pClrShim = (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM)(((ULONG_PTR)pComServerRedirect) + pComServerRedirect->ShimDataOffset);

    //
    // Now we've got all the stuff we need.  Calculate the required size of things.
    //
    cbRequired = sizeof(SXS_CLR_CLASS_INFORMATION);
    
    if ((dwFlags & SXS_FIND_CLR_CLASS_GET_PROGID) && (pComServerRedirect->ProgIdLength > 0))
        cbRequired += pComServerRedirect->ProgIdLength + sizeof(WCHAR);

    if (dwFlags & SXS_FIND_CLR_CLASS_GET_IDENTITY)
    {
        IFW32FALSE_EXIT(
            SxspLookupAssemblyIdentityInActCtx(
                UsedHandleDuringSearch, 
                KeyedData.ulAssemblyRosterIndex, 
                AssemblyIdentity));

        if (AssemblyIdentity.Cch() > 0) {
            cbRequired += (AssemblyIdentity.Cch() + 1) * sizeof(WCHAR);
        }
    }

    if ((dwFlags & SXS_FIND_CLR_CLASS_GET_RUNTIME_VERSION) && (pClrShim->ShimVersionLength > 0))
        cbRequired += pClrShim->ShimVersionLength + sizeof(WCHAR);

    if ((dwFlags & SXS_FIND_CLR_CLASS_GET_TYPE_NAME) && (pClrShim->TypeLength > 0))
        cbRequired += pClrShim->TypeLength + sizeof(WCHAR);

    //
    // Is there enough space in the outbound buffer?
    //    
    if (cbRequired <= cbDataBuffer)
    {        
        PWSTR pwszCursor;
        SIZE_T cbRemaining = cbDataBuffer;

        pOutputStruct = (PSXS_CLR_CLASS_INFORMATION)pvDataBuffer;
        pwszCursor = (PWSTR)(pOutputStruct + 1);
        cbRemaining -= sizeof(SXS_CLR_CLASS_INFORMATION);

        pOutputStruct->ReferenceClsid = pComServerRedirect->ReferenceClsid;
        pOutputStruct->dwFlags = 0;
        pOutputStruct->dwSize = sizeof(*pOutputStruct);
        pOutputStruct->ulThreadingModel = pComServerRedirect->ThreadingModel;
        pOutputStruct->ulType = pClrShim->Type;

        if (dwFlags & SXS_FIND_CLR_CLASS_GET_IDENTITY)
        {
            SIZE_T cbWritten;
            pOutputStruct->pcwszImplementingAssembly = pwszCursor;
            
            IFW32FALSE_EXIT(
                AssemblyIdentity.Win32CopyIntoBuffer(
                    &pwszCursor, 
                    &cbRemaining, 
                    &cbWritten, 
                    NULL, 
                    NULL, 
                    NULL));
        }
        else
            pOutputStruct->pcwszImplementingAssembly = NULL;

        if (dwFlags & SXS_FIND_CLR_CLASS_GET_PROGID)
        {
            WRITE_INTO_BUFFER(
                pwszCursor, 
                pOutputStruct->pcwszProgId, 
                pComServerRedirect->ProgIdLength, 
                (PVOID)(((ULONG_PTR)pComServerRedirect) + pComServerRedirect->ProgIdOffset),
                cbRemaining);
        }
        else
            pOutputStruct->pcwszProgId = NULL;


        if (dwFlags & SXS_FIND_CLR_CLASS_GET_RUNTIME_VERSION)
        {
            WRITE_INTO_BUFFER(
                pwszCursor, 
                pOutputStruct->pcwszRuntimeVersion, 
                pClrShim->ShimVersionLength, 
                (PVOID)(((ULONG_PTR)pClrShim) + pClrShim->ShimVersionOffset),
                cbRemaining);
        }
        else
            pOutputStruct->pcwszRuntimeVersion = NULL;

        if (dwFlags & SXS_FIND_CLR_CLASS_GET_TYPE_NAME)
        {
            WRITE_INTO_BUFFER(
                pwszCursor, 
                pOutputStruct->pcwszTypeName, 
                pClrShim->TypeLength, 
                (PVOID)(((ULONG_PTR)pClrShim) + pClrShim->TypeOffset),
                cbRemaining);
        }
        else
            pOutputStruct->pcwszTypeName = NULL;

        if (pcbDataBufferWrittenOrRequired)
            *pcbDataBufferWrittenOrRequired = cbRequired;
    }
    else
    {
        if (pcbDataBufferWrittenOrRequired)
            *pcbDataBufferWrittenOrRequired = cbRequired;
        ORIGINATE_WIN32_FAILURE_AND_EXIT(NotEnoughSpaceInOutboundBuffer, ERROR_INSUFFICIENT_BUFFER);
    }
    
    FN_EPILOG
}
    



BOOL
WINAPI
SxsFindClrSurrogateInformation(
    DWORD       dwFlags,
    LPGUID      lpGuidToFind,
    HANDLE      hActivationContext,
    PVOID       pvDataBuffer,
    SIZE_T      cbDataBuffer,
    PSIZE_T     pcbDataBufferWrittenOrRequired
    )
{
    FN_PROLOG_WIN32

    SIZE_T cbRequired = 0;
    PSXS_CLR_SURROGATE_INFORMATION pOutputStruct = NULL;
    PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE pSurrogateInfo = NULL;
    ACTCTX_SECTION_KEYED_DATA KeyedData = {sizeof(KeyedData)};
    CFusionActCtxScope ActCtxScope;
    CFusionActCtxHandle UsedActivationContext;
    CStringBuffer AssemblyIdentity;

    if (pcbDataBufferWrittenOrRequired != NULL)
        *pcbDataBufferWrittenOrRequired = 0;

    //
    // The data buffer has to be present, or the data buffer size has to be zero,
    // and the written-or-required value must be present as well.
    //
    PARAMETER_CHECK(lpGuidToFind != NULL);
    PARAMETER_CHECK(pvDataBuffer || (cbDataBuffer == 0));
    IFINVALID_FLAGS_EXIT_WIN32(dwFlags, 
        SXS_FIND_CLR_SURROGATE_USE_ACTCTX |
        SXS_FIND_CLR_SURROGATE_GET_IDENTITY |
        SXS_FIND_CLR_SURROGATE_GET_RUNTIME_VERSION |
        SXS_FIND_CLR_SURROGATE_GET_TYPE_NAME);

    //
    // Steps we take here:
    // - Activate the actctx if required.
    // - Find the surrogate that corresponds to this progid
    // - Calculate required size of data
    // - If there's enough space, then start copying into the output blob
    // - Otherwise, set the "required" size and error out with ERROR_INSUFFICIENT_BUFFER
    //


    //
    // If we were told to use the actctx, then activate it over this function,
    // and get a reference to it into UsedActivationContext so we can query with
    // it later.
    //
    if (dwFlags & SXS_FIND_CLR_SURROGATE_USE_ACTCTX)
    {
        IFW32FALSE_EXIT(ActCtxScope.Win32Activate(hActivationContext));
        AddRefActCtx(hActivationContext);
        UsedActivationContext = hActivationContext;
    }
    //
    // Otherwise, grab the current actctx and go to town.  This addrefs the activation
    // context, so we can let UsedActivationContext's destructor release it on the
    // exit path.
    //
    else 
    {
        IFW32FALSE_EXIT(GetCurrentActCtx(&UsedActivationContext));
    }

    //
    // Initially, we require at least this amount of space.
    //
    cbRequired += sizeof(SXS_CLR_SURROGATE_INFORMATION);
    IFW32FALSE_EXIT(
        FindActCtxSectionGuid(
            0, 
            NULL, 
            ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES, 
            lpGuidToFind, 
            &KeyedData));
    
    //
    // Start totalling up the size
    //
    pSurrogateInfo = (PCACTIVATION_CONTEXT_DATA_CLR_SURROGATE)KeyedData.lpData;

    if ((dwFlags & SXS_FIND_CLR_SURROGATE_GET_TYPE_NAME) && (pSurrogateInfo->TypeNameLength > 0))
        cbRequired += pSurrogateInfo->TypeNameLength + sizeof(WCHAR);

    if ((dwFlags & SXS_FIND_CLR_SURROGATE_GET_RUNTIME_VERSION) && (pSurrogateInfo->VersionLength > 0))
        cbRequired += pSurrogateInfo->VersionLength + sizeof(WCHAR);

    if (dwFlags & SXS_FIND_CLR_SURROGATE_GET_IDENTITY)
    {
        IFW32FALSE_EXIT(
            SxspLookupAssemblyIdentityInActCtx(
                UsedActivationContext, 
                KeyedData.ulAssemblyRosterIndex, 
                AssemblyIdentity));

        if (AssemblyIdentity.Cch() > 0) 
        {
            cbRequired += (AssemblyIdentity.Cch() + 1) * sizeof(WCHAR);
        }
    }

    //
    // Go stomp the gathered data into the right places
    //
    if (cbRequired <= cbDataBuffer)
    {
        PWSTR pwszOutputCursor;
        SIZE_T cbRemaining = cbDataBuffer;
        SIZE_T cbWritten = 0;
        
        pOutputStruct = (PSXS_CLR_SURROGATE_INFORMATION)pvDataBuffer;
        pwszOutputCursor = (PWSTR)(pOutputStruct + 1);
        
        pOutputStruct->cbSize = sizeof(SXS_CLR_SURROGATE_INFORMATION);
        pOutputStruct->dwFlags = 0;
        pOutputStruct->SurrogateIdent = pSurrogateInfo->SurrogateIdent;

        //
        // Write things into the output buffer
        //
        if ((dwFlags & SXS_FIND_CLR_SURROGATE_GET_IDENTITY) && (AssemblyIdentity.Cch() > 0))
        {
            pOutputStruct->pcwszImplementingAssembly = pwszOutputCursor;
            
            IFW32FALSE_EXIT(
                AssemblyIdentity.Win32CopyIntoBuffer(
                    &pwszOutputCursor,
                    &cbRemaining,
                    &cbWritten,
                    NULL, NULL, NULL));                
        }
        else
            pOutputStruct->pcwszImplementingAssembly = NULL;


        if (dwFlags & SXS_FIND_CLR_SURROGATE_GET_TYPE_NAME)
        {
            WRITE_INTO_BUFFER(
                pwszOutputCursor,
                pOutputStruct->pcwszSurrogateType,
                pSurrogateInfo->TypeNameLength,
                (PVOID)(((ULONG_PTR)pSurrogateInfo) + pSurrogateInfo->TypeNameOffset),
                cbRemaining);
        }
        else
            pOutputStruct->pcwszSurrogateType = NULL;

        if (dwFlags & SXS_FIND_CLR_SURROGATE_GET_RUNTIME_VERSION)
        {
            WRITE_INTO_BUFFER(
                pwszOutputCursor,
                pOutputStruct->pcwszRuntimeVersion,
                pSurrogateInfo->VersionLength,
                (PVOID)(((ULONG_PTR)pSurrogateInfo) + pSurrogateInfo->VersionOffset),
                cbRemaining);
        }
        else
            pOutputStruct->pcwszRuntimeVersion = NULL;

        if (pcbDataBufferWrittenOrRequired)
            *pcbDataBufferWrittenOrRequired = cbRequired;

    }
    else
    {
        if (pcbDataBufferWrittenOrRequired)
            *pcbDataBufferWrittenOrRequired = cbRequired;

        ORIGINATE_WIN32_FAILURE_AND_EXIT(NotEnoughSpaceInOutputBuffer, ERROR_INSUFFICIENT_BUFFER);
    }

    FN_EPILOG
}


BOOL
WINAPI
SxsLookupClrGuid(
    DWORD       dwFlags,
    LPGUID      pClsid,
    HANDLE      hActCtx,
    PVOID       pvOutputBuffer,
    SIZE_T      cbOutputBuffer,
    PSIZE_T     pcbOutputBuffer
    )
{
    FN_PROLOG_WIN32

    if (pcbOutputBuffer)
        *pcbOutputBuffer = 0;

    CStackBackingBuffer BackingBuffer;
    DWORD dwLastError;
    SIZE_T cbRequired = 0;
    PSXS_GUID_INFORMATION_CLR pOutputTarget = NULL;
    PCWSTR pcwszRuntimeVersion = NULL;
    PCWSTR pcwszTypeName = NULL;
    PCWSTR pcwszAssemblyName = NULL;
    SIZE_T cchRuntimeVersion = 0;
    SIZE_T cchTypeName = 0;
    SIZE_T cchAssemblyName = 0;

    enum {
        eFoundSurrogate,
        eFoundClrClass,
        eNotFound
    } FoundThingType = eNotFound;

    PARAMETER_CHECK(pvOutputBuffer || (cbOutputBuffer == 0));
    PARAMETER_CHECK(pClsid != NULL);
    IFINVALID_FLAGS_EXIT_WIN32(dwFlags, 
        SXS_LOOKUP_CLR_GUID_USE_ACTCTX |
        SXS_LOOKUP_CLR_GUID_FIND_SURROGATE |
        SXS_LOOKUP_CLR_GUID_FIND_CLR_CLASS |
        SXS_LOOKUP_CLR_GUID_FIND_ANY);
    //
    // Nothing found yet, let's look into the surrogate data tables first
    //
    if ((FoundThingType == eNotFound) && ((dwFlags & SXS_LOOKUP_CLR_GUID_FIND_SURROGATE) != 0))
    {
        IFW32FALSE_EXIT_UNLESS3(
            SxsFindClrSurrogateInformation(
                SXS_FIND_CLR_SURROGATE_GET_ALL | ((dwFlags & SXS_LOOKUP_CLR_GUID_USE_ACTCTX) ? SXS_FIND_CLR_SURROGATE_USE_ACTCTX : 0),
                pClsid,
                hActCtx,
                BackingBuffer.GetArrayPtr(),
                BackingBuffer.GetSize(),
                &cbRequired),
            LIST_3(ERROR_SXS_SECTION_NOT_FOUND, ERROR_SXS_KEY_NOT_FOUND, ERROR_INSUFFICIENT_BUFFER),
            dwLastError);

        //
        // If we found the key and section, but the buffer was too small, resize and try again
        //
        if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {
            IFW32FALSE_EXIT(BackingBuffer.Win32SetSize(cbRequired, CStackBackingBuffer::eSetSizeModeExact));

            IFW32FALSE_EXIT_UNLESS3(
                SxsFindClrSurrogateInformation(
                    SXS_FIND_CLR_SURROGATE_GET_ALL | ((dwFlags & SXS_LOOKUP_CLR_GUID_USE_ACTCTX) ? SXS_FIND_CLR_SURROGATE_USE_ACTCTX : 0),
                    pClsid,
                    hActCtx,
                    BackingBuffer.GetArrayPtr(),
                    BackingBuffer.GetSize(),
                    &cbRequired),
                LIST_2(ERROR_SXS_SECTION_NOT_FOUND, ERROR_SXS_KEY_NOT_FOUND),
                dwLastError);
        }

        //
        // Great - we either succeeded during the first call, or we succeeded after
        // resizing our buffers.  Gather information, set the type, and continue.
        //
        if (dwLastError == ERROR_SUCCESS)
        {
            //
            // At this point, BackingBuffer contains goop about a CLR surrogate.  Ensure that
            // our output buffer is large enough, and then fill it out.
            //
            PCSXS_CLR_SURROGATE_INFORMATION pSurrogateInfo = 
                (PCSXS_CLR_SURROGATE_INFORMATION)BackingBuffer.GetArrayPtr();
            
            pcwszAssemblyName = pSurrogateInfo->pcwszImplementingAssembly;
            pcwszTypeName = pSurrogateInfo->pcwszSurrogateType;
            pcwszRuntimeVersion = pSurrogateInfo->pcwszRuntimeVersion;
            FoundThingType = eFoundSurrogate;
        }
    }

    //
    // We've yet to find anything, and the flags say we can look up a clr class
    //
    if ((FoundThingType == eNotFound) && ((dwFlags & SXS_LOOKUP_CLR_GUID_FIND_CLR_CLASS) != 0))
    {
        IFW32FALSE_EXIT_UNLESS3(
            SxsFindClrClassInformation(
                SXS_FIND_CLR_CLASS_SEARCH_GUID | SXS_FIND_CLR_CLASS_GET_ALL | ((dwFlags & SXS_LOOKUP_CLR_GUID_USE_ACTCTX) ? SXS_FIND_CLR_CLASS_ACTIVATE_ACTCTX : 0),
                (PVOID)pClsid,
                hActCtx,
                BackingBuffer.GetArrayPtr(),
                BackingBuffer.GetSize(),
                &cbRequired),
            LIST_3(ERROR_INSUFFICIENT_BUFFER, ERROR_SXS_SECTION_NOT_FOUND, ERROR_SXS_KEY_NOT_FOUND),
            dwLastError);

        if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {
            IFW32FALSE_EXIT(BackingBuffer.Win32SetSize(cbRequired, CStackBackingBuffer::eSetSizeModeExact));

            IFW32FALSE_EXIT_UNLESS3(
                SxsFindClrClassInformation(
                    SXS_FIND_CLR_CLASS_SEARCH_GUID | SXS_FIND_CLR_CLASS_GET_ALL | ((dwFlags & SXS_LOOKUP_CLR_GUID_USE_ACTCTX) ? SXS_FIND_CLR_CLASS_ACTIVATE_ACTCTX : 0),
                    (PVOID)pClsid,
                    hActCtx,
                    BackingBuffer.GetArrayPtr(),
                    BackingBuffer.GetSize(),
                    &cbRequired),
                LIST_2(ERROR_SXS_SECTION_NOT_FOUND, ERROR_SXS_KEY_NOT_FOUND),
                dwLastError);            
        }

        //
        // We succeeded, either after the first query, or after resizing.
        //
        if (dwLastError == ERROR_SUCCESS)
        {
            PCSXS_CLR_CLASS_INFORMATION pClassInfo = 
                (PCSXS_CLR_CLASS_INFORMATION)BackingBuffer.GetArrayPtr();
            FoundThingType = eFoundClrClass;
            pcwszAssemblyName = pClassInfo->pcwszImplementingAssembly;
            pcwszRuntimeVersion = pClassInfo->pcwszRuntimeVersion;
            pcwszTypeName = pClassInfo->pcwszTypeName;
        }
    }
    
    //
    // If we got to this point and didn't find anything, then error out with a reasonable
    // error code.
    //
    if (FoundThingType == eNotFound)
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(DidntFindObject, ERROR_NOT_FOUND);
    }

    //
    // Calculate some sizes - string lengths, etc.
    //
    cbRequired = sizeof(SXS_GUID_INFORMATION_CLR);
    cchAssemblyName = StringLength(pcwszAssemblyName);
    cchRuntimeVersion = StringLength(pcwszRuntimeVersion);
    cchTypeName = StringLength(pcwszTypeName);
    cbRequired += (cchAssemblyName + cchRuntimeVersion + cchTypeName + 3) * sizeof(WCHAR);

    //
    // If there was enough space, start stomping data into the output buffer
    //
    if (cbRequired <= cbOutputBuffer)
    {
        PWSTR pwszCursor;
        pOutputTarget = (PSXS_GUID_INFORMATION_CLR)pvOutputBuffer;
        pwszCursor = (PWSTR)(pOutputTarget + 1);

        pOutputTarget->cbSize = sizeof(*pOutputTarget);
        pOutputTarget->dwFlags = 0;

        switch (FoundThingType) {
        case eFoundClrClass: 
            pOutputTarget->dwFlags |= SXS_GUID_INFORMATION_CLR_FLAG_IS_CLASS; 
            break;
        case eFoundSurrogate: 
            pOutputTarget->dwFlags |= SXS_GUID_INFORMATION_CLR_FLAG_IS_SURROGATE; 
            break;
        default:
            INTERNAL_ERROR_CHECK(FALSE);
            break;
        }

        //
        // This grossness is unfortunately required.
        //
        pOutputTarget->pcwszAssemblyIdentity = pwszCursor;
        wcscpy(pwszCursor, pcwszAssemblyName);
        pwszCursor += cchAssemblyName + 1;

        pOutputTarget->pcwszRuntimeVersion= pwszCursor;
        wcscpy(pwszCursor, pcwszRuntimeVersion);
        pwszCursor += cchRuntimeVersion+ 1;

        pOutputTarget->pcwszTypeName = pwszCursor;
        wcscpy(pwszCursor, pcwszTypeName);
        pwszCursor += cchTypeName + 1;

        if (pcbOutputBuffer)
            *pcbOutputBuffer = cbRequired;

    }
    else
    {
        if (pcbOutputBuffer)
            *pcbOutputBuffer = cbRequired;

        ORIGINATE_WIN32_FAILURE_AND_EXIT(NotEnoughSpaceInOutputBuffer, ERROR_INSUFFICIENT_BUFFER);
    }
    
    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsinstall.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsinstall.cpp

Abstract:

    Installation support

Author:

    Jay Krell (a-JayK, JayKrell) April 2000

Revision History:

--*/
#include "stdinc.h"
#include "sxsp.h"
#include "nodefactory.h"
#include "fusionarray.h"
#include "sxsinstall.h"
#include "sxspath.h"
#include "recover.h"
#include "cassemblyrecoveryinfo.h"
#include "sxsexceptionhandling.h"
#include "npapi.h"
#include "util.h"
#include "idp.h"
#include "sxscabinet.h"
#include "fusionprintf.h"

#if DBG
BOOL g_SxsOfflineInstall;
#else
#define g_SxsOfflineInstall FALSE
#endif

#define SXS_LANG_DEFAULT     (MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT)) // "0x0409"

BOOL
WINAPI
SxspInstallCallbackSetupCopyQueue(
    PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS
    );

BOOL
WINAPI
SxspInstallCallbackSetupCopyQueueEx(
    PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS
    );

CAssemblyInstall::CAssemblyInstall()
:
m_pInstallInfo(NULL),
m_bSuccessfulSoFar(TRUE)
{
}

BOOL
CAssemblyInstall::BeginAssemblyInstall(
    DWORD dwManifestOperationFlags,
    PSXS_INSTALLATION_FILE_COPY_CALLBACK installationCallback,
    PVOID  installationContext,
    const CImpersonationData &ImpersonationData
    )
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK((installationCallback != NULL) || (installationContext == NULL));

    // check for the "built in" ones, translate from bogus PFN values (1, 2, etc.)
    // to real functions
    if (installationCallback == SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE)
    {
        PARAMETER_CHECK(installationContext != NULL);
        installationCallback = SxspInstallCallbackSetupCopyQueue;
        // we can't verify that this is a valid setup copy queue..
    }
    else if (installationCallback == SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE_EX)
    {
        PCSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS typedContext =
            reinterpret_cast<PCSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS>(installationContext);

        PARAMETER_CHECK(installationContext != NULL);
        PARAMETER_CHECK(typedContext->cbSize >= sizeof(SXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS));
        installationCallback = SxspInstallCallbackSetupCopyQueueEx;
    }

    m_ImpersonationData = ImpersonationData;

    IFW32FALSE_EXIT(
        ::SxspInitActCtxGenCtx(
            &m_ActCtxGenCtx,              // context out
            MANIFEST_OPERATION_INSTALL,
            0,
            dwManifestOperationFlags,
            ImpersonationData,
            0,                          // processor architecture
            //0                         // langid
            SXS_LANG_DEFAULT,         // langid "0x0409"
            ACTIVATION_CONTEXT_PATH_TYPE_NONE,
            0,
            NULL));

    //
    // Oh where oh where did our call-back go? Oh where, oh where could it be?
    //
    m_ActCtxGenCtx.m_InstallationContext.Callback = installationCallback;
    m_ActCtxGenCtx.m_InstallationContext.Context = installationContext;

    fSuccess = TRUE;
Exit:
    m_bSuccessfulSoFar = m_bSuccessfulSoFar && fSuccess;

    return fSuccess;
}


class CInstallDirectoryDirWalkContext
{
public:
    CAssemblyInstall* m_pThis;
    DWORD             m_dwManifestOperationFlags;
};

CDirWalk::ECallbackResult
CAssemblyInstall::InstallDirectoryDirWalkCallback(
    CDirWalk::ECallbackReason  reason,
    CDirWalk*                  dirWalk,
    DWORD                      dwManifestOperationFlags,
    DWORD                      dwWalkDirFlags
    )
{
#if DBG
#define SET_LINE() Line = __LINE__
    ULONG Line = __LINE__;
#else
#define SET_LINE() /* nothing */
#endif

    CDirWalk::ECallbackResult result = CDirWalk::eKeepWalking;

    //
    // We short circuit more code by doing this up front rather
    // waiting for a directory notification; it'd be even quicker
    // if we could seed the value in CDirWalk, but we can't.
    //
    // actually, what we could do is turn off all file walking
    // by returning eStopWalkingFiles at every directory notification,
    // and and at each directory notification, try the exactly three
    // file names we accept
    //
    if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE) == 0)
    {
        result = CDirWalk::eStopWalkingDirectories;
    }

    if (reason == CDirWalk::eBeginDirectory)
    {
        // Prepend a / only if the current path is non-blank - otherwise, just prepend the
        // path element.
        if (m_buffCodebaseRelativePath.Cch() != 0)
        {
            if (!m_buffCodebaseRelativePath.Win32Append(m_wchCodebasePathSeparator))
            {
                TRACE_WIN32_FAILURE(m_buffCodebaseRelativePath.Win32Append);
                SET_LINE();
                goto Error;
            }
        }

        if (!m_buffCodebaseRelativePath.Win32Append(dirWalk->m_strLastObjectFound))
        {
            TRACE_WIN32_FAILURE(m_buffCodebaseRelativePath.Win32Append);
            SET_LINE();
            goto Error;
        }
    }
    else if (reason == CDirWalk::eFile)
    {
        //
        // the manifest must be in a file whose base name matches its
        // directory's base name, otherwise ignore it and keep going
        //
        // inefficient, but reusing code.

        // check whether this is a catalog file, if so, we would not install it
        {
            PWSTR p = wcsrchr(dirWalk->m_strLastObjectFound, L'.');
            if (p != NULL)
            {
                SIZE_T x = ::wcslen(p);
                if (::FusionpCompareStrings(p, x, (x == 4)? L".cat" : L".catalog", (x == 4)? 4 : 8, true) == 0)
                {
                    SET_LINE();
                    goto Exit;
                }
            }
        }

        {
            CFullPathSplitPointers splitParent;
            CFullPathSplitPointers splitChild;
            CSmallStringBuffer     child;
            CSmallStringBuffer     buffChildCodebase;

            //
            // OS installations get some special treatment.
            //
            if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_OSSETUP) && (!(dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_MIGRATION)))
            {
            
                CSmallStringBuffer     buffParentWorker;
                CSmallStringBuffer     buffChunklet;

                //
                // If this is an OS-installation, then we need the last two bits of
                // the parent path.  So if we were walking "C:\$win_nt$.~ls\i386\asms", we need
                // the "i386\asms" part out of that.  So we'll generate this differently.
                //
                if (!buffParentWorker.Win32Assign(dirWalk->m_strParent, dirWalk->m_cchOriginalPath)) 
                {
                    SET_LINE();
                    goto Error;
                }

                if (!buffParentWorker.Win32RemoveTrailingPathSeparators())
                {
                    SET_LINE();
                    goto Error;
                }

                //
                // For now, take at most the last two items off the thing.
                //
                for ( ULONG ulItems = 0; (ulItems < 2) && (buffParentWorker.Cch() > 0); ulItems++ )
                {
                    CSmallStringBuffer buffChunklet;

                    if (( ulItems != 0 ) && (!buffChildCodebase.Win32Prepend(m_wchCodebasePathSeparator)))
                    {
                        SET_LINE();
                        goto Error;
                    }
                    
                    if (!buffParentWorker.Win32GetLastPathElement(buffChunklet))
                    {
                        SET_LINE();
                        goto Error;
                    }
                    if (!buffChildCodebase.Win32Prepend(buffChunklet))
                    {
                        SET_LINE();
                        goto Error;
                    }
                    if (!buffParentWorker.Win32RemoveLastPathElement())
                    {
                        SET_LINE();
                        goto Error;
                    }
                }

                if (!buffChildCodebase.Win32Append(m_wchCodebasePathSeparator))
                {
                    SET_LINE();
                    goto Exit;
                }
                if (!buffChildCodebase.Win32Append(m_buffCodebaseRelativePath))
                {
                    SET_LINE();
                    goto Exit;
                }
            }
            else
            {
                if (!buffChildCodebase.Win32Assign(m_buffCodebaseRelativePath))
                {
                    SET_LINE();
                    goto Error;
                }
            }
            if (!buffChildCodebase.Win32Append(m_wchCodebasePathSeparator))
            {
                SET_LINE();
                goto Error;
            }
            if (!buffChildCodebase.Win32Append(dirWalk->m_strLastObjectFound))
            {
                SET_LINE();
                goto Error;
            }
            if (!child.Win32Assign(dirWalk->m_strParent))
            {
                SET_LINE();
                goto Error;
            }
            if (!child.Win32AppendPathElement(dirWalk->m_strLastObjectFound))
            {
                SET_LINE();
                goto Error;
            }
            if (!splitParent.Initialize(dirWalk->m_strParent))
            {
                SET_LINE();
                goto Error;
            }
            if (!splitChild.Initialize(child))
            {
                SET_LINE();
                goto Error;
            }

            //
            // Note - we can't just compare bases, as the 'base' of the directory
            // path "c:\foo\bar.bas" is "bar", while the base of the file
            // "c:\foo\bar.bas\bar.bas.man" is "bar.bas"  So, we need to compare
            // the 'name' parent path (foo.bar) with the base of the child path
            // (foo.bar)
            //
            if (!::FusionpEqualStrings(
                    splitChild.m_base, 
                    splitChild.m_baseEnd - splitChild.m_base, 
                    splitParent.m_name, 
                    StringLength(splitParent.m_name),
                    true))
            {
                SET_LINE();
                goto Exit;
            }

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INSTALLATION,
                "SXS.DLL: Installing file \"%S\"\n", static_cast<PCWSTR>(child));

            if (!this->InstallFile(child, buffChildCodebase))
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_SETUPLOG,
                    "Failed to install assembly from manifest: \"%S\"; Win32 Error Code = %lu\n", static_cast<PCWSTR>(child), ::GetLastError());

                //
                // If it was .man or .manifest, then it must be a manifest else error.
                //
                // If it was .dll, well, arbitrary .dlls don't necessarily contain
                // manifests, but we already look for .man and .manifest and this
                // .dll's base name matches its directory's name, so this is also
                // an error.
                //
                result = CDirWalk::eError;

                SET_LINE();
                goto Exit;
            }
        }

        //
        // we have a manifest in this directory, don't look for any manifests
        // in this directory or any of its children
        //
        // if we want to enforce one manifest per directory, then we'd have
        // to keep walking, or actually do a two pass in order to not install
        // when we would error later
        //
        result = (CDirWalk::eStopWalkingFiles | CDirWalk::eStopWalkingDirectories);
        SET_LINE();
        goto Exit;
    }
    else if (reason == CDirWalk::eEndDirectory)
    {
        // Trim back to the previous codebase path separator...
        PCWSTR pszPathSeparator = wcsrchr(m_buffCodebaseRelativePath, m_wchCodebasePathSeparator);
        if (pszPathSeparator != NULL)
            m_buffCodebaseRelativePath.Left(pszPathSeparator - m_buffCodebaseRelativePath);
        else
        {   // It's just one path element.
            m_buffCodebaseRelativePath.Clear();
        }

        //
        // find at least one file under the dir, however, no manifest available, this is an error case
        //
        if (((dwWalkDirFlags & SXSP_DIR_WALK_FLAGS_FIND_AT_LEAST_ONE_FILEUNDER_CURRENTDIR) != 0) &&
            ((dwWalkDirFlags & SXSP_DIR_WALK_FLAGS_INSTALL_ASSEMBLY_UNDER_CURRECTDIR_SUCCEED) == 0))
        {
            ::FusionpLogError(
                MSG_SXS_MANIFEST_MISSING_DURING_SETUP,
                 CEventLogString(dirWalk->m_strParent));  // this would log error to Setup.log if it is during setup
            SET_LINE();
            result |= CDirWalk::eError;
        }
    }
#if DBG
    if (Line == 0)
        SET_LINE();
#endif
Exit:
#if DBG
    if ((result & CDirWalk::eError) != 0)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "%s(%lu): %s\n", __FILE__, Line, __FUNCTION__);
    }
#endif
    return result;
Error:
    result = CDirWalk::eError;
    goto Exit;
#undef SET_LINE
}

CDirWalk::ECallbackResult
CAssemblyInstall::StaticInstallDirectoryDirWalkCallback(
    CDirWalk::ECallbackReason   reason,
    CDirWalk*                   dirWalk,
    DWORD                       dwWalkDirFlags
    )
{
    FN_TRACE();

    ASSERT(dirWalk != NULL);
    CInstallDirectoryDirWalkContext* context = reinterpret_cast<CInstallDirectoryDirWalkContext*>(dirWalk->m_context);
    CDirWalk::ECallbackResult result = context->m_pThis->InstallDirectoryDirWalkCallback(reason, dirWalk, context->m_dwManifestOperationFlags, dwWalkDirFlags);
    return result;
}

BOOL
CAssemblyInstall::InstallDirectory(
    const CBaseStringBuffer &rbuffPath,
    DWORD          dwFlags,
    WCHAR wchCodebasePathSeparator
    )
{
/*
NTRAID#NTBUG9-591148-2002/03/31-JayKrell
This function can recurse indefinitely, running out of stack and crashing,
including in msiexec.exe. Is this ok?
*/
    FN_PROLOG_WIN32

#define COMMA ,
    const static PCWSTR filters[] = {L"*" INSTALL_MANIFEST_FILE_NAME_SUFFIXES(COMMA L"*") };
#undef COMMA

    CDirWalk dirWalk;
    CInstallDirectoryDirWalkContext context = { this, dwFlags };

    m_wchCodebasePathSeparator = wchCodebasePathSeparator;
    m_buffCodebaseRelativePath.Clear();

    dirWalk.m_fileFiltersBegin = filters;
    dirWalk.m_fileFiltersEnd   = filters + NUMBER_OF(filters);
    dirWalk.m_context = &context;
    dirWalk.m_callback = StaticInstallDirectoryDirWalkCallback;
    IFW32FALSE_EXIT(dirWalk.m_strParent.Win32Assign(rbuffPath));
    IFW32FALSE_EXIT(dirWalk.m_strParent.Win32RemoveTrailingPathSeparators());
    IFW32FALSE_EXIT(dirWalk.Walk());

    FN_EPILOG
}



BOOL
SxspGenerateInstallationInfo(
    IN OUT CAssemblyRecoveryInfo &rRecovery,
    IN const CBaseStringBuffer &rbuffManifestSourcePath,
    IN const CBaseStringBuffer &rbuffRelativeCodebasePath,
    IN PCSXS_INSTALL_SOURCE_INFO pInstallInfo,
    IN PCWSTR pcwszAssemblyRoot,
    IN SIZE_T cchAssemblyRoot,
    IN const ASSEMBLY *pAssemblyInfo,
    OUT CCodebaseInformation &rCodebaseInfo
    )
{
    FN_PROLOG_WIN32

    BOOL fHasCatalog = FALSE;
    CSmallStringBuffer buffAssemblyDirName;
    CSmallStringBuffer buffFinalCodebase;
    CSmallStringBuffer buffFilePath;
    BOOL fIsPolicy = FALSE;
    BOOL fInstalledbySetup = FALSE;
    SxsWFPResolveCodebase CodebaseType = CODEBASE_RESOLVED_URLHEAD_UNKNOWN;

    PARAMETER_CHECK(pInstallInfo != NULL);

    // We either need a codebase or this had better be a darwin install
    PARAMETER_CHECK(
        ((pInstallInfo->dwFlags & SXSINSTALLSOURCE_HAS_CODEBASE) != 0) ||
        ((pInstallInfo->dwFlags & SXSINSTALLSOURCE_INSTALL_BY_DARWIN) != 0));

    PARAMETER_CHECK(pAssemblyInfo != NULL);

    IFW32FALSE_EXIT(rCodebaseInfo.Initialize());

    //
    // None of the installation context information actually contains the
    // unparsed name of the assembly.  As such, we re-generate the installation
    // path and then use it later.
    //
    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(pAssemblyInfo->GetAssemblyIdentity(), fIsPolicy));

    // x86_policy.1.0.dynamicdll_b54bc117ce08a1e8_en-us_b74d3d95 (w/o version) or
    // x86_dynamicdll_b54bc117ce08a1e8_1.1.0.0_en-us_d51541cb    (w version)
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | (fIsPolicy ? SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION : 0),
            SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
            pcwszAssemblyRoot,
            cchAssemblyRoot,
            pAssemblyInfo->GetAssemblyIdentity(),
            NULL,
            buffAssemblyDirName));

    //
    // Blindly add this registration information to the registry.  We really should
    // try to validate that it's a valid manifest/catalog pair (with strong name
    // and everything) before doing this, but it's happened several times before
    // (in theory) if we're being called during setup. Since setup/install are our
    // only clients as of yet, we can be reasonably sure that there won't be a
    // "rogue" call through here to install bogus assembly information.
    //
    fHasCatalog = ((pInstallInfo->dwFlags & SXSINSTALLSOURCE_HAS_CATALOG) != 0);

    if ((pInstallInfo->dwFlags & SXSINSTALLSOURCE_HAS_CODEBASE) != 0)
    {
        IFW32FALSE_EXIT(buffFinalCodebase.Win32Assign(pInstallInfo->pcwszCodebaseName, ::wcslen(pInstallInfo->pcwszCodebaseName)));
        if (!g_SxsOfflineInstall)
        {
            IFW32FALSE_EXIT(buffFinalCodebase.Win32Append(rbuffRelativeCodebasePath));
        }
    }

    if (buffFinalCodebase.Cch() == 0)
    {
        // eg: darwin, for which we don't write codebases to the registry
        CodebaseType = CODEBASE_RESOLVED_URLHEAD_UNKNOWN;
    }
    else
    {
        IFW32FALSE_EXIT(::SxspDetermineCodebaseType(buffFinalCodebase, CodebaseType, &buffFilePath));
    }

    // If this is a file-ish codebase, let's abstract it (e.g. replace cdrom drive info with cdrom: URL,
    // turn mapped drive letters into UNC paths.

    if (CodebaseType == CODEBASE_RESOLVED_URLHEAD_FILE)
    {
        //
        // Now, let's intuit the type of stuff we're supposed to be putting in the
        // registry based on the input path.
        //
        UINT uiDriveType = 0;

        CSmallStringBuffer buffDriveRoot;
        CSmallStringBuffer buffFullManifestSourcePath;

        // Convert the source path to a full path (in case it isn't) so that we can use the length of
        // the found volume root as an index into the full manifest source path.
        IFW32FALSE_EXIT(::SxspGetFullPathName(rbuffManifestSourcePath, buffFullManifestSourcePath, NULL));
        IFW32FALSE_EXIT(::SxspGetVolumePathName(0, buffFullManifestSourcePath, buffDriveRoot));
        uiDriveType = ::GetDriveTypeW(buffDriveRoot);

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION,
            "SXS: %s - Decided that drive for path \"%ls\" was \"%ls\" and type is %u\n",
            __FUNCTION__,
            static_cast<PCWSTR>(rbuffManifestSourcePath),
            static_cast<PCWSTR>(buffDriveRoot),
            uiDriveType);

        if (uiDriveType == DRIVE_CDROM)
        {
            // Neat, there's a good amount of work we have to do to get this up and
            // working...  In the interest of not blowing stack with really long buffers
            // here (or CStringBuffer objects), this is a heap-allocated string buffer.
            // Before you complain about heap usage, this path is /rarely/ ever hit.
            CSmartArrayPtr<WCHAR> pcwszVolumeName;
            const DWORD dwPathChars = MAX_PATH * 2;
            PCWSTR pszPostVolumeRootPath = NULL;

            // Find the name of the media
            IFW32FALSE_EXIT(pcwszVolumeName.Win32Allocate(dwPathChars, __FILE__, __LINE__));

            IFW32FALSE_ORIGINATE_AND_EXIT(
                ::GetVolumeInformationW(
                    buffDriveRoot,
                    pcwszVolumeName,
                    dwPathChars,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    0));

            pszPostVolumeRootPath = static_cast<PCWSTR>(buffFullManifestSourcePath) + buffDriveRoot.Cch();

            // construct the cdrom: URL...
            IFW32FALSE_EXIT(
                buffFinalCodebase.Win32AssignW(
                    6,
                    URLHEAD_CDROM,                  URLHEAD_LENGTH_CDROM,                   //  cdrom:
                    URLHEAD_CDROM_TYPE_VOLUMENAME,  URLHEAD_LENGTH_CDROM_TYPE_VOLUMENAME,   //  volumename
                    L"/",                           1,                                      //  /
                    static_cast<PCWSTR>(pcwszVolumeName), static_cast<int>((pcwszVolumeName != NULL) ? ::wcslen(pcwszVolumeName) : 0),      // <volume-name>
                    L"/",                           1,                                      //  /
                    pszPostVolumeRootPath,          static_cast<int>(::wcslen(pszPostVolumeRootPath))));        //  <rest-of-path>

            // e.g. cdrom:name/AOE/aoesetup.exe

        }
        else if (uiDriveType == DRIVE_UNKNOWN)
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetDriveTypeW, ERROR_BAD_PATHNAME);
        }
        else if (uiDriveType == DRIVE_REMOTE)
        {
            //
            // If this is a UNC path, then use it.
            //
            if (::SxspDetermineDosPathNameType(rbuffManifestSourcePath) == RtlPathTypeUncAbsolute)
            {
                IFW32FALSE_EXIT(buffFinalCodebase.Win32Assign(rbuffManifestSourcePath));
            }
            else
            {
                // This is a remote drive - figure out what the path was to get connected,
                // the put that into the buffFinalCodebase thing
                IFW32FALSE_EXIT(
                    ::SxspGetRemoteUniversalName(
                        rbuffManifestSourcePath,
                        buffFinalCodebase));
            }
        }
    }

    //
    // Now let's fill out the recovery information object
    //
    IFW32FALSE_EXIT(rRecovery.SetAssemblyIdentity(pAssemblyInfo->GetAssemblyIdentity()));

    if ((pInstallInfo->dwFlags & SXSINSTALLSOURCE_HAS_PROMPT) != 0)
    {
        if (pInstallInfo->pcwszPromptOnRefresh != NULL)
            IFW32FALSE_EXIT(rCodebaseInfo.SetPromptText(
                pInstallInfo->pcwszPromptOnRefresh, 
                ::wcslen(pInstallInfo->pcwszPromptOnRefresh)));
    }
    IFW32FALSE_EXIT(rCodebaseInfo.SetCodebase(buffFinalCodebase));

    FN_EPILOG
}

BOOL
CAssemblyInstall::InstallFile(
    const CBaseStringBuffer &rManifestPath,
    const CBaseStringBuffer &rRelativeCodebasePath
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY Asm = NULL;
    CInstalledItemEntry CurrentInstallEntry;
    const DWORD &dwManifestOperationFlags = m_ActCtxGenCtx.m_ManifestOperationFlags;

    IFALLOCFAILED_EXIT(Asm = new ASSEMBLY);

    //
    // refresh means wfp is doing a recovery..don't muck with the registry..and
    // also no logfile..this is expedient..and possibly proper.
    //
    if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFRESH) == 0)
    {
        IFW32FALSE_EXIT(CurrentInstallEntry.m_RecoveryInfo.Initialize());
        IFW32FALSE_EXIT(CurrentInstallEntry.m_RecoveryInfo.GetCodeBaseList().Win32SetSize(1)); // ??
        m_ActCtxGenCtx.m_InstallationContext.SecurityMetaData = &CurrentInstallEntry.m_RecoveryInfo.GetSecurityInformation();
    }

    //
    // The main code deals with the paths that the assembly is
    // being installed from, not where it is being installed to.
    //
    {
        CProbedAssemblyInformation AssemblyInfo;
        IFW32FALSE_EXIT(AssemblyInfo.Initialize(&m_ActCtxGenCtx));
        IFW32FALSE_EXIT(AssemblyInfo.SetManifestPath(ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE, rManifestPath));
        IFW32FALSE_EXIT(AssemblyInfo.SetManifestLastWriteTime(m_ImpersonationData));
        IFW32FALSE_EXIT(AssemblyInfo.SetManifestFlags(ASSEMBLY_MANIFEST_FILETYPE_AUTO_DETECT));
        IFW32FALSE_EXIT(::SxspInitAssembly(Asm, AssemblyInfo));
    }

    IFW32FALSE_EXIT(::SxspIncorporateAssembly(&m_ActCtxGenCtx, Asm));

    //
    // refresh means wfp is doing a recovery..don't muck with the registry..and
    // also no logfile..this is expedient..and possibly proper.
    //
    if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFRESH) == 0)
    {
        //
        // Track the installation data for this assembly
        //
        IFW32FALSE_EXIT(
            ::SxspGenerateInstallationInfo(
                CurrentInstallEntry.m_RecoveryInfo,
                rManifestPath,
                rRelativeCodebasePath,
                m_pInstallInfo,
                m_ActCtxGenCtx.m_AssemblyRootDirectoryBuffer,
                m_ActCtxGenCtx.m_AssemblyRootDirectoryBuffer.Cch(),
                Asm,
                CurrentInstallEntry.m_CodebaseInfo));

        CurrentInstallEntry.m_dwValidItems |= CINSTALLITEM_VALID_RECOVERY;

        //
        // Track the installation reference for this assembly
        //
        if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID) != 0)
        {
            IFW32FALSE_EXIT(CurrentInstallEntry.m_InstallReference.Initialize(
                static_cast<PCSXS_INSTALL_REFERENCEW>(m_ActCtxGenCtx.m_InstallationContext.InstallReferenceData)));
            IFW32FALSE_EXIT(CurrentInstallEntry.m_InstallReference.SetIdentity(Asm->GetAssemblyIdentity()));
            CurrentInstallEntry.m_CodebaseInfo.SetReference(CurrentInstallEntry.m_InstallReference.GetGeneratedIdentifier());
            CurrentInstallEntry.m_dwValidItems |= CINSTALLITEM_VALID_REFERENCE;
        }

        //
        // Track the identity that was incorporated
        //
        INTERNAL_ERROR_CHECK(CurrentInstallEntry.m_AssemblyIdentity == NULL);
        IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(
            0, 
            Asm->GetAssemblyIdentity(), 
            &CurrentInstallEntry.m_AssemblyIdentity));
        CurrentInstallEntry.m_dwValidItems |= CINSTALLITEM_VALID_IDENTITY;

        //
        // And, if we're logfiling..
        //
        if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE) != 0)
        {
            IFW32FALSE_EXIT(CurrentInstallEntry.m_buffLogFileName.Win32Assign(
                m_pInstallInfo->pcwszLogFileName,
                m_pInstallInfo->pcwszLogFileName != NULL ? ::wcslen(m_pInstallInfo->pcwszLogFileName) : 0));
            CurrentInstallEntry.m_dwValidItems |= CINSTALLITEM_VALID_LOGFILE;
        }

        IFW32FALSE_EXIT(m_ItemsInstalled.Win32Append(CurrentInstallEntry));
    }

    fSuccess = TRUE;
Exit:
    // We delete the ASSEMBLY here regardless of success vs. failure; the incorporate call above
    // does not actually add the PASSEMBLY to the list of assemblies associated with the activation
    // context.  [mgrier 8/9/2000]
    if (Asm != NULL)
    {
        CSxsPreserveLastError ple;
        Asm->Release();
        ple.Restore();
    }
    
    return fSuccess;
}

BOOL
CAssemblyInstall::InstallAssembly(
    DWORD dwManifestOperationFlags,
    PCWSTR ManifestPath,
    PCSXS_INSTALL_SOURCE_INFO pInstallSourceInfo,
    PCSXS_INSTALL_REFERENCEW pvReference
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    DWORD dwManifestOperationFlags_Saved = m_ActCtxGenCtx.m_ManifestOperationFlags;
    CSmallStringBuffer strPath;
    RTL_PATH_TYPE ManifestPathType = static_cast<RTL_PATH_TYPE>(0);
    BOOL fAreWeInSetupMode = FALSE;
    const WCHAR wchCodebasePathSeparator = L'/';

    IFW32FALSE_EXIT(::FusionpAreWeInOSSetupMode(&fAreWeInSetupMode));

    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INSTALLATION,
        "SXS.DLL: %s()\n"
        "   dwManifestOperationFlags = 0x%08lx\n"
        "   ManifestPath = \"%S\"\n"
        "   pInstallSourceInfo = %p\n",
        __FUNCTION__,
        dwManifestOperationFlags,
        ManifestPath,
        pInstallSourceInfo);

    PARAMETER_CHECK(ManifestPath != NULL);
    PARAMETER_CHECK(ManifestPath[0] != L'\0');
    PARAMETER_CHECK(
        (pInstallSourceInfo == NULL) ||
        ((dwManifestOperationFlags & 
            (MANIFEST_OPERATION_INSTALL_FLAG_INCLUDE_CODEBASE | 
                MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE |
                MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_DARWIN |
                MANIFEST_OPERATION_INSTALL_FLAG_REFRESH |
                MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
                MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_MIGRATION |
                MANIFEST_OPERATION_INSTALL_FLAG_FORCE_LOOK_FOR_CATALOG |
                MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID)) != 0));

    PARAMETER_CHECK((dwManifestOperationFlags & 
        (MANIFEST_OPERATION_INSTALL_FLAG_ABORT | 
        MANIFEST_OPERATION_INSTALL_FLAG_COMMIT)) == 0);

    PARAMETER_CHECK(
        ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE) == 0) ||
        (pInstallSourceInfo != NULL));   

    ManifestPathType = ::SxspDetermineDosPathNameType(ManifestPath);
    PARAMETER_CHECK(
        (ManifestPathType == RtlPathTypeUncAbsolute) ||
        (ManifestPathType == RtlPathTypeLocalDevice) ||
        (ManifestPathType == RtlPathTypeDriveAbsolute) ||
        (ManifestPathType == RtlPathTypeDriveRelative) ||
        (ManifestPathType == RtlPathTypeRelative));

    m_ActCtxGenCtx.m_ManifestOperationFlags |= dwManifestOperationFlags;

    //
    // Expand the input path to a full path that we can use later.
    //
    IFW32FALSE_EXIT(::SxspExpandRelativePathToFull(ManifestPath, ::wcslen(ManifestPath), strPath));

    if (m_ActCtxGenCtx.m_ManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_ABORT)
        FN_SUCCESSFUL_EXIT();

    DWORD dwFileAttributes;
    IFW32FALSE_EXIT(::SxspGetFileAttributesW(strPath, dwFileAttributes));

    // They can only ask for directory based installation iff the path they pass
    // in is a directory
    PARAMETER_CHECK(
        ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
        ==
        ((dwManifestOperationFlags &
            (MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY |
             MANIFEST_OPERATION_INSTALL_FLAG_FROM_CABINET |
             MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE)) != 0));


    //
    // If we're expecting to create a logfile, or we want to specify where this
    // assembly can be reloaded from, you'll need to tell us that in the operation
    // flags.
    //
    if (dwManifestOperationFlags & (MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_DARWIN | MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE | MANIFEST_OPERATION_INSTALL_FLAG_INCLUDE_CODEBASE))
    {
        //
        // Constness protection: Copy the data to our own structure, then pass along
        // the pointer to ourselves rather than the caller's
        //
        m_CurrentInstallInfoCopy = *pInstallSourceInfo;
        m_pInstallInfo = &m_CurrentInstallInfoCopy;

        m_ActCtxGenCtx.m_InstallationContext.InstallSource = m_pInstallInfo;

        //
        // So is wanting to create a logfile and not actively telling us where to
        // put it.
        //
        if (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE)
        {
            PARAMETER_CHECK(m_pInstallInfo->pcwszLogFileName);
        }

#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: %s - m_pInstallInfo->dwFlags : 0x%lx\n",
            __FUNCTION__, m_pInstallInfo->dwFlags);
#endif
    }

    if (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID)
    {
        PARAMETER_CHECK(pvReference->dwFlags == 0);
        PARAMETER_CHECK(pvReference->cbSize >= sizeof(SXS_INSTALL_REFERENCEW));
    
        PARAMETER_CHECK(
            (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL) ||
            (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING) ||
            (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_UNINSTALLKEY) ||
            (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_KEYFILE) ||
            (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY));

        //
        // OS-setup scheme is only valid if we're really doing setup.
        //
        PARAMETER_CHECK((pvReference->guidScheme != SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL)
            || fAreWeInSetupMode);

        if ( (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL) ||
              (pvReference->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY))
        {
            PARAMETER_CHECK(pvReference->lpIdentifier == NULL);
        }
        else
        {
            PARAMETER_CHECK((pvReference->lpIdentifier != NULL) && (pvReference->lpIdentifier[0] != UNICODE_NULL));
        }
            
        m_ActCtxGenCtx.m_InstallationContext.InstallReferenceData = pvReference;
    }
    else
        m_ActCtxGenCtx.m_InstallationContext.InstallReferenceData = NULL;


    if ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
    {
        if (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_FROM_CABINET)
        {
            //
            // This does all the work to do the installation
            //
            IFW32FALSE_EXIT(SxspInstallAsmsDotCabEtAl(
                0,
                *this,
                strPath,
                NULL));
        }
        else
        {
            IFW32FALSE_EXIT(strPath.Win32EnsureTrailingPathSeparator());
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_INSTALLATION,
                "SXS: Installing directory \"%S\" (installation flags: 0x%08lx)\n",
                static_cast<PCWSTR>(strPath),
                m_ActCtxGenCtx.m_ManifestOperationFlags);
            IFW32FALSE_EXIT(this->InstallDirectory(strPath, m_ActCtxGenCtx.m_ManifestOperationFlags, wchCodebasePathSeparator));
        }
    }
    else
    {
        CTinyStringBuffer buffRelativeCodebase;

        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INSTALLATION,
            "SXS.DLL: Installing file \"%S\"\n",
            static_cast<PCWSTR>(strPath));
        IFW32FALSE_EXIT(this->InstallFile(strPath, buffRelativeCodebase));
    }

    fSuccess = TRUE;
Exit:
    m_ActCtxGenCtx.m_ManifestOperationFlags = dwManifestOperationFlags_Saved;
    m_bSuccessfulSoFar = m_bSuccessfulSoFar && fSuccess;
    return fSuccess;
}

BOOL
CAssemblyInstall::WriteSingleInstallLog(
    const CInstalledItemEntry &rLogItemEntry,
    BOOL fOverWrite
    )
{
    FN_PROLOG_WIN32
    
    static const WCHAR header[] = { 0xFEFF };
    static const WCHAR eoln[] = L"\r\n";
    CFileStream LogFileStream;
    CSmallStringBuffer buffWritingText;

    //
    // Only call if you've got a log file name, an identity, and a reference.
    //
    PARAMETER_CHECK((rLogItemEntry.m_dwValidItems & 
        (CINSTALLITEM_VALID_LOGFILE | CINSTALLITEM_VALID_IDENTITY | CINSTALLITEM_VALID_REFERENCE)) != 0);

    IFW32FALSE_EXIT(
        LogFileStream.OpenForWrite(
            rLogItemEntry.m_buffLogFileName,
            FILE_SHARE_READ,
            fOverWrite ? CREATE_ALWAYS : OPEN_ALWAYS,
            FILE_FLAG_SEQUENTIAL_SCAN));

    //
    // If we're overwriting, then clip off whatever was
    // already there (if anything.)
    //
    if (fOverWrite)
    {
        ULARGE_INTEGER li;

        li.QuadPart = 0;
        IFCOMFAILED_EXIT(LogFileStream.SetSize(li));
    }

    //
    // Not overwriting? Zing to the end instead.
    //
    if (!fOverWrite)
    {
        LARGE_INTEGER li;
        li.QuadPart = 0;
        IFCOMFAILED_EXIT(LogFileStream.Seek(li, STREAM_SEEK_END, NULL));
    }

    //
    // Convert the installed identity to something that we can save to disk.
    //
    IFW32FALSE_EXIT(
        SxspGenerateTextualIdentity(
            0, 
            rLogItemEntry.m_AssemblyIdentity, 
            buffWritingText));

    //
    // Write the assembly identity
    //
    IFW32FALSE_EXIT(buffWritingText.Win32Append(eoln, NUMBER_OF(eoln)-1));
    IFCOMFAILED_EXIT(
        LogFileStream.Write(
            static_cast<PCWSTR>(buffWritingText),
            (ULONG)(buffWritingText.Cch() * sizeof(WCHAR)),
            NULL));

    //
    // And the reference
    //
    IFW32FALSE_EXIT(rLogItemEntry.m_InstallReference.GetIdentifierValue(buffWritingText));
    IFW32FALSE_EXIT(buffWritingText.Win32Append(eoln, NUMBER_OF(eoln)-1));
    IFCOMFAILED_EXIT(LogFileStream.Write(
            static_cast<PCWSTR>(buffWritingText),
            (ULONG)(buffWritingText.Cch() * sizeof(WCHAR)),
            NULL));

    IFW32FALSE_EXIT(LogFileStream.Close());

    FN_EPILOG
}

BOOL
SxspEnsureInstallReferencePresent(
    DWORD dwFlags,
    IN const CAssemblyInstallReferenceInformation &rcInstRef,
    OUT BOOL &rfWasAdded
    )
/*++

Purpose:

    Ensure that the installation reference given in pAsmIdent and pAsmInstallReference
    is really present in the registry.  If the reference is not present, then it is
    added.  If it's present already, it sets *pfWasPresent and returns.

Parameters:

    dwFlags - Future use, must be zero

    pAsmIdent - Assembly identity to add this reference to

    pAsmInstallReference - Assembly installation reference data, from the calling
        installer application.

--*/
{
    FN_PROLOG_WIN32

    CFusionRegKey       hkAsmInstallInfo;
    CFusionRegKey       hkAsmRefcount;
    CFusionRegKey       hkAllInstallInfo;
    DWORD               dwCreated = 0;
    CSmallStringBuffer  buffAssemblyDirNameInRegistry;
    CSmallStringBuffer  buffRefcountValueName;
    PCASSEMBLY_IDENTITY pAsmIdent = NULL;

    rfWasAdded = FALSE;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK((pAsmIdent = rcInstRef.GetIdentity().GetAssemblyIdentity()) != NULL);

    if (SXS_AVOID_WRITING_REGISTRY)
        FN_SUCCESSFUL_EXIT();

    //
    // Open installation data key
    //
    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(0, KEY_READ, hkAllInstallInfo));

    //
    // Open the specific assembly name key
    //
    IFW32FALSE_EXIT(::SxspGenerateAssemblyNameInRegistry(pAsmIdent, buffAssemblyDirNameInRegistry));
    IFW32FALSE_EXIT(hkAllInstallInfo.OpenOrCreateSubKey(
        hkAsmInstallInfo,
        buffAssemblyDirNameInRegistry,
        KEY_ALL_ACCESS,
        0,
        NULL,
        NULL));

    INTERNAL_ERROR_CHECK(hkAsmInstallInfo != CFusionRegKey::GetInvalidValue());

    //
    // Open the subey for refcounting
    //
    IFW32FALSE_EXIT(hkAsmInstallInfo.OpenOrCreateSubKey(
        hkAsmRefcount,
        WINSXS_INSTALLATION_REFERENCES_SUBKEY,
        KEY_SET_VALUE,
        0,
        &dwCreated,
        NULL));

    INTERNAL_ERROR_CHECK(hkAsmRefcount != CFusionRegKey::GetInvalidValue());

    //
    // Generate the installation data that will be populated here.
    //
    IFW32FALSE_EXIT(rcInstRef.WriteIntoRegistry(hkAsmRefcount));
    rfWasAdded = TRUE;
    
    FN_EPILOG
}




BOOL
CAssemblyInstall::EndAssemblyInstall(
    DWORD dwManifestOperationFlags,
    PVOID
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    PARAMETER_CHECK(
        (dwManifestOperationFlags & ~(
              MANIFEST_OPERATION_INSTALL_FLAG_ABORT
            | MANIFEST_OPERATION_INSTALL_FLAG_COMMIT
            | MANIFEST_OPERATION_INSTALL_FLAG_REFRESH
            )) == 0);

    // one of these but not both must be set
    PARAMETER_CHECK((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_ABORT)
        ^ (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_COMMIT));

    //
    // PARAMETER_CHECK above ensures that this only has known bits set.
    // If PARAMETER_CHECK above is expanded to allow more flags, maintain
    // this line appropriately.
    //
    m_ActCtxGenCtx.m_ManifestOperationFlags |= dwManifestOperationFlags;

    //
    // Clear out some metadata in the registry.
    //
    if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_ABORT) == 0)
    {
        for (ULONG ul = 0; ul < m_ItemsInstalled.GetSize(); ul++)
        {
            if (m_ItemsInstalled[ul].m_dwValidItems & CINSTALLITEM_VALID_RECOVERY)
            {
                IFW32FALSE_EXIT(m_ItemsInstalled[ul].m_RecoveryInfo.ClearExistingRegistryData());
            }
        }
    }

    IFW32FALSE_EXIT(::SxspFireActCtxGenEnding(&m_ActCtxGenCtx));

    //
    // write register before copy files into winsxs : see bug 316380
    //
    if ( ( dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_ABORT ) == 0 )
    {
        BOOL fWasAdded = FALSE;

        //
        // Post installation tidyup
        //
        for (ULONG ul = 0; ul < m_ItemsInstalled.GetSize(); ul++)
        {
            CInstalledItemEntry &Item = m_ItemsInstalled[ul];

            if (Item.m_dwValidItems & CINSTALLITEM_VALID_RECOVERY)
            {
                //
                // Add the codebase for this reference.  If one exists for the ref,
                // update its URL, prompt, etc.
                //
                CCodebaseInformation* pCodebaseInfo = NULL;
                CCodebaseInformationList &rCodebaseList = Item.m_RecoveryInfo.GetCodeBaseList();
                ULONG Flags = 0;
                
                IFW32FALSE_EXIT(rCodebaseList.FindCodebase(
                    Item.m_InstallReference.GetGeneratedIdentifier(),
                    pCodebaseInfo));

                if ( pCodebaseInfo != NULL )
                {
                    IFW32FALSE_EXIT(pCodebaseInfo->Initialize(Item.m_CodebaseInfo));
                }
                else
                {
                    IFW32FALSE_EXIT(rCodebaseList.Win32Append(Item.m_CodebaseInfo));
                }
                
                if (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFRESH)
                {
                    Flags |= SXSP_ADD_ASSEMBLY_INSTALLATION_INFO_FLAG_REFRESH;
#if DBG
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INSTALLATION,
                        "SXS.DLL: %s - propping recovery flag to SxspAddAssemblyInstallationInfo\n",
                        __FUNCTION__);
#endif
                }
                IFW32FALSE_EXIT(::SxspAddAssemblyInstallationInfo(Flags, Item.m_RecoveryInfo, Item.m_CodebaseInfo));
            }

            //
            // Adding a reference? Don't touch references when recovering assembly via wfp/sfc.
            //
            if ((dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFRESH) == 0)
            {
                if (Item.m_dwValidItems & CINSTALLITEM_VALID_REFERENCE)
                {
                    IFW32FALSE_EXIT(::SxspEnsureInstallReferencePresent(0, Item.m_InstallReference, fWasAdded));
                }
            }
            else
            {
#if DBG
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_WFP,
                    "SXS: %s() - not writing reference to registry in recovery/wfp/sfc\n",
                    __FUNCTION__
                    );
#endif
            }

            //
            // Creating a logfile?
            //
            if ((Item.m_dwValidItems & (CINSTALLITEM_VALID_IDENTITY | CINSTALLITEM_VALID_LOGFILE)) &&
                (m_ActCtxGenCtx.m_ManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE))
            {
                IFW32FALSE_EXIT(this->WriteSingleInstallLog(Item));
            }
        }
    }
    
    fSuccess = TRUE;
Exit:
    if (!fSuccess)
    {
        CSxsPreserveLastError ple;
        for (ULONG ul = 0; ul < m_ItemsInstalled.GetSize(); ul++)
        {
            m_ItemsInstalled[ul].m_RecoveryInfo.RestorePreviouslyExistingRegistryData();
        }
        ple.Restore();
    }
    m_bSuccessfulSoFar= m_bSuccessfulSoFar && fSuccess;
    return fSuccess;
}

BOOL
WINAPI
SxsBeginAssemblyInstall(
    DWORD Flags,
    PSXS_INSTALLATION_FILE_COPY_CALLBACK InstallationCallback,
    PVOID InstallationContext,
    PSXS_IMPERSONATION_CALLBACK ImpersonationCallback,
    PVOID ImpersonationContext,
    PVOID *ppvInstallCookie
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    DWORD dwManifestOperationFlags = 0;
    CAssemblyInstall* pInstall = NULL;
    CImpersonationData ImpersonationData(ImpersonationCallback, ImpersonationContext);

    if (ppvInstallCookie != NULL)
        *ppvInstallCookie = NULL;

    PARAMETER_CHECK(ppvInstallCookie != NULL);
    PARAMETER_CHECK(
        (Flags & ~(
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_MOVE |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_RESOURCE |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY |
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING)) == 0);

#define MAP_FLAG(x) do { if (Flags & SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_ ## x) dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ ## x; } while (0)

    MAP_FLAG(MOVE);
    MAP_FLAG(FROM_RESOURCE);
    MAP_FLAG(FROM_DIRECTORY);
    MAP_FLAG(FROM_DIRECTORY_RECURSIVE);
    MAP_FLAG(NOT_TRANSACTIONAL);
    MAP_FLAG(NO_VERIFY);
    MAP_FLAG(REPLACE_EXISTING);

#undef MAP_FLAG

    IFALLOCFAILED_EXIT(pInstall = new CAssemblyInstall);
    IFW32FALSE_EXIT(pInstall->BeginAssemblyInstall(dwManifestOperationFlags, InstallationCallback, InstallationContext, ImpersonationData));

    *ppvInstallCookie = pInstall;
    pInstall = NULL;

    fSuccess = TRUE;
Exit:
    FUSION_DELETE_SINGLETON(pInstall);
    return fSuccess;
}

BOOL
SxsInstallW(
    PSXS_INSTALLW lpInstallIn
    )
{
/*
NTRAID#NTBUG9-612092-2002/05/16-JayKrell
large frame -- over 3500 bytes
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SXS_INSTALL_SOURCE_INFO sisi;
    PSXS_INSTALL_SOURCE_INFO psisi = NULL;
    CAssemblyInstall* pInstall = NULL;
    CSmartPtr<CAssemblyInstall> defaultAssemblyInstall;
    CImpersonationData ImpersonationData;
    DWORD dwManifestOperationFlags = 0;
    SXS_INSTALL_REFERENCEW BlankReference;
    BOOL fAreWeInOSSetupMode = FALSE;
    SXS_INSTALLW InstallCopy = { sizeof(SXS_INSTALLW) };
    CSmallStringBuffer buffConstructedCodebaseBuffer;
    CSmallStringBuffer rgbFilenameBuffer;

    PARAMETER_CHECK(
        (lpInstallIn != NULL) &&
        RTL_CONTAINS_FIELD(lpInstallIn, lpInstallIn->cbSize, lpManifestPath));

    PARAMETER_CHECK((lpInstallIn->lpManifestPath != NULL) && (lpInstallIn->lpManifestPath[0] != L'\0'));

    PARAMETER_CHECK(
        (lpInstallIn->dwFlags & ~(
            SXS_INSTALL_FLAG_CODEBASE_URL_VALID |
            SXS_INSTALL_FLAG_MOVE |
            SXS_INSTALL_FLAG_FROM_RESOURCE |
            SXS_INSTALL_FLAG_FROM_DIRECTORY |
            SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE |
            SXS_INSTALL_FLAG_NOT_TRANSACTIONAL |
            SXS_INSTALL_FLAG_NO_VERIFY |
            SXS_INSTALL_FLAG_REPLACE_EXISTING |
            SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID |
            SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN |
            SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
            SXS_INSTALL_FLAG_INSTALLED_BY_MIGRATION |
            SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID |
            SXS_INSTALL_FLAG_REFERENCE_VALID |
            SXS_INSTALL_FLAG_REFRESH |
            SXS_INSTALL_FLAG_FROM_CABINET |
            SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID)) == 0);

#define FLAG_FIELD_CHECK(_flagname, _fieldname) PARAMETER_CHECK(((lpInstallIn->dwFlags & _flagname) == 0) || (RTL_CONTAINS_FIELD(lpInstallIn, lpInstallIn->cbSize, _fieldname)))

    FLAG_FIELD_CHECK(SXS_INSTALL_FLAG_CODEBASE_URL_VALID, lpCodebaseURL);
    FLAG_FIELD_CHECK(SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID, pvInstallCookie);
    FLAG_FIELD_CHECK(SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID, lpRefreshPrompt);
    FLAG_FIELD_CHECK(SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID, lpLogFileName);
    FLAG_FIELD_CHECK(SXS_INSTALL_FLAG_REFERENCE_VALID, lpReference);

#undef FLAG_FIELD_CHECK

    // If they said they have a codebase, they need to really have one.
    PARAMETER_CHECK(
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_CODEBASE_URL_VALID) == 0) ||
        ((lpInstallIn->lpCodebaseURL != NULL) &&
         (lpInstallIn->lpCodebaseURL[0] != L'\0')));

#if DBG
    if (lpInstallIn != NULL)
    {
#define X(x,y,z) if ((lpInstallIn->dwFlags & x) != 0) \
                     Y(y,z)
#define   Y(y,z)     ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_INSTALLATION, "SXS: %s() lpInstallIn->" #y " : " z "\n", __FUNCTION__, lpInstallIn->y)
        X(SXS_INSTALL_FLAG_CODEBASE_URL_VALID,   lpCodebaseURL, "  %ls");
        X(SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID, pvInstallCookie, "%p");
        X(SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID, lpRefreshPrompt, "%ls");
        X(SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID,  lpLogFileName, "  %ls");
        X(SXS_INSTALL_FLAG_REFERENCE_VALID,      lpReference, "    %p");
        Y(                lpManifestPath, " %ls");
        Y(                dwFlags, "        0x%lx");
#undef Y
#undef X
    }
#endif

    // If they say they have a valid cookie, make sure it is.
    PARAMETER_CHECK(
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID) == 0) ||
        (lpInstallIn->pvInstallCookie != NULL));

    // Darwin installs have implied codebases, so don't let both flags be set.
    PARAMETER_CHECK(
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN) == 0) ||
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_CODEBASE_URL_VALID) == 0));

    // OS Setup only makes sense with from-directory-recursive.  Otherwise we
    // can't figure out the magic x-ms-windows-source: url to put into the codebase.
    PARAMETER_CHECK(
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP) == 0) ||
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE) != 0) ||
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_FROM_CABINET) != 0) ||
        ((lpInstallIn->dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_MIGRATION) != 0) );

    // PARAMETER CHECKING IS DONE!  Let's copy the fields that don't have flags to
    // indicate that they're (optionally) set and start applying defaults.

    InstallCopy.dwFlags = lpInstallIn->dwFlags;
    InstallCopy.lpManifestPath = lpInstallIn->lpManifestPath;

    // Copy fields that the caller supplied and indicated were valid:

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID)
        InstallCopy.pvInstallCookie = lpInstallIn->pvInstallCookie;
    else
        InstallCopy.pvInstallCookie = NULL;

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_CODEBASE_URL_VALID)
        InstallCopy.lpCodebaseURL = lpInstallIn->lpCodebaseURL;
    else
        InstallCopy.lpCodebaseURL = NULL;

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID)
        InstallCopy.lpRefreshPrompt = lpInstallIn->lpRefreshPrompt;
    else
        InstallCopy.lpRefreshPrompt = NULL;

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID)
        InstallCopy.lpLogFileName = lpInstallIn->lpLogFileName;
    else
        InstallCopy.lpLogFileName = NULL;

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_REFERENCE_VALID)
        InstallCopy.lpReference = lpInstallIn->lpReference;
    else
        InstallCopy.lpReference = NULL;

    // APPLY DEFAULTS

    //
    // Fix up blank reference for non-darwin installations to at least indicate the
    // executable which performed the installation.
    //
    if (((InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN) == 0) &&
        ((InstallCopy.dwFlags & SXS_INSTALL_FLAG_REFERENCE_VALID) == 0))
    {
        ZeroMemory(&BlankReference, sizeof(BlankReference));

        BlankReference.cbSize = sizeof(BlankReference);
        BlankReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY;
        BlankReference.lpIdentifier = NULL;

        IFW32FALSE_EXIT(FusionpGetModuleFileName(0, GetModuleHandleW(NULL), rgbFilenameBuffer));
        BlankReference.lpNonCanonicalData = rgbFilenameBuffer;

        InstallCopy.lpReference = &BlankReference;
        InstallCopy.dwFlags |= SXS_INSTALL_FLAG_REFERENCE_VALID;
    }

    IFW32FALSE_EXIT(::FusionpAreWeInOSSetupMode(&fAreWeInOSSetupMode));

    if (!g_SxsOfflineInstall)
    {
        // If this is an OS install and a codebase was not passed, we'll fill in the magical
        // one that says to look under the os setup information key.  Since the are-we-in-
        // ossetup flag always overrides, ensure that the "are we in os setup" flag is set
        // in the structure as well.
        if ((InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP) != 0)
        {
            InstallCopy.lpCodebaseURL = URLHEAD_WINSOURCE;
            InstallCopy.dwFlags |= SXS_INSTALL_FLAG_CODEBASE_URL_VALID | SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP;
            if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_MIGRATION)
                InstallCopy.dwFlags |= SXS_INSTALL_FLAG_CODEBASE_URL_VALID | SXS_INSTALL_FLAG_INSTALLED_BY_MIGRATION;
        }
    }

    // If there's no codebase (and this isn't an MSI install);
    // we'll assume that the manifest path is a sufficient codebase.
    if (((InstallCopy.dwFlags & SXS_INSTALL_FLAG_CODEBASE_URL_VALID) == 0) &&
        ((InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN) == 0))
    {
        InstallCopy.lpCodebaseURL = InstallCopy.lpManifestPath;
        InstallCopy.dwFlags |= SXS_INSTALL_FLAG_CODEBASE_URL_VALID;
    }

#define MAP_FLAG(x) do { if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_ ## x) dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ ## x; } while (0)

    MAP_FLAG(MOVE);
    MAP_FLAG(FROM_RESOURCE);
    MAP_FLAG(NO_VERIFY);
    MAP_FLAG(NOT_TRANSACTIONAL);
    MAP_FLAG(REPLACE_EXISTING);
    MAP_FLAG(FROM_DIRECTORY);
    MAP_FLAG(FROM_DIRECTORY_RECURSIVE);
    MAP_FLAG(INSTALLED_BY_DARWIN);    
    MAP_FLAG(INSTALLED_BY_OSSETUP);    
    MAP_FLAG(INSTALLED_BY_MIGRATION);    
    MAP_FLAG(REFERENCE_VALID);
    MAP_FLAG(REFRESH);
    MAP_FLAG(FROM_CABINET);

#undef MAP_FLAG

    // Because we didn't have time to go through and get rid of the SXS_INSTALL_SOURCE_INFO struct
    // usage, we have to now map the SXS_INSTALLW to a legacy SXS_INSTALL_SOURCE_INFO.

    memset(&sisi, 0, sizeof(sisi));
    sisi.cbSize = sizeof(sisi);

    //
    // We could do this above, but that makes things 'messy' - a smart compiler
    // might merge the two..
    //
    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_CODEBASE_URL_VALID)
    {
        sisi.pcwszCodebaseName = InstallCopy.lpCodebaseURL;
        sisi.dwFlags |= SXSINSTALLSOURCE_HAS_CODEBASE;
        psisi = &sisi;
    }

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID)
    {
        sisi.pcwszPromptOnRefresh = InstallCopy.lpRefreshPrompt;
        sisi.dwFlags |= SXSINSTALLSOURCE_HAS_PROMPT;
        psisi = &sisi;
    }

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID)
    {
        dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE;
        sisi.pcwszLogFileName = InstallCopy.lpLogFileName;
        sisi.dwFlags |= SXSINSTALLSOURCE_CREATE_LOGFILE;
        psisi = &sisi;
    }

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN)
    {
        sisi.dwFlags |= SXSINSTALLSOURCE_INSTALL_BY_DARWIN;
        psisi = &sisi;
    }

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP)
    {
        sisi.dwFlags |= SXSINSTALLSOURCE_INSTALL_BY_OSSETUP;

        if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALLED_BY_MIGRATION)
            sisi.dwFlags |= SXSINSTALLSOURCE_INSTALL_BY_MIGRATION;

        psisi = &sisi;
    }

    if (InstallCopy.dwFlags & SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID)
        pInstall = reinterpret_cast<CAssemblyInstall*>(InstallCopy.pvInstallCookie);
    else
    {
        IFW32FALSE_EXIT(defaultAssemblyInstall.Win32Allocate(__FILE__, __LINE__));
        IFW32FALSE_EXIT(defaultAssemblyInstall->BeginAssemblyInstall(dwManifestOperationFlags, NULL, NULL, ImpersonationData));
        pInstall = defaultAssemblyInstall;
    }

    //
    // If psisi is non-null, we've filled out some about the codebase information,
    // so set the manifest operation flag.
    //
    if (psisi != NULL)
    {
        dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_INCLUDE_CODEBASE;
    }

    fSuccess = pInstall->InstallAssembly(
        dwManifestOperationFlags,
        InstallCopy.lpManifestPath,
        psisi,
        InstallCopy.lpReference);

    if (InstallCopy.pvInstallCookie == NULL)
    {
        DWORD dwError = ::FusionpGetLastWin32Error();
        BOOL fEndStatus = pInstall->EndAssemblyInstall(
            (fSuccess ? MANIFEST_OPERATION_INSTALL_FLAG_COMMIT : MANIFEST_OPERATION_INSTALL_FLAG_ABORT)
            | (dwManifestOperationFlags & MANIFEST_OPERATION_INSTALL_FLAG_REFRESH)
            );

        if (!fEndStatus)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS: %s() - Failed call to EndAssemblyInstall, previous winerror was %lu, error after EndAssemblyInstall %lu\n",
                __FUNCTION__,
                dwError,
                ::FusionpGetLastWin32Error());
        }

        //
        // If the install failed but the end succeeded, we want the status of the install, right?
        //
        // I think it should always keep the error status of installation failure no matter whether EndInstall succeed or not.        
        // so I change the code from         
        //      if (bEndStatus && !fSuccess)
        //  to
        //      if (!fSuccess)
        //
        
        if (!fSuccess)
        {
            ::FusionpSetLastWin32Error(dwError);
        }

        fSuccess = (fSuccess && fEndStatus);
    }

Exit:
    // add assembly-install info into setup log file
    {
        CSxsPreserveLastError ple;

        if (fAreWeInOSSetupMode)
        {
            if (fSuccess)
            {
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_SETUPLOG, "SXS Installation Succeed for %S \n", InstallCopy.lpManifestPath);
            }
            else // if the installation fails, we need specify what and why
            {
                ASSERT(ple.LastError()!= 0);
                CHAR rgchLastError[160];
                rgchLastError[0] = 0;
                if (!::FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY, NULL, ple.LastError(), 0, rgchLastError, NUMBER_OF(rgchLastError), NULL))
                {
                    FusionpFormatStringA(rgchLastError, NUMBER_OF(rgchLastError), "Message not avaiable for display, please refer error# :%d\n", ::FusionpGetLastWin32Error());
                }
                ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_SETUPLOG | FUSION_DBG_LEVEL_ERROR, "Installation Failed: %S. Error Message : %s\n", InstallCopy.lpManifestPath, rgchLastError);
            }
        }

        ple.Restore();
    }

    return fSuccess;
}


BOOL
WINAPI
SxsEndAssemblyInstall(
    PVOID   pvInstallCookie,
    DWORD   dwFlags,
    PVOID   pvReserved
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CAssemblyInstall* pInstall = NULL;
    DWORD dwManifestOperationFlags = 0;
    PBOOL pvReservedAsPointerToBool = NULL;

    if ((dwFlags & SXS_END_ASSEMBLY_INSTALL_FLAG_GET_STATUS) && pvReserved != NULL)
    {
        pvReservedAsPointerToBool = reinterpret_cast<PBOOL>(pvReserved);
        *pvReservedAsPointerToBool = FALSE;
    }

    PARAMETER_CHECK(pvInstallCookie != NULL);
    PARAMETER_CHECK(
        (dwFlags & ~(
            SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT |
            SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT |
            SXS_END_ASSEMBLY_INSTALL_FLAG_NO_VERIFY |
            SXS_END_ASSEMBLY_INSTALL_FLAG_GET_STATUS)) == 0);

#define X SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT
#define Y SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT
    PARAMETER_CHECK(((dwFlags & (X | Y)) == X)
        || ((dwFlags & (X | Y)) == Y));
#undef X
#undef Y

    //
    // Want the install status?  Don't forget to tell us where to put it.
    //
    PARAMETER_CHECK(!(
        (dwFlags & SXS_END_ASSEMBLY_INSTALL_FLAG_GET_STATUS) &&
        (pvReserved != NULL)));

#define MAP_FLAG(x) do { if (dwFlags & SXS_END_ASSEMBLY_INSTALL_FLAG_ ## x) dwManifestOperationFlags |= MANIFEST_OPERATION_INSTALL_FLAG_ ## x; } while (0)
    MAP_FLAG(COMMIT);
    MAP_FLAG(ABORT);
    MAP_FLAG(NO_VERIFY);
#undef MAP_FLAG

    pInstall = reinterpret_cast<CAssemblyInstall*>(pvInstallCookie);
    IFW32FALSE_EXIT(pInstall->EndAssemblyInstall(dwManifestOperationFlags));
    if (dwFlags & SXS_END_ASSEMBLY_INSTALL_FLAG_GET_STATUS)
    {
        INTERNAL_ERROR_CHECK(pvReserved != NULL);
        INTERNAL_ERROR_CHECK(pvReservedAsPointerToBool != NULL);
        *pvReservedAsPointerToBool = pInstall->m_bSuccessfulSoFar;
    }
    
    fSuccess = TRUE;
Exit:
    CSxsPreserveLastError ple;
    FUSION_DELETE_SINGLETON(pInstall); // no matter failed or succeed, delete it
    ple.Restore();

    return fSuccess;
}

/*-----------------------------------------------------------------------------
predefined setup callbacks
-----------------------------------------------------------------------------*/

/*
NTRAID#NTBUG9-591148-2002/03/31-JayKrell
remove dead code SxspInstallCallbackSetupCopyQueueEx
*/
BOOL
WINAPI
SxspInstallCallbackSetupCopyQueueEx(
    PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS parameters
    )
{
/*
NTRAID#NTBUG9-591148-2002/03/31-JayKrell
large stack frame -- over 1200 bytes
*/
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    PSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS parameters2 = reinterpret_cast<PSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS>(parameters->pvContext);
    ASSERT(parameters->cbSize == sizeof(*parameters));
    ASSERT(parameters2->cbSize == sizeof(*parameters2));

    CSetupCopyQueuePathParameters setupCopyQueueParameters;

    IFW32FALSE_EXIT(setupCopyQueueParameters.Initialize(parameters->pSourceFile, parameters->pDestinationFile));

    IFW32FALSE_EXIT(
        ::SetupQueueCopyW(
            parameters2->hSetupCopyQueue,
            setupCopyQueueParameters.m_sourceRoot,
            setupCopyQueueParameters.m_sourcePath,
            setupCopyQueueParameters.m_sourceName,
            parameters2->pszSourceDescription,
            NULL, // tag file
            setupCopyQueueParameters.m_destinationDirectory,
            setupCopyQueueParameters.m_destinationName,
            parameters2->dwCopyStyle));

    parameters->nDisposition = SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_QUEUED;
    fSuccess = TRUE;

Exit:
    ASSERT(HeapValidate(FUSION_DEFAULT_PROCESS_HEAP(), 0, NULL));
    return fSuccess;
}

/*
NTRAID#NTBUG9-591148-2002/03/31-JayKrell
remove dead code SxspInstallCallbackSetupCopyQueue
*/
BOOL
WINAPI
SxspInstallCallbackSetupCopyQueue(
    PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS parameters
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ASSERT(parameters->cbSize == sizeof(*parameters));
    HSPFILEQ hSetupCopyQueue = reinterpret_cast<HSPFILEQ>(parameters->pvContext);

    SXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS parameters2 = {sizeof(parameters2)};
    parameters2.hSetupCopyQueue = hSetupCopyQueue;
    parameters2.pszSourceDescription = NULL;
    parameters2.dwCopyStyle = 0;

    // copy to not violate const
    SXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS parameters3 = *parameters;
    parameters3.pvContext = &parameters2;

    IFW32FALSE_EXIT(::SxspInstallCallbackSetupCopyQueueEx(&parameters3));

    parameters->nDisposition = parameters3.nDisposition;
    fSuccess = TRUE;

Exit:
    ASSERT(HeapValidate(FUSION_DEFAULT_PROCESS_HEAP(), 0, NULL));
    return fSuccess;
}

VOID
CALLBACK
SxsRunDllInstallAssemblyW(HWND hwnd, HINSTANCE hinst, PWSTR lpszCmdLine, int nCmdShow)
{
    FN_PROLOG_VOID

    SXS_INSTALLW Install = { sizeof(SXS_INSTALLW) };
    SXS_INSTALL_REFERENCEW Reference = { sizeof(SXS_INSTALL_REFERENCEW) };
    CSmallStringBuffer FullPath;

    IFW32FALSE_EXIT(::SxspExpandRelativePathToFull(lpszCmdLine, ::wcslen(lpszCmdLine), FullPath));

    Install.dwFlags = SXS_INSTALL_FLAG_REPLACE_EXISTING | 
        SXS_INSTALL_FLAG_REFERENCE_VALID |
        SXS_INSTALL_FLAG_CODEBASE_URL_VALID;
    Install.lpManifestPath = FullPath;
    Install.lpCodebaseURL = FullPath;
    Install.lpReference = &Reference;

    Reference.dwFlags = 0;
    Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;
    Reference.lpIdentifier = L"RunDll32";

    ::SxsInstallW(&Install);

    FN_EPILOG
}

/*
NTRAID#NTBUG9-591148-2002/03/31-JayKrell
remove dead ansi code SxsRunDllInstallAssembly
*/
VOID
CALLBACK
SxsRunDllInstallAssembly(HWND hwnd, HINSTANCE hinst, PSTR lpszCmdLine, int nCmdShow)
{
    FN_TRACE_SMART_TLS();

    CSmallStringBuffer buffer;
    if (buffer.Win32Assign(lpszCmdLine, ::strlen(lpszCmdLine)))
    {
        ::SxsRunDllInstallAssemblyW(hwnd, hinst, const_cast<PWSTR>(static_cast<PCWSTR>(buffer)), nCmdShow);
    }
}

BOOL
CAssemblyInstallReferenceInformation::WriteIntoRegistry(
    const CFusionRegKey &rhkTargetKey
    ) const
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    FN_PROLOG_WIN32

    INTERNAL_ERROR_CHECK(this->m_fIdentityStuffReady);

    IFW32FALSE_EXIT(
        rhkTargetKey.SetValue(
            m_buffGeneratedIdentifier,
            this->GetCanonicalData()));
    
    FN_EPILOG
}

CAssemblyInstallReferenceInformation::CAssemblyInstallReferenceInformation()
    : m_SchemeGuid(GUID_NULL), m_fIdentityStuffReady(FALSE), m_dwFlags(0)
{
}

BOOL
CAssemblyInstallReferenceInformation::GenerateFileReference(
    IN const CBaseStringBuffer &buffKeyfileName,
    OUT CBaseStringBuffer &buffDrivePath,
    OUT CBaseStringBuffer &buffFilePart,
    OUT DWORD &dwDriveSerial
    )
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffWorking;
    CSmallStringBuffer buffTemp;
    bool fIsUncPath = false;

    dwDriveSerial = 0;

    /*
    NTRAID#NTBUG9-591148-2002/03/31-JayKrell
    case mapping of ':' ?
    */
    // The key file must either start with "\\" or "x:\" to be valid.
    PARAMETER_CHECK(buffKeyfileName.Cch() >= 3);
    PARAMETER_CHECK(
        ((::FusionpIsPathSeparator(buffKeyfileName[0]) &&
          ::FusionpIsPathSeparator(buffKeyfileName[1])) ||
         (::FusionpIsDriveLetter(buffKeyfileName[0]) &&
          (buffKeyfileName[1] == L':') &&
          ::FusionpIsPathSeparator(buffKeyfileName[2]))));

    //
    // Steps:
    // - Strip potential file name from buffKeyfileName.
    // - Call GetVolumePathName on buffKeyfileName, store that
    //   in buffDrivePath
    // - Call GetVolumeNameForVolumeMountPoint on buffDrivePath,
    //   store into some temporary
    // - Call GetVolumeInformation on the temporary to
    //   obtain the serial number.
    // - Call GetDriveType on the temporary to see what kind of 
    //   drive type the key is on.
    //   - If it's on a network, call SxspGetUniversalName to get
    //     the network path (call on buffDrivePath)
    //
    IFW32FALSE_EXIT(::SxspGetFullPathName(buffKeyfileName, buffWorking));
    IFW32FALSE_EXIT(::SxspGetVolumePathName(0, buffWorking, buffDrivePath));
    IFW32FALSE_EXIT(buffFilePart.Win32Assign(buffWorking));

    // If the user pointed us to something that is a volume path but did not include the
    // trailing path separator, we'll actually end up with a buffDrivePath like "c:\mountpoint\"
    // but the buffFilePart will be "c:\mountpoint".  we'll explicitly handle
    // this situation; there does not seem to be a generalization.  -mgrier 6/26/2001
    if ((buffDrivePath.Cch() == (buffFilePart.Cch() + 1)) &&
        buffDrivePath.HasTrailingPathSeparator() &&
        !buffFilePart.HasTrailingPathSeparator())
    {
        buffFilePart.Clear();
    }
    else
    {
        INTERNAL_ERROR_CHECK(buffFilePart.Cch() >= buffDrivePath.Cch());
        IFW32FALSE_EXIT(buffFilePart.Right(buffFilePart.Cch() - buffDrivePath.Cch()));
    }

    fIsUncPath = false;

    //
    // \\machine\share is unc
    // \\?\unc is unc
    // \\?foo is not unc
    //
    if (buffDrivePath.Cch() > 3)
    {
        if (::FusionpIsPathSeparator(buffDrivePath[0]))
        {
            if (::FusionpIsPathSeparator(buffDrivePath[1]))
            {
                if (buffDrivePath[2] == L'?')
                {
                    if (::FusionpIsPathSeparator(buffDrivePath[3]))
                    {
                        if (buffDrivePath.Cch() > 7)
                        {
                            if (::FusionpEqualStringsI(&buffDrivePath[4], 3, L"unc", 3) &&
                                ::FusionpIsPathSeparator(buffDrivePath[7]))
                                fIsUncPath = true;
                        }
                    }
                }
            }
            else
                fIsUncPath = true;
        }
    }

    if ((::GetDriveTypeW(buffDrivePath) == DRIVE_REMOTE) && !fIsUncPath)
    {
        IFW32FALSE_EXIT(::SxspGetRemoteUniversalName(buffDrivePath, buffTemp));
        IFW32FALSE_EXIT(buffDrivePath.Win32Assign(buffTemp));

        // This seems gross, but the drive letter can be mapped to \\server\share\dir, so we'll
        // trim it down to the volume path name, and anything that's after that we'll shift over
        // to the file part.
        //
        // Luckily the string always seems to be of the form \\server\share\path1\path2\ (note
        // the trailing slash), and GetVolumePathName() should always return "\\server\share\"
        // so relatively simple string manipulation should clean this up.
        IFW32FALSE_EXIT(::SxspGetVolumePathName(0, buffDrivePath, buffTemp));

        INTERNAL_ERROR_CHECK(buffTemp.Cch() <= buffDrivePath.Cch());

        if (buffTemp.Cch() != buffDrivePath.Cch())
        {
            IFW32FALSE_EXIT(buffFilePart.Win32Prepend(buffDrivePath + buffTemp.Cch(), buffDrivePath.Cch() - buffTemp.Cch()));
            IFW32FALSE_EXIT(buffDrivePath.Win32Assign(buffTemp));
        }
    }

    IFW32FALSE_ORIGINATE_AND_EXIT(::GetVolumeInformationW(
			buffDrivePath,
			NULL,
			0,
			&dwDriveSerial,
			NULL,
			NULL,
			NULL,
			0));

    //
    // Convert NT path to Win32 Path.
    //
    // \\?\unc\machine\share\foo => \\machine\share\foo
    // \\?\c:\foo => c:\
    //
    if (buffDrivePath.Cch() > 3)
    {
        if (::FusionpIsPathSeparator(buffDrivePath[0]) &&
            ::FusionpIsPathSeparator(buffDrivePath[1]) &&
            (buffDrivePath[2] == L'?') &&
            ::FusionpIsPathSeparator(buffDrivePath[3]))
        {
            if (buffDrivePath.Cch() > 7)
            {
                if (::FusionpEqualStringsI(&buffDrivePath[4], 3, L"unc", 3) &&
                    ::FusionpIsPathSeparator(buffDrivePath[7]))
                {
                    // "\\?\UNC\machine\share" -> "\machine\share" 
                    buffDrivePath.Right(buffDrivePath.Cch() - 7);

                    // "\machine\share" -> "\\machine\share" 
                    IFW32FALSE_EXIT(buffDrivePath.Win32Prepend(L'\\'));
                }
            }
            else
            {
                // "\\?foo" -> "foo"
                // "\\?\c:\foo" -> "c:\foo"
                buffDrivePath.Right(buffDrivePath.Cch() - 4);
            }
        }
    }


    FN_EPILOG
}



BOOL
pMapSchemeGuidToString(
    IN  const GUID &rcGuid,
    OUT CBaseStringBuffer &rbuffIdentifier
    )
{
    FN_PROLOG_WIN32

    static struct {
        const GUID* pguid;
        PCWSTR pcwsz;
        SIZE_T cch;
    } gds[] = {
        { &SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL, SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL_STRING, NUMBER_OF(SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL_STRING) - 1 },
        { &SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY, L"SIAW", 4 },
        { &SXS_INSTALL_REFERENCE_SCHEME_UNINSTALLKEY, L"U", 1 },
        { &SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING, L"S", 1 },
        { &SXS_INSTALL_REFERENCE_SCHEME_KEYFILE, L"F", 1 },
    };
    ULONG ul;

    for ( ul = 0; ul < NUMBER_OF(gds); ul++ )
    {
        if ( *(gds[ul].pguid) == rcGuid )
        {
            IFW32FALSE_EXIT(rbuffIdentifier.Win32Assign(gds[ul].pcwsz, gds[ul].cch));
            break;
        }
    }
    if ( ul == NUMBER_OF(gds) )
    {
        IFW32FALSE_EXIT(::SxspFormatGUID(rcGuid, rbuffIdentifier));
    }
    
    FN_EPILOG
}



BOOL
CAssemblyInstallReferenceInformation::GenerateIdentifierValue(
    OUT CBaseStringBuffer *pbuffTarget
    )
{
    FN_PROLOG_WIN32

    if ( pbuffTarget != NULL )
        pbuffTarget->Clear();

    if (m_fIdentityStuffReady)
    {
        if (pbuffTarget != NULL)
            IFW32FALSE_EXIT(pbuffTarget->Win32Assign(m_buffGeneratedIdentifier));
    }
    else
    {
        const GUID& SchemeGuid = this->GetSchemeGuid();
    
        IFW32FALSE_EXIT(::pMapSchemeGuidToString(SchemeGuid, m_buffGeneratedIdentifier));

        if ((SchemeGuid != SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL) &&
            (SchemeGuid != SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY))
        {
            IFW32FALSE_EXIT(m_buffGeneratedIdentifier.Win32Append(
                SXS_REFERENCE_CHUNK_SEPERATOR,
                SXS_REFERENCE_CHUNK_SEPERATOR_CCH));
                
            if ((SchemeGuid == SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING) ||
                 (SchemeGuid == SXS_INSTALL_REFERENCE_SCHEME_UNINSTALLKEY))
            {
                //
                // Both of these just use the value in the lpIdentifier member.  It was
                // validated above, so it's OK to use here directly
                //
                IFW32FALSE_EXIT(m_buffGeneratedIdentifier.Win32Append(this->GetIdentifier()));
            }
            else if (SchemeGuid == SXS_INSTALL_REFERENCE_SCHEME_KEYFILE)
            {
                CSmallStringBuffer buffDrivePath;
                CSmallStringBuffer buffFilePart;
                DWORD dwDriveSerialNumber = 0;
                
                IFW32FALSE_EXIT(this->GenerateFileReference(
                    this->GetIdentifier(),
                    buffDrivePath,
                    buffFilePart,
                    dwDriveSerialNumber));

                //
                // Now form up the value stuff.
                //
                IFW32FALSE_EXIT(buffDrivePath.Win32EnsureTrailingPathSeparator());
                buffFilePart.RemoveLeadingPathSeparators();
                IFW32FALSE_EXIT(m_buffGeneratedIdentifier.Win32FormatAppend(
                    L"%ls;%08lx;%ls",
                    static_cast<PCWSTR>(buffDrivePath),
                    dwDriveSerialNumber,
                    static_cast<PCWSTR>(buffFilePart)));
            }

        }

        this->m_fIdentityStuffReady = TRUE;
        if ( pbuffTarget != NULL )
        {
            IFW32FALSE_EXIT(pbuffTarget->Win32Assign(m_buffGeneratedIdentifier));
        }
    }

    FN_EPILOG
}

BOOL
CAssemblyInstallReferenceInformation::Initialize(
    PCSXS_INSTALL_REFERENCEW pRefData
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(pRefData != NULL);

    // 
    // One of our good GUIDs
    //
    PARAMETER_CHECK(
        (pRefData->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL) ||
        (pRefData->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING) ||
        (pRefData->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_UNINSTALLKEY) ||
        (pRefData->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_KEYFILE) ||
        (pRefData->guidScheme == SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY));

    //
    // If this is not the OS-install scheme, or the SxsInstallAssemblyW legacy API,
    // then ensure that there's at least the identifier data present.
    //
    if ((pRefData->guidScheme != SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL) && 
        (pRefData->guidScheme != SXS_INSTALL_REFERENCE_SCHEME_SXS_INSTALL_ASSEMBLY))
    {
        PARAMETER_CHECK((pRefData->lpIdentifier != NULL) && (pRefData->lpIdentifier[0] != UNICODE_NULL));
    }
        
    this->m_fIdentityStuffReady = FALSE;
    this->m_dwFlags = pRefData->dwFlags;
    this->m_SchemeGuid = pRefData->guidScheme;

    if ( pRefData->lpIdentifier != NULL)
    {
        IFW32FALSE_EXIT(this->m_buffIdentifier.Win32Assign( 
            pRefData->lpIdentifier, 
            ::wcslen(pRefData->lpIdentifier)));
    }
    
    if ( pRefData->lpNonCanonicalData != NULL )
    {
        IFW32FALSE_EXIT(this->m_buffNonCanonicalData.Win32Assign(
            pRefData->lpNonCanonicalData,
            ::wcslen(pRefData->lpNonCanonicalData)));
    }

    IFW32FALSE_EXIT(this->GenerateIdentifierValue());

    FN_EPILOG
}


BOOL 
CAssemblyInstallReferenceInformation::AcquireContents( 
    const CAssemblyInstallReferenceInformation& rcOther
    )
{
    FN_PROLOG_WIN32

    if (m_IdentityReference.IsInitialized())
        IFW32FALSE_EXIT(m_IdentityReference.Assign(rcOther.m_IdentityReference));
    else
        IFW32FALSE_EXIT(m_IdentityReference.Initialize(rcOther.m_IdentityReference));
        
    IFW32FALSE_EXIT(m_buffGeneratedIdentifier.Win32Assign(rcOther.m_buffGeneratedIdentifier));
    IFW32FALSE_EXIT(m_buffIdentifier.Win32Assign(rcOther.m_buffIdentifier));
    IFW32FALSE_EXIT(m_buffNonCanonicalData.Win32Assign(rcOther.m_buffNonCanonicalData));
    m_dwFlags = rcOther.m_dwFlags;
    m_fIdentityStuffReady = rcOther.m_fIdentityStuffReady;
    m_SchemeGuid = rcOther.m_SchemeGuid;

    FN_EPILOG
}


BOOL 
CAssemblyInstallReferenceInformation::IsReferencePresentIn( 
    const CFusionRegKey &rhkQueryKey,
    BOOL &rfPresent,
    BOOL *pfNonCanonicalDataMatches
    ) const
{
    FN_PROLOG_WIN32

    CSmallStringBuffer buffData;
    DWORD dwError = 0;

    if ( pfNonCanonicalDataMatches )
        *pfNonCanonicalDataMatches = FALSE;

    INTERNAL_ERROR_CHECK(this->m_fIdentityStuffReady);

    IFW32FALSE_EXIT(
        ::FusionpRegQuerySzValueEx(
            0,
            rhkQueryKey,
            this->m_buffGeneratedIdentifier,
            buffData,
            dwError,
            2,
            ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND));

    rfPresent = (dwError == ERROR_SUCCESS);

    if (pfNonCanonicalDataMatches)
    {
        bool fMatchesTemp;
        IFW32FALSE_EXIT(this->m_buffNonCanonicalData.Win32Equals(buffData, fMatchesTemp, true));
        rfPresent = fMatchesTemp;
    }

    FN_EPILOG
}

BOOL 
CAssemblyInstallReferenceInformation::DeleteReferenceFrom( 
    const CFusionRegKey &rhkQueryKey,
    BOOL &rfWasDeleted
    ) const
{
    FN_PROLOG_WIN32

    DWORD dwWin32Error;

    rfWasDeleted = FALSE;

    INTERNAL_ERROR_CHECK(this->m_fIdentityStuffReady);

    IFW32FALSE_EXIT(
        rhkQueryKey.DeleteValue(
            m_buffGeneratedIdentifier,
            dwWin32Error,
            2,
            ERROR_FILE_NOT_FOUND,
            ERROR_PATH_NOT_FOUND));

    rfWasDeleted = (dwWin32Error == ERROR_SUCCESS);

    FN_EPILOG
}


BOOL 
CInstalledItemEntry::AcquireContents( 
    const CInstalledItemEntry &other 
    )
{
    FN_PROLOG_WIN32

    m_dwValidItems = other.m_dwValidItems;
    
    if ( m_dwValidItems & CINSTALLITEM_VALID_REFERENCE )
    {
        IFW32FALSE_EXIT(m_InstallReference.AcquireContents(other.m_InstallReference));
    }

    if ( m_dwValidItems & CINSTALLITEM_VALID_RECOVERY )
    {
        IFW32FALSE_EXIT(m_RecoveryInfo.CopyValue(other.m_RecoveryInfo));
        IFW32FALSE_EXIT(m_CodebaseInfo.Initialize(other.m_CodebaseInfo));
    }

    if ( m_dwValidItems & CINSTALLITEM_VALID_LOGFILE )
    {
        IFW32FALSE_EXIT(m_buffLogFileName.Win32Assign(other.m_buffLogFileName));
    }

    if ( m_dwValidItems & CINSTALLITEM_VALID_IDENTITY )
    {
        m_AssemblyIdentity.Finalize();

        IFW32FALSE_EXIT(::SxsDuplicateAssemblyIdentity(
            0, 
            other.m_AssemblyIdentity, 
            &m_AssemblyIdentity));
    }

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsntrtl.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "sxsp.h"
#include "windows.h"
#include "ntexapi.h"

#define HASH_ALGORITHM HASH_STRING_ALGORITHM_X65599

ULONG
SxspSetLastNTError(
    NTSTATUS Status
    );

BOOL
SxspGetAssemblyRootDirectoryHelper(
    SIZE_T CchBuffer,
    WCHAR Buffer[],
    SIZE_T *CchWritten
    )
{
    BOOL fSuccess = FALSE;
    const PCWSTR NtSystemRoot = USER_SHARED_DATA->NtSystemRoot;
    const SIZE_T cchSystemRoot = wcslen(NtSystemRoot);
    #define SLASH_WINSXS_SLASH L"\\WinSxS\\"
    const SIZE_T cch = cchSystemRoot + (NUMBER_OF(SLASH_WINSXS_SLASH) - 1);

    if ((CchBuffer == 0) && (CchWritten == NULL))
    {
        ::SxspSetLastNTError(STATUS_INVALID_PARAMETER);
        goto Exit;
    }

    if ((CchBuffer != 0) && (Buffer == NULL))
    {
        ::SxspSetLastNTError(STATUS_INVALID_PARAMETER);
        goto Exit;
    }

    if (cch > CchBuffer)
    {
        if (CchWritten != NULL)
        {
            *CchWritten = cch;
        }
        if (Buffer != NULL)
        {
            ::SxspSetLastNTError(STATUS_BUFFER_TOO_SMALL);
        }
        else
        {
            fSuccess = TRUE;
        }
        goto Exit;
    }

    memcpy(Buffer, NtSystemRoot, cchSystemRoot * sizeof(WCHAR));
    memcpy(Buffer + cchSystemRoot, SLASH_WINSXS_SLASH, sizeof(SLASH_WINSXS_SLASH));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

ULONG
SxspSetLastNTError(
    NTSTATUS Status
    )
{
    ULONG dwErrorCode;
    dwErrorCode = ::FusionpRtlNtStatusToDosError(Status);
    ::FusionpSetLastWin32Error(dwErrorCode);
    return dwErrorCode;
}

BOOL
SxspHashString(
    PCWSTR String,
    SIZE_T cch,
    PULONG HashValue,
    bool CaseInsensitive
    )
{
    UNICODE_STRING s;
    NTSTATUS Status = STATUS_SUCCESS;

    s.MaximumLength = static_cast<USHORT>(cch * sizeof(WCHAR));
    // check for overflow
    if (s.MaximumLength != (cch * sizeof(WCHAR)))
    {
        ::SxspSetLastNTError(STATUS_NAME_TOO_LONG);
        return FALSE;
    }
    s.Length = s.MaximumLength;
    s.Buffer = const_cast<PWSTR>(String);

    Status = ::FusionpRtlHashUnicodeString(&s, CaseInsensitive, HASH_ALGORITHM, HashValue);
    if (!NT_SUCCESS(Status))
        ::SxspSetLastNTError(Status);

    return (NT_SUCCESS(Status));
}

ULONG
SxspGetHashAlgorithm(VOID)
{
    return HASH_ALGORITHM;
}

BOOL
SxspCreateLocallyUniqueId(
    OUT PSXSP_LOCALLY_UNIQUE_ID psxsLuid
    )
{
    FN_PROLOG_WIN32
    static WORD     s_wMilliseconds = 0;
    static ULONG    s_ulUniquification = 0;
    SYSTEMTIME      stLocalTime;

    PARAMETER_CHECK(psxsLuid != NULL);

    GetSystemTime(&stLocalTime);
    IFW32FALSE_EXIT(SystemTimeToTzSpecificLocalTime(NULL, &stLocalTime, &psxsLuid->stTimeStamp));

    if (psxsLuid->stTimeStamp.wMilliseconds == s_wMilliseconds)
    {
        s_ulUniquification = ::SxspInterlockedIncrement(&s_ulUniquification);
    }
    else
    {
        s_wMilliseconds = psxsLuid->stTimeStamp.wMilliseconds;
        s_ulUniquification = 0;        
    }
    
    psxsLuid->ulUniquifier = s_ulUniquification;

    FN_EPILOG
}

#define CHARS_IN_TIMESTAMP          (4 + (2*5) + 3 + 10)     // 8 * 4 + 4

BOOL
SxspFormatLocallyUniqueId(
    IN const SXSP_LOCALLY_UNIQUE_ID &rsxsLuid,
    OUT CBaseStringBuffer &rbuffUidBuffer
    )
{
    FN_PROLOG_WIN32

    if (rbuffUidBuffer.GetBufferCb() < CHARS_IN_TIMESTAMP)
    {
        IFW32FALSE_EXIT(rbuffUidBuffer.Win32ResizeBuffer(
            CHARS_IN_TIMESTAMP, 
            eDoNotPreserveBufferContents));
    }
    else
    {
        //
        // The caller may have previously grown the buffer
        // larger because they are putting in the
        // unique id followed by additional text. Don't
        // change the size on them.
        //
    }

    IFW32FALSE_EXIT(rbuffUidBuffer.Win32Format(
        L"%04u%02u%02u%02u%02u%02u%03u.%u",
        rsxsLuid.stTimeStamp.wYear,
        rsxsLuid.stTimeStamp.wMonth,
        rsxsLuid.stTimeStamp.wDay,
        rsxsLuid.stTimeStamp.wHour,
        rsxsLuid.stTimeStamp.wMinute,
        rsxsLuid.stTimeStamp.wSecond,
        rsxsLuid.stTimeStamp.wMilliseconds,
        rsxsLuid.ulUniquifier));
        
    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsoleaut.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsoleaut.cpp

Abstract:

    Implementation of helper functions called by oleaut32.dll to
    get type library and clsid isolation.

Author:

    Michael J. Grier (MGrier) 19-May-2000

Revision History:

  Jay Krell (JayKrell) November 2001
    fixed typelibrary redirection
    key typelibraries by guid only, then verify language

--*/

#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "fusionhandle.h"

typedef const GUID * PCGUID;

typedef CGenericStringBuffer<1, CUnicodeCharTraits> CSmallestUnicodeStringBuffer;

extern "C"
{
extern const CLSID CLSID_PSDispatch;
extern const CLSID CLSID_PSAutomation;
};

HRESULT
FusionpWin32GetAssemblyDirectory(
    PCACTCTX_SECTION_KEYED_DATA askd,
    CBaseStringBuffer &         rbuf
    );

HRESULT
HrFusionpWin32GetAssemblyDirectory(
    PCACTCTX_SECTION_KEYED_DATA askd,
    CBaseStringBuffer &         rbuff
    );

BOOL
FusionpHasAssemblyDirectory(
    PCACTCTX_SECTION_KEYED_DATA askd
    );

HRESULT
HrFusionpOleaut_CopyString(
    PWSTR       Buffer,
    SIZE_T      BufferSizeAvailable,
    SIZE_T *    BufferSizeWrittenOrRequired,
    PCWSTR      String,
    SIZE_T      Length
    )
{
    HRESULT hr;

    if (BufferSizeAvailable >= (Length + 1))
    {
        if (Buffer != NULL)
        {
            ::memcpy(Buffer, String, (Length * sizeof(WCHAR)));
            Buffer[Length] = L'\0';
        }
        *BufferSizeWrittenOrRequired = Length;
        hr = NOERROR;
    }
    else
    {
        // Need ... more .... room!
        *BufferSizeWrittenOrRequired = (Length + 1);
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }
Exit:
    return hr;
}

HRESULT
HrFusionpOleaut_GetTypeLibraryName(
    PCACTCTX_SECTION_KEYED_DATA askd,
    PCWSTR *                    ppsz,
    SIZE_T *                    pcch
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);
    ULONG cch = 0;
    PCWSTR psz = 0;

    if (ppsz != NULL)
        *ppsz = NULL;
    if (pcch != NULL)
        *pcch = 0;
    INTERNAL_ERROR_CHECK(askd != NULL);
    INTERNAL_ERROR_CHECK(ppsz != NULL);
    INTERNAL_ERROR_CHECK(pcch != NULL);

    PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION  Data = reinterpret_cast<PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION>(askd->lpData);

    if (Data->NameOffset == 0)
    {
        psz = NULL;
        cch = 0;
    }
    else
    {
        psz = reinterpret_cast<PCWSTR>(reinterpret_cast<ULONG_PTR>(askd->lpSectionBase) + Data->NameOffset);
        cch = Data->NameLength / sizeof(WCHAR);
        if (cch != 0 && psz[cch - 1] == 0)
            cch -= 1;
    }
    *ppsz = psz;
    *pcch = cch;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
HrFusionpOleaut_GetTypeLibraryFullPath(
    PCACTCTX_SECTION_KEYED_DATA askd,
    CBaseStringBuffer &         rbuff
    )
{
    FN_PROLOG_HR
    PCWSTR TypeLibraryName = NULL;
    SIZE_T TypeLibraryNameLength = 0;
    HANDLE ActivationContextHandle = NULL;

    IFCOMFAILED_EXIT(HrFusionpOleaut_GetTypeLibraryName(askd, &TypeLibraryName, &TypeLibraryNameLength));
    IFW32FALSE_EXIT(FusionpGetActivationContextFromFindResult(askd, &ActivationContextHandle));
    IFW32FALSE_EXIT(FusionpSearchPath(
        FUSIONP_SEARCH_PATH_ACTCTX,
        NULL, // path to search
        TypeLibraryName,
        NULL, // extension
        rbuff,
        NULL, // offset to file part
        ActivationContextHandle
        ));

    FN_EPILOG
}


#define FUSIONP_OLEAUT_HANDLE_FIND_ERROR() \
    do { \
        const DWORD dwLastError = ::FusionpGetLastWin32Error(); \
\
        if ((dwLastError == ERROR_SXS_KEY_NOT_FOUND) || (dwLastError == ERROR_SXS_SECTION_NOT_FOUND)) \
        { \
            hr = S_FALSE; \
            goto Exit; \
        } \
\
        hr = HRESULT_FROM_WIN32(dwLastError); \
        goto Exit; \
    } while(0)

EXTERN_C
HRESULT
STDAPICALLTYPE
SxsOleAut32MapReferenceClsidToConfiguredClsid(
    REFCLSID rclsidIn,
    CLSID *pclsidOut
    )
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    ACTCTX_SECTION_KEYED_DATA askd;
    PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION Data = NULL;

    PARAMETER_CHECK(pclsidOut != NULL);

    askd.cbSize = sizeof(askd);

    if (!::FindActCtxSectionGuid(
            0,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION,
            &rclsidIn,
            &askd))
    {
        FUSIONP_OLEAUT_HANDLE_FIND_ERROR();
    }

    Data = (PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION) askd.lpData;

    if ((askd.ulDataFormatVersion != ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_FORMAT_WHISTLER) ||
        (askd.ulLength < sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)) ||
        (Data->Size < sizeof(ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_SXS_INVALID_ACTCTXDATA_FORMAT);
        goto Exit;
    }

    // We should be clear to go now.
    if (pclsidOut != NULL)
        *pclsidOut = Data->ConfiguredClsid;

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
SxspOleAut32RedirectTypeLibrary(
    LPCOLESTR szGuid,
    WORD wMaj,
    WORD wMin,
    LANGID langid,
    SIZE_T *pcchFileName,
    LPOLESTR rgFileName
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);

    CFusionActCtxHandle ActCtxHandle;

    PARAMETER_CHECK(szGuid != NULL);
    PARAMETER_CHECK(pcchFileName != NULL);
    PARAMETER_CHECK((rgFileName != NULL) || (*pcchFileName));

    ACTCTX_SECTION_KEYED_DATA askd;
    PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION Data = NULL;

    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER AssemblyRosterHeader = NULL;
    PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY  AssemblyRosterEntry = NULL;

    askd.cbSize = sizeof(askd);
    askd.hActCtx = NULL;

    {
        GUID Guid;

        IFW32FALSE_EXIT(SxspParseGUID(szGuid, ::wcslen(szGuid), Guid));
        if (!::FindActCtxSectionGuid(
            FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX
            | FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS
            | FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION,
            &Guid,
            &askd))
        {
            FUSIONP_OLEAUT_HANDLE_FIND_ERROR();
        }
    }
    ActCtxHandle = askd.hActCtx; // ReleaseActCtx in destructor

    Data = (PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION) askd.lpData;

    if ((askd.ulDataFormatVersion != ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_FORMAT_WHISTLER) ||
        (askd.ulLength < sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION)) ||
        (Data->Size < sizeof(ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_SXS_INVALID_ACTCTXDATA_FORMAT);
        goto Exit;
    }

    if (langid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
    {
        ULONG  LanguageLength = 0;
        PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION AssemblyInformation = NULL;

        AssemblyInformation = reinterpret_cast<PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION>(askd.AssemblyMetadata.lpInformation);

        LanguageLength = (AssemblyInformation->LanguageLength / sizeof(WCHAR));
        if (LanguageLength != 0)
        {
            CSmallestUnicodeStringBuffer Cultures[2];
            PCWSTR LanguageString = NULL;

            // we should do bounds checking here against AssemblyMetadata.ulSectionLength
            LanguageString = reinterpret_cast<PCWSTR>(AssemblyInformation->LanguageOffset + reinterpret_cast<PCBYTE>(askd.AssemblyMetadata.lpSectionBase));

            IFW32FALSE_EXIT(SxspMapLANGIDToCultures(langid, Cultures[0], Cultures[1]));

            if (LanguageLength != 0 && LanguageString[LanguageLength - 1] == 0)
               LanguageLength -= 1;
            if (   !FusionpEqualStringsI(LanguageString, LanguageLength, Cultures[0])
                && !FusionpEqualStringsI(LanguageString, LanguageLength, Cultures[1])
                )
            {
               hr = S_FALSE;
               goto Exit;
            }
        }
    }
    if (wMaj != 0 || wMin != 0)
    {
        if (wMaj != Data->Version.Major)
        {
            hr = S_FALSE;
            goto Exit;
        }
        if (wMin > Data->Version.Minor)
        {
            hr = S_FALSE;
            goto Exit;
        }
    }


    {
        CSmallestUnicodeStringBuffer buff;

        IFCOMFAILED_EXIT(HrFusionpOleaut_GetTypeLibraryFullPath(&askd, buff));

        IFCOMFAILED_EXIT(
            HrFusionpOleaut_CopyString(
                rgFileName,
                *pcchFileName,
                pcchFileName,
                static_cast<PCWSTR>(buff),
                buff.Cch()
                ));
    }

    hr = NOERROR;
Exit:
    return hr;
}

LANGID
FusionpLanguageIdFromLocaleId(
    LCID lcid
    )
{
    //
    // LANGIDFROMLCID does not actually remove non default sort.
    //
    LANGID Language = LANGIDFROMLCID(lcid);
    ULONG PrimaryLanguage = PRIMARYLANGID(Language);
    ULONG SubLanguage = SUBLANGID(Language);
    Language = MAKELANGID(PrimaryLanguage, SubLanguage);
    return Language;
}

EXTERN_C
HRESULT
STDAPICALLTYPE
SxsOleAut32RedirectTypeLibrary(
    LPCOLESTR szGuid,
    WORD wMaj,
    WORD wMin,
    LCID lcid,
    BOOL /*fHighest*/,
    SIZE_T *pcchFileName,
    LPOLESTR rgFileName
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);

    PARAMETER_CHECK(szGuid != NULL);
    PARAMETER_CHECK(pcchFileName != NULL);
    PARAMETER_CHECK(rgFileName != NULL || *pcchFileName == 0);

    IFCOMFAILED_EXIT(hr = ::SxspOleAut32RedirectTypeLibrary(szGuid, wMaj, wMin, FusionpLanguageIdFromLocaleId(lcid), pcchFileName, rgFileName));
Exit:
    return hr;
}


HRESULT
HrFusionpOleaut_MapIIDToTLBID(
    REFIID  riid,
    PCGUID* ppctlbid
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);

    ACTCTX_SECTION_KEYED_DATA askd;
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Data = 0;

    PARAMETER_CHECK(&riid != NULL);
    PARAMETER_CHECK(ppctlbid != NULL);

    *ppctlbid = NULL;
    askd.cbSize = sizeof(askd);

    if (!::FindActCtxSectionGuid(
            0,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION,
            &riid,
            &askd))
    {
        FUSIONP_OLEAUT_HANDLE_FIND_ERROR();
    }
    Data = reinterpret_cast<PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION>(askd.lpData);
    *ppctlbid = &Data->TypeLibraryId;

    hr = NOERROR;
Exit:
    return hr;
}

EXTERN_C
HRESULT
STDAPICALLTYPE
SxsOleAut32MapIIDToTLBPath(
    REFIID riid,
    SIZE_T cchBuffer,
    WCHAR *pBuffer,
    SIZE_T *pcchWrittenOrRequired
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);
    ACTCTX_SECTION_KEYED_DATA askd;
    PCGUID pctlbid = NULL;
    CSmallStringBuffer buff;
    CFusionActCtxHandle ActCtxHandle;

    PARAMETER_CHECK(&riid != NULL);
    PARAMETER_CHECK(pBuffer != NULL);
    PARAMETER_CHECK(pcchWrittenOrRequired != NULL);
    PARAMETER_CHECK(cchBuffer != 0);

    IFCOMFAILED_EXIT(hr = HrFusionpOleaut_MapIIDToTLBID(riid, &pctlbid));
	if (hr == S_FALSE)
	{
		goto Exit;
	}
    askd.cbSize = sizeof(askd);
    if (!::FindActCtxSectionGuid(
            FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX
            | FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION,
            pctlbid,
            &askd))
    {
        FUSIONP_OLEAUT_HANDLE_FIND_ERROR();
    }
    ActCtxHandle = askd.hActCtx; // ReleaseActCtx in destructor

    IFCOMFAILED_EXIT(HrFusionpOleaut_GetTypeLibraryFullPath(&askd, buff));

    //
    // We do not care about version or language in this case.
    //
    IFCOMFAILED_EXIT(
        HrFusionpOleaut_CopyString(
            pBuffer,
            cchBuffer,
            pcchWrittenOrRequired,
            static_cast<PCWSTR>(buff),
            buff.Cch()
            ));

    hr = NOERROR;
Exit:
    return hr;
}

EXTERN_C
HRESULT
STDAPICALLTYPE
SxsOleAut32MapIIDToProxyStubCLSID(
    REFIID  riid,
    CLSID * pclsidOut
    )
{
    HRESULT hr = E_UNEXPECTED;
    FN_TRACE_HR(hr);

    ACTCTX_SECTION_KEYED_DATA askd;
    PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION Data = 0;

    if (pclsidOut != NULL)
        *pclsidOut = GUID_NULL;
    PARAMETER_CHECK(&riid != NULL);
    PARAMETER_CHECK(pclsidOut != NULL);

    askd.cbSize = sizeof(askd);
    if (!::FindActCtxSectionGuid(
            0,
            NULL,
            ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION,
            &riid,
            &askd))
    {
        FUSIONP_OLEAUT_HANDLE_FIND_ERROR();
    }
    Data = reinterpret_cast<PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION>(askd.lpData);

    *pclsidOut = Data->ProxyStubClsid32;

    //
    // There are only USUALLY two acceptable answers here.
    // (but there is one bit of code in oleaut32.dll that is
    // actually look for anything but these two.)
    //
    // CLSID_PSDispatch     {00020424-0000-0000-C000-000000000046}
    // CLSID_PSAutomation   {00020420-0000-0000-C000-000000000046}
    //
#if DBG
    {
        ULONG i;
        const static struct
        {
            const GUID * Guid;
            STRING       Name;
        } GuidNameMap[] = 
        {
            { NULL,                 RTL_CONSTANT_STRING("unknown") },
            { &CLSID_PSDispatch,    RTL_CONSTANT_STRING("CLSID_PSDispatch") },
            { &CLSID_PSAutomation,  RTL_CONSTANT_STRING("CLSID_PSAutomation") }
        };
        for (i = 1 ; i != NUMBER_OF(GuidNameMap) ; ++i)
            if (Data->ProxyStubClsid32 == *GuidNameMap[i].Guid)
                break;
        if (i == NUMBER_OF(GuidNameMap))
            i = 0;

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_VERBOSE | FUSION_DBG_LEVEL_INFO,
            "SXS: %s returning %Z\n",
            __FUNCTION__,
            &GuidNameMap[i].Name
            );
    }
#endif

    hr = NOERROR;
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsinstall.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsinstall.h

Abstract:

    Activation context section contributor for the DLL Redirection section.

Author:

    Jay Krell (a-JayK, JayKrell) April 2000

Revision History:

--*/
#if (_MSC_VER > 1020)
#pragma once
#endif
#include "util.h"
#include "cassemblyrecoveryinfo.h"
#include "actctxgenctx.h"

/*-----------------------------------------------------------------------------
Side By(x) Side Install

most of the work is actually done in dllredir.cpp
-----------------------------------------------------------------------------*/

class CAssemblyInstallReferenceInformation
{
    GUID            m_SchemeGuid;
    CStringBuffer   m_buffIdentifier;
    CStringBuffer   m_buffNonCanonicalData;
    CStringBuffer   m_buffGeneratedIdentifier;
    BOOL            m_fIdentityStuffReady;
    DWORD           m_dwFlags;    

    CAssemblyReference m_IdentityReference;


    PRIVATIZE_COPY_CONSTRUCTORS(CAssemblyInstallReferenceInformation);

public:
    CAssemblyInstallReferenceInformation();

    BOOL Initialize( PCSXS_INSTALL_REFERENCEW RefData );

    const GUID &GetSchemeGuid() const { return m_SchemeGuid; }
    const CBaseStringBuffer &GetIdentifier() const { return m_buffIdentifier; }
    const CBaseStringBuffer &GetGeneratedIdentifier() const { return m_buffGeneratedIdentifier; }
    const CBaseStringBuffer &GetCanonicalData() const { return m_buffNonCanonicalData; }

    DWORD GetFlags() const { return m_dwFlags; }

    BOOL SetIdentity(PCASSEMBLY_IDENTITY pAsmIdent) { return m_IdentityReference.Initialize(pAsmIdent); }

    BOOL ForceReferenceData(PCWSTR pcwszPrecalcedData) {
        FN_PROLOG_WIN32
        IFW32FALSE_EXIT(
            m_buffGeneratedIdentifier.Win32Assign(
                pcwszPrecalcedData,
                pcwszPrecalcedData != NULL ? ::wcslen(pcwszPrecalcedData) : 0));
        m_fIdentityStuffReady = TRUE;
        FN_EPILOG
    }


    BOOL GenerateFileReference(
        IN const CBaseStringBuffer &buffKeyfileName,
        OUT CBaseStringBuffer &buffDrivePath,
        OUT CBaseStringBuffer &buffFilePart,
        OUT DWORD &dwDriveSerial
        );

    const CAssemblyReference &GetIdentity() const { return m_IdentityReference; }
    
    BOOL GenerateIdentifierValue(
        CBaseStringBuffer *pbuffTarget = NULL
        );

    BOOL GetIdentifierValue(CBaseStringBuffer &pBuffTarget) const
    {
        return pBuffTarget.Win32Assign(m_buffGeneratedIdentifier);
    }

    BOOL WriteIntoRegistry(const CFusionRegKey &rhkTargetKey) const;
    BOOL IsReferencePresentIn(const CFusionRegKey &rhkQueryKey, BOOL &rfPresent, BOOL *rfNonCanonicalMatches = NULL) const;
    BOOL DeleteReferenceFrom(const CFusionRegKey &rhkQueryKey, BOOL &rfWasDeleted) const;
    BOOL AcquireContents(const CAssemblyInstallReferenceInformation &);
};

MAKE_CFUSIONARRAY_READY(CAssemblyInstallReferenceInformation, AcquireContents);


#define CINSTALLITEM_VALID_REFERENCE        (0x0000001)
#define CINSTALLITEM_VALID_RECOVERY         (0x0000002)
#define CINSTALLITEM_VALID_IDENTITY         (0x0000004)
#define CINSTALLITEM_VALID_LOGFILE          (0x0000008)

class CInstalledItemEntry
{
    PRIVATIZE_COPY_CONSTRUCTORS(CInstalledItemEntry);
    
public:
    CAssemblyInstallReferenceInformation m_InstallReference;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> m_AssemblyIdentity;
    CAssemblyRecoveryInfo m_RecoveryInfo;
    CSmallStringBuffer m_buffLogFileName;
    CCodebaseInformation m_CodebaseInfo;
    DWORD m_dwValidItems;

    CInstalledItemEntry() : m_dwValidItems(0) { }

    ~CInstalledItemEntry() { }

    BOOL AcquireContents( const CInstalledItemEntry &other ); 
};

MAKE_CFUSIONARRAY_READY(CInstalledItemEntry, AcquireContents);

class CAssemblyInstall
{
public:
    CAssemblyInstall();
    ~CAssemblyInstall() { }

    BOOL
    BeginAssemblyInstall(
        DWORD flags,
        PSXS_INSTALLATION_FILE_COPY_CALLBACK installationCallback,
        PVOID  installationContext,
        const CImpersonationData &ImpersonationData
        );

    enum EInstallStage
    {
        eBegin,
        ePer,
        eEnd
    };

    BOOL
    InstallAssembly(
        DWORD   flags,
        PCWSTR  manifestPath,
        PCSXS_INSTALL_SOURCE_INFO pcsisi,
        PCSXS_INSTALL_REFERENCEW pReference
        );

    BOOL
    EndAssemblyInstall(
        DWORD   flags,
        PVOID   pvReserved = NULL
        );

    BOOL
    InstallFile(
        const CBaseStringBuffer &ManifestPath,
        const CBaseStringBuffer &rbuffRelativeCodebase
        );

    CDirWalk::ECallbackResult
    InstallDirectoryDirWalkCallback(
        CDirWalk::ECallbackReason  reason,
        CDirWalk *pdirWalk,
        DWORD dwFlags,
        DWORD dwWalkDirFlags
        );

    static CDirWalk::ECallbackResult
    StaticInstallDirectoryDirWalkCallback(
        CDirWalk::ECallbackReason  reason,
        CDirWalk *dirWalk,
        DWORD                      dwWalkDirFlags
        );

    BOOL
    InstallDirectory(
        const CBaseStringBuffer &rPath,
        DWORD flags,
        WCHAR wchCodebasePathSeparator
        );

    ACTCTXGENCTX        m_ActCtxGenCtx;
    CImpersonationData  m_ImpersonationData;
    BOOL                m_bSuccessfulSoFar;
    PSXS_INSTALL_SOURCE_INFO m_pInstallInfo;
    CFusionArray<CInstalledItemEntry> m_ItemsInstalled;

    // In parallel to the other paths we're building up, we also build a
    // relative path to the base of the directory walk which uses the
    // path separator(s) that were present in the codebase URL.
    WCHAR               m_wchCodebasePathSeparator;
    CMediumStringBuffer m_buffCodebaseRelativePath;

protected:
    BOOL WriteSingleInstallLog(
        const CInstalledItemEntry &item,
        BOOL bOverWrite = FALSE
        );

    SXS_INSTALL_SOURCE_INFO m_CurrentInstallInfoCopy;

private:
    CAssemblyInstall(const CAssemblyInstall &);
    void operator =(const CAssemblyInstall &);
};

#define SXS_REFERENCE_CHUNK_SEPERATOR       (L"_")
#define SXS_REFERENCE_CHUNK_SEPERATOR_CCH   (NUMBER_OF(SXS_REFERENCE_CHUNK_SEPERATOR)-1)
#define WINSXS_INSTALLATION_REFERENCES_SUBKEY ( L"References")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsp.h ===
/*
Copyright (c) Microsoft Corporation
*/
#if !defined(_FUSION_DLL_WHISTLER_SXSP_H_INCLUDED_)
#define _FUSION_DLL_WHISTLER_SXSP_H_INCLUDED_

/*-----------------------------------------------------------------------------
Side X ("by") Side Private
-----------------------------------------------------------------------------*/
#pragma once

#include <stddef.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "setupapi.h"
#include "preprocessor.h"
#include "forwarddeclarations.h"
#include "enumbitoperations.h"
#include "sxstypes.h"
#include "policystatement.h"
#pragma warning(error:4244)
#include "sxsapi.h"
#include "fusion.h"
#include "fusionhash.h"
#include "fusionhandle.h"
typedef CRegKey CFusionRegKey; // need to change this when using ATL in ManifestTool.exe.
#include "processorarchitecture.h"
#include "debmacro.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "xmlns.h"
#include "sxsasmname.h"
#include "sxsexceptionhandling.h"
#include "filestream.h"
#include <objbase.h>
typedef struct _ACTCTXGENCTX ACTCTXGENCTX, *PACTCTXGENCTX;
typedef const struct _ACTCTXGENCTX *PCACTCTXGENCTX;

//
// This definition controls whether or not we allow fallback probing to the MS published
// assemblies.  Defining SXS_NO_MORE_MR_NICE_GUY_ABOUT_MISSING_MS_PKTS prints a message
// on an attached debugger regarding a missing (ms pubkey token), while
// SXS_NO_MORE_FALLBACK_PROBING_PERIOD turns off even the warning output and probing check
// (perf optimization.)
//
// #undef    SXS_NO_MORE_MR_NICE_GUY_ABOUT_MISSING_MS_PKTS
#define    SXS_NO_MORE_MR_NICE_GUY_ABOUT_MISSING_MS_PKTS        ( TRUE )
#undef    SXS_NO_MORE_FALLBACK_PROBING_PERIOD
//#define    SXS_NO_MORE_FALLBACK_PROBING_PERIOD                        ( TRUE )

//
// Here we define the minimal number of bits that a catalog signer must have
// to allow installation.  NOTE: The length of any key will be lied about by
// CPublicKeyInformation.GetPublicKeyBitLength if the test root certificate is
// installed.  If so, then it always returns SXS_MINIMAL_SIGNING_KEY_LENGTH!
//
#define SXS_MINIMAL_SIGNING_KEY_LENGTH    ( 2048 )


extern "C"
BOOL
WINAPI
SxsDllMain(
    HINSTANCE hInst,
    DWORD dwReason,
    PVOID pvReserved
    );

// Due to dependencies, the rest of the includes are later in the file.

#ifndef INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT_ALLOCATE_NOW
#define INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT_ALLOCATE_NOW ( 0x8000000 )
#endif

#define SXS_DEFAULT_ASSEMBLY_NAMESPACE          L""
#define SXS_DEFAULT_ASSEMBLY_NAMESPACE_CCH      0

typedef struct _name_length_pair_ {
    PCWSTR  string;
    ULONG length;
} SXS_NAME_LENGTH_PAIR;

#define SXS_UNINSTALL_ASSEMBLY_FLAG_USING_TEXTUAL_STRING      (0x00000001)
#define SXS_UNINSTALL_ASSEMBLY_FLAG_USING_INSTALL_LOGFILE     (0x00000002)

//
//  Legend for decoding probing strings:
//
//  First, we walk the string from beginning to end.  Normally, characters are copied to the
//  probe string literally.
//
//  If $ is found, the character after $ is an identifier for a replacement token.
//
//  Replacement tokens (note that case is sensitive and $ followed by an illegal character results in an internal error reported):
//
//      M - "%systemroot%\winsxs\manifests\"
//      . - Application root (including trailing slash)
//      L - langauge
//      N - full assembly text name
//      C - combined name (e.g. x86_foo.bar.baz_strong-name_language_version_hash)
//


#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_ROOT_SYSTEM_MANIFEST_STORE (1)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_ROOT_APPLICATION_DIRECTORY (2)

#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_NONE (0)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_ASSEMBLY_TEXT_NAME (1)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_ASSEMBLY_TEXT_SHORTENED_NAME (2)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_ASSEMBLY_TEXT_NAME_FINAL_SEGMENT (3)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_ASSEMBLY_DIRECTORY_NAME (4)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_LANGUAGE (5)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_IDENTITY_INCLUSION_VERSION (6)

#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_MANIFEST_FILE_TYPE_INVALID (0)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_MANIFEST_FILE_TYPE_FINAL_SEGMENT (1)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_MANIFEST_FILE_TYPE_SHORTENED_NAME (2)
#define SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR_MANIFEST_FILE_TYPE_NAME (3)

#define SXS_GENERATE_ACTCTX_SYSTEM_DEFAULT                          (0x0001)
#define SXS_GENERATE_ACTCTX_APP_RUNNING_IN_SAFEMODE                 (0x0002)

typedef struct _SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR
{
    ULONG Root;
    const WCHAR *SubDirectory;
    SIZE_T CchSubDirectory;
    ULONG FileType; // Only used for private probing to control order of .manifest vs. .dll probing
    const WCHAR *Extension;
    SIZE_T CchExtension;
    ULONG IdentityInclusionArray[8];
} SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR, *PSXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR;

typedef const SXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR *PCSXSP_GENERATE_MANIFEST_PATH_FOR_PROBING_CANDIDATE_DESCRIPTOR;

#define UNCHECKED_DOWNCAST static_cast

#define ASSEMBLY_PRIVATE_MANIFEST            (0x10)
#define ASSEMBLY_PRIVATE_MANIFEST_MASK       (0xF0)

typedef enum _SXS_POLICY_SOURCE
{
    SXS_POLICY_UNSPECIFIED,
    SXS_POLICY_SYSTEM_POLICY,
    SXS_POLICY_ROOT_POLICY,
    SXS_POLICY_REDMOND_POLICY
} SXS_POLICY_SOURCE;

typedef enum _SXS_PUBLISHER_POLICY_APPLY
{
    SXS_PUBLISHER_POLICY_APPLY_DEFAULT,
    SXS_PUBLISHER_POLICY_APPLY_YES,
    SXS_PUBLISHER_POLICY_APPLY_NO
} SXS_PUBLISHER_POLICY_APPLY;


#define ACTCTXDATA_ALIGNMENT_BITS (2)
#define ACTCTXDATA_ALIGNMENT (1 << ACTCTXDATA_ALIGNMENT_BITS)
#define ROUND_ACTCTXDATA_SIZE(_cb) (((_cb) + ACTCTXDATA_ALIGNMENT - 1) & (~(ACTCTXDATA_ALIGNMENT - 1)))
#define ALIGN_ACTCTXDATA_POINTER(_ptr, _type) ((_type) ROUND_ACTCTXDATA_SIZE(((ULONG_PTR) (_ptr))))

#include "fusionheap.h"
#include "util.h"
#include "comclsidmap.h"
#include "actctxgenctxctb.h"
#include "impersonationdata.h"
#include "fusionbuffer.h"
#include "fileoper.h"
// Due to dependencies, the rest of the includes are later in the file.

/*-----------------------------------------------------------------------------
This is useful like so:
    DbgPrint("something happened in %s", __FUNCTION__);
approx:
    LogError(L"something happened in %1", LFUNCTION);
but the string is actually in a message file and the extra parameters must
be passed as const UNICODE_STRING&, so more like:
    LogError(MSG_SXS_SOMETHING_HAPPENED, CUnicodeString(LFUNCTION));
-----------------------------------------------------------------------------*/
#define LFUNCTION   PASTE(L, __FUNCTION__)
#define LFILE       PASTE(L, __FILE__)

#if DBG
#define IF_DBG(x) x
#else
#define IF_DBG(x) /* nothing */
#endif

// This global is used for testing/debugging to set the assembly store root
// to something other than %windir%\winsxs
extern PCWSTR g_AlternateAssemblyStoreRoot;
extern BOOL g_WriteRegistryAnyway;

/*
    If they've set the alternate assembly store root, then they probably don't want
    us messing with the registry - unless, of course, they really want us to.

    if ((g_AlternateAssemblyStoreRoot == NULL) || g_WriteRegistryAnyway)
        continue;

    is the same as:

    if ((g_AlternateAssemblyStoreRoot != NULL) && !g_WriteRegistryAnyway)
        return TRUE;
*/
inline
BOOL
SxspAvoidWritingRegistry()
{
    return (g_AlternateAssemblyStoreRoot != NULL) && !g_WriteRegistryAnyway;
}
#define SXS_AVOID_WRITING_REGISTRY SxspAvoidWritingRegistry()

/*-----------------------------------------------------------------------------
copied from \\jayk1\g\vs\src\vsee\lib
Usage

If you say

OutputDebugStringA(PREPEND_FILE_LINE("foo"))
or

CStringBuffer msg;
msg.Format(PREPEND_FILE_LINE("foo%bar%x"), ...)
OutputDebugStringA(msg)
or

pragma message (PREPEND_FILE_LINE("foo"))

you can F4 through the output in VC's output window.

Don't checkin #pragma messages though.
-----------------------------------------------------------------------------*/
#define PREPEND_FILE_LINE(msg) __FILE__ "(" STRINGIZE(__LINE__) ") : " msg
#define PREPEND_FILE_LINE_W(msg) LFILE L"(" STRINGIZEW(__LINE__) L") : " msg

/*-----------------------------------------------------------------------------
Length = 0
MaximumLength = 0
Buffer = L""
-----------------------------------------------------------------------------*/
extern const UNICODE_STRING g_strEmptyUnicodeString;

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) ((sizeof(x)) / sizeof((x)[0]))
#endif

#define PATCHES_PATH_IN_CAB                                     L"patches"
#define PATCHES_PATH_IN_CAB_CCH                                 (NUMBER_OF(PATCHES_PATH_IN_CAB)-1)
#define MANIFEST_ROOT_DIRECTORY_NAME                            L"manifests"
#define POLICY_ROOT_DIRECTORY_NAME                              L"policies"
#define SETUP_POLICY_ROOT_DIRECTORY_NAME                        L"setuppolicies"

#define ASSEMBLY_TYPE_WIN32                                     L"win32"
#define ASSEMBLY_TYPE_WIN32_CCH                                 (NUMBER_OF(ASSEMBLY_TYPE_WIN32) - 1)

#define ASSEMBLY_TYPE_WIN32_POLICY                              L"win32-policy"
#define ASSEMBLY_TYPE_WIN32_POLICY_CCH                          (NUMBER_OF(ASSEMBLY_TYPE_WIN32_POLICY) - 1)

#define REGISTRY_BACKUP_ROOT_DIRECTORY_NAME                     L"recovery"
#define REGISTRY_BACKUP_ROOT_DIRECTORY_NAME_CCH                 (NUMBER_OF(REGISTRY_BACKUP_ROOT_DIRECTORY_NAME)-1)

#define ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_MANIFEST             L".manifest"
#define ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_DLL                  L".dll"
#define ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_MAN                  L".man"

#define ASSEMBLY_POLICY_FILE_NAME_SUFFIX_POLICY                 L".policy"

#define ASSEMBLY_LONGEST_MANIFEST_FILE_NAME_SUFFIX              L".manifest"
/* term is either L"\0" or , */
#define ASSEMBLY_MANIFEST_FILE_NAME_SUFFIXES(term)              L".manifest" term L".dll" term L".policy" term
#define INSTALL_MANIFEST_FILE_NAME_SUFFIXES(term)  L".Man" term L".manifest" term L".dll" term L".policy" term

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE L"no-public-key"

//
// This is the all-powerful public key token (in hex-string format) that is the
// Microsoft Windows Whistler Win32 Fusion public key token.  Don't change this
// unless a) you get a new key b) you update all the manifests that contain this
// string c) you really really really want a headache.
//
#define SXS_MS_PUBLIC_KEY_TOKEN_DEFAULT ( L"6595b64144ccf1df" )
#define SXS_MS_PUBLIC_KEY_DEFAULT ( \
    L"002400000480000014010000060200000024000052534131" \
    L"0008000001000100d5938fed940a72fe45232d867d252f87" \
    L"0097e0039ffbf647ebd8817bbeaefbbbf68ce55e2542769e" \
    L"8a43e5880daa307ff50783d3b157ac9fc3d5410259bd0111" \
    L"56d60bcd4c10d2ace51445e825ef6b1929d187360b08c7e1" \
    L"bc73a2c6f78434729eb58e481bb3635ecfdfcb683119dc61" \
    L"f5d29226e8c9d7ac415d53992ca9714722abfcfd88efd3e3" \
    L"46ef02b83b4dbbf429e026b1889a6ba228fdb5709be852e1" \
    L"e81c011a6a18055f898863ccd4902041543c6cf10efb038b" \
    L"5ab34f1bfa18d3affa01d4980a979606abd3b7ccdae2e0ae" \
    L"a0d875c2d4df5509a234d9dd840ef7be91fe362799b18ba4" \
    L"dfcf2a110052b5d63cb69014448bdb2ffb0832418c054695" \
)

#define ASSEMBLY_REGISTRY_ROOT L"Software\\Microsoft\\Windows\\CurrentVersion\\SideBySide\\"
#define WINSXS_INSTALLATION_INFO_REGKEY  ( ASSEMBLY_REGISTRY_ROOT L"Installations")

#define ASSEMBLY_INSTALL_TEMP_DIR_NAME ( L"InstallTemp" )

interface IXMLNodeSource;

typedef enum _SXS_NODE_TYPE
    {   SXS_ELEMENT = 1,
    SXS_ATTRIBUTE   = SXS_ELEMENT + 1,
    SXS_PI  = SXS_ATTRIBUTE + 1,
    SXS_XMLDECL = SXS_PI + 1,
    SXS_DOCTYPE = SXS_XMLDECL + 1,
    SXS_DTDATTRIBUTE    = SXS_DOCTYPE + 1,
    SXS_ENTITYDECL  = SXS_DTDATTRIBUTE + 1,
    SXS_ELEMENTDECL = SXS_ENTITYDECL + 1,
    SXS_ATTLISTDECL = SXS_ELEMENTDECL + 1,
    SXS_NOTATION    = SXS_ATTLISTDECL + 1,
    SXS_GROUP   = SXS_NOTATION + 1,
    SXS_INCLUDESECT = SXS_GROUP + 1,
    SXS_PCDATA  = SXS_INCLUDESECT + 1,
    SXS_CDATA   = SXS_PCDATA + 1,
    SXS_IGNORESECT  = SXS_CDATA + 1,
    SXS_COMMENT = SXS_IGNORESECT + 1,
    SXS_ENTITYREF   = SXS_COMMENT + 1,
    SXS_WHITESPACE  = SXS_ENTITYREF + 1,
    SXS_NAME    = SXS_WHITESPACE + 1,
    SXS_NMTOKEN = SXS_NAME + 1,
    SXS_STRING  = SXS_NMTOKEN + 1,
    SXS_PEREF   = SXS_STRING + 1,
    SXS_MODEL   = SXS_PEREF + 1,
    SXS_ATTDEF  = SXS_MODEL + 1,
    SXS_ATTTYPE = SXS_ATTDEF + 1,
    SXS_ATTPRESENCE = SXS_ATTTYPE + 1,
    SXS_DTDSUBSET   = SXS_ATTPRESENCE + 1,
    SXS_LASTNODETYPE    = SXS_DTDSUBSET + 1
    }   SXS_NODE_TYPE;

typedef struct _SXS_NODE_INFO {
    _SXS_NODE_INFO() { }
    ULONG Size;
    ULONG Type;
    CSmallStringBuffer NamespaceStringBuf;
    const WCHAR *pszText;       // this could be an attribute name or value string of an attribute
    SIZE_T cchText;
private:
    _SXS_NODE_INFO(const _SXS_NODE_INFO &);
    void operator =(const _SXS_NODE_INFO &);

} SXS_NODE_INFO, *PSXS_NODE_INFO;

typedef const SXS_NODE_INFO *PCSXS_NODE_INFO;

/*-----------------------------------------------------------------------------
This returns a pointer to statically allocated memory. Don't free it.
In free builds, it just returns an empty string.
-----------------------------------------------------------------------------*/
const WCHAR* SxspInstallDispositionToStringW(ULONG);

typedef const struct _ATTRIBUTE_NAME_DESCRIPTOR *PCATTRIBUTE_NAME_DESCRIPTOR;

typedef VOID (WINAPI * SXS_REPORT_PARSE_ERROR_MISSING_REQUIRED_ATTRIBUTE_CALLBACK)(
    IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    );

typedef VOID (WINAPI * SXS_REPORT_PARSE_ERROR_ATTRIBUTE_NOT_ALLOWED)(
    IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    );

typedef VOID (WINAPI * SXS_REPORT_PARSE_ERROR_INVALID_ATTRIBUTE_VALUE)(
    IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName
    );

class ACTCTXCTB_INSTALLATION_CONTEXT
{
public:
    ACTCTXCTB_INSTALLATION_CONTEXT() : Callback(NULL), Context(NULL), InstallSource(NULL), SecurityMetaData(NULL) { }

    PSXS_INSTALLATION_FILE_COPY_CALLBACK Callback;
    PVOID                           Context;
    PVOID                           InstallSource;
    PVOID                           SecurityMetaData;
    const void *                    InstallReferenceData;
};

typedef const ACTCTXCTB_INSTALLATION_CONTEXT *PCACTCTXCTB_INSTALLATION_CONTEXT;

typedef struct _ACTCTXCTB_CLSIDMAPPING_CONTEXT {
    CClsidMap *Map;
} ACTCTXCTB_CLSIDMAPPING_CONTEXT, *PACTCTXCTB_CLSIDMAPPING_CONTEXT;

typedef const ACTCTXCTB_CLSIDMAPPING_CONTEXT *PCACTCTXCTB_CLSIDMAPPING_CONTEXT;

#define MANIFEST_OPERATION_INVALID (0)
#define MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT (1)
#define MANIFEST_OPERATION_VALIDATE_SYNTAX (2)
#define MANIFEST_OPERATION_INSTALL (3)

#define MANIFEST_OPERATION_INSTALL_FLAG_NOT_TRANSACTIONAL           (0x00000001)
#define MANIFEST_OPERATION_INSTALL_FLAG_NO_VERIFY                   (0x00000002)
#define MANIFEST_OPERATION_INSTALL_FLAG_REPLACE_EXISTING            (0x00000004)
#define MANIFEST_OPERATION_INSTALL_FLAG_ABORT                       (0x00000008)
#define MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY              (0x00000010)
#define MANIFEST_OPERATION_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE    (0x00000020)
#define MANIFEST_OPERATION_INSTALL_FLAG_MOVE                        (0x00000040)
#define MANIFEST_OPERATION_INSTALL_FLAG_INCLUDE_CODEBASE            (0x00000080)
#define MANIFEST_OPERATION_INSTALL_FLAG_FROM_RESOURCE               (0x00000800)
#define MANIFEST_OPERATION_INSTALL_FLAG_COMMIT                      (0x00001000)
#define MANIFEST_OPERATION_INSTALL_FLAG_CREATE_LOGFILE              (0x00002000)
#define MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_DARWIN         (0x00004000)
#define MANIFEST_OPERATION_INSTALL_FLAG_REFERENCE_VALID             (0x00008000)
#define MANIFEST_OPERATION_INSTALL_FLAG_REFRESH                     (0x00010000)
#define MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_OSSETUP        (0x00020000)
#define MANIFEST_OPERATION_INSTALL_FLAG_INSTALLED_BY_MIGRATION      (0x00040000)
#define MANIFEST_OPERATION_INSTALL_FLAG_FROM_CABINET                (0x00080000)
#define MANIFEST_OPERATION_INSTALL_FLAG_APPLY_PATCHES               (0x00100000)
#define MANIFEST_OPERATION_INSTALL_FLAG_FORCE_LOOK_FOR_CATALOG      (0x00200000)

#define ASSEMBLY_MANIFEST_FILETYPE_AUTO_DETECT (  0)
#define ASSEMBLY_MANIFEST_FILETYPE_FILE        (  1)
#define ASSEMBLY_MANIFEST_FILETYPE_RESOURCE    (  2)
#define ASSEMBLY_MANIFEST_FILETYPE_STREAM      (  3)
#define ASSEMBLY_MANIFEST_FILETYPE_MASK        (0xF)

#define ASSEMBLY_POLICY_FILETYPE_STREAM      (  3)
#define ASSEMBLY_POLICY_FILETYPE_MASK        (0xF)

#define SXS_POLICY_KEY_NAME L"SOFTWARE\\Policies\\Microsoft\\Windows\\SideBySide\\AssemblyReplacementPolicies"
#define SXS_POLICY_PUBLICATION_DATE_VALUE_NAME L"PublicationDate"
#define SXS_POLICY_REDIRECTION_VALUE_NAME L"ReplacedBy"

#include "assemblyreference.h"
#include "probedassemblyinformation.h"
#include "fusionheap.h"
#include "comclsidmap.h"
#include "actctxgenctxctb.h"
#include "assemblyreference.h"
#include "impersonationdata.h"
#include "fusionbuffer.h"

//
//  Notes on heap allocation by contributors:
//
//  Heap allocations associated with processing an installation, parsing a
//    or generating an activation context should be done on the
//  heap passed in the Heap member of the callback header.
//
//  This heap is destroyed when the operation is complete, and any leaks
//  by contributors are reported and may constitute a BVT break.
//
//  The heap for the _INIT callback is guaranteed to stay alive until the
//  _UNINT callback is fired.  It is absolutely not guaranteed to survive
//  any longer, and leaks are build breaks.
//
//  In debug builds, contributors may be given private heaps so that leaks
//  can be tracked per-contributor.
//

typedef struct _ACTCTXCTB_CBHEADER {
    ULONG Reason;
    ULONG ManifestOperation;
    DWORD ManifestOperationFlags;
    DWORD Flags; // these are the same flags as ACTCTXGENCTX::m_Flags
    const GUID *ExtensionGuid;
    ULONG SectionId;
    PVOID ContributorContext;
    PVOID ActCtxGenContext;
    PVOID ManifestParseContext;
    PCACTCTXCTB_INSTALLATION_CONTEXT InstallationContext; // valid only if ACTCTXCTB_INSTALLING is set
    PCACTCTXCTB_CLSIDMAPPING_CONTEXT ClsidMappingContext; // Not valid if ACTCTXCTB_GENERATE_CONTEXT not set
    PACTCTXGENCTX pOriginalActCtxGenCtx;
} ACTCTXCTB_CBHEADER, *PACTCTXCTB_CBHEADER;

BOOL operator==(const ACTCTXCTB_CBHEADER&, const ACTCTXCTB_CBHEADER&);
BOOL operator!=(const ACTCTXCTB_CBHEADER&, const ACTCTXCTB_CBHEADER&);

#define ACTCTXCTB_CBREASON_INIT                 (1)
#define ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING   (2)
#define ACTCTXCTB_CBREASON_PARSEBEGINNING       (3)
#define ACTCTXCTB_CBREASON_IDENTITYDETERMINED   (4)
#define ACTCTXCTB_CBREASON_BEGINCHILDREN        (5)
#define ACTCTXCTB_CBREASON_ENDCHILDREN          (6)
#define ACTCTXCTB_CBREASON_ELEMENTPARSED        (7)
#define ACTCTXCTB_CBREASON_PCDATAPARSED         (8)
#define ACTCTXCTB_CBREASON_CDATAPARSED          (9)
#define ACTCTXCTB_CBREASON_PARSEENDING          (10)
#define ACTCTXCTB_CBREASON_PARSEENDED           (11)
#define ACTCTXCTB_CBREASON_ALLPARSINGDONE       (12)
#define ACTCTXCTB_CBREASON_GETSECTIONSIZE       (13)
#define ACTCTXCTB_CBREASON_GETSECTIONDATA       (14)
#define ACTCTXCTB_CBREASON_ACTCTXGENENDING      (15)
#define ACTCTXCTB_CBREASON_ACTCTXGENENDED       (16)
#define ACTCTXCTB_CBREASON_UNINIT               (17)

/*-----------------------------------------------------------------------------
This returns a pointer to statically allocated memory. Don't free it.
In free builds, it just returns an empty string.

ACTCTXCTB_CBREASON_INIT => "INIT"
ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING => "GENBEGINNING"
etc.
-----------------------------------------------------------------------------*/
PCSTR SxspActivationContextCallbackReasonToString(ULONG);

//
//  Basics of the callback order:
//
//  The ACTCTXCTB_CBREASON_INIT callback will always be issued first to allow
//  the contributor to set up some global state.
//
//  The ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING callback will be fired before any
//  parse callbacks (_BEGINCHILDREN, _ENDCHILDREN, _ELEMENTPARSED, _PARSEDONE,
//  _GETSECTIONDATA, _PARSEENDING) so that the contributor may set up per-parse
//  context.
//
//  The ACTCTXCTB_CBREASON_PARSEENDING callback may be fired any time after the
//  _ACTCTXGENBEGINNING callback.  The contributor should tear down any per-parse
//  state during this callback.  After the _PARSEENDING callback is fired, only
//  the _ACTCTXGENBEGINNING and _UNINIT callbacks may be called.
//
//  The ACTCTXCTB_CBREASON_ALLPARSINGDONE callback will be fired prior to the
//  _GETSECTIONSIZE or _GETSECTIONDATA callbacks.  It's an opportunity for the
//  contributor to stabilize their data structures for generation; no further
//  _PARSEBEGINNING, _ELEMENTPARSED, _BEGINCHILDREN, _ENDCHILDREN or _PARSEENDING
//  callbacks are issued.
//
//  The ACTCTXCTB_CBREASON_GETSECTIONSIZE callback will be fired prior to the
//  _GETSECTIONDATA callback.  The section size reported by the _GETSECTIONSIZE
//  must be exact.
//
//  The ACTCTXCTB_CBREASON_GETSECTIONDATA callback must fill in the data for the
//  activation context section.  It may not write more bytes to the section than
//  were requested in the response to _PARSEDONE.
//
//  The ACTCTXCTB_CBREASON_UNINIT callback should be used to tear down any global
//  state for the contributor.  The contributor DLL may be unloaded, or another
//  _INIT callback may be issued after the _UNINIT.
//

// Used with ACTCTXCTB_CBREASON_INIT
typedef struct _ACTCTXCTB_CBINIT {
    ACTCTXCTB_CBHEADER Header;
} ACTCTXCTB_CBINIT, *PACTCTXCTB_CBINIT;

BOOL operator==(const ACTCTXCTB_CBINIT&, const ACTCTXCTB_CBINIT&);

// Used with ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING
typedef struct _ACTCTXCTB_CBACTCTXGENBEGINNING {
    ACTCTXCTB_CBHEADER Header;
    PCWSTR ApplicationDirectory;
    SIZE_T ApplicationDirectoryCch;
    ULONG ApplicationDirectoryPathType;
    BOOL Success;
} ACTCTXCTB_CBACTCTXGENBEGINNING, *PACTCTXCTB_CBACTCTXGENBEGINNING;

BOOL operator==(const ACTCTXCTB_CBACTCTXGENBEGINNING&, const ACTCTXCTB_CBACTCTXGENBEGINNING&);

#define ACTCTXCTB_CBPARSEBEGINNING_FILEFLAGS_PRECOMPILED (0x00000001)

#define XML_FILE_TYPE_MANIFEST (1)
#define XML_FILE_TYPE_COMPONENT_CONFIGURATION (2)
#define XML_FILE_TYPE_APPLICATION_CONFIGURATION (3)

#define ACTCTXCTB_ASSEMBLY_CONTEXT_ASSEMBLY_POLICY_APPLIED  (0x00000001)
#define ACTCTXCTB_ASSEMBLY_CONTEXT_ROOT_POLICY_APPLIED      (0x00000002)
#define ACTCTXCTB_ASSEMBLY_CONTEXT_IS_ROOT_ASSEMBLY         (0x00000004)
#define ACTCTXCTB_ASSEMBLY_CONTEXT_IS_PRIVATE_ASSEMBLY      (0x00000008)
// in system-policy installation
#define ACTCTXCTB_ASSEMBLY_CONTEXT_IS_SYSTEM_POLICY_INSTALLATION    (0x00000010)

/*-----------------------------------------------------------------------------
This is the public ASSEMBLY that contributor callbacks see.
It is generated from the private ASSEMBLY struct.
-----------------------------------------------------------------------------*/
typedef struct _ACTCTXCTB_ASSEMBLY_CONTEXT {
    ULONG Flags;                    // Various indicators include what kind of policy was used etc.
    ULONG AssemblyRosterIndex;
    ULONG ManifestPathType;
    PCWSTR ManifestPath;            // not necessarily null terminated; respect ManifestPathCch!
    SIZE_T ManifestPathCch;
    ULONG PolicyPathType;
    PCWSTR PolicyPath;              // not necessarily null terminated; respect PolicyPathCch!
    SIZE_T PolicyPathCch;
    PCASSEMBLY_IDENTITY AssemblyIdentity;
    PVOID  TeeStreamForManifestInstall; // REVIEW hack/backdoor.. we might as well give the contributors the activation context
    PVOID  pcmWriterStream; // same comment as TeeStreamForManifestInstall
    PVOID  InstallationInfo; // ibid.
    PVOID  AssemblySecurityContext;
    PVOID  SecurityMetaData;
    const VOID *InstallReferenceData;

    PCWSTR TextuallyEncodedIdentity;    // always null terminated
    SIZE_T TextuallyEncodedIdentityCch;  // does not include trailing null character

    _ACTCTXCTB_ASSEMBLY_CONTEXT()
        : AssemblyIdentity(NULL),
          Flags(0),
          AssemblyRosterIndex(0),
          ManifestPathType(0),
          ManifestPathCch(0),
          ManifestPath(NULL),
          PolicyPathType(0),
          PolicyPath(NULL),
          PolicyPathCch(0),
          TeeStreamForManifestInstall(NULL),
          pcmWriterStream(NULL),
          InstallationInfo(NULL),
          InstallReferenceData(NULL),
          AssemblySecurityContext(NULL),
          TextuallyEncodedIdentity(NULL),
          TextuallyEncodedIdentityCch(0),
          SecurityMetaData(NULL) { }
    ~_ACTCTXCTB_ASSEMBLY_CONTEXT()
    {
        if (AssemblyIdentity != NULL)
        {
            CSxsPreserveLastError ple;
            ::SxsDestroyAssemblyIdentity(const_cast<PASSEMBLY_IDENTITY>(AssemblyIdentity));
            AssemblyIdentity = NULL;
            ple.Restore();
        }
    }

} ACTCTXCTB_ASSEMBLY_CONTEXT, *PACTCTXCTB_ASSEMBLY_CONTEXT;
typedef const ACTCTXCTB_ASSEMBLY_CONTEXT *PCACTCTXCTB_ASSEMBLY_CONTEXT;

typedef struct _ACTCTXCTB_ERROR_CALLBACKS {
    SXS_REPORT_PARSE_ERROR_MISSING_REQUIRED_ATTRIBUTE_CALLBACK MissingRequiredAttribute;
    SXS_REPORT_PARSE_ERROR_ATTRIBUTE_NOT_ALLOWED AttributeNotAllowed;
    SXS_REPORT_PARSE_ERROR_INVALID_ATTRIBUTE_VALUE InvalidAttributeValue;
} ACTCTXCTB_ERROR_CALLBACK, *PACTCTXCTB_ERROR_CALLBACKS;

typedef const struct _ACTCTXCTB_ERROR_CALLBACKS *PCACTCTXCTB_ERROR_CALLBACKS;

typedef struct _ACTCTXCTB_PARSE_CONTEXT {
    PCWSTR ElementPath;     // passed to callback - null terminated but ElementPathCch is also valid
    SIZE_T ElementPathCch;  // passed to callback
    PCWSTR ElementName;
    SIZE_T ElementNameCch;
    ULONG ElementHash;      // passed to callback
    ULONG XMLElementDepth;  // passed to callback
    ULONG SourceFilePathType; // passed to callback
    PCWSTR SourceFile;      // passed to callback - null terminated
    SIZE_T SourceFileCch;   // passed to callback
    FILETIME SourceFileLastWriteTime; // passed to callback
    ULONG LineNumber;       // passed to callback
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;   // passed to callback
    ACTCTXCTB_ERROR_CALLBACK ErrorCallbacks;        // passed to callback
} ACTCTXCTB_PARSE_CONTEXT;

// Used with ACTCTXCTB_CBREASON_PARSEBEGINNING
typedef struct _ACTCTXCTB_CBPARSEBEGINNING {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    ULONG ParseType;                // passed to callback
    ULONG FileFlags;                // passed to callback
    ULONG FilePathType;
    PCWSTR FilePath;                // passed to callback
    SIZE_T FilePathCch;             // passed to callback
    FILETIME FileLastWriteTime;     // passed to callback
    ULONG FileFormatVersionMajor;     // passed to callback
    ULONG FileFormatVersionMinor;     // passed to callback
    ULONG MetadataSatelliteRosterIndex; // passed to callback
    BOOL NoMoreCallbacksThisFile;   // returned from callback
    BOOL Success;
} ACTCTXCTB_CBPARSEBEGINNING, *PACTCTXCTB_CBPARSEBEGINNING;

BOOL operator==(const FILETIME&, const FILETIME&);
BOOL operator!=(const FILETIME&, const FILETIME&);
BOOL operator==(const ACTCTXCTB_CBPARSEBEGINNING&, const ACTCTXCTB_CBPARSEBEGINNING&);

// Used with ACTCTXCTB_CBREASON_BEGINCHILDREN
typedef struct _ACTCTXCTB_CBBEGINCHILDREN {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    PCSXS_NODE_INFO NodeInfo;    // passed to callback
    BOOL Success;
} ACTCTXCTB_CBBEGINCHILDREN, *PACTCTXCTB_CBBEGINCHILDREN;

BOOL operator==(const ACTCTXCTB_CBBEGINCHILDREN&, const ACTCTXCTB_CBBEGINCHILDREN&);

// Used with ACTCTXCTB_CBREASON_ENDCHILDREN
typedef struct _ACTCTXCTB_CBENDCHILDREN {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    BOOL Empty;                 // passed to callback
    PCSXS_NODE_INFO NodeInfo;    // passed to callback
    BOOL Success;
} ACTCTXCTB_CBENDCHILDREN, *PACTCTXCTB_CBENDCHILDREN;

BOOL operator==(const ACTCTXCTB_CBENDCHILDREN&, const ACTCTXCTB_CBENDCHILDREN&);

// Used with ACTCTXCTB_CBREASON_IDENTITYDETERMINED
typedef struct _ACTCTXCTB_CBIDENTITYDETERMINED {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    PCASSEMBLY_IDENTITY AssemblyIdentity;
    BOOL Success;
} ACTCTXCTB_CBIDENTITYDETERMINED, *PACTCTXCTB_CBIDENTITYDETERMINED;

typedef const ACTCTXCTB_CBIDENTITYDETERMINED *PCACTCTXCTB_CBIDENTITYDETERMINED;

BOOL operator==(const ACTCTXCTB_CBIDENTITYDETERMINED&, const ACTCTXCTB_CBIDENTITYDETERMINED&);

// Used with ACTCTXCTB_CBREASON_ELEMENTPARSED
typedef struct _ACTCTXCTB_CBELEMENTPARSED {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    ULONG NodeCount;            // passed to callback
    PCSXS_NODE_INFO NodeInfo;   // passed to callback
    BOOL Success;
} ACTCTXCTB_CBELEMENTPARSED, *PACTCTXCTB_CBELEMENTPARSED;

typedef const ACTCTXCTB_CBELEMENTPARSED *PCACTCTXCTB_CBELEMENTPARSED;

BOOL operator==(const ACTCTXCTB_CBELEMENTPARSED&, const ACTCTXCTB_CBELEMENTPARSED&);

// Used with ACTCTXCTB_CBREASON_PCDATAPARSED
typedef struct _ACTCTXCTB_CBPCDATAPARSED {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    const WCHAR *Text;
    ULONG TextCch;
    BOOL Success;
} ACTCTXCTB_CBPCDATAPARSED, *PACTCTXCTB_CBPCDATAPARSED;

typedef const ACTCTXCTB_CBPCDATAPARSED *PCACTCTXCTB_CBPCDATAPARSED;

BOOL operator==(const ACTCTXCTB_CBPCDATAPARSED&, const ACTCTXCTB_CBPCDATAPARSED&);

// Used with ACTCTXCTB_CBREASON_CDATAPARSED
typedef struct _ACTCTXCTB_CBCDATAPARSED {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    PCACTCTXCTB_PARSE_CONTEXT ParseContext;
    const WCHAR *Text;
    ULONG TextCch;
    BOOL Success;
} ACTCTXCTB_CBCDATAPARSED, *PACTCTXCTB_CBCDATAPARSED;

typedef const ACTCTXCTB_CBCDATAPARSED *PCACTCTXCTB_CBCDATAPARSED;

BOOL operator==(const ACTCTXCTB_CBCDATAPARSED&, const ACTCTXCTB_CBCDATAPARSED&);

// Used with ACTCTXCTB_CBREASON_ALLPARSINGDONE
typedef struct _ACTCTXCTB_CBALLPARSINGDONE {
    ACTCTXCTB_CBHEADER Header;
    BOOL Success;
} ACTCTXCTB_CBALLPARSINGDONE, *PACTCTXCTB_CBALLPARSINGDONE;

BOOL operator==(const ACTCTXCTB_CBALLPARSINGDONE&, const ACTCTXCTB_CBALLPARSINGDONE&);

// Used with ACTCTXCTB_CBREASON_GETSECTIONSIZE
typedef struct _ACTCTXCTB_CBGETSECTIONSIZE {
    ACTCTXCTB_CBHEADER Header;
    SIZE_T SectionSize;          // filled in by callback
    BOOL Success;
} ACTCTXCTB_CBGETSECTIONSIZE, *PACTCTXCTB_CBGETSECTIONSIZE;

BOOL operator==(const ACTCTXCTB_CBGETSECTIONSIZE&, const ACTCTXCTB_CBGETSECTIONSIZE&);

// Used with ACTCTXCTB_CBREASON_GETSECTIONDATA
typedef struct _ACTCTXCTB_CBGETSECTIONDATA {
    ACTCTXCTB_CBHEADER Header;
    SIZE_T SectionSize;          // passed to callback
    PVOID SectionDataStart;     // passed to callback
    BOOL Success;
} ACTCTXCTB_CBGETSECTIONDATA, *PACTCTXCTB_CBGETSECTIONDATA;

BOOL operator==(const ACTCTXCTB_CBGETSECTIONDATA&, const ACTCTXCTB_CBGETSECTIONDATA&);

// Used with ACTCTXCTB_CBREASON_PARSEENDING
typedef struct _ACTCTXCTB_CBPARSEENDING {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
    BOOL Success;
} ACTCTXCTB_CBPARSEENDING, *PACTCTXCTB_CBPARSEENDING;

BOOL operator==(const ACTCTXCTB_CBPARSEENDING&, const ACTCTXCTB_CBPARSEENDING&);

// Used with ACTCTXCTB_CBREASON_PARSEENDED
typedef struct _ACTCTXCTB_CBPARSEENDED {
    ACTCTXCTB_CBHEADER Header;
    PCACTCTXCTB_ASSEMBLY_CONTEXT AssemblyContext;
} ACTCTXCTB_CBPARSEENDED, *PACTCTXCTB_CBPARSEENDED;

BOOL operator==(const ACTCTXCTB_CBPARSEENDED&, const ACTCTXCTB_CBPARSEENDED&);

// Used with ACTCTXCTB_CBREASON_ACTCTXGENENDING
typedef struct _ACTCTXCTB_CBACTCTXGENENDING {
    ACTCTXCTB_CBHEADER Header;
    BOOL Success;
} ACTCTXCTB_CBACTCTXGENENDING, *PACTCTXCTB_CBACTCTXGENENDING;

BOOL operator==(const ACTCTXCTB_CBACTCTXGENENDING&, const ACTCTXCTB_CBACTCTXGENENDING&);

// Used with ACTCTXCTB_CBREASON_ACTCTXGENENDED
typedef struct _ACTCTXCTB_CBACTCTXGENENDED {
    ACTCTXCTB_CBHEADER Header;
    BOOL Success;
} ACTCTXCTB_CBACTCTXGENENDED, *PACTCTXCTB_CBACTCTXGENENDED;

BOOL operator==(const ACTCTXCTB_CBACTCTXGENENDED&, const ACTCTXCTB_CBACTCTXGENENDED&);

// Used with ACTCTXCTB_CBREASON_UNINIT
typedef struct _ACTCTXCTB_CBUNINIT {
    ACTCTXCTB_CBHEADER Header;
    PVOID ContribContext;       // passed to callback
} ACTCTXCTB_CBUNINIT, *PACTCTXCTB_CBUNINIT;

BOOL operator==(const ACTCTXCTB_CBUNINIT&, const ACTCTXCTB_CBUNINIT&);

typedef union _ACTCTXCTB_CALLBACK_DATA {
    ACTCTXCTB_CBHEADER Header;
    ACTCTXCTB_CBINIT Init;
    ACTCTXCTB_CBACTCTXGENBEGINNING GenBeginning;
    ACTCTXCTB_CBPARSEBEGINNING ParseBeginning;
    ACTCTXCTB_CBBEGINCHILDREN BeginChildren;
    ACTCTXCTB_CBENDCHILDREN EndChildren;
    ACTCTXCTB_CBELEMENTPARSED ElementParsed;
    ACTCTXCTB_CBPCDATAPARSED PCDATAParsed;
    ACTCTXCTB_CBCDATAPARSED CDATAParsed;
    ACTCTXCTB_CBPARSEENDING ParseEnding;
    ACTCTXCTB_CBALLPARSINGDONE AllParsingDone;
    ACTCTXCTB_CBGETSECTIONSIZE GetSectionSize;
    ACTCTXCTB_CBGETSECTIONDATA GetSectionData;
    ACTCTXCTB_CBACTCTXGENENDING GenEnding;
    ACTCTXCTB_CBUNINIT Uninit;
    ACTCTXCTB_CBPARSEENDED ParseEnded;
} ACTCTXCTB_CALLBACK_DATA, *PACTCTXCTB_CALLBACK_DATA;
typedef const ACTCTXCTB_CALLBACK_DATA* PCACTCTXCTB_CALLBACK_DATA;

typedef VOID (__fastcall * ACTCTXCTB_CALLBACK_FUNCTION)(
    IN OUT PACTCTXCTB_CALLBACK_DATA Data
    );

#define ACTCTXCTB_MAX_PREFIX_LENGTH (32)

typedef struct _ACTCTXCTB
{
    friend BOOL SxspAddActCtxContributor(
        PCWSTR DllName,
        PCSTR Prefix,
        SIZE_T PrefixCch,
        const GUID *ExtensionGuid,
        ULONG SectionId,
        ULONG Format,
        PCWSTR ContributorName
        );

    friend BOOL SxspAddBuiltinActCtxContributor(
        IN ACTCTXCTB_CALLBACK_FUNCTION CallbackFunction,
        const GUID *ExtensionGuid,
        ULONG SectionId,
        ULONG Format,
        PCWSTR ContributorName
        );

    _ACTCTXCTB() :
        m_RefCount(0),
        m_Next(NULL),
        m_ExtensionGuid(GUID_NULL),
        m_SectionId(0),
        m_Format(ACTIVATION_CONTEXT_SECTION_FORMAT_UNKNOWN),
        m_ContributorContext(NULL),
        m_CallbackFunction(NULL),
        m_BuiltinContributor(false),
        m_IsExtendedSection(false),
        m_PrefixCch(0)
        {
        }

    const GUID *GetExtensionGuidPtr() const
    {
        if (m_IsExtendedSection)
            return &m_ExtensionGuid;
        return NULL;
    }

    void AddRef() { ::InterlockedIncrement(&m_RefCount); }
    void Release() { ULONG ulRefCount; ulRefCount = ::InterlockedDecrement(&m_RefCount); if (ulRefCount == 0) { FUSION_DELETE_SINGLETON(this); } }

    LONG m_RefCount;
    struct _ACTCTXCTB *m_Next;
    GUID m_ExtensionGuid;
    ULONG m_SectionId;
#if SXS_EXTENSIBLE_CONTRIBUTORS
    CDynamicLinkLibrary m_DllHandle;
#endif
    PVOID m_ContributorContext;
    ACTCTXCTB_CALLBACK_FUNCTION m_CallbackFunction;
    ULONG m_Format;
    bool m_BuiltinContributor;  // For built-in contributors who aren't called through the extensibility
                                // interface.  This currently includes the cache coherency section and
                                // the assembly metadata section.
    bool m_IsExtendedSection;
    CStringBuffer m_ContributorNameBuffer;
    CStringBuffer m_DllNameBuffer;
    SIZE_T m_PrefixCch;

    ~_ACTCTXCTB() { ASSERT_NTC(m_RefCount == 0); }

private:
    _ACTCTXCTB(const _ACTCTXCTB &);
    void operator =(const _ACTCTXCTB &);
} ACTCTXCTB, *PACTCTXCTB;

/*-----------------------------------------------------------------------------
This is the private ASSEMBLY struct.
Contributor callbacks do not see this; they instead see
ASSEMBLY_CONTEXT which is very similar, but for example CStringBuffers
are replaced by .dll-boundary-crossing-politically-correct PCWSTR.
-----------------------------------------------------------------------------*/
typedef struct _ASSEMBLY
{
    _ASSEMBLY() : m_AssemblyRosterIndex(0), m_MetadataSatelliteRosterIndex(0), m_nRefs(1) { }

    CDequeLinkage m_Linkage;
    CProbedAssemblyInformation m_ProbedAssemblyInformation;
    BOOL m_Incorporated;
    ULONG m_ManifestVersionMajor;
    ULONG m_ManifestVersionMinor;
    ULONG m_AssemblyRosterIndex;
    ULONG m_MetadataSatelliteRosterIndex;

    void AddRef() { ::InterlockedIncrement(&m_nRefs); }
    void Release() { if (::InterlockedDecrement(&m_nRefs) == 0) { CSxsPreserveLastError ple; delete this; ple.Restore(); } }

    PCASSEMBLY_IDENTITY GetAssemblyIdentity() const { return m_ProbedAssemblyInformation.GetAssemblyIdentity(); };
    BOOL GetAssemblyName(PCWSTR *AssemblyName, SIZE_T *Cch) const { return m_ProbedAssemblyInformation.GetAssemblyName(AssemblyName, Cch); }
    BOOL GetManifestPath(PCWSTR *ManifestPath, SIZE_T *Cch) const { return m_ProbedAssemblyInformation.GetManifestPath(ManifestPath, Cch); }
    ULONG GetManifestPathType() const { return m_ProbedAssemblyInformation.GetManifestPathType(); }
    BOOL GetPolicyPath(PCWSTR &rManifestFilePath, SIZE_T &rCch) const { return m_ProbedAssemblyInformation.GetPolicyPath(rManifestFilePath, rCch); }
    ULONG GetPolicyPathType() const { return m_ProbedAssemblyInformation.GetPolicyPathType(); }
    const FILETIME &GetPolicyLastWriteTime() const { return m_ProbedAssemblyInformation.GetPolicyLastWriteTime(); }
    const FILETIME &GetManifestLastWriteTime() const { return m_ProbedAssemblyInformation.GetManifestLastWriteTime(); }
    BOOL IsRoot() const { return m_AssemblyRosterIndex == 1; }
    BOOL IsPrivateAssembly() const { return m_ProbedAssemblyInformation.IsPrivateAssembly(); }

private:
    ~_ASSEMBLY() { }

    LONG m_nRefs;

    _ASSEMBLY(const _ASSEMBLY &);
    void operator =(const _ASSEMBLY &);
} ASSEMBLY, *PASSEMBLY;
typedef const ASSEMBLY* PCASSEMBLY;

class CAssemblyTableHelper : public CCaseInsensitiveUnicodeStringPtrTableHelper<ASSEMBLY>
{
public:
    static BOOL InitializeValue(ASSEMBLY *vin, ASSEMBLY *&rvstored) { rvstored = vin; if (vin != NULL) vin->AddRef(); return TRUE; }
    static BOOL UpdateValue(ASSEMBLY *vin, ASSEMBLY *&rvstored) { if (vin != NULL) vin->AddRef(); if (rvstored != NULL) { rvstored->Release(); } rvstored = vin; return TRUE; }
    static VOID FinalizeValue(ASSEMBLY *&rvstored) { if (rvstored != NULL) { rvstored->Release(); rvstored = NULL; } }
};

extern CCriticalSectionNoConstructor g_ActCtxCtbListCritSec;

// The contributor list is a singly linked list
extern PACTCTXCTB g_ActCtxCtbListHead;
extern ULONG g_ActCtxCtbListCount;

BOOL
SxspCreateManifestFileNameFromTextualString(
    DWORD dwFlags,
    ULONG PathType,
    const CBaseStringBuffer &AssemblyDirectory,
    PCWSTR pwszTextualAssemblyIdentityString,
    CBaseStringBuffer &sbPathName
    );

BOOL
SxspGenerateActivationContext(
    PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters,
    CFileStream &SystemDefaultManifestFileStream
    );

BOOL
SxspInitActCtxContributors(
    );

VOID
SxspUninitActCtxContributors(
    VOID
    );

BOOL
SxspAddActCtxContributor(
    IN PCWSTR DllName,
    IN PCSTR Prefix OPTIONAL,
    IN SIZE_T PrefixCch OPTIONAL,
    IN const GUID *ExtensionGuid OPTIONAL,
    IN ULONG SectionId,
    IN ULONG Format,
    IN PCWSTR ContributorName
    );

BOOL
SxspAddBuiltinActCtxContributor(
    IN ACTCTXCTB_CALLBACK_FUNCTION CallbackFunction,
    const GUID *ExtensionGuid,
    ULONG SectionId,
    ULONG Format,
    PCWSTR ContributorName
    );

VOID
__fastcall
SxspAssemblyMetadataContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

VOID
__fastcall
SxspComProgIdRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

VOID
__fastcall
SxspComTypeLibRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

VOID
__fastcall
SxspComInterfaceRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

BOOL
SxspGetXMLParser(
    REFIID riid,
    LPVOID *ppvObj
    );

#define SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_PARSE_ONLY                  (1)
#define SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_GENERATE_ACTIVATION_CONTEXT (2)
#define SXSP_INIT_ACT_CTX_GEN_CTX_OPERATION_INSTALL                     (3)

BOOL
SxspInitActCtxGenCtx(
    OUT PACTCTXGENCTX pActCtxGenCtx,
    IN ULONG ulOperation,
    IN DWORD dwFlags, // from ACTCTXCTB_* set
    IN DWORD dwOperationSpecificFlags,
    IN const CImpersonationData &ImpersonationData,
    IN USHORT ProcessorArchitecture,
    IN LANGID LangId,
    IN ULONG ApplicationDirectoryPathType,
    IN SIZE_T ApplicationDirectoryCch,
    IN PCWSTR ApplicationDirectory
    );

BOOL
SxspFireActCtxGenEnding(
    IN PACTCTXGENCTX pActCtxGenCtx
    );

BOOL
SxspAddRootManifestToActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    PCSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters
    );

BOOL
SxspAddManifestToActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    CProbedAssemblyInformation &ProbedInformation, // arbitrarily valueless on exit
    PASSEMBLY *AssemblyOut
    );

BOOL
SxspAddAssemblyToActCtxGenCtx(
    PACTCTXGENCTX pActCtxGenCtx,
    PCWSTR AssemblyName,
    PCASSEMBLY_VERSION Version
    );

BOOL
SxspEnqueueAssemblyReference(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY SourceAssembly,
    PCASSEMBLY_IDENTITY Identity,
    bool Optional,
    bool MetadataSatellite
    );

/*-----------------------------------------------------------------------------
given an assembly name and optional version, but no langid, or processor, and
its referring generation context, this function looks in the "assembly store"
(file system) for an assembly with that name that matches the generation
context, first by exact match, then some ordered weaker forms, like language
neutral, processor unknown, etc. If a match is found, some information
about it is returned. The out parameters are clobbered upon errors as well.
-----------------------------------------------------------------------------*/

#define SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_OPTIONAL (0x00000001)
#define SXSP_RESOLVE_PARTIAL_REFERENCE_FLAG_SKIP_WORLDWIDE (0x00000002)


BOOL
SxspResolvePartialReference(
    DWORD Flags,
    PCASSEMBLY ParsingAssemblyContext,
    PACTCTXGENCTX pActCtxGenCtx,
    const CAssemblyReference &PartialReference,
    CProbedAssemblyInformation &ProbedAssemblyInformation,
    bool &rfFound
    );

BOOL
SxspCloseManifestGraph(
    PACTCTXGENCTX pActCtxGenCtx
    );

BOOL
SxspBuildActCtxData(
    PACTCTXGENCTX pActCtxGenCtx,
    PHANDLE SectionHandle
    );

BOOL
SxspGetAssemblyRootDirectoryHelper(
    IN SIZE_T CchBuffer,
    OUT WCHAR Buffer[],
    OUT SIZE_T *CchWritten OPTIONAL
    );

BOOL
SxspGetAssemblyRootDirectory(
    IN OUT CBaseStringBuffer &rRootDirectory
    );

BOOL
SxspGetNDPGacRootDirectory(
    OUT CBaseStringBuffer &rRootDirectory
    );

// x86, Alpha, IA64, Data, Alpha64
#define MAXIMUM_PROCESSOR_ARCHITECTURE_NAME_LENGTH (sizeof("Alpha64")-1)

BOOL
SxspFormatGUID(
    IN const GUID &rGuid,
    IN OUT CBaseStringBuffer &rBuffer
    );

//
#define SXSP_PARSE_GUID_FLAG_FAIL_ON_INVALID (0x00000001)

BOOL
SxspParseGUID(
    IN PCWSTR pszGuid,
    IN SIZE_T cchGuid,
    OUT GUID &rGuid
    );

BOOL
SxspParseThreadingModel(
    IN PCWSTR String,
    IN SIZE_T Cch,
    OUT PULONG ThreadingModel
    );

BOOL
SxspFormatThreadingModel(
    IN ULONG ThreadingModel,
    IN OUT CBaseStringBuffer &Buffer
    );

BOOL
SxspParseUSHORT(
    IN PCWSTR String,
    IN SIZE_T Cch,
    OUT PUSHORT Value
    );

ULONG
SxspSetLastNTError(
    LONG Status
    );

/*-----------------------------------------------------------------------------
private above
public below
-----------------------------------------------------------------------------*/

extern "C"
{

typedef struct _STRING_SECTION_GENERATION_CONTEXT_ENTRY
{
    struct _STRING_SECTION_GENERATION_CONTEXT_ENTRY *Next;

    PCWSTR String;
    SIZE_T Cch;
    ULONG PseudoKey;
    PVOID DataContext;
    SIZE_T DataSize;
} STRING_SECTION_GENERATION_CONTEXT_ENTRY, *PSTRING_SECTION_GENERATION_CONTEXT_ENTRY;

#define STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE     (1)
#define STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA         (2)
#define STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED    (3)
#define STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE (4)
#define STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA     (5)

typedef struct _STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE
{
    PVOID DataContext;  // DataContext passed in to SxsAddStringToStringSectionGenerationContext()
    SIZE_T DataSize;     // filled in by callback function
} STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE, *PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE;

typedef struct _STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA
{
    PVOID SectionHeader;
    PVOID DataContext;  // DataContext passed in to SxsAddStringToStringSectionGenerationContext()
    SIZE_T BufferSize;   // callback function may read but not modify
    PVOID Buffer;       // Callback function may not modify this pointer but may modify BufferSize
                        // bytes starting at this address
    SIZE_T BytesWritten; // Actual number of bytes written to buffer.  May not differ from DataSize
                        // returned from the _GETDATASIZE callback.
} STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA, *PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA;

typedef struct _STRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED
{
    PVOID DataContext;  // DataContext passed in to SxsAddStringToStringSectionGenerationContext()
} STRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED, *PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED;

typedef struct _STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE
{
    SIZE_T DataSize;     // filled in by callback function
} STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE, *PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE;

typedef struct _STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA
{
    PVOID SectionHeader;
    SIZE_T BufferSize;   // callback function may read but not modify
    PVOID Buffer;       // Callback function may not modify this pointer but may modify BufferSize
                        // bytes starting at this address
    SIZE_T BytesWritten; // Actual number of bytes written to buffer.  May not differ from DataSize
                        // returned from the _GETUSERDATASIZE callback.
} STRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA, *PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA;

typedef BOOL (WINAPI * STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION)(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

typedef struct _STRING_SECTION_GENERATION_CONTEXT *PSTRING_SECTION_GENERATION_CONTEXT;

BOOL
WINAPI
SxsQueryAssemblyInfo(
    DWORD dwFlags,
    PCWSTR pwzTextualAssembly,
    ASSEMBLY_INFO *pAsmInfo);

BOOL
WINAPI
SxsInitStringSectionGenerationContext(
    OUT PSTRING_SECTION_GENERATION_CONTEXT *SSGenContext,
    IN ULONG DataFormatVersion,
    IN BOOL CaseInSensitive,
    IN STRING_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    IN LPVOID CallbackContext
    );

PVOID
WINAPI
SxsGetStringSectionGenerationContextCallbackContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    );

VOID
WINAPI
SxsDestroyStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    );

BOOL
WINAPI
SxsAddStringToStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN PCWSTR String,
    IN SIZE_T Cch,
    IN PVOID DataContext,
    IN ULONG AssemblyRosterIndex,
    IN DWORD DuplicateErrorCode // GetLastError() returns this if the GUID is a duplicate
    );

BOOL
WINAPI
SxsFindStringInStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN PCWSTR String,
    IN SIZE_T Cch,
    OUT PVOID *DataContext,
    OUT BOOL *Found
    );

BOOL
WINAPI
SxsDoneModifyingStringSectionGenerationContext(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext
    );

BOOL
WINAPI
SxsGetStringSectionGenerationContextSectionSize(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    OUT PSIZE_T DataSize
    );

BOOL
WINAPI
SxsGetStringSectionGenerationContextSectionData(
    IN PSTRING_SECTION_GENERATION_CONTEXT SSGenContext,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT PSIZE_T BytesWritten OPTIONAL
    );

typedef struct _GUID_SECTION_GENERATION_CONTEXT_ENTRY
{
    struct _GUID_SECTION_GENERATION_CONTEXT_ENTRY *Next;

    GUID Guid;
    PVOID DataContext;
    SIZE_T DataSize;
} GUID_SECTION_GENERATION_CONTEXT_ENTRY, *PGUID_SECTION_GENERATION_CONTEXT_ENTRY;

#define GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE (1)
#define GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA (2)
#define GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED (3)
#define GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATASIZE (4)
#define GUID_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETUSERDATA (5)

typedef struct _GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE
{
    PVOID DataContext;  // DataContext passed in to SxsAddStringToGuidSectionGenerationContext()
    SIZE_T DataSize;     // filled in by callback function
} GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE, *PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE;

typedef struct _GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA
{
    PVOID SectionHeader;
    PVOID DataContext;  // DataContext passed in to SxsAddStringToGuidSectionGenerationContext()
    SIZE_T BufferSize;   // callback function may read but not modify
    PVOID Buffer;       // Callback function may not modify this pointer but may modify BufferSize
                        // bytes starting at this address
    SIZE_T BytesWritten; // Actual number of bytes written to buffer.  May not differ from DataSize
                        // returned from the _GETDATASIZE callback.
} GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA, *PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA;

typedef struct _GUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED
{
    PVOID DataContext;  // DataContext passed in to SxsAddStringToGuidSectionGenerationContext()
} GUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED, *PGUID_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED;

typedef struct _GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE
{
    SIZE_T DataSize;     // filled in by callback function
} GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE, *PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATASIZE;

typedef struct _GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA
{
    PVOID SectionHeader;
    SIZE_T BufferSize;   // callback function may read but not modify
    PVOID Buffer;       // Callback function may not modify this pointer but may modify BufferSize
                        // bytes starting at this address
    SIZE_T BytesWritten; // Actual number of bytes written to buffer.  May not differ from DataSize
                        // returned from the _GETUSERDATASIZE callback.
} GUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA, *PGUID_SECTION_GENERATION_CONTEXT_CBDATA_GETUSERDATA;

typedef BOOL (WINAPI * GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION)(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

typedef struct _GUID_SECTION_GENERATION_CONTEXT *PGUID_SECTION_GENERATION_CONTEXT;

BOOL
WINAPI
SxsInitGuidSectionGenerationContext(
    OUT PGUID_SECTION_GENERATION_CONTEXT *SSGenContext,
    IN ULONG DataFormatVersion,
    IN GUID_SECTION_GENERATION_CONTEXT_CALLBACK_FUNCTION CallbackFunction,
    IN LPVOID CallbackContext
    );

PVOID
WINAPI
SxsGetGuidSectionGenerationContextCallbackContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext
    );

VOID
WINAPI
SxsDestroyGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext
    );

BOOL
WINAPI
SxsAddGuidToGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN const GUID *Guid,
    IN PVOID DataContext,
    IN ULONG AssemblyRosterIndex,
    IN DWORD DuplicateErrorCode // GetLastError() returns this if the GUID is a duplicate
    );

BOOL
WINAPI
SxsFindGuidInGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN const GUID *Guid,
    OUT PVOID *DataContext
    );

BOOL
WINAPI
SxsGetGuidSectionGenerationContextSectionSize(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    OUT PSIZE_T DataSize
    );

BOOL
WINAPI
SxsGetGuidSectionGenerationContextSectionData(
    IN PGUID_SECTION_GENERATION_CONTEXT GSGenContext,
    IN SIZE_T BufferSize,
    IN PVOID Buffer,
    OUT PSIZE_T BytesWritten OPTIONAL
    );

inline
BOOL
WINAPI
SxsDoneModifyingGuidSectionGenerationContext(
    IN PGUID_SECTION_GENERATION_CONTEXT SSGenContext
    ) { /* Nothing needs to be done here currently. */ return TRUE; }

#define SXS_COMMA_STRING L"&#x2c;"
#define SXS_QUOT_STRING  L"&#x22;"
#define SXS_FUSION_TO_MSI_ATTRIBUTE_VALUE_CONVERSION_COMMA  0
#define SXS_FUSION_TO_MSI_ATTRIBUTE_VALUE_CONVERSION_QUOT    1

BOOL
SxspCreateAssemblyIdentityFromTextualString(
    IN PCWSTR pszTextualAssemblyIdentityString,
    OUT PASSEMBLY_IDENTITY *ppAssemblyIdentity
    );


/*-----------------------------------------------------------------------------
side by side installation functions
-----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
public above
private below
-----------------------------------------------------------------------------*/

typedef
BOOL
(__stdcall*
SXSP_DEBUG_FUNCTION)(
    ULONG iOperation,
    DWORD dwFlags,
    PCWSTR pszParameter1,
    PVOID pvParameter2);

#define SXSP_DEBUG_ORDINAL (1)

BOOL
__stdcall
SxspDebug(
    ULONG iOperation,
    DWORD dwFlags,
    PCWSTR pszParameter1,
    PVOID pvParameter2);

} // extern "C"

/*-----------------------------------------------------------------------------*/
BOOL
SxspDuplicateString(
    PCWSTR StringIn,
    SIZE_T cch,
    PWSTR *StringOut
    );

BOOL
SxspHashString(
    PCWSTR String,
    SIZE_T Cch,
    PULONG HashValue,
    bool CaseInsensitive
    );

ULONG
SxspGetHashAlgorithm(
    VOID
    );

BOOL
WINAPI
SxspAssemblyMetadataStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

VOID
__fastcall
SxspDllRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

BOOL
WINAPI
SxspDllRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

VOID
__fastcall
SxspWindowClassRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

BOOL
WINAPI
SxspWindowClassRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );

VOID
__fastcall
SxspComClassRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

BOOL
WINAPI
SxspComClassRedirectionGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );


VOID
__fastcall
SxspClrInteropContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    );

BOOL
WINAPI
SxspClrInteropGuidSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    );


BOOL
SxspVerifyPublicKeyAndStrongName(
    const WCHAR *pszPublicKey,
    SIZE_T CchPublicKey,
    const WCHAR *pszStrongName,
    SIZE_T CchStrongName,
    BOOL &fValid
    );

#define SXS_INSTALLATION_MOVE_FILE                 (0)
#define SXS_INSTALLATION_MOVE_DIRECTORY            (1)
#define SXS_INSTALLATION_MOVE_DIRECTORY_IF_EXIST_MOVE_FILES_AND_SUBDIR (2)

#define SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_NO_APPLICATION_ROOT_PATH_REQUIRED    (0x00000001)
#define SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS                (0x00000002)
#define SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_PRIVATE_ASSEMBLIES              (0x00000004)

#define PROBING_ATTRIBUTE_CACHE_FLAG_GOT_NAME                   (0x00000001)
#define PROBING_ATTRIBUTE_CACHE_FLAG_GOT_VERSION                (0x00000002)
#define PROBING_ATTRIBUTE_CACHE_FLAG_GOT_PROCESSOR_ARCHITECTURE (0x00000004)
#define PROBING_ATTRIBUTE_CACHE_FLAG_GOT_PUBLIC_KEY_TOKEN       (0x00000008)
#define PROBING_ATTRIBUTE_CACHE_FLAG_GOT_LANGUAGE               (0x00000010)

typedef struct _PROBING_ATTRIBUTE_CACHE
{
    DWORD dwFlags;
    PCWSTR pszName;
    SIZE_T cchName;
    PCWSTR pszVersion;
    SIZE_T cchVersion;
    PCWSTR pszProcessorArchitecture;
    SIZE_T cchProcessorArchitecture;
    PCWSTR pszPublicKeyToken;
    SIZE_T cchPublicKeyToken;
    PCWSTR pszLanguage;
    SIZE_T cchLanguage;
} PROBING_ATTRIBUTE_CACHE, *PPROBING_ATTRIBUTE_CACHE;

BOOL
SxspGenerateManifestPathForProbing(
    IN DWORD dwLocationIndex,
    IN DWORD dwFlags,
    IN PCWSTR AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCchIn OPTIONAL,
    IN ULONG ApplicationDirectoryPathType OPTIONAL,
    IN PCWSTR ApplicationDirectory OPTIONAL,
    IN SIZE_T ApplicationDirectoryCchIn OPTIONAL,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE pProbingAttributeCache,
    IN OUT CBaseStringBuffer &PathBuffer,
    BOOL *pfPrivateAssemblyFlag,
    bool &rfDone
    );

#define SXSP_GENERATE_SXS_PATH_PATHTYPE_INVALID         (0)
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST        (1)
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY        (2)
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY          (3)
#define SXSP_GENERATE_SXS_PATH_PATHTYPE_SETUP_POLICY    (4)

#define SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT       (0x00000001)
#define SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH    (0x00000002)
#define SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION    (0x00000004)

BOOL
SxspGenerateSxsPath(
    IN DWORD Flags,
    IN ULONG PathType,
    IN PCWSTR AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCch OPTIONAL,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    OUT CBaseStringBuffer &PathBuffer
    );

//
//  I tried to roll this into SxspGenerateSxsPath but the logic was
//  way too convoluted. -mgrier 11/29/2001
//
BOOL
SxspGenerateNdpGACPath(
    IN DWORD dwFlags,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    OUT CBaseStringBuffer &rPathBuffer
    );

BOOL
SxspGenerateSxsPath_FullPathToManifestOrPolicyFile(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer
    );

BOOL
SxspGenerateSxsPath_RelativePathToManifestOrPolicyFile(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer
    );

BOOL
SxspGenerateSxsPath_FullPathToCatalogFile(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer
    );

BOOL
SxspGenerateSxsPath_RelativePathToCatalogFile(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer
    );

BOOL
SxspGenerateSxsPath_FullPathToPayloadOrPolicyDirectory(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer
    );

BOOL
SxspGenerateSxsPath_RelativePathToPayloadOrPolicyDirectory(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer
    );

//
//  Note that SxspGetAttributeValue() does not fail if the
//  attribute is not found; *Found is set to TRUE/FALSE based on whether
//  the attribute is found.
//

typedef struct _ATTRIBUTE_NAME_DESCRIPTOR
{
    PCWSTR Namespace;
    SIZE_T NamespaceCch;
    PCWSTR Name;
    SIZE_T NameCch;
} ATTRIBUTE_NAME_DESCRIPTOR, *PATTRIBUTE_NAME_DESCRIPTOR;

#define DECLARE_ATTRIBUTE_NAME_DESCRIPTOR(_AttributeNamespace, _AttributeName) \
static const WCHAR __AttributeName_ ## _AttributeName [] = L ## #_AttributeName; \
static const ATTRIBUTE_NAME_DESCRIPTOR s_AttributeName_ ## _AttributeName = { \
    _AttributeNamespace, sizeof(_AttributeNamespace) / sizeof(_AttributeNamespace[0]) - 1, __AttributeName_ ## _AttributeName, sizeof(#_AttributeName) / sizeof(#_AttributeName [0]) - 1 }

#define DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(_AttributeName) \
static const WCHAR __AttributeName_ ## _AttributeName [] = L ## #_AttributeName; \
static const ATTRIBUTE_NAME_DESCRIPTOR s_AttributeName_ ## _AttributeName = { NULL, 0, __AttributeName_ ## _AttributeName, sizeof(#_AttributeName) / sizeof(#_AttributeName [0]) - 1 }

//
//  For those writing validation routines:
//
//  Only if the validation routine fails because of environmental conditions
//  (e.g. it is not able to validate it rather than the validation fails)
//  should it return false.
//
//  If the validation fails, you should return a Win32 error code in the
//  *pdwValidationStatus value.  If you're at a loss for the error code
//  to use, when in doubt use ERROR_SXS_MANIFEST_PARSE_ERROR.  Any other
//  code is reported in log files and the error log but is translated
//  into ERROR_SXS_MANIFEST_PARSE_ERROR in higher layers anyways.
//

typedef BOOL (*SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE)(
    IN DWORD ValidationFlags,
    IN const CBaseStringBuffer &rBuffer,
    OUT bool &rfValid,
    IN SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    OUT SIZE_T &OutputBytesWritten
    );

//
//  If the ValidationRoutine is omitted, no validation is done on the string
//  and OutputBufferSize must be sizeof(CStringBuffer) and OutputBuffer must
//  point to a constructed CStringBuffer instance.
//

#define SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE (0x00000001)

BOOL
SxspGetAttributeValue(
    IN DWORD dwFlags,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName,
    IN PCSXS_NODE_INFO NodeInfo,
    IN SIZE_T NodeCount,
    IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    OUT bool &rfFound,
    IN SIZE_T OutputBufferSize,
    OUT PVOID OutputBuffer,
    OUT SIZE_T &OutputBytesWritten,
    IN SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE ValidationRoutine OPTIONAL,
    IN DWORD ValidationRoutineFlags OPTIONAL
    );

BOOL
SxspGetAttributeValue(
    IN DWORD dwFlags,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeName,
    IN PCACTCTXCTB_CBELEMENTPARSED ElementParsed,
    OUT bool &rfFound,
    IN SIZE_T OutputBufferSize,
    OUT PVOID OutputBuffer,
    OUT SIZE_T &OutputBytesWritten,
    IN SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE ValidationRoutine OPTIONAL,
    IN DWORD ValidationRoutineFlags OPTIONAL
    );

BOOL
SxspValidateBoolAttribute(
    DWORD Flags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    );

BOOL
SxspValidateUnsigned64Attribute(
    DWORD Flags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    );

BOOL
SxspValidateGuidAttribute(
    DWORD Flags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    );

#define SXSP_VALIDATE_PROCESSOR_ARCHITECTURE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED (0x00000001)

BOOL
SxspValidateProcessorArchitectureAttribute(
    DWORD Flags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    );

#define SXSP_VALIDATE_LANGUAGE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED (0x00000001)

BOOL
SxspValidateLanguageAttribute(
    DWORD Flags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten
    );

VOID
SxspDbgPrintActivationContextData(
    ULONG Level,
    PCACTIVATION_CONTEXT_DATA Data,
    CBaseStringBuffer &rbuffPerLinePrefix
    );

BOOL
SxspFormatFileTime(
    LARGE_INTEGER ft,
    CBaseStringBuffer &rBuffer
    );

BOOL
SxspIsRightXMLTag(
    PACTCTXCTB_CBELEMENTPARSED CBData,
    ULONG ExpectedDepth,
    PCWSTR ParentTagPath,
    PCWSTR ChildTag
    );

BOOL
SxspFindLastSegmentOfAssemblyName(
    IN PCWSTR AssemblyName,
    IN SIZE_T AssemblyNameCch OPTIONAL,
    OUT PCWSTR *LastSegment,
    OUT SIZE_T *LastSegmentCch
    );

typedef struct _ELEMENT_PATH_MAP_ENTRY {
    ULONG ElementDepth;
    PCWSTR ElementPath;
    SIZE_T ElementPathCch;
    ULONG MappedValue;
} ELEMENT_PATH_MAP_ENTRY, *PELEMENT_PATH_MAP_ENTRY;

typedef const ELEMENT_PATH_MAP_ENTRY *PCELEMENT_PATH_MAP_ENTRY;

BOOL
SxspProcessElementPathMap(
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    PCELEMENT_PATH_MAP_ENTRY MapEntries,
    SIZE_T MapEntryCount,
    ULONG &MappedValue,
    bool &Found
    );

HRESULT
SxspLogLastParseError(
    IXMLNodeSource *pSource,
    PCACTCTXCTB_PARSE_CONTEXT pParseContext
    );

// Merge this with util\io.cpp\FusionpCreateDirectories.
BOOL
SxspCreateMultiLevelDirectory(
    PCWSTR CurrentDirectory,
    PCWSTR pwszNewDirs
    );

#define SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED    (0x00000001)
#define SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED (0x00000008)
#define SXSP_VALIDATE_IDENTITY_FLAG_POLICIES_NOT_ALLOWED (0x00000010)

BOOL
SxspValidateIdentity(
    DWORD Flags,
    ULONG Type,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    );

typedef enum _SXS_DEBUG_OPERATION
{
    SXS_DEBUG_XML_PARSER,
    SXS_DEBUG_CREAT_MULTILEVEL_DIRECTORY,
    SXS_DEBUG_PROBE_MANIFST,
    SXS_DEBUG_CHECK_MANIFEST_SCHEMA,
    SXS_DEBUG_SET_ASSEMBLY_STORE_ROOT,
    SXS_DEBUG_PRECOMPILED_MANIFEST,
    SXS_DEBUG_TIME_PCM,
    SXS_DEBUG_FORCE_LEAK,
    SXS_DEBUG_PROBE_ASSEMBLY,
    SXS_DEBUG_DLL_REDIRECTION,
    SXS_DEBUG_FUSION_ARRAY,
    SXS_DEBUG_FOLDERNAME_FROM_ASSEMBLYIDENTITY_GENERATION,
    SXS_DEBUG_ASSEMBLYNAME_CONVERSION,
    SXS_DEBUG_DIRECTORY_WATCHER,
    SXS_DEBUG_SFC_SCANNER,
    SXS_DEBUG_GET_STRONGNAME,
    SXS_DEBUG_FUSION_REPARSEPOINT,
    SXS_DEBUG_ASSEMBLY_IDENTITY_HASH,
    SXS_DEBUG_CATALOG_SIGNER_CHECK,
    SXS_DEBUG_SYSTEM_DEFAULT_ACTCTX_GENERATION,
    SXS_DEBUG_SFC_UI_TEST,
    SXS_DEBUG_EXIT_PROCESS,
    SXS_DEBUG_PARSE_PATCH_FILE,
    SXS_DEBUG_EXPAND_CAB_FILE,
    SXS_DEBUG_TERMINATE_PROCESS
} SXS_DEBUG_OPERATION;

/*-----------------------------------------------------------------------------
FALSE / GetLastError upon error
will use GetFileAttributesEx instead of FindFirstFile when available
-----------------------------------------------------------------------------*/
#define SXSP_GET_FILE_SIZE_FLAG_COMPRESSION_AWARE (0x00000001)
#define SXSP_GET_FILE_SIZE_FLAG_GET_COMPRESSED_SOURCE_SIZE (0x00000002)

BOOL
SxspGetFileSize(
    DWORD dwFlags,
    PCWSTR pszFileName,
    ULONGLONG &rullSize
    );

BOOL
SxspInitAssembly(
    PASSEMBLY Asm,
    CProbedAssemblyInformation &AssemblyInformation
    );

/*-----------------------------------------------------------------------------
These let you avoid casting.
-----------------------------------------------------------------------------*/
 LONG SxspInterlockedIncrement(LONG*);
ULONG SxspInterlockedIncrement(ULONG*);
 LONG SxspInterlockedDecrement(LONG*);
ULONG SxspInterlockedDecrement(ULONG*);
 LONG SxspInterlockedExchange(LONG*, LONG);
ULONG SxspInterlockedExchange(ULONG*, ULONG);
 LONG SxspInterlockedCompareExchange(LONG*, LONG, LONG);
ULONG SxspInterlockedCompareExchange(ULONG*, ULONG, ULONG);
 LONG SxspInterlockedExchangeAdd(LONG*, LONG, LONG);
ULONG SxspInterlockedExchangeAdd(ULONG*, ULONG, ULONG);

/*
#if defined(_WIN64)
unsigned __int64 SxspInterlockedExchange(unsigned __int64* pi, unsigned __int64 x);
unsigned __int64 SxspInterlockedCompareExchange(unsigned __int64* pi, unsigned __int64 x, unsigned __int64 y);
#endif
*/

template <typename T> T* SxspInterlockedExchange(T** pp, T* p1);
template <typename T> T* SxspInterlockedCompareExchange(T** pp, T* p1, T* p2);

BOOL
SxspIncorporateAssembly(
    PACTCTXGENCTX pActCtxGenCtx,
    PASSEMBLY Asm
    );

/*-----------------------------------------------------------------------------
impersonate in constructor, unimpersonate in destructor, but we use
explicit unimpersonation in order to progagate its error
-----------------------------------------------------------------------------*/

class CImpersonate
{
public:
    CImpersonate(const CImpersonationData &ImpersonationData) : m_ImpersonationData(ImpersonationData), m_Impersonating(FALSE) { }
    ~CImpersonate()
    {
        if (m_Impersonating)
        {
            CSxsPreserveLastError ple;

            //
            // removed SOFT_VERIFY2 because
            // 1) this line has never been seen to fail
            // 2) SOFT_VERIFY2 or somesuch seemed to cause problems in the past
            //
            m_ImpersonationData.Call(CImpersonationData::eCallTypeUnimpersonate);

            ple.Restore();
        }
    }

    BOOL Impersonate()
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        INTERNAL_ERROR_CHECK(!m_Impersonating);
        IFW32FALSE_EXIT(m_ImpersonationData.Call(CImpersonationData::eCallTypeImpersonate));
        m_Impersonating = TRUE;
        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

    enum UnimpersonateWhenNotImpersonatingBehavior
    {
        eUnimpersonateFailsIfNotImpersonating,
        eUnimpersonateSucceedsIfNotImpersonating
    };

    BOOL Unimpersonate(UnimpersonateWhenNotImpersonatingBehavior e = eUnimpersonateFailsIfNotImpersonating)
    {
        BOOL fSuccess = FALSE;
        FN_TRACE_WIN32(fSuccess);

        PARAMETER_CHECK((e == eUnimpersonateFailsIfNotImpersonating) || (e == eUnimpersonateSucceedsIfNotImpersonating));

        if (e == eUnimpersonateFailsIfNotImpersonating)
            INTERNAL_ERROR_CHECK(m_Impersonating);

        if (m_Impersonating)
        {
            m_Impersonating = FALSE;
            IFW32FALSE_EXIT(m_ImpersonationData.Call(CImpersonationData::eCallTypeUnimpersonate));
        }

        fSuccess = TRUE;
    Exit:
        return fSuccess;
    }

private:
    CImpersonationData m_ImpersonationData;
    BOOL m_Impersonating;
};

/*-----------------------------------------------------------------------------
deletes recursively, including readonly files, continues after errors,
but returns if there were any
-----------------------------------------------------------------------------*/

BOOL
SxspDeleteDirectory(
    const CBaseStringBuffer &rdir
    );

#define SXSP_MOVE_FILE_FLAG_COMPRESSION_AWARE 1

BOOL
SxspMoveFilesUnderDir(
    DWORD dwFlags,
    CBaseStringBuffer & sbSourceDir,
    CBaseStringBuffer & sbDestDir,
    DWORD dwMoveFileFlags
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

typedef struct _SXSP_LOCALLY_UNIQUE_ID
{
    SYSTEMTIME stTimeStamp;
    ULONG ulUniquifier;
} SXSP_LOCALLY_UNIQUE_ID, *PSXSP_LOCALLY_UNIQUE_ID;
typedef const SXSP_LOCALLY_UNIQUE_ID* PCSXSP_LOCALLY_UNIQUE_ID;

BOOL
SxspCreateLocallyUniqueId(
    OUT PSXSP_LOCALLY_UNIQUE_ID pUniqueId
    );

BOOL
SxspFormatLocallyUniqueId(
    IN const SXSP_LOCALLY_UNIQUE_ID &rluid,
    OUT CBaseStringBuffer &rBuffer
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

VOID
SxspInitializeSListHead(
    IN PSLIST_HEADER ListHead
    );

PSLIST_ENTRY
SxspInterlockedPopEntrySList(
    IN PSLIST_HEADER ListHead
    );

PSLIST_ENTRY
SxspPopEntrySList(
    IN PSLIST_HEADER ListHead
    );

PSLIST_ENTRY
SxspInterlockedPushEntrySList(
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

class __declspec(align(16)) CAlignedSingleListEntry : public SLIST_ENTRY { };

class CCleanupBase : public CAlignedSingleListEntry
{
public:
    CCleanupBase() : m_fInAtExitList(false) { }

    virtual VOID DeleteYourself() = 0;

    bool m_fInAtExitList;

protected:
    virtual ~CCleanupBase() = 0 { }

};

BOOL
SxspAtExit(
    CCleanupBase* pCleanup
    );

BOOL
SxspTryCancelAtExit(
    CCleanupBase* pCleanup
    );

BOOL
SxspInstallDecompressOrCopyFileW(
    PCWSTR lpSource,
    PCWSTR lpDest,
    BOOL bFailIfExists);

BOOL
SxspInstallMoveFileExW(
    CBaseStringBuffer &moveOrigination,
    CBaseStringBuffer &moveDestination,
    DWORD             dwFlags,
    BOOL              fAwareNonCompressed = FALSE
    );


BOOL SxspInstallDecompressAndMoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags,
    BOOL fAwareNonCompressed = FALSE
    );

/*-----------------------------------------------------------------------------
create a unique temp directory under %windir%\WinSxs
-----------------------------------------------------------------------------*/
BOOL
SxspCreateWinSxsTempDirectory(
    OUT CBaseStringBuffer &rbuffTemp,
    OUT SIZE_T * pcch OPTIONAL = NULL,
    OUT CBaseStringBuffer *pBuffUniquePart OPTIONAL = NULL, // good to pass to CRunOnceDeleteDirectory::Initialize
    OUT SIZE_T * pcchUniquePart OPTIONAL = NULL
    );

#define SXSP_CREATE_ASSEMBLY_IDENTITY_FROM_IDENTITY_TAG_FLAG_VERIFY_PUBLIC_KEY_IF_PRESENT (0x00000001)

BOOL
SxspCreateAssemblyIdentityFromIdentityElement(
    DWORD Flags,
    ULONG Type,
    PASSEMBLY_IDENTITY *AssemblyIdentityOut,
    DWORD cNumRecs,
    PCSXS_NODE_INFO prgNodeInfo
    );

/*-----------------------------------------------------------------------------
this must be heap allocated
the C-api enforces that
-----------------------------------------------------------------------------*/

class CRunOnceDeleteDirectory : public CCleanupBase
{
public:
    CRunOnceDeleteDirectory() { }

    BOOL
    Initialize(
        IN const CBaseStringBuffer &rbuffDirectoryToDelete,
        IN const CBaseStringBuffer *pstrUniqueKey OPTIONAL = NULL
        );

    BOOL Cancel();

    // very unusual.. this is noncrashing, but
    // leaves the stuff in the registry
    BOOL Close();

    VOID DeleteYourself() { FUSION_DELETE_SINGLETON(this); }

    ~CRunOnceDeleteDirectory();
protected:

    CFusionRegKey       m_hKey;
    CStringBuffer   m_strValueName;

private:
    CRunOnceDeleteDirectory(const CRunOnceDeleteDirectory &);
    void operator =(const CRunOnceDeleteDirectory &);
};

/*-----------------------------------------------------------------------------
C-like API over the above
-----------------------------------------------------------------------------*/

BOOL
SxspCreateRunOnceDeleteDirectory(
    IN const CBaseStringBuffer &rbuffDirectoryToDelete,
    IN const CBaseStringBuffer *pbuffUniqueKey OPTIONAL,
    OUT PVOID* cookie
    );

BOOL
SxspCancelRunOnceDeleteDirectory(
    PVOID cookie
    );

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/

USHORT
SxspGetSystemProcessorArchitecture();

/*-----------------------------------------------------------------------------*/

RTL_PATH_TYPE
SxspDetermineDosPathNameType(
    PCWSTR DosFileName
    );

/*-----------------------------------------------------------------------------*/

interface IAssemblyName;

typedef
HRESULT
(STDAPICALLTYPE*
PFNCreateAssemblyNameObject)(
    OUT IAssemblyName** ppAssemblyName,
    IN LPCOLESTR        szAssemblyName,
    IN DWORD            dwFlags,
    LPVOID              pvReserved
    );

typedef HRESULT (WINAPI * PFNCreateAssemblyCache)(
    OUT IAssemblyCache **ppAsmCache,
    IN  DWORD dwReserved
    );

typedef HRESULT (WINAPI * PFNCreateAssemblyCacheItem)(
    OUT IAssemblyCacheItem** ppAsmItem,
    IN  IAssemblyName *pName,
    IN  PCWSTR pwzCodebase,
    IN  FILETIME *pftLastMod,
    IN  DWORD dwInstaller,
    IN  DWORD dwReserved
    );

/*-----------------------------------------------------------------------------*/

//
//  Private APIs used by OLEAUT32 to invoke isolation:
//

EXTERN_C HRESULT STDAPICALLTYPE SxsOleAut32MapReferenceClsidToConfiguredClsid(
    REFCLSID rclsidIn,
    CLSID *pclsidOut
    );

EXTERN_C HRESULT STDAPICALLTYPE SxsOleAut32RedirectTypeLibrary(
    LPCOLESTR szGuid,
    WORD wMaj,
    WORD wMin,
    LCID lcid,
    BOOL fHighest,
    SIZE_T *pcchFileName,
    LPOLESTR rgFileName
    );

/*-----------------------------------------------------------------------------*/

BOOL
SxspDoesPathCrossReparsePointVa(
    PCWSTR BasePath,
    SIZE_T cchBasePath,
    PCWSTR Path,
    SIZE_T  cchPath,
    BOOL &CrossesReparsePoint,
    DWORD &dwLastError,
    SIZE_T cOkErrors,
    va_list vaOkErrors
    );



inline BOOL
SxspDoesPathCrossReparsePoint(
    PCWSTR BasePath,
    SIZE_T cchBasePath,
    PCWSTR Path,
    SIZE_T  cchPath,
    BOOL &CrossesReparsePoint,
    DWORD &dwLastError,
    SIZE_T cOkErrors,
    ...
    )
{
    va_list va;
    va_start(va, cOkErrors);
    return SxspDoesPathCrossReparsePointVa(BasePath, cchBasePath, Path, cchPath, CrossesReparsePoint, dwLastError, cOkErrors, va);
}


inline BOOL
SxspDoesPathCrossReparsePoint(
    PCWSTR BasePath,
    SIZE_T cchBasePath,
    PCWSTR Path,
    SIZE_T  cchPath,
    BOOL &CrossesReparsePoint
    )
{
    DWORD dwError;
    return SxspDoesPathCrossReparsePoint(BasePath, cchBasePath, Path, cchPath, CrossesReparsePoint, dwError, 0);
}

inline BOOL
SxspDoesPathCrossReparsePoint(
    PCWSTR Path,
    SIZE_T  Start,
    BOOL &CrossesReparsePoint
    )
{
    const SIZE_T PathLength = StringLength(Path);
    return SxspDoesPathCrossReparsePoint(
        Path,
        PathLength,
        Path + Start,
        PathLength - Start,
        CrossesReparsePoint);
}


/*-----------------------------------------------------------------------------
inline implementations
-----------------------------------------------------------------------------*/

#include "sxsntrtl.inl"

inline USHORT
SxspGetSystemProcessorArchitecture()
{
    SYSTEM_INFO systemInfo;
    systemInfo.wProcessorArchitecture = DEFAULT_ARCHITECTURE;

    GetSystemInfo(&systemInfo);

    return systemInfo.wProcessorArchitecture;
}

#define SXS_REALLY_PRIVATE_INTERLOCKED1(SxsFunction, Win32Function, SxsT, Win32T) \
    inline SxsT Sxsp##SxsFunction(SxsT* p) { return (SxsT)Win32Function((Win32T*)p); }
#define SXS_REALLY_PRIVATE_INTERLOCKED2(SxsFunction, Win32Function, SxsT, Win32T) \
    inline SxsT Sxsp##SxsFunction(SxsT* p, SxsT x) { return (SxsT)Win32Function((Win32T*)p, (Win32T)x); }
#define SXS_REALLY_PRIVATE_INTERLOCKED3(SxsFunction, Win32Function, SxsT, Win32T) \
    inline SxsT Sxsp##SxsFunction(SxsT* p, SxsT x, SxsT y) { return (SxsT)Win32Function((Win32T*)p, (Win32T)x, (Win32T)y); }

SXS_REALLY_PRIVATE_INTERLOCKED1(InterlockedIncrement, InterlockedIncrement, LONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED1(InterlockedIncrement, InterlockedIncrement, ULONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED1(InterlockedDecrement, InterlockedDecrement, LONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED1(InterlockedDecrement, InterlockedDecrement, ULONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchange, LONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchange, ULONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED3(InterlockedCompareExchange, InterlockedCompareExchange, LONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED3(InterlockedCompareExchange, InterlockedCompareExchange, ULONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchangeAdd, InterlockedExchangeAdd, LONG, LONG)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchangeAdd, InterlockedExchangeAdd, ULONG, LONG)

#if defined(_WIN64)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchangePointer, __int64, PVOID)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchangePointer, unsigned __int64, PVOID)
SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchangePointer, PCWSTR, PVOID)
SXS_REALLY_PRIVATE_INTERLOCKED3(InterlockedCompareExchange, InterlockedCompareExchangePointer, __int64, PVOID)
SXS_REALLY_PRIVATE_INTERLOCKED3(InterlockedCompareExchange, InterlockedCompareExchangePointer, unsigned __int64, PVOID)
#endif

template <typename U> SXS_REALLY_PRIVATE_INTERLOCKED2(InterlockedExchange, InterlockedExchangePointer, U*, PVOID)
template <typename U> SXS_REALLY_PRIVATE_INTERLOCKED3(InterlockedCompareExchange, InterlockedCompareExchangePointer, U*, PVOID)

#undef SXS_REALLY_PRIVATE_INTERLOCKED1
#undef SXS_REALLY_PRIVATE_INTERLOCKED2
#undef SXS_REALLY_PRIVATE_INTERLOCKED3

inline BOOL operator==(const FILETIME& ft1, const FILETIME& ft2)
{
    BOOL fResult = (
        ft1.dwLowDateTime == ft2.dwLowDateTime
        && ft1.dwHighDateTime == ft2.dwHighDateTime);
    return fResult;
}

inline BOOL operator!=(const FILETIME& ft1, const FILETIME& ft2)
{
    return !(ft1 == ft2);
}

inline BOOL operator==(const FILETIME& ft, __int64 i)
{
    LARGE_INTEGER lift;
    LARGE_INTEGER lii;

    lii.QuadPart = i;
    lift.LowPart = ft.dwLowDateTime;
    lift.HighPart = ft.dwHighDateTime;

    return (lii.QuadPart == lift.QuadPart);
}

inline BOOL operator!=(const FILETIME& ft, __int64 i)
{
    return !(ft == i);
}

//
// Some helpful strings, centralized
//
#define FILE_EXTENSION_CATALOG          ( L"cat" )
#define FILE_EXTENSION_CATALOG_CCH      ( NUMBER_OF( FILE_EXTENSION_CATALOG ) - 1 )
#define FILE_EXTENSION_MANIFEST         ( L"manifest" )
#define FILE_EXTENSION_MANIFEST_CCH     ( NUMBER_OF( FILE_EXTENSION_MANIFEST ) - 1 )
#define FILE_EXTENSION_MAN              ( L"man" )
#define FILE_EXTENSION_MAN_CCH          ( NUMBER_OF( FILE_EXTENSION_MAN ) - 1 )

int  SxspHexDigitToValue(WCHAR wch);
bool SxspIsHexDigit(WCHAR wch);

BOOL
SxspExpandRelativePathToFull(
    IN PCWSTR wszString,
    IN SIZE_T cchString,
    OUT CBaseStringBuffer &rbuffDestination
    );

BOOL
SxspParseComponentPolicy(
    DWORD Flags,
    PACTCTXGENCTX pActCtxGenCtx,
    const CProbedAssemblyInformation &PolicyAssemblyInformation,
    CPolicyStatement *&rpPolicyStatement
    );

BOOL
SxspParseApplicationPolicy(
    DWORD Flags,
    PACTCTXGENCTX pActCtxGenCtx,
    ULONG ulPolicyPathType,
    PCWSTR pszPolicyPath,
    SIZE_T cchPolicyPath,
    IStream *pIStream
    );

BOOL
SxspParseNdpGacComponentPolicy(
    ULONG Flags,
    PACTCTXGENCTX pGenContext,
    const CProbedAssemblyInformation &PolicyAssemblyInformation,
    CPolicyStatement *&rpPolicyStatement
    );

#define POLICY_PATH_FLAG_POLICY_IDENTITY_TEXTUAL_FORMAT     0
#define POLICY_PATH_FLAG_FULL_QUALIFIED_POLICIES_DIR        1
#define POLICY_PATH_FLAG_FULL_QUALIFIED_POLICY_FILE_NAME    2


//
// Generate the shortened name version of this path string
//
BOOL
SxspGetShortPathName(
    IN const CBaseStringBuffer &rcbuffLongPathName,
    OUT CBaseStringBuffer &rbuffShortenedVersion
    );

BOOL
SxspGetShortPathName(
    IN const CBaseStringBuffer &rcbuffLongPathName,
    OUT CBaseStringBuffer &rbuffShortenedVersion,
    DWORD &rdwWin32Error,
    SIZE_T cExceptionalWin32Errors,
    ...
    );

BOOL
SxspLoadString(
    HINSTANCE hSource,
    UINT uiStringIdent,
    OUT CBaseStringBuffer &rbuffOutput
    );

BOOL
SxspFormatString(
    DWORD dwFlags,
    LPCVOID pvSource,
    DWORD dwId,
    DWORD dwLangId,
    OUT CBaseStringBuffer &rbuffOutput,
    va_list* pvalArguments
    );

BOOL
SxspSaveAssemblyRegistryData(
    DWORD Flags,
    IN PCASSEMBLY_IDENTITY pcAssemblyIdentity
    );

#define FILE_OR_PATH_NOT_FOUND(x) (((x) == ERROR_FILE_NOT_FOUND) || ((x) == ERROR_PATH_NOT_FOUND))

#define PRIVATIZE_COPY_CONSTRUCTORS( obj ) obj( const obj& ); obj& operator=(const obj&);

BOOL
SxspGenerateAssemblyNameInRegistry(
    IN PCASSEMBLY_IDENTITY pcAsmIdent,
    OUT CBaseStringBuffer &rbuffRegistryName
    );

BOOL
SxspGenerateAssemblyNameInRegistry(
    IN const CBaseStringBuffer &rcbuffTextualString,
    OUT CBaseStringBuffer &rbuffRegistryName
    );

BOOL
SxspGetRemoteUniversalName(
    IN PCWSTR pcszPathName,
    OUT CBaseStringBuffer &rbuffUniversalName
    );

#define SXS_GET_VOLUME_PATH_NAME_NO_FULLPATH    (0x00000001)

BOOL
SxspGetVolumePathName(
    IN DWORD dwFlags,
    IN PCWSTR pcwszVolumePath,
    OUT CBaseStringBuffer &buffVolumePathName
    );

BOOL
SxspGetFullPathName(
    IN  PCWSTR pcwszPathName,
    OUT CBaseStringBuffer &rbuffPathName,
    OUT CBaseStringBuffer *pbuffFilePart = NULL
    );

BOOL
SxspGetVolumeNameForVolumeMountPoint(
    IN PCWSTR pcwsMountPoint,
    OUT CBaseStringBuffer &rbuffMountPoint
    );

BOOL
SxspExpandEnvironmentStrings(
    IN PCWSTR pcwszSource,
    OUT CBaseStringBuffer &buffTarget
    );

BOOL
SxspDoesMSIStillNeedAssembly(
    IN  PCWSTR pcAsmName,
    OUT BOOL &rfNeedsAssembly
    );

BOOL
SxspIsFileNameValidForManifest(
    const CBaseStringBuffer &rsbFileName,
    bool &rfValid
    );

typedef CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> CSmartAssemblyIdentity;

#define SXSP_MODIFY_REGISTRY_DATA_FLAG_REPAIR_SHORT_NAMES                (0x00000001)
#define SXSP_MODIFY_REGISTRY_DATA_FLAG_DELETE_SHORT_NAMES                (0x00000002)
#define SXSP_MODIFY_REGISTRY_DATA_FLAG_REPAIR_OFFLINE_INSTALL_REFRESH_PROMPTS (0x00000004)
#define SXSP_MODIFY_REGISTRY_DATA_FLAG_REPAIR_ALL                        (0x00000008)
#define SXSP_MODIFY_REGISTRY_DATA_FLAG_REPAIR_CODEBASE_KEYS_TO_VALUES    (0x00000010)
#define SXSP_MODIFY_REGISTRY_DATA_VALIDATE                               (0x00000020)
#define SXSP_MODIFY_REGISTRY_DATA_FLAG_VALID_FLAGS                       (0x0000002F)

BOOL
SxspModifyRegistryData(
    DWORD Flags
    );

BOOL
SxspDeleteShortNamesInRegistry(
    VOID
    );

STDAPI
DllInstall(
	BOOL fInstall,
	PCWSTR pszCmdLine
    );

#define SXSP_OFFLINE_INSTALL_REFRESH_PROMPT_PLACEHOLDER L"(offline setup placeholder {b3759bd6-4503-4856-8518-109b9791855e})"

#define SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL_STRING L"OS"

#endif // !defined(_FUSION_DLL_WHISTLER_SXSP_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxspath.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxspath.cpp

Abstract:

    popular cousin of "String.cpp" and "Wheel.cpp"

Author:

    Jay Krell (a-JayK, JayKrell) April 2000

Revision History:

--*/
#include "stdinc.h"
#include "fusiontrace.h"
#include "fusionbuffer.h"
#include "sxsntrtl.inl"
#include "sxspath.h"

/*-----------------------------------------------------------------------------
Building on CFullPathSplitPointers, take two strings and split them up
exactly as the SetupCopyQueue API wants them, into
source root, root path, source name (base + extension)
destination directory (root + path), destination name (base + extension)

The output of this class is its public member data.
-----------------------------------------------------------------------------*/

BOOL
CSetupCopyQueuePathParameters::Initialize(
    PCWSTR pszSource,
    PCWSTR pszDestination
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CStringBufferAccessor Accessor;

    IFW32FALSE_EXIT(m_sourceBuffer.Win32Assign(pszSource, (pszSource != NULL) ? ::wcslen(pszSource) : 0));
    IFW32FALSE_EXIT(m_destinationBuffer.Win32Assign(pszDestination, (pszDestination != NULL) ? ::wcslen(pszDestination) : 0));

    Accessor.Attach(&m_sourceBuffer);
    IFW32FALSE_EXIT(m_sourceSplit.Initialize(Accessor.GetBufferPtr()));
    Accessor.Detach();

    Accessor.Attach(&m_destinationBuffer);
    IFW32FALSE_EXIT(m_destinationSplit.Initialize(Accessor.GetBufferPtr()));
    Accessor.Detach();

    if (m_sourceSplit.m_rootEnd - m_sourceSplit.m_root == 3)
    {
        m_sourceRootStorage[0] = m_sourceBuffer[0];
        m_sourceRootStorage[1] = ':';
        m_sourceRootStorage[2] = CUnicodeCharTraits::PreferredPathSeparator();
        m_sourceRootStorage[3] = 0;
        m_sourceSplit.m_root = m_sourceRootStorage;
        m_sourceSplit.m_rootEnd = m_sourceRootStorage + 3;
        m_sourceRoot = m_sourceRootStorage;
    }
    else
    {
        ASSERT(::FusionpIsPathSeparator(*m_sourceSplit.m_rootEnd));
        *m_sourceSplit.m_rootEnd = 0;
        m_sourceRoot = m_sourceSplit.m_root;
    }
    if (m_sourceSplit.m_pathEnd != NULL)
    {
        *m_sourceSplit.m_pathEnd = 0;
    }

    if (m_sourceSplit.m_path != NULL)
    {
        m_sourcePath = m_sourceSplit.m_path;
        *m_sourceSplit.m_pathEnd = 0;
    }
    else
    {
        m_sourcePath = L"";
    }

    if (m_sourceSplit.m_base != NULL)
    {
        m_sourceName = m_sourceSplit.m_base;
    }
    else
    {
        m_sourceName = m_sourceSplit.m_extension - 1;
    }
    // sourceName runs to end of original string, so no terminal nul needs to be stored

    // destination is simpler, not as much worth all the splitting work.
    // again though, we don't want to write a nul over the slash in c:\ if
    // that string stands alone; we don't need a root here, so it's less likely,
    // but the case of returning the root+path of a file at the root..
    if (
            (m_destinationSplit.m_base != NULL
                && m_destinationSplit.m_base - m_destinationSplit.m_root == 3) // c:\foo.txt
        || (m_destinationSplit.m_extension != NULL
                && m_destinationSplit.m_extension - m_destinationSplit.m_root == 4) // c:\.txt
        )
    {
        ASSERT(m_destinationSplit.m_path == NULL);
        m_destinationDirectoryStorage[0] = m_destinationBuffer[0];
        m_destinationDirectoryStorage[1] = ':';
        m_destinationDirectoryStorage[2] = CUnicodeCharTraits::PreferredPathSeparator();
        m_destinationDirectoryStorage[3] = 0;

        m_destinationSplit.m_root = m_destinationDirectoryStorage;
        m_destinationSplit.m_rootEnd = m_destinationDirectoryStorage + 3;
        m_destinationDirectory = m_destinationDirectoryStorage;
    }
    else
    {
        m_destinationDirectory = m_destinationBuffer; // == m_destinationSplit.m_root
    }
    PWSTR destinationName; // temporarily mutable
    if (m_destinationSplit.m_base != NULL)
    {
        destinationName = m_destinationSplit.m_base;
    }
    else
    {
        // c:\.foo
        destinationName = m_destinationSplit.m_extension - 1;
    }
    ASSERT(::FusionpIsPathSeparator(*(destinationName - 1)));
    *(destinationName - 1) = 0;
    m_destinationName = destinationName; // now const

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsprobe.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "windows.h"
#include "stdlib.h"
#include "sxsp.h"
#include "util.h"
#include "fusionhandle.h"
#include "fusionhash.h"
#pragma warning(error:4244)

#define ASMPROBE_DOT		(L".")
#define ASMPROBE_WILDCARD	(L"*")

BOOL
SxsProbeAssemblyInstallation(
    DWORD dwFlags,
    PCWSTR lpAsmIdentSource,
    PDWORD lpDisposition
    )
{
    FN_PROLOG_WIN32

    CMediumStringBuffer AssemblyPathBuffer, AssemblyRoot, ManifestPathBuffer;
    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, ::SxsDestroyAssemblyIdentity> pAssemblyIdentity;
    DWORD dwDisposition = 0;
    BOOL fIsPolicy;
    DWORD dwAttributes, dwLastError;

    if (lpDisposition != NULL)
        *lpDisposition = 0;

    IFINVALID_FLAGS_EXIT_WIN32(dwFlags, SXS_PROBE_ASSEMBLY_INSTALLATION_IDENTITY_PRECOMPOSED);
    PARAMETER_CHECK(lpAsmIdentSource != NULL);
    PARAMETER_CHECK(lpDisposition != NULL);

    //
    // If the lpAsmIdentSource is really a PCASSEMBLY_IDENTITY, then attach (no delete)
    // for use.
    //
    if (dwFlags & SXS_PROBE_ASSEMBLY_INSTALLATION_IDENTITY_PRECOMPOSED)
    {
        pAssemblyIdentity.AttachNoDelete(reinterpret_cast<PASSEMBLY_IDENTITY>(const_cast<PWSTR>(lpAsmIdentSource)));
    }
    //
    // Otherwise, create an assembly identity from the string that was there
    //
    else
    {
        IFW32FALSE_EXIT(::SxspCreateAssemblyIdentityFromTextualString(
            lpAsmIdentSource,
            &pAssemblyIdentity));
    }

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(AssemblyRoot));

    IFW32FALSE_EXIT(
        ::SxspValidateIdentity(
            SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED,
            ASSEMBLY_IDENTITY_TYPE_REFERENCE,
            pAssemblyIdentity));

    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(pAssemblyIdentity, fIsPolicy));

    // AssemblyIdentity is created, now generate the path
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            0,
            (fIsPolicy ? SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY : SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST),
            AssemblyRoot,
            AssemblyRoot.Cch(),
            pAssemblyIdentity,
            NULL,
            ManifestPathBuffer));

     //
    // See if the file is there.
    //
    IFW32FALSE_EXIT(
        ::SxspGetFileAttributesW(
            ManifestPathBuffer, 
            dwAttributes, 
            dwLastError, 
            2, 
            ERROR_FILE_NOT_FOUND, 
            ERROR_PATH_NOT_FOUND));

    //
    // Path not found or file not found means The assembly can't possibly be installed or resident.
    //
    if (dwLastError != ERROR_SUCCESS)
    {
        dwDisposition |= SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_NOT_INSTALLED;
        goto DoneLooking;
    }
    //
    // Otherwise, the manifest or policy file was present, so the assembly is installed.
    //
    else
    {
        dwDisposition |= SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_INSTALLED;
    }

    //
    // If this assembly is policy, we need to not look to see if it's resident -
    // it's always resident, and we can quit looking.
    //
    if (fIsPolicy)
    {
        dwDisposition |= SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_RESIDENT;
        goto DoneLooking;
    }
    //
    // Otherwise, we should look to see if the directory for the assembly is present -
    // if it is, then the assembly is "resident".
    //
    else
    {
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                AssemblyRoot,
                AssemblyRoot.Cch(),
                pAssemblyIdentity,
                NULL,
                AssemblyPathBuffer));

        IFW32FALSE_EXIT(
            ::SxspGetFileAttributesW(
                AssemblyPathBuffer,
                dwAttributes,
                dwLastError,
                2,
                ERROR_FILE_NOT_FOUND,
                ERROR_PATH_NOT_FOUND));

        //
        // We found the path, and it's a directory!
        //
        if ((dwLastError == ERROR_SUCCESS) && (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            dwDisposition |= SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_RESIDENT;
        }
        //
        // Hmm... failed to find the directory, looks like we have to see if there were
        // any actual files in the assembly before we say that it's not resident.
        //
        else
        {
            SXS_MANIFEST_INFORMATION_BASIC ManifestInfo;
            SIZE_T cbRequired;

            IFW32FALSE_EXIT(
                ::SxsQueryManifestInformation(
                    0, 
                    ManifestPathBuffer, 
                    SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC,
                    SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_IDENTITY |
                    SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME,
                    sizeof(ManifestInfo),
                    (PVOID)&ManifestInfo,
                    &cbRequired));
                    

            if (ManifestInfo.ulFileCount == 0)
            {
                dwDisposition |= SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_RESIDENT;
            }
        }
    }

DoneLooking:    
    *lpDisposition = dwDisposition;

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsprotect.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
Some general issues in this file:

    We should stop using slists.

    Shouldn't wfp/sfc work even under stress? Should we preallocate memory during boot?
*/
#include "stdinc.h"
#include "util.h"
#include "xmlparser.hxx"
#include "fusioneventlog.h"
#include "hashfile.h"
#include "recover.h"
#include "filestream.h"
#include "cassemblyrecoveryinfo.h"
#include "sxsprotect.h"
#include "strongname.h"
#include "sxsexceptionhandling.h"
#include "sxssfcscan.h"

#define MANIFEST_FILE_EXTENSION     (L".manifest")
#define FILE_ELEMENT_NAME           (L"file")

#define HASH_ATTRIB_NAME            (L"hash")
#define FILE_ATTRIB_NAME            (L"name")
#define HASHALG_ATTRIB_NAME         (L"hashalg")

class CProtectionRequestList;
CProtectionRequestList* g_ProtectionRequestList;
HANDLE g_hSxsLoginEvent;
BOOL s_fIsSfcAcceptingNotifications = TRUE;

BOOL
CRecoveryJobTableEntry::Initialize()
{
    FN_PROLOG_WIN32

    //
    // Creates an event that other callers should wait on - manual reset, not
    // currently signalled.
    //
    m_Subscriber = 0;
    m_fSuccessValue = FALSE;
    IFW32NULL_EXIT(m_EventInstallingAssemblyComplete = ::CreateEventW(NULL, TRUE, FALSE, NULL));

    FN_EPILOG
}

BOOL
CRecoveryJobTableEntry::StartInstallation()
{
    FN_PROLOG_WIN32

    //
    // Clear the event (if it wasn't already cleared.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(::ResetEvent(m_EventInstallingAssemblyComplete));

    FN_EPILOG
}


BOOL
SxspEnsureCatalogStillPresentForManifest(
    IN const CBaseStringBuffer& buffManifestPath,
    OUT BOOL &rfStillPresent
    )
{
    FN_PROLOG_WIN32

    rfStillPresent = FALSE;

    CStringBuffer buffCatalogPath;
    bool fExist = false;

    IFW32FALSE_EXIT(buffCatalogPath.Win32Assign(buffManifestPath));

    IFW32FALSE_EXIT(
        buffCatalogPath.Win32ChangePathExtension(
            FILE_EXTENSION_CATALOG,
            FILE_EXTENSION_CATALOG_CCH,
            eAddIfNoExtension));
    IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_FILE_ONLY | SXSP_DOES_FILE_EXIST_FLAG_INCLUDE_NETWORK_ERRORS, buffCatalogPath, fExist));
    if (fExist)
    {
        rfStillPresent = TRUE;
    }
    
    FN_EPILOG
}

BOOL
CRecoveryJobTableEntry::InstallationComplete(
    BOOL bDoneOk,
    SxsRecoveryResult Result,
    DWORD dwRecoveryLastError
    )
{
    FN_PROLOG_WIN32

    m_Result = Result;
    m_fSuccessValue = bDoneOk;
    m_dwLastError = dwRecoveryLastError;

    //
    // This will tell all the people waiting that we're done and that they
    // should capture the exit code and exit out.
    //
    IFW32FALSE_ORIGINATE_AND_EXIT(::SetEvent(m_EventInstallingAssemblyComplete));

    //
    // We wait for all our subscribers to go away (ie: for them to capture an
    // install code and success value.)
    //
    while (m_Subscriber)
    {
        Sleep(50);
    }

    FN_EPILOG
}


BOOL
CRecoveryJobTableEntry::WaitUntilCompleted(
    SxsRecoveryResult &rResult,
    BOOL &rfSucceededValue,
    DWORD &rdwErrorResult
    )
{
    FN_PROLOG_WIN32

    DWORD WaitResult = 0;

    rfSucceededValue = FALSE;

    //
    // Here we join up to the existing installation routine. We up the number
    // of people waiting before entering the wait.  I wish there was a better
    // way of doing this, something like a built-in kernel object that we can
    // raise a count on (like a semaphore), and have another thread lower a
    // count on, and someone can wait on the internal count being zero.  Yes,
    // I could implement this by hand using something with another event or
    // two, but that's not the point.
    //
    ::SxspInterlockedIncrement(&m_Subscriber);

    //
    // Hang about forever until another thread is done installing
    //
    IFW32FALSE_ORIGINATE_AND_EXIT((WaitResult = ::WaitForSingleObject(m_EventInstallingAssemblyComplete, INFINITE)) != WAIT_FAILED);

    //
    // Capture values once the installation is done, return them to the caller.
    //
    rResult = m_Result;
    rdwErrorResult = m_dwLastError;
    rfSucceededValue = m_fSuccessValue;

    //
    // And indicate that we're complete.
    //
    ::SxspInterlockedDecrement(&m_Subscriber);

    FN_EPILOG
}

CRecoveryJobTableEntry::~CRecoveryJobTableEntry()
{
    //
    // We're done with the event, so close it (release refcount, we don't want lots of these
    // just sitting around.)
    //
    if ((m_EventInstallingAssemblyComplete != NULL) &&
        (m_EventInstallingAssemblyComplete != INVALID_HANDLE_VALUE))
    {
        ::CloseHandle(m_EventInstallingAssemblyComplete);
        m_EventInstallingAssemblyComplete = INVALID_HANDLE_VALUE;
    }
}


//
// This is our holy grail of sxs protection lists.  Don't fidget with
// this listing.  Note that we've also got only one.  This is because
// right now, there's only one entry to be had (a), and (b) because we
// will fill in the sxs directory on the fly at runtime.
//
SXS_PROTECT_DIRECTORY s_SxsProtectionList[] =
{
    {
        {0},
        0,
        SXS_PROTECT_RECURSIVE,
        SXS_PROTECT_FILTER_DEFAULT
    }
};

const SIZE_T s_SxsProtectionListCount = NUMBER_OF(s_SxsProtectionList);


BOOL SxspConstructProtectionList();


BOOL WINAPI
SxsProtectionGatherEntriesW(
    PCSXS_PROTECT_DIRECTORY *prgpProtectListing,
    SIZE_T *pcProtectEntries
    )
/*++
    This is called by Sfc to gather the entries that we want them to watch.
    At the moment, it's a 'proprietary' listing of all the directories and
    flags we want them to set on their call to the directory-change watcher.
    Mayhaps we should work with them to find out exactly what they want us
    to pass (probably the name plus a PVOID, which is fine) and then go from
    there.
--*/
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CStringBuffer sbTemp;


    if (prgpProtectListing)
        *prgpProtectListing = NULL;

    if (pcProtectEntries)
        *pcProtectEntries = 0;

    PARAMETER_CHECK(prgpProtectListing);
    PARAMETER_CHECK(pcProtectEntries);

    //
    // This is try/caught because we don't want something here to
    // cause WinLogon to bugcheck the system when it AV's.
    //
	IFW32FALSE_EXIT(::SxspConstructProtectionList());

    //
    // We really have only one entry, so let's go and edit the first entry to
    // be the main sxs store directory.
    //
    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(sbTemp));
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
truncating string copy, need growing buffer
*/
    wcsncpy(
        s_SxsProtectionList[0].pwszDirectory,
        sbTemp,
        NUMBER_OF(s_SxsProtectionList[0].pwszDirectory));
    //
    // Zero out the last character, just in case wcsncpy didn't do it for us
    //
    s_SxsProtectionList[0].pwszDirectory[NUMBER_OF(s_SxsProtectionList[0].pwszDirectory) - 1] = L'\0';

    //
    // Shh, don't tell anyone, but the cookie is actually this structure!
    //
    for (DWORD dw = 0; dw < s_SxsProtectionListCount; dw++)
    {
        s_SxsProtectionList[dw].pvCookie = &(s_SxsProtectionList[dw]);
    }

    *prgpProtectListing = s_SxsProtectionList;
    *pcProtectEntries = s_SxsProtectionListCount;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}








BOOL
SxspExpandLongPath(
    IN OUT CBaseStringBuffer &rbuffPathToLong
    )
/*++

Takes in a short path (c:\foo\bar\bloben~1.zot) and sends back out the
full path (c:\foo\bar\blobenheisen.zotamax) if possible.  Returns FALSE if
the path could not be expanded (most likely because the path on-disk is
no longer available.)

--*/
{
    FN_PROLOG_WIN32

    CStringBuffer           buffPathName;
    CStringBufferAccessor   buffAccess;
    SIZE_T                  cchNeededChars = 0;

    IFW32ZERO_EXIT(
        cchNeededChars = ::GetLongPathNameW(
            static_cast<PCWSTR>(rbuffPathToLong),
            NULL,
            0));

    IFW32FALSE_EXIT(buffPathName.Win32ResizeBuffer(cchNeededChars, eDoNotPreserveBufferContents));
    buffAccess.Attach(&buffPathName);

    IFW32ZERO_EXIT(
        cchNeededChars = ::GetLongPathNameW(
            rbuffPathToLong,
            buffAccess,
            static_cast<DWORD>(buffAccess.GetBufferCch())));

/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
this can fail in reality; it is not an internal error;
this is because the general try, grow buffer, try again, contains a race condition,
the second try will not necessarily work
*/
    INTERNAL_ERROR_CHECK(cchNeededChars <= buffAccess.GetBufferCch());

    IFW32FALSE_EXIT(rbuffPathToLong.Win32Assign(buffPathName));

    FN_EPILOG
}

BOOL
SxspResolveAssemblyManifestPath(
    const CBaseStringBuffer &rbuffAssemblyDirectoryName,
    CBaseStringBuffer &rbuffManifestPath
    )
{
    FN_PROLOG_WIN32
    CStringBuffer   buffAssemblyRootDir;
    BOOL            fLooksLikeAssemblyName = FALSE;

    rbuffManifestPath.Clear();

    //
    // If the string doesn't look like an assembly name, then it's an
    // invalid parameter.  This is somewhat heavy-handed, as the caller(s)
    // to this function will be entirely hosed if they haven't checked to
    // see if the string is really an assembly name.  Make sure that all
    // clients of this,
    //
    IFW32FALSE_EXIT(::SxspLooksLikeAssemblyDirectoryName(rbuffAssemblyDirectoryName, fLooksLikeAssemblyName));
    PARAMETER_CHECK(fLooksLikeAssemblyName);

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffAssemblyRootDir));
    IFW32FALSE_EXIT(rbuffManifestPath.Win32Format(
        L"%ls\\Manifests\\%ls.%ls",
        static_cast<PCWSTR>(buffAssemblyRootDir),
        static_cast<PCWSTR>(rbuffAssemblyDirectoryName),
        FILE_EXTENSION_MANIFEST));

    FN_EPILOG
}




CProtectionRequestRecord::CProtectionRequestRecord()
    : m_dwAction(0), m_pvProtection(NULL), m_ulInRecoveryMode(0),
      m_pParent(NULL),
      m_bIsManPathResolved(FALSE),
      m_bInitialized(FALSE)
{
}

BOOL
CProtectionRequestRecord::GetManifestPath(
    CBaseStringBuffer &rsbManPath
    )
{
    BOOL bOk = FALSE;
    FN_TRACE_WIN32(bOk);

    rsbManPath.Clear();

    if (!m_bIsManPathResolved)
    {
        m_bIsManPathResolved =
            ::SxspResolveAssemblyManifestPath(
                m_sbAssemblyDirectoryName,
                m_sbManifestPath);
    }

    if (m_bIsManPathResolved)
    {
        IFW32FALSE_EXIT(rsbManPath.Win32Assign(m_sbManifestPath));
    }
    else
    {
        goto Exit;
    }

    bOk = TRUE;
Exit:
    return bOk;
}

//
// Close down this request record.
//
CProtectionRequestRecord::~CProtectionRequestRecord()
{
    if (m_bInitialized)
    {
        ClearList();
        m_bInitialized = FALSE;
    }
}

VOID
CProtectionRequestRecord::ClearList()
/*
NTRAID#NTBUG9-591177-2002/03/31-JayKrell
stop using slists
*/
{
    CStringListEntry *pTop;

    while (pTop = (CStringListEntry*)::SxspInterlockedPopEntrySList(&m_ListHeader))
    {
        FUSION_DELETE_SINGLETON(pTop);
    }
}

BOOL
CProtectionRequestRecord::AddSubFile(
    const CBaseStringBuffer &rbuffRelChange
    )
{
    CStringListEntry *pairing = NULL;
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    if (!::SxspInterlockedCompareExchange(&m_ulInRecoveryMode, 0, 0))
    {
        IFALLOCFAILED_EXIT(pairing = new CStringListEntry);
        IFW32FALSE_EXIT(pairing->m_sbText.Win32Assign(rbuffRelChange));

        //
        // Add it to the list (atomically, to boot!)
        //
        ::SxspInterlockedPushEntrySList(&m_ListHeader, pairing);
        pairing = NULL;
    }

    fSuccess = TRUE;
Exit:
    if (pairing)
    {
        //
        // The setup or something like that failed - release it here.
        //
        FUSION_DELETE_SINGLETON(pairing);
    }
    return fSuccess;
}


BOOL
CProtectionRequestRecord::Initialize(
    const CBaseStringBuffer &rsbAssemblyDirectoryName,
    const CBaseStringBuffer &rsbKeyString,
    CProtectionRequestList* ParentList,
    PVOID                   pvRequestRecord,
    DWORD                   dwAction
    )
{
    BOOL    fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    m_sbAssemblyDirectoryName.Clear();
    m_sbKeyValue.Clear();
    m_sbManifestPath.Clear();
    ::SxspInitializeSListHead(&m_ListHeader);

    PARAMETER_CHECK(ParentList != NULL);
    PARAMETER_CHECK(pvRequestRecord != NULL);

    m_pParent               = ParentList;
    m_dwAction              = dwAction;
    m_pvProtection          = (PSXS_PROTECT_DIRECTORY)pvRequestRecord;

    IFW32FALSE_EXIT(m_sbAssemblyStore.Win32Assign(m_pvProtection->pwszDirectory, (m_pvProtection->pwszDirectory != NULL) ? ::wcslen(m_pvProtection->pwszDirectory) : 0));
    IFW32FALSE_EXIT(m_sbAssemblyDirectoryName.Win32Assign(rsbAssemblyDirectoryName));
    IFW32FALSE_EXIT(m_sbKeyValue.Win32Assign(rsbKeyString));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}



//
// Bad form: This returns a BOOL to indicate whether or not this class
// was able to pop something off the list.  It's no good to ask "is the
// list empty," since that's not provided with this list class.
//
BOOL
CProtectionRequestRecord::PopNextFileChange(CBaseStringBuffer &Dest)
{
    BOOL fFound = FALSE;

    Dest.Clear();
    CStringListEntry *pPairing = reinterpret_cast<CStringListEntry*>(::SxspInterlockedPopEntrySList(&m_ListHeader));

    if (pPairing != NULL)
    {
        //
        // NTRAID#NTBUG9-591177-2002/03/31-JayKrell
        // missing error check
        //
        Dest.Win32Assign(pPairing->m_sbText);
        FUSION_DELETE_SINGLETON(pPairing);
        fFound = TRUE;
    }

    return fFound;
}


// NTRAID#NTBUG9-591177-2002/03/31-JayKrell
// "If a thread dies in winlogon, and no kernel debugger is attached, does it
// bugcheck the system?" - From 'The Zen of Dodgy Code'
//
DWORD
CProtectionRequestList::ProtectionNormalThreadProc(PVOID pvParam)
{
    BOOL    fSuccess = FALSE;
    CProtectionRequestRecord *pRequestRecord = NULL;
    CProtectionRequestList *pThis = NULL;

    pRequestRecord = static_cast<CProtectionRequestRecord*>(pvParam);
    if (pRequestRecord)
    {
        pThis = pRequestRecord->GetParent();
    }
    if (pThis)
    {
        fSuccess = pThis->ProtectionNormalThreadProcWrapped(pRequestRecord);
    }

    return static_cast<DWORD>(fSuccess);
}

BOOL
CProtectionRequestList::Initialize()
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ASSERT(m_pInternalList == NULL);

    IFW32FALSE_EXIT(::FusionpInitializeCriticalSectionAndSpinCount(&m_cSection, INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT_ALLOCATE_NOW));
    IFW32FALSE_EXIT(::FusionpInitializeCriticalSectionAndSpinCount(&m_cInstallerCriticalSection, INITIALIZE_CRITICAL_SECTION_AND_SPIN_COUNT_ALLOCATE_NOW));
    IFW32FALSE_EXIT(::SxspAtExit(this));

    IFALLOCFAILED_EXIT(m_pInternalList = new COurInternalTable);
    IFW32FALSE_EXIT(m_pInternalList->Initialize());

    IFALLOCFAILED_EXIT(m_pInstallsTable = new CInstallsInProgressTable);
    IFW32FALSE_EXIT(m_pInstallsTable->Initialize());

    //
    // Manifest protection stuff
    //
    ::SxspInitializeSListHead(&m_ManifestEditList);

    /*
    NTRAID#NTBUG9-591177-2002/03/31-JayKrell
    This should be IF32NULL_EXIT(::CreateEventW(NULL, TRUE, FALSE, NULL));
    */
    m_hManifestEditHappened = ::CreateEventW(NULL, TRUE, FALSE, NULL);
    if (m_hManifestEditHappened == NULL)
    {
        TRACE_WIN32_FAILURE_ORIGINATION(CreateEventW);
        goto Exit;
    }

    ASSERT(m_pInternalList != NULL);
    ASSERT(m_pInstallsTable != NULL);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

CProtectionRequestList::CProtectionRequestList()
    : m_pInternalList(NULL), m_pInstallsTable(NULL),
      m_hManifestEditHappened(INVALID_HANDLE_VALUE),
      m_ulIsAThreadServicingManifests(0)

{
}


CProtectionRequestList::~CProtectionRequestList()
{
    ::DeleteCriticalSection(&m_cSection);
    ::DeleteCriticalSection(&m_cInstallerCriticalSection);

    COurInternalTable *pTempListing = m_pInternalList;
    CInstallsInProgressTable *pInstalls = m_pInstallsTable;

    m_pInternalList = NULL;
    m_pInternalList = NULL;

    if (pTempListing != NULL)
    {
        pTempListing->Clear(this, &CProtectionRequestList::ClearProtectionItems);
        FUSION_DELETE_SINGLETON(pTempListing);
    }

    if (pInstalls != NULL)
    {
        pInstalls->ClearNoCallback();
        FUSION_DELETE_SINGLETON(pInstalls);
    }

}

BOOL
CProtectionRequestList::IsSfcIgnoredStoreSubdir(PCWSTR wsz)
{
    FN_TRACE();

    ASSERT(m_arrIgnorableSubdirs);

    for (SIZE_T i = 0; i < m_cIgnorableSubdirs; i++)
    {
        if (::FusionpEqualStringsI(m_arrIgnorableSubdirs[i], wsz))
        {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CProtectionRequestList::AttemptRemoveItem(CProtectionRequestRecord *AttemptRemoval)
{
    //
    // This quickly indicates that the progress is complete and just returns to
    // the caller.
    //
    const CBaseStringBuffer &sbKey = AttemptRemoval->GetChangeBasePath();
    BOOL fSuccess = FALSE;
    CSxsLockCriticalSection lock(m_cSection);

    FN_TRACE_WIN32(fSuccess);
    PARAMETER_CHECK(AttemptRemoval != NULL);

    IFW32FALSE_EXIT(lock.Lock());
    //
    // This item is no longer in service.  Please check the item and
    // try your call again.  The nice thing is that Remove on CStringPtrTable
    // knows to delete the value lickety-split before returning.  This isn't
    // such a bad thing, but it's ... different.
    //
    m_pInternalList->Remove(sbKey, NULL);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CProtectionRequestList::AddRequest(
    PSXS_PROTECT_DIRECTORY pProtect,
    PCWSTR pcwszDirName,
    SIZE_T cchName,
    DWORD dwAction
    )
{
    BOOL fSuccess = FALSE;
    bool fIsManifestEdit = false;
    BOOL fIsIgnorable = FALSE;
    BOOL fNewAddition = FALSE;
    CSmallStringBuffer sbTemp;
    CSmallStringBuffer sbAssemblyDirectoryName;
    CSmallStringBuffer sbRequestText;
    CSmallStringBuffer buffManifestsDirectoryName;
    CSmallStringBuffer buffManifestsShortDirectoryName;
    CProtectionRequestRecord *pRecord = NULL;
    CProtectionRequestRecord *ppFoundInTable = NULL;
    CSxsLockCriticalSection lock(m_cSection);

    FN_TRACE_WIN32(fSuccess);

    //
    // The key here is the first characters (up to the first slash) in the
    // notification name.  If there's no slash in the notification name, then
    // we can ignore this change request, since nothing important happened.
    //
    IFW32FALSE_EXIT(sbTemp.Win32Assign(pProtect->pwszDirectory, (pProtect->pwszDirectory != NULL) ? ::wcslen(pProtect->pwszDirectory) : 0));
    IFW32FALSE_EXIT(sbRequestText.Win32Assign(pcwszDirName, cchName));
    IFW32FALSE_EXIT(sbRequestText.Win32GetFirstPathElement(sbAssemblyDirectoryName));

    fIsIgnorable = IsSfcIgnoredStoreSubdir(sbAssemblyDirectoryName);

    fIsManifestEdit = !::FusionpStrCmpI(sbAssemblyDirectoryName, MANIFEST_ROOT_DIRECTORY_NAME);

    if (!fIsManifestEdit)
    {
        DWORD dwTemp = 0;
        CStringBufferAccessor acc;

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffManifestsDirectoryName));
        IFW32FALSE_EXIT(buffManifestsDirectoryName.Win32AppendPathElement(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));

        acc.Attach(&buffManifestsShortDirectoryName);
        IFW32ZERO_ORIGINATE_AND_EXIT(dwTemp = ::GetShortPathNameW(buffManifestsDirectoryName, acc.GetBufferPtr(), acc.GetBufferCchAsDWORD()));
        /*
        NTRAID#NTBUG9-591177-2002/03/31-JayKrell
        possibility of infinite loop; "only try twice".
        */
        while (dwTemp >= acc.GetBufferCchAsDWORD())
        {
            acc.Detach();
            IFW32FALSE_EXIT(buffManifestsShortDirectoryName.Win32ResizeBuffer(dwTemp, eDoNotPreserveBufferContents));
            acc.Attach(&buffManifestsShortDirectoryName);
            IFW32ZERO_ORIGINATE_AND_EXIT(dwTemp = ::GetShortPathNameW(buffManifestsDirectoryName, acc.GetBufferPtr(), acc.GetBufferCchAsDWORD()));
        }

        acc.Detach();

        // Ok all that work and now we finally have the manifests directory name as a short string.  Let's abuse buffManifestsShortDirectoryName
        // to just hold the short name of the manifests directory.

        IFW32FALSE_EXIT(buffManifestsShortDirectoryName.Win32GetLastPathElement(buffManifestsDirectoryName));

        if (::FusionpCompareStrings(
                buffManifestsDirectoryName,
                sbAssemblyDirectoryName,
                true) == 0)
        {
            // Convert the directory name to its proper long form
            IFW32FALSE_EXIT(sbAssemblyDirectoryName.Win32Assign(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));
            fIsManifestEdit = true;
        }
    }

    if ((fIsIgnorable) && (!fIsManifestEdit))
    {
#if DBG
        //
        // We get a lot of these.
        //
        if (::FusionpStrCmpI(sbAssemblyDirectoryName, L"InstallTemp") != 0)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS.DLL: %s() - %ls is ignorable (%d)\n",
                __FUNCTION__,
                static_cast<PCWSTR>(sbAssemblyDirectoryName),
                fIsIgnorable
                );
        }
#endif
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // The "key" value here is the full path to the assembly that we're protecting.
    // This is what we'll store in the table.
    //
    IFW32FALSE_EXIT(sbTemp.Win32AppendPathElement(sbAssemblyDirectoryName));


    if (fIsManifestEdit)
    {
        CStringListEntry *pEntry = NULL;
        ULONG ulWasSomeoneServicing = 0;

        //
        // Create a new manifest edit slot, add it to the list of items that are being
        // serviced.
        //
        IFALLOCFAILED_EXIT(pEntry = new CStringListEntry);
        if (!pEntry->m_sbText.Win32Assign(sbRequestText))
        {
            TRACE_WIN32_FAILURE(m_sbText.Win32Assign);
            FUSION_DELETE_SINGLETON(pEntry);
            pEntry = NULL;
            goto Exit;
        }
        ::SxspInterlockedPushEntrySList(&m_ManifestEditList, pEntry);
        pEntry = NULL;

        //
        // Tell anyone that's listening that we have a new manifest edit here
        //
        SetEvent(m_hManifestEditHappened);

        //
        // See if someone is servicing the queue at the moment
        //
        ulWasSomeoneServicing = ::SxspInterlockedCompareExchange(&m_ulIsAThreadServicingManifests, 1, 0);

        if (!ulWasSomeoneServicing)
        {
			// Missing error checking!
            QueueUserWorkItem(ProtectionManifestThreadProc, (PVOID)this, WT_EXECUTEDEFAULT);
        }

        fSuccess = TRUE;
        goto Exit;
    }

    //
    // At this point, we need to see if the chunk that we identified is currently
    // in the list of things to be validated.  If not, it gets added and a thread
    // is spun off to work on it.  Otherwise, an entry may already exist in a
    // thread that's being serviced, and so it needs to be deleted.
    //
    IFW32FALSE_EXIT(lock.Lock());
    m_pInternalList->Find(sbTemp, ppFoundInTable);

    if (!ppFoundInTable)
    {
        IFALLOCFAILED_EXIT(pRecord = new CProtectionRequestRecord);
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS.DLL: %s() - Creating protection record for %ls:\n"
            "\tKey              = %ls\n"
            "\tManifest?        = %d\n"
            "\tProtectionRecord = %p\n"
            "\tAction           = %d\n",
            __FUNCTION__,
            static_cast<PCWSTR>(sbAssemblyDirectoryName),
            static_cast<PCWSTR>(sbTemp),
            fIsManifestEdit,
            pProtect,
            dwAction);
#endif
        IFW32FALSE_EXIT(pRecord->Initialize(
            sbAssemblyDirectoryName,
            sbTemp,
            this,
            pProtect,
            dwAction));

        //
        // Add this first request to be serviced, then spin a thread to start it.
        //
        m_pInternalList->Insert(sbTemp, pRecord);
        fNewAddition = TRUE;

        //
        // A little bookkeeping ... so we don't accidentally use it later.
        //
        ppFoundInTable = pRecord;
        pRecord = NULL;
    }

    //
    // If we actually got something into the table...
    //
    if (ppFoundInTable)
    {
        ppFoundInTable->AddSubFile(sbRequestText);

        //
        // If this is a new thing in the table (ie: we inserted it ourselves)
        // then we should go and spin up a thread for it.
        //
        if (fNewAddition)
        {
            /*
            NTRAID#NTBUG9-591177-2002/03/31-JayKrell
            We should check for an error from QueueUserWorkItem, like out of memory.
            */
            QueueUserWorkItem(ProtectionNormalThreadProc, (PVOID)ppFoundInTable, WT_EXECUTEDEFAULT);
        }
    }

    fSuccess = TRUE;

Exit:
    DWORD dwLastError = ::FusionpGetLastWin32Error();
    if (pRecord)
    {
        //
        // If this is still set, something bad happened in the process of trying to
        // create/find this object.  Delete it here.
        //
        FUSION_DELETE_SINGLETON(pRecord);
        pRecord = NULL;
    }
    ::FusionpSetLastWin32Error(dwLastError);
    return fSuccess;
}

static BYTE p_bProtectionListBuffer[ sizeof(CProtectionRequestList) * 2 ];
PCWSTR CProtectionRequestList::m_arrIgnorableSubdirs[] = 
{ 
    ASSEMBLY_INSTALL_TEMP_DIR_NAME, 
    POLICY_ROOT_DIRECTORY_NAME,   
    REGISTRY_BACKUP_ROOT_DIRECTORY_NAME
};
SIZE_T CProtectionRequestList::m_cIgnorableSubdirs =
    NUMBER_OF(CProtectionRequestList::m_arrIgnorableSubdirs);

BOOL
SxspIsSfcIgnoredStoreSubdir(PCWSTR pwsz)
{
    return CProtectionRequestList::IsSfcIgnoredStoreSubdir(pwsz);
}

BOOL
SxspConstructProtectionList()
{
    CProtectionRequestList *pTemp = NULL;
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    //
    // This only gets called once, if they know what's good for them.
    //
    ASSERT(!g_ProtectionRequestList);

    /*
    NTRAID#NTBUG9-591177-2002/03/31-JayKrell
    The comments here are bogus.
    Placement new actually cannot fail due to out of memory,
    only the constructor throwing an exception.
    */
    //
    // Construct - this should never fail, but if it does, there's trouble.
    //
    pTemp = new (&p_bProtectionListBuffer) CProtectionRequestList;
    if (pTemp == NULL)
    {
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_ERROR, "SXS: %s() - Failed placement new of CProtectionRequestList????\n", __FUNCTION__);
        ::FusionpSetLastWin32Error(FUSION_WIN32_ALLOCFAILED_ERROR);
        TRACE_WIN32_FAILURE_ORIGINATION(new(CProtectionRequestList));
        goto Exit;
    }
    IFW32FALSE_EXIT(pTemp->Initialize());

    g_ProtectionRequestList = pTemp;
    pTemp = NULL;

    //
    // Create our logon event.
    //
    IFW32NULL_EXIT(g_hSxsLoginEvent = ::CreateEventW(NULL, TRUE, FALSE, NULL));

    fSuccess = TRUE;
Exit:

    if (pTemp)
    {
        //
        // If this is still set, then something failed somewhere in the construction
        // code for the protection system.  We don't want to delete it, per-se, but
        // we need to just null out everything.
        //
        g_ProtectionRequestList = NULL;
        pTemp = NULL;
        g_hSxsLoginEvent = NULL;
    }

    return fSuccess;
}



BOOL
WINAPI
SxsProtectionNotifyW(
    PVOID   pvCookie,
    PCWSTR  wsChangeText,
    SIZE_T  cchChangeText,
    DWORD   dwChangeAction
    )
{
#if YOU_ARE_HAVING_ANY_WIERDNESS_WITH_SFC_AND_SXS
    return TRUE;
#else
    BOOL fSuccess = FALSE;

    if (::FusionpDbgWouldPrintAtFilterLevel(FUSION_DBG_LEVEL_FILECHANGENOT))
    {
        const USHORT Length = (cchChangeText > UNICODE_STRING_MAX_CHARS) ? UNICODE_STRING_MAX_BYTES : ((USHORT) (cchChangeText * sizeof(WCHAR)));
        const UNICODE_STRING u = { Length, Length, const_cast<PWSTR>(wsChangeText) };

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_FILECHANGENOT,
            "[%lx.%lx: %wZ] SXS FCN (cookie, action, text): %p, %lu, \"%wZ\"\n",
            HandleToULong(NtCurrentTeb()->ClientId.UniqueProcess),
            HandleToULong(NtCurrentTeb()->ClientId.UniqueThread),
            &NtCurrentPeb()->ProcessParameters->ImagePathName,
            pvCookie,
            dwChangeAction,
            &u);
    }

    //
    // If we're not accepting notifications, then quit out immediately.
    //
    if (!s_fIsSfcAcceptingNotifications)
    {
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // Having done this in the wrong order is also a Bad Bad Thing
    //
    ASSERT2_NTC(g_ProtectionRequestList != NULL, "SXS.DLL: Protection - Check order of operations, g_ProtectionRequestList is invalid!!\n");

    fSuccess = g_ProtectionRequestList->AddRequest(
        (PSXS_PROTECT_DIRECTORY)pvCookie,
        wsChangeText,
        cchChangeText,
        dwChangeAction);

    fSuccess = TRUE;
Exit:
    return fSuccess;
#endif
}

BOOL
CProtectionRequestList::ProtectionManifestThreadProcNoSEH(LPVOID pvParam)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CProtectionRequestList *pThis = NULL;

    PARAMETER_CHECK(pvParam != NULL);

    pThis = reinterpret_cast<CProtectionRequestList*>(pvParam);
    IFW32FALSE_EXIT(pThis->ProtectionManifestThreadProcWrapped());
    fSuccess = TRUE;
Exit:
    return fSuccess;
}


DWORD
CProtectionRequestList::ProtectionManifestThreadProc(LPVOID pvParam)
{
    BOOL fSuccess = FALSE;
    fSuccess = ProtectionManifestThreadProcNoSEH(pvParam);
    return static_cast<DWORD>(fSuccess);
}


class CProtectionManifestSingleManifestWorkerLocals
{
public:
    CProtectionManifestSingleManifestWorkerLocals() { }
    ~CProtectionManifestSingleManifestWorkerLocals() { }

    CStringBuffer       sbAssemblyDirectoryName;
    CStringBuffer       sbManifestPath;
    CAssemblyRecoveryInfo RecoverInfo;
};

BOOL
CProtectionRequestList::ProtectionManifestSingleManifestWorker(
    const CStringListEntry *pEntry
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SxsRecoveryResult RecoverResult = Recover_Unknown;
    HashValidateResult HashValidResult = HashValidate_OtherProblems;
    BOOL fCatalogPresent = FALSE;
    bool fNoAssembly = false;

    CSmartPtr<CProtectionManifestSingleManifestWorkerLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    CStringBuffer       &sbAssemblyDirectoryName = Locals->sbAssemblyDirectoryName;
    CStringBuffer       &sbManifestPath = Locals->sbManifestPath;
    CAssemblyRecoveryInfo &RecoverInfo = Locals->RecoverInfo;

    PARAMETER_CHECK(pEntry);

    //
    // Calculate the name of the assembly based on the middling part of
    // the string
    //
    IFW32FALSE_EXIT(sbAssemblyDirectoryName.Win32Assign(pEntry->m_sbText));
    IFW32FALSE_EXIT(sbAssemblyDirectoryName.Win32RemoveFirstPathElement());
    IFW32FALSE_EXIT(sbAssemblyDirectoryName.Win32ClearPathExtension());

    if (sbAssemblyDirectoryName.Cch() == 0)
        FN_SUCCESSFUL_EXIT();

	::Sleep(5000); // wait 5 seconds for the offender to probably let go of their handle on the file

    //
    // Try mashing this into an assembly name/recovery info
    //
	IFW32FALSE_EXIT(RecoverInfo.AssociateWithAssembly(sbAssemblyDirectoryName, fNoAssembly));

	// If we couldn't figure out what this was for, we have to ignore it.
	if (fNoAssembly)
	{
#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_WFP,
            "SXS.DLL: %s() - File \"%ls\" in the manifest directory modified, but could not be mapped to an assembly.  IGNORING.\n",
            __FUNCTION__,
            static_cast<PCWSTR>(pEntry->m_sbText));
#endif

        FN_SUCCESSFUL_EXIT();
    }

    //
    // Now that we have the recovery info..
    //
    if (!RecoverInfo.GetHasCatalog())
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS.DLL: %s() - Assembly %ls was in the registry, but without a catalog so we aren't protecting it\n",
            __FUNCTION__,
            static_cast<PCWSTR>(sbAssemblyDirectoryName));
#endif

		FN_SUCCESSFUL_EXIT();
    }

    //
    // Resolve the manifest path, then validate
    //
    IFW32FALSE_EXIT(::SxspResolveAssemblyManifestPath(sbAssemblyDirectoryName, sbManifestPath));

    IFW32FALSE_EXIT(
        ::SxspVerifyFileHash(
            SVFH_RETRY_LOGIC_SIMPLE,
            sbManifestPath,
            RecoverInfo.GetSecurityInformation().GetManifestHash(),
            CALG_SHA1,
            HashValidResult));
    
    IFW32FALSE_EXIT(::SxspEnsureCatalogStillPresentForManifest(sbManifestPath, fCatalogPresent));

    //
    // Reinstall needed?
    //
    if ((HashValidResult != HashValidate_Matches) || !fCatalogPresent)
        IFW32FALSE_EXIT(this->PerformRecoveryOfAssembly(RecoverInfo, RecoverResult));


    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
CProtectionRequestList::ProtectionManifestThreadProcWrapped()
{
    BOOL                fSuccess = FALSE;
    BOOL                bFoundItemsThisTimeAround;
    CStringListEntry    *pNextItem = NULL;
    DWORD               dwWaitResult = 0;

    FN_TRACE_WIN32(fSuccess);

    bFoundItemsThisTimeAround = FALSE;

    do
    {
        //
        // Yes, mother, we hear you.
        //
        ::ResetEvent(m_hManifestEditHappened);

        //
        // Pull the next thing off the list and service it.
        //
        while (pNextItem = (CStringListEntry*)::SxspInterlockedPopEntrySList(&m_ManifestEditList))
        {
            bFoundItemsThisTimeAround = TRUE;

            if (!this->ProtectionManifestSingleManifestWorker(pNextItem))
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP,
                    "SXS: %s - Processing work item %p failed\n", __FUNCTION__, pNextItem);

            FUSION_DELETE_SINGLETON(pNextItem);
        }

        //
        // Loaf about for a bit and see if anyone else has stuff for us to do
        //
        dwWaitResult = ::WaitForSingleObject(m_hManifestEditHappened, 3000);
        if (dwWaitResult == WAIT_TIMEOUT)
        {
            ::SxspInterlockedExchange(&m_ulIsAThreadServicingManifests, 0);
            break;
        }
        else if (dwWaitResult == WAIT_OBJECT_0)
        {
            continue;
        }
        else
        {
            TRACE_WIN32_FAILURE_ORIGINATION(WaitForSingleObject);
            goto Exit;
        }

    }
    while (true);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}



class CProtectionRequestListProtectionNormalThreadProcWrappedLocals
{
public:
    CProtectionRequestListProtectionNormalThreadProcWrappedLocals() { }
    ~CProtectionRequestListProtectionNormalThreadProcWrappedLocals() { }

    CSmallStringBuffer          buffFullPathOfChange;
    CSmallStringBuffer          buffAssemblyStore;
    CSmallStringBuffer          buffAssemblyRelativeChange;
    CStringBuffer               rbuffAssemblyDirectoryName;  
};

BOOL
CProtectionRequestList::ProtectionNormalThreadProcWrapped(
    CProtectionRequestRecord *pRequestRecord
    )
{
    BOOL                        fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CProtectionRequestRecord    &rRequest = *pRequestRecord;
    CProtectionRequestList      *pRequestList = rRequest.GetParent();

    BOOL                        fNeedsReinstall = FALSE;
    BOOL                        fAssemblyNotFound = FALSE;

    DWORD                       dwAsmPathAttribs = 0;

    SxsRecoveryResult           RecoverResult = Recover_Unknown;

    bool fNoAssembly = false;
    bool fExist = false;

    //
    // The request's key value contains the full path of the assembly that
    // is being modified, in theory.  So, we can just use it locally.
    //
    const CBaseStringBuffer &rbuffAssemblyPath = rRequest.GetChangeBasePath();
    CAssemblyRecoveryInfo &rRecoveryInfo = rRequest.GetRecoveryInfo();
    CSecurityMetaData &rSecurityMetaData = rRecoveryInfo.GetSecurityInformation();

    CSmartPtr<CProtectionRequestListProtectionNormalThreadProcWrappedLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));
    CSmallStringBuffer          &buffFullPathOfChange = Locals->buffFullPathOfChange;
    CSmallStringBuffer          &buffAssemblyStore = Locals->buffAssemblyStore;
    CSmallStringBuffer          &buffAssemblyRelativeChange = Locals->buffAssemblyRelativeChange;
    CStringBuffer               &rbuffAssemblyDirectoryName = Locals->rbuffAssemblyDirectoryName;  

	::Sleep(5000); // wait 5 seconds for the offender to let go of the file handle

    //
    // this name could be changes because the assemblyName in the request could be a short name,
    // in this case, we need reset the AssemblyName in rRequest
    //
    IFW32FALSE_EXIT(rbuffAssemblyDirectoryName.Win32Assign(rRequest.GetAssemblyDirectoryName()));
   
    //
    // This value should not change at all during this function.  Save it here.
    //
    IFW32FALSE_EXIT(rRequest.GetAssemblyStore(buffAssemblyStore));

    //
    // The big question of the day - find out the recovery information for this
    // assembly.  See if there was a catalog at installation time (a) or find out
    // whether or not there is a catalog for it right now.
    //
    IFW32FALSE_EXIT(rRecoveryInfo.AssociateWithAssembly(rbuffAssemblyDirectoryName, fNoAssembly));

    // If we couldn't figure out what assembly this was for, we ignore it.
    if (fNoAssembly)
        FN_SUCCESSFUL_EXIT();

    //
    // if rbuffAssemblyName is different from the assemblyname from rRequest, 
    // it must be a short name, we must reset the AssemblyName in rRequest
    //
    StringComparisonResult scr = eEquals;
    IFW32FALSE_EXIT(rbuffAssemblyDirectoryName.Win32Compare(rRequest.GetAssemblyDirectoryName(), rRequest.GetAssemblyDirectoryName().Cch(), scr, NORM_IGNORECASE));
    if (scr != eEquals)
        IFW32FALSE_EXIT(rRequest.SetAssemblyDirectoryName(rbuffAssemblyDirectoryName));

	if (rRecoveryInfo.GetInfoPrepared() == FALSE)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(RecoveryInfoCouldNotBePrepared, ERROR_PATH_NOT_FOUND);

    if (!rRecoveryInfo.GetHasCatalog())
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_INFO,
            "SXS.DLL: %s - Assembly %ls not registered with catalog, WFP ignoring it.\n",
            __FUNCTION__,
            static_cast<PCWSTR>(rbuffAssemblyDirectoryName));
#endif
        fSuccess = TRUE;
        goto Exit;
    }

    //
    // See if it still exists...
    //
    IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY, rbuffAssemblyPath, fExist));
    if (!fExist) // the directory does not exist
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS.DLL: WFP reinstalling assembly because GetFileAttributesW(\"%ls\") failed with win32 error %ld\n",
            static_cast<PCWSTR>(rbuffAssemblyPath),
            ::FusionpGetLastWin32Error());

        fNeedsReinstall = TRUE;
        goto DoReinstall;
    }

#if 0 
    // "if 0" is added by xiaoyuw-2002.05.01, 
    // the reason is that if the file is not a directory, we still need do reinstall, instead of SUCCESSFUL_EXIT
    //

    //
    // Otherwise, is it maybe not a directory for one reason or another?
    //
    else if (!(dwAsmPathAttribs & FILE_ATTRIBUTE_DIRECTORY))
    {
#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL:%s - %ws isn't a directory, we should attempt to remove it?\n",
            __FUNCTION__,
            static_cast<PCWSTR>(rbuffAssemblyPath));
#endif
        FN_SUCCESSFUL_EXIT();
    }
#endif


    //
    // Find out whether or not the file is still OK by checking against the manifest
    //
    {
        HashValidateResult HashValid = HashValidate_OtherProblems;
        CStringBuffer      buffManifestFullPath;
        BOOL               fPresent = FALSE;

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory( buffFullPathOfChange ) );
        IFW32FALSE_EXIT(::SxspCreateManifestFileNameFromTextualString(
            0,
            SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
            buffFullPathOfChange,
            rSecurityMetaData.GetTextualIdentity(),
            buffManifestFullPath) );

#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_WFP,
            "SXS.DLL:%s - Checking to see if manifest %ls is OK\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffManifestFullPath));
#endif

        IFW32FALSE_EXIT(::SxspVerifyFileHash(
            SVFH_RETRY_LOGIC_SIMPLE,
            buffManifestFullPath,
            rSecurityMetaData.GetManifestHash(),
            CALG_SHA1,
            HashValid));

#if DBG
        FusionpDbgPrintEx( FUSION_DBG_LEVEL_WFP,
            "SXS.DLL:%s - Manifest %ls checks %ls\n",
            __FUNCTION__,
            static_cast<PCWSTR>(buffManifestFullPath),
            SxspHashValidateResultToString(HashValid) );
#endif

        if ( HashValid != HashValidate_Matches )
        {
            fNeedsReinstall = TRUE;
            goto DoReinstall;
        }

        //
        // Let's just ensure the catalog is there - it's not necessary anymore
        // for the protection pass, but it should be there if someone wants to
        // repackage the assembly for distribution.
        //
        IFW32FALSE_EXIT(::SxspEnsureCatalogStillPresentForManifest(buffManifestFullPath, fPresent));
        if ( !fPresent )
        {
            fNeedsReinstall = TRUE;
            goto DoReinstall;
        }
    }


    //
    // Now we can loop through the items in our list of things to be evaluated and
    // see if any of them are bad (or missing, or whatever.)
    //
    // Start out by touching the thing that indicates the last time we spun through
    // here and looked at the file list.
    //
    while (!fNeedsReinstall)
    {
        const CMetaDataFileElement* pFileDataElement = NULL;
        HashValidateResult Valid = HashValidate_OtherProblems;
        BOOL fFileNotFound;

        if (!rRequest.PopNextFileChange(buffAssemblyRelativeChange))
        {
            break;
        }

        IFW32FALSE_EXIT(buffAssemblyRelativeChange.Win32RemoveFirstPathElement());

        //
        // The change here is really to the top level directory - don't
        // bother doing anything in this case.  Maybe we should catch
        // this beforehand so we don't do the work of parsing?
        //
        if (buffAssemblyRelativeChange.Cch() == 0)
        {
            continue;
        }


        //
        // Acquire the security data
        //
        IFW32FALSE_EXIT( rSecurityMetaData.GetFileMetaData(
            buffAssemblyRelativeChange,
            pFileDataElement ) );

        //
        // There wasn't any data for this file?  Means we don't know about the file, so we
        // probably should do /something/ about it.  For now, however, with the agreeance of
        // the backup team, we let sleeping files lie.
        if ( pFileDataElement == NULL )
        {
            // 
            // because short-filename is not stored in registry, so for a filename, which might be long-pathname
            // or a short pathname, if we try out all entries in the Registry and still can not find it, 
            // we assume it is a short filename. In this case, we would verify the assembly, if it is not intact, 
            // do reinstall for the assembly....
            //

            DWORD dwResult = 0;           

            IFW32FALSE_EXIT(::SxspValidateEntireAssembly(
                SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING, 
                rRecoveryInfo,
                dwResult));

            fNeedsReinstall = ( dwResult != SXS_VALIDATE_ASM_FLAG_VALID_PERFECT );
            goto DoReinstall;
        }

        //
        // And build the full path of the change via:
        //
        // sbAssemblyPath + \ + buffAssemblyRelativeChange
        //
        IFW32FALSE_EXIT(buffFullPathOfChange.Win32Assign(rbuffAssemblyPath));
        IFW32FALSE_EXIT(buffFullPathOfChange.Win32AppendPathElement(buffAssemblyRelativeChange));

        //
        // We really should check the return value here, but the
        // function is smart enough to set Valid to something useful
        // before returning.  A failure here should NOT be an IFW32FALSE_EXIT
        // call, mostly because we don't want to stop protecting this
        // assembly just because it failed with a FILE_NOT_FOUND or other
        // such.
        //
        IFW32FALSE_EXIT_UNLESS(::SxspValidateAllFileHashes(
            *pFileDataElement,
            buffFullPathOfChange,
            Valid ),
            FILE_OR_PATH_NOT_FOUND(::FusionpGetLastWin32Error()),
            fFileNotFound );

        if ( ( Valid != HashValidate_Matches ) || fFileNotFound )
        {
            fNeedsReinstall = TRUE;
            goto DoReinstall;
        }

    } /* while */



DoReinstall:
    //
    // If somewhere along the line we were supposed to reinstall, then we
    // do so.
    //
    if (fNeedsReinstall)
    {
        //
        // We have to indicate that all changes from point A to point B need
        // to be ignored.
        //
        rRequest.MarkInRecoveryMode(TRUE);
        PerformRecoveryOfAssembly(rRecoveryInfo, RecoverResult);
        rRequest.ClearList();
        rRequest.MarkInRecoveryMode(FALSE);

        /*
        NTRAID#NTBUG9-591177-2002/03/31-JayKrell
        see following comment
        */
        //
        // HACKHACK jonwis 1/20/2001 - Stop failing assertions because lasterror
        // is set wrong by one of the above.
        //
        ::FusionpSetLastWin32Error(0);
    }

    fSuccess = TRUE;
Exit:
    const DWORD dwLastErrorSaved = ::FusionpGetLastWin32Error();

    //
    // We are done - this always succeeds.  The explanation is hairy.
    //
    if (pRequestList->AttemptRemoveItem(&rRequest))
    {
        ::FusionpSetLastWin32Error(dwLastErrorSaved);
    }
    else
    {
        if (!fSuccess)
        {
            // This seems bad that we're losing the original failure; let's at least spew it.
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s() losing original win32 error code of %d; replaced with %d from CProtectionRequestList::AttemptRemoveItem() call.\n",
                __FUNCTION__,
                dwLastErrorSaved,
                ::FusionpGetLastWin32Error());
        }

        fSuccess = FALSE;
    }

    return fSuccess;
}


BOOL WINAPI
SxsProtectionUserLogonEvent()
{
    return SetEvent(g_hSxsLoginEvent);
}

BOOL WINAPI
SxsProtectionUserLogoffEvent()
{
    return ResetEvent(g_hSxsLoginEvent);
}



BOOL
CProtectionRequestList::PerformRecoveryOfAssembly(
    const CAssemblyRecoveryInfo &RecoverInfo,
    SxsRecoveryResult &ResultOut
    )
{
    FN_PROLOG_WIN32

    BOOL                    fFound = FALSE;
    CRecoveryJobTableEntry  *pNewEntry, **pExistingEntry;
	DWORD dwRecoveryLastError = ERROR_SUCCESS;
    CSxsLockCriticalSection lock(m_cInstallerCriticalSection);

    IFALLOCFAILED_EXIT(pNewEntry = new CRecoveryJobTableEntry);
    IFW32FALSE_EXIT(pNewEntry->Initialize());

    IFW32FALSE_EXIT(lock.Lock());
    IFW32FALSE_EXIT(
        m_pInstallsTable->FindOrInsertIfNotPresent(
            RecoverInfo.GetAssemblyDirectoryName(),
            pNewEntry,
            &pExistingEntry,
            &fFound));
    lock.Unlock();

    //
    // Great, it was either inserted or it was already there - if not already there,
    // then we'll take care if it.
    //
    if (!fFound)
    {
        BOOL fSuccess = FALSE;

        IFW32FALSE_EXIT(pNewEntry->StartInstallation());

        //
        // Perform the recovery.
        //
        fSuccess = ::SxspRecoverAssembly(RecoverInfo, ResultOut);

		if (!fSuccess)
			dwRecoveryLastError = ::FusionpGetLastWin32Error();

#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_WFP,
            "SXS: %s() - RecoverAssembly returned Result = %ls, fSuccess = %s, LastError = 0x%08x\n",
            __FUNCTION__,
            ::SxspRecoveryResultToString(ResultOut),
            fSuccess ? "true" : "false",
            dwRecoveryLastError);
#endif

        //
        // Tell this entry that it's all done.  This releases the other people
        // that were waiting on the event to get done as well.
        //
        IFW32FALSE_EXIT(pNewEntry->InstallationComplete(fSuccess, ResultOut, dwRecoveryLastError));

        //
        // And now delete the item from the list.
        //
        IFW32FALSE_EXIT(lock.Lock());
        IFW32FALSE_EXIT(m_pInstallsTable->Remove(RecoverInfo.GetAssemblyDirectoryName()));
        lock.Unlock();
    }
    else
    {
        DWORD dwLastError;
        BOOL fSuccess = FALSE;
        IFW32FALSE_EXIT((*pExistingEntry)->WaitUntilCompleted(ResultOut, fSuccess, dwLastError));

#if DBG
        ::FusionpDbgPrintEx(FUSION_DBG_LEVEL_WFP,
            "SXS: %s() - WaitUntilCompleted returned Result = %ls, fInstalledOk = %s, LastError = 0x%08x\n",
            __FUNCTION__,
            ::SxspRecoveryResultToString(ResultOut),
            fSuccess ? "true" : "false",
            dwLastError);
#endif

		dwRecoveryLastError = dwLastError;
    }

	if (dwRecoveryLastError != ERROR_SUCCESS)
		ORIGINATE_WIN32_FAILURE_AND_EXIT(RecoveryFailed, dwRecoveryLastError);

    FN_EPILOG
}


VOID WINAPI
SxsProtectionEnableProcessing(BOOL fActivityEnabled)
{
    s_fIsSfcAcceptingNotifications = fActivityEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxssfcscan.h ===
#pragma once


#define SXS_VALIDATE_ASM_FLAG_CHECK_CATALOG         ( 0x00000001 )
#define SXS_VALIDATE_ASM_FLAG_CHECK_FILES           ( 0x00000002 )
#define SXS_VALIDATE_ASM_FLAG_CHECK_STRONGNAME      ( 0x00000004 )
#define SXS_VALIDATE_ASM_FLAG_CHECK_CAT_STRONGNAME  ( 0x00000008 )
#define SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING      ( 0x0000000F )

#define SXS_VALIDATE_ASM_FLAG_MODE_STOP_ON_FAIL     ( 0x00000100 )

#define SXS_VALIDATE_ASM_FLAG_VALID_CATALOG         SXS_VALIDATE_ASM_FLAG_CHECK_CATALOG
#define SXS_VALIDATE_ASM_FLAG_VALID_FILES           SXS_VALIDATE_ASM_FLAG_CHECK_FILES
#define SXS_VALIDATE_ASM_FLAG_VALID_STRONGNAME      SXS_VALIDATE_ASM_FLAG_CHECK_STRONGNAME
#define SXS_VALIDATE_ASM_FLAG_VALID_CAT_STRONGNAME  SXS_VALIDATE_ASM_FLAG_CHECK_CAT_STRONGNAME
#define SXS_VALIDATE_ASM_FLAG_VALID_PERFECT         SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING

BOOL
SxspValidateEntireAssembly(
    DWORD dwFlags,
    const CAssemblyRecoveryInfo &RecoverInfo,
    DWORD &dwResult,
    PCASSEMBLY_IDENTITY pAssemblyIdentity = NULL,
    const CBaseStringBuffer *pbuffWinsxsRoot = NULL
    );

//
// Single-shot scanning
//
BOOL
SxsProtectionPerformScanNow(
    HWND hwProgressWindow,
    BOOL bValidate,
    BOOL bUIAllowed
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxspath.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxspath.h

Abstract:

    popular cousin of "String.h" and "Wheel.h"

Author:

    Jay Krell (a-JayK, JayKrell) April 2000

Revision History:

--*/
#pragma once
#include "fusionstring.h"

/*
See also

If you find yourself scanning strings with for loops, stop, and
learn to use:
FusionString.h
    StringReverseSpan
    StringReverseComplementSpan

<string.h> / <wchar.h>
    wcschr
    wcsrchr
    wcsspn
    wcscspn
    wcsstr

StringBuffer.h
    Member functions with "Path" in their name.
*/

/*-----------------------------------------------------------------------------
Split a path into

root, path, base, extension

the full path is roughly root + "\\" + path + "\\" + base + "." + extension
but path, base, and extension can be empty (but not all three) and root
might end in a slash, so you shouldn't do that blindly.

Forward and backward slashes are accepted.
Runs of slashes are accepted and mean the same thing as individual slashes
    (a run is sort of special case at the start to indicate UNC, but other than
    the call out to ntdll.dll, that doesn't effect the logic here)

This class has no path length limitations (ntdll.dll?)

The output of this class is its public member data.
-----------------------------------------------------------------------------*/
template <typename PCWSTRorPWSTR = PCWSTR>
class CFullPathSplitPointersTemplate
{
public:
    CFullPathSplitPointersTemplate();

    BOOL Initialize(PCWSTR full)
    {
        return GenericInitialize(full);
    }

    BOOL Initialize(PWSTR full)
    {
        return GenericInitialize(full);
    }

protected:
    BOOL GenericInitialize(PCWSTRorPWSTR full);

public:

    BOOL IsBaseEmpty() const;
    BOOL IsBaseEqual(const CFullPathSplitPointersTemplate&) const;

    //
    // This public data is the output of this class.
    // none of these have trailing slashes except possibly "c:\"
    // all "end" values are "one past the end", STL style
    // extension doesn't include the dot, but you can be paranoid
    // and check for that (it'll be NULL or point to nul if there's no extension)
    // path must be "well formed", full, Win32 drive letter or UNC,
    // and not end in a slash, otherwise Initialize will return false
    //
    // These are not in general nul terminated.
    // m_extensionEnd usually does point to a nul.
    //
    // Generally, you yourself put stick a nul over m_*end,
    // because generally none of the pieces overlap, but a
    // root of c:\ is a common exception. CSetupCopyQueuePathParameters
    // sticks in nuls, and allows for this exception.
    //
    // The length of any element is m_*end - m_*, as is the STL iterator way.
    //
    PCWSTRorPWSTR m_root;         // never NULL or ""
    PCWSTRorPWSTR m_rootEnd;      // never == m_root
    PCWSTRorPWSTR m_path;         // NULL or "" in case of c:\foo.txt
    PCWSTRorPWSTR m_pathEnd;      // == m_path in case of c:\foo.txt
    PCWSTRorPWSTR m_base;         // NULL or "" in case of c:\.foo
    PCWSTRorPWSTR m_baseEnd;      // == m_base in case of c:\.foo
    PCWSTRorPWSTR m_extension;    // NULL or "" in case c:\foo
    PCWSTRorPWSTR m_extensionEnd; // == fullEnd if there is no extension

    // if the file has a base, this points to it
    //      followed by dot and extension if it has one
    // if the file has no base, this points to the extension, including the dot
    // this is always nul terminated
    // this is never null, and shouldn't be empty either
    PCWSTRorPWSTR m_name;
};

typedef CFullPathSplitPointersTemplate<>       CFullPathSplitPointers;
typedef CFullPathSplitPointersTemplate<PWSTR>  CMutableFullPathSplitPointers;

/*-----------------------------------------------------------------------------
Building on CFullPathSplitPointers, take two strings and split them up
exactly as SetupCopyQueue wants them, into
source root, root path, source name (base + extension)
destination directory (root + path), destination name (base + extension)

The output of this class is its public member data.
-----------------------------------------------------------------------------*/
class CSetupCopyQueuePathParameters
{
public:
    CSetupCopyQueuePathParameters();

    BOOL
    Initialize(
        PCWSTR pszSource,
        PCWSTR pszDestination
        );

    // rather than copy each substring into its own buffer, put nuls
    // in place, over the delimiting slashes (and dot), BUT watch out
    // for c:\foo, so if the root is three characters, copy it
    // into a seperate buffer.
public:
    //
    // These are null terminated.
    //
    PCWSTR m_sourceRoot;
    PCWSTR m_sourcePath;
    PCWSTR m_sourceName; // base and extension

    PCWSTR m_destinationDirectory; // root and path
    PCWSTR m_destinationName; // base and extension
protected:
    WCHAR                         m_sourceRootStorage[4];
    CStringBuffer                 m_sourceBuffer;
    CMutableFullPathSplitPointers m_sourceSplit;

    WCHAR                         m_destinationDirectoryStorage[4]; // root and path, if path is empty
    CStringBuffer                 m_destinationBuffer;
    CMutableFullPathSplitPointers m_destinationSplit;

private:
    CSetupCopyQueuePathParameters(const CSetupCopyQueuePathParameters &);
    void operator =(const CSetupCopyQueuePathParameters &);
};

/*-----------------------------------------------------------------------------
inline implementation of CFullPathSplitPointersTemplate,
because it is a template
-----------------------------------------------------------------------------*/
template <typename T>
inline CFullPathSplitPointersTemplate<T>::CFullPathSplitPointersTemplate()
:
    m_root(NULL),
    m_rootEnd(NULL),
    m_path(NULL),
    m_pathEnd(NULL),
    m_base(NULL),
    m_baseEnd(NULL),
    m_extension(NULL),
    m_extensionEnd(NULL),
    m_name(L"")
{
}

template <typename T>
inline BOOL
CFullPathSplitPointersTemplate<T>::GenericInitialize(T full)
{
    BOOL fSuccess = FALSE;

    FN_TRACE_WIN32(fSuccess);

    RTL_PATH_TYPE pathType;

    pathType = ::SxspDetermineDosPathNameType(full);

    PARAMETER_CHECK(
        (pathType == RtlPathTypeUncAbsolute) ||
        (pathType == RtlPathTypeLocalDevice) ||
        (pathType == RtlPathTypeDriveAbsolute));

    T fullEnd;
    fullEnd = full + StringLength(full);
    m_root = full;
    if (m_root[1] == ':')
    {
        m_path  = m_root + 3;
        m_rootEnd = m_path;
        m_path += wcsspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip path separators
    }
    else
    {
        m_path = m_root;
        m_path +=  wcsspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip "\\"
        m_path += wcscspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip "\\computer"
        m_path +=  wcsspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip "\\computer\"
        m_path += wcscspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip "\\computer\share"
        m_rootEnd = m_path;
        m_path +=  wcsspn(m_path, CUnicodeCharTraits::PathSeparators()); // skip "\\computer\share\"
    }

    //
    // now work from the right
    // first find the last dot and last slash, and determine
    // where the base and extension are, if any
    //

    INT nameExtLength;
    INT extLength;

    
    nameExtLength = ::StringReverseComplementSpan(m_path, fullEnd, CUnicodeCharTraits::PathSeparators());
    extLength = ::StringReverseComplementSpan(m_path, fullEnd, L".");

    //
    // determine the extension
    //
    if (extLength > nameExtLength)
    {
        // no extension on leaf, but one on a parent, slightly unusual
        // c:\foo.bar\abc
        m_extension = NULL;
        m_extensionEnd = NULL;
    }
    else
    {
        // c:\foo\abc.txt or c:\foo.bar\abc.txt (or c:\foo\.txt or some others)
        m_extension  = fullEnd - extLength;
        m_extensionEnd = fullEnd;
    }

    //
    // determine the base
    //
    if (extLength + 1 == nameExtLength)
    {
        // unusual case, extension but no base
        // c:\.foo or c:\abc\.foo
        m_base = NULL;
        m_baseEnd = NULL;
    }
    else
    {
        m_base = fullEnd - nameExtLength;
        if (m_extension != NULL)
        {
            // normal case, base.extension
            m_baseEnd = m_extension - 1;
        }
        else
        {
            // no extension
            m_baseEnd = fullEnd;
        }
    }

    //
    // determine the path
    //
    if (m_base != NULL)
    {
        if (m_path == m_base)
        {
            // no path c:\foo.txt
            m_path = NULL;
            m_pathEnd = NULL;
        }
        else
        {
            // normal case of path ends at base c:\abc\def.txt
            m_pathEnd = m_base - 1;
        }
    }
    else if (m_extension != NULL)
    {
        // no base, but an extension
        // c:\.txt or c:\abc\.txt
        if (m_path + 1 == m_extension)
        {
            // no path c:\.txt
            m_path = NULL;
            m_pathEnd = NULL;
        }
        else
        {
            // path ends at extension c:\abc\.txt
            m_pathEnd = m_extension - 2;
        }
    }
    else
    {
        // no path and no extension
        // this probably happens when we have a terminal slash
        // we've already filtered out empty strings
        m_pathEnd = fullEnd - ::StringReverseSpan(m_path, fullEnd, CUnicodeCharTraits::PathSeparators());
    }

    // there is always a root (paths are always full)
    ASSERT(m_root != NULL && m_rootEnd != NULL);

    // there is always a base or an extension (or both)
    ASSERT(m_base != NULL || m_extension != NULL);

    // if there's a start, there's an end
    ASSERT((m_base != NULL) == (m_baseEnd != NULL));
    ASSERT((m_extension != NULL) == (m_extensionEnd != NULL));

    m_name = (m_base != NULL) ? m_base : (m_extension - 1);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

template <typename T>
inline BOOL
CFullPathSplitPointersTemplate<T>::IsBaseEmpty(
    ) const
{
    return (m_base == m_baseEnd);
}

template <typename T>
inline BOOL
CFullPathSplitPointersTemplate<T>::IsBaseEqual(
    const CFullPathSplitPointersTemplate& other
    ) const
{
    BOOL fEqual = FALSE;
    const INT length1 = static_cast<INT>(m_baseEnd - m_base);
    const INT length2 = static_cast<INT>(other.m_baseEnd - other.m_base);
    if (length1 != length2)
        goto Exit;
    fEqual = (::FusionpCompareStrings(m_base, length1, other.m_base, length1, true) == 0);
Exit:
    return fEqual;
}

/*-----------------------------------------------------------------------------
inline implementation of CSetupCopyQueuePathParameters
-----------------------------------------------------------------------------*/
inline CSetupCopyQueuePathParameters::CSetupCopyQueuePathParameters()
:
    m_sourcePath(NULL),
    m_sourceName(NULL),
    m_destinationDirectory(NULL),
    m_destinationName(NULL)
{
    m_sourceRootStorage[0] = 0;
    m_destinationDirectoryStorage[0] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsprotect.h ===
#pragma once

#include "sxsp.h"

//
// Turn this off to fail all manifests without catalogs during the parse!
//
#define SXS_LAX_MANIFEST_VALIDATION

//
// Warning - leaving this defined will --DISABLE-- WFP-SXS.
// Define it as FALSE if you want to turn it back on.
//
#define YOU_ARE_HAVING_ANY_WIERDNESS_WITH_SFC_AND_SXS FALSE
//
// For this checkin (11/23ish/2000), we'll be leaving it turned OFF
//
// #define YOU_ARE_HAVING_ANY_WIERDNESS_WITH_SFC_AND_SXS TRUE


//
// This stuff is private!
//
#include "hashfile.h"
#include "cassemblyrecoveryinfo.h"
#include "recover.h"

BOOL
SxspResolveAssemblyManifestPath(
    const CBaseStringBuffer &rAsmDirectoryName,
    CBaseStringBuffer &rbsManifestPath
    );

BOOL
SxspIsSfcIgnoredStoreSubdir(
    PCWSTR pwszDir
    );


class CProtectionRequestList;
class CStringListEntry;
class CProtectionRequestRecord;

#include "hashfile.h"
#include "fusionhash.h"

class CStringListEntry : public CAlignedSingleListEntry
{
public:
    CStringListEntry() { }

    CStringBuffer   m_sbText;
private:
    CStringListEntry(const CStringListEntry &);
    void operator =(const CStringListEntry &);
};

#pragma warning(disable:4327)  // indirection alignment of LHS (16) is greater than RHS (8)
#pragma warning(disable:4328)  // indirection alignment of formal parameter 2 (16) is greater than the actual argument alignment (8)

class CProtectionRequestRecord
{
private:
    CStringBuffer                   m_sbAssemblyDirectoryName;
    CStringBuffer                   m_sbManifestPath;
    CStringBuffer                   m_sbAssemblyStore;
    CStringBuffer                   m_sbKeyValue;
    DWORD                           m_dwAction;
    PSXS_PROTECT_DIRECTORY          m_pvProtection;
    ULONG                           m_ulInRecoveryMode;
    CProtectionRequestList          *m_pParent;
    __declspec(align(16))
    SLIST_HEADER                    m_ListHeader;
    BOOL                            m_bIsManPathResolved;
    BOOL                            m_bInitialized;
    CAssemblyRecoveryInfo           m_RecoverInfo;

public:

    CProtectionRequestRecord();


    CProtectionRequestList *GetParent() const { return m_pParent; }
    CAssemblyRecoveryInfo &GetRecoveryInfo() { return m_RecoverInfo; }
    const CAssemblyRecoveryInfo &GetRecoveryInfo() const { return m_RecoverInfo; }
    const CBaseStringBuffer &GetAssemblyDirectoryName() const { return m_sbAssemblyDirectoryName; }
    const CBaseStringBuffer &GetChangeBasePath() const { return m_sbKeyValue; }

    VOID SetParent(CProtectionRequestList *pParent) { m_pParent = pParent; };
    VOID MarkInRecoveryMode(BOOL inRecovery) { ::SxspInterlockedExchange( &m_ulInRecoveryMode, ( inRecovery ? 1 : 0 ) ); }
    VOID ClearList();

    BOOL SetAssemblyDirectoryName(const CBaseStringBuffer &rsbNewname) { return m_sbAssemblyDirectoryName.Win32Assign(rsbNewname); }
    BOOL GetManifestPath(CBaseStringBuffer &sbManPath);
    BOOL AddSubFile(const CBaseStringBuffer &sbThing);
    BOOL PopNextFileChange(CBaseStringBuffer &Dest);
    BOOL GetAssemblyStore(CBaseStringBuffer &Dest) { return Dest.Win32Assign(m_sbAssemblyStore); }

    BOOL Initialize(
        const CBaseStringBuffer &sbAssemblyName,
        const CBaseStringBuffer &sbKeyString,
        CProtectionRequestList* ParentList,
        PVOID                   pvRequestRecord,
        DWORD                   dwAction
        );

    ~CProtectionRequestRecord();

private:
    CProtectionRequestRecord(const CProtectionRequestRecord &);
    void operator =(const CProtectionRequestRecord &);
};

class CRecoveryJobTableEntry
{
public:
    CRecoveryJobTableEntry()
        : m_Result(Recover_Unknown), m_dwLastError(ERROR_SUCCESS),  m_fSuccessValue(TRUE),
          m_Subscriber(0), m_EventInstallingAssemblyComplete(INVALID_HANDLE_VALUE)
    { }

    SxsRecoveryResult   m_Result;
    DWORD               m_dwLastError;
    BOOL                m_fSuccessValue;
    ULONG               m_Subscriber;
    HANDLE              m_EventInstallingAssemblyComplete;

    BOOL Initialize();
    BOOL StartInstallation();
    BOOL InstallationComplete( BOOL bDoneOk, SxsRecoveryResult Result, DWORD dwLastError );

    BOOL WaitUntilCompleted( SxsRecoveryResult &rResult, BOOL &rbSucceededValue, DWORD &rdwErrorResult );

    ~CRecoveryJobTableEntry();
private:
    CRecoveryJobTableEntry(const CRecoveryJobTableEntry &);
    void operator =(const CRecoveryJobTableEntry &);
};

class CProtectionRequestList : public CCleanupBase
{
private:
    typedef CCaseInsensitiveUnicodeStringPtrTable<CProtectionRequestRecord> COurInternalTable;
    typedef CCaseInsensitiveUnicodeStringPtrTableIter<CProtectionRequestRecord> COurInternalTableIter;
    typedef CCaseInsensitiveUnicodeStringPtrTable<CRecoveryJobTableEntry> CInstallsInProgressTable;

    CRITICAL_SECTION    m_cSection;
    CRITICAL_SECTION    m_cInstallerCriticalSection;
    COurInternalTable   *m_pInternalList;
    CInstallsInProgressTable *m_pInstallsTable;

    //
    // Manifest edits are trickier, they get their own system of being handled.
    //
    __declspec(align(16))    
    SLIST_HEADER        m_ManifestEditList;
    HANDLE              m_hManifestEditHappened;
    ULONG               m_ulIsAThreadServicingManifests;
    PVOID               m_Padding;  // Required for win64 win S-Lists are 16 byte aligned

    static DWORD ProtectionNormalThreadProc( PVOID pvParam );
    static DWORD ProtectionManifestThreadProc( PVOID pvParam );
    static BOOL  ProtectionManifestThreadProcNoSEH( PVOID pvParam );

    BOOL ProtectionNormalThreadProcWrapped( CProtectionRequestRecord *pProtectionRequest );
    BOOL ProtectionManifestThreadProcWrapped();
    BOOL ProtectionManifestSingleManifestWorker( const CStringListEntry *pEntry );

    static PCWSTR m_arrIgnorableSubdirs[];
    static SIZE_T m_cIgnorableSubdirs;

    friend BOOL SxspConstructProtectionList();

    BOOL Initialize();

    CProtectionRequestList();

    BOOL PerformRecoveryOfAssembly(
        const CAssemblyRecoveryInfo &RecoverInfo,
        SxsRecoveryResult &Result
        );

    ~CProtectionRequestList();

public:
    static BOOL IsSfcIgnoredStoreSubdir( PCWSTR wsz );
    void DeleteYourself() { this->~CProtectionRequestList(); }
    VOID ClearProtectionItems(CProtectionRequestRecord *Asm) { FUSION_DELETE_SINGLETON( Asm ); }

    BOOL AttemptRemoveItem( CProtectionRequestRecord *AttemptRemoval );
    BOOL AddRequest( PSXS_PROTECT_DIRECTORY pProtect, PCWSTR pcwszDirName, SIZE_T cchName, DWORD dwAction );

private:
    CProtectionRequestList(const CProtectionRequestList &);
    void operator =(const CProtectionRequestList &);
};

VOID
SxsProtectionEnableProcessing(
    BOOL bActivityEnabled
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxssfcscan.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "windows.h"
#include "sxsapi.h"
#include "sxsprotect.h"
#include "sxssfcscan.h"
#include "wintrust.h"
#include "softpub.h"
#include "strongname.h"
#include "recover.h"

BOOL
SxspValidateEntireAssembly(
    DWORD dwFlags,
    const CAssemblyRecoveryInfo &RecoverInfo,
    DWORD &dwResult,
    PCASSEMBLY_IDENTITY pAssemblyIdentity,
    const CBaseStringBuffer *pbuffWinsxsRoot
    )
{
    BOOL                        bSuccess = FALSE;
    const CSecurityMetaData     &rSecurityData = RecoverInfo.GetSecurityInformation();
    FN_TRACE_WIN32(bSuccess);

#define CHECKSHOULDSTOPFAIL { if (dwFlags & SXS_VALIDATE_ASM_FLAG_MODE_STOP_ON_FAIL) { bSuccess = TRUE; goto Exit; } }
#define ADDFLAG(result, test, flag) { if (test) { (result) |= (flag); } else CHECKSHOULDSTOPFAIL }

    ManifestValidationResult    ManifestValidity;
    CSecurityMetaData           SecurityMetaData;
    CStringBuffer               sbManifestPath;

    dwResult = 0;

    if (dwFlags == 0)
    {
        dwFlags = SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING;
        dwFlags |= (SXS_VALIDATE_ASM_FLAG_MODE_STOP_ON_FAIL);
    }

    IFINVALID_FLAGS_EXIT_WIN32(dwFlags,
        SXS_VALIDATE_ASM_FLAG_CHECK_CATALOG |
        SXS_VALIDATE_ASM_FLAG_CHECK_FILES |
        SXS_VALIDATE_ASM_FLAG_CHECK_STRONGNAME |
        SXS_VALIDATE_ASM_FLAG_CHECK_CAT_STRONGNAME |
        SXS_VALIDATE_ASM_FLAG_MODE_STOP_ON_FAIL);

    //
    // Asking us to check the catalog when there's no catalog on the assembly
    // is a Bad Thing.  Perhaps this should just return TRUE with a missing catalog?
    //
    PARAMETER_CHECK(dwFlags & SXS_VALIDATE_ASM_FLAG_CHECK_CATALOG);
    PARAMETER_CHECK(RecoverInfo.GetHasCatalog());

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS.DLL: %s() - Beginning protection scan of %ls, flags 0x%08x\n",
        __FUNCTION__,
        static_cast<PCWSTR>(RecoverInfo.GetAssemblyDirectoryName()),
        dwFlags);
#endif

    if (pAssemblyIdentity == NULL)
    {
        IFW32FALSE_EXIT(::SxspResolveAssemblyManifestPath(RecoverInfo.GetAssemblyDirectoryName(), sbManifestPath));
    }
    else
    {
        CTinyStringBuffer           buffWinsxsRoot;
        PROBING_ATTRIBUTE_CACHE     AttributeCache = { 0 };

        if (pbuffWinsxsRoot == NULL)
        {
            IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffWinsxsRoot));
            pbuffWinsxsRoot = &buffWinsxsRoot;
        }
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath_FullPathToManifestOrPolicyFile(
                *pbuffWinsxsRoot,
                pAssemblyIdentity,
                &AttributeCache,
                sbManifestPath));
    }

    //
    // If we're checking the catalog, then do it.  If the catalog is bad or
    // otherwise doesn't match the actual assembly, then we need to mark
    // ourselves as successful, then exit.
    //
    if (dwFlags & SXS_VALIDATE_ASM_FLAG_CHECK_CATALOG)
    {
		IFW32FALSE_EXIT(::SxspValidateManifestAgainstCatalog(
            sbManifestPath,
            ManifestValidity,
            0));

#if DBG
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_WFP,
            "SXS.DLL:    Manifest Validity = %ls\n",
            ::SxspManifestValidationResultToString(ManifestValidity));
#endif

        ADDFLAG(
            dwResult,
            ManifestValidity == ManifestValidate_IsIntact,
            SXS_VALIDATE_ASM_FLAG_VALID_CATALOG);
    }


    //TODO: Problems - make sure that we validate the manifest against what's in the
    // registry.  Maybe we need a special mode of incorporating assemblies (over a manifest)
    // that will just fill out the security data and nothing else...
   
    //
    // Validate the strong name of the assembly first.
    //
    if (dwFlags & SXS_VALIDATE_ASM_FLAG_CHECK_STRONGNAME)
    {
        //
        // JW 3/19/2001 - Public keys are NO LONGER IN THE BUILD, and as such
        // this check is moot.
        //
        ADDFLAG(dwResult, TRUE, SXS_VALIDATE_ASM_FLAG_VALID_STRONGNAME);
    }

    //
    // Let's open the catalog and scour through it certificate-wise
    // looking for a strong name that matches up.
    //
    if (dwFlags & SXS_VALIDATE_ASM_FLAG_CHECK_CAT_STRONGNAME)
    {
        CStringBuffer sbCatalogName;
        CSmallStringBuffer sbTheorheticalStrongName;
        const CFusionByteArray &rbaSignerPublicKey = rSecurityData.GetSignerPublicKeyTokenBits();
        CPublicKeyInformation PublicKeyInfo;
        BOOL bStrongNameFoundInCatalog;

        IFW32FALSE_EXIT(sbCatalogName.Win32Assign(sbManifestPath));
        IFW32FALSE_EXIT(sbCatalogName.Win32ChangePathExtension(
            FILE_EXTENSION_CATALOG,
            FILE_EXTENSION_CATALOG_CCH,
            eAddIfNoExtension));

        if (!PublicKeyInfo.Initialize(sbCatalogName))
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();
            if ((dwLastError != ERROR_PATH_NOT_FOUND) &&
                 (dwLastError != ERROR_FILE_NOT_FOUND))
                 goto Exit;
        }

        IFW32FALSE_EXIT(
			::SxspHashBytesToString(
				rbaSignerPublicKey.GetArrayPtr(),
				rbaSignerPublicKey.GetSize(),
				sbTheorheticalStrongName));

        IFW32FALSE_EXIT(
			PublicKeyInfo.DoesStrongNameMatchSigner(
				sbTheorheticalStrongName,
				bStrongNameFoundInCatalog));

        ADDFLAG(dwResult, bStrongNameFoundInCatalog, SXS_VALIDATE_ASM_FLAG_VALID_CAT_STRONGNAME);
    }

    //
    // Now, scan through all the files that are listed in the manifest and
    // ensure that they're all OK.
    //
    if (dwFlags & SXS_VALIDATE_ASM_FLAG_CHECK_FILES)
    {
        CStringBuffer sbTempScanPath;
        CStringBuffer sbAsmRootDir;
        const CBaseStringBuffer &sbAssemblyName = RecoverInfo.GetAssemblyDirectoryName();
        CFileInformationTableIter ContentTableIter(const_cast<CFileInformationTable&>(rSecurityData.GetFileDataTable()));

        HashValidateResult hvResult;
        BOOL bAllFilesMatch = TRUE;
        BOOL fTempBoolean;
        SIZE_T cchPath;

        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(sbAsmRootDir));

        IFW32FALSE_EXIT(sbTempScanPath.Win32Assign(sbAsmRootDir));
        IFW32FALSE_EXIT(sbTempScanPath.Win32AppendPathElement(sbAssemblyName));
        cchPath = sbTempScanPath.Cch();
        

        for (ContentTableIter.Reset();
              ContentTableIter.More();
              ContentTableIter.Next())
        {
            //
            // Cobble together a path to scan for the file in, based on the
            // assembly root directory, the 'name' of the assembly (note:
            // we can't use this to go backwards to get an identity,
            // unfortunately), and the name of the file to be validated.
            //
            PCWSTR wsString = ContentTableIter.GetKey();
            CMetaDataFileElement &HashEntry = ContentTableIter.GetValue();

            sbTempScanPath.Left(cchPath);
            IFW32FALSE_EXIT(sbTempScanPath.Win32AppendPathElement(wsString, ::wcslen(wsString)));

            IFW32FALSE_EXIT_UNLESS( ::SxspValidateAllFileHashes( 
                HashEntry, 
                sbTempScanPath,
                hvResult ),
                FILE_OR_PATH_NOT_FOUND(::FusionpGetLastWin32Error()),
                fTempBoolean );

            if ( ( hvResult != HashValidate_Matches ) || ( fTempBoolean ) )
            {
                bAllFilesMatch = FALSE;
				break;
            }

        }

        ADDFLAG(dwResult, bAllFilesMatch, SXS_VALIDATE_ASM_FLAG_VALID_FILES);
    }

    //
    // Phew - should be done doing everything the user wanted us to.
    //
    bSuccess = TRUE;
Exit:
#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_WFP,
        "SXS.DLL: Done validating, result = 0x%08x, success = %d\n",
        dwResult,
        bSuccess);
#endif

    return bSuccess;

#undef CHECKSHOULDSTOPFAIL
}



//
// Single-shot scanning
//
BOOL
SxsProtectionPerformScanNowNoSEH(
    HWND hwProgressWindow,
    BOOL bValidate,
    BOOL bUIAllowed
    )
{
    BOOL                bSuccess = TRUE;
    FN_TRACE_WIN32(bSuccess);

    CFusionRegKey       hkInstallRoot;
    CStringBuffer       sbKeyName;
    DWORD               dwKeyIndex;
    BOOL                fNoMoreKeys = FALSE;
    CStringBuffer       sbAssemblyDirectory, sbManifestPath;

    //
    // If we're scanning, then we don't want to bother sxs-sfc with changes,
    // now do we?
    //
    // REVIEW: Handy way to get around sfc-sxs... start a series of scans, and
    // insert 'bad' files into assemblies while we're scanning.
    //
    ::SxsProtectionEnableProcessing(FALSE);

    bSuccess = TRUE;

    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey( 0, KEY_READ, hkInstallRoot ));

    dwKeyIndex = 0;
    while (!fNoMoreKeys)
    {
        CAssemblyRecoveryInfo ri;
        
        bool fHasAssociatedAssembly;
        IFW32FALSE_EXIT(hkInstallRoot.EnumKey(dwKeyIndex++, sbKeyName, NULL, &fNoMoreKeys));

        if (fNoMoreKeys)
        {
            break;
        }

        IFW32FALSE_EXIT(ri.AssociateWithAssembly(sbKeyName, fHasAssociatedAssembly));

        if (!fHasAssociatedAssembly)
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS.DLL: %s() - We found the assembly %ls in the registry, but were not able to associate it with an assembly\n",
                __FUNCTION__,
                static_cast<PCWSTR>(sbKeyName));
        }
        else if (!ri.GetHasCatalog())
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_WFP,
                "SXS.DLL: %s() - Assembly %ls in registry, no catalog, not validating.\n",
                __FUNCTION__,
                static_cast<PCWSTR>(sbKeyName));
        }
        else
        {
            DWORD dwValidateMode, dwResult;
            SxsRecoveryResult RecoverResult;

            dwValidateMode = SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING;

            IFW32FALSE_EXIT(::SxspValidateEntireAssembly(
                dwValidateMode,
                ri,
                dwResult));

            if (dwResult != SXS_VALIDATE_ASM_FLAG_VALID_PERFECT)
            {
#if DBG
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL:  %s() - Scan of %ls failed one or more, flagset 0x%08x\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(sbKeyName),
                    dwResult);
#endif

                IFW32FALSE_EXIT(
                    ::SxspRecoverAssembly(
                        ri,
                        RecoverResult));

#if DBG
                if (RecoverResult != Recover_OK)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_WFP | FUSION_DBG_LEVEL_ERROR,
                        "SXS.DLL: %s() - Reinstallation of assembly %ls failed, status %ls\n",
                        static_cast<PCWSTR>(sbKeyName),
                        ::SxspRecoveryResultToString(RecoverResult));
                }
#endif
            }

        }
    }

    bSuccess = TRUE;
Exit:
    return bSuccess;
}

BOOL
SxsProtectionPerformScanNow(
    HWND hwProgressWindow,
    BOOL bValidate,
    BOOL bUIAllowed
    )
{
    BOOL                bSuccess = TRUE;
    bSuccess = ::SxsProtectionPerformScanNowNoSEH(hwProgressWindow, bValidate, bUIAllowed);

    //
    // Always reenable sfc notifications!
    //
    ::SxsProtectionEnableProcessing(TRUE);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsuninstall.h ===
asdfasdf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsuninstall.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "sxsapi.h"
#include "recover.h"
#include "sxsinstall.h"

BOOL
pDeleteFileOrDirectoryHelper(
    IN const CBaseStringBuffer &rcbuffFileName
    )
/*++

Purpose:

    When you need a filesystem object gone, call us.

Parameters:

    The absolute name of the thing being killed.

Returns:

    TRUE if the object was deleted, false if it (or any subobjects) wasn't.

--*/
{
    FN_PROLOG_WIN32
    //
    // Maybe this is a directory.  Trying this won't hurt.
    //
    bool fExist = false;
    IFW32FALSE_EXIT(SxspDoesFileExist(0, rcbuffFileName, fExist));
    if (fExist)
    {
        DWORD dwAttr = 0;
        IFW32FALSE_EXIT(SxspGetFileAttributesW(rcbuffFileName, dwAttr));
        if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
        {
            IFW32FALSE_EXIT(::SxspDeleteDirectory(rcbuffFileName));
        }else // it should be a file
        {
            // try to reset FileAttribute for DeleteFile
            ::SetFileAttributesW(rcbuffFileName, FILE_ATTRIBUTE_NORMAL);
            IFW32FALSE_ORIGINATE_AND_EXIT(::DeleteFileW(rcbuffFileName));
        }
    }

    FN_EPILOG
}


BOOL
pRemovePotentiallyEmptyDirectory(
    IN const CBaseStringBuffer &buffDirName
    )
{
    FN_PROLOG_WIN32
    bool fExist = false;

    IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY, buffDirName, fExist));
    if (fExist)
    {    
        BOOL fDumpBoolean = FALSE;

        IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS(
            ::SetFileAttributesW(
                buffDirName,
                FILE_ATTRIBUTE_NORMAL),
            FILE_OR_PATH_NOT_FOUND(::FusionpGetLastWin32Error()),
            fDumpBoolean);

        if (!fDumpBoolean)
        {
            IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS2(
                ::RemoveDirectoryW(buffDirName),
                LIST_4(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_DIR_NOT_EMPTY, ERROR_SHARING_VIOLATION),
                fDumpBoolean);
        }            
    }

    FN_EPILOG
}


BOOL
pCleanUpAssemblyData(
    IN  const PCASSEMBLY_IDENTITY pcAsmIdent, 
    OUT BOOL  &rfWasRemovedProperly
    )
/*++

Purpose:

    Deletes registry and filesystem information about the assembly indicated.
    Removes installation data from the registry first, so as to avoid SFP
    interactions.

Parameters:

    pcAsmIdent          - Identity of the assembly to be destroyed

    rfWasRemovedProperly- Flag to indicate whether or not all the assembly
                          data was actually removed.


Returns:

    FALSE if "anything bad" happened while deleting registry data.  See
    rfWasRemovedProperly for actual status.

--*/
{
    if (SXS_AVOID_WRITING_REGISTRY)
        return TRUE;

    FN_PROLOG_WIN32

    BOOL                fDumpBoolean = FALSE;
    BOOL                fPolicy = FALSE;
    CSmallStringBuffer  buffSxsStore;
    CSmallStringBuffer  buffScratchSpace;
    CFusionRegKey       hkAsmInstallInfo;
    CFusionRegKey       hkSingleAsmInfo;

    //
    // Cleanup happens in two phases:
    //
    // 1 - The registry data is whacked from rhkAsmInstallInfo.  Since we're
    //     uninstalling an assembly, there's no reason to keep anything in it,
    //     especially because it's got no references.  Use DestroyKeyTree and
    //     then DeleteKey to remove it.
    //
    // 2 - Delete as many of the on-disk files as possible, esp. the manifest
    //     and catalog.
    //

    PARAMETER_CHECK(pcAsmIdent != NULL);

    //
    // Start this out at true, we'll call it false later on.
    //
    rfWasRemovedProperly = TRUE;

    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(pcAsmIdent, fPolicy));
    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffSxsStore));

    //
    // Bye-bye to the registry first
    //
    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(0 , KEY_ALL_ACCESS, hkAsmInstallInfo));
    IFW32FALSE_EXIT(::SxspGenerateAssemblyNameInRegistry(pcAsmIdent, buffScratchSpace));
    IFW32FALSE_EXIT(hkAsmInstallInfo.OpenSubKey(hkSingleAsmInfo, buffScratchSpace, KEY_ALL_ACCESS, 0));
    if ( hkSingleAsmInfo != CFusionRegKey::GetInvalidValue() )
    {
        //
        // Failure here isn't so bad...
        //
        IFW32FALSE_EXIT_UNLESS2(
            hkSingleAsmInfo.DestroyKeyTree(),
            LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
            fDumpBoolean);

        if ( !fDumpBoolean )
        {
            IFW32FALSE_EXIT_UNLESS2(
                hkAsmInstallInfo.DeleteKey(buffScratchSpace),
                LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                fDumpBoolean);
        }

    }

    //
    // Both policies and normal assemblies have a manifest and catalog.
    //
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            0,
            fPolicy ? SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY : SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
            buffSxsStore,
            buffSxsStore.Cch(),
            pcAsmIdent,
            NULL,
            buffScratchSpace));

    rfWasRemovedProperly = rfWasRemovedProperly && ::pDeleteFileOrDirectoryHelper(buffScratchSpace);

    IFW32FALSE_EXIT(buffScratchSpace.Win32ChangePathExtension(
        FILE_EXTENSION_CATALOG,
        FILE_EXTENSION_CATALOG_CCH,
        eErrorIfNoExtension));

    rfWasRemovedProperly = rfWasRemovedProperly && pDeleteFileOrDirectoryHelper(buffScratchSpace);

    //
    // Clean up data
    //
    if (!fPolicy)
    {
        //
        // This just poofs the assembly member files.
        // If the delete fails, we'll try to rename the directory to something else.
        //
        IFW32FALSE_EXIT(
            ::SxspGenerateSxsPath(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                buffSxsStore,
                buffSxsStore.Cch(),
                pcAsmIdent,
                NULL,
                buffScratchSpace));

        rfWasRemovedProperly = rfWasRemovedProperly && ::pDeleteFileOrDirectoryHelper(buffScratchSpace);
    }
    else
    {
        //
        // The policy file above should already have been deleted, so we should
        // attempt to remove the actual policy directory if it's empty.  The
        // directory name is still in buffScratchSpace, if we just yank off the
        // last path element.
        //
        IFW32FALSE_EXIT(buffScratchSpace.Win32RemoveLastPathElement());
        rfWasRemovedProperly = rfWasRemovedProperly && ::pRemovePotentiallyEmptyDirectory(buffScratchSpace);

    }


    //
    // Once we've killed all the assembly information, if the Manifests or the
    // Policies directory is left empty, go clean them up as well.
    //
    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffScratchSpace));
    IFW32FALSE_EXIT(buffScratchSpace.Win32AppendPathElement(
        (fPolicy? POLICY_ROOT_DIRECTORY_NAME : MANIFEST_ROOT_DIRECTORY_NAME),
        (fPolicy? NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1 : NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1)));
    IFW32FALSE_EXIT(::pRemovePotentiallyEmptyDirectory(buffScratchSpace));

    FN_EPILOG
}


bool IsCharacterNulOrInSet(WCHAR ch, PCWSTR set);

BOOL
pAnalyzeLogfileForUninstall(
    PCWSTR lpcwszLogFileName
    )
{
    FN_PROLOG_WIN32

    CFusionFile         File;
    CFileMapping        FileMapping;
    CMappedViewOfFile   MappedViewOfFile;
    PCWSTR              pCursor = NULL;
    ULONGLONG           ullFileSize = 0;
    ULONGLONG           ullFileCharacters = 0;
    ULONGLONG           ullCursorPos = 0;
    const static WCHAR  wchLineDividers[] = { L'\r', L'\n', 0xFEFF, 0 };
    ULONG               ullPairsEncountered = 0;
    CSmallStringBuffer  buffIdentity;
    CSmallStringBuffer  buffReference;

    IFW32FALSE_EXIT(File.Win32CreateFile(lpcwszLogFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING));
    IFW32FALSE_EXIT(File.Win32GetSize(ullFileSize));
    ASSERT(ullFileSize % sizeof(WCHAR) == 0);
    ullFileCharacters = ullFileSize / sizeof(WCHAR);
    IFW32FALSE_EXIT(FileMapping.Win32CreateFileMapping(File, PAGE_READONLY));
    IFW32FALSE_EXIT(MappedViewOfFile.Win32MapViewOfFile(FileMapping, FILE_MAP_READ));
    pCursor = reinterpret_cast<PCWSTR>(static_cast<const VOID*>(MappedViewOfFile));

#define SKIP_BREAKERS while ((ullCursorPos < ullFileCharacters) && IsCharacterNulOrInSet(pCursor[ullCursorPos], wchLineDividers)) ullCursorPos++;
#define FIND_NEXT_BREAKER while ((ullCursorPos < ullFileCharacters) && !IsCharacterNulOrInSet(pCursor[ullCursorPos], wchLineDividers)) ullCursorPos++;
#define ENSURE_NOT_EOF if (ullCursorPos >= ullFileCharacters) break;
    
    for ( ullCursorPos = 0; ullCursorPos < ullFileCharacters; ++ullCursorPos )
    {
        SKIP_BREAKERS
        ENSURE_NOT_EOF
        
        PCWSTR pcwszIdentityStart = pCursor + ullCursorPos;
        
        FIND_NEXT_BREAKER
        ENSURE_NOT_EOF

        PCWSTR pcwszIdentityEnd = pCursor + ullCursorPos;

        SKIP_BREAKERS
        ENSURE_NOT_EOF

        PCWSTR pcwszReferenceStart = pCursor + ullCursorPos;

        FIND_NEXT_BREAKER
        ENSURE_NOT_EOF

        PCWSTR pcwszReferenceEnd = pCursor + ullCursorPos;

        ullPairsEncountered++;

        IFW32FALSE_EXIT(buffIdentity.Win32Assign(
            pcwszIdentityStart,
            pcwszIdentityEnd - pcwszIdentityStart));
        IFW32FALSE_EXIT(buffReference.Win32Assign(
            pcwszReferenceStart,
            pcwszReferenceEnd - pcwszReferenceStart));

        SXS_UNINSTALLW Uninstall;
        ZeroMemory(&Uninstall, sizeof(Uninstall));
        Uninstall.cbSize = sizeof(Uninstall);
        Uninstall.dwFlags = SXS_UNINSTALL_FLAG_REFERENCE_VALID | SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED;
        Uninstall.lpAssemblyIdentity = buffIdentity;
        Uninstall.lpInstallReference = reinterpret_cast<PCSXS_INSTALL_REFERENCEW>(static_cast<PCWSTR>(buffReference));
        IFW32FALSE_EXIT(::SxsUninstallW(&Uninstall, NULL));
    }

    PARAMETER_CHECK(ullPairsEncountered != 0);

    FN_EPILOG
}

class CSxsUninstallWLocals
{
public:
    CSxsUninstallWLocals() { }
    ~CSxsUninstallWLocals() { }

    CSmallStringBuffer          buffAsmNameInRegistry;
    CAssemblyInstallReferenceInformation Ref;
};

BOOL
WINAPI
SxsUninstallW(
    IN  PCSXS_UNINSTALLW pcUnInstallData,
    OUT DWORD *pdwDisposition
    )
/*++

Parameters:

    pcUnInstallData - Contains uninstallation data about the assembly being
        removed from the system, including the calling application's reference
        to the assembly.

        cbSize      - Size, in bytes, of the structure pointed to by
                      pcUnInstallData

        dwFlags     - Indicates the state of the members of this reference,
                      showing which of the following fields are valid.
                      Allowed bitflags are:

                      SXS_UNINSTALL_FLAG_REFERENCE_VALID
                      SXS_UNINSTALL_FLAG_FORCE_DELETE

        lpAssemblyIdentity - Textual representation of the assembly's identity
                      as installed by the application.

        lpInstallReference - Pointer to a SXS_INSTALL_REFERENCEW structure
                      that contains the reference information for this
                      application.

    pdwDisposition  - Points to a DWORD that will return status about what was
                      done to the assembly; whether it was uninstalled or not,
                      and whether the reference given was removed.

Returns:

    TRUE if the assembly was able to be uninstalled, FALSE otherwise.  If the
    uninstall failed, lasterror is set to the probable cause.
    
--*/
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> AssemblyIdentity;
    CFusionRegKey               hkReferences;
    CFusionRegKey               hkAllInstallInfo;
    CFusionRegKey               hkAsmInstallInfo;

    CSmartPtr<CSxsUninstallWLocals> Locals;
    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));

    CSmallStringBuffer          &buffAsmNameInRegistry = Locals->buffAsmNameInRegistry;
    BOOL                        fDoRemoveActualBits = FALSE;

    if (pdwDisposition != NULL)
        *pdwDisposition = 0;

    //
    // The parameter must be non-null, and must have at least dwFlags and the 
    // assemblyidentity.  
    //
    PARAMETER_CHECK(pcUnInstallData != NULL);
    PARAMETER_CHECK(RTL_CONTAINS_FIELD(pcUnInstallData, pcUnInstallData->cbSize, dwFlags) &&    
        RTL_CONTAINS_FIELD(pcUnInstallData, pcUnInstallData->cbSize, lpAssemblyIdentity));

    //
    // Check flags
    //
    PARAMETER_CHECK((pcUnInstallData->dwFlags & 
        ~(SXS_UNINSTALL_FLAG_FORCE_DELETE | 
            SXS_UNINSTALL_FLAG_REFERENCE_VALID | 
            SXS_UNINSTALL_FLAG_USE_INSTALL_LOG | 
            SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED)) == 0);

    //
    // If you specify the uninstall log, then that's the only thing that can be set.  XOR
    // them together, so only one of the two will be set.
    //
    PARAMETER_CHECK(
        ((pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_USE_INSTALL_LOG) == 0) ||
        ((pcUnInstallData->dwFlags & (SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED|SXS_UNINSTALL_FLAG_REFERENCE_VALID|SXS_UNINSTALL_FLAG_FORCE_DELETE)) == 0));

    //
    // If the reference flag was set, then the member has to be present, and 
    // non-null as well.
    //
    PARAMETER_CHECK(((pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_REFERENCE_VALID) == 0) ||
        (RTL_CONTAINS_FIELD(pcUnInstallData, pcUnInstallData->cbSize, lpInstallReference) &&
         (pcUnInstallData->lpInstallReference != NULL)));

    //
    // If the log file is not present, the assembly identity can't be a zero-length string, and it can't be null - it's
    // required.
    //
    
    
    PARAMETER_CHECK((pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_USE_INSTALL_LOG) || ((pcUnInstallData->lpAssemblyIdentity != NULL) && (pcUnInstallData->lpAssemblyIdentity[0] != UNICODE_NULL)));

    //
    // If the install log flag was set, then the member needs to be set and non-null
    //
    PARAMETER_CHECK(((pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_USE_INSTALL_LOG) == 0) ||
        (RTL_CONTAINS_FIELD(pcUnInstallData, pcUnInstallData->cbSize, lpInstallLogFile) &&
         ((pcUnInstallData->lpInstallLogFile != NULL) && (pcUnInstallData->lpInstallLogFile[0] != UNICODE_NULL))));

    if ( pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_USE_INSTALL_LOG )
    {
        IFW32FALSE_EXIT(pAnalyzeLogfileForUninstall(pcUnInstallData->lpInstallLogFile));
    }
    else
    {
        //
        // And the reference scheme must not be SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL,
        // as you can't "uninstall" OS-installed assemblies!
        //
        if (pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_REFERENCE_VALID)
        {
            if (pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED)
            {
                PCWSTR pcwszEndOfString = NULL;
                GUID gTheGuid;

                PCWSTR pcwszReferenceString = reinterpret_cast<PCWSTR>(pcUnInstallData->lpInstallReference);

                //
                // Non-null, non-zero-length
                //
                PARAMETER_CHECK((pcwszReferenceString != NULL) && (pcwszReferenceString[0] != L'\0'));

                //
                // Parse the displayed guid.  If there's no _, then ensure that the guid
                // is not the os-installed guid.
                //
                pcwszEndOfString = wcschr(pcwszReferenceString, SXS_REFERENCE_CHUNK_SEPERATOR[0]);
                if ( pcwszEndOfString == NULL )
                {
                    pcwszEndOfString = pcwszReferenceString + ::wcslen(pcwszReferenceString);
                    IFW32FALSE_EXIT(
                        ::SxspParseGUID(
                            pcwszReferenceString,
                            pcwszEndOfString - pcwszReferenceString,
                            gTheGuid));
                    PARAMETER_CHECK(gTheGuid != SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL);
                }
                
            }
            else
            {
                PARAMETER_CHECK(pcUnInstallData->lpInstallReference->guidScheme != SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL);
            }                
        }

        //
        // Let's turn the identity back into a real identity object
        //
        IFW32FALSE_EXIT(
            ::SxspCreateAssemblyIdentityFromTextualString(
                pcUnInstallData->lpAssemblyIdentity,
                &AssemblyIdentity));

        IFW32FALSE_EXIT(
            ::SxspValidateIdentity(
                SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED,
                ASSEMBLY_IDENTITY_TYPE_REFERENCE,
                AssemblyIdentity));

        //
        // And go open the registry key that corresponds to it
        //
        IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(
            0, 
            KEY_ALL_ACCESS, 
            hkAllInstallInfo));
        IFW32FALSE_EXIT(::SxspGenerateAssemblyNameInRegistry(
            AssemblyIdentity, 
            buffAsmNameInRegistry));
        IFW32FALSE_EXIT(hkAllInstallInfo.OpenSubKey( 
            hkAsmInstallInfo, 
            buffAsmNameInRegistry,
            KEY_ALL_ACCESS,
            0));

        //
        // If the assembly didn't have registry data, then obviously nobody cares
        // about it at all.  Delete it with great vigor.
        //
        if (hkAsmInstallInfo == CFusionRegKey::GetInvalidValue())
        {
            fDoRemoveActualBits = TRUE;
        }
        else 
        {
            DWORD dwReferenceCount = 0;
            BOOL fTempFlag = FALSE;

            //
            // We're going to need the references key in just a second...
            //
            IFW32FALSE_EXIT(
                hkAsmInstallInfo.OpenOrCreateSubKey(
                    hkReferences,
                    WINSXS_INSTALLATION_REFERENCES_SUBKEY,
                    KEY_ALL_ACCESS,
                    0, NULL, NULL));

            //
            // If we were given an uninstall reference, then attempt to remove it.
            //
            if (pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_REFERENCE_VALID)
            {
                CSmartPtr<CAssemblyInstallReferenceInformation> AssemblyReference;
                BOOL fWasDeleted = FALSE;

                //
                // Opened the references key OK?
                //
                if (hkReferences != CFusionRegKey::GetInvalidValue())
                {
                    IFW32FALSE_EXIT(AssemblyReference.Win32Allocate(__FILE__, __LINE__));

                    //
                    // Did the user precompute the reference string?
                    //
                    if (pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED)
                        IFW32FALSE_EXIT(AssemblyReference->ForceReferenceData(reinterpret_cast<PCWSTR>(pcUnInstallData->lpInstallReference)));
                    else
                        IFW32FALSE_EXIT(AssemblyReference->Initialize(pcUnInstallData->lpInstallReference));

                    IFW32FALSE_EXIT(AssemblyReference->DeleteReferenceFrom(hkReferences, fWasDeleted));
                }

                if (fWasDeleted)
                {
                    //
                    // and delete the codebase
                    //
                    CFusionRegKey CodeBases;
                    CFusionRegKey ThisCodeBase;
                    DWORD         Win32Error = NO_ERROR;

                    IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS3(
                        hkAsmInstallInfo.OpenSubKey( 
                            CodeBases, 
                            CSMD_TOPLEVEL_CODEBASES,
                            KEY_ALL_ACCESS,
                            0),
                        LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                        Win32Error);

                    if (Win32Error == NO_ERROR)
                    {
                        IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS3(
                            CodeBases.OpenSubKey( 
                                ThisCodeBase, 
                                AssemblyReference->GetGeneratedIdentifier(),
                                KEY_ALL_ACCESS,
                                0),
                            LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                            Win32Error);
                    }
                    if (Win32Error == NO_ERROR)
                    {
                        IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS3(
                            ThisCodeBase.DestroyKeyTree(),
                            LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                            Win32Error);
                    }
                    if (Win32Error == NO_ERROR)
                    {
                        IFW32FALSE_ORIGINATE_AND_EXIT(ThisCodeBase.Win32Close());
                        IFW32FALSE_ORIGINATE_AND_EXIT_UNLESS3(
                            CodeBases.DeleteKey(AssemblyReference->GetGeneratedIdentifier()),
                            LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                            Win32Error);
                    }

                    //
                    // If the assembly reference was removed, tell our caller.
                    //
                    if (pdwDisposition != NULL)
                    {
                        *pdwDisposition |= SXS_UNINSTALL_DISPOSITION_REMOVED_REFERENCE;
                    }
                }
            }

            //
            // Now see if there are any references left at all.
            //
            IFREGFAILED_ORIGINATE_AND_EXIT_UNLESS2(
                ::RegQueryInfoKeyW(
                    hkReferences,
                    NULL, NULL, NULL, NULL, NULL, NULL,
                    &dwReferenceCount,
                    NULL, NULL, NULL, NULL),
                LIST_3(ERROR_FILE_NOT_FOUND, ERROR_PATH_NOT_FOUND, ERROR_KEY_DELETED),
                fTempFlag);

            //
            // If getting the key information succeeded and there were no more references,
            // then pow - make it go away.
            //
            if ((!fTempFlag) && (dwReferenceCount == 0))
                fDoRemoveActualBits = TRUE;

        }

        //
        // Now, if the "force delete" flag was set, set the "nuke this data anyhow"
        // flag.  MSI still gets to veto the uninstall, so make sure that's done last.
        //
        if ((!fDoRemoveActualBits) && (pcUnInstallData->dwFlags & SXS_UNINSTALL_FLAG_FORCE_DELETE))
            fDoRemoveActualBits = TRUE;

        //
        // One last chance - we're about to remove the assembly from the system.  Does Darwin
        // know about it?
        //
        if ( fDoRemoveActualBits )
        {
            IFW32FALSE_EXIT(
                ::SxspDoesMSIStillNeedAssembly(
                    pcUnInstallData->lpAssemblyIdentity,
                    fDoRemoveActualBits));

            fDoRemoveActualBits = !fDoRemoveActualBits;
        }

        if ( fDoRemoveActualBits && (hkReferences != CFusionRegKey::GetInvalidValue()))
        {
            //
            // One last check - is the assembly referenced by the OS?  They get absolute
            // trump over all the other checks.
            //
            CAssemblyInstallReferenceInformation &Ref = Locals->Ref;
            SXS_INSTALL_REFERENCEW Reference;

            ZeroMemory(&Reference, sizeof(Reference));
            Reference.cbSize = sizeof(Reference);
            Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL;

            IFW32FALSE_EXIT(Ref.Initialize(&Reference));
            IFW32FALSE_EXIT(Ref.IsReferencePresentIn(hkReferences, fDoRemoveActualBits));

            //
            // If it was present, then don't remove!
            //
            fDoRemoveActualBits = !fDoRemoveActualBits;
            
        }

        //
        // Now, if we're still supposed to delete the assembly, go yank it out of the
        // registry and the filesystem; pCleanupAssemblyData knows how to do that.
        //
        if (fDoRemoveActualBits)
        {
            BOOL fWasRemovedProperly;
            
            IFW32FALSE_EXIT(::pCleanUpAssemblyData(AssemblyIdentity, fWasRemovedProperly));

            if (fWasRemovedProperly && (pdwDisposition != NULL))
                *pdwDisposition |= SXS_UNINSTALL_DISPOSITION_REMOVED_ASSEMBLY;
        }
    }
    
    fSuccess = TRUE;
Exit:
#if DBG
    if (!fSuccess && pcUnInstallData != NULL && pcUnInstallData->lpAssemblyIdentity != NULL)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s(%ls) failed\n",
            __FUNCTION__,
            pcUnInstallData->lpAssemblyIdentity
            );
    }
#endif
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxssfc_repairshortnames.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxssfc_repairshortnames.cpp

Abstract:

    after textmode setup extracts asms*.cab and write hivesxs.inf,
    write the correct shortnames into the registry

Author:

    Jay Krell (Jaykrell) June 2002

Revision History:

--*/

#include "stdinc.h"
#include "recover.h"
#include "cassemblyrecoveryinfo.h"
#include "sxssfcscan.h"

BOOL
SxspSetupGetSourceInfo(
    HINF InfHandle,          // handle to the INF file
    UINT SourceId,           // ID of the source media
    UINT InfoDesired,        // information to retrieve
    CBaseStringBuffer &buff,
    LPDWORD RequiredSize     // optional, buffer size needed
    )
{
    FN_PROLOG_WIN32
    CStringBufferAccessor acc;
    DWORD RequiredSize2 = 0;
    BOOL fTooSmall = FALSE;

    if (RequiredSize == NULL)
    {
        RequiredSize = &RequiredSize2;
    }

    acc.Attach(&buff);

    IFW32FALSE_EXIT_UNLESS2(
        ::SetupGetSourceInfoW(
            InfHandle,
            SourceId,
            InfoDesired,
            acc,
            acc.GetBufferCchAsDWORD(),
            RequiredSize
            ),
        LIST_1(ERROR_INSUFFICIENT_BUFFER),
        fTooSmall);

    if (fTooSmall)
    {
        acc.Detach();

        IFW32FALSE_EXIT(buff.Win32ResizeBuffer(*RequiredSize + 1, eDoNotPreserveBufferContents));

        acc.Attach(&buff);

        IFW32FALSE_EXIT(
            ::SetupGetSourceInfoW(
                InfHandle,
                SourceId,
                InfoDesired,
                acc,
                acc.GetBufferCchAsDWORD(),
                RequiredSize
                ));
    }

    FN_EPILOG
}

BOOL
SxspGetWindowsSetupPrompt(
    CBaseStringBuffer &rbuffWinsxsRoot
    )
//
// This code is based closely on code in base\ntsetup\syssetup\copy.c
// Legacy wfp is a little different, it opens layout.inf, but the results
// should be the same.
//
{
    FN_PROLOG_WIN32

    CFusionSetupInfFile InfFile;
    CStringBuffer       InfPath;
    const static UNICODE_STRING inf = RTL_CONSTANT_STRING(L"inf");
    const static UNICODE_STRING filename_inf = RTL_CONSTANT_STRING(L"layout.inf");
    UINT SourceId = 0;
    const PCWSTR SystemRoot = USER_SHARED_DATA->NtSystemRoot;

    IFW32FALSE_EXIT(InfPath.Win32Assign(SystemRoot, ::wcslen(SystemRoot)));
    IFW32FALSE_EXIT(InfPath.Win32AppendPathElement(&inf));
    IFW32FALSE_EXIT(InfPath.Win32AppendPathElement(&filename_inf));
    IFW32FALSE_EXIT(InfFile.Win32SetupOpenInfFileW(InfPath, NULL, INF_STYLE_WIN4, NULL));
    IFW32FALSE_EXIT(::SetupGetSourceFileLocationW(InfFile, NULL, L"shell32.dll", &SourceId, NULL, 0, NULL));
    IFW32FALSE_EXIT(::SxspSetupGetSourceInfo(InfFile, SourceId, SRCINFO_DESCRIPTION, rbuffWinsxsRoot, NULL));

    FN_EPILOG
}

BOOL
SxspModifyRegistryData(
    DWORD Flags
    )
{
    //
    // In postbuild we run sxsofflineinstall.
    // This includes creating hivesxs.inf to populate the registry
    // with data needed for windows file protection.
    //
    // The data includes short names, but we don't know the short names
    // until textmode setup. The code in textmode setup is fairly generic
    // and just expands .cabs.
    //
    // We do not need the short names to be correct until we expect
    // bogus file changes against short file names to induce recovery
    // of assemblies. It is reasonable to assume that these won't happen
    // until setup is done and the system is running.
    //
    // Therefore it is sufficient to fixup the shortnames after textmode setup,
    // such as in a RunOnce entry.
    //

/*
Here is an example of what we are fixing up.
[AddReg]
HKLM,"\Software\Microsoft\Windows\CurrentVersion\SideBySide\Installations
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5","Identity",0x00001000,"Microsoft.Windows.Common-Controls,processorArchitecture="IA64",publicKeyToken="6595b64144ccf1df",type="win32",version="5.82.0.0""
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5","Catalog",0x00011001,0x00000001
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5","ManifestSHA1Hash",0x00001001,3b,26,4a,90,08,0f,6a,dd,b6,00,55,5b,a5,a4,9e,21,ad,e3,90,84
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5","ShortName",0x00001000,"IA64_M~2.0_X"
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5","ShortCatalogName",0x00001000,"IA64_M~4.CAT"
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5","ShortManifestName",0x00001000,"IA64_M~4.MAN"
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5","PublicKeyToken",0x00001001,65,95,b6,41,44,cc,f1,df
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5","Codebase",0x00001000,"x-ms-windows-source:W_fusi_bin.IA64chk/asms/58200/Msft/Windows/Common/Controls/Controls.man"
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5\Codebases\OS","Prompt",0x00001000,"(textmode setup placeholder)"
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5\Codebases\OS","URL",0x00001000,"x-ms-windows-source:W_fusi_bin.IA64chk/asms/58200/Msft/Windows/Common/Controls/Controls.man"
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5\Files\0","",0x00001000,"comctl32.dll"
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5\Files\0","SHA1",0x00001001,76,c3,6e,4c,c4,10,14,7f,38,c8,bc,cd,4b,4f,b2,90,d8,0a,7c,d7
HKLM,"\...\IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5\References","OS",0x00001000,"Foom"
IA64_Microsoft.Windows.Common-Controls_6595b64144ccf1df_5.82.0.0_x-ww_B9C4A0A5
*/
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CFusionRegKey regkeyInstallations;
    CFusionRegKey regkeyInstallation;
    DWORD dwRegSubKeyIndex = 0;
    BOOL  fNoMoreItems = FALSE;
    FILETIME LastWriteFileTimeIgnored = { 0 };
    CTinyStringBuffer buffInstallationName;
    CTinyStringBuffer buffWinsxsRoot;
    CTinyStringBuffer *buffLongFullPath = NULL;
    CTinyStringBuffer buffShortFullPath;
    CTinyStringBuffer buffShortPathLastElement;
    CTinyStringBuffer buffTextualIdentity;
    CTinyStringBuffer buffEmpty;
    CTinyStringBuffer buffWindowsSetupPrompt;
    CTinyStringBuffer buffCurrentPromptInRegistry;
    CTinyStringBuffer buffFullPathToManifest;
    CTinyStringBuffer buffFullPathToCatalog;
    CTinyStringBuffer buffFullPathToPayloadDirectory;
    SIZE_T i = 0;
    const bool fRepairAll = ((Flags & SXSP_MODIFY_REGISTRY_DATA_FLAG_REPAIR_ALL) != 0); 
    const bool fRepairShort = fRepairAll || ((Flags & SXSP_MODIFY_REGISTRY_DATA_FLAG_REPAIR_SHORT_NAMES) != 0);
    const bool fDeleteShort = ((Flags & SXSP_MODIFY_REGISTRY_DATA_FLAG_DELETE_SHORT_NAMES) != 0);
    const bool fRepairPrompt = fRepairAll || ((Flags & SXSP_MODIFY_REGISTRY_DATA_FLAG_REPAIR_OFFLINE_INSTALL_REFRESH_PROMPTS) != 0);
    const bool fValidate = ((Flags & SXSP_MODIFY_REGISTRY_DATA_VALIDATE) != 0);
#if DBG
    bool fDbgPrintBecauseHashValidationFailed = false;
#endif

    PARAMETER_CHECK(Flags != 0);
    PARAMETER_CHECK((Flags & ~SXSP_MODIFY_REGISTRY_DATA_FLAG_VALID_FLAGS) == 0);

    IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(buffWinsxsRoot));
    IFW32FALSE_EXIT(::SxspOpenAssemblyInstallationKey(0, KEY_READ | KEY_SET_VALUE | FUSIONP_KEY_WOW64_64KEY, regkeyInstallations));

    if (fRepairPrompt)
    {
        IFW32FALSE_EXIT(::SxspGetWindowsSetupPrompt(buffWindowsSetupPrompt));
    }

    for ((dwRegSubKeyIndex = 0), (fNoMoreItems = FALSE); !fNoMoreItems ; ++dwRegSubKeyIndex)
    {
        bool fNotFound = false;
        CSmartAssemblyIdentity AssemblyIdentity;
        PROBING_ATTRIBUTE_CACHE AttributeCache = { 0 };
        CFusionRegKey codebase_os;

        IFW32FALSE_EXIT(
            regkeyInstallations.EnumKey(
                dwRegSubKeyIndex,
                buffInstallationName,
                &LastWriteFileTimeIgnored,
                &fNoMoreItems));
        if (fNoMoreItems)
        {
            break;
        }

        IFW32FALSE_EXIT(
            regkeyInstallations.OpenSubKey(
                regkeyInstallation,
                buffInstallationName,
                KEY_READ | KEY_SET_VALUE | ((fRepairPrompt || fValidate) ? KEY_ENUMERATE_SUB_KEYS : 0)
                ));
        IFW32FALSE_EXIT(
            regkeyInstallation.GetValue(
                CSMD_TOPLEVEL_IDENTITY,
                buffTextualIdentity
                ));

        IFW32FALSE_EXIT(::SxspCreateAssemblyIdentityFromTextualString(buffTextualIdentity, &AssemblyIdentity));

        typedef struct _SXSP_GENERATE_PATH_FUNCTION_REGISTRY_VALUE_NAME
        {
            BOOL (*GeneratePathFunction)(
                IN const CBaseStringBuffer &AssemblyRootDirectory,
                IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
                IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
                IN OUT CBaseStringBuffer &PathBuffer
            );
            PCWSTR RegistryValueName;
        } SXSP_GENERATE_PATH_FUNCTION_REGISTRY_VALUE_NAME, *PSXSP_GENERATE_PATH_FUNCTION_REGISTRY_VALUE_NAME;
        typedef const SXSP_GENERATE_PATH_FUNCTION_REGISTRY_VALUE_NAME *PCSXSP_GENERATE_PATH_FUNCTION_REGISTRY_VALUE_NAME;

        const static SXSP_GENERATE_PATH_FUNCTION_REGISTRY_VALUE_NAME s_rgFunctionRegistryValueName[] =
        {
            //
            // Note that policies are not currently wfp protected,
            // but it's easy and obvious to put reasonable data
            // in the registry for them.
            //
            { &::SxspGenerateSxsPath_FullPathToManifestOrPolicyFile, CSMD_TOPLEVEL_SHORTMANIFEST },
            { &::SxspGenerateSxsPath_FullPathToCatalogFile, CSMD_TOPLEVEL_SHORTCATALOG },
            { &::SxspGenerateSxsPath_FullPathToPayloadOrPolicyDirectory, CSMD_TOPLEVEL_SHORTNAME }
        };
        CBaseStringBuffer * const rgpbuffFullPaths[] =
        {
            &buffFullPathToManifest,
            &buffFullPathToCatalog,
            &buffFullPathToPayloadDirectory
        };

        //
        // first generate all three fullpaths
        //
        for (i = 0 ; i != NUMBER_OF(s_rgFunctionRegistryValueName)  ; ++i)
        {
            const PCSXSP_GENERATE_PATH_FUNCTION_REGISTRY_VALUE_NAME p = &s_rgFunctionRegistryValueName[i];
            CBaseStringBuffer * const pbuffLongFullPath = rgpbuffFullPaths[i];

            IFW32FALSE_EXIT((*p->GeneratePathFunction)(
                buffWinsxsRoot,
                AssemblyIdentity,
                &AttributeCache,
                *pbuffLongFullPath));
            IFW32FALSE_EXIT(pbuffLongFullPath->Win32RemoveTrailingPathSeparators());
        }

        //
        // optionally repair short names
        //
        if (fRepairShort)
        {
            for (i = 0 ; i != NUMBER_OF(s_rgFunctionRegistryValueName)  ; ++i)
            {
                const PCSXSP_GENERATE_PATH_FUNCTION_REGISTRY_VALUE_NAME p = &s_rgFunctionRegistryValueName[i];
                CBaseStringBuffer * const pbuffLongFullPath = rgpbuffFullPaths[i];
                {
                    DWORD dwWin32Error = NO_ERROR;

                    IFW32FALSE_EXIT(
                        ::SxspGetShortPathName(
                                *pbuffLongFullPath,
                                buffShortFullPath,
                                dwWin32Error,
                                static_cast<SIZE_T>(4),
                                    ERROR_PATH_NOT_FOUND,
                                    ERROR_FILE_NOT_FOUND,
                                    ERROR_BAD_NET_NAME,
                                    ERROR_BAD_NETPATH));
                    if (dwWin32Error == NO_ERROR)
                    {
                        IFW32FALSE_EXIT(buffShortFullPath.Win32GetLastPathElement(buffShortPathLastElement));
                        IFW32FALSE_EXIT(regkeyInstallation.SetValue(p->RegistryValueName, buffShortPathLastElement));
                    }
                }
            }
        }

        //
        // optionally delete short names
        //
        if (fDeleteShort)
        {
            for (i = 0 ; i != NUMBER_OF(s_rgFunctionRegistryValueName)  ; ++i)
            {
                IFW32FALSE_EXIT(regkeyInstallation.DeleteValue(s_rgFunctionRegistryValueName[i].RegistryValueName));
            }
        }

        //
        // validate hashes and repair prompts
        // BE SURE TO validate hashes first, as we filter what assemblies
        //   to repair based on the placeholder prompt
        //
        IFW32FALSE_EXIT_UNLESS2(
            regkeyInstallation.OpenSubKey(
                codebase_os,
                CSMD_TOPLEVEL_CODEBASES L"\\" SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL_STRING,
                KEY_READ | KEY_SET_VALUE),
                LIST_2(ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND),
                fNotFound);
        //
        // OpenSubKey actually eats some errors, so you can't trust
        // fNotFound or the BOOL returned.
        //
        if (!fNotFound && codebase_os.IsValid())
        {
            fNotFound = false;
            IFW32FALSE_EXIT_UNLESS2(
                codebase_os.GetValue(
                    CSMD_CODEBASES_PROMPTSTRING,
                    buffCurrentPromptInRegistry),
                    LIST_2(ERROR_PATH_NOT_FOUND, ERROR_FILE_NOT_FOUND),
                    fNotFound);
            if (!fNotFound)
            {
                if (::FusionpEqualStringsI(
                    buffCurrentPromptInRegistry,
                    SXSP_OFFLINE_INSTALL_REFRESH_PROMPT_PLACEHOLDER,
                    NUMBER_OF(SXSP_OFFLINE_INSTALL_REFRESH_PROMPT_PLACEHOLDER) - 1))
                {

                    if (fValidate)
                    {
                        CAssemblyRecoveryInfo AssemblyRecoveryInfo;
                        bool fNoAssembly = false;
                        DWORD dwResult = 0;

                        IFW32FALSE_EXIT(AssemblyRecoveryInfo.Initialize());
                        IFW32FALSE_EXIT(AssemblyRecoveryInfo.AssociateWithAssembly(buffInstallationName, fNoAssembly));
                        IFW32FALSE_EXIT(::SxspValidateEntireAssembly(
                            SXS_VALIDATE_ASM_FLAG_CHECK_EVERYTHING,
                            AssemblyRecoveryInfo,
                            dwResult,
                            AssemblyIdentity
                            ));
                        if (dwResult != SXS_VALIDATE_ASM_FLAG_VALID_PERFECT)
                        {
                            ::FusionpDbgPrintEx(
                                FUSION_DBG_LEVEL_SETUPLOG,
                                "The assembly %ls contains file hash errors.\n",
                                static_cast<PCWSTR>(buffTextualIdentity));
                            ::FusionpDbgPrintEx(
                                FUSION_DBG_LEVEL_ERROR,
                                "SXS.DLL %s: The assembly %ls contains file hash errors.\n",
                                __FUNCTION__,
                                static_cast<PCWSTR>(buffTextualIdentity));
                            ::FusionpSetLastWin32Error(ERROR_SXS_FILE_HASH_MISMATCH);
#if DBG
                            fDbgPrintBecauseHashValidationFailed = true;
#endif
                            goto Exit;
                        }
                    }
                    if (fRepairPrompt)
                    {
                        IFW32FALSE_EXIT(
                            codebase_os.SetValue(
                                CSMD_CODEBASES_PROMPTSTRING,
                                buffWindowsSetupPrompt));
                    }
                }
            }
        }
    }

    fSuccess = TRUE;
Exit:
    if ((!fSuccess && ::FusionpDbgWouldPrintAtFilterLevel(FUSION_DBG_LEVEL_ERROR))
#if DBG
        || fDbgPrintBecauseHashValidationFailed
#endif
        )
    {
        //
        // multiple dbgprints due to 511 limit
        // use tick count to link together seperate prints
        //
        CSxsPreserveLastError ple;
        DWORD TickCount = ::GetTickCount();

        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s 0x%lx error 0x%lx\n", __FUNCTION__, TickCount, ple.LastError());
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s 0x%lx dwRegSubKeyIndex 0x%lx\n", __FUNCTION__, TickCount, dwRegSubKeyIndex);
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s 0x%lx i 0x%Ix\n", __FUNCTION__, TickCount, i);
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s 0x%lx buffInstallationName %ls\n", __FUNCTION__, TickCount, static_cast<PCWSTR>(buffInstallationName));
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s 0x%lx buffTextualIdentity %ls\n", __FUNCTION__, TickCount, static_cast<PCWSTR>(buffTextualIdentity));
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s 0x%lx buffFullPathToManifest %ls\n", __FUNCTION__, TickCount, static_cast<PCWSTR>(buffFullPathToManifest));
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s 0x%lx buffFullPathToCatalog %ls\n", __FUNCTION__, TickCount, static_cast<PCWSTR>(buffFullPathToCatalog));
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s 0x%lx buffFullPathToPayloadDirectory %ls\n", __FUNCTION__, TickCount, static_cast<PCWSTR>(buffFullPathToPayloadDirectory));
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s 0x%lx buffShortFullPath %ls\n", __FUNCTION__, TickCount, static_cast<PCWSTR>(buffShortFullPath));
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s 0x%lx buffShortPathLastElement %ls\n", __FUNCTION__, TickCount, static_cast<PCWSTR>(buffShortPathLastElement));

        ple.Restore();
    }

    return fSuccess;
}

BOOL
SxspDeleteShortNamesInRegistry(
    VOID
    )
{
    return ::SxspModifyRegistryData(SXSP_MODIFY_REGISTRY_DATA_FLAG_DELETE_SHORT_NAMES);
}

STDAPI
DllInstall(
	BOOL fInstall,
	PCWSTR pszCmdLine
    )
{
    FN_PROLOG_HR

    //
    // Just ignore uninstall requests.
    //
    if (!fInstall)
    {
        FN_SUCCESSFUL_EXIT();
    }

    //
    // It doesn't look like guimode setup ever passes in
    // anything for pszCmdLine, so we don't look at it.
    //
    IFW32FALSE_EXIT(::SxspModifyRegistryData(SXSP_MODIFY_REGISTRY_DATA_FLAG_REPAIR_ALL | SXSP_MODIFY_REGISTRY_DATA_VALIDATE));

    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsxmltree.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsxmltree.h

Abstract:
    Create a XML DOM tree during push-mode parsing

Author:

    Xiaoyu Wu (xiaoyuw) Aug 2000

Revision History:

--*/
#if !defined(_FUSION_SXS_XMLTREE_H_INCLUDED_)
#define _FUSION_SXS_XMLTREE_H_INCLUDED_

#pragma once

#include "xmlparser.h"
#include "fusionheap.h"

// allocatememory for this element, and all its attributes once
struct _SXS_XMLATTRIBUTE{
    PWSTR m_wszName;
    ULONG m_ulPrefixLen;
    PWSTR m_wszValue;
};

typedef struct _SXS_XMLATTRIBUTE SXS_XMLATTRIBUTE;

class SXS_XMLTreeNode{
public:
    friend VOID PrintTreeFromRoot(SXS_XMLTreeNode * Root);
    friend class SXS_XMLDOMTree;
    SXS_XMLTreeNode() :
        m_AttributeList(NULL),
        m_cAttributes(0),
        m_pwszStr(NULL),
        m_ulPrefixLen(0),
        m_pSiblingNode(NULL),
        m_pParentNode(NULL),
        m_pFirstChild(NULL),
        m_pMemoryPool(NULL) { }

    VOID DeleteSelf() { FUSION_DELETE_SINGLETON(this); }
    ~SXS_XMLTreeNode() {
        CSxsPreserveLastError ple;
        if (m_pMemoryPool != NULL)
        {
            FUSION_DELETE_ARRAY(m_pMemoryPool);
            m_pMemoryPool = NULL;
        }

        ple.Restore();
    }

    HRESULT CreateTreeNode(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo);
    VOID PrintSelf();

private:
    HRESULT ComputeBlockSize(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo, DWORD * dwBlockSizeInBytes);

    // for each node, allocate memory once : compute the total spaces need for prefix, localname, and value,
    ULONG m_ulPrefixLen;
    PWSTR m_pwszStr; // Can be a name for ELEMENT, a value for a PCDATA
    SXS_XMLATTRIBUTE *m_AttributeList;
    USHORT            m_cAttributes;
    SXS_XMLTreeNode  *m_pSiblingNode;
    SXS_XMLTreeNode  *m_pParentNode;
    SXS_XMLTreeNode  *m_pFirstChild;
    BYTE             *m_pMemoryPool;  // memory for attribs array, name-value pairs and name-value for the node
};

class SXS_XMLDOMTree{
public:
    HRESULT AddNode(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo); // CreateNode calls this func to add node into the Tree,
    VOID ReturnToParent();      // EndChildren calls this func if "fEmpty=FALSE"
    VOID SetChildCreation();    // BeginChildren calls this func
    /*
    VOID TurnOffFirstChildFlag();
    */

    SXS_XMLDOMTree():
        m_fBeginChildCreation(FALSE),
        m_Root(NULL),
        m_pCurrentNode(NULL)
        { }

    VOID DeleteTreeBranch(SXS_XMLTreeNode * pNode);

    ~SXS_XMLDOMTree(){
        CSxsPreserveLastError ple;
        this->DeleteTreeBranch(m_Root); // do not delete its siblings
        ple.Restore();
    }
    VOID PrintTreeFromRoot(SXS_XMLTreeNode * Root);

    SXS_XMLTreeNode * GetRoot() {
        return m_Root;
    }


private :
    BOOL m_fBeginChildCreation; // everytime, when BeginChild is called, it is set, once it is checked, set it to be FALSE
    SXS_XMLTreeNode * m_Root;
    SXS_XMLTreeNode * m_pCurrentNode;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\drain\drain.cpp ===
void fDrain() { } // just here to have something to compile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsmain\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

SOURCES_USED=$(SOURCES_USED) ..\sources.inc

TARGETTYPE=LIBRARY
TARGETPATH=$(FUSION_LIB_DEST)
TARGETNAME=$(FUSION_BUILD_TYPE_PREFIX)sxsmain

INCLUDES= \
 ..; \
 $(FUSION_PATH)\sxs; \
 $(FUSION_INC_PATH); \
 $(FUSION_PATH)\xmlparser; \
 $(FUSION_PATH)\id; \
 $(FUSION_PATH)\inc; \
 $(FUSION_PATH)\eventlog\$(FUSION_BUILD_LEAF_DIRECTORY)\$(O); \
 $(FUSION_PATH)\idl\$(O); \
 $(INCLUDES); \
 $(COM_INC_PATH); \
 $(ADMIN_INC_PATH)

SOURCES=\
 ..\sxsmain.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\sxsxmltree.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsxmltree.cpp

Abstract:
    Create a XML DOM tree during push-mode parsing

Author:

    Xiaoyu Wu (xiaoyuw) Aug 2000

Revision History:

--*/
#include "stdinc.h"
#include "ole2.h"
#include "sxsxmltree.h"
#include "fusiontrace.h"
#include "fusionheap.h"
#include "simplefp.h"

//////////////////////////////////////////////////////////////////////////////////////
//
// SXS_XMLDOMTree
//
//////////////////////////////////////////////////////////////////////////////////////
VOID SXS_XMLDOMTree::DeleteTreeBranch(SXS_XMLTreeNode * pNode)
{
//    SXS_XMLTreeNode * pParent = NULL;
    SXS_XMLTreeNode * pChild = NULL;
    SXS_XMLTreeNode * pNext = NULL;

    if (pNode == NULL)
        return;

    pChild = pNode->m_pFirstChild;
    while(pChild){
        pNext = pChild->m_pSiblingNode;
        this->DeleteTreeBranch(pChild);
        pChild = pNext;
    }
    pNode->DeleteSelf();
}

//
// CreateNode calls this func to add node into the Tree,
//
HRESULT SXS_XMLDOMTree::AddNode(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo)
{
    HRESULT hr = NOERROR;
    FN_TRACE_HR(hr);
    SXS_XMLTreeNode * pNewTreeNode= NULL ;

    if ((apNodeInfo == NULL) || (cNumRecs <= 0)){
        hr = E_INVALIDARG;
        goto Exit;
    }
    if (!((apNodeInfo[0]->dwType == XML_ELEMENT) ||(apNodeInfo[0]->dwType == XML_PCDATA))){// ignore nodes other than ELEMENT and PCDATA
        hr = NOERROR;
        goto Exit;
    }
    IFALLOCFAILED_EXIT(pNewTreeNode = new SXS_XMLTreeNode);

    IFCOMFAILED_EXIT(pNewTreeNode->CreateTreeNode(cNumRecs, apNodeInfo));

    if (m_fBeginChildCreation) {
        m_pCurrentNode->m_pFirstChild = pNewTreeNode;
        pNewTreeNode->m_pParentNode = m_pCurrentNode;
        m_pCurrentNode = pNewTreeNode;
        m_fBeginChildCreation = FALSE;
    }
    else{
        if (m_pCurrentNode){
            m_pCurrentNode->m_pSiblingNode = pNewTreeNode;
            pNewTreeNode->m_pParentNode = m_pCurrentNode->m_pParentNode;
        }
        m_pCurrentNode = pNewTreeNode;
    }
    if (m_Root == NULL) // root has not been setup
        m_Root = m_pCurrentNode;

    pNewTreeNode = NULL;
    hr = NOERROR;

Exit:
    if (pNewTreeNode){
        pNewTreeNode->DeleteSelf();
        pNewTreeNode = NULL;
    }

    return hr;
}

//
// EndChildren is called with "fEmpty=FALSE", go to parent node
//
VOID SXS_XMLDOMTree::ReturnToParent()
{
    if (m_pCurrentNode)
        m_pCurrentNode = m_pCurrentNode->m_pParentNode;
    return;
}

// BeginChildren calls this func
VOID SXS_XMLDOMTree::SetChildCreation()
{
    m_fBeginChildCreation = TRUE;
}
/*
VOID SXS_XMLDOMTree::TurnOffFirstChildFlag()
{
    m_fBeginChildCreation = FALSE;
}
*/

//////////////////////////////////////////////////////////////////////////////////////
//
// SXS_XMLTreeNode
//
//////////////////////////////////////////////////////////////////////////////////////
HRESULT SXS_XMLTreeNode::ComputeBlockSize(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo, ULONG * pulBlockSizeInBytes)
{
    HRESULT hr = NOERROR;
    ULONG ulBlockSizeInBytes = 0;
    USHORT i;
    USHORT cAttributes;

    FN_TRACE_HR(hr);
    if (pulBlockSizeInBytes)
        *pulBlockSizeInBytes = 0 ;
    else {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if ((apNodeInfo == NULL) || (cNumRecs <= 0)){
        hr = E_INVALIDARG;
        goto Exit;
    }
    ulBlockSizeInBytes = 0;

    for ( i = 0; i< cNumRecs; i ++ ) {
        ulBlockSizeInBytes += apNodeInfo[i]->ulLen * sizeof(WCHAR);
        ulBlockSizeInBytes +=  sizeof(WCHAR); //trailing '\0'
    }

    // if attributes present, add size of attribute array
    cAttributes = (cNumRecs - 1) >> 1 ; // name:value pair
    if (cAttributes > 0)
        ulBlockSizeInBytes += cAttributes * sizeof(SXS_XMLATTRIBUTE);

    * pulBlockSizeInBytes = ulBlockSizeInBytes;
    hr = NOERROR;

Exit:
    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////
HRESULT SXS_XMLTreeNode::CreateTreeNode(USHORT cNumRecs, XML_NODE_INFO** apNodeInfo)
{
    HRESULT hr = NOERROR;
    DWORD dwBlockSizeInBytes;
    PBYTE Cursor = NULL;
    USHORT i;

    FN_TRACE_HR(hr);

    PARAMETER_CHECK((apNodeInfo != NULL) || (cNumRecs == 0));

    IFCOMFAILED_EXIT(this->ComputeBlockSize(cNumRecs, apNodeInfo, &dwBlockSizeInBytes));
    IFALLOCFAILED_EXIT(m_pMemoryPool = FUSION_NEW_ARRAY(BYTE, dwBlockSizeInBytes));
    m_AttributeList = (SXS_XMLATTRIBUTE *)m_pMemoryPool;
    m_cAttributes = (cNumRecs - 1) >> 1;
    Cursor = m_pMemoryPool + m_cAttributes*(sizeof(SXS_XMLATTRIBUTE));

    // set Name(Element) or Value(PCData)
    m_pwszStr = (PWSTR)Cursor;
    wcsncpy((WCHAR*)Cursor, apNodeInfo[0]->pwcText, apNodeInfo[0]->ulLen); //ulLen is # of WCHAR or BYTE?
    Cursor += apNodeInfo[0]->ulLen * sizeof(WCHAR);
    *(WCHAR *)Cursor = L'\0';
    Cursor += sizeof(WCHAR); // '\0'

    for ( i=0 ;i<m_cAttributes ;i++) {
        // copy name
        m_AttributeList[i].m_wszName = (PWSTR)Cursor;
        wcsncpy((WCHAR*)Cursor, apNodeInfo[1+2*i]->pwcText, apNodeInfo[1+2*i]->ulLen); //ulLen is # of WCHAR or BYTE?
        Cursor += apNodeInfo[1+2*i]->ulLen * sizeof(WCHAR);
        *(WCHAR *)Cursor = L'\0';
        Cursor += sizeof(WCHAR); // '\0'

        //copy value
        m_AttributeList[i].m_wszValue = (PWSTR)Cursor;
        wcsncpy((PWSTR)Cursor, apNodeInfo[1 + 2*i + 1]->pwcText, apNodeInfo[1 + 2*i + 1]->ulLen); //ulLen is # of WCHAR or BYTE?
        Cursor += apNodeInfo[1 + 2*i + 1]->ulLen * sizeof(WCHAR);
        *(WCHAR *)Cursor = L'\0';
        Cursor += sizeof(WCHAR); // '\0'

        m_AttributeList[i].m_ulPrefixLen = apNodeInfo[1+2*i]->ulNsPrefixLen;
    }


Exit:
    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////

VOID SXS_XMLTreeNode::PrintSelf()
{
    FusionpDbgPrint("CreateNode\n");
    FusionpDbgPrint("NodeName = %ls\n", m_pwszStr);
    if ( m_cAttributes > 0)
    {
        FusionpDbgPrint("Attributes :\n");
        for ( USHORT i = 0; i < m_cAttributes; i++)
        {
            FusionpDbgPrint("\t%ls = %ls\n", m_AttributeList[i].m_wszName, m_AttributeList[i].m_wszValue);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\util.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include <windows.h>
#include "fusionstring.h"
#include "sxsp.h"
#include <stdio.h>
#include "fusionhandle.h"
#include "sxspath.h"
#include "sxsapi.h"
#include "sxsid.h"
#include "sxsidp.h"
#include "strongname.h"
#include "fusiontrace.h"
#include "cassemblyrecoveryinfo.h"
#include "recover.h"
#include "sxsinstall.h"
#include "msi.h"

// diff shrinkers to be propated and removed..
#define IsHexDigit      SxspIsHexDigit
#define HexDigitToValue SxspHexDigitToValue

#define ASSEMBLY_NAME_VALID_SPECIAL_CHARACTERS  L".-"
#define ASSEMBLY_NAME_INVALID_CHARACTERS        L"_\/:?*"
#define ASSEMBLY_NAME_VALID_SEPARATORS          L"."
#define ASSEMBLY_NAME_TRIM_INDICATOR            L".."
#define ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH     2
#define ASSEMBLY_NAME_PRIM_MAX_LENGTH           64
#define ASSEMBLY_STRONG_NAME_LENGTH             16

#define ULONG_STRING_FORMAT                     L"%08lx"
#define ULONG_STRING_LENGTH                     8


#define MSI_PROVIDEASSEMBLY_NAME        ("MsiProvideAssemblyW")
#define MSI_DLL_NAME_W                  (L"msi.dll")
#ifndef INSTALLMODE_NODETECTION_ANY
#define INSTALLMODE_NODETECTION_ANY (INSTALLMODE)-4
#endif


// Honest, we exist - Including all of sxsprotect.h is too much in this case.
BOOL SxspIsSfcIgnoredStoreSubdir(PCWSTR pwszDir);

// deliberately no surrounding parens or trailing comma
#define STRING_AND_LENGTH(x) (x), (NUMBER_OF(x) - 1)

/*-----------------------------------------------------------------------------
this makes the temp install be %windir%\WinSxs\InstallTemp\uid
instead of %windir%\WinSxs\uid
-----------------------------------------------------------------------------*/
#define SXSP_SEMIREADABLE_INSTALL_TEMP 1

const static HKEY  hKeyRunOnceRoot = HKEY_LOCAL_MACHINE;
const static WCHAR rgchRunOnceSubKey[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce";
const static WCHAR rgchRunOnceValueNameBase[] = L"WinSideBySideSetupCleanup ";

/*-----------------------------------------------------------------------------
append the directory name to this and put it in RunOnce in the registry
to cleanup crashed installs upon login
-----------------------------------------------------------------------------*/
const static WCHAR rgchRunOnePrefix[]  = L"rundll32 sxs.dll,SxspRunDllDeleteDirectory ";

#define SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY  (0x00000001)
#define SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY         (0x00000002)
#define SXSP_PROBING_CANDIDATE_FLAG_IS_NDP_GAC                  (0x00000004)

static const struct _SXSP_PROBING_CANDIDATE
{
    PCWSTR Pattern;
    DWORD Flags;
} s_rgProbingCandidates[] =
{
    { L"$M", 0 },
    { L"$G\\$N.DLL", SXSP_PROBING_CANDIDATE_FLAG_IS_NDP_GAC },
    { L"$.$L$N.DLL", SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY | SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY },
    { L"$.$L$N.MANIFEST", SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY | SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY },
    { L"$.$L$N\\$N.DLL", SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY | SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY },
    { L"$.$L$N\\$N.MANIFEST", SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY | SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY },
};

const static struct
{
    ULONG ThreadingModel;
    WCHAR String[10];
    SIZE_T Cch;
} gs_rgTMMap[] =
{
    { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_APARTMENT, STRING_AND_LENGTH(L"Apartment") },
    { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_FREE, STRING_AND_LENGTH(L"Free") },
    { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE, STRING_AND_LENGTH(L"Single") },
    { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH, STRING_AND_LENGTH(L"Both") },
    { ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_NEUTRAL, STRING_AND_LENGTH(L"Neutral") },
};

PCSTR SxspActivationContextCallbackReasonToString(ULONG activationContextCallbackReason)
{
#if DBG
static const CHAR rgs[][16] =
{
    "",
    "INIT",
    "GENBEGINNING",
    "PARSEBEGINNING",
    "BEGINCHILDREN",
    "ENDCHILDREN",
    "ELEMENTPARSED",
    "PARSEENDING",
    "ALLPARSINGDONE",
    "GETSECTIONSIZE",
    "GETSECTIONDATA",
    "GENENDING",
    "UNINIT"
};
    if (activationContextCallbackReason > 0 && activationContextCallbackReason <= NUMBER_OF(rgs))
    {
        return rgs[activationContextCallbackReason-1];
    }
    return rgs[0];
#else
    return "";
#endif
}

PCWSTR SxspInstallDispositionToStringW(ULONG installDisposition)
{
#if DBG
static const WCHAR rgs[][12] =
{
    L"",
    L"COPIED",
    L"QUEUED",
    L"PLEASE_COPY",
};
    if (installDisposition > 0 && installDisposition <= NUMBER_OF(rgs))
    {
        return rgs[installDisposition-1];
    }
    return rgs[0];
#else
    return L"";
#endif
}

BOOL
SxspParseThreadingModel(
    PCWSTR String,
    SIZE_T Cch,
    ULONG *ThreadingModel)
{
    ULONG i;
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    // We'll let ProcessorArchitecture be NULL if the caller just wants to
    // test whether there is a match.

    for (i=0; i<NUMBER_OF(gs_rgTMMap); i++)
    {
        if (::FusionpCompareStrings(
                gs_rgTMMap[i].String,
                gs_rgTMMap[i].Cch,
                String,
                Cch,
                true) == 0)
        {
            if (ThreadingModel != NULL)
                *ThreadingModel = gs_rgTMMap[i].ThreadingModel;

            break;
        }
    }

    if (i == NUMBER_OF(gs_rgTMMap))
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: Invalid threading model string\n");

        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFormatThreadingModel(
    ULONG ThreadingModel,
    CBaseStringBuffer &Buffer)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i;

    for (i=0; i<NUMBER_OF(gs_rgTMMap); i++)
    {
        if (gs_rgTMMap[i].ThreadingModel == ThreadingModel)
            break;
    }

    PARAMETER_CHECK(i != NUMBER_OF(gs_rgTMMap));
    IFW32FALSE_EXIT(Buffer.Win32Assign(gs_rgTMMap[i].String, gs_rgTMMap[i].Cch));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

SIZE_T
CchForUSHORT(USHORT us)
{
    if (us > 9999)
        return 5;
    else if (us > 999)
        return 4;
    else if (us > 99)
        return 3;
    else if (us > 9)
        return 2;

    return 1;
}

BOOL
SxspAllocateString(
    SIZE_T cch,
    PWSTR *StringOut)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    ASSERT(StringOut != NULL);

    if (StringOut != NULL)
        *StringOut = NULL;

    PARAMETER_CHECK(StringOut != NULL);
    PARAMETER_CHECK(cch != 0);
    IFALLOCFAILED_EXIT(*StringOut = NEW(WCHAR[cch]));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
//
//For deallocation of the output string, use "delete[] StringOut" xiaoyuw@08/31/00
//
BOOL
SxspDuplicateString(
    PCWSTR StringIn,
    SIZE_T cch,
    PWSTR *StringOut)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (StringOut != NULL)
        *StringOut = NULL;

    PARAMETER_CHECK(StringOut != NULL);
    PARAMETER_CHECK((StringIn != NULL) || (cch == 0));

    if (cch == 0)
        *StringOut = NULL;
    else
    {
        cch++;
        IFW32FALSE_EXIT(::SxspAllocateString(cch, StringOut));
        memcpy(*StringOut, StringIn, cch * sizeof(WCHAR));
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#define COMMA ,
extern const WCHAR sxspAssemblyManifestFileNameSuffixes[4][10] =  { L"", ASSEMBLY_MANIFEST_FILE_NAME_SUFFIXES(COMMA) };
#undef COMMA

// format an input ULONG to be a string in HEX format
BOOL
SxspFormatULONG(
    ULONG ul,
    SIZE_T CchBuffer,
    WCHAR Buffer[],
    SIZE_T *CchWrittenOrRequired)
{
    FN_PROLOG_WIN32

    if (CchWrittenOrRequired != NULL)
        *CchWrittenOrRequired = 0;

    PARAMETER_CHECK(Buffer != NULL);

    if (CchBuffer < (ULONG_STRING_LENGTH + 1))
    {
        if (CchWrittenOrRequired != NULL)
            *CchWrittenOrRequired = ULONG_STRING_LENGTH + 1;

        ORIGINATE_WIN32_FAILURE_AND_EXIT(BufferTooSmall, ERROR_INSUFFICIENT_BUFFER);
    }

    // Yes, these are char instead of WCHAR; better density and cache behavior -mgrier 12/4/2001
    static const char s_rgHex[] = "0123456789ABCDEF";

#define DOCHAR(n) Buffer[n] = (WCHAR) s_rgHex[(ul >> (28 - (n * 4))) & 0xf]

    DOCHAR(0);
    DOCHAR(1);
    DOCHAR(2);
    DOCHAR(3);
    DOCHAR(4);
    DOCHAR(5);
    DOCHAR(6);
    DOCHAR(7);

#undef DOCHAR

    Buffer[8] = L'\0';

    if (CchWrittenOrRequired != NULL)
        *CchWrittenOrRequired = 8;

    FN_EPILOG
}

// besides these specials, the NORMAL CHAR is in [A-Z] or [a-z] or [0-9]
bool
__fastcall
IsValidAssemblyNameCharacter(
    WCHAR ch)
{
    return
        (((ch >= L'A') && (ch <= L'Z')) ||
         ((ch >= L'a') && (ch <= L'z')) ||
         ((ch >= L'0') && (ch <= L'9')) ||
         (ch == L'.') ||
         (ch == L'-'));
}

BOOL
SxspGenerateAssemblyNamePrimeFromName(
    PCWSTR pszAssemblyName,
    SIZE_T CchAssemblyName,
    CBaseStringBuffer *Buffer)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PWSTR pStart = NULL, pEnd = NULL;
    PWSTR qEnd = NULL, pszBuffer = NULL;
    ULONG i, j, len, ulSpaceLeft;
    ULONG cch;
    PWSTR pLeftEnd = NULL, pRightStart = NULL, PureNameEnd = NULL, PureNameStart = NULL;
    CStringBuffer buffTemp;
    CStringBufferAccessor accessor;

    PARAMETER_CHECK(pszAssemblyName != NULL);
    PARAMETER_CHECK(Buffer != NULL);

    // See how many characters we need max in the temporary buffer.
    cch = 0;

    for (i=0; i<CchAssemblyName; i++)
    {
        if (::IsValidAssemblyNameCharacter(pszAssemblyName[i]))
            cch++;
    }

    IFW32FALSE_EXIT(buffTemp.Win32ResizeBuffer(cch + 1, eDoNotPreserveBufferContents));

    accessor.Attach(&buffTemp);

    pszBuffer = accessor.GetBufferPtr();

    j = 0;
    for (i=0; i<CchAssemblyName; i++)
    {
        if (::IsValidAssemblyNameCharacter(pszAssemblyName[i]))
        {
            pszBuffer[j] = pszAssemblyName[i];
            j++;
        }
    }

    ASSERT(j == cch);

    pszBuffer[j] = L'\0';

    // if the name is not too long, just return ;
    if (j < ASSEMBLY_NAME_PRIM_MAX_LENGTH)
    { // less or equal 64
        IFW32FALSE_EXIT(Buffer->Win32Assign(pszBuffer, cch));
    }
    else
    {
        // name is too long, have to trim a little bit
        ulSpaceLeft = ASSEMBLY_NAME_PRIM_MAX_LENGTH;

        PureNameStart = pszBuffer;
        PureNameEnd = pszBuffer + j;
        pLeftEnd = PureNameStart;
        pRightStart = PureNameEnd;

        while (PureNameStart < PureNameEnd)
        {
            // left end
            pStart = PureNameStart;
            i = 0;
            while ((wcschr(ASSEMBLY_NAME_VALID_SEPARATORS, pStart[i]) == 0) && (pStart+i != pRightStart)) // not a separator character
                i++;

            pEnd = pStart + i ;
            len = i;  // it should be length of WCHAR! not BYTE!!!

            if (len >= ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH)  {// because we use ".." if trim happen
                pLeftEnd += (ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH);
                break;
            }
            ulSpaceLeft -=  len;
            pLeftEnd = pEnd; // "abc.xxxxxxx" pointing to "c"

            // right end
            qEnd = PureNameEnd;
            i = 0 ;
            while ((qEnd+i != pLeftEnd) && (wcschr(ASSEMBLY_NAME_VALID_SEPARATORS, qEnd[i]) == 0))
                i--;

            len = 0 - i;
            if (len >= ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH)  {// because we use ".." if trim happen
                pRightStart -= ulSpaceLeft - ASSEMBLY_NAME_TRIM_INDICATOR_LENGTH;
                break;
            }
            ulSpaceLeft -=  len;
            PureNameStart = pLeftEnd + 1;
            PureNameEnd = pRightStart - 1;
        } // end of while

        IFW32FALSE_EXIT(Buffer->Win32Assign(pszBuffer, pLeftEnd-pszBuffer));
        IFW32FALSE_EXIT(Buffer->Win32Append(ASSEMBLY_NAME_TRIM_INDICATOR, NUMBER_OF(ASSEMBLY_NAME_TRIM_INDICATOR) - 1));
        IFW32FALSE_EXIT(Buffer->Win32Append(pRightStart, ::wcslen(pRightStart)));  // till end of the buffer
    }

    fSuccess = TRUE;

Exit:

    return fSuccess;
}

// not implemented : assume Jon has this API
BOOL
SxspVerifyPublicKeyAndStrongName(
    const WCHAR *pszPublicKey,
    SIZE_T CchPublicKey,
    const WCHAR *pszStrongName,
    SIZE_T CchStrongName,
    BOOL & fValid)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CSmallStringBuffer buf1;
    CSmallStringBuffer buf2;

    IFW32FALSE_EXIT(buf1.Win32Assign(pszPublicKey, CchPublicKey));
    IFW32FALSE_EXIT(buf2.Win32Assign(pszStrongName, CchStrongName));
    IFW32FALSE_EXIT(::SxspDoesStrongNameMatchKey(buf1, buf2, fValid));
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspGenerateSxsPath_ManifestOrPolicyFile(
    IN DWORD Flags,
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer)
{
    FN_PROLOG_WIN32

    DWORD dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST;
    BOOL fIsPolicy = FALSE;

    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(AssemblyIdentity, fIsPolicy));
    if (fIsPolicy)
    {
        dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY;
    }

    return SxspGenerateSxsPath(
        Flags,
        dwPathType,
        static_cast<PCWSTR>(AssemblyRootDirectory),
        AssemblyRootDirectory.Cch(),
        AssemblyIdentity,
        ppac,
        PathBuffer);

    FN_EPILOG
}

BOOL
SxspGenerateSxsPath_FullPathToManifestOrPolicyFile(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer)
{
    return SxspGenerateSxsPath_ManifestOrPolicyFile(
        0,
        AssemblyRootDirectory,
        AssemblyIdentity,
        ppac,
        PathBuffer);
}

BOOL
SxspGenerateSxsPath_RelativePathToManifestOrPolicyFile(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer)
{
    return SxspGenerateSxsPath_ManifestOrPolicyFile(
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
        AssemblyRootDirectory,
        AssemblyIdentity,
        ppac,
        PathBuffer);
}

extern const UNICODE_STRING CatalogFileExtensionUnicodeString = RTL_CONSTANT_STRING(L".cat");

BOOL
SxspGenerateSxsPath_CatalogFile(
    IN DWORD Flags,
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer)
{
    FN_PROLOG_WIN32

    DWORD dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST;
    BOOL fIsPolicy = FALSE;

    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(AssemblyIdentity, fIsPolicy));
    if (fIsPolicy)
    {
        dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY;
    }

    IFW32FALSE_EXIT(SxspGenerateSxsPath(
        Flags,
        dwPathType,
        static_cast<PCWSTR>(AssemblyRootDirectory),
        AssemblyRootDirectory.Cch(),
        AssemblyIdentity,
        ppac,
        PathBuffer));

    IFW32FALSE_EXIT(PathBuffer.Win32ChangePathExtension(&CatalogFileExtensionUnicodeString, eErrorIfNoExtension));

    FN_EPILOG
}

BOOL
SxspGenerateSxsPath_RelativePathToCatalogFile(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer)
{
    return SxspGenerateSxsPath_CatalogFile(
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
        AssemblyRootDirectory,
        AssemblyIdentity,
        ppac,
        PathBuffer);
}

BOOL
SxspGenerateSxsPath_FullPathToCatalogFile(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer)
{
    return SxspGenerateSxsPath_CatalogFile(
        0,
        AssemblyRootDirectory,
        AssemblyIdentity,
        ppac,
        PathBuffer);
}

BOOL
SxspGenerateSxsPath_PayloadOrPolicyDirectory(
    IN DWORD Flags,
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer)
{
    FN_PROLOG_WIN32
    DWORD dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY;
    BOOL fIsPolicy = FALSE;

    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(AssemblyIdentity, fIsPolicy));
    if (fIsPolicy)
    {
        dwPathType = SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY;
    }

    IFW32FALSE_EXIT(SxspGenerateSxsPath(
        Flags,
        dwPathType,
        static_cast<PCWSTR>(AssemblyRootDirectory),
        AssemblyRootDirectory.Cch(),
        AssemblyIdentity,
        ppac,
        PathBuffer));

    if (fIsPolicy)
    {
        IFW32FALSE_EXIT(PathBuffer.Win32RemoveLastPathElement());
    }

    FN_EPILOG
}

BOOL
SxspGenerateSxsPath_FullPathToPayloadOrPolicyDirectory(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer)
{
    return SxspGenerateSxsPath_PayloadOrPolicyDirectory(
        0,
        AssemblyRootDirectory,
        AssemblyIdentity,
        ppac,
        PathBuffer);
}

BOOL
SxspGenerateSxsPath_RelativePathToPayloadOrPolicyDirectory(
    IN const CBaseStringBuffer &AssemblyRootDirectory,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer)
{
    return SxspGenerateSxsPath_PayloadOrPolicyDirectory(
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
        AssemblyRootDirectory,
        AssemblyIdentity,
        ppac,
        PathBuffer);
}

BOOL
SxspGenerateSxsPath(
    IN DWORD Flags,
    IN ULONG PathType,
    IN const WCHAR *AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCch,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    SIZE_T  cch = 0;
    PCWSTR  pszAssemblyName=NULL, pszVersion=NULL, pszProcessorArchitecture=NULL, pszLanguage=NULL, pszPolicyFileNameWithoutExt = NULL;
    PCWSTR  pszPublicKeyToken=NULL;
    SIZE_T  cchAssemblyName = 0, cchPublicKeyToken=0, cchVersion=0, cchProcessorArchitecture=0, cchLanguage=0;
    SIZE_T  PolicyFileNameWithoutExtCch=0;
    BOOL    fNeedSlashAfterRoot = FALSE;
    ULONG   IdentityHash = 0;
    const bool fOmitRoot     = ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT) != 0);
    const bool fPartialPath  = ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH) != 0);

    WCHAR HashBuffer[ULONG_STRING_LENGTH + 1];
    SIZE_T  HashBufferCch = 0;

    PCWSTR  pcwszPolicyPathComponent = NULL;
    SIZE_T  cchPolicyPathComponent = 0;

    // We'll be using this a lot - a bool check is cheaper than two =='s checks everywhere.
    const bool fIsInstallingPolicy = ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY) ||
         (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_SETUP_POLICY));

    CSmallStringBuffer NamePrimeBuffer;

#if DBG_SXS
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_INFO,
        "SXS.DLL: Entered %s()\n"
        "   Flags = 0x%08lx\n"
        "   AssemblyRootDirectory = %p\n"
        "   AssemblyRootDirectoryCch = %lu\n"
        "   PathBuffer = %p\n",
        __FUNCTION__,
        Flags,
        AssemblyRootDirectory,
        AssemblyRootDirectoryCch,
        &PathBuffer);
#endif // DBG_SXS

    PARAMETER_CHECK(
        (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY) ||
        (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) ||
        (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY) ||
        (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_SETUP_POLICY));
    PARAMETER_CHECK(pAssemblyIdentity != NULL);
    PARAMETER_CHECK((Flags & ~(SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION | SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH)) == 0);
    // Not supplying the assembly root is only legal if you're asking for it to be left out...
    PARAMETER_CHECK((AssemblyRootDirectoryCch != 0) || (Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT));

    // You can't combine SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH with anything else...
    PARAMETER_CHECK(
        ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH) == 0) ||
        ((Flags & ~(SXSP_GENERATE_SXS_PATH_FLAG_PARTIAL_PATH)) == 0));

    // get AssemblyName
    if (ppac != NULL)
    {
        if ((ppac->dwFlags & PROBING_ATTRIBUTE_CACHE_FLAG_GOT_NAME) == 0)
        {
            IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, pAssemblyIdentity, &s_IdentityAttribute_name, &pszAssemblyName, &cchAssemblyName));
            ppac->pszName = pszAssemblyName;
            ppac->cchName = cchAssemblyName;
            ppac->dwFlags |= PROBING_ATTRIBUTE_CACHE_FLAG_GOT_NAME;
        }
        else
        {
            pszAssemblyName = ppac->pszName;
            cchAssemblyName = ppac->cchName;
        }
    }
    else
        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, pAssemblyIdentity, &s_IdentityAttribute_name, &pszAssemblyName, &cchAssemblyName));

    INTERNAL_ERROR_CHECK((pszAssemblyName != NULL) && (cchAssemblyName != 0));

    // get AssemblyName' based on AssemblyName
    IFW32FALSE_EXIT(::SxspGenerateAssemblyNamePrimeFromName(pszAssemblyName, cchAssemblyName, &NamePrimeBuffer));

    // get Assembly Version
    if (ppac != NULL)
    {
        if ((ppac->dwFlags & PROBING_ATTRIBUTE_CACHE_FLAG_GOT_VERSION) == 0)
        {
            IFW32FALSE_EXIT(
                ::SxspGetAssemblyIdentityAttributeValue(
                    SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, // for policy_lookup, no version is used
                    pAssemblyIdentity,
                    &s_IdentityAttribute_version,
                    &pszVersion,
                    &cchVersion));
            ppac->pszVersion = pszVersion;
            ppac->cchVersion = cchVersion;
            ppac->dwFlags |= PROBING_ATTRIBUTE_CACHE_FLAG_GOT_VERSION;
        }
        else
        {
            pszVersion = ppac->pszVersion;
            cchVersion = ppac->cchVersion;
        }
    }
    else
        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, // for policy_lookup, no version is used
                pAssemblyIdentity,
                &s_IdentityAttribute_version,
                &pszVersion,
                &cchVersion));

    if ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION) || fIsInstallingPolicy)
    {
        // for policy file, version of the policy file is used as policy filename
        pszPolicyFileNameWithoutExt = pszVersion;
        PolicyFileNameWithoutExtCch = cchVersion;
        pszVersion = NULL;
        cchVersion = 0;
    }
    else
    {
        PARAMETER_CHECK((pszVersion != NULL) && (cchVersion != 0));
    }

    // get Assembly Langage
    if (ppac != NULL)
    {
        if ((ppac->dwFlags & PROBING_ATTRIBUTE_CACHE_FLAG_GOT_LANGUAGE) == 0)
        {
            IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                pAssemblyIdentity,
                &s_IdentityAttribute_language,
                &pszLanguage,
                &cchLanguage));
            ppac->pszLanguage = pszLanguage;
            ppac->cchLanguage = cchLanguage;
            ppac->dwFlags |= PROBING_ATTRIBUTE_CACHE_FLAG_GOT_LANGUAGE;
        }
        else
        {
            pszLanguage = ppac->pszLanguage;
            cchLanguage = ppac->cchLanguage;
        }
    }
    else
        IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, pAssemblyIdentity, &s_IdentityAttribute_language, &pszLanguage, &cchLanguage));

    if (cchLanguage == 0)
    {
        pszLanguage = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE;
        cchLanguage = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE) - 1;
    }

    // get Assembly ProcessorArchitecture
    if (ppac != NULL)
    {
        if ((ppac->dwFlags & PROBING_ATTRIBUTE_CACHE_FLAG_GOT_PROCESSOR_ARCHITECTURE) == 0)
        {
            IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                pAssemblyIdentity,
                &s_IdentityAttribute_processorArchitecture,
                &pszProcessorArchitecture,
                &cchProcessorArchitecture));
            ppac->pszProcessorArchitecture = pszProcessorArchitecture;
            ppac->cchProcessorArchitecture = cchProcessorArchitecture;
            ppac->dwFlags |= PROBING_ATTRIBUTE_CACHE_FLAG_GOT_PROCESSOR_ARCHITECTURE;
        }
        else
        {
            pszProcessorArchitecture = ppac->pszProcessorArchitecture;
            cchProcessorArchitecture = ppac->cchProcessorArchitecture;
        }
    }
    else
        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                pAssemblyIdentity,
                &s_IdentityAttribute_processorArchitecture,
                &pszProcessorArchitecture,
                &cchProcessorArchitecture));

    if (pszProcessorArchitecture == NULL)
    {
        pszProcessorArchitecture = L"data";
        cchProcessorArchitecture = 4;
    }

    // get Assembly StrongName
    if (ppac != NULL)
    {
        if ((ppac->dwFlags & PROBING_ATTRIBUTE_CACHE_FLAG_GOT_PUBLIC_KEY_TOKEN) == 0)
        {
            IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                pAssemblyIdentity,
                &s_IdentityAttribute_publicKeyToken,
                &pszPublicKeyToken,
                &cchPublicKeyToken));
            ppac->pszPublicKeyToken = pszPublicKeyToken;
            ppac->cchPublicKeyToken = cchPublicKeyToken;
            if (pszPublicKeyToken != NULL)
                ppac->dwFlags |= PROBING_ATTRIBUTE_CACHE_FLAG_GOT_PUBLIC_KEY_TOKEN;
        }
        else
        {
            pszPublicKeyToken = ppac->pszPublicKeyToken;
            cchPublicKeyToken = ppac->cchPublicKeyToken;
        }
    }
    else
    {
        IFW32FALSE_EXIT(
            ::SxspGetAssemblyIdentityAttributeValue(
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                pAssemblyIdentity,
                &s_IdentityAttribute_publicKeyToken,
                &pszPublicKeyToken,
                &cchPublicKeyToken));
    }

    if (pszPublicKeyToken == NULL)
    {
        pszPublicKeyToken = SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE;
        cchPublicKeyToken = NUMBER_OF(SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_PUBLICKEY_MISSING_VALUE) - 1;
    }

    //get Assembly Hash String
    if ((Flags & SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION) || fIsInstallingPolicy)
    {
        IFW32FALSE_EXIT(::SxspHashAssemblyIdentityForPolicy(0, pAssemblyIdentity, IdentityHash));
    }
    else
    {
        IFW32FALSE_EXIT(::SxsHashAssemblyIdentity(0, pAssemblyIdentity, &IdentityHash));
    }

    IFW32FALSE_EXIT(::SxspFormatULONG(IdentityHash, NUMBER_OF(HashBuffer), HashBuffer, &HashBufferCch));

    if (!fOmitRoot)
    {
        // If the assembly root was not passed in, get it.
        fNeedSlashAfterRoot = (! ::FusionpIsPathSeparator(AssemblyRootDirectory[AssemblyRootDirectoryCch-1]));
    }
    else
    {
        // If we don't want to include the root, then don't account for it below...
        AssemblyRootDirectoryCch = 0;
        fNeedSlashAfterRoot = FALSE;
    }

    // this computation can be off by one or a few, it's an optimization
    // to pregrow a string buffer
    cch =
            AssemblyRootDirectoryCch +                                          // "C:\WINNT\WinSxS\"
            (fNeedSlashAfterRoot ? 1 : 0);

    switch (PathType)
    {
    case SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST:
        // Wacky parens and ... - 1) + 1) to reinforce that it's the number of
        // characters in the string not including the null and then an extra separator.
        cch += (NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1) + 1;
        break;

    case SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY:
        pcwszPolicyPathComponent = POLICY_ROOT_DIRECTORY_NAME;
        cchPolicyPathComponent = (NUMBER_OF(POLICY_ROOT_DIRECTORY_NAME) - 1);
        break;

    case SXSP_GENERATE_SXS_PATH_PATHTYPE_SETUP_POLICY:
        pcwszPolicyPathComponent = SETUP_POLICY_ROOT_DIRECTORY_NAME;
        cchPolicyPathComponent = NUMBER_OF(SETUP_POLICY_ROOT_DIRECTORY_NAME) - 1;
        break;
    }

    // Seperator, plus the length of the policy component (if necessary)
    cch++;
    cch += cchPolicyPathComponent;

    // fPartialPath means that we don't actually want to take the assembly's identity into
    // account; the caller just wants the path to the manifests or policies directories.
    if (!fPartialPath)
    {
        cch +=
                cchProcessorArchitecture +                                      // "x86"
                1 +                                                             // "_"
                NamePrimeBuffer.Cch() +                                         // "FooBar"
                1 +                                                             // "_"
                cchPublicKeyToken +                                         // StrongName
                1 +                                                             // "_"
                cchVersion +                                                    // "5.6.2900.42"
                1 +                                                             // "_"
                cchLanguage +                                                   // "0409"
                1 +                                                             // "_"
                HashBufferCch;

        if (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST)
        {
            cch += NUMBER_OF(ASSEMBLY_LONGEST_MANIFEST_FILE_NAME_SUFFIX);        // ".manifest\0"
        }
        else if (fIsInstallingPolicy)
        {
            // "_" has already reserve space for "\"
            cch += PolicyFileNameWithoutExtCch;
            cch += NUMBER_OF(ASSEMBLY_POLICY_FILE_NAME_SUFFIX_POLICY);          // ".policy\0"
        }
        else {  // pathType must be SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY

            // if (!fOmitRoot)
            //    cch++;
            cch++; // trailing null character
        }
    }

    // We try to ensure that the buffer is big enough up front so that we don't have to do any
    // dynamic reallocation during the actual process.
    IFW32FALSE_EXIT(PathBuffer.Win32ResizeBuffer(cch, eDoNotPreserveBufferContents));


    // Note that since when GENERATE_ASSEMBLY_PATH_OMIT_ROOT is set, we force AssemblyRootDirectoryCch to zero
    // and fNeedSlashAfterRoot to FALSE, so the first two entries in this concatenation actually don't
    // contribute anything to the string constructed.
    if (fPartialPath)
    {
        const bool fAddExtraSlash = ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) || fIsInstallingPolicy);

        IFW32FALSE_EXIT(PathBuffer.Win32AssignW(5,
                        AssemblyRootDirectory, static_cast<INT>(AssemblyRootDirectoryCch),  // "C:\WINNT\WINSXS"
                        L"\\", (fNeedSlashAfterRoot ? 1 : 0),                               // optional '\'
                        // manifests subdir
                        MANIFEST_ROOT_DIRECTORY_NAME, ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) ? NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) -1 : 0), // "manifests"
                        // policies subdir
                        pcwszPolicyPathComponent, cchPolicyPathComponent,
                        L"\\", fAddExtraSlash ? 1 : 0)); // optional '\'
    }
    else
    {
        const bool fAddExtraSlash = ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) || fIsInstallingPolicy);

        //
        // create one of below
        //  (1) fully-qualified manifest filename,
        //          eg, [C:\WINNT\WinSxS\]Manifests\X86_DynamicDll_6595b64144ccf1df_2.0.0.0_en-us_2f433926.Manifest
        //  (2) fully-qualified policy filename,
        //          eg, [C:\WINNT\WinSxS\]Policies\x86_policy.1.0.DynamicDll_b54bc117ce08a1e8_en-us_d51541cb\1.1.0.0.cat
        //  (3) fully-qulified assembly name (w. or w/o a version)
        //          eg, [C:\WINNT\WinSxS\]x86_DynamicDll_6595b64144ccf1df_6.0.0.0_x-ww_ff9986d7
        //  (4) fully-qualified policy path during setup
        //          eg, [C:\WINNT\WinSxS\]SetupPolicies\x86_policy.1.0.DynamicDll_b54bc117ce08a1e8_en-us_d51541cb\1.1.0.0.cat
        //
        IFW32FALSE_EXIT(
            PathBuffer.Win32AssignW(17,
                AssemblyRootDirectory, static_cast<INT>(AssemblyRootDirectoryCch),  // "C:\WINNT\WINSXS"
                L"\\", (fNeedSlashAfterRoot ? 1 : 0),                               // optional '\'
                MANIFEST_ROOT_DIRECTORY_NAME, ((PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST) ? NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1 : 0),
                pcwszPolicyPathComponent, cchPolicyPathComponent,
                L"\\", (fAddExtraSlash ? 1 : 0),   // optional '\'
                pszProcessorArchitecture, static_cast<INT>(cchProcessorArchitecture),
                L"_", 1,
                static_cast<PCWSTR>(NamePrimeBuffer), static_cast<INT>(NamePrimeBuffer.Cch()),
                L"_", 1,
                pszPublicKeyToken, static_cast<INT>(cchPublicKeyToken),
                L"_", (cchVersion != 0) ? 1 : 0,
                pszVersion, static_cast<INT>(cchVersion),
                L"_", 1,
                pszLanguage, static_cast<INT>(cchLanguage),
                L"_", 1,
                static_cast<PCWSTR>(HashBuffer), static_cast<INT>(HashBufferCch),
                L"\\", ((fOmitRoot ||(PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST)) ? 0 : 1)));

        if (PathType == SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST)
        {
            IFW32FALSE_EXIT(PathBuffer.Win32Append(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_MANIFEST, NUMBER_OF(ASSEMBLY_MANIFEST_FILE_NAME_SUFFIX_MANIFEST) - 1));
        }
        else if (fIsInstallingPolicy)
        {
            if ((pszPolicyFileNameWithoutExt != NULL) && (PolicyFileNameWithoutExtCch >0))
            {
                IFW32FALSE_EXIT(PathBuffer.Win32Append(pszPolicyFileNameWithoutExt, PolicyFileNameWithoutExtCch));
                IFW32FALSE_EXIT(PathBuffer.Win32Append(ASSEMBLY_POLICY_FILE_NAME_SUFFIX_POLICY, NUMBER_OF(ASSEMBLY_POLICY_FILE_NAME_SUFFIX_POLICY) - 1));
            }
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGenerateManifestPathForProbing(
    ULONG dwLocationIndex,
    DWORD dwFlags,
    IN PCWSTR AssemblyRootDirectory OPTIONAL,
    IN SIZE_T AssemblyRootDirectoryCch OPTIONAL,
    IN ULONG ApplicationDirectoryPathType OPTIONAL,
    IN PCWSTR ApplicationDirectory OPTIONAL,
    IN SIZE_T ApplicationDirectoryCch OPTIONAL,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    IN OUT CBaseStringBuffer &PathBuffer,
    BOOL  *pfPrivateAssembly,
    bool &rfDone)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    BOOL fIsPrivate = FALSE;

    rfDone = false;

    if (pfPrivateAssembly != NULL) // init
        *pfPrivateAssembly = FALSE;

    PathBuffer.Clear();

    PARAMETER_CHECK(pAssemblyIdentity != NULL);
    PARAMETER_CHECK(AssemblyRootDirectory != NULL);
    PARAMETER_CHECK(AssemblyRootDirectoryCch != 0);
    PARAMETER_CHECK((dwFlags & ~(SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_NO_APPLICATION_ROOT_PATH_REQUIRED |
                                 SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS |
                                 SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_PRIVATE_ASSEMBLIES)) == 0);
    PARAMETER_CHECK((dwLocationIndex == 0) || (dwFlags & SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_NO_APPLICATION_ROOT_PATH_REQUIRED) || (ApplicationDirectory != NULL));
    PARAMETER_CHECK((dwLocationIndex == 0) || (dwFlags & SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_NO_APPLICATION_ROOT_PATH_REQUIRED) || (ApplicationDirectoryCch != 0));
    PARAMETER_CHECK(::FusionpIsPathSeparator(AssemblyRootDirectory[AssemblyRootDirectoryCch - 1]));
    PARAMETER_CHECK((ApplicationDirectory == NULL) || (ApplicationDirectory[0] == L'\0') || ::FusionpIsPathSeparator(ApplicationDirectory[ApplicationDirectoryCch - 1]));
    PARAMETER_CHECK((ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_NONE) ||
                    (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE) ||
                    (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_URL));
    PARAMETER_CHECK((ApplicationDirectoryCch != 0) || (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_NONE));

    INTERNAL_ERROR_CHECK(dwLocationIndex <= NUMBER_OF(s_rgProbingCandidates));
    if (dwLocationIndex >= NUMBER_OF(s_rgProbingCandidates))
    {
        rfDone = true;
    }
    else
    {
        PCWSTR Candidate = s_rgProbingCandidates[dwLocationIndex].Pattern;
        WCHAR wch = 0;
        SIZE_T iPosition = 0; // Used to track that $M and $. only appear first

        if ((dwFlags & SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS) &&
            (s_rgProbingCandidates[dwLocationIndex].Flags & SXSP_PROBING_CANDIDATE_FLAG_USES_LANGUAGE_SUBDIRECTORY))
        {
            // No probing for languages I guess!
            fSuccess = TRUE;
            goto Exit;
        }

        if ((dwFlags & SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_PRIVATE_ASSEMBLIES) &&
            (s_rgProbingCandidates[dwLocationIndex].Flags & SXSP_PROBING_CANDIDATE_FLAG_IS_PRIVATE_ASSEMBLY))
        {
            fSuccess = TRUE;
            goto Exit;
        }

        while ((wch = *Candidate++) != L'\0')
        {
            switch (wch)
            {
            default:
                IFW32FALSE_EXIT(PathBuffer.Win32Append(&wch, 1));
                break;

            case L'$':
                wch = *Candidate++;

                switch (wch)
                {
                default:
                    // Bad macro expansion...
                    INTERNAL_ERROR_CHECK(FALSE);
                    break; // extraneous since there was effectively an unconditional goto in the internal error check...

                case L'M':
                    // $M is only allowed as the first element.
                    INTERNAL_ERROR_CHECK(iPosition == 0);
                    IFW32FALSE_EXIT(
                        ::SxspGenerateSxsPath(// "winnt\winsxs\manifests\x86_bar_1000_0409.manifest
                            0,
                            SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
                            AssemblyRootDirectory,
                            AssemblyRootDirectoryCch,
                            pAssemblyIdentity,
                            ppac,
                            PathBuffer));

                    // and it has to be the only element
                    INTERNAL_ERROR_CHECK(*Candidate == L'\0');
                    break;

                case L'G':
                    IFW32FALSE_EXIT(::SxspGenerateNdpGACPath(0, pAssemblyIdentity, ppac, PathBuffer));
                    break;

                case L'.':
                    // $. is only allowed as the first element
                    INTERNAL_ERROR_CHECK(iPosition == 0);

                    if (ApplicationDirectoryPathType == ACTIVATION_CONTEXT_PATH_TYPE_NONE)
                    {
                        // No local probing...
                        fSuccess = TRUE;
                        goto Exit;
                    }

                    IFW32FALSE_EXIT(PathBuffer.Win32Append(ApplicationDirectory, ApplicationDirectoryCch));
                    fIsPrivate = TRUE;
                    break;

                case L'L': // language
                    {
                        INTERNAL_ERROR_CHECK((dwFlags & SXS_GENERATE_MANIFEST_PATH_FOR_PROBING_SKIP_LANGUAGE_SUBDIRS) == 0);

                        if ((ppac->dwFlags & PROBING_ATTRIBUTE_CACHE_FLAG_GOT_LANGUAGE) == 0)
                        {
                            IFW32FALSE_EXIT(
                                ::SxspGetAssemblyIdentityAttributeValue(
                                    SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
                                    pAssemblyIdentity,
                                    &s_IdentityAttribute_language,
                                    &ppac->pszLanguage,
                                    &ppac->cchLanguage));

                            ppac->dwFlags |= PROBING_ATTRIBUTE_CACHE_FLAG_GOT_LANGUAGE;
                        }

                        if (ppac->cchLanguage != 0)
                        {
                            IFW32FALSE_EXIT(PathBuffer.Win32Append(ppac->pszLanguage, ppac->cchLanguage));
                            IFW32FALSE_EXIT(PathBuffer.Win32Append(PathBuffer.PreferredPathSeparatorString(), 1));
                        }

                        break;
                    }

                case L'N': // full assembly name
                    {
                        if ((ppac->dwFlags & PROBING_ATTRIBUTE_CACHE_FLAG_GOT_NAME) == 0)
                        {
                            IFW32FALSE_EXIT(
                                ::SxspGetAssemblyIdentityAttributeValue(
                                    0,
                                    pAssemblyIdentity,
                                    &s_IdentityAttribute_name,
                                    &ppac->pszName,
                                    &ppac->cchName));

                            dwFlags |= PROBING_ATTRIBUTE_CACHE_FLAG_GOT_NAME;
                        }

                        INTERNAL_ERROR_CHECK(ppac->cchName != 0);
                        IFW32FALSE_EXIT(PathBuffer.Win32Append(ppac->pszName, ppac->cchName));
                        break;
                    }

                case L'n': // final segment of assembly name
                    {
                        PCWSTR pszPartialName = NULL;
                        SIZE_T cchPartialName = 0;

                        if ((ppac->dwFlags & PROBING_ATTRIBUTE_CACHE_FLAG_GOT_NAME) == 0)
                        {
                            IFW32FALSE_EXIT(
                                ::SxspGetAssemblyIdentityAttributeValue(
                                    0,
                                    pAssemblyIdentity,
                                    &s_IdentityAttribute_name,
                                    &ppac->pszName,
                                    &ppac->cchName));

                            dwFlags |= PROBING_ATTRIBUTE_CACHE_FLAG_GOT_NAME;
                        }

                        INTERNAL_ERROR_CHECK(ppac->cchName != 0);
                        IFW32FALSE_EXIT(::SxspFindLastSegmentOfAssemblyName(ppac->pszName, ppac->cchName, &pszPartialName, &cchPartialName));
                        IFW32FALSE_EXIT(PathBuffer.Win32Append(pszPartialName, cchPartialName));
                        break;
                    }

                case L'P': // P for Prime because in discussions we always called this "name prime" (vs. "name")
                    {
                        CSmallStringBuffer buffShortenedAssemblyName;

                        if ((ppac->dwFlags & PROBING_ATTRIBUTE_CACHE_FLAG_GOT_NAME) == 0)
                        {
                            IFW32FALSE_EXIT(
                                ::SxspGetAssemblyIdentityAttributeValue(
                                    0,
                                    pAssemblyIdentity,
                                    &s_IdentityAttribute_name,
                                    &ppac->pszName,
                                    &ppac->cchName));

                            dwFlags |= PROBING_ATTRIBUTE_CACHE_FLAG_GOT_NAME;
                        }

                        INTERNAL_ERROR_CHECK(ppac->cchName != 0);

                        IFW32FALSE_EXIT(::SxspGenerateAssemblyNamePrimeFromName(ppac->pszName, ppac->cchName, &buffShortenedAssemblyName));
                        IFW32FALSE_EXIT(PathBuffer.Win32Append(buffShortenedAssemblyName, buffShortenedAssemblyName.Cch()));
                        break;
                    }
                }

                break;
            }

            iPosition++;
        }

    }

    if (pfPrivateAssembly != NULL)
        *pfPrivateAssembly = fIsPrivate;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGetAttributeValue(
    IN DWORD dwFlags,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeNameDescriptor,
    IN PCSXS_NODE_INFO NodeInfo,
    IN SIZE_T NodeCount,
    IN PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    OUT bool &rfFound,
    IN SIZE_T OutputBufferSize,
    OUT PVOID OutputBuffer,
    OUT SIZE_T &rcbOutputBytesWritten,
    IN SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE ValidationRoutine OPTIONAL,
    IN DWORD ValidationRoutineFlags OPTIONAL)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG i = 0;
    PCWSTR AttributeName = NULL;
    PCWSTR AttributeNamespace = NULL;
    SIZE_T AttributeNameCch = 0;
    SIZE_T AttributeNamespaceCch = 0;
    CStringBuffer buffValue;
    BOOL fSmallStringBuffer = FALSE;

    rfFound = false;
    rcbOutputBytesWritten = 0;

    PARAMETER_CHECK((dwFlags & ~(SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE)) == 0);
    PARAMETER_CHECK(AttributeNameDescriptor != NULL);
    PARAMETER_CHECK((NodeInfo != NULL) || (NodeCount == 0));
    PARAMETER_CHECK((OutputBuffer != NULL) || (OutputBufferSize == 0));
    PARAMETER_CHECK((ValidationRoutine != NULL) || (ValidationRoutineFlags == 0));
    PARAMETER_CHECK((ValidationRoutine != NULL) ||
                (OutputBufferSize == 0) || (OutputBufferSize == sizeof(CSmallStringBuffer)) || (OutputBufferSize == sizeof(CStringBuffer)));
    if (OutputBufferSize != sizeof(CStringBuffer))
        fSmallStringBuffer = TRUE;

    AttributeName = AttributeNameDescriptor->Name;
    AttributeNameCch = AttributeNameDescriptor->NameCch;
    AttributeNamespace = AttributeNameDescriptor->Namespace;
    AttributeNamespaceCch = AttributeNameDescriptor->NamespaceCch;

    for (i=0; i<NodeCount; i++)
    {
        if ((NodeInfo[i].Type == SXS_ATTRIBUTE) &&
            (::FusionpCompareStrings(// compare name
                NodeInfo[i].pszText,
                NodeInfo[i].cchText,
                AttributeName,
                AttributeNameCch,
                false) == 0))
        {
            //compare namespace
            if (((NodeInfo[i].NamespaceStringBuf.Cch() == 0) && (AttributeNamespaceCch==0)) ||
                (::FusionpCompareStrings(// compare namespace string
                    NodeInfo[i].NamespaceStringBuf,
                    NodeInfo[i].NamespaceStringBuf.Cch(),
                    AttributeNamespace,
                    AttributeNamespaceCch,
                    false) == 0))
            {
                // We found the attribute.  Now we need to start accumulating the parts of the value;
                // entity references (e.g. &amp;) show up as separate nodes.
                while ((++i < NodeCount) &&
                       (NodeInfo[i].Type == SXS_PCDATA))
                    IFW32FALSE_EXIT(buffValue.Win32Append(NodeInfo[i].pszText, NodeInfo[i].cchText));

                if (ValidationRoutine == NULL)
                {
                    if (OutputBuffer != NULL)
                    {
                        // Have the caller's buffer take over ours
                        CBaseStringBuffer *pCallersBuffer = (CBaseStringBuffer *) OutputBuffer;
                        IFW32FALSE_EXIT(pCallersBuffer->Win32Assign(buffValue));
                        rcbOutputBytesWritten = pCallersBuffer->Cch() * sizeof(WCHAR);
                    }
                }
                else
                {
                    bool fValid = false;

                    IFW32FALSE_EXIT(
                        (*ValidationRoutine)(
                            ValidationRoutineFlags,
                            buffValue,
                            fValid,
                            OutputBufferSize,
                            OutputBuffer,
                            rcbOutputBytesWritten));

                    if (!fValid)
                    {
                        (*ParseContext->ErrorCallbacks.InvalidAttributeValue)(
                            ParseContext,
                            AttributeNameDescriptor);

                        ORIGINATE_WIN32_FAILURE_AND_EXIT(AttributeValidation, ERROR_SXS_MANIFEST_PARSE_ERROR);
                    }
                }

                rfFound = true;

                break;
            }
        }
    }

    if ((dwFlags & SXSP_GET_ATTRIBUTE_VALUE_FLAG_REQUIRED_ATTRIBUTE) && (!rfFound))
    {
        (*ParseContext->ErrorCallbacks.MissingRequiredAttribute)(
            ParseContext,
            AttributeNameDescriptor);

        ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingRequiredAttribute, ERROR_SXS_MANIFEST_PARSE_ERROR);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGetAttributeValue(
    IN DWORD dwFlags,
    IN PCATTRIBUTE_NAME_DESCRIPTOR AttributeNameDescriptor,
    IN PCACTCTXCTB_CBELEMENTPARSED ElementParsed,
    OUT bool &rfFound,
    IN SIZE_T OutputBufferSize,
    OUT PVOID OutputBuffer,
    OUT SIZE_T &rcbOutputBytesWritten,
    IN SXSP_GET_ATTRIBUTE_VALUE_VALIDATION_ROUTINE ValidationRoutine OPTIONAL,
    IN DWORD ValidationRoutineFlags OPTIONAL)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    // Since we're doing some parameter validation here, we need to initialize our output parameters
    rfFound = false;
    rcbOutputBytesWritten = 0;

    PARAMETER_CHECK(ElementParsed != NULL);

    // We're going to depend on the other function to do the rest of the parameter validation
    // a little sleazy but what the heck

    IFW32FALSE_EXIT(
        ::SxspGetAttributeValue(
            dwFlags,
            AttributeNameDescriptor,
            ElementParsed->NodeInfo,
            ElementParsed->NodeCount,
            ElementParsed->ParseContext,
            rfFound,
            OutputBufferSize,
            OutputBuffer,
            rcbOutputBytesWritten,
            ValidationRoutine,
            ValidationRoutineFlags));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFormatGUID(
    const GUID &rGuid,
    CBaseStringBuffer &rBuffer)
{
    FN_PROLOG_WIN32

    // It would seem nice to use RtlStringFromGUID(), but it does a dynamic allocation, which we do not
    // want.  Instead, we'll just format it ourselves; it's pretty trivial...
    //
    //  {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    //  00000000011111111112222222222333333333
    //  12345678901234567890123456789012345678
    //
    // 128 bits / 4 bits per digit = 32 digits
    // + 4 dashes + 2 braces = 38
#define CCH_GUID (38)

    IFW32FALSE_EXIT(rBuffer.Win32ResizeBuffer(CCH_GUID + 1, eDoNotPreserveBufferContents));

    // It's still unbelievably slow to use swprintf() here, but this is a good opportunity for someone
    // to optimize in the future if it ever is a perf issue.

    IFW32FALSE_EXIT(
        rBuffer.Win32Format(
            L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
            rGuid.Data1, rGuid.Data2, rGuid.Data3, rGuid.Data4[0], rGuid.Data4[1], rGuid.Data4[2], rGuid.Data4[3], rGuid.Data4[4], rGuid.Data4[5], rGuid.Data4[6], rGuid.Data4[7]));

    INTERNAL_ERROR_CHECK(rBuffer.Cch() == CCH_GUID);

    FN_EPILOG
}

BOOL
SxspParseGUID(
    PCWSTR String,
    SIZE_T Cch,
    GUID &rGuid)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SIZE_T ich = 0;
    ULONG i = 0;
    ULONG acc;

    if (Cch != CCH_GUID)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() caller passed in GUID that is %d characters long; GUIDs must be exactly 38 characters long.\n", Cch);
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    ich = 1;

    if (*String++ != L'{')
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() caller pass in GUID that does not begin with a left brace ('{')\n");

        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    ich++;

    // Parse the first segment...
    acc = 0;
    for (i=0; i<8; i++)
    {
        WCHAR wch = *String++;

        if (!::IsHexDigit(wch))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspParseGUID() given GUID where character %d is not hexidecimal\n", ich);
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }

        ich++;

        acc = acc << 4;

        acc += HexDigitToValue(wch);
    }

    rGuid.Data1 = acc;

    // Look for the dash...
    if (*String++ != L'-')
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not a dash.\n", ich);
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }
    ich++;

    acc = 0;
    for (i=0; i<4; i++)
    {
        WCHAR wch = *String++;

        if (!::IsHexDigit(wch))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspParseGUID() given GUID where character %d is not hexidecimal\n", ich);
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }
        ich++;

        acc = acc << 4;

        acc += HexDigitToValue(wch);
    }

    rGuid.Data2 = static_cast<USHORT>(acc);

    // Look for the dash...
    if (*String++ != L'-')
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not a dash.\n", ich);
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }
    ich++;

    acc = 0;
    for (i=0; i<4; i++)
    {
        WCHAR wch = *String++;

        if (!::IsHexDigit(wch))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspParseGUID() given GUID where character %d is not hexidecimal\n", ich);
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }

        ich++;

        acc = acc << 4;

        acc += HexDigitToValue(wch);
    }

    rGuid.Data3 = static_cast<USHORT>(acc);

    // Look for the dash...
    if (*String++ != L'-')
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not a dash.\n", ich);
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }
    ich++;

    for (i=0; i<8; i++)
    {
        WCHAR wch1, wch2;

        wch1 = *String++;
        if (!::IsHexDigit(wch1))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not hexidecimal\n", ich);
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }
        ich++;

        wch2 = *String++;
        if (!::IsHexDigit(wch2))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not hexidecimal\n", ich);
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }
        ich++;

        rGuid.Data4[i] = static_cast<unsigned char>((::HexDigitToValue(wch1) << 4) | ::HexDigitToValue(wch2));

        // There's a dash after the 2nd byte
        if (i == 1)
        {
            if (*String++ != L'-')
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: SxspParseGUID() passed in GUID where character %d is not a dash.\n", ich);
                ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
                goto Exit;
            }
            ich++;
        }
    }

    // This replacement should be made.
    //INTERNAL_ERROR_CHECK(ich == CCH_GUID);
    ASSERT(ich == CCH_GUID);

    if (*String != L'}')
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: SxspParseGUID() passed in GUID which does not terminate with a closing brace ('}')\n");
        ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspFormatFileTime(
    LARGE_INTEGER ft,
    CBaseStringBuffer &rBuffer)
{
    FN_PROLOG_WIN32

    SIZE_T Cch = 0;
    CStringBufferAccessor acc;

    if (ft.QuadPart == 0)
    {
        IFW32FALSE_EXIT(rBuffer.Win32Assign(L"n/a", 3));
        Cch = 3;
    }
    else
    {
        SYSTEMTIME st;
        int iResult = 0;
        int cchDate = 0;
        int cchTime = 0;

        IFW32FALSE_ORIGINATE_AND_EXIT(::FileTimeToSystemTime((FILETIME *) &ft, &st));

        IFW32ZERO_ORIGINATE_AND_EXIT(iResult = ::GetDateFormatW(
                            LOCALE_USER_DEFAULT,
                            LOCALE_USE_CP_ACP,
                            &st,
                            NULL,
                            NULL,
                            0));

        cchDate = iResult - 1;

        IFW32ZERO_ORIGINATE_AND_EXIT(iResult = ::GetTimeFormatW(
                            LOCALE_USER_DEFAULT,
                            LOCALE_USE_CP_ACP,
                            &st,
                            NULL,
                            NULL,
                            0));

        cchTime = iResult - 1;

        IFW32FALSE_EXIT(rBuffer.Win32ResizeBuffer(cchDate + 1 + cchTime + 1, eDoNotPreserveBufferContents));

        acc.Attach(&rBuffer);
        IFW32ZERO_ORIGINATE_AND_EXIT(iResult = ::GetDateFormatW(
                            LOCALE_USER_DEFAULT,
                            LOCALE_USE_CP_ACP,
                            &st,
                            NULL,
                            acc.GetBufferPtr(),
                            cchDate + 1));

        // This replacement should be made.
        //INTERNAL_ERROR_CHECK(iResult == (cchDate + 1));
        ASSERT(iResult == (cchDate + 1));

        acc.GetBufferPtr()[cchDate] = L' ';

        IFW32ZERO_ORIGINATE_AND_EXIT(iResult = ::GetTimeFormatW(
                        LOCALE_USER_DEFAULT,
                        LOCALE_USE_CP_ACP,
                        &st,
                        NULL,
                        acc.GetBufferPtr() + cchDate + 1,
                        cchTime + 1));

        // This replacement should be made.
        //INTERNAL_ERROR_CHECK(iResult == (cchTime + 1));
        ASSERT(iResult == (cchTime + 1));

        Cch = (cchDate + 1 + cchTime);
        acc.Detach();
    }

    FN_EPILOG
}



BOOL
SxspGetNDPGacRootDirectory(
    OUT CBaseStringBuffer &rRootDirectory)
{
    FN_PROLOG_WIN32
    static const WCHAR GacDirectory[] = L"\\Assembly\\GAC";
    const PCWSTR SystemRoot = USER_SHARED_DATA->NtSystemRoot;

    //
    // BUGBUG CAUTION: This doesn't know anything about relocating GACs at the moment!
    //
    IFW32FALSE_EXIT(rRootDirectory.Win32Assign(SystemRoot, ::wcslen(SystemRoot)));
    IFW32FALSE_EXIT(rRootDirectory.Win32AppendPathElement(
        GacDirectory,
        NUMBER_OF(GacDirectory) - 1));

    FN_EPILOG
}



BOOL
SxspGetAssemblyRootDirectory(
    CBaseStringBuffer &rBuffer)
{
    FN_PROLOG_WIN32

    CStringBufferAccessor acc;
    SIZE_T CchRequired = 0;

    // Short-circuit - if someone wanted to use an alternate assembly store, report it instead
    if (g_AlternateAssemblyStoreRoot)
    {
        IFW32FALSE_EXIT(rBuffer.Win32Assign(g_AlternateAssemblyStoreRoot, ::wcslen(g_AlternateAssemblyStoreRoot)));
        FN_SUCCESSFUL_EXIT();
    }

    acc.Attach(&rBuffer);

    if (!::SxspGetAssemblyRootDirectoryHelper(acc.GetBufferCch(), acc.GetBufferPtr(), &CchRequired))
    {
        DWORD dwLastError = ::FusionpGetLastWin32Error();

        if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
            goto Exit;

        acc.Detach();
        IFW32FALSE_EXIT(rBuffer.Win32ResizeBuffer(CchRequired + 1, eDoNotPreserveBufferContents));
        acc.Attach(&rBuffer);
        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectoryHelper(acc.GetBufferCch(), acc.GetBufferPtr(), NULL));
    }

    acc.Detach();

    FN_EPILOG
}

BOOL
SxspFindLastSegmentOfAssemblyName(
    PCWSTR AssemblyName,
    SIZE_T cchAssemblyName,
    PCWSTR *LastSegment,
    SIZE_T *LastSegmentCch)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    if (LastSegment != NULL)
        *LastSegment = NULL;

    if (LastSegmentCch != NULL)
        *LastSegmentCch = 0;

    PARAMETER_CHECK(LastSegment != NULL);
    PARAMETER_CHECK((AssemblyName != NULL) || (cchAssemblyName == 0));

    if (cchAssemblyName != 0)
    {
        PCWSTR LastPartOfAssemblyName = AssemblyName + cchAssemblyName - 1;
        SIZE_T LastPartOfAssemblyNameCch = 1;

        while (LastPartOfAssemblyName != AssemblyName)
        {
            const WCHAR wch = *LastPartOfAssemblyName;

            if ((wch == L'.') || (wch == L'\\') || (wch == L'/'))
            {
                LastPartOfAssemblyName++;
                LastPartOfAssemblyNameCch--;
                break;
            }

            LastPartOfAssemblyName--;
            LastPartOfAssemblyNameCch++;
        }

        *LastSegment = LastPartOfAssemblyName;
        if (LastSegmentCch != NULL)
            *LastSegmentCch = LastPartOfAssemblyNameCch;
    }
    else
    {
        *LastSegment = NULL;
        if (LastSegmentCch != NULL)
            *LastSegmentCch = 0;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspProcessElementPathMap(
    PCACTCTXCTB_PARSE_CONTEXT ParseContext,
    PCELEMENT_PATH_MAP_ENTRY MapEntries,
    SIZE_T MapEntryCount,
    ULONG &MappedValue,
    bool &Found)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    ULONG XMLElementDepth = 0;
    PCWSTR ElementPath = NULL;
    SIZE_T ElementPathCch = 0;
    SIZE_T i = 0;

    PARAMETER_CHECK(ParseContext != NULL);
    PARAMETER_CHECK((MapEntries != NULL) || (MapEntryCount == 0));

    XMLElementDepth = ParseContext->XMLElementDepth;
    ElementPath = ParseContext->ElementPath;
    ElementPathCch = ParseContext->ElementPathCch;

    MappedValue = 0;
    Found = false;

    for (i=0; i<MapEntryCount; i++)
    {
        if ((MapEntries[i].ElementDepth == XMLElementDepth) &&
            (MapEntries[i].ElementPathCch == ElementPathCch) &&
            (::FusionpCompareStrings(
                    ElementPath,
                    ElementPathCch,
                    MapEntries[i].ElementPath,
                    ElementPathCch,
                    false) == 0))
        {
            MappedValue = MapEntries[i].MappedValue;
            Found = true;
            break;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspParseUSHORT(
    PCWSTR String,
    SIZE_T Cch,
    USHORT *Value)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    USHORT Temp = 0;

    PARAMETER_CHECK((String != NULL) || (Cch == 0));

    while (Cch != 0)
    {
        WCHAR wch = *String++;

        if ((wch < L'0') || (wch > L'9'))
        {
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: Error parsing 16-bit unsigned short integer; character other than 0-9 found\n");
            ::FusionpSetLastWin32Error(ERROR_SXS_MANIFEST_PARSE_ERROR);
            goto Exit;
        }

        Temp = (Temp * 10) + (wch - L'0');

        Cch--;
    }

    if (Value != NULL)
        *Value = Temp;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


/*-----------------------------------------------------------------------------
create a unique temp directory under %windir%\WinSxs
-----------------------------------------------------------------------------*/
BOOL
SxspCreateWinSxsTempDirectory(
    OUT CBaseStringBuffer &rbuffTemp,
    OUT SIZE_T *pcch OPTIONAL,
    OUT CBaseStringBuffer *pbuffUniquePart OPTIONAL,
    OUT SIZE_T *pcchUniquePart OPTIONAL)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    INT     iTries = 0;
    CSmallStringBuffer uidBuffer;
    CBaseStringBuffer *puidBuffer = (pbuffUniquePart != NULL) ? pbuffUniquePart : &uidBuffer;

    INTERNAL_ERROR_CHECK(rbuffTemp.IsEmpty());
    INTERNAL_ERROR_CHECK(puidBuffer->IsEmpty());

    for (iTries = 0 ; rbuffTemp.IsEmpty() && iTries < 2 ; ++iTries)
    {
        SXSP_LOCALLY_UNIQUE_ID luid;
        IFW32FALSE_EXIT(::SxspCreateLocallyUniqueId(&luid));
        IFW32FALSE_EXIT(::SxspFormatLocallyUniqueId(luid, *puidBuffer));
        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(rbuffTemp));

        IFW32FALSE_EXIT(rbuffTemp.Win32RemoveTrailingPathSeparators()); // CreateDirectory doesn't like them

        // create \winnt\WinSxs, must not delete even on failure
        if (::CreateDirectoryW(rbuffTemp, NULL))
        {
            // We don't care if this fails.
            ::SetFileAttributesW(rbuffTemp, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
        }
        else if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
        {
            TRACE_WIN32_FAILURE_ORIGINATION(CreateDirectoryW);
            goto Exit;
        }
        // create \winnt\winsxs\manifests, must not delete even on failure

        IFW32FALSE_EXIT(rbuffTemp.Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(rbuffTemp.Win32Append(MANIFEST_ROOT_DIRECTORY_NAME, NUMBER_OF(MANIFEST_ROOT_DIRECTORY_NAME) - 1));
        if (::CreateDirectoryW(rbuffTemp, NULL))
        {
            ::SetFileAttributesW(rbuffTemp, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
        }
        else if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
        {
            TRACE_WIN32_FAILURE_ORIGINATION(CreateDirectoryW);
            goto Exit;
        }
        // restore to be "\winnt\winsxs\"
        IFW32FALSE_EXIT(rbuffTemp.Win32RemoveLastPathElement());

#if SXSP_SEMIREADABLE_INSTALL_TEMP
        // create \winnt\WinSxs\InstallTemp, must not delete even on failure
        ASSERT(::SxspIsSfcIgnoredStoreSubdir(ASSEMBLY_INSTALL_TEMP_DIR_NAME));
        IFW32FALSE_EXIT(rbuffTemp.Win32AppendPathElement(ASSEMBLY_INSTALL_TEMP_DIR_NAME, NUMBER_OF(ASSEMBLY_INSTALL_TEMP_DIR_NAME) - 1));
        IFW32FALSE_ORIGINATE_AND_EXIT(::CreateDirectoryW(rbuffTemp, NULL) || ::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS);
#endif
        IFW32FALSE_EXIT(rbuffTemp.Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(rbuffTemp.Win32Append(*puidBuffer, puidBuffer->Cch()));

        if (!::CreateDirectoryW(rbuffTemp, NULL))
        {
            rbuffTemp.Clear();
            if (::FusionpGetLastWin32Error() != ERROR_ALREADY_EXISTS)
            {
                TRACE_WIN32_FAILURE_ORIGINATION(CreateDirectoryW);
                goto Exit;
            }
        }
    }

    INTERNAL_ERROR_CHECK(!rbuffTemp.IsEmpty());

    if (pcch != NULL)
        *pcch = rbuffTemp.Cch();

    if (pcchUniquePart != NULL)
        *pcchUniquePart = pbuffUniquePart->Cch();

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
SxspCreateRunOnceDeleteDirectory(
    IN const CBaseStringBuffer &rbuffDirectoryToDelete,
    IN const CBaseStringBuffer *pbuffUniqueKey OPTIONAL,
    OUT PVOID* cookie)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CRunOnceDeleteDirectory* p = NULL;

    IFALLOCFAILED_EXIT(p = new CRunOnceDeleteDirectory);
    IFW32FALSE_EXIT(p->Initialize(rbuffDirectoryToDelete, pbuffUniqueKey));

    *cookie = p;
    p = NULL;
    fSuccess = TRUE;
Exit:
    FUSION_DELETE_SINGLETON(p);
    return fSuccess;
}

BOOL
SxspCancelRunOnceDeleteDirectory(
    PVOID cookie)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CRunOnceDeleteDirectory* p = reinterpret_cast<CRunOnceDeleteDirectory*>(cookie);

    IFW32FALSE_EXIT(p->Cancel());

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CRunOnceDeleteDirectory::Initialize(
    IN const CBaseStringBuffer &rbuffDirectoryToDelete,
    IN const CBaseStringBuffer *pbuffUniqueKey OPTIONAL)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CSmallStringBuffer buffUniqueKey;
    HKEY hKey = NULL;
    DWORD dwRegDisposition = 0;
    LONG lReg = 0;
    CStringBuffer buffValue;

    if (!::SxspAtExit(this))
    {
        TRACE_WIN32_FAILURE(SxspAtExit);
        FUSION_DELETE_SINGLETON(this);
        goto Exit;
    }

    if (pbuffUniqueKey == NULL)
    {
        SXSP_LOCALLY_UNIQUE_ID luid;

        IFW32FALSE_EXIT(::SxspCreateLocallyUniqueId(&luid));
        IFW32FALSE_EXIT(::SxspFormatLocallyUniqueId(luid, buffUniqueKey));

        pbuffUniqueKey = &buffUniqueKey;
    }

    IFREGFAILED_ORIGINATE_AND_EXIT(
        lReg =
            ::RegCreateKeyExW(
                hKeyRunOnceRoot,
                rgchRunOnceSubKey,
                0, // reserved
                NULL, // class
                REG_OPTION_NON_VOLATILE,
                KEY_SET_VALUE | FUSIONP_KEY_WOW64_64KEY,
                NULL, // security
                &hKey,
                &dwRegDisposition));

    m_hKey = hKey;

    IFW32FALSE_EXIT(m_strValueName.Win32Assign(rgchRunOnceValueNameBase, ::wcslen(rgchRunOnceValueNameBase)));
    IFW32FALSE_EXIT(m_strValueName.Win32Append(*pbuffUniqueKey));
    IFW32FALSE_EXIT(buffValue.Win32Assign(rgchRunOnePrefix, ::wcslen(rgchRunOnePrefix)));
    IFW32FALSE_EXIT(buffValue.Win32Append(rbuffDirectoryToDelete));

    IFREGFAILED_ORIGINATE_AND_EXIT(
        lReg =
            ::RegSetValueExW(
                hKey,
                m_strValueName,
                0, // reserved
                REG_SZ,
                reinterpret_cast<const BYTE*>(static_cast<PCWSTR>(buffValue)),
                static_cast<ULONG>((buffValue.Cch() + 1) * sizeof(WCHAR))));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

CRunOnceDeleteDirectory::~CRunOnceDeleteDirectory(
    )
{
    CSxsPreserveLastError ple;
    this->Cancel();
    ple.Restore();
}

BOOL
CRunOnceDeleteDirectory::Close(
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    // very unusual.. this is noncrashing, but
    // leaves the stuff in the registry
    m_strValueName.Clear();
    IFW32FALSE_EXIT(m_hKey.Win32Close());
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
CRunOnceDeleteDirectory::Cancel(
    )
{
    BOOL fSuccess = TRUE;
    FN_TRACE_WIN32(fSuccess);

    if (!m_strValueName.IsEmpty())
    {
        LONG lReg = ::RegDeleteValueW(m_hKey, m_strValueName);
        if (lReg != ERROR_SUCCESS)
        {
            fSuccess = FALSE;
            ::FusionpSetLastWin32Error(lReg);
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): RegDeleteValueW(RunOnce,%ls) failed:%ld\n",
                __FUNCTION__,
                static_cast<PCWSTR>(m_strValueName),
                lReg);
        }
    }
    if (!m_hKey.Win32Close())
    {
        fSuccess = FALSE;
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s(): RegCloseKey(RunOnce) failed:%ld\n",
            __FUNCTION__,
            ::FusionpGetLastWin32Error()
           );
    }
    m_strValueName.Clear();

    if (fSuccess && ::SxspTryCancelAtExit(this))
        FUSION_DELETE_SINGLETON(this);

    return fSuccess;
}

/* ///////////////////////////////////////////////////////////////////////////////////////
 CurrentDirectory
        is fully qualified directory path, for example, "c:\tmp"
   pwszNewDirs
        is a string such as "a\b\c\d",  this function would create "c:\tmp\a", "c:\tmp\a\b",
        "c:\tmp\a\b\c", and "c:\tmp\a\b\c\d"
Merge this with util\io.cpp\FusionpCreateDirectories.
///////////////////////////////////////////////////////////////////////////////////////// */
BOOL SxspCreateMultiLevelDirectory(PCWSTR CurrentDirectory, PCWSTR pwszNewDirs)
{
    FN_PROLOG_WIN32

    PCWSTR p = NULL;
    CStringBuffer FullPathSubDirBuf;

    PARAMETER_CHECK(pwszNewDirs != NULL);

    p = pwszNewDirs;
    IFW32FALSE_EXIT(FullPathSubDirBuf.Win32Assign(CurrentDirectory, ::wcslen(CurrentDirectory)));

    while (*p)
    {
        SIZE_T cCharsInSegment;

        //
        // How long is this segment?
        //
        cCharsInSegment = wcscspn(p, CUnicodeCharTraits::PathSeparators());

        //
        // Zero characters in this segment?
        //
        if (cCharsInSegment == 0)
            break;

        IFW32FALSE_EXIT(FullPathSubDirBuf.Win32EnsureTrailingPathSeparator());
        IFW32FALSE_EXIT(FullPathSubDirBuf.Win32Append(p, cCharsInSegment));
        IFW32FALSE_ORIGINATE_AND_EXIT(
            CreateDirectoryW(FullPathSubDirBuf, NULL) ||
            ::FusionpGetLastWin32Error() == ERROR_ALREADY_EXISTS);

        //
        // Increment path buffer pointer, and skip the next set of slashes.
        //
        p += cCharsInSegment;
        p += wcsspn(p, CUnicodeCharTraits::PathSeparators());
    }

    FN_EPILOG

}

//
// ISSUE - 2002/05/05 - This is gross, don't rely on GetFileAttributes like this, use
// SxspDoesFileExist instead.
//
BOOL SxspInstallDecompressOrCopyFileW(PCWSTR lpSource, PCWSTR lpDest, BOOL bFailIfExists)
{
    FN_PROLOG_WIN32

    bool fExist = false;
    IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_FILE_ONLY, lpDest, fExist));
    if (fExist)
    {
        if (bFailIfExists == FALSE)
        {
            IFW32FALSE_ORIGINATE_AND_EXIT(::SetFileAttributesW(lpDest, FILE_ATTRIBUTE_NORMAL));
            IFW32FALSE_ORIGINATE_AND_EXIT(::DeleteFileW(lpDest));
        }else
        {
            ::SetLastError(ERROR_FILE_EXISTS);
            goto Exit;
        }
    }

    DWORD err = ::SetupDecompressOrCopyFileW(lpSource, lpDest, NULL);
    if (err != ERROR_SUCCESS)
    {
        ::SetLastError(err);
        goto Exit;
    }

    FN_EPILOG
}

//
// Function :
//  For files, it try to decompress a compressed file before move,
//  for firectories, it would work as MoveFileExW, fail if the dirs are on different
//  volumns
//
BOOL SxspInstallDecompressAndMoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags,
    BOOL fAwareNonCompressed)
{
    FN_PROLOG_WIN32

    DWORD   dwTemp1 = 0;
    DWORD   dwTemp2 = 0;
    UINT    uiCompressType = 0;
    PWSTR   pszCompressedFileName = NULL;
    bool fExist = false;
    //
    // make sure that the source file exists, based on SetupGetFileCompressionInfo() in MSDN :
    //  Because SetupGetFileCompressionInfo determines the compression by referencing the physical file, your setup application
    //  should ensure that the file is present before calling SetupGetFileCompressionInfo.
    //
    IFW32FALSE_EXIT(SxspDoesFileExist(0, lpExistingFileName, fExist));
    if (!fExist)
    {
        if (fAwareNonCompressed)
        {
            goto Exit;
        }
        // it is possible that the file existed is named as a.dl_, while the input file name is a.dll, in this case, we
        // assume that lpExistingFileName is a filename of compressed file, so just go ahead to call SetupDecompressOrCopyFile

        IFW32FALSE_EXIT(::SxspInstallDecompressOrCopyFileW(lpExistingFileName, lpNewFileName, !(dwFlags & MOVEFILE_REPLACE_EXISTING)));

        //
        // try to find the "realname" of the file, which is in compression-format, so that we could delete it
        // because the compressed file is named in a way we do not know, such as a.dl_ or a.dl$,

        if (::SetupGetFileCompressionInfoW(lpExistingFileName, &pszCompressedFileName, &dwTemp1, &dwTemp2, &uiCompressType) != NO_ERROR)
        {
            goto Exit;
        }

        IFW32FALSE_ORIGINATE_AND_EXIT(::SetFileAttributesW(pszCompressedFileName, FILE_ATTRIBUTE_NORMAL));
        IFW32FALSE_ORIGINATE_AND_EXIT(::DeleteFileW(pszCompressedFileName));
        goto WellDone;
    }
    DWORD dwAttributes = 0;
    IFW32FALSE_EXIT(SxspGetFileAttributesW(lpExistingFileName, dwAttributes));
    if ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
    {
        //
        // this file is named in normal way, such as "a.dll" but it is also possible that it is compressed
        //
        IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_FILE_ONLY, lpNewFileName, fExist));
        if (fExist)
        {
            if ((dwFlags & MOVEFILE_REPLACE_EXISTING))
            {
                IFW32FALSE_ORIGINATE_AND_EXIT(::SetFileAttributesW(lpNewFileName, FILE_ATTRIBUTE_NORMAL));
                IFW32FALSE_ORIGINATE_AND_EXIT(::DeleteFileW(lpNewFileName));
            }
            else
            {
                ::SetLastError(ERROR_FILE_EXISTS);
                goto Exit;
            }
        }

        if (! fAwareNonCompressed)
        {
            if (::SetupGetFileCompressionInfoW(lpExistingFileName, &pszCompressedFileName, &dwTemp1, &dwTemp2, &uiCompressType) != NO_ERROR)
            {
                goto Exit;
            }

            LocalFree(pszCompressedFileName);
            pszCompressedFileName = NULL;

            if ((dwTemp1 == dwTemp2) && (uiCompressType == FILE_COMPRESSION_NONE ))
            {
                //BUGBUG:
                // this only mean the compress algo is not recognized, may or maynot be compressed
                //
                IFW32FALSE_ORIGINATE_AND_EXIT(::MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags));
            }
            else
            {
                IFW32FALSE_EXIT(::SxspInstallDecompressOrCopyFileW(lpExistingFileName, lpNewFileName, !(dwFlags & MOVEFILE_REPLACE_EXISTING)));

                //
                // try to delete the original file after copy it into destination
                //
                IFW32FALSE_ORIGINATE_AND_EXIT(::SetFileAttributesW(lpExistingFileName, FILE_ATTRIBUTE_NORMAL));
                IFW32FALSE_ORIGINATE_AND_EXIT(::DeleteFileW(lpExistingFileName));
            }
        }
        else
        {
            // already know that the file is non-compressed, move directly
            IFW32FALSE_ORIGINATE_AND_EXIT(::MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags));
        }
    }
    else
    {
        // move a directory, it would just fail as MoveFileExW if the destination is on a different volumn from the source
        IFW32FALSE_ORIGINATE_AND_EXIT(::MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags));
    }

WellDone:
    __fSuccess = TRUE;
Exit:
    if (pszCompressedFileName != NULL)
        LocalFree(pszCompressedFileName);

    return __fSuccess;
}

//
// Function:
//  same as MoveFileExW except
//  (1) if the source is compressed, this func would decompress the file before move
//  (2) if the destination has existed, compare the source and destination in "our" way, if the comparison result is EQUAL
//      exit with TRUE
//
// Note: for directories on different Volumn, it would just fail, as MoveFileExW

BOOL
SxspInstallMoveFileExW(
    CBaseStringBuffer   &moveOrigination,
    CBaseStringBuffer   &moveDestination,
    DWORD               dwFlags,
    BOOL                fAwareNonCompressed
    )
{
    BOOL    fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    DWORD   dwLastError = 0;
    CFusionDirectoryDifference directoryDifference;

    if (::SxspInstallDecompressAndMoveFileExW(moveOrigination, moveDestination, dwFlags, fAwareNonCompressed) == 0) // MoveFileExW failed
    {
        //
        // MoveFileExW failed, but if the existing destination is the "same" as the source, the failure is acceptable
        //
        dwLastError = ::FusionpGetLastWin32Error();
        DWORD dwFileAttributes = 0;
        bool fExist = false;
        IFW32FALSE_EXIT(SxspDoesFileExist(0, moveDestination, fExist));
        if (!fExist)
        {
#if DBG
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: %s(): MoveFile(%ls,%ls,%s) failed %lu\n",
                __FUNCTION__,
                static_cast<PCWSTR>(moveOrigination),
                static_cast<PCWSTR>(moveDestination),
                (dwFlags & MOVEFILE_REPLACE_EXISTING) ? "MOVEFILE_REPLACE_EXISTING" : "0",
                dwLastError
                );
#endif
            ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
        }
        IFW32FALSE_EXIT(SxspGetFileAttributesW(moveDestination, dwFileAttributes));
        if ((dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            //
            // if the destination file has already been there but the error is not ERROR_ALREADY_EXISTS,
            // we give up, otherwise, we would compare the two files later
            //
            if ((dwLastError != ERROR_ALREADY_EXISTS) &&
                (dwLastError != ERROR_FILE_EXISTS))
                /*
                && dwLastError != ERROR_USER_MAPPED_FILE
                && dwLastError != ERROR_ACCESS_DENIED
                && dwLastError != ERROR_SHARING_VIOLATION
                )*/
            {
                ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
            }
        }
        else
        {
            if (dwLastError != ERROR_ACCESS_DENIED
                && dwLastError != ERROR_ALREADY_EXISTS)
                ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
        }

        //
        // We could delete the file if fReplaceExisting, but that doesn't feel safe.
        //

        //
        // in case there is a preexisting directory, that's probably why the move failed
        //
        if (dwFlags & MOVEFILE_REPLACE_EXISTING)
        {
            CStringBuffer          tempDirForRenameExistingAway;
            CSmallStringBuffer     uidBuffer;
            CFullPathSplitPointers splitExistingDir;
            BOOL                   fHaveTempDir = FALSE;

            //
            // try a directory swap,
            // if that fails, say because some of the files are in use, we'll try other
            // things; though some failures we must bail on (like out of memory)
            //
            IFW32FALSE_EXIT(splitExistingDir.Initialize(moveDestination));
            IFW32FALSE_EXIT(::SxspCreateWinSxsTempDirectory(tempDirForRenameExistingAway, NULL, &uidBuffer, NULL));

            fHaveTempDir = TRUE;

            IFW32FALSE_EXIT(
                tempDirForRenameExistingAway.Win32AppendPathElement(
                    splitExistingDir.m_name,
                    (splitExistingDir.m_name != NULL) ? ::wcslen(splitExistingDir.m_name) : 0));

            //
            // move file into temporary directory, so we do not need worry about Compressed file
            //
            if (!::MoveFileExW(moveDestination, tempDirForRenameExistingAway, FALSE)) // no decompress needed
            {
                dwLastError = ::FusionpGetLastWin32Error();
                if ((dwLastError == ERROR_SHARING_VIOLATION) ||
                    (dwLastError == ERROR_USER_MAPPED_FILE))
                {
                    goto TryMovingFiles;
                }

                ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
            }

            //
            // try again after move the existing dest file into tempDirectory,
            // use DecompressAndMove instead of move because we are trying to copy file into Destination
            //
            if (!::SxspInstallDecompressAndMoveFileExW(moveOrigination, moveDestination, FALSE, fAwareNonCompressed))
            {
                dwLastError = ::FusionpGetLastWin32Error();

                // rollback from temporaray to dest
                if (!::MoveFileExW(tempDirForRenameExistingAway, moveDestination, FALSE)) // no decompress needed
                {
                    // uh oh, rollback failed, very bad, call in SQL Server..
                    // so much for transactional + replace existing..
                }

                ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
            }

            // success, now just cleanup, do we care about failure here?
            // \winnt\winsxs\installtemp\1234\x86_comctl_6.0
            // -> \winnt\winsxs\installtemp\1234
            IFW32FALSE_EXIT(tempDirForRenameExistingAway.Win32RemoveLastPathElement());

            if (!::SxspDeleteDirectory(tempDirForRenameExistingAway))
            {
                const DWORD Error = ::FusionpGetLastWin32Error();
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS.DLL: %s(): SxspDeleteDirectory(%ls) failed:%ld\n",
                    __FUNCTION__,
                    static_cast<PCWSTR>(tempDirForRenameExistingAway),
                    Error);
            }
            /*
            if (!::SxspDeleteDirectory(tempDirForRenameExistingAway))
            {
                CRunOnceDeleteDirectory runOnceDeleteRenameExistingAwayDirectory;
                runOnceDeleteRenameExistingAwayDirectory.Initialize(tempDirForRenameExistingAway, NULL);
                runOnceDeleteRenameExistingAwayDirectory.Close(); // leave the data in the registry
            }
            */
            goto TryMoveFilesEnd;
TryMovingFiles:
            // need parallel directory walk class (we actually do this in SxspMoveFilesAndSubdirUnderDirectory)
            // otherwise punt
            goto Exit;
            //ORIGINATE_WIN32_FAILURE_AND_EXIT(MoveFileExW, dwLastError);
TryMoveFilesEnd:;
        }
        else // !fReplaceExisting
        {
            // compare them
            // DbgPrint if they vary
            // fail if they vary
            // succeed if they do not vary
            if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (!::FusionpCompareDirectoriesSizewiseRecursively(&directoryDifference, moveOrigination, moveDestination))
                {
                    const DWORD Error = ::FusionpGetLastWin32Error();
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS.DLL: %s(): FusionpCompareDirectoriesSizewiseRecursively(%ls,%ls) failed:%ld\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(moveOrigination),
                        static_cast<PCWSTR>(moveDestination),
                        Error);
                    goto Exit;
                    //ORIGINATE_WIN32_FAILURE_AND_EXIT(FusionpCompareDirectoriesSizewiseRecursively, Error);
                }
                if (directoryDifference.m_e != CFusionDirectoryDifference::eEqual)
                {
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS.DLL: %s(): MoveFile(%ls,%ls) failed, UNequal duplicate assembly : ERROR_ALREADY_EXISTS\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(moveOrigination),
                        static_cast<PCWSTR>(moveDestination));
                    directoryDifference.DbgPrint(moveOrigination, moveDestination);
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(DifferentAssemblyWithSameIdentityAlreadyInstalledAndNotReplaceExisting, ERROR_ALREADY_EXISTS);
                }
                else
                {
                    // They're equal so the installation is effectively done.
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_INFO | FUSION_DBG_LEVEL_INSTALLATION,
                        "SXS.DLL: %s(): MoveFile(%ls,%ls) failed, equal duplicate assembly ignored\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(moveOrigination),
                        static_cast<PCWSTR>(moveDestination));
                    // fall through, no goto Exit
                }
            }
            else // move files
            {
                // At least let's see if they have the same size.
                WIN32_FILE_ATTRIBUTE_DATA wfadOrigination;
                WIN32_FILE_ATTRIBUTE_DATA wfadDestination;

                IFW32FALSE_EXIT(
                    ::GetFileAttributesExW(
                        moveOrigination,
                        GetFileExInfoStandard,
                        &wfadOrigination));

                IFW32FALSE_EXIT(
                    ::GetFileAttributesExW(
                        moveDestination,
                        GetFileExInfoStandard,
                        &wfadDestination));

                if ((wfadOrigination.nFileSizeHigh == wfadDestination.nFileSizeHigh) &&
                    (wfadOrigination.nFileSizeLow == wfadDestination.nFileSizeLow))
                {
                    // let's call it even

                    // We should use SxspCompareFiles here.
#if DBG
                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_INSTALLATION,
                        "SXS: %s - move %ls -> %ls claimed success because files have same size\n",
                        __FUNCTION__,
                        static_cast<PCWSTR>(moveOrigination),
                        static_cast<PCWSTR>(moveDestination)
                        );
#endif
                }
                else
                {
                    ORIGINATE_WIN32_FAILURE_AND_EXIT(SxspInstallMoveFileExW, dwLastError);
                }
            }//end of if (dwFlags == SXS_INSTALLATION_MOVE_DIRECTORY)
        } // end of if  (fReplaceFiles)
    } // end of if (MoveFileX())

    fSuccess = TRUE;
Exit:
#if DBG
    if (!fSuccess)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_INSTALLATION | FUSION_DBG_LEVEL_ERROR,
            "SXS: %s(0x%lx, %ls, %ls, %s) failing %lu\n",
            __FUNCTION__, dwFlags, static_cast<PCWSTR>(moveOrigination), static_cast<PCWSTR>(moveDestination),
            (dwFlags & MOVEFILE_REPLACE_EXISTING)? "replace_existing" : "do_not_replace_existing", ::FusionpGetLastWin32Error());
    }
#endif
    return fSuccess;
}


inline
bool IsErrorInErrorList(
    DWORD dwError,
    SIZE_T cErrors,
    va_list Errors
    )
{
    for (cErrors; cErrors > 0; cErrors--)
    {
        if (dwError == va_arg(Errors, DWORD))
            return true;
    }

    return false;
}


BOOL
SxspDoesPathCrossReparsePointVa(
    IN PCWSTR pcwszBasePathBuffer,
    IN SIZE_T cchBasePathBuffer,
    IN PCWSTR pcwszTotalPathBuffer,
    IN SIZE_T cchTotalPathBuffer,
    OUT BOOL &CrossesReparsePoint,
    OUT DWORD &rdwLastError,
    SIZE_T cErrors,
    va_list vaOkErrors
    )
{
    FN_PROLOG_WIN32

    CStringBuffer PathWorker;
    CStringBuffer PathRemainder;

    CrossesReparsePoint = FALSE;
    rdwLastError = ERROR_SUCCESS;

    // If the base path is non-null, then great.  Otherwise, the length
    // has to be zero as well.
    PARAMETER_CHECK(
        (pcwszBasePathBuffer != NULL) ||
        ((pcwszBasePathBuffer == NULL) && (cchBasePathBuffer == 0)));
    PARAMETER_CHECK(pcwszTotalPathBuffer != NULL);

    //
    // The base path must start the total path.  It might be easier to allow users
    // to specify a base path and then subdirectories, bu then for the 90% case of
    // people having both a root and a total, they'd have to do the work below to
    // seperate the two.
    //
    if (pcwszBasePathBuffer != NULL)
    {
        PARAMETER_CHECK( ::FusionpCompareStrings(
                pcwszBasePathBuffer,
                cchBasePathBuffer,
                pcwszTotalPathBuffer,
                cchBasePathBuffer,
                true ) == 0 );
    }

    //
    // PathWorker will be the path we'll be checking subthings on. Start it off
    // at the base path we were given.
    //
    // PathRemainder is what's left to process.
    //
    IFW32FALSE_EXIT(PathWorker.Win32Assign(pcwszBasePathBuffer, cchBasePathBuffer));
    IFW32FALSE_EXIT(PathRemainder.Win32Assign(pcwszTotalPathBuffer + cchBasePathBuffer,
        cchTotalPathBuffer - cchBasePathBuffer));
    PathRemainder.RemoveLeadingPathSeparators();

    while ( PathRemainder.Cch() && !CrossesReparsePoint )
    {
        CSmallStringBuffer buffSingleChunk;
        DWORD dwAttributes = 0;

        IFW32FALSE_EXIT(PathRemainder.Win32GetFirstPathElement(buffSingleChunk, TRUE));
        if (PathWorker.Cch() == 0)
        {
            IFW32FALSE_EXIT(PathWorker.Win32Assign(buffSingleChunk));
        }
        else
        {
            IFW32FALSE_EXIT(PathWorker.Win32AppendPathElement(buffSingleChunk));
        }

        dwAttributes = ::GetFileAttributesW(PathWorker);

        if ( dwAttributes == INVALID_FILE_ATTRIBUTES )
        {
            const DWORD dwError = ::FusionpGetLastWin32Error();
            if (!IsErrorInErrorList(dwError, cErrors, vaOkErrors))
                ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFileAttributesW, ::FusionpGetLastWin32Error());
            else
            {
                rdwLastError = dwError;
                FN_SUCCESSFUL_EXIT();
            }

        }
        else if ( dwAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
        {
            CrossesReparsePoint = TRUE;
        }
    }

    FN_EPILOG
}

BOOL
SxspValidateBoolAttribute(
    DWORD dwFlags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    bool fValid = false;
    StringComparisonResult scr;
    bool fValue = false;

    rfValid = false;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK((OutputBufferSize == 0) || (OutputBufferSize == sizeof(bool)));

    if (rbuff.Cch() == 2)
    {
        IFW32FALSE_EXIT(rbuff.Win32Compare(L"no", 2, scr, NORM_IGNORECASE));
        if (scr == eEquals)
        {
            fValid = true;
            fValue = false;
        }
    }
    else if (rbuff.Cch() == 3)
    {
        IFW32FALSE_EXIT(rbuff.Win32Compare(L"yes", 3, scr, NORM_IGNORECASE));
        if (scr == eEquals)
        {
            fValid = true;
            fValue = true;
        }
    }

    if (fValid)
    {
        if (OutputBuffer != NULL)
            *((bool *) OutputBuffer) = fValue;

        OutputBytesWritten = sizeof(bool);
        rfValid = true;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateUnsigned64Attribute(
    DWORD dwFlags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    bool fValid = false;
    bool fBadChar = false;
    bool fOverflow = false;
    ULONGLONG ullOldValue = 0;
    ULONGLONG ullNewValue = 0;
    SIZE_T i = 0;
    SIZE_T cch = 0;
    PCWSTR psz = NULL;

    rfValid = false;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK((OutputBufferSize == 0) || (OutputBufferSize == sizeof(ULONGLONG)));

    OutputBytesWritten = 0;

    cch = rbuff.Cch();
    psz = rbuff;

    for (i=0; i<cch; i++)
    {
        const WCHAR wch = *psz++;

        if ((wch < L'0') || (wch > L'9'))
        {
            fBadChar = true;
            break;
        }

        ullNewValue = (ullOldValue * 10);

        if (ullNewValue < ullOldValue)
        {
            fOverflow = true;
            break;
        }

        ullOldValue = ullNewValue;
        ullNewValue += (wch - L'0');
        if (ullNewValue < ullOldValue)
        {
            fOverflow = true;
            break;
        }

        ullOldValue = ullNewValue;
    }

    if ((cch != 0) && (!fBadChar) && (!fOverflow))
        fValid = true;

    if (fValid && (OutputBuffer != NULL))
    {
        *((ULONGLONG *) OutputBuffer) = ullNewValue;
        OutputBytesWritten = sizeof(ULONGLONG);
    }

    rfValid = fValid;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateGuidAttribute(
    DWORD dwFlags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    GUID *pGuid = reinterpret_cast<GUID *>(OutputBuffer);
    GUID guidWorkaround;

    rfValid = false;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK((OutputBufferSize == 0) || (OutputBufferSize == sizeof(GUID)));

    if (pGuid == NULL)
        pGuid = &guidWorkaround;

    IFW32FALSE_EXIT(::SxspParseGUID(rbuff, rbuff.Cch(), *pGuid));

    rfValid = true;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateProcessorArchitectureAttribute(
    DWORD dwFlags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    USHORT *pPA = reinterpret_cast<USHORT *>(OutputBuffer);

    rfValid = false;

    PARAMETER_CHECK((dwFlags & ~(SXSP_VALIDATE_PROCESSOR_ARCHITECTURE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED)) == 0);
    PARAMETER_CHECK((OutputBufferSize == 0) || (OutputBufferSize == sizeof(USHORT)));

    if (dwFlags & SXSP_VALIDATE_PROCESSOR_ARCHITECTURE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED)
    {
        if (rbuff.Cch() == 1)
        {
            if (rbuff[0] == L'*')
                rfValid = true;
        }
    }

    if (!rfValid)
        IFW32FALSE_EXIT(::FusionpParseProcessorArchitecture(rbuff, rbuff.Cch(), pPA, rfValid));

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspValidateLanguageAttribute(
    DWORD dwFlags,
    const CBaseStringBuffer &rbuff,
    bool &rfValid,
    SIZE_T OutputBufferSize,
    PVOID OutputBuffer,
    SIZE_T &OutputBytesWritten)
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CBaseStringBuffer *pbuffOut = reinterpret_cast<CBaseStringBuffer *>(OutputBuffer);
    bool fValid = false;

    rfValid = false;

    PARAMETER_CHECK((dwFlags & ~(SXSP_VALIDATE_LANGUAGE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED)) == 0);
    PARAMETER_CHECK((OutputBufferSize == 0) || (OutputBufferSize >= sizeof(CBaseStringBuffer)));

    if (dwFlags & SXSP_VALIDATE_LANGUAGE_ATTRIBUTE_FLAG_WILDCARD_ALLOWED)
    {
        if (rbuff.Cch() == 1)
        {
            if (rbuff[0] == L'*')
                fValid = true;
        }
    }

    if (!fValid)
    {
        PCWSTR Cursor = rbuff;
        bool fDashSeen = false;
        WCHAR wch = 0;

        while ((wch = *Cursor++) != L'\0')
        {
            if (wch == '-')
            {
                if (fDashSeen)
                {
                    fValid = false;
                    break;
                }

                fDashSeen = true;
            }
            else if (
                ((wch >= L'a') && (wch <= L'z')) ||
                ((wch >= L'A') && (wch <= L'Z')))
            {
                fValid = true;
            }
            else
            {
                fValid = false;
                break;
            }
        }
    }

    rfValid = fValid;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#define SXS_MSI_TO_FUSION_ATTRIBUTE_VALUE_CONVERSION_COMMA  0
#define SXS_MSI_TO_FUSION_ATTRIBUTE_VALUE_CONVERSION_QUOT   1

// ---------------------------------------------------------------------------------
// Convert function for Assembly-Attribute-Value :
//        1. for value of assembly-Name, replace L"&#x2c;" by comma
//        2. for value of other assembly-identity-attribute, replace L"&#x22;" by quot
// no new space is allocate, use the old space
// ---------------------------------------------------------------------------------
BOOL
SxspConvertAssemblyNameFromMSInstallerToFusion(
    DWORD   dwFlags,                /* in */
    PWSTR   pszAssemblyStringInOut, /*in, out*/
    SIZE_T  CchAssemblyStringIn,    /*in */
    SIZE_T* pCchAssemblyStringOut   /*out */
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PWSTR pCursor = NULL;
    PWSTR pSpecialSubString= NULL;
    WCHAR pSpecialSubStringReplacement = 0;
    SIZE_T index = 0;
    SIZE_T border = 0;
    SIZE_T CchSpecialSubString = 0;

    PARAMETER_CHECK((dwFlags == SXS_MSI_TO_FUSION_ATTRIBUTE_VALUE_CONVERSION_COMMA) ||
                          (dwFlags == SXS_MSI_TO_FUSION_ATTRIBUTE_VALUE_CONVERSION_QUOT));
    PARAMETER_CHECK(pszAssemblyStringInOut != NULL);
    PARAMETER_CHECK(pCchAssemblyStringOut != NULL);

    if (dwFlags == SXS_MSI_TO_FUSION_ATTRIBUTE_VALUE_CONVERSION_COMMA)
    {
        pSpecialSubStringReplacement= L',';
        pSpecialSubString = SXS_COMMA_STRING;
        CchSpecialSubString = NUMBER_OF(SXS_COMMA_STRING) - 1;
    }
    else
    {
        pSpecialSubStringReplacement = L'"';
        pSpecialSubString = SXS_QUOT_STRING;
        CchSpecialSubString = NUMBER_OF(SXS_QUOT_STRING) - 1;
    }

    index = 0 ;
    border = CchAssemblyStringIn;
    while (index < border)
    {
        pCursor = wcsstr(pszAssemblyStringInOut, pSpecialSubString);
        if (pCursor == NULL)
            break;
        index = pCursor - pszAssemblyStringInOut;
        if (index < border) {
            *pCursor = pSpecialSubStringReplacement;
            index ++;  // skip the special character
            for (SIZE_T i=index; i<border; i++)
            { // reset the input string
                pszAssemblyStringInOut[i] = pszAssemblyStringInOut[i + CchSpecialSubString - 1];
            }
            pCursor ++;
             border -= CchSpecialSubString - 1;
        }
        else
            break;
    }
    *pCchAssemblyStringOut = border;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspDequoteString(
    IN PCWSTR pcwszString,
    IN SIZE_T cchString,
    OUT CBaseStringBuffer &buffDequotedString
    )
{
    FN_PROLOG_WIN32

    SIZE_T cchQuotedString = 0;
    BOOL fNotEnoughBuffer = FALSE;

    //
    // the output string *must* be always shorter than input string because of the logic of the replacement.
    // but it would not a very big difference in the real case. By allocating memory at very beginning it would cut
    // the loop below. In very rare case, when the input is "plain" and very long, the loop would not help if we do not
    // allocate space beforehand(bug 360177).
    //
    //
    if (cchString > buffDequotedString.GetBufferCch())
        IFW32FALSE_EXIT(buffDequotedString.Win32ResizeBuffer(cchString + 1, eDoNotPreserveBufferContents));

    for (;;)
    {
        cchQuotedString = buffDequotedString.GetBufferCch();

        CStringBufferAccessor sba;
        sba.Attach(&buffDequotedString);
        IFW32FALSE_EXIT_UNLESS(
            ::SxspDequoteString(
                0,
                pcwszString,
                cchString,
                sba.GetBufferPtr(),
                &cchQuotedString),
                (::GetLastError() == ERROR_INSUFFICIENT_BUFFER),
                fNotEnoughBuffer );


        if ( fNotEnoughBuffer )
        {
            sba.Detach();
            IFW32FALSE_EXIT(buffDequotedString.Win32ResizeBuffer(cchQuotedString, eDoNotPreserveBufferContents));
        }
        else break;
    }

    FN_EPILOG
}

BOOL
SxspCreateAssemblyIdentityFromTextualString(
    PCWSTR pszTextualAssemblyIdentityString,
    PASSEMBLY_IDENTITY *ppAssemblyIdentity
    )
{
    FN_PROLOG_WIN32

    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> pAssemblyIdentity;
    SXS_ASSEMBLY_IDENTITY_ATTRIBUTE_REFERENCE AttributeReference;

    CSmallStringBuffer buffTextualAttributeValue;
    CSmallStringBuffer buffWorkingString;
    CSmallStringBuffer buffNamespaceTwiddle;

    if (ppAssemblyIdentity != NULL)
        *ppAssemblyIdentity = NULL;

    PARAMETER_CHECK(pszTextualAssemblyIdentityString != NULL);
    PARAMETER_CHECK(*pszTextualAssemblyIdentityString != L'\0');
    PARAMETER_CHECK(ppAssemblyIdentity != NULL);

    IFW32FALSE_EXIT(::SxsCreateAssemblyIdentity(0, ASSEMBLY_IDENTITY_TYPE_DEFINITION, &pAssemblyIdentity, 0, NULL));
    IFW32FALSE_EXIT(buffWorkingString.Win32Assign(pszTextualAssemblyIdentityString, ::wcslen(pszTextualAssemblyIdentityString)));

    PCWSTR pcwszIdentityCursor = buffWorkingString;
    PCWSTR pcwszIdentityEndpoint = pcwszIdentityCursor + buffWorkingString.Cch();
    SIZE_T CchAssemblyName = ::StringComplimentSpan(pcwszIdentityCursor, pcwszIdentityEndpoint, L",");

    // Generate the name of the assembly from the first non-comma'd piece of the string
    IFW32FALSE_EXIT(
        ::SxspDequoteString(
            pcwszIdentityCursor,
            CchAssemblyName,
            buffTextualAttributeValue));

    IFW32FALSE_EXIT(
        ::SxspSetAssemblyIdentityAttributeValue(
            0,
            pAssemblyIdentity,
            &s_IdentityAttribute_name,
            buffTextualAttributeValue,
            buffTextualAttributeValue.Cch()));

    // Skip the name and the following comma
    pcwszIdentityCursor += ( CchAssemblyName + 1 );

    // Find the namespace:name=value pieces
    while (pcwszIdentityCursor < pcwszIdentityEndpoint)
    {
        SIZE_T cchAttribName = ::StringComplimentSpan(pcwszIdentityCursor, pcwszIdentityEndpoint, L"=");
        SIZE_T cchAfterNamespace = ::StringReverseComplimentSpan(pcwszIdentityCursor, pcwszIdentityCursor + cchAttribName, L":");

        PCWSTR pcwszAttribName = (pcwszIdentityCursor + cchAttribName - cchAfterNamespace);
        // not accounting for the colon, cchNamespace + cchAfterNamespace == cchAttribName
        SIZE_T cchNamespace = (cchAttribName - cchAfterNamespace);
        cchAttribName = cchAfterNamespace; // now just the length without the namespace
        PCWSTR pcwszNamespace = (cchNamespace != 0) ? pcwszIdentityCursor : NULL;

        // don't count the colon in the length
        if (cchNamespace != 0)
            cchNamespace -= 1;

        // The value is one past the = sign in the chunklet
        PCWSTR pcwszValue = pcwszAttribName + (cchAttribName + 1);

        // Then a quote, then the string...
        PARAMETER_CHECK((pcwszValue < pcwszIdentityEndpoint) && (pcwszValue[0] == L'"'));
        pcwszValue++;
        SIZE_T cchValue = ::StringComplimentSpan(pcwszValue, pcwszIdentityEndpoint, L"\"");

        {
            PCWSTR pcwszChunkEndpoint = pcwszValue + cchValue;
            PARAMETER_CHECK((pcwszChunkEndpoint < pcwszIdentityEndpoint) && (pcwszChunkEndpoint[0] == L'\"'));
        }

        IFW32FALSE_EXIT(
            ::SxspDequoteString(
                pcwszValue,
                cchValue,
                buffTextualAttributeValue));

        if (cchNamespace != 0)
        {
            IFW32FALSE_EXIT(buffNamespaceTwiddle.Win32Assign(pcwszNamespace, cchNamespace));
            IFW32FALSE_EXIT(
                ::SxspDequoteString(
                    pcwszNamespace,
                    cchNamespace,
                    buffNamespaceTwiddle));

            AttributeReference.Namespace = buffNamespaceTwiddle;
            AttributeReference.NamespaceCch = buffNamespaceTwiddle.Cch();
        }
        else
        {
            AttributeReference.Namespace = NULL;
            AttributeReference.NamespaceCch = 0;
        }

        AttributeReference.Name = pcwszAttribName;
        AttributeReference.NameCch = cchAttribName;

        {
            IFW32FALSE_EXIT(
                ::SxspSetAssemblyIdentityAttributeValue(
                    0,
                    pAssemblyIdentity,
                    &AttributeReference,
                    buffTextualAttributeValue,
                    buffTextualAttributeValue.Cch()));
        }

        pcwszIdentityCursor = pcwszValue + cchValue + 1;
        if (pcwszIdentityCursor == pcwszIdentityEndpoint)
        {
            PARAMETER_CHECK(pcwszIdentityCursor[0] == L'\0');
        }
        else if (pcwszIdentityCursor < pcwszIdentityEndpoint)
        {
            PARAMETER_CHECK(pcwszIdentityCursor[0] == L',');
            pcwszIdentityCursor++;
        }
        else
            ORIGINATE_WIN32_FAILURE_AND_EXIT(BadIdentityString, ERROR_INVALID_PARAMETER);
    }

    *ppAssemblyIdentity  = pAssemblyIdentity.Detach();

    FN_EPILOG
}

BOOL
SxspCreateManifestFileNameFromTextualString(
    DWORD           dwFlags,
    ULONG           PathType,
    const CBaseStringBuffer &AssemblyDirectory,
    PCWSTR          pwszTextualAssemblyIdentityString,
    CBaseStringBuffer &sbPathName
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PASSEMBLY_IDENTITY pAssemblyIdentity = NULL;

    PARAMETER_CHECK(pwszTextualAssemblyIdentityString != NULL);

    IFW32FALSE_EXIT(::SxspCreateAssemblyIdentityFromTextualString(pwszTextualAssemblyIdentityString, &pAssemblyIdentity));

    //
    // generate a FULLY PATH for manifest, such as I:\WINDOWS\WinSxS\Manifests\x86_xxxxxxxxxxxxx_6.0.0.0_en-us_cd4c0d12.Manifest
    //
    IFW32FALSE_EXIT(
        ::SxspGenerateSxsPath(
            dwFlags,
            PathType,
            AssemblyDirectory,
            AssemblyDirectory.Cch(),
            pAssemblyIdentity,
            NULL,
            sbPathName));

    fSuccess = TRUE;

Exit:
    if (pAssemblyIdentity != NULL)
        ::SxsDestroyAssemblyIdentity(pAssemblyIdentity);

    return fSuccess ;
}

bool IsCharacterNulOrInSet(WCHAR ch, PCWSTR set)
{
    return (ch == 0 || wcschr(set, ch) != NULL);
}

class CSxsQueryAssemblyInfoLocals
{
public:
    CSxsQueryAssemblyInfoLocals() { }
    ~CSxsQueryAssemblyInfoLocals() { }

    CStringBuffer buffAssemblyPath;
    CStringBuffer sbManifestFullPathFileName;
};

BOOL
SxsQueryAssemblyInfo(
    DWORD dwFlags,
    PCWSTR pwzTextualAssembly,
    ASSEMBLY_INFO *pAsmInfo
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CSmartRef<CAssemblyName> pName;
    BOOL fInstalled = FALSE;
    CSmartPtr<CSxsQueryAssemblyInfoLocals> Locals;

    PARAMETER_CHECK((dwFlags == 0) && (pwzTextualAssembly != NULL));

    IFW32FALSE_EXIT(Locals.Win32Allocate(__FILE__, __LINE__));

    IFCOMFAILED_EXIT(::CreateAssemblyNameObject((LPASSEMBLYNAME *)&pName, pwzTextualAssembly, CANOF_PARSE_DISPLAY_NAME, NULL));
    IFCOMFAILED_EXIT(pName->IsAssemblyInstalled(fInstalled));
    if (pAsmInfo == NULL)
    {
        if (fInstalled)
            FN_SUCCESSFUL_EXIT();

        // the error value "doesn't matter", Darwin compares against S_OK for equality
        ORIGINATE_WIN32_FAILURE_AND_EXIT(AssemblyNotFound, ERROR_NOT_FOUND);
    }

    if (!fInstalled)
    {
        // pAsmInfo->dwAssemblyFlags |= ASSEMBLYINFO_FLAG_NOT_INSTALLED;
        //
        // Darwin wants FAIL instead of FLAG setting
        //
        ORIGINATE_WIN32_FAILURE_AND_EXIT(AssemblyNotInstalled, ERROR_NOT_FOUND);
    }
    else
    {
        CStringBuffer &buffAssemblyPath = Locals->buffAssemblyPath;
        PCWSTR pszInstalledPath = NULL;
        DWORD CchInstalledPath = 0 ;
        BOOL fIsPolicy = FALSE;
        CStringBuffer &sbManifestFullPathFileName = Locals->sbManifestFullPathFileName;


        pAsmInfo->dwAssemblyFlags |= ASSEMBLYINFO_FLAG_INSTALLED;
        IFCOMFAILED_EXIT(pName->DetermineAssemblyType(fIsPolicy));

        if (!fIsPolicy)
        {
            //
            // check whether the assembly has a manifest ONLY
            //
            IFCOMFAILED_EXIT(pName->GetInstalledAssemblyName(
                0,
                SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
                buffAssemblyPath));
            bool fExist = false;

            IFW32FALSE_EXIT(SxspDoesFileExist(0, buffAssemblyPath, fExist));
            if (!fExist)
            {
                IFCOMFAILED_EXIT(
                    pName->GetInstalledAssemblyName(
                        0,
                        SXSP_GENERATE_SXS_PATH_PATHTYPE_MANIFEST,
                        sbManifestFullPathFileName));
                pszInstalledPath = sbManifestFullPathFileName;
                CchInstalledPath = sbManifestFullPathFileName.GetCchAsDWORD();
            }
            else
            {
                pszInstalledPath = buffAssemblyPath;
                CchInstalledPath = buffAssemblyPath.GetCchAsDWORD();
            }
        }
        else // if (fIsPolicy)// it must be a policy
        {
            IFCOMFAILED_EXIT(
                pName->GetInstalledAssemblyName(
                    SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION,
                    SXSP_GENERATE_SXS_PATH_PATHTYPE_POLICY,
                    sbManifestFullPathFileName));

            pszInstalledPath = sbManifestFullPathFileName;
            CchInstalledPath = sbManifestFullPathFileName.GetCchAsDWORD();
        }

        if(pAsmInfo->cchBuf >= 1 + CchInstalledPath) // adding 1 for trailing NULL
        {
            memcpy(pAsmInfo->pszCurrentAssemblyPathBuf, pszInstalledPath, CchInstalledPath * sizeof(WCHAR));
            pAsmInfo->pszCurrentAssemblyPathBuf[CchInstalledPath] = L'\0';
        }
        else
        {
            // HACK!  It's too late to fix this but Darwin sometimes doesn't want to get the path at all;
            // there's no way for them to indicate this today but we'll take the convention that if
            // the buffer length is 0 and the buffer pointer is NULL, we'll not fail with ERROR_INSUFFICENT_BUFFER.
            // mgrier 6/21/2001

            if ((pAsmInfo->cchBuf != 0) ||
                (pAsmInfo->pszCurrentAssemblyPathBuf != NULL))
            {
                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_INFO,
                    "SXS: %s - insufficient buffer passed in.  cchBuf passed in: %u; cchPath computed: %u\n",
                    __FUNCTION__,
                    pAsmInfo->cchBuf,
                    CchInstalledPath + 1
                    );

                pAsmInfo->cchBuf = 1 + CchInstalledPath;

                ORIGINATE_WIN32_FAILURE_AND_EXIT(NoRoom, ERROR_INSUFFICIENT_BUFFER);
            }
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}


BOOL
SxspExpandRelativePathToFull(
    IN PCWSTR wszString,
    IN SIZE_T cchString,
    OUT CBaseStringBuffer &rsbDestination
    )
{
    BOOL bSuccess = FALSE;
    DWORD dwNeededChars = 0;
    CStringBufferAccessor access;

    FN_TRACE_WIN32(bSuccess);

    access.Attach(&rsbDestination);

    //
    // Try to get the path expansion into our own buffer to start with.
    //
    IFW32ZERO_EXIT(dwNeededChars = ::GetFullPathNameW(wszString, (DWORD)access.GetBufferCch(), access.GetBufferPtr(), NULL));

    //
    // Did we need more characters?
    //
    if (dwNeededChars > access.GetBufferCch())
    {
        //
        // Expand out the buffer to be big enough, then try again.  If it fails again,
        // we're just hosed.
        //
        access.Detach();
        IFW32FALSE_EXIT(rsbDestination.Win32ResizeBuffer(dwNeededChars, eDoNotPreserveBufferContents));
        access.Attach(&rsbDestination);
        IFW32ZERO_EXIT(dwNeededChars = ::GetFullPathNameW(wszString, (DWORD)access.GetBufferCch(), access.GetBufferPtr(), NULL));
        if (dwNeededChars > access.GetBufferCch())
        {
            TRACE_WIN32_FAILURE_ORIGINATION(GetFullPathNameW);
            goto Exit;
        }
    }

    FN_EPILOG
}

BOOL
SxspGetShortPathName(
    IN const CBaseStringBuffer &rcbuffLongPathName,
    OUT CBaseStringBuffer &rbuffShortenedVersion
    )
{
    DWORD dw = 0;
    return ::SxspGetShortPathName(rcbuffLongPathName, rbuffShortenedVersion, dw, 0);
}

BOOL
SxspGetShortPathName(
    IN const CBaseStringBuffer &rcbuffLongPathName,
    OUT CBaseStringBuffer &rbuffShortenedVersion,
    DWORD &rdwWin32Error,
    SIZE_T cExceptionalWin32Errors,
    ...
    )
{
    FN_PROLOG_WIN32

    va_list ap;
    CStringBufferAccessor sba;

    rdwWin32Error = ERROR_SUCCESS;

    for (;;)
    {
        DWORD dwRequired = 0;

        if (rbuffShortenedVersion.GetBufferCch() < 2)
        {
            IFW32FALSE_EXIT(
                rbuffShortenedVersion.Win32ResizeBuffer(
                    2,
                    eDoNotPreserveBufferContents));
        }

        sba.Attach(&rbuffShortenedVersion);

        //
        // We were getting stringbuffer corruption here.
        // Assume that GetShortPathNameW might not nul terminate
        // the buffer. Assume that GetShortPathNameW returns
        // either the number of characters written or the requires
        // number of characters.
        //
        dwRequired = ::GetShortPathNameW(
            rcbuffLongPathName,
            sba.GetBufferPtr(),
            sba.GetBufferCchAsDWORD() - 1);
        sba.GetBufferPtr()[sba.GetBufferCchAsDWORD() - 1] = 0;

        if (dwRequired == 0)
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();
            SIZE_T i;

            va_start(ap, cExceptionalWin32Errors);

            for (i=0; i<cExceptionalWin32Errors; i++)
            {
                if (va_arg(ap, DWORD) == dwLastError)
                {
                    rdwWin32Error = dwLastError;
                    break;
                }
            }

            va_end(ap);

            if (rdwWin32Error != ERROR_SUCCESS)
                FN_SUCCESSFUL_EXIT();
#if DBG
            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS.DLL: GetShortPathNameW(%ls) : %lu\n",
                static_cast<PCWSTR>(rcbuffLongPathName),
                dwLastError
                );
#endif
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetShortPathNameW, dwLastError);
        }
        else if (dwRequired >= (sba.GetBufferCch() - 1))
        {
            //
            // If we were merely told that we got back characters
            // filling the buffer and not the required length,
            // double the buffer.
            //
            if (dwRequired <= sba.GetBufferCch())
            {
                dwRequired = (dwRequired + 1) * 2;
            }

            sba.Detach();

            IFW32FALSE_EXIT(
                rbuffShortenedVersion.Win32ResizeBuffer(
                    dwRequired + 1,
                    eDoNotPreserveBufferContents));
        }
        else
        {
            break;
        }
    }

    FN_EPILOG
}

BOOL
SxspValidateIdentity(
    DWORD Flags,
    ULONG Type,
    PCASSEMBLY_IDENTITY AssemblyIdentity
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    PCWSTR pszTemp = NULL;
    SIZE_T cchTemp = 0;
    bool fSyntaxValid = false;
    bool fError = false;
    bool fMissingRequiredAttributes = false;
    bool fInvalidAttributeValues = false;
    BOOL fIsPolicy = FALSE;

    PARAMETER_CHECK((Flags & ~(
                            SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED |
                            SXSP_VALIDATE_IDENTITY_FLAG_POLICIES_NOT_ALLOWED |
                            SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED)) == 0);
    PARAMETER_CHECK((Type == ASSEMBLY_IDENTITY_TYPE_DEFINITION) || (Type == ASSEMBLY_IDENTITY_TYPE_REFERENCE));
    PARAMETER_CHECK(AssemblyIdentity != NULL);

    //
    // only one of these flags is allowed
    //
    PARAMETER_CHECK(
        (Flags & (SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED | SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED)) !=
                 (SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED | SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED));

    IFW32FALSE_EXIT(::SxspDetermineAssemblyType(AssemblyIdentity, fIsPolicy));

    if (fIsPolicy && ((Flags & SXSP_VALIDATE_IDENTITY_FLAG_POLICIES_NOT_ALLOWED) != 0))
    {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE);
    }

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_name,
            &pszTemp,
            &cchTemp));

    if (cchTemp == 0)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE);

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_processorArchitecture,
            &pszTemp,
            &cchTemp));

    if (cchTemp == 0)
        ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE);

    IFW32FALSE_EXIT(
        ::SxspGetAssemblyIdentityAttributeValue(
            SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL,
            AssemblyIdentity,
            &s_IdentityAttribute_version,
            &pszTemp,
            &cchTemp));

    if (cchTemp != 0)
    {
        ASSEMBLY_VERSION av;

        IFW32FALSE_EXIT(CFusionParser::ParseVersion(av, pszTemp, cchTemp, fSyntaxValid));

        if (!fSyntaxValid)
            ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE);
    }

    if ((Flags & (SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED | SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED)) != 0)
    {
        if (((Flags & SXSP_VALIDATE_IDENTITY_FLAG_VERSION_NOT_ALLOWED) != 0) && (cchTemp != 0))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE);
        else if (((Flags & SXSP_VALIDATE_IDENTITY_FLAG_VERSION_REQUIRED) != 0) && (cchTemp == 0))
            ORIGINATE_WIN32_FAILURE_AND_EXIT(MissingType, ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE);
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
SxspGenerateAssemblyNameInRegistry(
    IN PCASSEMBLY_IDENTITY pcAsmIdent,
    OUT CBaseStringBuffer &rbuffRegistryName
    )
{
    FN_PROLOG_WIN32

    //BOOL fIsWin32, fIsPolicy;
    //
    // the policies for the same Dll would be stored in reg separately. So, the RegKeyName needs the version in it,
    // that is, generate the keyName just like assembly manifest
    // See bug 422195
    //
    //IFW32FALSE_EXIT(::SxspDetermineAssemblyType( pcAsmIdent, fIsWin32, fIsPolicy));

    IFW32FALSE_EXIT(::SxspGenerateSxsPath(
        //SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT | ( fIsPolicy ? SXSP_GENERATE_SXS_PATH_FLAG_OMIT_VERSION : 0 ),
        SXSP_GENERATE_SXS_PATH_FLAG_OMIT_ROOT,
        SXSP_GENERATE_SXS_PATH_PATHTYPE_ASSEMBLY,
        NULL,
        0,
        pcAsmIdent,
        NULL,
        rbuffRegistryName));

    FN_EPILOG
}

BOOL
SxspGenerateAssemblyNameInRegistry(
    IN const CBaseStringBuffer &rcbuffTextualString,
    OUT CBaseStringBuffer &rbuffRegistryName
    )
{
    FN_PROLOG_WIN32

    CSmartPtrWithNamedDestructor<ASSEMBLY_IDENTITY, &::SxsDestroyAssemblyIdentity> pAsmIdent;

    IFW32FALSE_EXIT(::SxspCreateAssemblyIdentityFromTextualString(rcbuffTextualString, &pAsmIdent));
    IFW32FALSE_EXIT(::SxspGenerateAssemblyNameInRegistry(pAsmIdent, rbuffRegistryName));

    FN_EPILOG
}

BOOL
SxspGetFullPathName(
    IN  PCWSTR pcwszPathName,
    OUT CBaseStringBuffer &rbuffPathName,
    OUT CBaseStringBuffer *pbuffFilePart
    )
{
    FN_PROLOG_WIN32

    PARAMETER_CHECK(pcwszPathName != NULL);

    rbuffPathName.Clear();
    if ( pbuffFilePart ) pbuffFilePart->Clear();

    do
    {
        CStringBufferAccessor sba;
        DWORD dwRequired;
        PWSTR pcwszFileChunk = NULL;

        sba.Attach(&rbuffPathName);

        dwRequired = ::GetFullPathNameW(
            pcwszPathName,
            sba.GetBufferCchAsDWORD(),
            sba.GetBufferPtr(),
            &pcwszFileChunk );

        //
        // In the strange case that we got a blank path, we'll get back that zero characters
        // are required, but lasterror is ERROR_SUCCESS.  Don't fail, but stop trying.
        //
        if (dwRequired == 0)
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();
            if (dwLastError != ERROR_SUCCESS)
                ORIGINATE_WIN32_FAILURE_AND_EXIT(GetFullPathNameW, dwLastError);
            else
                break;
        }
        else if (dwRequired >= sba.GetBufferCch())
        {
            sba.Detach();
            IFW32FALSE_EXIT(rbuffPathName.Win32ResizeBuffer(dwRequired+1, eDoNotPreserveBufferContents));
        }
        else
        {
            if ( pcwszFileChunk && pbuffFilePart )
            {
                IFW32FALSE_EXIT(pbuffFilePart->Win32Assign(pcwszFileChunk, ::wcslen(pcwszFileChunk)));
            }
            break;
        }

    }
    while ( true );

    FN_EPILOG
}


#define MPR_DLL_NAME        (L"mpr.dll")

BOOL
SxspGetRemoteUniversalName(
    IN PCWSTR pcszPathName,
    OUT CBaseStringBuffer &rbuffUniversalName
    )
{
    FN_PROLOG_WIN32

    CFusionArray<BYTE> baBufferData;
    REMOTE_NAME_INFOW *pRemoteInfoData;
    DWORD dwRetVal = 0;
    CDynamicLinkLibrary dllMpr;
    DWORD (APIENTRY * pfnWNetGetUniversalNameW)(
        LPCWSTR lpLocalPath,
        DWORD    dwInfoLevel,
        LPVOID   lpBuffer,
        LPDWORD  lpBufferSize
        );

    IFW32FALSE_EXIT(dllMpr.Win32LoadLibrary(MPR_DLL_NAME));
    IFW32FALSE_EXIT(dllMpr.Win32GetProcAddress("WNetGetUniversalNameW", &pfnWNetGetUniversalNameW));

    IFW32FALSE_EXIT(baBufferData.Win32SetSize( MAX_PATH * 2, CFusionArray<BYTE>::eSetSizeModeExact));

    for (;;)
    {
        DWORD dwDataUsed = baBufferData.GetSizeAsDWORD();

        dwRetVal = (*pfnWNetGetUniversalNameW)(
            pcszPathName,
            UNIVERSAL_NAME_INFO_LEVEL,
            (PVOID)baBufferData.GetArrayPtr(),
            &dwDataUsed );

        if ( dwRetVal == WN_MORE_DATA )
        {
            IFW32FALSE_EXIT(baBufferData.Win32SetSize(
                dwDataUsed,
                CFusionArray<BYTE>::eSetSizeModeExact )) ;
        }
        else if ( dwRetVal == WN_SUCCESS )
        {
            break;
        }
        else
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(NPGetUniversalName, dwRetVal);
        }
    }

    pRemoteInfoData = (REMOTE_NAME_INFOW*)baBufferData.GetArrayPtr();
    ASSERT( pRemoteInfoData != NULL );

    IFW32FALSE_EXIT( rbuffUniversalName.Win32Assign(
        pRemoteInfoData->lpUniversalName,
        lstrlenW(pRemoteInfoData->lpUniversalName)));

    FN_EPILOG
}



BOOL
SxspGetVolumePathName(
    IN DWORD dwFlags,
    IN PCWSTR pcwszVolumePath,
    OUT CBaseStringBuffer &buffVolumePathName
    )
{
    FN_PROLOG_WIN32

    CStringBuffer buffTempPathName;
    CStringBufferAccessor sba;

    PARAMETER_CHECK((dwFlags & ~SXS_GET_VOLUME_PATH_NAME_NO_FULLPATH) == 0);

    IFW32FALSE_EXIT(::SxspGetFullPathName(pcwszVolumePath, buffTempPathName));
    IFW32FALSE_EXIT(
        buffVolumePathName.Win32ResizeBuffer(
            buffTempPathName.Cch() + 1,
            eDoNotPreserveBufferContents));
    buffVolumePathName.Clear();

    //
    // The documentation for this is somewhat suspect.  It says that the
    // data size required from GetVolumePathNameW will be /less than/
    // the length of the full path of the path name passed in, hence the
    // call to getfullpath above. (This pattern is suggested by MSDN)
    //
    sba.Attach(&buffVolumePathName);
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::GetVolumePathNameW(
            buffTempPathName,
            sba.GetBufferPtr(),
            sba.GetBufferCchAsDWORD()));
    sba.Detach();

    FN_EPILOG
}


BOOL
SxspGetVolumeNameForVolumeMountPoint(
    IN PCWSTR pcwszMountPoint,
    OUT CBaseStringBuffer &rbuffMountPoint
    )
{
    FN_PROLOG_WIN32

    CStringBufferAccessor sba;

    IFW32FALSE_EXIT(rbuffMountPoint.Win32ResizeBuffer(55, eDoNotPreserveBufferContents));
    rbuffMountPoint.Clear();

    sba.Attach(&rbuffMountPoint);
    IFW32FALSE_ORIGINATE_AND_EXIT(
        ::GetVolumeNameForVolumeMountPointW(
            pcwszMountPoint,
            sba.GetBufferPtr(),
            sba.GetBufferCchAsDWORD()));
    sba.Detach();

    FN_EPILOG
}


BOOL
SxspExpandEnvironmentStrings(
    IN PCWSTR pcwszSource,
    OUT CBaseStringBuffer &buffTarget
    )
{
    FN_PROLOG_WIN32

    // be wary about about subtracting one from unsigned zero
    PARAMETER_CHECK(buffTarget.GetBufferCch() != 0);

    //
    // ExpandEnvironmentStrings is very rude and doesn't put the trailing NULL
    // into the target if the buffer isn't big enough. This causes the accessor
    // detach to record a size == to the number of characters in the buffer,
    // which fails the integrity check later on.
    //
    do
    {
        CStringBufferAccessor sba;
        sba.Attach(&buffTarget);

        DWORD dwNecessary =
            ::ExpandEnvironmentStringsW(
                pcwszSource,
                sba.GetBufferPtr(),
                sba.GetBufferCchAsDWORD() - 1);

        if ( dwNecessary == 0 )
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(ExpandEnvironmentStringsW, ::FusionpGetLastWin32Error());
        }
        else if ( dwNecessary >= (sba.GetBufferCch() - 1) )
        {
            (sba.GetBufferPtr())[sba.GetBufferCch()-1] = UNICODE_NULL;
            sba.Detach();
            IFW32FALSE_EXIT(buffTarget.Win32ResizeBuffer(dwNecessary+1, eDoNotPreserveBufferContents));
        }
        else
        {
            break;
        }

    }
    while ( true );

    FN_EPILOG
}




BOOL
SxspDoesMSIStillNeedAssembly(
    IN  PCWSTR pcAsmName,
    OUT BOOL &rfNeedsAssembly
    )
/*++

Purpose:

    Determines whether or not an assembly is still required, according to
    Darwin.  Since Darwin doesn't pass in an assembly reference to the
    installer API's, we have no way of determining whether or not some
    MSI-installed application actually contains a reference to an
    assembly.

Parameters:

    pcAsmIdent      - Identity of the assembly to be checked in text

    rfNeedsAssembly - OUT flag indicating whether or not the assembly is
                      still wanted, according to Darwin.  This function
                      errs on the side of caution, and will send back "true"
                      if this information was unavailable, as well as if the
                      assembly was really necessary.

Returns:

    TRUE if there was no error
    FALSE if there was an error.

--*/
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    CDynamicLinkLibrary dllMSI;
    CSmallStringBuffer  buffAssemblyName;
    UINT (WINAPI *pfMsiProvideAssemblyW)( LPCWSTR, LPCWSTR, DWORD, DWORD, LPWSTR, DWORD* );
    UINT uiError = 0;

    rfNeedsAssembly = TRUE; // err toward caution in the even of an error

    PARAMETER_CHECK(pcAsmName != NULL);

    IFW32FALSE_EXIT(dllMSI.Win32LoadLibrary(MSI_DLL_NAME_W, 0));
    IFW32FALSE_EXIT(dllMSI.Win32GetProcAddress(MSI_PROVIDEASSEMBLY_NAME, &pfMsiProvideAssemblyW));

    //
    // This is based on a detailed reading of the Darwin code.
    //
    uiError = (*pfMsiProvideAssemblyW)(
        pcAsmName,                              // assembly name
        NULL,                                   // full path to .cfg file
        static_cast<DWORD>(INSTALLMODE_NODETECTION_ANY), // install/reinstall mode
        MSIASSEMBLYINFO_WIN32ASSEMBLY,          // dwAssemblyInfo
        NULL,                                   // returned path buffer
        0);                                     // in/out returned path character count
    switch (uiError)
    {
    default:
    case ERROR_BAD_CONFIGURATION:
    case ERROR_INVALID_PARAMETER:
		::SetLastError(uiError);
        ORIGINATE_WIN32_FAILURE_AND_EXIT(MsiProvideAssemblyW, uiError);
        break;
    case ERROR_UNKNOWN_COMPONENT:
        rfNeedsAssembly = FALSE;
        fSuccess = TRUE;
        goto Exit;
    case NO_ERROR:
        rfNeedsAssembly = TRUE;
        fSuccess = TRUE;
        goto Exit;
    }
    fSuccess = FALSE; // unusual
Exit:
    return fSuccess;
}

BOOL
SxspMoveFilesUnderDir(
    DWORD dwFlags,
    CBaseStringBuffer & sbSourceDir,
    CBaseStringBuffer & sbDestDir,
    DWORD dwMoveFileFlags,
    WIN32_FIND_DATAW &findData // avoid allocating one of these in each recursive frame
    )
{
    FN_PROLOG_WIN32

    SIZE_T CchDestDir = 0;
    SIZE_T CchSourceDir = 0;
    CFindFile findFile;

    PARAMETER_CHECK((dwFlags & ~SXSP_MOVE_FILE_FLAG_COMPRESSION_AWARE) == 0);
	bool fExist = false;
	IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY, sbSourceDir, fExist));
	if (!fExist)
	{
        //
        // File or path not found propagated from GetFileAttributes is probably
        // generally better here.
        //
		PARAMETER_CHECK(fExist);
	}

	fExist = false;
	IFW32FALSE_EXIT(::SxspDoesFileExist(SXSP_DOES_FILE_EXIST_FLAG_CHECK_DIRECTORY_ONLY, sbDestDir, fExist));
	if (!fExist)
	{
        //
        // Other than at the top of the call tree, just CreateDirectory "one"
        // is sufficient.
        //
		IFW32FALSE_EXIT(::FusionpCreateDirectories(sbDestDir, sbDestDir.Cch()));
	}

    IFW32FALSE_EXIT(sbSourceDir.Win32EnsureTrailingPathSeparator());
    IFW32FALSE_EXIT(sbDestDir.Win32EnsureTrailingPathSeparator());

    CchDestDir = sbDestDir.Cch();
    CchSourceDir = sbSourceDir.Cch();

    IFW32FALSE_EXIT(sbSourceDir.Win32Append(L"*", 1));

    IFW32FALSE_EXIT(findFile.Win32FindFirstFile(sbSourceDir, &findData));

    do {
        // skip . and ..
        if (::FusionpIsDotOrDotDot(findData.cFileName))
            continue;

        sbDestDir.Left(CchDestDir);
        sbSourceDir.Left(CchSourceDir);

        IFW32FALSE_EXIT(sbDestDir.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));
        IFW32FALSE_EXIT(sbSourceDir.Win32Append(findData.cFileName, ::wcslen(findData.cFileName)));

        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            //
            // call itself recursively
            //
            IFW32FALSE_EXIT(::SxspMoveFilesUnderDir(dwFlags, sbSourceDir, sbDestDir, dwMoveFileFlags, findData));
        }

        if ((dwFlags & SXSP_MOVE_FILE_FLAG_COMPRESSION_AWARE) != 0)
        {
            IFW32FALSE_EXIT(::SxspInstallMoveFileExW(sbSourceDir, sbDestDir, dwMoveFileFlags));
        }
        else
        {
            IFW32FALSE_ORIGINATE_AND_EXIT(::MoveFileExW(sbSourceDir, sbDestDir, dwMoveFileFlags));
        }

    } while (::FindNextFileW(findFile, &findData));

    if (::FusionpGetLastWin32Error() != ERROR_NO_MORE_FILES)
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s(): FindNextFile() failed:%ld\n",
            __FUNCTION__,
            ::FusionpGetLastWin32Error());
        goto Exit;
    }

    if (!findFile.Win32Close())
    {
        ::FusionpDbgPrintEx(
            FUSION_DBG_LEVEL_ERROR,
            "SXS.DLL: %s(): FindClose() failed:%ld\n",
            __FUNCTION__,
            ::FusionpGetLastWin32Error());
        goto Exit;
    }

    FN_EPILOG
}

BOOL
SxspMoveFilesUnderDir(
    DWORD dwFlags,
    CBaseStringBuffer &sbSourceDir,
    CBaseStringBuffer &sbDestDir,
    DWORD dwMoveFileFlags)
{
    WIN32_FIND_DATAW findData; // avoid allocating one of these in each recursive frame

    return SxspMoveFilesUnderDir(dwFlags, sbSourceDir, sbDestDir, dwMoveFileFlags, findData);
}

BOOL
SxspGenerateNdpGACPath(
    IN DWORD dwFlags,
    IN PCASSEMBLY_IDENTITY pAssemblyIdentity,
    IN OUT PPROBING_ATTRIBUTE_CACHE ppac,
    OUT CBaseStringBuffer &rPathBuffer)
/*++

Description:

    SxspGenerateNdpGACPath

    Generate a path into the NDP GAC for a given assembly identity.

Parameters:

    dwFlags
        Flags to modify function behavior.  All undefined bits must be zero.

    pAssemblyIdentity
        Pointer to assembly identity for which to generate a path.

    rPathBuffer
        Reference to string buffer to fill in.

--*/
{
    FN_PROLOG_WIN32

    SIZE_T cchName = 0;
    SIZE_T cchLanguage = 0;
    SIZE_T cchPublicKeyToken = 0;
    SIZE_T cchVersion = 0;
    PCWSTR pszName = NULL;
    PCWSTR pszLanguage = NULL;
    PCWSTR pszPublicKeyToken = NULL;
    PCWSTR pszVersion = NULL;

    PARAMETER_CHECK(dwFlags == 0);
    PARAMETER_CHECK(pAssemblyIdentity != NULL);

    rPathBuffer.Clear();

#define GET(x, y, z) \
    do { \
        if (ppac != NULL) { \
            if ((ppac->dwFlags & PROBING_ATTRIBUTE_CACHE_FLAG_GOT_ ## z) == 0) { \
                IFW32FALSE_EXIT( \
                    ::SxspGetAssemblyIdentityAttributeValue( \
                    SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, \
                    pAssemblyIdentity, \
                    &s_IdentityAttribute_ ## x, \
                    &psz ## y, \
                    &cch ## y)); \
                ppac->psz ## y = psz ## y; \
                ppac->cch ## y = cch ## y; \
                ppac->dwFlags |= PROBING_ATTRIBUTE_CACHE_FLAG_GOT_ ## z; \
            } else { \
                psz ## y = ppac->psz ## y; \
                cch ## y = ppac->cch ## y; \
            } \
        } else { \
            IFW32FALSE_EXIT( \
                ::SxspGetAssemblyIdentityAttributeValue( \
                SXSP_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_VALUE_FLAG_NOT_FOUND_RETURNS_NULL, \
                pAssemblyIdentity, \
                &s_IdentityAttribute_ ## x, \
                &psz ## y, \
                &cch ## y)); \
        } \
    } while (0)

    GET(name, Name, NAME);
    GET(language, Language, LANGUAGE);
    GET(publicKeyToken, PublicKeyToken, PUBLIC_KEY_TOKEN);
    GET(version, Version, VERSION);

#undef GET

    IFW32FALSE_EXIT(
        rPathBuffer.Win32AssignW(
            9,
            USER_SHARED_DATA->NtSystemRoot, -1,
            L"\\assembly\\GAC\\", -1,
            pszName, static_cast<INT>(cchName),
            L"\\", 1,
            pszVersion, static_cast<INT>(cchVersion),
            L"_", 1,
            pszLanguage, static_cast<INT>(cchLanguage),
            L"_", 1,
            pszPublicKeyToken, static_cast<INT>(cchPublicKeyToken)));

    FN_EPILOG
}

BOOL
SxspIsFileNameValidForManifest(
    const CBaseStringBuffer &rsbFileName,
    bool &rfValid)
{
    FN_PROLOG_WIN32

    static const PCWSTR s_rgDotPatterns[] = {
        L"..\\",
        L"../",
        L"\\..",
        L"/.."
    };

    //
    // Rules for a file name:
    // - Must be 'relative' in the eyes of Rtl
    // - Must not contain ../, ..\, /.., or \..
    //

    rfValid = false;

    //
    // The string has to be less than max-unicode-string max, and it has to
    // be a relative path, and it can't contain the above pattern of dots
    // and slashes.
    //
    if (::SxspDetermineDosPathNameType(rsbFileName) == RtlPathTypeRelative)
    {
        //
        // Ensure that none of the patterns are there.
        //
        for (SIZE_T c = 0; c < NUMBER_OF(s_rgDotPatterns); c++)
        {
            if (wcsstr(rsbFileName, s_rgDotPatterns[c]) != NULL)
                break;
        }

        //
        // Ran to the end of the query items w/o matching
        //
        if (c == NUMBER_OF(s_rgDotPatterns))
            rfValid = true;
    }


    FN_EPILOG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsservice\makefile.inc ===
C_DEFINES=-DWIN32 -DUNICODE -D_UNICODE
RCOPTIONS=-N
UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsmain\sxsmain.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsmain.cpp

Abstract:

Author:

Revision History:

--*/
#include "stdinc.h"
#include <windows.h>
#include "sxsp.h"
#include "fusioneventlog.h"
#include "fusiontrace.h"
#include "fusionsha1.h"

extern CRITICAL_SECTION g_csHashFile;

//
// This typedef of a function represents a dll-main startup function.  These are
// called during a DLL_PROCESS_ATTACH call to SxsDllMain in the order they're listed.
//
typedef BOOL (WINAPI *PFNStartupPointer)(
    HINSTANCE hDllInstnace,
    DWORD dwReason,
    PVOID pvReason
   );

BOOL WINAPI DllStartup_CrtInit(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI FusionpEventLogMain(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_HeapSetup(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_ActCtxContributors(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI FusionpCryptoContext_DllMain(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_AtExitList(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_AlternateAssemblyStoreRoot(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved);
BOOL WINAPI DllStartup_SetupLog(HINSTANCE Module, DWORD Reason, PVOID Reserved);
BOOL WINAPI DllStartup_FileHashCriticalSectionInitialization(HINSTANCE Module, DWORD Reason, PVOID Reserved);
BOOL WINAPI FusionpAreWeInOSSetupModeMain(HINSTANCE Module, DWORD Reason, PVOID Reserved);

#define MAKE_STARTUP_RECORD(f) { &f, L#f }

#define SXSP_DLLMAIN_ATTACHED 0x01

const struct StartupFunctionRecord {
    PFNStartupPointer Handler;
    PCWSTR Name;
} g_SxspDllMainStartupPointers[] = {
    MAKE_STARTUP_RECORD(DllStartup_CrtInit),
    MAKE_STARTUP_RECORD(DllStartup_HeapSetup),
    MAKE_STARTUP_RECORD(FusionpEventLogMain),
    MAKE_STARTUP_RECORD(DllStartup_AtExitList),
    MAKE_STARTUP_RECORD(DllStartup_AlternateAssemblyStoreRoot),
    MAKE_STARTUP_RECORD(DllStartup_ActCtxContributors),
    MAKE_STARTUP_RECORD(FusionpCryptoContext_DllMain),
    MAKE_STARTUP_RECORD(DllStartup_SetupLog),
    MAKE_STARTUP_RECORD(DllStartup_FileHashCriticalSectionInitialization),
    MAKE_STARTUP_RECORD(FusionpAreWeInOSSetupModeMain)
};

BYTE g_SxspDllMainStartupStatus[NUMBER_OF(g_SxspDllMainStartupPointers)];

HINSTANCE g_hInstance;

/*
NTRAID#NTBUG9-591174-2002/03/31-JayKrell
Replace all SLists with criticalsection and CDeque.
*/
SLIST_HEADER sxspAtExitList;

PCWSTR g_AlternateAssemblyStoreRoot;
BOOL g_WriteRegistryAnyway;

#if DBG
PCSTR
FusionpDllMainReasonToString(DWORD Reason)
{
    PCSTR String;

    String =
        (Reason ==  DLL_THREAD_ATTACH) ?  "DLL_THREAD_ATTACH" :
        (Reason ==  DLL_THREAD_DETACH) ?  "DLL_THREAD_DETACH" :
        (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH" :
        (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH" :
        "";

    return String;
}
#endif

extern "C"
BOOL
WINAPI
SxsDllMain(
    HINSTANCE hInst,
    DWORD dwReason,
    PVOID pvReserved
    )
//
// We do not call DisableThreadLibraryCalls
// because some/all versions of the CRT do work in the thread calls,
// allocation and free of the per thread data.
//
{
    //
    // Several "oca" (online crash analysis) bugs show
    // Sxs.dll in various places in DllMain(process_detach) in hung apps.
    // We load in many processes for oleaut/typelibrary support.
    //
    // When ExitProcess is called, it is impossible to leak memory and kernel handles,
    // so it is sufficient and preferrable to do nothing quickly than to go through
    // and free each individual resource.
    //
    // The pvReserved parameter is actually documented as having a meaning.
    // Its NULLness indicates if we are in FreeLibrary or ExitProcess.
    //
    if (dwReason == DLL_PROCESS_DETACH && pvReserved != NULL)
    {
        // For ExitProcess, do nothing quickly.
        return TRUE;
    }

    BOOL    fResult = FALSE;
    SIZE_T  nCounter = 0;

#if DBG
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_VERBOSE,
        "SXS: 0x%lx.0x%lx, %s() %s\n",
        GetCurrentProcessId(),
        GetCurrentThreadId(),
        __FUNCTION__,
        FusionpDllMainReasonToString(dwReason));
#endif

    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:
        if (!g_SxspDllMainStartupPointers[0].Handler(hInst, dwReason, pvReserved))
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS: %s - %ls(DLL_THREAD_ATTACH) failed. Last WinError 0x%08x (%d).\n",
                __FUNCTION__,
                g_SxspDllMainStartupPointers[0].Name,
                dwLastError,
                dwLastError);

            ::SxsDllMain(hInst, DLL_THREAD_DETACH, pvReserved);

            ::FusionpSetLastWin32Error(dwLastError);
            goto Exit;
        }

        break;
    case DLL_THREAD_DETACH:
        if (!g_SxspDllMainStartupPointers[0].Handler(hInst, dwReason, pvReserved))
        {
            const DWORD dwLastError = ::FusionpGetLastWin32Error();

            ::FusionpDbgPrintEx(
                FUSION_DBG_LEVEL_ERROR,
                "SXS: %s - %ls(DLL_THREAD_ATTACH) failed. Last WinError 0x%08x (%d).\n",
                __FUNCTION__,
                g_SxspDllMainStartupPointers[0].Name,
                dwLastError,
                dwLastError);
            // Eat the error, the loader ignores it.
        }
        break;

    case DLL_PROCESS_ATTACH:
        ASSERT_NTC(hInst);
        g_hInstance = hInst;

        for (nCounter = 0; nCounter != NUMBER_OF(g_SxspDllMainStartupPointers) ; ++nCounter)
        {
            const SIZE_T nIndex = nCounter;
            if (g_SxspDllMainStartupPointers[nIndex].Handler(hInst, dwReason, pvReserved))
            {
                g_SxspDllMainStartupStatus[nIndex] |= SXSP_DLLMAIN_ATTACHED;
            }
            else
            {
                const DWORD dwLastError = ::FusionpGetLastWin32Error();
                //
                // It's a little iffy to set the bit even upon failure, but
                // we do this because we assume individual functions do not handle
                // rollback internally upon attach failure.
                //
                g_SxspDllMainStartupStatus[nIndex] |= SXSP_DLLMAIN_ATTACHED;

                ::FusionpDbgPrintEx(
                    FUSION_DBG_LEVEL_ERROR,
                    "SXS: %s - %ls(DLL_PROCESS_ATTACH) failed. Last WinError 0x%08x (%d).\n",
                    __FUNCTION__,
                    g_SxspDllMainStartupPointers[nIndex].Name,
                    dwLastError,
                    dwLastError);

                // pvReserved has approximately the same defined meaning for attach and detach
                ::SxsDllMain(hInst, DLL_PROCESS_DETACH, pvReserved);

                ::FusionpSetLastWin32Error(dwLastError);
                goto Exit;
            }
        }

        break;
    case DLL_PROCESS_DETACH:
        //
        // We always succeed DLL_PROCESS_DETACH, and we do not
        // short circuit it upon failure. The loader in fact
        // ignores what we return.
        //
        for (nCounter = NUMBER_OF(g_SxspDllMainStartupPointers) ; nCounter != 0 ; --nCounter)
        {
            const SIZE_T nIndex = nCounter - 1;
            if ((g_SxspDllMainStartupStatus[nIndex] & SXSP_DLLMAIN_ATTACHED) != 0)
            {
                g_SxspDllMainStartupStatus[nIndex] &= ~SXSP_DLLMAIN_ATTACHED;
                if (!g_SxspDllMainStartupPointers[nIndex].Handler(hInst, dwReason, pvReserved))
                {
                    const DWORD dwLastError = ::FusionpGetLastWin32Error();

                    ::FusionpDbgPrintEx(
                        FUSION_DBG_LEVEL_ERROR,
                        "SXS: %s - %ls(DLL_PROCESS_DETACH) failed. Last WinError 0x%08x (%d).\n",
                        __FUNCTION__,
                        g_SxspDllMainStartupPointers[nIndex].Name,
                        dwLastError,
                        dwLastError);
                }
            }
        }
        break;
    }
    fResult = TRUE;
Exit:
    return fResult;
}

/*
NTRAID#NTBUG9-591174-2002/03/31-JayKrell
Replace all SLists with criticalsection and CDeque.
*/
BOOL
SxspAtExit(
    CCleanupBase* pCleanup
    )
{
    if (!pCleanup->m_fInAtExitList)
    {
        SxspInterlockedPushEntrySList(&sxspAtExitList, pCleanup);
        pCleanup->m_fInAtExitList = true;
    }
    return TRUE;
}

/*
NTRAID#NTBUG9-591174-2002/03/31-JayKrell
Replace all SLists with criticalsection and CDeque.
*/
BOOL
SxspTryCancelAtExit(
    CCleanupBase* pCleanup
    )
{
    if (!pCleanup->m_fInAtExitList)
        return FALSE;

    if (::SxspIsSListEmpty(&sxspAtExitList))
    {
        pCleanup->m_fInAtExitList = false;
        return FALSE;
    }

    PSLIST_ENTRY pTop = ::SxspInterlockedPopEntrySList(&sxspAtExitList);
    if (pTop == pCleanup)
    {
        pCleanup->m_fInAtExitList = false;
        return TRUE;
    }

    if (pTop != NULL)
        ::SxspInterlockedPushEntrySList(&sxspAtExitList, pTop);
    return FALSE;
}

#define COMMON_HANDLER_PROLOG(dwReason) \
    {  \
        ASSERT_NTC(\
            (dwReason == DLL_PROCESS_ATTACH) || \
            (dwReason == DLL_PROCESS_DETACH) \
       ); \
        if (!(\
            (dwReason == DLL_PROCESS_ATTACH) || \
            (dwReason == DLL_PROCESS_DETACH) \
       )) goto Exit; \
    }

BOOL WINAPI
DllStartup_AtExitList(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved)
{
    BOOL fSuccess = FALSE;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    case DLL_PROCESS_DETACH:
        {
            CCleanupBase *pCleanup = NULL;
            while (pCleanup = UNCHECKED_DOWNCAST<CCleanupBase*>(SxspPopEntrySList(&sxspAtExitList)))
            {
                pCleanup->m_fInAtExitList = false;
                pCleanup->DeleteYourself();
            }

            fSuccess = TRUE;
        }
        break;

    case DLL_PROCESS_ATTACH:
        ::SxspInitializeSListHead(&sxspAtExitList);
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}

extern "C"
{

BOOL g_fInCrtInit;

//
// This is the internal CRT routine that does the bulk of
// the initialization and uninitialization.
//
BOOL
WINAPI
_CRT_INIT(
    HINSTANCE hDllInstnace,
    DWORD dwReason,
    PVOID pvReason
    );

void
SxspCrtRaiseExit(
    PCSTR    pszCaller,
    int      crtError
    )
//
// all the various CRT functions that end up calling ExitProcess end up here
// see crt0dat.c
//
{
    const static struct
    {
        NTSTATUS ntstatus;
        PCSTR    psz;
    } rgErrors[] =
    {
        { STATUS_FATAL_APP_EXIT, "STATUS_FATAL_APP_EXIT" },
        { STATUS_DLL_INIT_FAILED, "STATUS_DLL_INIT_FAILED" },
    };
    const ULONG nInCrtInit = g_fInCrtInit ? 1 : 0;

    //
    // if (!g_fInCrtInit), then throwing STATUS_DLL_INIT_FAILED is dubious,
    // but there no clearly good answer, maybe STATUS_NO_MEMORY, maybe introduce
    // an NTSTATUS facility to wrap the values in.
    //
    ::FusionpDbgPrintEx(
        FUSION_DBG_LEVEL_ERROR,
        "SXS: [0x%lx.0x%lx] %s(crtError:%d, g_fInCrtInit:%s) calling RaiseException(%08lx %s)\n",
        GetCurrentProcessId(),
        GetCurrentThreadId(),
        pszCaller,
        crtError,
        nInCrtInit ? "true" : "false",
        rgErrors[nInCrtInit].ntstatus,
        rgErrors[nInCrtInit].psz
        );
    ::RaiseException(
        static_cast<DWORD>(rgErrors[nInCrtInit].ntstatus),
        0, // flags
        0, // number of extra parameters
        NULL); // extra parameters
    //
    // RaiseException returns void, and generally doesn't return, though it
    // can if you intervene in a debugger.
    //
}

extern void (__cdecl * _aexit_rtn)(int);

void
__cdecl
SxsCrtAExitRoutine(
    int crtError
    )
//
// This is our replacement for an internal CRT routine that otherwise
// calls ExitProcess.
//
{
    SxspCrtRaiseExit(__FUNCTION__, crtError);
}

}

/*
NTRAID#NTBUG9-591174-2002/03/31-JayKrell
It'd be nice if we could just use msvcrt.dll without this hacking..
*/
BOOL WINAPI
DllStartup_CrtInit(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved)
/*
This mess is because
 we need destructors to run, even if there is an exception
 the startup code in msvcrt.dll and libcmt.lib is not very good
   it tends to call MessageBox and/or ExitProcess upon out of memory
   we need it to simply propagate an error
*/
{
#if !FUSION_WIN
    //
    // having this do-nothing function makes our DLL_THREAD_ATTACH handling simpler.
    //
    return TRUE;
#else
    BOOL fSuccess = FALSE;
    DWORD dwExceptionCode = 0;

    __try
    {
        __try
        {
            g_fInCrtInit = TRUE;
            if (dwReason == DLL_PROCESS_ATTACH)
            {
                _aexit_rtn = SxsCrtAExitRoutine;
                //
                // __app_type and __error_mode determine if
                // _CRT_INIT calls MessageBox or WriteFile(GetStdHandle()) upon errors.
                // MessageBox is a big nono in csrss.
                // WriteFile we expect to fail, but that's ok, and they don't check
                // the return value.
                //
                // It should be sufficient to set __error_mode.
                //
                _set_error_mode(_OUT_TO_STDERR);
            }
            fSuccess = _CRT_INIT(hInstance, dwReason, pvReserved);
        }
        __finally
        {
            g_fInCrtInit = FALSE;
        }
    }
    __except(
            (   (dwExceptionCode = GetExceptionCode()) == STATUS_DLL_INIT_FAILED
              || dwExceptionCode == STATUS_FATAL_APP_EXIT
            )
            ? EXCEPTION_EXECUTE_HANDLER
            : EXCEPTION_CONTINUE_SEARCH)
    {
    }
    return fSuccess;
#endif // FUSION_WIN
}

BOOL WINAPI
DllStartup_HeapSetup(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved)
{
    BOOL fSuccess = FALSE;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        fSuccess = FusionpInitializeHeap(hInstance);
        break;
    case DLL_PROCESS_DETACH:
#if defined(FUSION_DEBUG_HEAP)
        ::FusionpDumpHeap(L"");
#endif
        ::FusionpUninitializeHeap();
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}



BOOL WINAPI
DllStartup_ActCtxContributors(HINSTANCE hInstance, DWORD dwReason, PVOID pvReserved)
{
    BOOL fSuccess = FALSE;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        fSuccess = SxspInitActCtxContributors();
        break;
    case DLL_PROCESS_DETACH:
        SxspUninitActCtxContributors();
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}


BOOL
WINAPI
DllStartup_AlternateAssemblyStoreRoot(HINSTANCE, DWORD dwReason, PVOID pvReserved)
{
    BOOL fSuccess = FALSE;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    case DLL_PROCESS_DETACH:
        if (g_AlternateAssemblyStoreRoot != NULL)
        {
            CSxsPreserveLastError ple;
            delete[] const_cast<PWSTR>(g_AlternateAssemblyStoreRoot);
            g_AlternateAssemblyStoreRoot = NULL;
            ple.Restore();
        }
        fSuccess = TRUE;
        break;

    case DLL_PROCESS_ATTACH:
        g_AlternateAssemblyStoreRoot = NULL;
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}

BOOL
WINAPI
DllStartup_FileHashCriticalSectionInitialization(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID pvReserved
    )
{
    BOOL fSuccess = FALSE;
    //
    // We're always called back on disconnect, which isn't really a bug,
    // but a different contract that this can't uphold.  Instead, we'll
    // keep rollback information here about whether or not the csec was
    // initialized.
    //
    static BOOL s_fCritSecCreated;

    COMMON_HANDLER_PROLOG(dwReason);

    switch (dwReason)
    {
    case DLL_PROCESS_DETACH:
        if (s_fCritSecCreated)
        {
            ::DeleteCriticalSection(&g_csHashFile);
            s_fCritSecCreated = FALSE;
        }
        fSuccess = TRUE;
        break;

    case DLL_PROCESS_ATTACH:
        if (!s_fCritSecCreated)
        {
            if (!::FusionpInitializeCriticalSection(&g_csHashFile))
                goto Exit;
            s_fCritSecCreated = TRUE;
        }
        fSuccess = TRUE;
        break;
    }

Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsservice\client\sxsservice_client.c ===
#include <sxsservice_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxs\windowclass.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "stdinc.h"
#include "sxsp.h"

DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(name);
DECLARE_STD_ATTRIBUTE_NAME_DESCRIPTOR(versioned);

typedef struct _WINDOW_CLASS_CONTEXT
{
    _WINDOW_CLASS_CONTEXT() { }

    CSmallStringBuffer m_FileNameBuffer;
    bool m_Versioned;
private:
    _WINDOW_CLASS_CONTEXT(const _WINDOW_CLASS_CONTEXT &);
    void operator =(const _WINDOW_CLASS_CONTEXT &);

} WINDOW_CLASS_CONTEXT, *PWINDOW_CLASS_CONTEXT;

typedef struct _WINDOW_CLASS_ENTRY
{
    _WINDOW_CLASS_ENTRY() { }

    CSmallStringBuffer m_FileNameBuffer;
    CSmallStringBuffer m_VersionSpecificWindowClassNameBuffer;

private:
    _WINDOW_CLASS_ENTRY(const _WINDOW_CLASS_ENTRY &);
    void operator =(const _WINDOW_CLASS_ENTRY &);
} WINDOW_CLASS_ENTRY, *PWINDOW_CLASS_ENTRY;

VOID
__fastcall
SxspWindowClassRedirectionContributorCallback(
    PACTCTXCTB_CALLBACK_DATA Data
    )
{
    FN_TRACE();
    PSTRING_SECTION_GENERATION_CONTEXT SSGenContext = (PSTRING_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext;
    PWINDOW_CLASS_CONTEXT WindowClassContext = NULL;
    PWINDOW_CLASS_ENTRY Entry = NULL; // deleted on exit if not NULL

    if (SSGenContext != NULL)
        WindowClassContext = (PWINDOW_CLASS_CONTEXT) ::SxsGetStringSectionGenerationContextCallbackContext(SSGenContext);

    switch (Data->Header.Reason)
    {
    case ACTCTXCTB_CBREASON_ACTCTXGENBEGINNING:
        {
            Data->GenBeginning.Success = FALSE;

            INTERNAL_ERROR_CHECK(WindowClassContext == NULL);

            if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
            {
                // NTRAID#NTBUG9 - 590977 - 2002/03/30 - mgrier - use smart pointer class here
                IFALLOCFAILED_EXIT(WindowClassContext = new WINDOW_CLASS_CONTEXT);

                if (!::SxsInitStringSectionGenerationContext(
                        &SSGenContext,
                        ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION_FORMAT_WHISTLER,
                        TRUE,
                        &::SxspWindowClassRedirectionStringSectionGenerationCallback,
                        WindowClassContext))
                {
                    FUSION_DELETE_SINGLETON(WindowClassContext);
                    WindowClassContext = NULL;
                    goto Exit;
                }

                Data->Header.ActCtxGenContext = SSGenContext;
            }

            Data->GenBeginning.Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_ACTCTXGENENDED:
        if (SSGenContext != NULL)
        {
            ::SxsDestroyStringSectionGenerationContext(SSGenContext);
            SSGenContext = NULL;
        }
        FUSION_DELETE_SINGLETON(WindowClassContext);
        WindowClassContext = NULL;
        break;

    case ACTCTXCTB_CBREASON_ALLPARSINGDONE:
        {
            Data->AllParsingDone.Success = FALSE;
            if (SSGenContext != NULL)
                IFW32FALSE_EXIT(::SxsDoneModifyingStringSectionGenerationContext(SSGenContext));
            Data->AllParsingDone.Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_GETSECTIONSIZE:
        {
            Data->GetSectionSize.Success = FALSE;
            INTERNAL_ERROR_CHECK(SSGenContext != NULL);
            IFW32FALSE_EXIT(::SxsGetStringSectionGenerationContextSectionSize(SSGenContext, &Data->GetSectionSize.SectionSize));
            Data->GetSectionSize.Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_PCDATAPARSED:
        {
            Data->PCDATAParsed.Success = FALSE;

            if ((Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT) &&
                (Data->PCDATAParsed.ParseContext->XMLElementDepth == 3) &&
                (::FusionpCompareStrings(
                    Data->PCDATAParsed.ParseContext->ElementPath,
                    Data->PCDATAParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^windowClass",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^windowClass") - 1,
                    false) == 0))
            {
                SIZE_T VersionCch;
                PCWSTR pwszVersion = NULL;

                INTERNAL_ERROR_CHECK(SSGenContext != NULL);
                INTERNAL_ERROR_CHECK(WindowClassContext != NULL);

                // NTRAID#NTBUG9 - 590977 - 2002/03/30 - mgrier - use smart pointer class here
                IFALLOCFAILED_EXIT(Entry = new WINDOW_CLASS_ENTRY);

                IFW32FALSE_EXIT(Entry->m_FileNameBuffer.Win32Assign(WindowClassContext->m_FileNameBuffer));

                IFW32FALSE_EXIT(::SxspGetAssemblyIdentityAttributeValue(0, Data->ElementParsed.AssemblyContext->AssemblyIdentity, &s_IdentityAttribute_version, &pwszVersion, &VersionCch));

                if (WindowClassContext->m_Versioned)
                {
                    IFW32FALSE_EXIT(Entry->m_VersionSpecificWindowClassNameBuffer.Win32Assign(pwszVersion, VersionCch));
                    IFW32FALSE_EXIT(Entry->m_VersionSpecificWindowClassNameBuffer.Win32Append(L"!", 1));
                }

                IFW32FALSE_EXIT(Entry->m_VersionSpecificWindowClassNameBuffer.Win32Append(Data->PCDATAParsed.Text, Data->PCDATAParsed.TextCch));

                IFW32FALSE_EXIT(
                    ::SxsAddStringToStringSectionGenerationContext(
                        (PSTRING_SECTION_GENERATION_CONTEXT) Data->Header.ActCtxGenContext,
                        Data->PCDATAParsed.Text,
                        Data->PCDATAParsed.TextCch,
                        Entry,
                        Data->PCDATAParsed.AssemblyContext->AssemblyRosterIndex,
                        ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME));

                // Prevent deletion in exit path...
                Entry = NULL;
            }

            // Everything's groovy!
            Data->PCDATAParsed.Success = TRUE;
            break;
        }


    case ACTCTXCTB_CBREASON_ELEMENTPARSED:
        {
            Data->ElementParsed.Success = FALSE;

            if ((Data->ElementParsed.ParseContext->XMLElementDepth == 2) &&
                (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file") - 1,
                    false) == 0))
            {
                CStringBuffer FileNameBuffer;
                bool fFound = false;
                SIZE_T cb;

                // capture the name of the file we're parsing...

                IFW32FALSE_EXIT(
                    ::SxspGetAttributeValue(
                        0,
                        &s_AttributeName_name,
                        &Data->ElementParsed,
                        fFound,
                        sizeof(FileNameBuffer),
                        &FileNameBuffer,
                        cb,
                        NULL,
                        0));

                // If there's no NAME attribute, someone else will puke; we'll handle it
                // gracefully.
                if (fFound)
                {
                    if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                    {
                        INTERNAL_ERROR_CHECK(WindowClassContext != NULL);
                        IFW32FALSE_EXIT(WindowClassContext->m_FileNameBuffer.Win32Assign(FileNameBuffer));
                    }
                }
            }
            else if ((Data->ElementParsed.ParseContext->XMLElementDepth == 3) &&
                (::FusionpCompareStrings(
                    Data->ElementParsed.ParseContext->ElementPath,
                    Data->ElementParsed.ParseContext->ElementPathCch,
                    L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^windowClass",
                    NUMBER_OF(L"urn:schemas-microsoft-com:asm.v1^assembly!urn:schemas-microsoft-com:asm.v1^file!urn:schemas-microsoft-com:asm.v1^windowClass") - 1,
                    false) == 0))
            {
                bool fVersioned = true;
                bool fFound = false;
                SIZE_T cbBytesWritten;

                IFW32FALSE_EXIT(
                    ::SxspGetAttributeValue(
                        0,
                        &s_AttributeName_versioned,
                        &Data->ElementParsed,
                        fFound,
                        sizeof(fVersioned),
                        &fVersioned,
                        cbBytesWritten,
                        &::SxspValidateBoolAttribute,
                        0));

                if (!fFound)
                    fVersioned = true;

                if (Data->Header.ManifestOperation == MANIFEST_OPERATION_GENERATE_ACTIVATION_CONTEXT)
                {
                    INTERNAL_ERROR_CHECK(WindowClassContext != NULL);
                    WindowClassContext->m_Versioned = fVersioned;
                }

            }

            // Everything's groovy!
            Data->ElementParsed.Success = TRUE;
            break;
        }

    case ACTCTXCTB_CBREASON_GETSECTIONDATA:
        Data->GetSectionData.Success = FALSE;
        INTERNAL_ERROR_CHECK(SSGenContext != NULL);
        IFW32FALSE_EXIT(
            ::SxsGetStringSectionGenerationContextSectionData(
                SSGenContext,
                Data->GetSectionData.SectionSize,
                Data->GetSectionData.SectionDataStart,
                NULL));
        Data->GetSectionData.Success = TRUE;
        break;
    }

Exit:
    ;
}

BOOL
SxspWindowClassRedirectionStringSectionGenerationCallback(
    PVOID Context,
    ULONG Reason,
    PVOID CallbackData
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);

    switch (Reason)
    {
    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_ENTRYDELETED:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_ENTRYDELETED) CallbackData;
            PWINDOW_CLASS_ENTRY Entry = (PWINDOW_CLASS_ENTRY) CBData->DataContext;
            FUSION_DELETE_SINGLETON(Entry);
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATASIZE:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATASIZE) CallbackData;
            PWINDOW_CLASS_ENTRY Entry = (PWINDOW_CLASS_ENTRY) CBData->DataContext;

            CBData->DataSize = sizeof(ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION);
            CBData->DataSize += ((Entry->m_FileNameBuffer.Cch() + 1 +
                                  Entry->m_VersionSpecificWindowClassNameBuffer.Cch() + 1) * sizeof(WCHAR));
            break;
        }

    case STRING_SECTION_GENERATION_CONTEXT_CALLBACK_REASON_GETDATA:
        {
            PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA CBData =
                (PSTRING_SECTION_GENERATION_CONTEXT_CBDATA_GETDATA) CallbackData;
            PWINDOW_CLASS_ENTRY Entry = (PWINDOW_CLASS_ENTRY) CBData->DataContext;
            PACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION Info;

            SIZE_T BytesLeft = CBData->BufferSize;
            SIZE_T BytesWritten = 0;
            PWSTR Cursor;

            Info = (PACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION) CBData->Buffer;
            Cursor = (PWSTR) (Info + 1);

            if (BytesLeft < sizeof(ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION))
            {
                ::FusionpSetLastWin32Error(ERROR_INSUFFICIENT_BUFFER);
                goto Exit;
            }

            BytesWritten += sizeof(ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION);
            BytesLeft -= sizeof(ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION);

            Info->Size = sizeof(ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION);
            Info->Flags = 0;

            IFW32FALSE_EXIT(Entry->m_VersionSpecificWindowClassNameBuffer.Win32CopyIntoBuffer(
                &Cursor,
                &BytesLeft,
                &BytesWritten,
                Info,
                &Info->VersionSpecificClassNameOffset,
                &Info->VersionSpecificClassNameLength));

            IFW32FALSE_EXIT(Entry->m_FileNameBuffer.Win32CopyIntoBuffer(
                &Cursor,
                &BytesLeft,
                &BytesWritten,
                CBData->SectionHeader,
                &Info->DllNameOffset,
                &Info->DllNameLength));

            CBData->BytesWritten = BytesWritten;
        }
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsservice\common\debug.cpp ===
#include "stdinc.h"

void DebugPrintVa(ULONG ulLevel, PCSTR Format, va_list va)
{
    //do me
}

void DebugPrint(ULONG ulLevel, PCSTR Format, ...)
{
    va_list va;
    va_start(va, Format);
    DebugPrintVa(ulLevel, Format, va);
    va_end(va);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsservice\client\main.cpp ===
#include "stdinc.h"
#pragma hdrstop

#include "sxsservice.h"
#include "stdlib.h"
#include "stdio.h"

EXTERN_C RPC_IF_HANDLE SxsStoreManager_ClientIfHandle;


//
// In the client, we parse the commandline, get a connection to the server, and
// go to town.  We implement some things like recursive directory walking ourselves, 
// because the server knows nothing more than "where a manifest is" and what installation
// reference to use when installing it.
// 
RPC_STATUS __cdecl wmain(INT argc, PWSTR argv[])
{
    PWSTR pcwszUuid = NULL;
    PWSTR pcwszProtocolSequence = L"ncacn_np";
    PWSTR pcwszNetworkAddress = NULL;
    PWSTR pcwszEndpoint = SXS_STORE_SERVICE_NAME;
    PWSTR pcwszOptions = NULL;
    PWSTR pcwszBindingString = NULL;
    handle_t BindingHandle;
    RPC_STATUS status;
    SXS_INSTALL_DATA InstallData = {0};
    SXS_INSTALL_RESULT InstallResult;

    for (INT i = 1; i < argc; i++) {
        PCWSTR arg = argv[i];

        if (lstrcmpiW(arg, L"-rpcuuid") == 0) {
            pcwszUuid = argv[++i];
        }
        else if (lstrcmpiW(arg, L"-rpcprotocol") == 0) {
            pcwszProtocolSequence = argv[++i];
        }
        else if (lstrcmpiW(arg, L"-rpcaddress") == 0) {
            pcwszNetworkAddress = argv[++i];
        }
        else if (lstrcmpiW(arg, L"-rpcendpoint") == 0) {
            pcwszEndpoint = argv[++i];
        }
        else if (lstrcmpiW(arg, L"-rpcoptions") == 0) {
            pcwszOptions = argv[++i];
        }
        else if (lstrcmpiW(arg, L"-storeid") == 0) {
            UNICODE_STRING us;
            RtlInitUnicodeString(&us, argv[++i]);
            if (!NT_SUCCESS(RtlGUIDFromString(&us, &InstallData.StoreIdentifier))) {
                wprintf(L"Unable to convert store id %wZ to a guid.\n", &us);
                return ERROR_INVALID_PARAMETER;
            }
        }
        else if (lstrcmpiW(arg, L"-manifestpath") == 0) {
            InstallData.pcwszManifestPath = argv[++i];
        }
        else if (lstrcmpiW(arg, L"-reftype") == 0) {
            UNICODE_STRING us;
            RtlInitUnicodeString(&us, argv[++i]);
            if (!NT_SUCCESS(RtlGUIDFromString(&us, &InstallData.AssemblyReference.InstallationReferenceType))) {
                wprintf(L"Unable to convert reference type %wZ to a guid.\n", &us);
                return ERROR_INVALID_PARAMETER;
            }
        }
        else if (lstrcmpiW(arg, L"-refdata") == 0) {
            InstallData.AssemblyReference.pcwszReferenceData = argv[++i];
        }
        else if (lstrcmpiW(arg, L"-refsubdata") == 0) {
            InstallData.AssemblyReference.pcwszReferenceSubData = argv[++i];
        }
    }

    status = RpcStringBindingComposeW(
        pcwszUuid,
        pcwszProtocolSequence,
        pcwszNetworkAddress,
        pcwszEndpoint,
        pcwszOptions,
        &pcwszBindingString);

    if (status != RPC_S_OK) {
        return status;
    }

    status = RpcBindingFromStringBindingW(pcwszBindingString, &BindingHandle);
    RpcStringFreeW(&pcwszBindingString);

    if (status != RPC_S_OK) {
        return status;
    }

    if (!SxsProtectedInstall(
        BindingHandle,
        0,
        1,
        &InstallData,
        &InstallResult))
    {
        wprintf(L"Installation failed - lasterror = 0x%08lx (%ld)\n", ::GetLastError(), ::GetLastError());
    }
    else {
        wprintf(L"Installation succeeded - disposition %d\n", InstallResult);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsservice\server\protectedstore.h ===
#pragma once



class CProtectedStoreDetails
{
private:
    CStringBuffer m_FileSystemPath;
    DWORD m_dwFlags;
    CMiniInlineHeap<> m_SecDescBacking;
    
    void Reset();
public:
    CProtectedStoreDetails() : m_dwFlags(0) { }
    ~CProtectedStoreDetails();
    static BOOL ResolveStore(LPCGUID pGuid, CProtectedStoreDetails* pTarget);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsservice\server\protectedstore.cpp ===
#include "stdinc.h"
#include "regpaths.h"
#include "protectedstore.h"


CProtectedStoreDetails::~CProtectedStoreDetails()
{
    const DWORD dwLastError = ::GetLastError();
    this->Reset();
    SetLastError(dwLastError);
}

void
CProtectedStoreDetails::Reset()
{
    m_FileSystemPath.Clear();
    m_SecDescBacking.Reset();
}


BOOL
CProtectedStoreDetails::ResolveStore(
    LPCGUID pGuid,
    CProtectedStoreDetails *pTarget
    )
{
    BOOL fSuccess = FALSE;
    CStringBuffer PathToRegistry;
    CStringBuffer FormattedGuid;
    CStringPair StringPairs[5];

    if (pTarget) {
        pTarget->Reset();
    }
    
    if ((pTarget == NULL) || (pGuid == NULL)) {
        ::SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (!FormatGuid(pGuid, FormattedGuid)) {
        goto Exit;
    }

    //
    // Look in the registry for information on the store in question.  Form up a path to the
    // keys
    //
    StringPairs[0].SetPointerAndCount(SXS_REGPATH_INSTALLATIONS, NUMBER_OF(SXS_REGPATH_INSTALLATIONS) - 1);
    StringPairs[1].SetPointerAndCount(L"\\", 1);
    StringPairs[2].SetPointerAndCount(SXS_REGKEYNAME_GACS, NUMBER_OF(SXS_REGKEYNAME_GACS) - 1);
    StringPairs[3].SetPointerAndCount(L"\\", 1);
    StringPairs[4] = StringPair(FormattedGuid);
    
    PathToRegistry.AssignArray(NUMBER_OF(StringPairs), StringPairs);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsservice\server\sxsservice_server.c ===
#include <sxsservice_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsservice\server\regpaths.h ===
#pragma once

#define SXS_REGPATH_INSTALLATIONS       (L"Software\\Microsoft\\Windows\\SideBySide\\ProtectedInstallations")
#define SXS_REGKEYNAME_GACS             (L"GACS")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsservice\inc\stdinc.h ===
#pragma once
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "bcl_common.h"
#include "bcl_w32unicodeinlinestringbuffer.h"

#define DBGPRINT_LVL_ERROR              (0x00000001)
#define DBGPRINT_LVL_SPEW               (0x00000002)

#define SXS_STORE_SERVICE_NAME          (L"SxsStoreManagementService")

void DebugPrint(ULONG ulLevel, PCSTR Format, ...);
void DebugPrintVa(ULONG ulLevel, PCSTR Format, va_list va);

typedef BCL::CWin32BaseUnicodeInlineStringBuffer<64> CStringBuffer;
typedef BCL::CWin32BaseUnicodeInlineStringBufferTraits<64> CStringBufferTraits;
typedef BCL::CConstantPointerAndCountPair<WCHAR, SIZE_T> CStringPair;

template<typename T> inline 
CStringPair StringPair(T& source) {
    return CStringBufferTraits::GetStringPair(&source);
}


BOOL FormatGuid(LPCGUID g, CStringBuffer &Target);

#ifndef NUMBER_OF
#define NUMBER_OF(x) (sizeof(x)/sizeof(*x))
#endif

#if DBG
#define DbgPrint(x) DebugPrint x
#else
#define DbgPrint(x)
#endif

#ifndef ALIGN_TO_SIZE
#define ALIGN_TO_SIZE(P, Sz) (((ULONG_PTR)(P)) & ~((ULONG_PTR)(Sz) - 1))
#endif




template <SIZE_T cbInternalSize = 64, SIZE_T cbGrowthSize = 4096>
class CMiniInlineHeap
{
    BYTE m_bInternalHeap[cbInternalSize];
    PBYTE m_pbCurrentBlob;
    PBYTE m_pbBlobEnding;
    
    SIZE_T m_cbCurrentBlob;
    PBYTE m_pbNextAvailable;
public:
    CMiniInlineHeap() 
        : m_pbCurrentBlob(m_bInternalHeap), 
          m_cbCurrentBlob(cbInternalSize), 
          m_pbNextAvailable(m_bInternalHeap),
          m_pbBlobEnding(m_bInternalHeap + cbInternalSize)
    {
    }

    ~CMiniInlineHeap() 
    {
        if (m_pbCurrentBlob && (m_pbCurrentBlob != m_bInternalHeap)) {
            HeapFree(GetProcessHeap(), 0, m_pbCurrentBlob);
            m_pbCurrentBlob = m_bInternalHeap;
            m_cbCurrentBlob = cbInternalSize;
        }
    }

    template <typename T>
    BOOL Allocate(SIZE_T Count, T*& rptAllocated) {
        return this->AllocateBytes(sizeof(T) * Count, sizeof(T), rptAllocated);
    }

    BOOL AllocateBytes(SIZE_T cbRequired, SIZE_T cbAlignment, PVOID &ppvAllocated) {

        //
        // Align the next-available pointer up to store cbAlignment-sized stuff
        //
        PBYTE pbAlignedPointer = ALIGN_TO_SIZE(m_pbNextAvailable, cbAlignment);

        ppvAllocated = NULL;

        //
        // If there's no space left at the end of the heap, expand ourselves and
        // try again.
        //
        if ((pbAlignedPointer + cbRequired) >= m_pbBlobEnding) {
            if (!ExpandHeap(m_cbCurrentBlob + cbRequired + cbAlignment)) {
                return FALSE;
            }
            else {
                pbAlignedPointer = ALIGN_TO_SIZE(m_pbNextAvailable, cbAlignment);
            }
        }

        //
        // Advance our pointers, set the outbound thing, return true.
        //
        ppvAllocated = pbAlignedPointer;
        m_pbNextAvailable = (pbAlignedPointer + cbRequired);
        ASSERT(m_pbNextAvailable <= m_pbBlobEnding);
        return TRUE;
    }

    PBYTE GetCurrentBase() { return m_pbCurrentBlob; }
    
    void Reset()
    {
        m_pbNextAvailable = m_pbCurrentBlob;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsvc1\makefile.inc ===
# Copyright (c) Microsoft Corporation

$(O)\$(TARGETNAME).res: $(O_MANIFESTS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsvc1\resource.h ===
/*
Copyright (c) Microsoft Corporation
*/
#define SYSTEM32_MANIFEST_ID 12345
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsservice\server\main.cpp ===
#include "stdinc.h"
#pragma hdrstop

#include <svcs.h>
#include "sxsserviceserver.h"

EXTERN_C RPC_IF_HANDLE SxsStoreManager_ServerIfHandle;


BOOL 
CServiceStatus::Initialize(
    PCWSTR pcwszServiceName, 
    LPHANDLER_FUNCTION pHandler, 
    DWORD dwServiceType, 
    DWORD dwControlsAccepted, 
    DWORD dwInitialState
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    BOOL fSuccess = FALSE;

    //
    // Double-initialization isn't a bad thing, but it's frowned on.
    //        
    ASSERT(m_StatusHandle == NULL);
    if (m_StatusHandle != NULL)
        return TRUE;

    InitializeCriticalSection(&m_CSection);

    //
    // Register this service as owning the service status
    //
    m_StatusHandle = RegisterServiceCtrlHandler(pcwszServiceName, pHandler);
    if (m_StatusHandle == NULL) {
        goto Failure;
    }

    //
    // Set the initial state of the world
    //
    ZeroMemory(static_cast<SERVICE_STATUS*>(this), sizeof(SERVICE_STATUS));
    this->dwServiceType = dwServiceType;
    this->dwCurrentState = dwInitialState;
    this->dwControlsAccepted = dwControlsAccepted;
    if (!SetServiceStatus(m_StatusHandle, this)) {
        goto Failure;
    }

    return TRUE;

Failure:
    {
        const DWORD dwLastError = ::GetLastError();
        DeleteCriticalSection(&m_CSection);
        m_StatusHandle = NULL;
        SetLastError(dwLastError);
    }
    return FALSE;        
}



BOOL 
CServiceStatus::SetServiceState(
    DWORD dwStatus, 
    DWORD dwCheckpoint
    )
{
    BOOL fSuccess = FALSE;
    
    EnterCriticalSection(&m_CSection);
    __try {

        if (m_StatusHandle != NULL) {
            
            this->dwCurrentState = dwStatus;

            if (dwCheckpoint != 0xFFFFFFFF) {
                this->dwCheckPoint = dwCheckpoint;
            }

            fSuccess = SetServiceStatus(m_StatusHandle, this);            
        }
    }
    __finally {
        LeaveCriticalSection(&m_CSection);
    }

    return fSuccess;
}



//
// In-place construction
//
bool 
CServiceStatus::Construct(
    CServiceStatus *&pServiceStatusTarget
    )
{

    ASSERT(pServiceStatusTarget == NULL);
    return (pServiceStatusTarget = new CServiceStatus) != NULL;
}




EXTERN_C HANDLE g_hFakeServiceControllerThread = INVALID_HANDLE_VALUE;
EXTERN_C DWORD g_dwFakeServiceControllerThreadId = 0;
EXTERN_C PSVCHOST_GLOBAL_DATA g_pGlobalServiceData = NULL;
BYTE g_rgbServiceStatusStorage[sizeof(CServiceStatus)];
EXTERN_C CServiceStatus *g_pServiceStatus = NULL;

//
// The service host will call this to send in API callbacks
//
VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    ASSERT(g_pGlobalServiceData == NULL);
    g_pGlobalServiceData = pGlobals;
}


PVOID operator new(size_t cb, PVOID pv) {
    return pv;
}


//
// Control handler for service notifications
//
VOID
ServiceHandler(
    DWORD dwControlCode
    )
{
    return;
}


#define CHECKPOINT_ZERO             (0)
#define CHECKPOINT_RPC_STARTED      (1)

//
// Stop the service with an error code, ERROR_SUCCESS for a successful stoppage
//
VOID
ShutdownService(
    DWORD dwLastError
    )
{
    return;
}

//
// Where the fun starts
//
VOID WINAPI
ServiceMain(
    DWORD dwServiceArgs,
    LPWSTR lpServiceArgList[]
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    
    //
    // svchost must have given us some global data before we got to this point.
    //
    ASSERT(g_pGlobalServiceData != NULL);
    ASSERT(g_pServiceStatus == NULL);

    g_pServiceStatus = new (g_rgbServiceStatusStorage) CServiceStatus;
    if (!g_pServiceStatus->Initialize(
        SXS_STORE_SERVICE_NAME, ServiceHandler,
        SERVICE_WIN32,
        SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE,
        SERVICE_START_PENDING))
    {
        DebugPrint(DBGPRINT_LVL_ERROR, "Can't start service status handler, error 0x%08lx\n", ::GetLastError());
    }
        

    //
    // Go initialize RPC, and register our interface.  If this fails, we shut down.
    //
    status = g_pGlobalServiceData->StartRpcServer(
        SXS_STORE_SERVICE_NAME,
        SxsStoreManager_ServerIfHandle);

    if (!NT_SUCCESS(status)) {
        ShutdownService(status);
        return;
    }

    //
    // Tell the world that we're off and running
    //
    g_pServiceStatus->SetServiceState(SERVICE_RUNNING);
    return;
}



DWORD WINAPI FakeServiceController(PVOID pvCookie);



//
// This stub will start a dispatch thread, and then call into the
// service main function
//
BOOL 
FakeRunningAsService()
{
    //
    // Create a thread running the service dispatch function, and then call
    // the service main function to get things rolling
    //
    g_hFakeServiceControllerThread = CreateThread(
        NULL, 
        0, 
        FakeServiceController, 
        0, 
        0, 
        &g_dwFakeServiceControllerThreadId);

    if (g_hFakeServiceControllerThread == NULL) {
        return FALSE;
    }

    ServiceMain(0, NULL);
    return TRUE;
}

VOID __cdecl wmain(INT argc, WCHAR** argv)
{
    SERVICE_TABLE_ENTRYW SxsGacServiceEntries[] = {
        { SXS_STORE_SERVICE_NAME, ServiceMain },
        { NULL, NULL }
    };

    BOOL RunningAsService = TRUE;
    BOOL fSuccess = FALSE;

    if (argc > 1 && (lstrcmpiW(argv[1], L"notservice") == 0)) {
        RunningAsService = FALSE;
    }


    if (RunningAsService) {
        fSuccess = StartServiceCtrlDispatcherW(SxsGacServiceEntries);
        if (!fSuccess) {
            const DWORD dwError = ::GetLastError();
            DebugPrint(DBGPRINT_LVL_ERROR, "Failed starting service dispatch, error %ld\n", dwError);
        }
    }
    else {
        fSuccess = FakeRunningAsService();
        if (!fSuccess) {
            const DWORD dwError = ::GetLastError();
            DebugPrint(DBGPRINT_LVL_ERROR, "Failed faking service startup, error %ld\n", dwError);
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsvc2\dll\makefile.inc ===
# Copyright (c) Microsoft Corporation

# This file is needed, even if it is empty.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsvc2\sources.inc ===
# Copyright (c) Microsoft Corporation

SXS_ASSEMBLY_NAME=Microsoft.Windows.Example.SideBySideService2
SXS_SHORT_ASSEMBLY_NAME=Microsoft.Windows.Example.sxsvc2
SXS_ASSEMBLY_VERSION=1.0
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1

SXS_MANIFEST=$(NAME).manifest

O_MANIFESTS= \
 $(O)\$(NAME).man \

NTTARGETFILE0=\
 $(O_MANIFESTS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsvc1\sxsvc1.h ===
/*
Copyright (c) Microsoft Corporation
*/

#include <stdio.h>
#include <stdarg.h>
#include "windows.h"
#include "delayimp.h"

#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

PVOID MemAlloc(SIZE_T n);
VOID MemFree(PVOID p);

void strcatfW(PWSTR Buffer, SIZE_T n, PCWSTR Format, ...);

HMODULE GetMyModule(VOID);
void GetMyFullPathW(PWSTR Buffer, DWORD BufferSize);
BOOL ChangePathExtensionW(PWSTR Buffer, SIZE_T BufferSize, PCWSTR NewExtension);

extern const WCHAR ServiceName[];

#define ServiceTypeValue SERVICE_WIN32_OWN_PROCESS /* SERVICE_WIN32_OWN_PROCESS, SERVICE_WIN32_SHARE_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsvc2\dll\sxsvc2.c ===
/*
Copyright (c) Microsoft Corporation
*/

#include <stdio.h>
#include <stdarg.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "delayimp.h"
#include "strsafe.h"
#include "sxsvc2.h"

#define SERVICE_NAME L"sxsvc2"
extern const WCHAR ServiceName[] = SERVICE_NAME L"\0"; // extra nul terminal for REG_MULTI_SZ

typedef struct _SERVICE_CONTEXT {
    HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;
} SERVICE_CONTEXT, *PSERVICE_CONTEXT;

PVOID MemAlloc(SIZE_T n) { return HeapAlloc(GetProcessHeap(), 0, n); }
VOID MemFree(PVOID p) { HeapFree(GetProcessHeap(), 0, p); }

BOOL
WINAPI
DllEntry(
    HINSTANCE hInst,
    DWORD dwReason,
    PVOID pvReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInst);
        break;
    }
    return TRUE;
}

HMODULE GetMyModule(VOID)
{
    return (HMODULE)&__ImageBase;
}

void GetMyFullPathW(PWSTR Buffer, DWORD BufferSize)
{
    // NOTE: Do not put this is in the registry.
    Buffer[0] = 0;
    GetModuleFileNameW(GetMyModule(), Buffer, BufferSize);
}

void strcatfW(PWSTR Buffer, SIZE_T n, PCWSTR Format, ...)
{
    va_list Args;
    va_start(Args, Format);
    if (n != 0 && Buffer != NULL && Format != NULL)
    {
        SIZE_T i = wcslen(Buffer);
        if (i < n)
        {
            SIZE_T j = n - i;
            StringCchVPrintfW(Buffer + i, j, Format, Args);
        }
        Buffer[n - 1] = 0;
    }
    va_end(Args);
}

const STRING EmptyString = RTL_CONSTANT_STRING("");

const STRING *
DbgServiceControlToString(
    DWORD dw
    )
{
    const STRING * String = &EmptyString;
    switch (dw)
    {
#define CASE(x) case x: { const static STRING y = RTL_CONSTANT_STRING(#x); String = &y; } break;
        CASE(SERVICE_CONTROL_CONTINUE)
        CASE(SERVICE_CONTROL_INTERROGATE)
        CASE(SERVICE_CONTROL_NETBINDADD)
        CASE(SERVICE_CONTROL_NETBINDDISABLE)
        CASE(SERVICE_CONTROL_NETBINDENABLE)
        CASE(SERVICE_CONTROL_NETBINDREMOVE)
        CASE(SERVICE_CONTROL_PARAMCHANGE)
        CASE(SERVICE_CONTROL_PAUSE)
        CASE(SERVICE_CONTROL_SHUTDOWN)
        CASE(SERVICE_CONTROL_STOP)
        CASE(SERVICE_CONTROL_DEVICEEVENT)
        CASE(SERVICE_CONTROL_HARDWAREPROFILECHANGE)
        CASE(SERVICE_CONTROL_POWEREVENT)
        CASE(SERVICE_CONTROL_SESSIONCHANGE)
#undef CASE
    }
    return String;
}

DWORD
WINAPI
ServiceHandlerEx(
    DWORD dwControl,     // requested control code
    DWORD dwEventType,   // event type
    LPVOID lpEventData,  // event data
    LPVOID lpContext     // user-defined context data
    )
{
    BOOL CallSetStatus = FALSE;
    PSERVICE_CONTEXT ServiceContext = (PSERVICE_CONTEXT)lpContext;

    DbgPrint("sxsvc2: %Z\n", DbgServiceControlToString(dwControl));
    if (ServiceContext == NULL)
    {
        DbgPrint("sxsvc2: got null context\n");
        return (DWORD)-1;
    }
    switch (dwControl)
    {
    case SERVICE_CONTROL_CONTINUE:
        ServiceContext->ServiceStatus.dwCurrentState = SERVICE_RUNNING;
        CallSetStatus = TRUE;
        break;
    case SERVICE_CONTROL_INTERROGATE:
        CallSetStatus = TRUE;
        break;
    case SERVICE_CONTROL_NETBINDADD:
        break;
    case SERVICE_CONTROL_NETBINDDISABLE:
        break;
    case SERVICE_CONTROL_NETBINDENABLE:
        break;
    case SERVICE_CONTROL_NETBINDREMOVE:
        break;
    case SERVICE_CONTROL_PARAMCHANGE:
        break;
    case SERVICE_CONTROL_PAUSE:
        ServiceContext->ServiceStatus.dwCurrentState = SERVICE_PAUSED;
        CallSetStatus = TRUE;
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        ServiceContext->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
        CallSetStatus = TRUE;
        break;
    case SERVICE_CONTROL_STOP:
        ServiceContext->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
        CallSetStatus = TRUE;
        break;
    case SERVICE_CONTROL_DEVICEEVENT:
        break;
    case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
        break;
    case SERVICE_CONTROL_POWEREVENT:
        break;
    case SERVICE_CONTROL_SESSIONCHANGE:
        break;
    }
    if (CallSetStatus)
    {
        SetServiceStatus(ServiceContext->ServiceHandle, &ServiceContext->ServiceStatus);
    }
    return NO_ERROR;
}

VOID
WINAPI
ServiceMain(
    DWORD   argc,
    PWSTR   argv[]
    )
{
    const static WCHAR MyFullPathFormat[] =  L"MyFullPath: %ls: ";
    HANDLE FileHandle = 0;
    SIZE_T Length = 0;
    SIZE_T i = 0;
    PWSTR MyFullPath = 0;
    PWSTR Buffer = 0;
    HANDLE CurrentActCtx = 0;
    DWORD BytesWritten = 0;
    PSERVICE_CONTEXT ServiceContext = 0;

    MyFullPath = (PWSTR)MemAlloc(MAX_PATH);
    if (MyFullPath == NULL)
        goto Exit;

    MyFullPath[0] = 0;

    GetMyFullPathW(MyFullPath, MAX_PATH);

    Length = 0;
    if (argc != 0 && argv != NULL)
    {
        for (i = 0 ; i < argc ; i++ )
        {
            Length += wcslen(argv[i]) + 1;
        }
    }
    Length += wcslen(MyFullPath) + NUMBER_OF(MyFullPathFormat);
    Length += 1;

    Buffer = (PWSTR)MemAlloc(Length * sizeof(WCHAR));
    if (Buffer == NULL)
    {
        goto Exit;
    }

    Buffer[0] = 0;
    strcatfW(Buffer, Length, MyFullPathFormat, MyFullPath);
    if (argc != 0 && argv != NULL)
    {
        for (i = 0 ; i < argc ; i++ )
        {
            strcatfW(Buffer, Length, L"%ls ", argv[i]);
        }
    }
    GetCurrentActCtx(&CurrentActCtx);

#if DBG
    DbgPrint("sxsvc2: %ls\n", Buffer);
#endif

    ServiceContext = (PSERVICE_CONTEXT)MemAlloc(sizeof(*ServiceContext));
    if (ServiceContext == NULL)
    {
        DbgPrint("sxsvc2: out of memory line %ld\n", (ULONG)__LINE__);
    }
    RtlZeroMemory(ServiceContext, sizeof(*ServiceContext));
    ServiceContext->ServiceHandle = RegisterServiceCtrlHandlerExW(ServiceName, ServiceHandlerEx, ServiceContext);
    if (ServiceContext->ServiceHandle == 0)
    {
        DbgPrint("sxsvc2: RegisterServiceCtrlHandlerExW failed 0x%lx\n", (ULONG)GetLastError());
        goto Exit;
    }
    ServiceContext->ServiceStatus.dwServiceType = ServiceTypeValue;
    ServiceContext->ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    ServiceContext->ServiceStatus.dwControlsAccepted |= SERVICE_ACCEPT_STOP;
    ServiceContext->ServiceStatus.dwControlsAccepted |= SERVICE_ACCEPT_SHUTDOWN;
    ServiceContext->ServiceStatus.dwControlsAccepted |= SERVICE_ACCEPT_PAUSE_CONTINUE;
    ServiceContext->ServiceStatus.dwControlsAccepted |= SERVICE_ACCEPT_PARAMCHANGE;
    ServiceContext->ServiceStatus.dwControlsAccepted |= SERVICE_ACCEPT_SESSIONCHANGE;
    ServiceContext->ServiceStatus.dwWin32ExitCode = NO_ERROR;
    SetServiceStatus(ServiceContext->ServiceHandle, &ServiceContext->ServiceStatus);
    ServiceContext = NULL;

Exit:
    MemFree(Buffer);
    MemFree(MyFullPath);
    MemFree(ServiceContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsvc2\sys32proxyman\makefile.inc ===
# Copyright (c) Microsoft Corporation

# This file is needed, even if it is empty.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsvc1\sxsvc1.c ===
/*
Copyright (c) Microsoft Corporation
*/

#include <stdio.h>
#include <stdarg.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "delayimp.h"
#include "strsafe.h"
#include "sxsvc1.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

typedef struct _SERVICE_CONTEXT {
    HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;
} SERVICE_CONTEXT, *PSERVICE_CONTEXT;


PVOID MemAlloc(SIZE_T n) { return HeapAlloc(GetProcessHeap(), 0, n); }
VOID MemFree(PVOID p) { HeapFree(GetProcessHeap(), 0, p); }

BOOL
WINAPI
DllEntry(
    HINSTANCE hInst,
    DWORD dwReason,
    PVOID pvReserved
    )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInst);
        break;
    }
    return TRUE;
}

#if 0
BOOL ChangePathExtensionW(PWSTR Buffer, SIZE_T BufferSize, PCWSTR NewExtension)
{
    SIZE_T OldLength = 0;
    SIZE_T NewLength = 0;
    PWSTR  OldExtension = NULL;
    SIZE_T NewExtensionLength = 0;
    SIZE_T OldExtensionLength = 0;
    SIZE_T Counter = 0;

    OldLength = wcslen(Buffer);
    if (NewExtension[0] == '.')
    {
        NewExtension += 1;
    }
    NewExtensionLength = wcslen(NewExtension);
    if ((NewExtensionLength + 1) >= BufferSize)
    {
        return FALSE;
    }
    for (Counter = 0; Counter != OldLength; ++Counter)
    {
        SIZE_T Index = (OldLength - 1 - Counter);

        if (Buffer[Index] == '.')
        {
            OldExtension = Buffer + Index + 1;
            break;
        }
        if (Buffer[Index] == '\\' || Buffer[Index] == '/')
        {
            break;
        }
    }
    if (OldExtension == NULL)
    {
        if (OldLength + 1 + NewExtensionLength >= BufferSize)
        {
            return FALSE;
        }
        Buffer[OldLength] = '.';
        CopyMemory(Buffer + OldLength + 1, NewExtension, NewExtensionLength * sizeof(WCHAR));
        Buffer[OldLength + 1 + NewExtensionLength + 1] = 0;
        return TRUE;
    }
    OldExtensionLength = wcslen(OldExtension);
    NewLength = OldLength - OldExtensionLength + NewExtensionLength;
    if (NewLength + 1 >= BufferSize)
    {
        return FALSE;
    }
    CopyMemory(Buffer + OldLength - OldExtensionLength, NewExtension, NewExtensionLength * sizeof(WCHAR));
    Buffer[OldLength - OldExtensionLength + NewExtensionLength] = 0;
    return TRUE;
}
#endif

HMODULE GetMyModule(VOID)
{
    return (HMODULE)&__ImageBase;
}

void GetMyFullPathW(PWSTR Buffer, DWORD BufferSize)
{
    Buffer[0] = 0;
    GetModuleFileNameW(GetMyModule(), Buffer, BufferSize);
}

void strcatfW(PWSTR Buffer, SIZE_T n, PCWSTR Format, ...)
{
    va_list Args;
    va_start(Args, Format);
    if (n != 0 && Buffer != NULL && Format != NULL)
    {
        SIZE_T i = wcslen(Buffer);
        if (i < n)
        {
            SIZE_T j = n - i;
            StringCchVPrintfW(Buffer + i, j, Format, Args);
        }
        Buffer[n - 1] = 0;
    }
    va_end(Args);
}

const STRING EmptyString = RTL_CONSTANT_STRING("");

const STRING *
DbgServiceControlToString(
    DWORD dw
    )
{
    const STRING * String = &EmptyString;
    switch (dw)
    {
#define CASE(x) case x: { const static STRING y = RTL_CONSTANT_STRING(#x); String = &y; } break;
        CASE(SERVICE_CONTROL_CONTINUE)
        CASE(SERVICE_CONTROL_INTERROGATE)
        CASE(SERVICE_CONTROL_NETBINDADD)
        CASE(SERVICE_CONTROL_NETBINDDISABLE)
        CASE(SERVICE_CONTROL_NETBINDENABLE)
        CASE(SERVICE_CONTROL_NETBINDREMOVE)
        CASE(SERVICE_CONTROL_PARAMCHANGE)
        CASE(SERVICE_CONTROL_PAUSE)
        CASE(SERVICE_CONTROL_SHUTDOWN)
        CASE(SERVICE_CONTROL_STOP)
        CASE(SERVICE_CONTROL_DEVICEEVENT)
        CASE(SERVICE_CONTROL_HARDWAREPROFILECHANGE)
        CASE(SERVICE_CONTROL_POWEREVENT)
        CASE(SERVICE_CONTROL_SESSIONCHANGE)
#undef CASE
    }
    return String;
}

DWORD
WINAPI
ServiceHandlerEx(
    DWORD dwControl,     // requested control code
    DWORD dwEventType,   // event type
    LPVOID lpEventData,  // event data
    LPVOID lpContext     // user-defined context data
    )
{
    BOOL CallSetStatus = FALSE;
    PSERVICE_CONTEXT ServiceContext = (PSERVICE_CONTEXT)lpContext;

    DbgPrint("sxsvc1: %Z\n", DbgServiceControlToString(dwControl));
    if (ServiceContext == NULL)
    {
        DbgPrint("sxsvc1: got null context\n");
        return (DWORD)-1;
    }
    switch (dwControl)
    {
    case SERVICE_CONTROL_CONTINUE:
        ServiceContext->ServiceStatus.dwCurrentState = SERVICE_RUNNING;
        CallSetStatus = TRUE;
        break;
    case SERVICE_CONTROL_INTERROGATE:
        CallSetStatus = TRUE;
        break;
    case SERVICE_CONTROL_NETBINDADD:
        break;
    case SERVICE_CONTROL_NETBINDDISABLE:
        break;
    case SERVICE_CONTROL_NETBINDENABLE:
        break;
    case SERVICE_CONTROL_NETBINDREMOVE:
        break;
    case SERVICE_CONTROL_PARAMCHANGE:
        break;
    case SERVICE_CONTROL_PAUSE:
        ServiceContext->ServiceStatus.dwCurrentState = SERVICE_PAUSED;
        CallSetStatus = TRUE;
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        ServiceContext->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
        CallSetStatus = TRUE;
        break;
    case SERVICE_CONTROL_STOP:
        ServiceContext->ServiceStatus.dwCurrentState = SERVICE_STOPPED;
        CallSetStatus = TRUE;
        break;
    case SERVICE_CONTROL_DEVICEEVENT:
        break;
    case SERVICE_CONTROL_HARDWAREPROFILECHANGE:
        break;
    case SERVICE_CONTROL_POWEREVENT:
        break;
    case SERVICE_CONTROL_SESSIONCHANGE:
        break;
    }
    if (CallSetStatus)
    {
        SetServiceStatus(ServiceContext->ServiceHandle, &ServiceContext->ServiceStatus);
    }
    return NO_ERROR;
}

VOID
WINAPI
ServiceMain(
    DWORD   argc,
    PWSTR   argv[]
    )
{
    const static WCHAR MyFullPathFormat[] =  L"MyFullPath: %ls: ";
    const static WCHAR CurrentActCtxFormat[] =  L"CurrentActCtx: %p: ";
    HANDLE FileHandle = 0;
    SIZE_T Length = 0;
    SIZE_T i = 0;
    PWSTR MyFullPath = 0;
    PWSTR Buffer = 0;
    HANDLE CurrentActCtx = 0;
    DWORD BytesWritten = 0;
    PSERVICE_CONTEXT ServiceContext = 0;

    MyFullPath = (PWSTR)MemAlloc(MAX_PATH);
    if (MyFullPath == NULL)
        goto Exit;

    MyFullPath[0] = 0;

    GetMyFullPathW(MyFullPath, MAX_PATH);
    FileHandle = CreateFileW(L"C:\\sxsvc.log", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (FileHandle == INVALID_HANDLE_VALUE)
    {
        goto Exit;
    }

    Length = 0;
    if (argc != 0 && argv != NULL)
    {
        for (i = 0 ; i < argc ; i++ )
        {
            Length += wcslen(argv[i]) + 1;
        }
    }
    Length += wcslen(MyFullPath) + NUMBER_OF(MyFullPathFormat);
    Length += sizeof(PVOID) * 8 + NUMBER_OF(CurrentActCtxFormat);
    Length += 1;

    Buffer = (PWSTR)MemAlloc(Length * sizeof(WCHAR));
    if (Buffer == NULL)
    {
        goto Exit;
    }

    Buffer[0] = 0;
    strcatfW(Buffer, Length, MyFullPathFormat, MyFullPath);
    if (argc != 0 && argv != NULL)
    {
        for (i = 0 ; i < argc ; i++ )
        {
            strcatfW(Buffer, Length, L"%ls ", argv[i]);
        }
    }
    GetCurrentActCtx(&CurrentActCtx);
    strcatfW(Buffer, Length, CurrentActCtxFormat, CurrentActCtx);

    WriteFile(FileHandle, Buffer, wcslen(Buffer), &BytesWritten, NULL);
#if DBG
    DbgPrint("sxsvc1: %ls\n", Buffer);
#endif

    ServiceContext = (PSERVICE_CONTEXT)MemAlloc(sizeof(*ServiceContext));
    if (ServiceContext == NULL)
    {
        DbgPrint("sxsvc1: out of memory line %ld\n", (ULONG)__LINE__);
    }
    RtlZeroMemory(ServiceContext, sizeof(*ServiceContext));
    ServiceContext->ServiceHandle = RegisterServiceCtrlHandlerExW(ServiceName, ServiceHandlerEx, ServiceContext);
    if (ServiceContext->ServiceHandle == 0)
    {
        DbgPrint("sxsvc1: RegisterServiceCtrlHandlerExW failed 0x%lx\n", (ULONG)GetLastError());
        goto Exit;
    }
    ServiceContext->ServiceStatus.dwServiceType = ServiceTypeValue;
    ServiceContext->ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    ServiceContext->ServiceStatus.dwControlsAccepted |= SERVICE_ACCEPT_STOP;
    ServiceContext->ServiceStatus.dwControlsAccepted |= SERVICE_ACCEPT_SHUTDOWN;
    ServiceContext->ServiceStatus.dwControlsAccepted |= SERVICE_ACCEPT_PAUSE_CONTINUE;
    ServiceContext->ServiceStatus.dwControlsAccepted |= SERVICE_ACCEPT_PARAMCHANGE;
    ServiceContext->ServiceStatus.dwControlsAccepted |= SERVICE_ACCEPT_SESSIONCHANGE;
    ServiceContext->ServiceStatus.dwWin32ExitCode = NO_ERROR;
    SetServiceStatus(ServiceContext->ServiceHandle, &ServiceContext->ServiceStatus);
    ServiceContext = NULL;

Exit:
    if (FileHandle != NULL)
        CloseHandle(FileHandle);
    MemFree(Buffer);
    MemFree(MyFullPath);
    MemFree(ServiceContext);
}

#if 0
int __cdecl wmain(int argc, wchar_t ** argv)
{
    WCHAR Buffer[MAX_PATH];
    int i = 0;

    for ( i = 1 ; i < argc ; i += 2)
    {
        StringCchCopyW(Buffer, NUMBER_OF(Buffer), argv[i]);
        ChangePathExtensionW(Buffer, NUMBER_OF(Buffer), argv[i + 1]);
        printf("%ls\n", Buffer);
    }
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsvc2\dll\sxsvc2.h ===
/*
Copyright (c) Microsoft Corporation
*/

#include <stdio.h>
#include <stdarg.h>
#include "windows.h"
#include "delayimp.h"

#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

PVOID MemAlloc(SIZE_T n);
VOID MemFree(PVOID p);
void strcatfW(PWSTR Buffer, SIZE_T n, PCWSTR Format, ...);
HMODULE GetMyModule(VOID);
void GetMyFullPathW(PWSTR Buffer, DWORD BufferSize);
extern const WCHAR ServiceName[];

#define ServiceTypeValue SERVICE_WIN32_OWN_PROCESS /* SERVICE_WIN32_OWN_PROCESS, SERVICE_WIN32_SHARE_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\sxsvc1\sxsvc1_install.c ===
/*
Copyright (c) Microsoft Corporation
*/

/*
This is not really how things should be done.
Write an .inf. I need to learn how.
*/
#include <stdio.h>
#include <stdarg.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "delayimp.h"
#include "strsafe.h"
#include "sxsvc1.h"
#include "resource.h"

#define USE_CREATESERVICE 1
#define COPY_FROM_FILE_TO_SYSTEM32 0
#define COPY_FROM_RESOURCE_TO_SYSTEM32 1

#define SERVICE_NAME L"sxsvc1"
extern const WCHAR ServiceName[] = SERVICE_NAME L"\0"; // extra nul terminal for REG_MULTI_SZ

typedef struct _REGISTRY_VALUE {
    DWORD  Type;
    PCWSTR Name;
    union {
        PCWSTR String;
        DWORD  Dword;
    } Value;
} REGISTRY_VALUE;

extern const WCHAR DescriptionValue[] = L"This is an example sidebyside installed service.";
extern const WCHAR DisplayNameValue[] = L"This is the display name.";
#define StartTypeValue   SERVICE_AUTO_START
#define ServiceTypeValue SERVICE_WIN32_OWN_PROCESS /* SERVICE_WIN32_OWN_PROCESS, SERVICE_WIN32_SHARE_PROCESS */
#define ErrorControlValue SERVICE_ERROR_NORMAL
extern const WCHAR ImagePathValue[] = L"%SystemRoot%\\System32\\svchost.exe -k " SERVICE_NAME;

#if !USE_CREATESERVICE
extern const REGISTRY_VALUE RegistryValues1[] =
{
    { REG_SZ,        L"Description", DescriptionValue },
    { REG_SZ,        L"DisplayName", DisplayNameValue },
    { REG_EXPAND_SZ, L"ImagePath",   ImagePathValue },
    { REG_DWORD,     L"Start",       (PCWSTR)(ULONG_PTR)StartTypeValue },
    { REG_DWORD,     L"Type",        (PCWSTR)(ULONG_PTR)ServiceTypeValue },
    { REG_DWORD,     L"ErrorControl", (PCWSTR)(ULONG_PTR)ErrorControlValue }
};
#endif

const REGISTRY_VALUE RegistryValues2[] =
{
    { REG_EXPAND_SZ,    L"ServiceManifest", L"%SystemRoot%\\System32\\" SERVICE_NAME L".manifest" },
    { REG_EXPAND_SZ,    L"ServiceDll", SERVICE_NAME L".dll" },
};

LONG
SetRegistryValues(
    HKEY RegistryKeyHandle,
    const REGISTRY_VALUE * RegistryValues,
    SIZE_T NumberOfRegistryValues
    )
{
    LONG RegResult = ERROR_SUCCESS;
    SIZE_T i;

    for (i = 0 ; i != NumberOfRegistryValues ; ++i)
    {
        const REGISTRY_VALUE * RegistryValue = &RegistryValues[i];
        DWORD Size = 0;
        const BYTE * Data = 0;
        switch (RegistryValue->Type)
        {
        case REG_DWORD:
            Size = sizeof(RegistryValue->Value.Dword);
            Data = (const BYTE *)&RegistryValue->Value.Dword;
            break;
        case REG_SZ:
        case REG_EXPAND_SZ:
            Size = (wcslen(RegistryValue->Value.String) + 1) * sizeof(WCHAR);
            Data = (const BYTE *)RegistryValue->Value.String;
            break;
        }
        RegResult = RegSetValueExW(RegistryKeyHandle, RegistryValue->Name, 0, RegistryValue->Type, Data, Size);
        if (RegResult != ERROR_SUCCESS)
            goto RegExit;
    }
RegExit:
    return RegResult;
}

STDAPI DllRegisterServer(void) { return NOERROR; }
STDAPI DllUnregisterServer(void) { return NOERROR; }

STDAPI 
DllInstall(
    BOOL fInstall,
    LPCWSTR pszCmdLine
    )
{
    const static WCHAR s1[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost";
    const static WCHAR s2[] = L"System\\CurrentControlSet\\Services\\" SERVICE_NAME;
    HANDLE ServiceControlManager = 0;
    HANDLE ServiceHandle = 0;
    HKEY RegistryHandles[4] = { 0 };
    DWORD Disposition = 0;
    LONG RegResult = ERROR_SUCCESS;
    SIZE_T i = 0;
    PWSTR InstallManifestFrom1 = 0;
    PWSTR InstallManifestFrom2 = 0;
    PWSTR InstallManifestFrom = 0;
    PWSTR InstallManifestTo = 0;
    HRSRC ResourceHandle = 0;
    HMODULE MyModule = 0;
    HGLOBAL GlobalResourceHandle = 0;
    PVOID PointerToResource = 0;
    DWORD ResourceSize = 0;
    DWORD BytesWritten = 0;
    HANDLE FileHandle = 0;
    DWORD  Retried = 0;

    if (!fInstall)
    {
        return NOERROR;
    }

    InstallManifestFrom1 = (PWSTR)MemAlloc((MAX_PATH + 1) * sizeof(WCHAR));
    InstallManifestFrom2 = (PWSTR)MemAlloc((MAX_PATH + 1) * sizeof(WCHAR));
    InstallManifestTo    = (PWSTR)MemAlloc((MAX_PATH + 1) * sizeof(WCHAR));
    if (InstallManifestFrom1 == NULL
        || InstallManifestFrom2 == NULL
        || InstallManifestTo == NULL
        )
    {
        goto OutOfMemory;
    }
    InstallManifestFrom1[0] = 0;
    InstallManifestFrom2[0] = 0;

    ServiceControlManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (ServiceControlManager == NULL || ServiceControlManager == INVALID_HANDLE_VALUE)
    {
        DbgPrint("OpenSCManager failed 0x%lx\n", (ULONG)GetLastError());
        goto LastErrorExit;
    }

    RegResult = RegCreateKeyExW(HKEY_LOCAL_MACHINE, s1, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &RegistryHandles[0], &Disposition);
    if (RegResult != ERROR_SUCCESS)
    {
        DbgPrint("RegCreateKeyExW failed 0x%lx\n", (ULONG)RegResult);
        goto RegExit;
    }

    RegResult = RegCreateKeyExW(RegistryHandles[0], ServiceName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &RegistryHandles[1], &Disposition);
    if (RegResult != ERROR_SUCCESS)
    {
        DbgPrint("RegCreateKeyExW failed 0x%lx\n", (ULONG)RegResult);
        goto RegExit;
    }

    //
    // In reality this needs to append to the possibly preexisting REG_MULTI_SZE.
    //
    RegResult = RegSetValueExW(RegistryHandles[0], ServiceName, 0, REG_MULTI_SZ, (const BYTE*)&ServiceName, sizeof(ServiceName));
    if (RegResult != ERROR_SUCCESS)
    {
        DbgPrint("RegSetValueExW failed 0x%lx\n", (ULONG)RegResult);
        goto RegExit;
    }

#if !USE_CREATESERVICE
    RegResult = RegCreateKeyExW(HKEY_LOCAL_MACHINE, s2, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &RegistryHandles[2], &Disposition);
    if (RegResult != ERROR_SUCCESS)
    {
        DbgPrint("RegCreateKeyExW failed 0x%lx\n", (ULONG)RegResult);
        goto RegExit;
    }

    RegResult = SetRegistryValues(RegistryHandles[2], RegistryValues1, NUMBER_OF(RegistryValues1));
    if (RegResult != ERROR_SUCCESS)
        goto RegExit;
#else
    //
    // First stop and delete the service.
    // 
    ServiceHandle = 
        OpenServiceW(
            ServiceControlManager,
            ServiceName,
            GENERIC_ALL
            );
    if (ServiceHandle != NULL && ServiceHandle != INVALID_HANDLE_VALUE)
    {
        SERVICE_STATUS ServiceStatus;

        ControlService(ServiceHandle, SERVICE_STOP, &ServiceStatus);
        if (!DeleteService(ServiceHandle))
        {
            DWORD Error = GetLastError();
            if (Error != ERROR_SERVICE_MARKED_FOR_DELETE
                && Error != ERROR_KEY_DELETED
                )
            {
                DbgPrint("sxsvc1: DeleteService failed 0x%lx\n", (ULONG)Error);
                goto LastErrorExit;
            }
        }
        CloseServiceHandle(ServiceHandle);
        ServiceHandle = NULL;

        //
        // close and reopen to avoid use-after-delete / use-while-delete-pending errors (0x430/0x3fa) ?
        //
        CloseServiceHandle(ServiceControlManager);
        ServiceControlManager = NULL;
        ServiceControlManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (ServiceControlManager == NULL || ServiceControlManager == INVALID_HANDLE_VALUE)
        {
            DbgPrint("OpenSCManager failed 0x%lx\n", (ULONG)GetLastError());
            goto LastErrorExit;
        }
    }
RetryCreate:
    ServiceHandle = 
        CreateServiceW(
            ServiceControlManager,
            ServiceName,
            DisplayNameValue,
            GENERIC_ALL,
            ServiceTypeValue,
            StartTypeValue,
            ErrorControlValue,
            ImagePathValue,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL
            );
    if (ServiceHandle == NULL || ServiceHandle == INVALID_HANDLE_VALUE)
    {
        if ((Retried & 1) == 0 && GetLastError() == ERROR_SERVICE_MARKED_FOR_DELETE)
        {
            Sleep(500);
            Retried |= 1;
            goto RetryCreate;
        }
        DbgPrint("sxsvc1: CreateService failed 0x%lx\n", (ULONG)GetLastError());
        goto LastErrorExit;
    }
#endif

#if USE_CREATESERVICE
    //
    // close and reopen to avoid use-after-delete / use-while-delete-pending errors (0x430/0x3fa) ?
    //
    if (RegistryHandles[2] != NULL)
    {
        RegCloseKey(RegistryHandles[2]);
        RegistryHandles[2] = NULL;
    }
    RegResult = RegCreateKeyExW(HKEY_LOCAL_MACHINE, s2, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &RegistryHandles[2], &Disposition);
    if (RegResult != ERROR_SUCCESS)
    {
        DbgPrint("RegCreateKeyExW failed 0x%lx\n", (ULONG)RegResult);
        goto RegExit;
    }
#endif

    // But need to put in the svchost parameters ourselves.
    RegResult = RegCreateKeyExW(RegistryHandles[2], L"Parameters", 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &RegistryHandles[3], &Disposition);
    if (RegResult != ERROR_SUCCESS)
    {
        DbgPrint("sxsvc1: RegCreateKeyExW(Parameters) failed 0x%lx\n", (ULONG)RegResult);
        goto RegExit;
    }

    RegResult = SetRegistryValues(RegistryHandles[3], RegistryValues2, NUMBER_OF(RegistryValues2));
    if (RegResult != ERROR_SUCCESS)
    {
        DbgPrint("sxsvc1: SetRegistryValues(3) failed 0x%lx\n", (ULONG)RegResult);
        goto RegExit;
    }

#if COPY_FROM_FILE_TO_SYSTEM32
    InstallManifestFrom1[0] = 0;
    InstallManifestFrom2[0] = 0;
    GetMyFullPathW(InstallManifestFrom1, MAX_PATH);
    CopyMemory(InstallManifestFrom2, InstallManifestFrom1, (wcslen(InstallManifestFrom1) + 1) * sizeof(WCHAR));
    RegResult = ERROR_BUFFER_OVERFLOW;
    if (!ChangePathExtensionW(InstallManifestFrom1, MAX_PATH, L".man"))
        goto RegExit;
    if (!ChangePathExtensionW(InstallManifestFrom2, MAX_PATH, L".manifest"))
        goto RegExit;
    if (GetFileAttributesW(InstallManifestFrom1) != 0xFFFFFFFF)
    {
        InstallManifestFrom = InstallManifestFrom1;
    }
    else if (GetFileAttributesW(InstallManifestFrom2) != 0xFFFFFFFF)
    {
        InstallManifestFrom = InstallManifestFrom2;
    }
    else
    {
        goto LastErrorExit;
    }
#endif

#if COPY_FROM_FILE_TO_SYSTEM32 || COPY_FROM_RESOURCE_TO_SYSTEM32
    InstallManifestTo[0] = 0;
    if (ExpandEnvironmentStringsW(RegistryValues2[0].Value.String, InstallManifestTo, MAX_PATH) == 0)
    {
        goto LastErrorExit;
    }
#endif
#if COPY_FROM_FILE_TO_SYSTEM32
    if (!CopyFileW(InstallManifestFrom, InstallManifestTo, FALSE))
    {
        goto LastErrorExit;
    }
#endif

#if COPY_FROM_RESOURCE_TO_SYSTEM32
    ResourceHandle = FindResourceW(MyModule = GetMyModule(), MAKEINTRESOURCEW(SYSTEM32_MANIFEST_ID), MAKEINTRESOURCEW(RT_MANIFEST));
    if (ResourceHandle == NULL)
    {
        goto LastErrorExit;
    }
    GlobalResourceHandle = LoadResource(MyModule, ResourceHandle);
    if (GlobalResourceHandle == NULL)
    {
        goto LastErrorExit;
    }
    PointerToResource = LockResource(GlobalResourceHandle);
    if (PointerToResource == NULL)
    {
        goto LastErrorExit;
    }
    ResourceSize = SizeofResource(MyModule, ResourceHandle);
    if (ResourceSize == 0)
    {
        goto LastErrorExit;
    }

    FileHandle = CreateFileW(InstallManifestTo, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (FileHandle == INVALID_HANDLE_VALUE)
    {
        goto LastErrorExit;
    }
    if (!WriteFile(FileHandle, PointerToResource, ResourceSize, &BytesWritten, NULL))
    {
        goto LastErrorExit;
    }
    CloseHandle(FileHandle);
    FileHandle = NULL;
#endif

    RegResult = ERROR_SUCCESS;
RegExit:
#if DBG
    if (RegResult != ERROR_SUCCESS)
    {
        DbgPrint("%ls:%s: Registry Error 0x%lx\n", ServiceName, __FUNCTION__, RegResult);
    }
#endif
    if (ServiceHandle != NULL)
    {
        CloseServiceHandle(ServiceHandle);
    }
    if (ServiceControlManager != NULL)
    {
        CloseServiceHandle(ServiceControlManager);
    }
    for (i = 0 ; i != NUMBER_OF(RegistryHandles) ; ++i )
    {
        if (RegistryHandles[i] != NULL)
        {
            RegCloseKey(RegistryHandles[i]);
        }
    }
    if (FileHandle != NULL || FileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(FileHandle);
    }
    MemFree(InstallManifestFrom1);
    MemFree(InstallManifestFrom2);
    MemFree(InstallManifestTo);
    if (RegResult == ERROR_SUCCESS)
    {
        return NOERROR;
    }
    else
    {
        return HRESULT_FROM_WIN32(RegResult);
    }
LastErrorExit:
    RegResult = GetLastError();
    goto RegExit;
OutOfMemory:
    RegResult = ERROR_OUTOFMEMORY;
    goto RegExit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\actctxtests\actctxtests.cpp ===
#include "windows.h"
#include "stdio.h"

void DoIt(
    PCWSTR pcwszSource,
    PCWSTR pcwszAsmDir,
    PCWSTR pcwszAppName
    )
{
    ACTCTXW ActCtx = {sizeof(ActCtx)};
    HANDLE hCreated;
    DWORD x;

    ActCtx.lpSource = pcwszSource;
    ActCtx.lpApplicationName = pcwszAppName;
    ActCtx.lpAssemblyDirectory = pcwszAsmDir;

    for (x = 0; x < 4; x++)
    {
        ActCtx.dwFlags =
            ((x & 1) ? ACTCTX_FLAG_APPLICATION_NAME_VALID : 0) |
            ((x & 2) ? ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID: 0);

        printf("Run %d with source %ls, appname %svalid '%ls', asmdir %svalid '%ls'\n", 
            x, 
            ActCtx.lpSource,
            (ActCtx.dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID) ? "" : "not ",
            (ActCtx.dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID) ? ActCtx.lpApplicationName : L"",
            (ActCtx.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) ? "" : "not ",
            (ActCtx.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) ? ActCtx.lpAssemblyDirectory : L""
            );

        hCreated = CreateActCtxW(&ActCtx);
        if (hCreated != INVALID_HANDLE_VALUE)
        {
            PACTIVATION_CONTEXT_DETAILED_INFORMATION DetailedInfo = NULL;
            SIZE_T cbRequired = 0;
            SIZE_T cbAvailable = 0;

            if (!QueryActCtxW(
                    0,
                    hCreated,
                    NULL,
                    ActivationContextDetailedInformation,
                    DetailedInfo,
                    cbAvailable,
                    &cbRequired))
            {
                const DWORD dwL = ::GetLastError();

                if (dwL != ERROR_INSUFFICIENT_BUFFER)
                {
                    printf(" ! Got error 0x%08lx (%ld) querying actctx data\n", dwL, dwL);
                }
                else
                {
                    DetailedInfo = (PACTIVATION_CONTEXT_DETAILED_INFORMATION)HeapAlloc(GetProcessHeap(), 0, cbRequired);
                    cbAvailable = cbRequired;

                    if (!QueryActCtxW(
                            0, 
                            hCreated, 
                            NULL,
                            ActivationContextDetailedInformation,
                            DetailedInfo,
                            cbAvailable,
                            &cbRequired))
                    {
                        printf(" ! Failed second call to queryactctxw, error 0x%08lx (%ld)\n",
                            ::GetLastError(), ::GetLastError());
                    }
                    else
                    {
                        printf(" + App path '%.*ls'\n + Assembly path '%.*ls'\n + Root manifest '%.*ls'\n",
                            DetailedInfo->ulAppDirPathChars, DetailedInfo->lpAppDirPath,
                            DetailedInfo->ulRootConfigurationPathChars, DetailedInfo->lpRootConfigurationPath,
                            DetailedInfo->ulRootManifestPathChars, DetailedInfo->lpRootManifestPath);
                    }

                    HeapFree(GetProcessHeap(), 0, DetailedInfo);
                }
            }
            else
            {
                printf(" ! First call to queryactctxw with empty buffers should not succeed\n");
            }




            printf(" ! Created activation context\n");
            ReleaseActCtx(hCreated);
        }
        else
        {
            printf(" ! Failed creating activation context, error 0x%08lx (%ld)\n",
                ::GetLastError(),
                ::GetLastError());
        }
    }
}

int __cdecl wmain(int argc, WCHAR *argv[])
{
    PWSTR pwszAsmDirectory = new WCHAR[::wcslen(argv[1])];
    wcscpy(pwszAsmDirectory, argv[1]);
    *wcsrchr(pwszAsmDirectory, L'\\') = UNICODE_NULL;

    // Do it with NULL source
    DoIt(NULL, argv[2], argv[3]);

    // Do it with directory source
    DoIt(pwszAsmDirectory, argv[2], argv[3]);

    // Do it with file source
    DoIt(argv[1], argv[2], argv[3]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\comtests\inproc\makefile.inc ===
lastminute:
	copy sxsmanifestdom.dll $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\comtests\inproc\stdinc.h ===
#pragma once
#define UNICODE
#define _UNICODE
#include "windows.h"
#include "comdef.h"
#include "stdio.h"
#include "stdlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\comtests\inproc\inproc.cpp ===
#include "stdinc.h"

PCWSTR g_pcwszManifestFilename = NULL;
PCWSTR g_pcwszGuidToCreate = NULL;
DWORD  g_dwOperations = NULL;
DWORD  g_dwContexts = 0;
DWORD  g_dwCoInitContextForCreatedThread = 0;
DWORD  g_dwCoInitContextForMainThread = 0;

#define OP_CREATE_ALTERNATE_THREAD                  (0x00000001)
#define OP_ACTIVATE_BEFORE_CREATE_ON_CREATE_THREAD  (0x00000002)

DWORD WINAPI ThreadFunc(PVOID)
{
    ACTCTXW Ctx = { sizeof(Ctx) };
    WCHAR wchPath[MAX_PATH];
    HANDLE hActCtx = INVALID_HANDLE_VALUE;
    ULONG_PTR ulpCookie = 0;
    CLSID clsidToCreate;
    HRESULT hr = S_OK;
    IUnknown* ppUnk = NULL;
    
    if (g_dwOperations & OP_CREATE_ALTERNATE_THREAD)
    {
        hr = CoInitializeEx(NULL, g_dwCoInitContextForCreatedThread);
        if (FAILED(hr))
        {
            wprintf(L"Failed to coinitialize on the alternate thread, error 0x%08lx\n", hr);
            return 0;
        }
    }
    
    if (g_pcwszManifestFilename == NULL)
    {
        GetModuleFileNameW(NULL, wchPath, MAX_PATH);
        wcscpy(wcsrchr(wchPath, L'.'), L".manifest");
        g_pcwszManifestFilename = wchPath;
    }
    
    if (g_pcwszGuidToCreate != NULL)
    {
        if (FAILED(CLSIDFromString(const_cast<LPOLESTR>(g_pcwszGuidToCreate), &clsidToCreate)))
        {
            wprintf(L"Failed converting guid string '%ls' to a real GUID",
                g_pcwszGuidToCreate);
            return 0;
        }
    }
    
    Ctx.lpSource = g_pcwszManifestFilename;
    hActCtx = CreateActCtxW(&Ctx);
    
    if (g_dwOperations & OP_ACTIVATE_BEFORE_CREATE_ON_CREATE_THREAD)
    {
        if (!ActivateActCtx(hActCtx, &ulpCookie))
        {
            wprintf(L"Failed activation context %p?\n", hActCtx);
            return 0;
        }
    }

    //
    // First pass, with context nonactive
    //
    hr = CoCreateInstance(
        clsidToCreate,
        NULL, 
        g_dwContexts,
        IID_IUnknown,
        (PVOID*)&ppUnk);
    
    if (SUCCEEDED(hr) && (ppUnk != NULL))
    {
        wprintf(L"Created instance.\n");
        ppUnk->Release();
        ppUnk = NULL;
    }
    else
    {
        DWORD le = GetLastError();
        wprintf(L"Error creating instance - 0x%08lx - lasterror %ld\r\n", hr, le);
    }
    
    if (g_dwOperations & OP_ACTIVATE_BEFORE_CREATE_ON_CREATE_THREAD)
    {
        if (!DeactivateActCtx(0, ulpCookie))
        {
            wprintf(L"Failed deactivating context cookie %l\n", ulpCookie);
            return 0;
        }
    }
    
    if ( hActCtx != INVALID_HANDLE_VALUE )
    {
        ReleaseActCtx(hActCtx);
    }
    
    if (g_dwOperations & OP_CREATE_ALTERNATE_THREAD)
    {
        CoUninitialize();
    }

    return 0;
}

void
PumpMessagesUntilSignalled(HANDLE hThing)
{
    do
    {
        // Wait 20msec for a signal ... otherwise we'll spin
        MSG msg;
        DWORD dwWaitResult = WaitForSingleObject(hThing, 20);
        
        if (dwWaitResult == WAIT_OBJECT_0)
            break;
        
        // Pump all waiting messages
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    while (true);
}

int __cdecl wmain(int argc, WCHAR** wargv)
{
    HANDLE hCreatedThread;
    DWORD dwThreadIdent;
    HRESULT hr;
    
    for (int i = 1; i < argc; i++)
    {
        if (lstrcmpiW(wargv[i], L"-manifest") == 0)
            g_pcwszManifestFilename = wargv[++i];

        else if (lstrcmpiW(wargv[i], L"-activatebeforecreate") == 0)
            g_dwOperations |= OP_ACTIVATE_BEFORE_CREATE_ON_CREATE_THREAD;

        else if (lstrcmpiW(wargv[i], L"-createotherthread") == 0)
            g_dwOperations |= OP_CREATE_ALTERNATE_THREAD;

        else if (lstrcmpiW(wargv[i], L"-coinitparamformainthread") == 0)
            g_dwCoInitContextForMainThread = _wtoi(wargv[++i]);

        else if (lstrcmpiW(wargv[i], L"-coinitparamforcreatedthread") == 0)
            g_dwCoInitContextForCreatedThread = _wtoi(wargv[++i]);

        else if (lstrcmpiW(wargv[i], L"-clsctx") == 0)
            g_dwContexts = _wtoi(wargv[++i]);

        else if (lstrcmpiW(wargv[i], L"-clsidtocreate") == 0)
            g_pcwszGuidToCreate = wargv[++i];

        else {
            wprintf(L"Invalid parameter %ls\r\n", wargv[i]);
            return -1;
        }
    }

    if (g_pcwszGuidToCreate == NULL)
    {
        wprintf(L"Must at least use -clsidtocreate to give a clsid target\r\n");
        return -2;
    }

    hr = CoInitializeEx(NULL, g_dwCoInitContextForMainThread);
    if (FAILED(hr))
    {
        wprintf(L"Failed main CoInitializeEx, error 0x%08lx\n", hr);
        return -3;
    }

    //
    // Create that alternate thread to do the test on?
    //
    if (g_dwOperations & OP_CREATE_ALTERNATE_THREAD)
    {
        hCreatedThread = CreateThread(NULL, 0, ThreadFunc, NULL, 0, &dwThreadIdent);
        PumpMessagesUntilSignalled(hCreatedThread);
        CloseHandle(hCreatedThread);
    }
    else
    {
        ThreadFunc(NULL);
    }
    
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\comtests\outofproc\main.cpp ===
#include "windows.h"
#include "comdef.h"
#include "comip.h"
#include "stdio.h"

class __declspec(uuid("8af0ddb0-39bf-4e8e-b459-3561ef382ab3")) COutOfProcFoo : public IUnknown
{
    ULONG m_ulRefCount;
public:
    COutOfProcFoo(void) : m_ulRefCount(1) { }
    STDMETHOD_(ULONG, AddRef)() { return m_ulRefCount++; }
    STDMETHOD_(ULONG, Release)() { if (--m_ulRefCount == 0) { delete this; return 0; } return m_ulRefCount; }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject) 
    {
        if (ppvObject == NULL) return E_INVALIDARG;
        *ppvObject = NULL;
        if (riid != IID_IUnknown) return E_NOINTERFACE;
        *ppvObject = (IUnknown*)this;
        return this->AddRef(), S_OK;
    }
};

ULONG g_ulServerLocks = 0;

class __declspec(uuid("bf944fe6-54a3-4d27-ad96-16a9d427c01b")) CFooFactory : public IClassFactory
{
public:
    ULONG m_ulRefCount;
    DWORD m_dwRegisteredServerItem;
    CFooFactory(void) : m_dwRegisteredServerItem(0), m_ulRefCount(1) { }
    STDMETHOD_(ULONG, AddRef)() { return m_ulRefCount++; }
    STDMETHOD_(ULONG, Release)() { if (--m_ulRefCount == 0) { delete this; return 0; } return m_ulRefCount; }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject) 
    {
        if (ppvObject == NULL) return E_INVALIDARG;
        *ppvObject = NULL;
        if (riid == IID_IUnknown) *ppvObject = (IUnknown*)this;
        if (riid == IID_IClassFactory) *ppvObject = (IClassFactory*)this;
        return (*ppvObject != NULL) ? this->AddRef(), S_OK : E_NOINTERFACE;
    }

    STDMETHOD(CreateInstance)(IUnknown* punk, REFIID riid, void** ppUnk)
    {
        if (punk != NULL) return CLASS_E_NOAGGREGATION;

        COutOfProcFoo *pFoo = new COutOfProcFoo();
        HRESULT hr = pFoo->QueryInterface(riid, ppUnk);
        pFoo->Release();
        return hr;
    }

    STDMETHOD(LockServer)(BOOL fLock)
    {
        g_ulServerLocks += fLock ? 1 : -1;
        return S_OK;
    }
};

int __cdecl wmain(int argc, WCHAR** argv)
{
    bool fRegister = false;
    bool fCleanup = false;
    bool fClient = false;
    PCWSTR pcwszMachineName = NULL;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    for (int i = 1; i < argc; i++)
    {
        if (lstrcmpiW(argv[i], L"-register") == 0)
            fRegister = true;
        else if (lstrcmpiW(argv[i], L"-unregister") == 0)
            fCleanup = true;
        else if (lstrcmpiW(argv[i], L"-client") == 0)
            fClient = true;
        else if (lstrcmpiW(argv[i], L"-machine") == 0)
            pcwszMachineName = argv[++i];
    }

    if ((fRegister && fCleanup) || (fRegister && fClient) || (fClient && fCleanup))
    {
        wprintf(L"One at a time, please\n");
        return -1;
    }

    //
    // Add to the registry
    //
    if (fRegister)
    {
        HKEY hkClsidRoot;
        ULONG ulResult;
        WCHAR wchLocalPath[MAX_PATH];

        GetModuleFileNameW(NULL, wchLocalPath, MAX_PATH);

        ulResult = RegSetValueW(
            HKEY_CLASSES_ROOT, 
            L"CLSID\\{8af0ddb0-39bf-4e8e-b459-3561ef382ab3}\\LocalServer32",
            REG_SZ,
            wchLocalPath,
            lstrlenW(wchLocalPath) * sizeof(WCHAR));

        if (ulResult != ERROR_SUCCESS)
        {
            wprintf(L"Issues creating localserver32 key default value. - whoops?\n");
            return -1;
        }
    }
    else if (fCleanup)
    {
        ULONG ulResult;

        ulResult = RegDeleteKeyW(HKEY_CLASSES_ROOT, L"CLSID\\{8af0ddb0-39bf-4e8e-b459-3561ef382ab3}\\LocalServer32");
        if (ulResult == ERROR_SUCCESS)
        {
            ulResult = RegDeleteKeyW(HKEY_CLASSES_ROOT, L"CLSID\\{8af0ddb0-39bf-4e8e-b459-3561ef382ab3}");
        }

        wprintf((ulResult == ERROR_SUCCESS) ? L"Successfully uninstalled." : L"Can't uninstall!");

    }
    else if (fClient)
    {
        IUnknown *punk;
        HRESULT hr;
        MULTI_QI mqi;
        COSERVERINFO serverInfo = { 0 };

        mqi.pIID = &IID_IUnknown;
        mqi.pItf = NULL;
        mqi.hr = 0;

        if (pcwszMachineName)
            serverInfo.pwszName = _wcsdup(pcwszMachineName);

        hr = CoCreateInstanceEx(
            __uuidof(COutOfProcFoo),
            NULL,
            CLSCTX_ALL,
            pcwszMachineName ? &serverInfo : NULL,
            1,
            &mqi);

        if (FAILED(hr))
        {
            wprintf(L"Failed cocreate, error code 0x%08x\n", hr);
        }
        else
        {
            wprintf(L"Created fine.\n");
            mqi.pItf->Release();
        }

        if (serverInfo.pwszName)
            free(serverInfo.pwszName);
    }
    else
    {
        CFooFactory *pFactory = new CFooFactory();
        IUnknown *pUnk = NULL;

        if (FAILED(pFactory->QueryInterface(IID_IUnknown, (void**)&pUnk)))
        {
            pFactory->Release();
            return -1;
        }

        CoRegisterClassObject(
            __uuidof(COutOfProcFoo),
            pUnk,
            CLSCTX_SERVER,
            REGCLS_MULTIPLEUSE,
            &pFactory->m_dwRegisteredServerItem
            );

        pUnk->Release();

        while(true)
        {
            Sleep(500);
        }

        CoRevokeClassObject(pFactory->m_dwRegisteredServerItem);
        pFactory->Release();
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\dynamic_windowclass_registration1\dynamic_windowclass_registration1.c ===
#include "windows.h"
#include <stdio.h>

int __cdecl main()
{
    WNDCLASS WindowClass = { 0 };

    GetClassInfo(NULL, "Button", &WindowClass);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\comtests\outofproc\picobject.cpp ===
#include "windows.h"

#define PHDRF_CONTAINER_RELATIVE        (0x00000001)

typedef struct _PIC_OBJECT_HEADER
{
    ULONG ulFlags;
    ULONG ulSize;
    ULONG ulType;
} PIC_OBJECT_HEADER, *PPIC_OBJECT_HEADER;

typedef struct _PIC_CONTAINER
{
    PIC_OBJECT_HEADER Header;           // Header blob
    ULONG ulTotalPicSize;               // How many bytes long is this PIC region?
    ULONG ulIndexTableOffset;           // Index table offset from PIC header
} PIC_CONTAINER, *PPIC_CONTAINER;

#define PSTF_ITEMS_SORTED_BY_STRING     (0x00010000)
#define PSTF_ITEMS_SORTED_BY_IDENT      (0x00020000)
#define PSTF_ITEM_IDENT_IS_HASH         (0x00040000)

typedef struct _PIC_STRING_TABLE
{
    PIC_OBJECT_HEADER Header;
    ULONG ulStringCount;            // Object header
    ULONG ulTableItemsOffset;       // Offset to the table of string items
    ULONG ulContainerBlobOffset;    // Offset to the blob of string data
} PIC_STRING_TABLE, *PPIC_STRING_TABLE;

typedef struct _PIC_STRING_TABLE_ENTRY
{
    ULONG ulStringIdent;
    ULONG ulStringLength;
    ULONG ulOffsetIntoBlob;
} PIC_STRING_TABLE_ENTRY, *PPIC_STRING_TABLE_ENTRY;

#define PBLBF_DATA_FOLLOWS              (0x00010000)    // Data follows this object directly

typedef struct _PIC_DATA_BLOB
{
    PIC_OBJECT_HEADER Header;
    ULONG ulSize;
    ULONG ulOffsetToObject;
} PIC_DATA_BLOB, *PPIC_DATA_BLOB;

//
// An object table acts as an index into a blob of PIC items.  Think of it like a
// top-level directory that you can index into with some pretty trivial functions.
// You can store things by name, identifier, etc.  Type information is also available
//
typedef struct _PIC_OBJECT_TABLE
{
    PIC_OBJECT_HEADER Header;   // Header blob
    ULONG ulEntryCount;         // How many objects?
    ULONG ulTableOffset;        // Offset in the container to the entry table
    ULONG ulStringTableOffset;  // Offset to the stringtable that matches this in container
} PIC_OBJECT_TABLE, *PPIC_OBJECT_TABLE;

#define PIC_OBJTYPE_STRING      ((ULONG)'rtsP') // Object is a string
#define PIC_OBJTYPE_TABLE       ((ULONG)'lbtP') // Object is a string table
#define PIC_OBJTYPE_DIRECTORY   ((ULONG)'ridP') // Object is a directory blob
#define PIC_OBJTYPE_BLOB        ((ULONG)'blbP') // Object is an anonymous blob of data

#define POBJTIF_HAS_STRING      (0x00010000)    // The object table entry string offset is valid
#define POBJTIF_KEY_VALID       (0x00020000)    // The object key value is valid
#define POBJTIF_STRING_IS_INDEX (0x00040000)    // The string value is an index into the table
#define PBOJTIF_STRING_IS_IDENT (0x00080000)    // The string value is an identifier

typedef struct _PIC_OBJECT_TABLE_ENTRY
{
    ULONG ulObjectKey;      // integral key of this object
    ULONG ulObjectType;     // Object type (PIC_OBJ_*)
    ULONG ulStringIdent;    // Identifier in the matching stringtable for this objecttable, if 
    ULONG ulObjectOffset;   // Offset to the object from the table's indicated base addy
} PIC_OBJECT_TABLE_ENTRY, *PPIC_OBJECT_TABLE_ENTRY;

#define PSTRF_UNICODE       (0x00010000)
#define PSTRF_MBCS          (0x00020000)

typedef struct _PIC_STRING
{
    PIC_OBJECT_HEADER Header;           // Header blob
    ULONG ulLength;                     // Length, in bytes, of the string
    ULONG ulContentOffset;              // Relative to either the containing object or the table base.
                                        // Zero indicates that the data is immediately following.
} PIC_STRING, *PPIC_STRING;

//
// C++ analogues to the above structures for easier access
//

class CPicIndexTable;
class CPicHeaderObject;
class CPicReference;

class CPicObject
{
protected:
    PVOID m_pvObjectBase;
    PPIC_OBJECT_HEADER m_pObjectHeader;
    CPicHeaderObject *m_pParentContainer;
    ULONG m_ulObjectOffset;

    PVOID GetObjectPointer() { return m_pvObjectBase; }

public:
    CPicObject(CPicHeaderObject* pOwningObject, ULONG ulOffsetFromParentBase);
    CPicObject(CPicReference pr);

    ULONG GetType() const { return m_pObjectHeader->ulType; }
    ULONG GetSize() const { return m_pObjectHeader->ulSize; }
    ULONG GetFlags() const { return m_pObjectHeader->ulFlags; }
    CPicHeaderObject *GetContainer() const { return m_pParentContainer; }

    CPicReference GetSelfReference();

    friend CPicReference;
};

//
// This is the object that represents the root of a PI object tree.
// You may construct it based on just a PVOID, in which case it assumes
// that there's at least sizeof(PIC_CONTAINER) there to gather details
// from to load the rest of the tree into memory.  Things are created on-
// demand, to optimize for things like memory-mapped files.
//
// PI headers may contain an 'index table' like a card catalog to find
// objects in the structure.
//
class CPicHeaderObject : public CPicObject
{
    PPIC_CONTAINER m_pPicContainerBase; // m_pvBaseOfPic, just cast for easy access
    CPicIndexTable *m_pIndexTable;      // Index table, if present

public:
    CPicHeaderObject(PVOID pvBaseOfCollection);
    CPicHeaderObject(CPicReference objectReference);

    const CPicIndexTable* GetIndexTable();

    friend CPicReference;
};

//
// Index table of objects in this PI blob, referrable by name or key.
//
class CPicIndexTable : public CPicObject
{
    PPIC_OBJECT_TABLE m_pObject;      // Pointer to the actual object table
    PPIC_OBJECT_TABLE_ENTRY m_pObjectList;     // Pointer to the list of object table entries
public:
    CPicIndexTable(CPicReference object);   // Construct this index table based on the object

    bool FindObject(ULONG ulObjectIdent, CPicReference *reference) const;
    bool FindObject(PCWSTR pcwszString, CPicReference *reference) const;
    bool FindObjects(ULONG ulObjectType, ULONG *pulObjectKeys, SIZE_T *cObjectKeys) const;
    ULONG GetObjectCount() const;
};

//
// This reference object can be carted around and be passed from object to
// object.  The CPicObject class works well off these, and every other CPic*
// class has constructors for a reference object.  Basically, this works like
// a pointer ... there's an object base, and an offset into the object.
//
class CPicReference
{
    ULONG m_ulObjectOffsetFromParent;
    CPicHeaderObject *m_pParentObject;
public:
    CPicReference(CPicHeaderObject *pParent, ULONG ulOffset);
    const PVOID GetRawPointer() const;
    ULONG GetOffset() const;
    CPicObject GetObject() const { return CPicObject(m_pParentObject, m_ulObjectOffsetFromParent); }
    void Clear();
};


//
// String table
//
class CPicStringTable : public CPicObject
{
    PPIC_STRING_TABLE m_pObject;
public:
    CPicStringTable(CPicReference object);

    bool GetString(ULONG ulFlags, ULONG ulIdent, WCHAR* pwsStringData, ULONG *ulCbString);
};


CPicIndexTable::CPicIndexTable(CPicReference object) : CPicObject(object)
{
    if (this->GetType() != PIC_OBJTYPE_DIRECTORY)
        DebugBreak();

    // This is just "self"
    m_pObject = (PPIC_OBJECT_TABLE)this->GetObjectPointer();

    // This is the list of objects
    m_pObjectList = (PPIC_OBJECT_TABLE_ENTRY)CPicReference(this->GetContainer(), m_pObject->ulTableOffset).GetRawPointer();
}

//
// Search for an object by its identifier
//
bool
CPicIndexTable::FindObject(ULONG ulObjectIdent, CPicReference *reference) const
{
    if (reference)
        reference->Clear();

    ULONG ul;
    PPIC_OBJECT_TABLE_ENTRY pHere = this->m_pObjectList;

    for (ul = 0;  ul < m_pObject->ulEntryCount; ul++, pHere++)
    {
        if (pHere->ulObjectKey == ulObjectIdent)
        {
            if (reference)
                *reference = CPicReference(this->GetContainer(), pHere->ulObjectOffset);
            return true;
        }
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\shfusion2\uselibc.c ===
/* Copyright (c) Microsoft Corporation */

#define ISOLATION_AWARE_ENABLED 1
#define ISOLATION_AWARE_USE_STATIC_LIBRARY 1
#include "windows.h"
#include "winuser.h"
#include "prsht.h"
#include "commdlg.h"
#include "commctrl.h"
#include <stdio.h>

int __cdecl main()
{
    printf("%p\n", (void*)&LoadLibraryA);
    printf("%p\n", (void*)&LoadLibraryW);
    printf("%p\n", (void*)&CreateWindowExA);
    printf("%p\n", (void*)&CreateWindowExW);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\jonwis\fastsha1\fastsha1.c ===
#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "fastsha1.h"

//
// Note - these numbers are from the FIPS-180-1 standard documentation.
// Don't change them, period.
//
#define FASTSHA1_STATE_INITIAL_H0       (0x67452301)
#define FASTSHA1_STATE_INITIAL_H1       (0xEFCDAB89)
#define FASTSHA1_STATE_INITIAL_H2       (0x98BADCFE)
#define FASTSHA1_STATE_INITIAL_H3       (0x10325476)
#define FASTSHA1_STATE_INITIAL_H4       (0xC3D2E1F0)
#define FASTSHA1_FINALIZATION_BYTE        (0x80)

#define HVALUE( state, which ) ( (state).dwHValues[which] )

#define SHA1STATE_A(state) (HVALUE(state, 0))
#define SHA1STATE_B(state) (HVALUE(state, 1))
#define SHA1STATE_C(state) (HVALUE(state, 2))
#define SHA1STATE_D(state) (HVALUE(state, 3))
#define SHA1STATE_E(state) (HVALUE(state, 4))

#define BLOCK_WORD_LENGTH               ( 16 )
#define SHA1_HASH_RESULT_SIZE           ( 20 )
#define BITS_PER_BYTE                   ( 8 )

static SHA_WORD __fastcall swap_order( SHA_WORD w )
{
    return  ( ( ( (w) >> 24 ) & 0x000000FFL ) |
              ( ( (w) >>  8 ) & 0x0000FF00L ) |
              ( ( (w) <<  8 ) & 0x00FF0000L ) |
              ( ( (w) << 24 ) & 0xFF000000L ) );
}

/*
    b   c   d   b&c ~b  ~b&d    (b&c)|(~b&d)
    0   0   0   0   1   0       0
    0   0   1   0   1   1       1
    0   1   0   0   1   0       0
    0   1   1   0   1   1       1
    1   0   0   0   0   0       0
    1   0   1   0   0   0       0
    1   1   0   1   0   0       1
    1   1   1   1   0   0       1
*/
#define F_00( b, c, d )     ( ( (b) & (c) ) | ( ~(b) & (d) ) )


/*
    b   c   d   b^c     b^c^d
    0   0   0   0       0
    0   0   1   0       1
    0   1   0   1       1
    0   1   1   1       0
    1   0   0   1       1
    1   0   1   1       0
    1   1   0   0       0
    1   1   1   0       1

*/
#define F_01( b, c, d )     ( (b) ^ (c) ^ (d) )


/*
    b   c   d   b&c b&d c&d |
    0   0   0   0   0   0   0
    0   0   1   0   0   0   0
    0   1   0   0   0   0   0
    0   1   1   0   0   1   1
    1   0   0   0   0   0   0
    1   0   1   0   1   0   1
    1   1   0   1   0   0   1
    1   1   1   1   1   1   1

    c&d | (b&(c|d))
*/
//#define F_02( b, c, d )     ( ( (b) & (c) ) | ( (b) & (d) ) | ( (c) & (d) ) )
#define F_02( b, c, d )     ( ( (c) & (d) ) | ( (b) & ( (c) | (d) ) ) )
#define F_03( b, c, d )     ( (b) ^ (c) ^ (d) )

static
BOOL
__FastSHA1HashPreparedMessage(
    PFASTSHA1_STATE pState,
    SHA_WORD* pdwMessage
);


BOOL
InitializeFastSHA1State(
    DWORD dwFlags,
    PFASTSHA1_STATE pState
    )
{
    BOOL bOk = FALSE;

    if ( ( !pState ) ||
         ( pState->cbStruct < sizeof( FASTSHA1_STATE ) ) ||
         ( dwFlags != 0 ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    pState->bIsSha1Locked = FALSE;
    ZeroMemory( pState->bLatestMessage, sizeof( pState->bLatestMessage ) );
    pState->bLatestMessageSize = 0;
    pState->cbTotalMessageSizeInBytes.QuadPart = 0;

    HVALUE( *pState, 0 )  = FASTSHA1_STATE_INITIAL_H0;
    HVALUE( *pState, 1 )  = FASTSHA1_STATE_INITIAL_H1;
    HVALUE( *pState, 2 )  = FASTSHA1_STATE_INITIAL_H2;
    HVALUE( *pState, 3 )  = FASTSHA1_STATE_INITIAL_H3;
    HVALUE( *pState, 4 )  = FASTSHA1_STATE_INITIAL_H4;

    bOk = TRUE;
Exit:
    return bOk;
}


BOOL
FinalizeFastSHA1State(
    DWORD dwFlags,
    PFASTSHA1_STATE pState
    )
/*++

Finalizing a SHA1 hash locks the hash state so its value can be queried.
It also ensures that the right padding is done w.r.t. the total bit length
and whatnot required by the SHA1 hash spec.

1 - This should have been called right after a HashMoreFastSHA1Data, so either
    the buffer is entirely empty, or it's got at least eight bits left.

2 - Figure out what the last byte in the message is (easy enough).  The next
    byte should be set to 0x80 - 10000000b.

3 - If this buffer has less than

--*/
{
    BOOL bOk = FALSE;
    LARGE_INTEGER TotalBitsInMessage;
    LARGE_INTEGER *pMsgSizeLocation;

    if ( ( !pState ) ||
         ( pState->cbStruct < sizeof(FASTSHA1_STATE ) ) ||
         ( pState->bIsSha1Locked ) ||
         ( dwFlags != 0 ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }


    //
    // Finalize the SHA1 state data.  This is annoying, but not difficult..
    //

    //
    // When we're in this state, we should have at least one byte of data left over to
    // or in our final flag.  If not, something bad happened at some point along the
    // line.
    //
    if ( ( pState->bLatestMessageSize - SHA1_MESSAGE_BYTE_LENGTH ) < 1 )
    {
        SetLastError( ERROR_INTERNAL_ERROR );
        goto Exit;
    }

    //
    // Into the byte right after the last one we have seen so far, inject a high-bit
    // one.  This translates to 0x80 (see the #define above), since we don't deal in
    // non-integral-byte-numbers of bits.  This bit does NOT change the total number of
    // bits in the message!
    //
    pState->bLatestMessage[pState->bLatestMessageSize++] = FASTSHA1_FINALIZATION_BYTE;

    //
    // We need some space to put the bit count to this point.  If we don't have at least
    // two sha-words (64 bits) in the end of the message, then we need to add this blob
    // of bits to the resulting hash so far.
    //
    if ( ( SHA1_MESSAGE_BYTE_LENGTH - pState->bLatestMessageSize ) < ( sizeof(SHA_WORD) * 2 ) )
    {
        __FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pState->bLatestMessage );
        ZeroMemory( pState->bLatestMessage, sizeof(pState->bLatestMessage) );
        pState->bLatestMessageSize = 0;
    }

    //
    // Now stick the byte count at the end of the blob
    //
    TotalBitsInMessage.QuadPart = pState->cbTotalMessageSizeInBytes.QuadPart * BITS_PER_BYTE;

    //
    // Point our size thing at the right place
    //
    pMsgSizeLocation = (LARGE_INTEGER*)(pState->bLatestMessage + (SHA1_MESSAGE_BYTE_LENGTH - (sizeof(SHA_WORD)*2)));

    //
    // This bit of a mess actually puts the length bits in the right order.
    //
    pMsgSizeLocation->LowPart = swap_order( TotalBitsInMessage.HighPart );
    pMsgSizeLocation->HighPart = swap_order( TotalBitsInMessage.LowPart );

    //
    // And run the hash over this final blob
    //
    __FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pState->bLatestMessage );

    //
    // Rotate our bits around.  This has the unintended side-effect of locking
    // the blob of H-values by messing with their byte order.  All the modifying functions
    // (except initialize) will choke if you try and do something like hash more data
    // with a locked state.
    //
    pState->dwHValues[0] = swap_order( pState->dwHValues[0] );
    pState->dwHValues[1] = swap_order( pState->dwHValues[1] );
    pState->dwHValues[2] = swap_order( pState->dwHValues[2] );
    pState->dwHValues[3] = swap_order( pState->dwHValues[3] );
    pState->dwHValues[4] = swap_order( pState->dwHValues[4] );

    //
    // We're done!
    //
    pState->bIsSha1Locked = TRUE;

    bOk = TRUE;
Exit:
    return bOk;
}





BOOL
GetFastSHA1Result( PFASTSHA1_STATE pState, PBYTE pdwDestination, PSIZE_T cbDestination )
{
    BOOL bOk = FALSE;
    SHA_WORD *pSrc, *pDst;

    //
    // If you are seeing this, something bad has happened with the sizes of things.
    //
    C_ASSERT( SHA1_HASH_RESULT_SIZE == 20 );
    C_ASSERT( SHA1_HASH_RESULT_SIZE == sizeof(pState->dwHValues) );

    if ( !pState || !cbDestination )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    //
    // No fair getting the internal state until you're done with the sha1.
    // IE: Call FinalizeFastSHA1Hash() before requesting the result.
    //
    if ( !pState->bIsSha1Locked )
    {
        SetLastError( ERROR_INVALID_STATE );
        goto Exit;
    }


    //
    // If there's no destination specified, then we'll need to tell them how big
    // the data really is.
    //
    if ( !pdwDestination )
    {
        *cbDestination = SHA1_HASH_RESULT_SIZE;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        goto Exit;
    }


    //
    // Otherwise, copy the state out of the state object and into the desination
    //
    pSrc = pState->dwHValues;
    pDst = (SHA_WORD*)pdwDestination;

    pDst[0] = pSrc[0];
    pDst[1] = pSrc[1];
    pDst[2] = pSrc[2];
    pDst[3] = pSrc[3];
    pDst[4] = pSrc[4];

    bOk = TRUE;
Exit:
    return bOk;
}




//
// These define the core functions of the bit-twiddling in the SHA1 hash
// routine.  If you want optimization, try these first.
// RotateBitsLeft could probably get a boost if we used rol/ror on x86.
//
#define RotateBitsLeft( w, sh ) ( ( w << sh ) | ( w >> ( 32 - sh ) ) )

#define fidgetcore( f, cnst, i ) \
        Temp = cnst + E + WorkBuffer[i] + f( B, C, D ) + RotateBitsLeft( A, 5 ); \
        E = D; \
        D = C;  \
        C = RotateBitsLeft( B, 30 ); \
        B = A; \
        A = Temp;


static void
__fastcall __FastSHA1TwiddleBitsCore( SHA_WORD *state, SHA_WORD *WorkBuffer )
{
    register SHA_WORD A, B, C, D, E, Temp;
    register SHA_WORD i;

    A = state[0];
    B = state[1];
    C = state[2];
    D = state[3];
    E = state[4];

    i = 0;
    {
        // Temp = RotateBitsLeft( A, 5 ) + E + WorkBuffer[i] + F_00(B,C,D) + 0x5a827999;
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
        fidgetcore( F_00, 0x5a827999, i++ );
    }

    {
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
        fidgetcore( F_01, 0x6ed9eba1, i++ );
    }

    {
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
        fidgetcore( F_02, 0x8f1bbcdc, i++ );
    }

    {
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
        fidgetcore( F_03, 0xca62c1d6, i++ );
    }

    state[0] += A;
    state[1] += B;
    state[2] += C;
    state[3] += D;
    state[4] += E;

}



static
BOOL
__FastSHA1HashPreparedMessage(
    PFASTSHA1_STATE pState,
    SHA_WORD* pdwMessage
    )
{
    BOOL bOk = FALSE;

    //
    // This function makes a few assumptions.  First, it assumes that pdwMessage really
    // is 16 sha-words long.  If that's not the case, prepare yourself for some
    // ugly errors.  That's why this is static inline - don't be calling this except
    // via HashMoreFastSHA1Data.
    //
    SHA_WORD WorkBuffer[80];
    register SHA_WORD A, B, C, D, E;
    register SHA_WORD Temp;
    register int t;

    if ( !pdwMessage || !pState )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    if ( pState->bIsSha1Locked )
    {
        SetLastError( ERROR_INVALID_STATE );
        goto Exit;
    }

    // Loop unrolling seemed to help a little
    {
        register SHA_WORD *pWB = WorkBuffer;
        register SHA_WORD *pMSG = pdwMessage;
        t = 16;

        while ( t ) {
            *(pWB+0) = swap_order( *(pMSG+0) );
            *(pWB+1) = swap_order( *(pMSG+1) );
            *(pWB+2) = swap_order( *(pMSG+2) );
            *(pWB+3) = swap_order( *(pMSG+3) );
            pWB+=4;
            pMSG+=4;
            t-=4;
        }
    }

    {
        register SHA_WORD *pWB = WorkBuffer+16;
        register SHA_WORD *pWBm3 = pWB-3;
        register SHA_WORD *pWBm8 = pWB-8;
        register SHA_WORD *pWBm14 = pWB-14;
        register SHA_WORD *pWBm16 = pWB-16;
        register DWORD i = 80 - 16;

        while ( i ) {
            *(pWB+0) = *(pWBm3+0) ^ *(pWBm8+0) ^ *(pWBm14+0) ^ *(pWBm16+0);
            *(pWB+1) = *(pWBm3+1) ^ *(pWBm8+1) ^ *(pWBm14+1) ^ *(pWBm16+1);
            *(pWB+2) = *(pWBm3+2) ^ *(pWBm8+2) ^ *(pWBm14+2) ^ *(pWBm16+2);
            *(pWB+3) = *(pWBm3+3) ^ *(pWBm8+3) ^ *(pWBm14+3) ^ *(pWBm16+3);
            *(pWB+4) = *(pWBm3+4) ^ *(pWBm8+4) ^ *(pWBm14+4) ^ *(pWBm16+4);
            *(pWB+5) = *(pWBm3+5) ^ *(pWBm8+5) ^ *(pWBm14+5) ^ *(pWBm16+5);
            *(pWB+6) = *(pWBm3+6) ^ *(pWBm8+6) ^ *(pWBm14+6) ^ *(pWBm16+6);
            *(pWB+7) = *(pWBm3+7) ^ *(pWBm8+7) ^ *(pWBm14+7) ^ *(pWBm16+7);
            pWB += 8;
            i -= 8;
        }
    }


    //
    // Part c - Start off the A-F values
    //
    // A = H_0, B = H_1, C = H_2, D = H_3, E = H_4
    //
    __FastSHA1TwiddleBitsCore( pState->dwHValues, WorkBuffer );

    bOk = TRUE;
Exit:
    return bOk;
}


void __fastcall
__ZeroFastSHA1Message( PFASTSHA1_STATE pState )
{
    SHA_WORD *pStateData = (SHA_WORD*)pState->bLatestMessage;
    pState->bLatestMessageSize = 0;

    pStateData[0x0] = 0x0;
    pStateData[0x1] = 0;
    pStateData[0x2] = 0;
    pStateData[0x3] = 0;
    pStateData[0x4] = 0;
    pStateData[0x5] = 0;
    pStateData[0x6] = 0;
    pStateData[0x7] = 0;
    pStateData[0x8] = 0;
    pStateData[0x9] = 0;
    pStateData[0xa] = 0;
    pStateData[0xb] = 0;
    pStateData[0xc] = 0;
    pStateData[0xd] = 0;
    pStateData[0xe] = 0;
    pStateData[0xf] = 0;

}





BOOL
HashMoreFastSHA1Data( PFASTSHA1_STATE pState, PBYTE pbData, SIZE_T cbData )
{
    BOOL bOk = FALSE;
    ULONG cbStreamBlocksThisRound, cbStreamBytesLeftAtEnd;

    if ( !pState || !pbData )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    if ( pState->bIsSha1Locked )
    {
        SetLastError( ERROR_INVALID_STATE );
        goto Exit;
    }

	pState->cbTotalMessageSizeInBytes.QuadPart += cbData;

    //
    // Start off by filling in the pending message buffer block if we can.
    //
    if ( pState->bLatestMessageSize != 0 )
    {
        //
        // Copy into our internal state buffer, then hash what we found.
        //
        SIZE_T cbFiller = sizeof(pState->bLatestMessage) - pState->bLatestMessageSize;
        cbFiller = ( cbFiller > cbData ? cbData : cbFiller );
        memcpy( pState->bLatestMessage + pState->bLatestMessageSize, pbData, cbFiller );

        //
        // Bookkeeping
        //
        cbData -= cbFiller;
        pbData += cbFiller;
        pState->bLatestMessageSize += cbFiller;

        //
        // If that got us up to a full message, then update state.
        //
        if ( pState->bLatestMessageSize == SHA1_MESSAGE_BYTE_LENGTH )
        {
            __FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pState->bLatestMessage );
            __ZeroFastSHA1Message( pState );
        }
        //
        // Otherwise, we still don't have enough to fill up a single buffer, so don't
        // bother doing anything else here.
        //
        else
        {
            bOk = TRUE;
            goto Exit;
        }
    }

    //
    // Now that we've aligned our buffer, find out how many blocks we can process in
    // this input stream.
    //
    cbStreamBlocksThisRound = cbData / SHA1_MESSAGE_BYTE_LENGTH;
    cbStreamBytesLeftAtEnd = cbData % SHA1_MESSAGE_BYTE_LENGTH;

    //
    // Spin through all the full blocks
    //
	if ( cbStreamBlocksThisRound )
	{
		while ( cbStreamBlocksThisRound-- )
		{
			__FastSHA1HashPreparedMessage( pState, (SHA_WORD*)pbData );
			pbData += SHA1_MESSAGE_BYTE_LENGTH;
		}
		__ZeroFastSHA1Message( pState );
	}

    //
    // And account for leftovers
    //
    if ( cbStreamBytesLeftAtEnd )
    {
        pState->bLatestMessageSize = cbStreamBytesLeftAtEnd;
        memcpy( pState->bLatestMessage, pbData, cbStreamBytesLeftAtEnd );
        ZeroMemory( pState->bLatestMessage + cbStreamBytesLeftAtEnd, SHA1_MESSAGE_BYTE_LENGTH - cbStreamBytesLeftAtEnd );
    }


    bOk = TRUE;
Exit:
    return bOk;
}

BOOL
CompareFashSHA1Hashes(
    PFASTSHA1_STATE pStateLeft,
    PFASTSHA1_STATE pStateRight,
    BOOL *pbComparesEqual
    )
{
    BOOL bOk = FALSE;

    if ( pbComparesEqual ) *pbComparesEqual = FALSE;

    if ( !pStateLeft || !pStateRight || !pbComparesEqual )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    if ( !pStateLeft->bIsSha1Locked || !pStateRight->bIsSha1Locked )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto Exit;
    }

    //
    // Easy way out: compare the two blobs of H's to see if they're equal.
    //
    *pbComparesEqual = ( memcmp(
            pStateLeft->dwHValues,
            pStateRight->dwHValues,
            sizeof(SHA_WORD)*5 ) == 0 );

    bOk = TRUE;
Exit:
    return bOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\jonwis\fastsha1\harness.cpp ===
#define FUSION_PROFILING 1
#define DBG 1

#include "windows.h"
#include "wincrypt.h"
#include "stdlib.h"
#include "stdio.h"
#include "fastsha1.h"
#include "fusionbuffer.h"
#include "perfclocking.h"

FASTSHA1_STATE ShaState;
#define ASM_CPUID { __asm cpuid }
#define ASM_RDTSC { __asm rdtsc }
#define NUMBER_OF( n ) ( sizeof(n) / sizeof(*n) )
#define INPUT_BLOCK_SIZE ( 4096*4 )

inline VOID GetCpuIdLag( LARGE_INTEGER *ref )
{
LARGE_INTEGER temp, temp2;
#if !defined(_WIN64)
_asm
{
cpuid
cpuid
cpuid
cpuid
cpuid
rdtsc
mov temp.LowPart, eax
mov temp.HighPart, edx
cpuid
rdtsc
mov temp2.LowPart, eax
mov temp2.HighPart, edx
}

ref->QuadPart = temp2.QuadPart - temp.QuadPart;
#else
ref->QuadPart = 0;
#endif
}

LARGE_INTEGER CpuIdLag;

BYTE TestCase1[] = { 0x61, 0x62, 0x63 };
BYTE TestCase2[] = {
	0x61, 0x62, 0x63, 0x64,
	0x62, 0x63, 0x64, 0x65,
	0x63, 0x64, 0x65, 0x66,
	0x64, 0x65, 0x66, 0x67,
	0x65, 0x66, 0x67, 0x68,
	0x66, 0x67, 0x68, 0x69,
	0x67, 0x68, 0x69, 0x6A,
	0x68, 0x69, 0x6A, 0x6B,
	0x69, 0x6A, 0x6B, 0x6C,
	0x6A, 0x6B, 0x6C, 0x6D,
	0x6B, 0x6C, 0x6D, 0x6E,
	0x6C, 0x6D, 0x6E, 0x6F,
	0x6D, 0x6E, 0x6F, 0x70,
	0x6E, 0x6F, 0x70, 0x71
};

HCRYPTPROV hProvider;
#define CHECKFAIL( f ) do { if ( !(f) ) return FALSE; } while ( 0 )

BOOL ObtainFastSHA1OfFile( PBYTE pvBase, SIZE_T cbSize, BYTE bShaHashData[20], PSIZE_T pcbSize )
{
	FUSION_PERF_INFO InfoSlots[4];
	FASTSHA1_STATE State;
	
	State.cbStruct = sizeof( State );
	
	PERFINFOTIME( &InfoSlots[0], CHECKFAIL( InitializeFastSHA1State( 0, &State ) ) );
	while ( cbSize )
	{
		DWORD dwThisSize = ( cbSize > INPUT_BLOCK_SIZE ) ? INPUT_BLOCK_SIZE : cbSize;

		PERFINFOTIME( &InfoSlots[1], CHECKFAIL( HashMoreFastSHA1Data( 
			&State, 
			pvBase, 
			dwThisSize
		) ) );
		pvBase += dwThisSize;
		cbSize -= dwThisSize;
	}
	PERFINFOTIME( &InfoSlots[2], CHECKFAIL( FinalizeFastSHA1State( 0, &State ) ) );
	PERFINFOTIME( &InfoSlots[3], CHECKFAIL( GetFastSHA1Result( &State, bShaHashData, pcbSize ) ) );
	FusionpReportPerfInfo( 
		FUSIONPERF_DUMP_TO_STDOUT |
		FUSIONPERF_DUMP_ALL_STATISTICS |
		FUSIONPERF_DUMP_ALL_SOURCEINFO,
		InfoSlots,
		NUMBER_OF( InfoSlots )
	);
	printf("\n\n");
	return TRUE;
}

BOOL ObtainReferenceSHA1Hash( PBYTE pvBase, SIZE_T cbSize, BYTE bShaHashData[20], PDWORD pdwData )
{
	FUSION_PERF_INFO InfoSlots[4];
	FASTSHA1_STATE State;
	DWORD dwDump;
	HCRYPTHASH hHash;

	PERFINFOTIME( &InfoSlots[0], CHECKFAIL( CryptCreateHash( hProvider, CALG_SHA1, NULL, 0, &hHash ) ) );
	while ( cbSize )
	{
		DWORD dwThisSize = ( cbSize > INPUT_BLOCK_SIZE ) ? INPUT_BLOCK_SIZE : cbSize;
		PERFINFOTIME( &InfoSlots[1], CHECKFAIL( CryptHashData( hHash, pvBase, dwThisSize, 0 ) ) );
		cbSize -= dwThisSize;
		pvBase += dwThisSize;
	}
	PERFINFOTIME( &InfoSlots[2], CHECKFAIL( CryptGetHashParam( 
		hHash,
		HP_HASHVAL,
		bShaHashData,
		pdwData,
		0
	) ) );
	PERFINFOTIME( &InfoSlots[3], CHECKFAIL( CryptDestroyHash( hHash ) ) );

	FusionpReportPerfInfo( 
		FUSIONPERF_DUMP_TO_STDOUT |
		FUSIONPERF_DUMP_ALL_STATISTICS |
		FUSIONPERF_DUMP_ALL_SOURCEINFO,
		InfoSlots,
		NUMBER_OF( InfoSlots )
	);

	printf("\n\n");
	return TRUE;
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
	BYTE bDestination[20];
	SIZE_T cbDestination;
	int i = 0;

ShaState.cbStruct = sizeof( ShaState );
InitializeFastSHA1State( 0, &ShaState );
HashMoreFastSHA1Data( &ShaState, TestCase1, sizeof( TestCase1 ) );
FinalizeFastSHA1State( 0, &ShaState );



	GetCpuIdLag( &CpuIdLag );
	CryptAcquireContextW( &hProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_SILENT | CRYPT_VERIFYCONTEXT );

	BYTE bReferenceHash[20], bFastHash[20];
	SIZE_T cbReferenceHash, cbFastHash;
	HANDLE hFile, hFileMapping;
	PBYTE pbFileContents;
	DWORD dwFileContents;

	if ( GetFileAttributesW( argv[1] ) & FILE_ATTRIBUTE_DIRECTORY )
	{
		printf( "dir  : %ls\n", argv[1] );
		return 0;
	}

	hFile = CreateFileW( argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( hFile == INVALID_HANDLE_VALUE ) goto ErrorPath;
	
	hFileMapping = CreateFileMapping( hFile, NULL, PAGE_READONLY, 0, 0, NULL );
	if ( ( hFileMapping == NULL ) || ( hFileMapping == INVALID_HANDLE_VALUE ) ) goto ErrorPath;

	pbFileContents = (PBYTE)MapViewOfFile( hFileMapping, FILE_MAP_READ, 0, 0, 0 );
	if ( pbFileContents == NULL ) goto ErrorPath;

	dwFileContents = GetFileSize( hFile, NULL );

	if ( !ObtainReferenceSHA1Hash( 
		pbFileContents, 
		dwFileContents, 
		bReferenceHash, 
		&(cbReferenceHash = sizeof(bReferenceHash))
	) )
	{
		printf("(Reference failed) ");
		goto ErrorPath;
	}

	if ( !ObtainFastSHA1OfFile( 
		pbFileContents, 
		dwFileContents, 
		bFastHash, 
		&(cbFastHash = sizeof(bFastHash))
	) )
	{
		printf( "(fastsha1 failed) " );
		goto ErrorPath;
	}

	if ( memcmp( bFastHash, bReferenceHash, 20 ) == 0 )
	{
		printf( "match: %ls\n", argv[1] );
	}
	else
	{
		printf( "fails: %ls\n", argv[1] );
	}
	
	CryptReleaseContext( hProvider, 0 );
return 0;   

ErrorPath:
	printf( "Failure: 0x%08x on file %ls\n", GetLastError(), argv[1] );
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\jonwis\fastsha1\fastsha1.h ===
#pragma once

typedef DWORD SHA_WORD;
#define SHA1_MESSAGE_BYTE_LENGTH        ( 512/8 )

typedef struct _tagFASTSHA1_STATE
{
    DWORD           cbStruct;
    BOOL            bIsSha1Locked;
    SHA_WORD        dwHValues[5];
    BYTE            bLatestMessage[SHA1_MESSAGE_BYTE_LENGTH];
    DWORD           bLatestMessageSize;
    LARGE_INTEGER   cbTotalMessageSizeInBytes;
}
FASTSHA1_STATE, *PFASTSHA1_STATE;

#ifdef __cplusplus
extern "C" {
#endif

BOOL
InitializeFastSHA1State(
    DWORD dwFlags,
    PFASTSHA1_STATE pState
);


BOOL
FinalizeFastSHA1State(
    DWORD dwFlags,
    PFASTSHA1_STATE pState
);



BOOL
GetFastSHA1Result(
    PFASTSHA1_STATE pState,
    PBYTE pdwDestination,
    PSIZE_T cbDestination
);


BOOL
HashMoreFastSHA1Data(
    PFASTSHA1_STATE pState,
    PBYTE pbData,
    SIZE_T cbData
);

BOOL
CompareFashSHA1Hashes(
    PFASTSHA1_STATE pStateLeft,
    PFASTSHA1_STATE pStateRight,
    BOOL *pbComparesEqual
);

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\shfusion2\inline\inline2.c ===
/* Copyright (c) Microsoft Corporation */

#define ISOLATION_AWARE_ENABLED 1
#include "windows.h"
#include "winuser.h"
#include "prsht.h"
#include "commdlg.h"
#include "commctrl.h"
#include <stdio.h>

void Test_Shfusion2_Inline2C()
{
    printf("%p\n", (void*)&CreateWindowExA);
    printf("%p\n", (void*)&CreateWindowExW);
    printf("%p\n", (void*)&LoadLibraryA);
    printf("%p\n", (void*)&LoadLibraryW);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\shfusion2\uselibcpp.cpp ===
/* Copyright (c) Microsoft Corporation */

#include "uselibc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\shfusion2\inline\inlinec.c ===
/* Copyright (c) Microsoft Corporation */

#define ISOLATION_AWARE_ENABLED 1
#include "windows.h"
#include "winuser.h"
#include "prsht.h"
#include "commdlg.h"
#include "commctrl.h"
#include <stdio.h>

void Test_Shfusion2_InlineC(void);
void Test_Shfusion2_InlineCpp(void);
void Test_Shfusion2_Inline2C(void);

void Test_Shfusion2_InlineC()
{
    printf("%p\n", (void*)&CreateWindowExA);
    printf("%p\n", (void*)&CreateWindowExW);
    printf("%p\n", (void*)&LoadLibraryA);
    printf("%p\n", (void*)&LoadLibraryW);
}

int __cdecl main()
{
    Test_Shfusion2_InlineC();
    Test_Shfusion2_Inline2C();
    Test_Shfusion2_InlineCpp();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\shfusion2\makelibc\makelibc.c ===
/* Copyright (c) Microsoft Corporation */

#define ISOLATION_AWARE_ENABLED 1
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 1
#include "windows.h"
#include "winuser.h"
#include "prsht.h"
#include "commdlg.h"
#include "commctrl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\shfusion2\inline\inlinecpp.cpp ===
/* Copyright (c) Microsoft Corporation */

#define ISOLATION_AWARE_ENABLED 1
#include "windows.h"
#include "winuser.h"
#include "prsht.h"
#include "commdlg.h"
#include "commctrl.h"
#include <stdio.h>

extern "C"
void Test_Shfusion2_InlineCpp()
{
    printf("%p\n", (void*)&LoadLibraryW);
    printf("%p\n", (void*)&LoadLibraryA);
    printf("%p\n", (void*)&CreateWindowExW);
    printf("%p\n", (void*)&CreateWindowExA);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\mgrier\tsp\tsp.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    csrdbgmon.cpp

Abstract:

Author:

    Michael Grier (MGrier) June 2002

Revision History:

    Jay Krell (Jaykrell) June 2002
        make it compile for 64bit
        tabs to spaces
        init some locals
        make some tables const

--*/
#include <windows.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <dbghelp.h>

#define ASSERT(x) do { /* nothing */ } while(0)

#define NUMBER_OF(_x) (sizeof(_x) / sizeof((_x)[0]))

static const char g_szImage[] = "csrdbgmon";
static const char *g_pszImage = g_szImage;

static PCWSTR g_pszDefaultExtension = NULL;

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;

    int i;
    bool fNoMoreSwitches = false;

    i = 1;

    while (i < argc)
    {
        bool fDoSearch = true;

        if (!fNoMoreSwitches && (argv[i][0] == L'-'))
        {
            if (_wcsicmp(argv[i], L"-ext") == 0)
            {
                i++;
                if (i < argc)
                {
                    if (_wcsicmp(argv[i], L"-") == 0)
                    {
                        g_pszDefaultExtension = NULL;
                        i++;
                    }
                    else
                        g_pszDefaultExtension = argv[i++];
                }

                fDoSearch = false;
            }
            else if (_wcsicmp(argv[i], L"-nomoreswitches") == 0)
            {
                i++;
                fNoMoreSwitches = true;
                fDoSearch = false;
                break;
            }
        }

        if (fDoSearch)
        {
            WCHAR rgwchBuffer[512];
            PWSTR pszFilePart = NULL;
            DWORD dw = ::SearchPathW(NULL, argv[i], g_pszDefaultExtension, NUMBER_OF(rgwchBuffer), rgwchBuffer, &pszFilePart);
            if (dw != 0)
            {
                ULONG cch = (ULONG) (((ULONG_PTR) pszFilePart) - ((ULONG_PTR) rgwchBuffer));

                if (g_pszDefaultExtension != NULL)
                {
                    printf(
                        "SearchPathW(NULL, \"%ls\", \"%ls\", %lu, %p, %p) succeeded\n"
                        "   Return Value: %lu\n"
                        "   Returned Path: \"%ls\"\n"
                        "   pszFilePart: %p \"%ls\" (%lu chars in)\n",
                        argv[i], g_pszDefaultExtension, NUMBER_OF(rgwchBuffer), rgwchBuffer, &pszFilePart,
                        dw,
                        rgwchBuffer,
                        pszFilePart, pszFilePart, cch);
                }
                else
                {
                    printf(
                        "SearchPathW(NULL, \"%ls\", NULL, %lu, %p, %p) succeeded\n"
                        "   Return Value: %lu\n"
                        "   Returned Path: \"%ls\"\n"
                        "   pszFilePart: %p \"%ls\" (%lu chars in)\n",
                        argv[i], NUMBER_OF(rgwchBuffer), rgwchBuffer, &pszFilePart,
                        dw,
                        rgwchBuffer,
                        pszFilePart, pszFilePart, cch);
                }
            }
            else
            {
                const DWORD dwLastError = ::GetLastError();

                if (g_pszDefaultExtension != NULL)
                {
                    printf(
                        "SearchPathW(NULL, \"%ls\", \"%ls\", %lu, %p, %p) failed\n",
                        argv[i], g_pszDefaultExtension, NUMBER_OF(rgwchBuffer), rgwchBuffer, &pszFilePart);
                }
                else
                {
                    printf(
                        "SearchPathW(NULL, \"%ls\", NULL, %lu, %p, %p) failed\n",
                        argv[i], NUMBER_OF(rgwchBuffer), rgwchBuffer, &pszFilePart);
                }

                printf("   GetLastError() returned: %lu\n", dwLastError);
            }

            i++;
        }
    }

    iReturnStatus = EXIT_SUCCESS;

//Exit:
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\shfusion2\makelibcpp\makelibcpp.cpp ===
/* Copyright (c) Microsoft Corporation */

#define ISOLATION_AWARE_ENABLED 1
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 1
#include "windows.h"
#include "winuser.h"
#include "prsht.h"
#include "commdlg.h"
#include "commctrl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dlldatax.h ===
// Copyright (c) Microsoft Corporation
#if !defined(AFX_DLLDATAX_H__F2FA5566_54AD_4B7B_BF50_9BE72F4A457B__INCLUDED_)
#define AFX_DLLDATAX_H__F2FA5566_54AD_4B7B_BF50_9BE72F4A457B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__F2FA5566_54AD_4B7B_BF50_9BE72F4A457B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dlldatax.c ===
// Copyright (c) Microsoft Corporation
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#endif
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\makefile.inc ===
# We don't want all that SXS_MANIFEST_IN_RESOURCES implies.
# This doesn't work completely, we still get extra rc_temp files, but their contents
# are ok.
!if "$(NUMBER_OF_MANIFESTS)" != "0" && "$(NUMBER_OF_MANIFESTS)" != "1"
!undef RC_FORCE_INCLUDE_STRING
!undef RC_FORCE_INCLUDE_FILES
RC_FORCE_INCLUDE_FILES_CMD=echo.
!endif

.SUFFIXES: .mansrc .man

{}.mansrc{$(O)\}.man:
    $(CXX_COMPILER_NAME) $(SXS_MANIFEST_DEFINES) $(CXX_COMPILER_FLAGS) -EP $(USE_FC) $< | perl <<$(O)\cleanup_rgs.pl > $@
$$file = join("", <>);      # read all the lines into one string
$$file =~ s/^#.+$$//gm;     # remove preprocessor directives
$$file =~ s/\n+/\n/gms;     # remove empty lines
print($$file);              # and print it all back out
<<KEEP

$(O)\sxstest_lib.obj: ..\..\sxstest.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\peb.h ===
/*
This file is meant only to assist in ensuring offsets in peb and teb
are maintained while editing base\published\pebteb.w.
*/
PEB_MEMBER(InheritedAddressSpace)
PEB_MEMBER(ReadImageFileExecOptions)
PEB_MEMBER(BeingDebugged)
PEB_MEMBER(SpareBool)
PEB_MEMBER(Mutant)
PEB_MEMBER(ImageBaseAddress)
PEB_MEMBER(Ldr)
PEB_MEMBER(ProcessParameters)
PEB_MEMBER(SubSystemData)
PEB_MEMBER(ProcessHeap)
PEB_MEMBER(FastPebLock)
PEB_MEMBER(SparePtr1)
PEB_MEMBER(SparePtr2)
PEB_MEMBER(EnvironmentUpdateCount)
PEB_MEMBER(KernelCallbackTable)
PEB_MEMBER(SystemReserved)
PEB_MEMBER(FreeList)
PEB_MEMBER(TlsExpansionCounter)
PEB_MEMBER(TlsBitmap)
PEB_MEMBER(TlsBitmapBits)
PEB_MEMBER(ReadOnlySharedMemoryBase)
PEB_MEMBER(ReadOnlySharedMemoryHeap)
PEB_MEMBER(ReadOnlyStaticServerData)
PEB_MEMBER(AnsiCodePageData)
PEB_MEMBER(OemCodePageData)
PEB_MEMBER(UnicodeCaseTableData)
PEB_MEMBER(NumberOfProcessors)
PEB_MEMBER(NtGlobalFlag)
PEB_MEMBER(CriticalSectionTimeout)
PEB_MEMBER(HeapSegmentReserve)
PEB_MEMBER(HeapSegmentCommit)
PEB_MEMBER(HeapDeCommitTotalFreeThreshold)
PEB_MEMBER(HeapDeCommitFreeBlockThreshold)
PEB_MEMBER(NumberOfHeaps)
PEB_MEMBER(MaximumNumberOfHeaps)
PEB_MEMBER(ProcessHeaps)
PEB_MEMBER(GdiSharedHandleTable)
PEB_MEMBER(ProcessStarterHelper)
PEB_MEMBER(GdiDCAttributeList)
PEB_MEMBER(LoaderLock)
PEB_MEMBER(OSMajorVersion)
PEB_MEMBER(OSMinorVersion)
PEB_MEMBER(OSBuildNumber)
PEB_MEMBER(OSCSDVersion)
PEB_MEMBER(OSPlatformId)
PEB_MEMBER(ImageSubsystem)
PEB_MEMBER(ImageSubsystemMajorVersion)
PEB_MEMBER(ImageSubsystemMinorVersion)
PEB_MEMBER(ImageProcessAffinityMask)
PEB_MEMBER(GdiHandleBuffer)
PEB_MEMBER(PostProcessInitRoutine)
PEB_MEMBER(TlsExpansionBitmap)
PEB_MEMBER(TlsExpansionBitmapBits)
PEB_MEMBER(SessionId)
PEB_MEMBER(AppCompatFlags)
PEB_MEMBER(AppCompatFlagsUser)
PEB_MEMBER(pShimData)
PEB_MEMBER(AppCompatInfo)
PEB_MEMBER(CSDVersion)
PEB_MEMBER(ActivationContextData)
PEB_MEMBER(ProcessAssemblyStorageMap)
PEB_MEMBER(SystemDefaultActivationContextData)
PEB_MEMBER(SystemAssemblyStorageMap)
PEB_MEMBER(MinimumStackCommit)
PEB_MEMBER(FlsCallback)
PEB_MEMBER(FlsListHead)
PEB_MEMBER(FlsBitmap)
PEB_MEMBER(FlsBitmapBits)
PEB_MEMBER(FlsHighIndex)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxstest.cpp ===
// Copyright (c) Microsoft Corporation
#include "stdinc.h" // actually from dll\whistler directory
/*-----------------------------------------------------------------------------
Side X ("by") Side Test
-----------------------------------------------------------------------------*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "lm.h"
#include "lmdfs.h"
#define CRegKey ATL_CRegKey
#include "atlbase.h"
#undef CRegKey
#include "fusionlastwin32error.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include "fusionbuffer.h"
#include "fusion.h"
#include "sxsasmname.h"
#include "util.h"
#include "sxsapi.h"
#include "fusiontrace.h"
#include "wintrust.h"
#include "softpub.h"
#include "perfclocking.h"
#include "strongname.h"
#include "fusionversion.h"
#include <setupapi.h>
#include "commctrl.h"
#include "fusionsha1.h"
#include "cguid.h"
#include "winbasep.h"
#include "sxstest_idl.h"
#include <time.h>
#include "fusiondump.h"
#include "imagehlp.h"
#undef ADDRESS
#undef LoadLibraryA
#undef LoadLibraryW
#undef LoadLibraryExA
#undef LoadLibraryExW
#undef InitCommonControls
BOOL IamExe;
BOOL IamDll;
extern "C" { void (__cdecl * _aexit_rtn)(int); }
#include "sxstest.h"

#include "sxstest_trace.cpp"

__inline
ULONGLONG
GetCycleCount(void)
{
#if defined(_X86_)
    __asm {
        RDTSC
    }
#else
    return 0;
#endif // defined(_X86_)
}

typedef BOOL (WINAPI * PSXSPGENERATEMANIFESTPATHONASSEMBLYIDENTITY)(
    PWSTR str,         // input string, must have name, version, langid and processorarchitecture
    PWSTR psz,         // output string, like x86_cards_strongname,.......
    SIZE_T * pCch,     // IN : length of psz, OUT : used
    PASSEMBLY_IDENTITY *ppAssemblyIdentity  // could be NULL
   );

#define SXSTEST_BEGIN_INSTALL          (0x4000000000000000i64)
#define SXSTEST_INSTALL                (0x2000000000000000i64)
#define SXSTEST_END_INSTALL            (0x1000000000000000i64)
#define SXSTEST_END_OF_FLAGS           (0x0200000000000000i64)
#define SXSTEST_THREADS                (0x0100000000000000i64)
#define SXSTEST_INSTALLED_DLL          (0x0080000000000000i64)
#define SXSTEST_BUILT_DLL              (0x0040000000000000i64)
#define SXSTEST_STATIC_DLL             (0x0020000000000000i64)

inline int PRINTABLE(int ch) { return isprint(ch) ? ch : '.'; }

VOID
PrintBlob(
    FILE *pf,
    PVOID Data,
    SIZE_T Length,
    PCWSTR PerLinePrefix
   );

BOOL GenerateHashOfFileLikeSxsDoes(PCWSTR pcwszFileName);
BOOL TestLeakMemory(DWORD Amount);
BOOL TestAssemblyProbing(int argc, wchar_t **argv, int *piNext);
BOOL TestDirectoryChangeWatcher(int argc, wchar_t **argv, int *piNext);
BOOL TestXMLParsing(int argc, wchar_t **argv, int *piNext);
BOOL TestMultiAct(int argc, wchar_t **argv);
BOOL TestManifestSchema(int argc, wchar_t **argv, int *piNext);
BOOL TestDirect(int argc, wchar_t **argv, int *piNext);
void TestWin32(wchar_t** argv);
BOOL TestAct(int argc, wchar_t **argv, int *piNext);
BOOL TestInstall(PCWSTR manifest, __int64 flags, DWORD beginInstallFlags, DWORD installFlags, DWORD endInstallFlags);
int  TestDiffDir(PCWSTR dir1, PCWSTR dir2);
BOOL TestSearchPath(int argc, wchar_t** argv, int* piNext);
BOOL TestMSIInstall(int argc, wchar_t** argv, int* piNext);
int  TestDirWalk(PCWSTR root, PWSTR filter);
BOOL TestLoadLibrary(int argc, wchar_t** argv, int* piNext);
int  TestAssemblyName(VOID);
int  TestPrecomiledManifest(PCWSTR szFileName);
int  TestPCMTime(PCWSTR manifestFilename);
int  TestCreateProcess(wchar_t** argv);
int  TestCreateProcess2(wchar_t** argv);
BOOL TestInstallPrivateAssembly(int argc, wchar_t** argv, int* piNext);
BOOL TestManifestProbing(int argc, wchar_t** argv, int* piNext);
int  TestCreateMultiLevelDirectory(PCWSTR dirs);
BOOL TestXMLDOM(PCWSTR xmlfilename);
BOOL TestFusionArray(PCWSTR, PCWSTR);
BOOL TestGeneratePathFromIdentityAttributeString(PCWSTR str);
BOOL TestRefreshAssembly(PCWSTR wsAssembly);
BOOL TestInstallWithInstallInfo(PCWSTR wsAssemblyManifest, PCWSTR wsReference);
BOOL TestOpeningStuff(PCWSTR wsSourceName, PCWSTR wsType, PCWSTR wsCount);
BOOL TestVerifyFileSignature(PCWSTR wsFilename);
BOOL TestInstallLikeWindowsSetup(PCWSTR szDirectory, PCWSTR szCodebase);
BOOL TestDumpContainedManifests(PCWSTR wsFilename);
BOOL TestGenerateStringWithIdenticalHash(WCHAR iString[33]);
BOOL TestAssemblyIdentityHash();
void TestInherit();
void TestNoInherit();
void TestEmpty();
BOOL TestMessagePerf(int argc, wchar_t **arg, int *piNext);
LRESULT CALLBACK TestMessagePerfWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void TestTrickyMultipleAssemblyCacheItems(PCWSTR);
void TestSfcScanKickoff();
void GenerateStrongNameAndPublicKey(PCWSTR wsCertificate);
VOID TestCreateActctxLeakHandles(DWORD num);
BOOL TestSystemDefaultActivationContextGeneration();
BOOL TestAsyncIO(int argc, wchar_t **argv, int *piNext);
void TestRefCount();
void TestGuidSort();
void TestStringSort();
BOOL TestNewCatalogSignerThingy(PCWSTR pcwszCatalog);
void TestExeDll();
int TestThreadInheritLeak();
BOOL TestSxsSfcUI();
void TestGetModuleHandleEx();
void TestGetFullPathName(PCWSTR);
void TestCreateFile(PCWSTR);
void TestGetPathBaseName(LPCWSTR Path);
PCSTR PrintPathToString(RTL_PATH_TYPE);
void TestPathType(PCWSTR*);
void TestVersion();
void TestGetProcessImageFileName();
void TestErrorInfra();
void TestQueryActCtx();
void TestQueryActCtx2();
void Test64k();
void TestDotLocalSingleInstancing();
void TestCreateActCtx(int nCreations, wchar_t **rgCreations);
void TestCreateActctxLikeCreateProcess();
void TestCreateActctxAdminOverride();
void TestQueryManifestInformationBasic(PCWSTR pszManifest);
void TestCreateActctxWindowsShellManifest();
void TestCreateGlobalEvent();
void TestHandleLeaks(void);
void TestCRuntimeAsms(void);
BOOL TestMfcCreateAndMarshal(void);
void TestAtlCreate(void);
void TestAlignment(void);
BOOL TestPrivateSha1Impl(PCWSTR pcwszDirName);
BOOL TestNewSxsInstallAPI(PCWSTR pcwszManifest);
void TestImage(void);
void TestInterlockedAlignment(void);
void TestCreateActCtx_PE_flags0(void);
void TestUninstall(PCWSTR ManifestPath, PCWSTR ReferenceString);
void TestParsePatchInfo(PCWSTR PatchInfoFile);
PCWSTR GetLastErrorMessage();
void DumpXmlErrors();
BOOL TestCoCreate(wchar_t ** argv);
void TestDFS();
BOOL TestFindActCtx_AssemblyInfo(PCWSTR *);
void FusionpTestOleAut1(DWORD dwCoInit = COINIT_MULTITHREADED);
void FusionpTestOleAut2();
void FusionpTestOle32Cache(); // bug 482347 Server RC1 DllGetClassObject of initially activated activation context is called instead of DGCO of current act ctx
void FusionpTestProgidCache();
BOOL FusionpTestUniqueValues();
void TestExpandCabinet(PCWSTR CabinetPath, PCWSTR TargetPath);
BOOL GenerateFileHash(PCWSTR pcwsz);
BOOL TestComctl5Comctl6();
void TestSystemDefaultDllRedirection();
DWORD LastError;
BOOL CreateActCtxLocally(PCWSTR pcwszManifestFile, PCWSTR pcwszConfigFile);

BOOL LoadSxs();
int Usage(const char* argv0);

PFNCreateAssemblyCache          g_pfnCreateAssemblyCache;
PFNCreateAssemblyCacheItem      g_pfnCreateAssemblyCacheItem;
SXSP_DEBUG_FUNCTION             g_pfnSxspDebug;
PSXS_BEGIN_ASSEMBLY_INSTALL     g_pfnSxsBeginAssemblyInstall;
PSXS_INSTALL_W                  g_pfnSxsInstallW;
PSXS_END_ASSEMBLY_INSTALL       g_pfnSxsEndAssemblyInstall;
PSXSPGENERATEMANIFESTPATHONASSEMBLYIDENTITY g_pfnGenerateManifestPathOnAssemblyIdentity;
BOOL (WINAPI *g_pfnSxsGenerateActivationContext)(PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters);
PSXS_UNINSTALL_W_ROUTINE            g_pfnSxsUninstallW;
PSXS_QUERY_MANIFEST_INFORMATION     g_pfnQueryManifestInformation;
PSXS_PROBE_ASSEMBLY_INSTALLATION    g_pfnSxsProbeAssemblyInstallation;
PSXS_QUERY_MANIFEST_INFORMATION     g_pfnSxsQueryManifestInformation;
PFN_SXS_FIND_CLR_CLASS_INFO         g_pfnClrClass;
PFN_SXS_FIND_CLR_SURROGATE_INFO     g_pfnClrSurrogate;
PFN_SXS_LOOKUP_CLR_GUID             g_pfnClrLookup;

BOOL ParseProcessorArchitecture(int argc, wchar_t** argv, int* piCurrent);
BOOL ParseLangId(int argc, wchar_t** argv, int* piCurrent);

PCWSTR FusionpThreadUnsafeGetLastWin32ErrorMessageW()
{
    CSxsPreserveLastError ple;
    static WCHAR LastErrorMessage[4096];

    LastErrorMessage[0] = 0;

    ::FormatMessageW(
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        ::FusionpGetLastWin32Error(),
        0,
        LastErrorMessage,
        RTL_NUMBER_OF(LastErrorMessage),
        NULL);
    if (LastErrorMessage[0] != 0)
    {
        PWSTR p = LastErrorMessage + ::StringLength(LastErrorMessage) - 1;
        while (p != LastErrorMessage && (*p == '\n' || *p == '\r' || *p == ' ' || *p == '\t'))
        {
            *p-- = 0;
        }
    }
    ple.Restore();
    return LastErrorMessage;
}


void __stdcall ThrowLastError(DWORD error)
{
    RaiseException(error, 0, 0, NULL);
    //throw HRESULT_FROM_WIN32(error);
}

void __stdcall ThrowWin32(ULONG_PTR error = ::GetLastError())
{
    ThrowLastError(static_cast<DWORD>(error));
}

void __stdcall CheckHresult(HRESULT hr)
{
    if (FAILED(hr))
        throw hr;
}

void SetDllBitInPeImage(PCWSTR Path)
/*++
.exes and .dlls are the same format except one bit in the headers distinguishes them.
--*/
{
    CFusionFile File;
    CFileMapping FileMapping;
    CMappedViewOfFile MappedViewOfFile;

    if (!File.Win32CreateFile(Path, GENERIC_READ | GENERIC_WRITE, 0, OPEN_EXISTING))
        ThrowLastError();
    if (!FileMapping.Win32CreateFileMapping(File, PAGE_READWRITE))
        ThrowLastError();
    if (!MappedViewOfFile.Win32MapViewOfFile(FileMapping, FILE_MAP_WRITE))
        ThrowLastError();

    PIMAGE_NT_HEADERS NtHeaders = ImageNtHeader(static_cast<PVOID>(MappedViewOfFile));
    if (NtHeaders == NULL)
        ThrowLastError(ERROR_BAD_EXE_FORMAT);

    // This is correct for PE32 or PE32+.
    NtHeaders->FileHeader.Characteristics |= IMAGE_FILE_DLL;

    if (!MappedViewOfFile.Win32Close())
        ThrowLastError();
    if (!FileMapping.Win32Close())
        ThrowLastError();
    if (!File.Win32Close())
        ThrowLastError();
}

PCSTR PrintPathToString(RTL_PATH_TYPE PathType)
{
    switch (PathType)
    {
#define X(x) case x: return #x;
        X(RtlPathTypeUnknown)
        X(RtlPathTypeUncAbsolute)
        X(RtlPathTypeDriveAbsolute)
        X(RtlPathTypeDriveRelative)
        X(RtlPathTypeRooted)
        X(RtlPathTypeRelative)
        X(RtlPathTypeLocalDevice)
        X(RtlPathTypeRootLocalDevice)
#undef X
    default:
        return "unknown";
    }
}

void TestPathType(const PCWSTR* argv)
{
    if (*argv != NULL)
    {
        while (*argv != NULL)
        {
            RTL_PATH_TYPE PathType = SxspDetermineDosPathNameType(*argv);
            printf("%ls -> %s\n", *argv, PrintPathToString(PathType));
            argv += 1;
        }
    }
    else
    {
        const static PCWSTR args[] =
        {
            L"a",
            L"\\a",
            L"\\\\a",
            L"\\\\\\a",
            L"a:",
            L"a:\\",
            L"\\?",
            L"\\.",
            L"\\\\?",
            L"\\\\.",
            L"\\\\?\\",
            L"\\\\.\\",
            L"\\\\?\\a",
            L"\\\\.\\a",
            L"\\\\?\\a:",
            L"\\\\.\\a:",
            L"\\\\?\\a:\\",
            L"\\\\.\\a:\\",
            L"\\\\?\\unc",
            L"\\\\.\\unc",
            L"\\\\?\\unc\\",
            L"\\\\.\\unc\\",
            NULL
        };
        TestPathType(args);
    }
}

CSxsTestGlobals g;

const static struct
{
    DWORD  (WINAPI * GetModuleFileNameW)(HMODULE, LPWSTR, DWORD);
    SIZE_T (WINAPI * VirtualQuery)(LPCVOID, PMEMORY_BASIC_INFORMATION, SIZE_T);
    BOOL   (WINAPI * ReadFile)(HANDLE, LPVOID, DWORD, LPDWORD, LPOVERLAPPED);
    BOOL   (WINAPI * WriteFile)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED);
    UINT   (WINAPI * GetTempFileNameW)(LPCWSTR, LPCWSTR, UINT, LPWSTR);
    BOOL   (WINAPI * DeleteFileW)(LPCWSTR);
}
Kernel32 =
{
    GetModuleFileNameW,
    VirtualQuery,
    ReadFile,
    WriteFile,
    GetTempFileNameW,
    DeleteFileW
};

const static struct
{
    HRESULT (WINAPI * IIDFromString)(LPOLESTR, LPIID);
    HRESULT (WINAPI * CLSIDFromString)(LPOLESTR, LPIID);
    HRESULT (WINAPI * CoCreateInstance)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID*);
    HRESULT (WINAPI * CoInitialize)(LPVOID);
    void    (WINAPI * CoUninitialize)();
    HRESULT (WINAPI * CoInitializeEx)(void * Reserved, DWORD dwCoInit);
}
Ole32 =
{
    IIDFromString,
    CLSIDFromString,
    CoCreateInstance,
    CoInitialize,
    CoUninitialize,
    CoInitializeEx,
};

void
ManifestStringToTempFile(
    PCWSTR ManifestString,
    CBaseStringBuffer &rTempFilePath
    )
{
    CFusionFile File;
    WCHAR xTempFilePath[MAX_PATH];
    WCHAR TempDirectory[MAX_PATH];
    const static WCHAR NativeUnicodeByteOrderMark = 0xfeff;
    DWORD BytesWritten = 0;

    //if (!::GetTempPathW(NUMBER_OF(TempDirectory), TempDirectory))
    //   ThrowLastError();

    Kernel32.GetModuleFileNameW(NULL, TempDirectory, NUMBER_OF(TempDirectory));
    *wcsrchr(TempDirectory, '\\') = 0;
    ::Trace("TempDirectory:%ls\n", TempDirectory);

    if (!Kernel32.GetTempFileNameW(TempDirectory, L"", 0, xTempFilePath))
        ::ThrowLastError();
    rTempFilePath.Win32Assign(xTempFilePath, wcslen(xTempFilePath));

    ::Trace("xTempFilePath:%ls\n", xTempFilePath);
    ::Trace("TempFilePath:%ls\n", static_cast<PCWSTR>(xTempFilePath));

    if (!File.Win32CreateFile(rTempFilePath, GENERIC_WRITE, 0, CREATE_ALWAYS))
        ::ThrowLastError();

    if (!Kernel32.WriteFile(File, &NativeUnicodeByteOrderMark, sizeof(NativeUnicodeByteOrderMark), &BytesWritten, NULL))
        ::ThrowLastError();

    if (!Kernel32.WriteFile(File, ManifestString, static_cast<DWORD>(sizeof(*ManifestString) * StringLength(ManifestString)), &BytesWritten, NULL))
        ::ThrowLastError();
}

HANDLE
CreateActivationContextFromStringW(
    PCWSTR ManifestString
    )
{
    CStringBuffer TempFilePath;

    ::ManifestStringToTempFile(ManifestString, TempFilePath);

    ACTCTXW ActivationContextCreate = { sizeof(ActivationContextCreate) };
    ActivationContextCreate.lpSource = TempFilePath;
    HANDLE ActivationContextHandle = ::CreateActCtxW(&ActivationContextCreate);
    DWORD Error = ::GetLastError();
    Kernel32.DeleteFileW(TempFilePath);
    if (ActivationContextHandle == INVALID_HANDLE_VALUE)
        ::ThrowLastError(Error);
    return ActivationContextHandle;
}

int Usage(const wchar_t* argv0)
{
#if 0
    std::wstring strargv0 = argv0;
    fprintf(stderr,
        "%ls",
        (
        L"Usage: \n"
        L"   " + strargv0 + L" [install-flags] manifest-or-image-with-manifest-resource-path\n"
        L"   " + strargv0 + L" [-pa processor-architecture] [-langid langid] -d manifest-path ...\n"
        L"   " + strargv0 + L" [-pa processor-architecture] [-langid langid] -p manifest-path ...\n"
        L"   " + strargv0 + L" [-pa processor-architecture] [-langid langid] -w32 manifest-path ...\n"
        L"   " + strargv0 + L" [-pa processor-architecture] [-langid langid] -msi msi-script...\n"
        L"   " + strargv0 + L" -tcreateprocess ...\n"
        L"   " + strargv0 + L" -tsearchpath ...\n"
        L"   " + strargv0 + L" -tcreateprocess ...\n"
        L"   " + strargv0 + L" -tempty test pushing a special empty context ...\n"
        L"   " + strargv0 + L" -tinherit test the usual default inheritance ...\n"
        L"   " + strargv0 + L" -tnoinherit test the noinherit bit ...\n"
        L"   " + strargv0 + L" [-threads n] create n threads for some tests ...\n"
        L"   " + strargv0 + L" probably other choices, use the source\n"
        L"\n"
        L"install-flags:\n"
        L"   -i\n"
        L"   -install\n"
        L"   -install-from-resource\n"
        L"   -install-move\n"
        ).c_str()
        );
#endif
    return EXIT_FAILURE;
}

const wchar_t* GetLastOperation()
{
    return g.lastOperation;
}

void SetLastOperation(const wchar_t* format, ...)
{
    va_list args;

    g.lastOperation[0] = 0;
    g.lastOperation[NUMBER_OF(g.lastOperation) - 1] = 0;

    va_start(args, format);
    _vsnwprintf(g.lastOperation, NUMBER_OF(g.lastOperation) - 1, format, args);
    va_end(args);
}

HANDLE DuplicateHandle(HANDLE handle)
{
    HANDLE newHandle = NULL;
    if (!DuplicateHandle(GetCurrentProcess(), handle, GetCurrentProcess(), &newHandle, 0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        ThrowLastError();
    }
    return newHandle;
}

__int64 IsFlag(PCWSTR arg)
{
const static struct
{
    WCHAR   name[32];
    __int64 value;
} flags[] =
{
    { L"i",                              SXSTEST_BEGIN_INSTALL},
    { L"install",                        SXSTEST_BEGIN_INSTALL},

    { L"install-from-resource",          SXS_INSTALL_FLAG_FROM_RESOURCE            | SXSTEST_INSTALL},
    { L"install-move",                   SXS_INSTALL_FLAG_MOVE                     | SXSTEST_INSTALL },
    { L"install-dir",                    SXS_INSTALL_FLAG_FROM_DIRECTORY           | SXSTEST_INSTALL},
    { L"install-dir-recursive",          SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE | SXSTEST_INSTALL},
    { L"install-no-verify",              SXS_INSTALL_FLAG_NO_VERIFY                | SXSTEST_INSTALL},
    { L"install-no-transact",            SXS_INSTALL_FLAG_NOT_TRANSACTIONAL        | SXSTEST_INSTALL},
    { L"install-replace-existing",       SXS_INSTALL_FLAG_REPLACE_EXISTING         | SXSTEST_INSTALL},

    { L"begin-install-replace-existing", SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING   | SXSTEST_BEGIN_INSTALL},
    { L"begin-install-from-resource",    SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_RESOURCE      | SXSTEST_BEGIN_INSTALL},
    { L"begin-install-move",             SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_MOVE               | SXSTEST_BEGIN_INSTALL },
    { L"begin-install-dir",              SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY     | SXSTEST_BEGIN_INSTALL},
    { L"begin-install-dir-recursive",    SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE | SXSTEST_BEGIN_INSTALL},
    { L"begin-install-no-verify",        SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY          | SXSTEST_BEGIN_INSTALL},
    { L"begin-install-no-transact",      SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL  | SXSTEST_BEGIN_INSTALL},

    { L"end-install-no-verify",          SXS_END_ASSEMBLY_INSTALL_FLAG_NO_VERIFY            | SXSTEST_END_INSTALL},

    { L"threads",                        SXSTEST_THREADS },

    { L"-installed-dll",                SXSTEST_INSTALLED_DLL },
    { L"-built-dll",                    SXSTEST_BUILT_DLL },
    { L"-static",                       SXSTEST_STATIC_DLL },
    { L"-static-dll",                   SXSTEST_STATIC_DLL },


    { L"-",                              SXSTEST_END_OF_FLAGS }
};
    if (*arg == '-')
    {
        arg += 1;
        for (SIZE_T i = 0 ; i != NUMBER_OF(flags) ; ++i)
        {
            if (_wcsicmp(flags[i].name, arg) == 0)
                return flags[i].value;
        }
    }
    return 0;
}

DWORD __stdcall ThreadMain(PVOID)
{
//
// We run stuff in other threads via QueueUserAPC.
//
    __try
    {
        WaitForSingleObjectEx(g.ThreadExitEvent, INFINITE, TRUE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG
        if (IsDebuggerPresent())
        {
            FUSION_DEBUG_BREAK();
        }
#endif
        QueueUserAPC(ThrowWin32, g.MainThread, GetExceptionCode());
    }
    return 0;
}

void CreateThreads()
{
    INT i;
    g.MainThread = DuplicateHandle(GetCurrentThread());
    g.ThreadExitEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
    if (g.ThreadExitEvent == NULL)
    {
        ThrowLastError();
    }
    for (i = 0 ; i < g.NumberOfThreads ; i++)
    {
        g.Threads[i] = CreateThread(NULL, 0, ThreadMain, NULL, 0, NULL);
        if (g.Threads[i] == NULL)
        {
            int error = ::GetLastError();
            if (i > 2)
            {
                fprintf(stderr, "Only able to created %d threads, error=%d, continuing\n", i, error);
                g.NumberOfThreads = i;
                break;
            }
            fprintf(stderr, "Unable to create threads, error=%d, terminating\n", error);
            ThrowWin32(error);
        }
    }
}

void
GetFlags(
    wchar_t**& argv,
    __int64& flags,
    DWORD& beginInstallFlags,
    DWORD& installFlags,
    DWORD& endInstallFlags
    )
{
    __int64 flag;
    while (flag = IsFlag(argv[1]))
    {
        ++argv;
        if (flag & SXSTEST_END_OF_FLAGS)
        {
            break;
        }
        else if (flag & SXSTEST_BEGIN_INSTALL)
        {
            beginInstallFlags |= flag;
        }
        else if (flag & SXSTEST_INSTALL)
        {
            installFlags |= flag;
        }
        else if (flag & SXSTEST_END_INSTALL)
        {
            endInstallFlags |= flag;
        }
        else if (flag & SXSTEST_THREADS)
        {
            g.NumberOfThreads = _wtoi(*++argv);
            if (g.NumberOfThreads > NUMBER_OF(g.Threads))
            {
                g.NumberOfThreads = NUMBER_OF(g.Threads);
            }
        }
        else if (flag & SXSTEST_INSTALLED_DLL)
        {
            LoadInstalledSxsDll();
        }
        else if (flag & SXSTEST_BUILT_DLL)
        {
            LoadBuiltSxsDll();
        }
        else if (flag & SXSTEST_STATIC_DLL)
        {
            UseStaticSxsDll();
        }

        // always set flags because normal installation is 0 now
        flags |= flag;
   }
}

VOID
FusionpSetSystemSetupInProgress(bool f)
{
    CFusionRegKey Regkey;
    CFusionRegKey RegkeyLocalMachine(HKEY_LOCAL_MACHINE);

    if (!RegkeyLocalMachine.OpenSubKey(Regkey, L"System\\Setup", KEY_ALL_ACCESS))
        return;
    Regkey.SetValue(L"SystemSetupInProgress", f ? 1 : 0);
}

int Main(int argc, wchar_t** argv)
{
    int i = 0;
    __int64 flags = 0;
    //__int64 flag  = 0;
    DWORD beginInstallFlags = 0;
    DWORD installFlags = 0;
    DWORD endInstallFlags = 0;
    wchar_t* argv0 = argv[0];

    g.wProcessorArchitecture = SxspGetSystemProcessorArchitecture();
    g.wLangId = ::GetUserDefaultLangID();
    if (argc > 1)
    {
        FusionpSetSystemSetupInProgress(false);
        __try
        {
        __try
        {
            if (!SxsDllMain(GetModuleHandle(NULL), DLL_PROCESS_ATTACH, NULL))
                ThrowLastError();
            GetFlags(argv, flags, beginInstallFlags, installFlags, endInstallFlags);

            i = 1;

            // consume global flags...
            for (;;)
            {
                if (::FusionpEqualStringsI(argv[i], L"-pa"))
                {
                    if (!ParseProcessorArchitecture(argc, argv, &i))
                        goto Exit;
                }
                else if (::FusionpEqualStringsI(argv[i], L"-langid"))
                {
                    if (!ParseLangId(argc, argv, &i))
                        goto Exit;
                }
                else
                    break;
            }

            if (false) { }
            else if (::FusionpEqualStringsI(argv[i], L"-id"))
            {
                DWORD index = 0;
                if (argv[3]){ // have an index present
                    index = argv[3][0] - L'0';
                }
                i = TestGeneratePathFromIdentityAttributeString(argv[2]);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tPathType"))
            {
                TestPathType(argv + i + 1);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-dfs"))
            {
                TestDFS();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-systemdefault"))
            {
                i = TestSystemDefaultActivationContextGeneration();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-dom"))
            {
                i = TestXMLDOM(argv[2]);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-hash"))
            {
                i = TestGenerateStringWithIdenticalHash(argv[2]);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tasyncio"))
            {
                i++;
                i = TestAsyncIO(argc, argv, &i);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-assemblyidentityhash"))
            {
                i = TestAssemblyIdentityHash();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-array"))
            {
                i = TestFusionArray(argv[2], argv[3]);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-diffdir"))
            {
                i = TestDiffDir(argv[i + 1], argv[i + 2]);
            }
            else if (::FusionpEqualStringsI(argv[1], L"-pcm"))
            {
                i = TestPrecomiledManifest(argv[2]);
            }
            else if (::FusionpEqualStringsI(argv[1], L"-dll"))
            {
                TestSystemDefaultDllRedirection();
            }
            else if (::FusionpEqualStringsI(argv[1], L"-testpcm"))
            {
                i = TestPCMTime(argv[2]);
            }
            else if (::FusionpEqualStringsI(argv[1], L"-cd"))
            {
                i = TestCreateMultiLevelDirectory(argv[2]);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-manifests"))
            {
                TestDumpContainedManifests(argv[++i]);
            }
            else if (::FusionpEqualStringsI(argv[1], L"-dirwalk"))
            {
                i = TestDirWalk(argv[i + 1], argv[i + 2]);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-cabextract"))
            {
                TestExpandCabinet(
                    argv[i+1],
                    argv[i+2]);
                i += 2;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-patchfile"))
            {
                TestParsePatchInfo(argv[++i]);
            }
            else if (::FusionpEqualStringsI(argv[1], L"-tmultiact"))
            {
                i = TestMultiAct(argc, argv);
            }
            else if (flags)
            {
                i = TestInstall(argv[i], flags, beginInstallFlags, installFlags, endInstallFlags);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-sfcui"))
            {
                if ( !TestSxsSfcUI() )
                    goto Exit;
                i++;
            }
            else if (FusionpEqualStringsI( argv[i], L"-installwithinfo"))
            {
                TestInstallWithInstallInfo(
                    ( i + 1 < argc ) ? argv[i + 1] : NULL,
                    ( i + 2 < argc ) ? argv[i+2] : NULL);
                i += 2;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-multicache"))
            {
                TestTrickyMultipleAssemblyCacheItems(argv[i + 1]);
                i++;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-d"))
            {
                if (!TestDirect(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tcomctl"))
            {
                if (!TestComctl5Comctl6())
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-probe"))
            {
                i++;
                argv[i] = L"foo,type=\"win32\",processorArchitecture=\"x86\",version=\"6.0.0.0\",publicKeyToken=\"6595b64144ccf1df\"";
                if (!TestAssemblyProbing(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-dirchanges"))
            {
                if (!TestDirectoryChangeWatcher(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-newinstall"))
            {
                if (!TestNewSxsInstallAPI(argv[++i]))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tuninstall")
                  || ::FusionpEqualStringsI(argv[i], L"-uninstall"))
            {
                TestUninstall(argv[i + 1], argv[i + 2]);
                goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-hashimage"))
            {
                if (!GenerateHashOfFileLikeSxsDoes(argv[++i]))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-localcreateactctx"))
            {
                if (!CreateActCtxLocally(argv[i + 1], argv[i+2]))
                    goto Exit;
                i += 2;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-probemanifest"))
            {
                if (!TestManifestProbing(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-p"))
            {
                if (!TestXMLParsing(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-w32"))
            {
                TestWin32(argv + i + 1);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-msi"))
            {
                if (!TestMSIInstall(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-mp"))
            {
                if (!TestManifestSchema(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-act"))
            {
                if (!TestAct(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-hashfile"))
            {
                if (!GenerateFileHash(argv[++i]))
                    goto Exit;

            }
            else if (::FusionpEqualStringsI(argv[i], L"-shatest"))
            {
                if (!TestPrivateSha1Impl(argv[++i]))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[1], L"-am"))
            {
                i = TestAssemblyName();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tsearchpath"))
            {
                if (!TestSearchPath(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-testmapping"))
            {
                if (!TestOpeningStuff(argv[i+1], argv[i+2], argv[i+3]))
                    goto Exit;
                i += 3;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-validatefile"))
            {
                if (!TestVerifyFileSignature(argv[++i]))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tloadlibrary"))
            {
                if (!TestLoadLibrary(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-refresh"))
            {
                if (!TestRefreshAssembly(argv[i+1]))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-unique"))
            {
                if (!FusionpTestUniqueValues())
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-leak"))
            {
                //
                // We dump a little bit of memory
                //
                UINT iAmount = 0;
                iAmount = _wtoi(argv[++i]);
                if (!TestLeakMemory(iAmount))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tcreateprocess"))
            {
                if (!TestCreateProcess(argv + i + 1))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tcreateprocess2"))
            {
                if (!TestCreateProcess2(argv + i + 1))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tinherit"))
            {
                TestInherit();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tnoinherit"))
            {
                TestNoInherit();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tempty"))
            {
                TestEmpty();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-ttsappcmp"))
            {
                TestCreateGlobalEvent();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tmsgperf"))
            {
                i++;
                if (!TestMessagePerf(argc, argv, &i))
                    goto Exit;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-twinsetup"))
            {
                FusionpSetSystemSetupInProgress(true);
                if (!TestInstallLikeWindowsSetup(argv[i + 1], (argv[i + 2] != NULL) ? argv[i + 2] : argv[i + 1]))
                    goto Exit;
                i += 3;
            }
            else if (::FusionpEqualStringsI(argv[i], L"-sfcscan"))
            {
                TestSfcScanKickoff();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-certinfo"))
            {
                GenerateStrongNameAndPublicKey(argv[++i]);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-thandle"))
            {
                DWORD iAmount = 0;
                iAmount = _wtoi(argv[++i]);

                TestCreateActctxLeakHandles(iAmount);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-catsigner"))
            {
                TestNewCatalogSignerThingy(argv[++i]);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-trefcount"))
            {
                TestRefCount();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-ttileak"))
            {
                TestThreadInheritLeak();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tguidsort"))
            {
                TestGuidSort();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tstringsort"))
            {
                TestStringSort();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-tExeDll"))
            {
                TestExeDll();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tExitProcess"))
            {
                LoadSxs();
                g_pfnSxspDebug(SXS_DEBUG_EXIT_PROCESS, 0, 0, NULL);
            }
            else if (FusionpEqualStringsI(argv[i], L"-tTerminateProcess"))
            {
                LoadSxs();
                g_pfnSxspDebug(SXS_DEBUG_TERMINATE_PROCESS, 0, 0, NULL);
            }
            else if (FusionpEqualStringsI(argv[i], L"-tLastError"))
            {
                ::SetLastError(123);
                printf("%lu\n", FusionpGetLastWin32Error());
                printf("%lu\n", ::GetLastError());
                ::FusionpSetLastWin32Error(456);
                printf("%lu\n", FusionpGetLastWin32Error());
                printf("%lu\n", ::GetLastError());
            }
            else if (FusionpEqualStringsI(argv[i], L"-tGetModuleHandleEx"))
            {
                TestGetModuleHandleEx();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tGetFullPathName"))
            {
                TestGetFullPathName(argv[i + 1]);
            }
            else if (FusionpEqualStringsI(argv[i], L"-tCreateFile"))
            {
                TestCreateFile(argv[i + 1]);
            }
            else if (FusionpEqualStringsI(argv[i], L"-tGetPathBaseName"))
            {
                TestGetPathBaseName(argv[i + 1]);
            }
            else if (FusionpEqualStringsI(argv[i], L"-tVersion"))
            {
                TestVersion();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tGetProcessImageFileName"))
            {
                TestGetProcessImageFileName();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tErrorInfra"))
            {
                TestErrorInfra();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tQueryActCtx"))
                TestQueryActCtx();
            else if (FusionpEqualStringsI(argv[i], L"-tQueryActCtx2"))
                TestQueryActCtx2();
            else if (FusionpEqualStringsI(argv[i], L"-tqmib"))
            {
                TestQueryManifestInformationBasic(argv[i+1]);
            }
            else if (FusionpEqualStringsI(argv[i], L"-t64k"))
            {
                Test64k();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tcreateactctx"))
            {
                TestCreateActCtx(argc - (i + 1), &argv[i+1]);
            }
            else if (FusionpEqualStringsI(argv[i], L"-TestCreateActCtx_PE_flags0"))
            {
                TestCreateActCtx_PE_flags0();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tDotLocalSingleInstancing"))
            {
                TestDotLocalSingleInstancing();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tCreateActctxLikeCreateProcess"))
            {
                TestCreateActctxLikeCreateProcess();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tCreateActctxLikeCreateProcess"))
            {
                TestCreateActctxLikeCreateProcess();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tCreateActctxAdminOverride"))
            {
                TestCreateActctxAdminOverride();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tCreateActctxWindowsShellManifest"))
            {
                TestCreateActctxWindowsShellManifest();
            }
            else if (FusionpStrCmpI(argv[i], L"-tHandleLeak") == 0)
            {
                //for (SIZE_T i = 0 ; i != 5 ; i += 1)
                    TestHandleLeaks();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tMfcCreateAndMarshal"))
            {
                TestMfcCreateAndMarshal();
            }
            else if (FusionpEqualStringsI(argv[i], L"-tAtlCreate"))
            {
                TestAtlCreate();
            }
            else if (FusionpEqualStringsI(argv[i], L"-TestAlignment"))
            {
                TestAlignment();
            }
            else if (FusionpEqualStringsI(argv[i], L"-DoNothingJustSeeIfItRuns"))
            {
                printf("%wZ ran successfully\n", &NtCurrentPeb()->ProcessParameters->ImagePathName);
            }
            else if (FusionpEqualStringsI(argv[i], L"-TestImage"))
            {
                TestImage();
            }
            else if (FusionpEqualStringsI(argv[i], L"-TestInterlockedAlignment"))
            {
                TestInterlockedAlignment();
            }
            else if (FusionpEqualStringsI(argv[i], L"-DumpXmlErrors"))
            {
                DumpXmlErrors();
            }
            else if (FusionpEqualStringsI(argv[i], L"-TestCoCreate"))
            {
                TestCoCreate(argv + i + 1);
            }
            else if (FusionpEqualStringsI(argv[i], L"-TestFindActCtx_AssemblyInfo"))
            {
                TestFindActCtx_AssemblyInfo(const_cast<PCWSTR*>(argv + i + 1));
            }
            else if (FusionpEqualStringsI(argv[i], L"-TestOleAut1"))
            {
                FusionpTestOleAut1();
            }
            else if (FusionpEqualStringsI(argv[i], L"-TestOleAut2"))
            {
                FusionpTestOleAut2();
            }
            else if (FusionpEqualStringsI(argv[i], L"-TestOle32Cache"))
            {
                FusionpTestOle32Cache();
            }
            else if (FusionpEqualStringsI(argv[i], L"-TestProgidCache"))
            {
                FusionpTestProgidCache();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-DeleteShortNamesInRegistry"))
            {
                SxspDeleteShortNamesInRegistry();
            }
            else if (::FusionpEqualStringsI(argv[i], L"-DllInstall"))
            {
                DllInstall(TRUE, NULL);
            }
            else if (::FusionpEqualStringsI(argv[i], L"-snprintf"))
            {
                char buffer[2];

                buffer[0] = 0;
                buffer[1] = 0;
                ::printf("%d\n", ::_snprintf(buffer, 2, "%s", "1"));
                ::printf("%d %d\n", buffer[0], buffer[1]);

                buffer[0] = 0;
                buffer[1] = 0;
                ::printf("%d\n", ::_snprintf(buffer, 2, "%s", "12"));
                ::printf("%d %d\n", buffer[0], buffer[1]);

                buffer[0] = 0;
                buffer[1] = 0;
                ::printf("%d\n", ::_snprintf(buffer, 2, "%s", "123"));
                ::printf("%d %d\n", buffer[0], buffer[1]);
            }
            else
            {
                i = Usage(argv0);
            }
            if (g.ThreadExitEvent)
            {
                SetEvent(g.ThreadExitEvent);
                WaitForMultipleObjectsEx(g.NumberOfThreads, g.Threads, TRUE, INFINITE, TRUE);
            }
            if (g.sxsDll != NULL)
            {
                FreeLibrary(g.sxsDll);
            }
        }
        __finally
        {
            FusionpSetSystemSetupInProgress(false);
        }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
#if DBG
            if (IsDebuggerPresent())
            {
                FUSION_DEBUG_BREAK();
            }
#endif
            i = GetExceptionCode();
            WCHAR message[128];
            DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM;
            FormatMessageW(flags, NULL, i, 0, message, NUMBER_OF(message), NULL);
            PWSTR end = message + wcslen(message);
            while (end != message && isspace(*(end - 1)))
            {
                --end;
            }
            *end = 0;
            ::Trace("%ls failed, %d, %#x, %ls", g.lastOperation, i, i, message);
        }
        PTEB teb;
        teb = NtCurrentTeb();
        if (teb->CountOfOwnedCriticalSections != 0)
        {
            DbgPrint("teb->CountOfOwnedCriticalSections %d\n", teb->CountOfOwnedCriticalSections);
            //ASSERT(teb->CountOfOwnedCriticalSections == 0);
        }

        return i ? EXIT_SUCCESS : EXIT_FAILURE;
    }
    return Usage(argv[0]);

Exit:
    return ::GetLastError();
}

int TestDiffDir(PCWSTR dir1, PCWSTR dir2)
{
    CFusionDirectoryDifference diff;
    CStringBuffer buf1;
    CStringBuffer buf2;
    BOOL fSuccess = FALSE;

    if (!buf1.Win32Assign(dir1, ::wcslen(dir1)))
        goto Exit;
    if (!buf2.Win32Assign(dir2, ::wcslen(dir2)))
        goto Exit;

    if (!::FusionpCompareDirectoriesSizewiseRecursively(&diff, buf1, buf2))
        goto Exit;

    diff.DbgPrint(buf1, buf2);

    fSuccess = TRUE;
Exit:
    return fSuccess ? EXIT_SUCCESS : EXIT_FAILURE;
}

PCWSTR GetUser()
{
    static bool fInited;
    static WCHAR userName[MAX_PATH];
    if (!fInited)
    {
        DWORD size = NUMBER_OF(userName);
        userName[0] = 0;
        userName[1] = 0;
        GetUserNameW(userName, &size);
        if (userName[1] == '-')
        {
            wmemcpy(userName, 2+userName, 1+wcslen(2+userName));
        }
        fInited = true;
    }
    return userName;
}

void UserBreakPoint(PCWSTR user)
{
    if (::IsDebuggerPresent() && _wcsicmp(GetUser(), user) == 0)
    {
        ASSERT2_NTC(FALSE, __FUNCTION__);
    }
}

__declspec(selectany) extern const UNICODE_STRING x86String = RTL_CONSTANT_STRING(L"x86");
__declspec(selectany) extern const UNICODE_STRING i386String = RTL_CONSTANT_STRING(L"i386");
__declspec(selectany) extern const UNICODE_STRING BackslashString = RTL_CONSTANT_STRING(L"\\");
__declspec(selectany) extern const UNICODE_STRING asms01_dot_cabString = RTL_CONSTANT_STRING(L"asms01.cab");
__declspec(selectany) extern const UNICODE_STRING ProcessorBuildObjString = RTL_CONSTANT_STRING(SXSP_PROCESSOR_BUILD_OBJ_DIRECTORY_W);
__declspec(selectany) extern const UNICODE_STRING ProcessorInstallDirectoryString = RTL_CONSTANT_STRING(SXSP_PROCESSOR_INSTALL_DIRECTORY_W);

BOOL
SxspConvertI386ToX86(
    CBaseStringBuffer & buffProcessor
    )
{
    FN_PROLOG_WIN32;
    if (::FusionpEqualStringsI(buffProcessor, i386String.Buffer, RTL_STRING_GET_LENGTH_CHARS(&i386String)))
    {
        IFW32FALSE_EXIT(buffProcessor.Win32Assign(&x86String));
    }
    FN_EPILOG;
}

inline
BOOL
SxspConvertX86ToI386(
    CBaseStringBuffer & buffProcessor
    )
{
    FN_PROLOG_WIN32;
    if (::FusionpEqualStringsI(buffProcessor, x86String.Buffer, RTL_STRING_GET_LENGTH_CHARS(&x86String)))
    {
        IFW32FALSE_EXIT(buffProcessor.Win32Assign(&i386String));
    }
    FN_EPILOG;
}

typedef struct _SXSP_PROCEDURE_NAME_AND_ADDRESS {
    union
    {
        PCSTR Name;
        ULONG_PTR Ordinal;
    };
    PVOID *Address;
} SXSP_PROCEDURE_NAME_AND_ADDRESS, *PSXSP_PROCEDURE_NAME_AND_ADDRESS;

const static SXSP_PROCEDURE_NAME_AND_ADDRESS SxsProcs[] =
{
    { "CreateAssemblyCache",            (PVOID*)&g_pfnCreateAssemblyCache },
    //{ "CreateAssemblyCacheItem",        (PVOID*)&g_pfnCreateAssemblyCacheItem },
    { "SxsBeginAssemblyInstall",        (PVOID*)&g_pfnSxsBeginAssemblyInstall },
    { "SxsEndAssemblyInstall",          (PVOID*)&g_pfnSxsEndAssemblyInstall },
    { "SxspGenerateManifestPathOnAssemblyIdentity", (PVOID*)&g_pfnGenerateManifestPathOnAssemblyIdentity },
    { "SxsGenerateActivationContext",   (PVOID*)&g_pfnSxsGenerateActivationContext },
    { "SxsQueryManifestInformation",    (PVOID*)&g_pfnQueryManifestInformation },
    { "SxsInstallW",                    (PVOID*)&g_pfnSxsInstallW },
    { "SxsUninstallW",                  (PVOID*)&g_pfnSxsUninstallW },
    { (PCSTR)SXSP_DEBUG_ORDINAL,        (PVOID*)&g_pfnSxspDebug },
    { SXS_PROBE_ASSEMBLY_INSTALLATION,  (PVOID*)&g_pfnSxsProbeAssemblyInstallation },
    { SXS_FIND_CLR_SURROGATE_INFO,      (PVOID*)&g_pfnClrSurrogate },
    { SXS_FIND_CLR_CLASS_INFO,          (PVOID*)&g_pfnClrClass },
    { SXS_LOOKUP_CLR_GUID,              (PVOID*)&g_pfnClrLookup }
};

extern const UNICODE_STRING sxs_dot_dll_UnicodeString = RTL_CONSTANT_STRING(L"sxs.dll");
extern const UNICODE_STRING sxs_dot_cap_dot_dll_UnicodeString = RTL_CONSTANT_STRING(L"sxs.cap.dll");
extern const UNICODE_STRING d_UnicodeString = RTL_CONSTANT_STRING(L"d");
extern const UNICODE_STRING obj_UnicodeString = RTL_CONSTANT_STRING(L"obj");
extern const UNICODE_STRING dll_backslash_whistler_UnicodeString = RTL_CONSTANT_STRING(L"dll\\whistler");
extern const UNICODE_STRING base_backslash_win32_backslash_fusion_backslash_dll_whistler_UnicodeString = RTL_CONSTANT_STRING(L"base\\win32\\fusion\\dll\\whistler");

BOOL LoadSxsDllCommonTail()
{
    //
    // raise an exception if the load failed
    // call GetProcAddress a bunch of times
    //
    FN_PROLOG_WIN32;

    BOOL IsWow = FALSE;
    SIZE_T i = 0;

    if (g.sxsDll == NULL)
    {
        ThrowLastError();
    }
    for (i = 0 ; i != NUMBER_OF(SxsProcs) ; ++i)
    {
        if (SxsProcs[i].Ordinal == SXSP_DEBUG_ORDINAL)
        {
            GetSxsProc(SxsProcs[i].Ordinal, SxsProcs[i].Address);
        }
        else
        {
            GetSxsProc(SxsProcs[i].Name, SxsProcs[i].Address);
        }
    }
    if (IsWow64Process(GetCurrentProcess(), &IsWow) && !IsWow)
    {
        UserBreakPoint(L"JayKrell");
    }

    FN_EPILOG;
}

BOOL LoadInstalledSxsDll()
{
    FN_PROLOG_WIN32;

    if (g.sxsDll == NULL)
    {
        CTinyStringBuffer DllPath;
        CStringBufferAccessor acc;

        IFW32FALSE_EXIT(DllPath.Win32ResizeBuffer(MAX_PATH, eDoNotPreserveBufferContents));

        acc.Attach(&DllPath);
        acc.GetBufferPtr()[acc.GetBufferCch() - 1] = 0;
        GetSystemDirectoryW(
            acc.GetBufferPtr(),
            acc.GetBufferCchAsDWORD() - 1
            );
        acc.Detach();

        IFW32FALSE_EXIT(DllPath.Win32AppendPathElement(&sxs_dot_dll_UnicodeString));

        g.sxsDll = LoadLibraryW(DllPath);

        LoadSxsDllCommonTail();
    }

    FN_EPILOG;
}

BOOL
SxspGetEnvironmentVariable(
    PCWSTR Name,
    CBaseStringBuffer &Value,
    DWORD *pdw OPTIONAL = NULL
    )
{
    FN_PROLOG_WIN32;
    CStringBufferAccessor acc;
    DWORD dw = 0;
    pdw = (pdw != NULL) ? pdw : &dw;

    IFW32FALSE_EXIT(Value.Win32ResizeBuffer(MAX_PATH, eDoNotPreserveBufferContents));

    acc.Attach(&Value);
    acc.GetBufferPtr()[0] = 0;
    acc.GetBufferPtr()[acc.GetBufferCch() - 1] = 0;
    *pdw = ::GetEnvironmentVariableW(
        Name,
        acc.GetBufferPtr(),
        acc.GetBufferCchAsDWORD() - 1
        );

    FN_EPILOG;
}

BOOL
UseStaticSxsDll()
{
    FN_PROLOG_WIN32;

    if (g.sxsDll == NULL)
    {
        g.sxsDll = ::GetModuleHandleW(NULL);
        LoadSxsDllCommonTail();
    }

    FN_EPILOG;
}

BOOL
LoadBuiltSxsDll()
{
    FN_PROLOG_WIN32;

    if (g.sxsDll == NULL)
    {
        CTinyStringBuffer DllPath;
        CTinyStringBuffer SdxRoot;
        CTinyStringBuffer ExePath;
        CTinyStringBuffer BuildAltDirEnvironmentVariable;
        CTinyStringBuffer ObjDirEnvironmentVariable;
        CTinyStringBuffer CheckedAltDirEnvironmentVariable;
#if DBG
        bool FreeBuild = false;
#else
        bool FreeBuild = true;
#endif
        CTinyStringBuffer ObjDir;
        CStringBufferAccessor acc;

        //
        // see makefile.def
        //
        SxspGetEnvironmentVariable(L"BUILD_ALT_DIR", BuildAltDirEnvironmentVariable);
        SxspGetEnvironmentVariable(L"_OBJ_DIR", ObjDirEnvironmentVariable);
        SxspGetEnvironmentVariable(L"CHECKED_ALT_DIR", CheckedAltDirEnvironmentVariable);

        if (BuildAltDirEnvironmentVariable.Cch() == 0)
        {
            if (CheckedAltDirEnvironmentVariable.Cch() != 0)
            {
                if (!FreeBuild)
                {
                    IFW32FALSE_EXIT(BuildAltDirEnvironmentVariable.Win32Assign(&d_UnicodeString));
                }
            }
        }
        if (ObjDirEnvironmentVariable.Cch() != 0)
        {
            IFW32FALSE_EXIT(ObjDir.Win32Assign(ObjDirEnvironmentVariable));
        }
        else
        {
            IFW32FALSE_EXIT(ObjDir.Win32Assign(&obj_UnicodeString));
            IFW32FALSE_EXIT(ObjDir.Win32Append(BuildAltDirEnvironmentVariable));
        }


        // Override with the SXS_DLL environment variable first...
        SxspGetEnvironmentVariable(L"SXS_DLL", DllPath);
        if (DllPath.Cch() != 0)
        {
            g.sxsDll = ::LoadLibraryW(DllPath);
        }

        //
        // try %sdxroot%\base\win32\fusion\dll\whistler\obj\i386\sxs.cap.dll
        // and %sdxroot%\base\win32\fusion\dll\whistler\obj\i386\sxs.dll
        //
        if (g.sxsDll == NULL)
        {
            SxspGetEnvironmentVariable(L"SdxRoot", SdxRoot);
            if (SdxRoot.Cch() != 0)
            {
                IFW32FALSE_EXIT(DllPath.Win32Assign(SdxRoot));
                IFW32FALSE_EXIT(DllPath.Win32EnsureTrailingPathSeparator());
                IFW32FALSE_EXIT(DllPath.Win32Append(&base_backslash_win32_backslash_fusion_backslash_dll_whistler_UnicodeString));
                IFW32FALSE_EXIT(DllPath.Win32AppendPathElement(ObjDir));
                IFW32FALSE_EXIT(DllPath.Win32AppendPathElement(&ProcessorBuildObjString));

                IFW32FALSE_EXIT(DllPath.Win32AppendPathElement(&sxs_dot_cap_dot_dll_UnicodeString));

                if (g.sxsDll == NULL)
                {
                    g.sxsDll = LoadLibraryW(DllPath);
                }
                if (g.sxsDll == NULL)
                {
                    IFW32FALSE_EXIT(DllPath.Win32RemoveLastPathElement());
                    IFW32FALSE_EXIT(DllPath.Win32AppendPathElement(&sxs_dot_dll_UnicodeString));

                    g.sxsDll = LoadLibraryW(DllPath);
                }
            }
        }

        //
        // try to get it relative to where the .exe is instead of relative to sdxroot
        //
        if (g.sxsDll == NULL)
        {
            IFW32FALSE_EXIT(ExePath.Win32ResizeBuffer(MAX_PATH, eDoNotPreserveBufferContents));
            acc.Attach(&ExePath);
            acc.GetBufferPtr()[acc.GetBufferCch() - 1] = 0;

            GetModuleFileNameW(
                NULL,
                acc.GetBufferPtr(),
                acc.GetBufferCchAsDWORD() - 1
                );

            acc.Detach();
        }

        //
        // try the same directory as the .exe
        //
        if (g.sxsDll == NULL)
        {
            IFW32FALSE_EXIT(DllPath.Win32Assign(ExePath));
            IFW32FALSE_EXIT(DllPath.Win32RemoveLastPathElement());
            IFW32FALSE_EXIT(DllPath.Win32AppendPathElement(&sxs_dot_dll_UnicodeString));
            g.sxsDll = LoadLibraryW(DllPath);
        }


        //
        // try relative to where the .exe is built
        //
        //
        // W:\fusi\base\win32\fusion\dll\whistler\obj\ia64\sxs.dll
        // W:\fusi\base\win32\fusion\whistler\obj\ia64\sxstest.exe
        //
        if (g.sxsDll == NULL)
        {
            IFW32FALSE_EXIT(DllPath.Win32Assign(ExePath));
            IFW32FALSE_EXIT(DllPath.Win32RemoveLastPathElement()); // sxstest.exe
            IFW32FALSE_EXIT(DllPath.Win32RemoveLastPathElement()); // ia64
            IFW32FALSE_EXIT(DllPath.Win32RemoveLastPathElement()); // obj
            IFW32FALSE_EXIT(DllPath.Win32RemoveLastPathElement()); // whistler
            IFW32FALSE_EXIT(DllPath.Win32EnsureTrailingPathSeparator());
            IFW32FALSE_EXIT(DllPath.Win32Append(&dll_backslash_whistler_UnicodeString)); // dll\whistler
            IFW32FALSE_EXIT(DllPath.Win32AppendPathElement(ObjDir)); // obj
            IFW32FALSE_EXIT(DllPath.Win32AppendPathElement(&ProcessorBuildObjString)); // i386
            IFW32FALSE_EXIT(DllPath.Win32AppendPathElement(&sxs_dot_dll_UnicodeString)); // sxs.dll

            g.sxsDll = LoadLibraryW(DllPath);
        }

        LoadSxsDllCommonTail();
    }

    FN_EPILOG;
}

BOOL
LoadSxs()
{
    return
        LoadBuiltSxsDll()
        || LoadInstalledSxsDll()
        || UseStaticSxsDll();
}

int
TestInstall(
    PCWSTR manifest,
    __int64 flags,
    DWORD beginInstallFlags,
    DWORD installFlags,
    DWORD endInstallFlags
    )
{
    BOOL                        fSuccess = FALSE;
    PVOID                       installCookie = NULL;
    BOOL                        fCleanup = FALSE;
    SXS_INSTALL_SOURCE_INFO     SxsInstallInfo = {0};
    SXS_INSTALLW                SxsInstall = {sizeof(SxsInstall) };


    PSXS_INSTALLATION_FILE_COPY_CALLBACK    callback = NULL;
    PVOID                                   context = NULL;

    LoadSxs();

    if (!(*g_pfnSxsBeginAssemblyInstall)(
        beginInstallFlags,
        callback,
        context,
        NULL, // ImpersonationCallback,
        NULL, // ImpersonationContext,
        &installCookie))
    {
        goto Exit;
    }
    fCleanup = TRUE;

    SxsInstall.dwFlags = installFlags | SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID;
    SxsInstall.lpManifestPath = manifest;
    SxsInstall.pvInstallCookie = installCookie;
    SxsInstall.lpReference = NULL;

    fSuccess = g_pfnSxsInstallW(&SxsInstall);

Exit:
    if (fCleanup)
    {
        (*g_pfnSxsEndAssemblyInstall)(installCookie, endInstallFlags | (fSuccess ? SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT : SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT), NULL);
    }

    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

BOOL
TestManifestSchema(
    int argc,
    wchar_t** argv,
    int* piNext
    )
{
    BOOL fSuccess = FALSE;

    int i = (*piNext) + 1;

    if (i >= argc)
    {
        fprintf(stderr, "%S: Missing parameter after \"%S\"\n", argv[0], argv[i-1]);
        goto Exit;
    }

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_CHECK_MANIFEST_SCHEMA, 0, argv[i++], NULL);

    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        goto Exit;
    }

    *piNext = i;
    fSuccess = TRUE;

Exit:
    return fSuccess;
}

BOOL
TestXMLParsing(
    int argc,
    wchar_t** argv,
    int* piNext)
{
    BOOL fSuccess = FALSE;
    int i = (*piNext) + 1;

    if (i >= argc)
    {
        fprintf(stderr, "%S: missing parameter after \"%S\"\n", argv[0], argv[i-1]);
        goto Exit;
    }

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_XML_PARSER, 0, argv[i], NULL);

    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        goto Exit;
    }

    *piNext = i + 1;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
TestDirect(
    int argc,
    wchar_t** argv,
    int* piNext)
{
    BOOL fSuccess = FALSE;
    int i = (*piNext) + 1;
    int n = 1;
    ULONGLONG cc1, cc2;

    if (i >= argc)
    {
        fprintf(stderr, "%S: missing parameter after \"%S\"\n", argv[0], argv[i-1]);
        goto Exit;
    }

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_DLL_REDIRECTION, 0, argv[i], NULL);
    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        goto Exit;
    }

    cc1 = GetCycleCount();

    for (n=0; n<10; n++)
        fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_DLL_REDIRECTION, 0, argv[i], NULL);

    cc2 = GetCycleCount();

    printf("%I64u cycles for %d iterations\n", cc2 - cc1, n);

    *piNext = i + 1;
    fSuccess = TRUE;
Exit:
    return fSuccess;

}

VOID
PrintBlob(
    FILE *pf,
    PVOID Data,
    SIZE_T Length,
    PCWSTR PerLinePrefix
    )
{
    SIZE_T Offset = 0;

    if (PerLinePrefix == NULL)
        PerLinePrefix = L"";

    // we'll output in 8-byte chunks as shown:
    //
    //  [prefix]Binary section %p (%d bytes)
    //  [prefix]   00000000: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //  [prefix]   00000008: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //  [prefix]   00000010: xx-xx-xx-xx-xx-xx-xx-xx (........)
    //

    while (Length >= 8)
    {
        BYTE *pb = (BYTE *) (((ULONG_PTR) Data) + Offset);

        fprintf(
            pf,
            "%S   %08lx: %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x (%c%c%c%c%c%c%c%c)\n",
            PerLinePrefix,
            Offset,
            pb[0], pb[1], pb[2], pb[3], pb[4], pb[5], pb[6], pb[7],
            PRINTABLE(pb[0]),
            PRINTABLE(pb[1]),
            PRINTABLE(pb[2]),
            PRINTABLE(pb[3]),
            PRINTABLE(pb[4]),
            PRINTABLE(pb[5]),
            PRINTABLE(pb[6]),
            PRINTABLE(pb[7]));

        Offset += 8;
        Length -= 8;
    }

    if (Length != 0)
    {
        CStringBuffer buffTemp;
        bool First = true;
        ULONG i;
        BYTE *pb = (BYTE *) (((ULONG_PTR) Data) + Offset);

        buffTemp.Win32ResizeBuffer(48, eDoNotPreserveBufferContents);

        buffTemp.Win32Format(L"   %08lx: ", Offset);

        for (i=0; i<8; i++)
        {
            if (Length > 0)
            {
                if (!First)
                    buffTemp.Win32Append("-", 1);
                else
                    First = false;

                buffTemp.Win32FormatAppend(L"%02x", pb[i]);

                Length--;
            }
            else
            {
                buffTemp.Win32Append("   ", 3);
            }
        }

        buffTemp.Win32Append(" (", 2);

        i = 0;

        while (Length != 0)
        {
            CHAR chTemp = static_cast<CHAR>(PRINTABLE(pb[i]));
            i++;
            buffTemp.Win32Append(&chTemp, 1);
            Length--;
        }

        buffTemp.Win32Append(L")", 1);

        fprintf(
            pf,
            "%S%S\n",
            PerLinePrefix,
            static_cast<PCWSTR>(buffTemp));
    }
}

void __stdcall TestWin32Apc(ULONG_PTR arg)
{
    ACTCTXW ac = {sizeof(ac)};
    int     error = 0;
    PWSTR   source = reinterpret_cast<PWSTR>(arg);
    HANDLE  hActCtx = NULL;
    BOOL    fSuccess = FALSE;

    ac.lpSource = source;
    PWSTR pound = wcschr(source, '#');
    if (pound != NULL)
    {
        *pound = 0;
        ac.lpResourceName = pound + 1;
        ac.dwFlags |= ACTCTX_FLAG_RESOURCE_NAME_VALID;
    }
    ac.wProcessorArchitecture = g.wProcessorArchitecture;
    ac.wLangId = g.wLangId;
    hActCtx = ::CreateActCtxW(&ac);
    if (hActCtx == INVALID_HANDLE_VALUE)
    {
        error = ::GetLastError();
        fwprintf(stderr, L"CreateActCtxW(%ls) failed; ::GetLastError() = %d\n", source, error);
        goto Exit;
    }
    //fSuccess = ::ReleaseActCtx(hActCtx);
    fSuccess = TRUE;
    hActCtx = NULL;
    if (!fSuccess)
    {
        error = ::GetLastError();
        goto Exit;
    }
Exit:
    if (error)
        ThrowWin32(error);
}

void
TestWin32(
    wchar_t** argv
    )
{
    CreateThreads();
    int i = 0;

    for (i = 0 ; argv[i] ; ++i)
    {
        if (g.NumberOfThreads)
        {
            if (!QueueUserAPC(TestWin32Apc, g.Threads[i % g.NumberOfThreads], reinterpret_cast<ULONG_PTR>(argv[i])))
            {
                fprintf(stderr, "QueueUserAPC() failed\n");
                ThrowWin32(((ULONG_PTR) (LONG_PTR) -1));
            }
        }
        else
        {
            TestWin32Apc(reinterpret_cast<ULONG_PTR>(argv[i]));
        }
    }
}

const static WCHAR InheritManifest[] =
L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
L"<assemblyIdentity type=\"win32\" name=\"Microsoft.Windows.SystemCompatibleAssembly\" version=\"1.0.0.0\" processorArchitecture=\"x86\" />"
L"<description>System Compatible Default</description> "
L"<dependency> <dependentAssembly>"
L"<assemblyIdentity type=\"win32\" name=\"Microsoft.Tools.VisualCPlusPlus.Runtime-Libraries\" version=\"6.0.0.0\" language=\"*\" processorArchitecture=\"x86\" publicKeyToken=\"6595b64144ccf1df\" />"
L"</dependentAssembly> </dependency></assembly>"
;

const static WCHAR NoInheritManifest[] =
L"<assembly manifestversion=\"1.0\" name=\"InheritManifest\">"
L"<dependency assemblyname=\"Microsoft-Visual-CPlusPlus-Runtime-Libraries\" version=\"6.0.0.0\" language=\"0000\"/>"
L"<noinherit/>"
L"</assembly>"
;

const static WCHAR RefCountManifest[] =
L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
L"<assemblyIdentity type=\"win32\" name=\"Microsoft.Windows.SxsTest.RefCount\" version=\"1.0.0.0\" processorArchitecture=\"x86\" />"
L"<description>blah</description> "
L"<dependency><dependentAssembly>"
//L"<assemblyIdentity type=\"win32\" name=\"Microsoft.Windows.SxsTest1\" version=\"1.0.0.0\" language=\"*\" processorArchitecture=\"x86\" publicKeyToken=\"6595b64144ccf1df\" />"
L"<assemblyIdentity type=\"win32\" name=\"Microsoft.Tools.VisualCPlusPlus.Runtime-Libraries\" version=\"6.0.0.0\" language=\"*\" processorArchitecture=\"x86\" publicKeyToken=\"6595b64144ccf1df\" />"
L"</dependentAssembly> </dependency></assembly>"
;

// to test the empty actctx, we push this, probe, push empty, probe
const static PCWSTR DependentOnMsvc6Manifest = InheritManifest;

WCHAR SearchPathResult[MAX_PATH];

void ProbeContext(const char* Function, PCWSTR Dll = L"msvcrt.dll")
{
    SearchPathResult[0] = 0;
    SearchPathW(NULL, Dll, NULL, NUMBER_OF(SearchPathResult), SearchPathResult, NULL);

    DbgPrint("%s %ls\n", Function, SearchPathResult);
}

DWORD CALLBACK InheritThreadMain(VOID*)
{
    ProbeContext(__FUNCTION__);
    return 0;
}

DWORD CALLBACK NoinheritThreadMain(VOID*)
{
    ProbeContext(__FUNCTION__);
    return 0;
}

void TestInherit()
{
    ProbeContext(__FUNCTION__);
    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(InheritManifest);
    ULONG_PTR Cookie;
    ActivateActCtx(ActivationContextHandle, &Cookie);
    ProbeContext(__FUNCTION__);
    DWORD ThreadId;
    WaitForSingleObject(CreateThread(NULL, 0, InheritThreadMain, NULL, 0, &ThreadId), INFINITE);
}

void TestNoInherit()
{
    ProbeContext(__FUNCTION__);
    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(NoInheritManifest);
    ULONG_PTR Cookie;
    ActivateActCtx(ActivationContextHandle, &Cookie);
    ProbeContext(__FUNCTION__);
    DWORD ThreadId;
    WaitForSingleObject(CreateThread(NULL, 0, NoinheritThreadMain, NULL, 0, &ThreadId), INFINITE);
}

void TestEmpty()
{
    ProbeContext(__FUNCTION__);
    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(DependentOnMsvc6Manifest);
    ULONG_PTR Cookie1;
    ULONG_PTR Cookie2;
    ActivateActCtx(ActivationContextHandle, &Cookie1);
    ProbeContext(__FUNCTION__);
    ActivateActCtx(ACTCTX_EMPTY, &Cookie2);
    ProbeContext(__FUNCTION__);
    DeactivateActCtx(0, Cookie2);
    ProbeContext(__FUNCTION__);
    DeactivateActCtx(0, Cookie1);
    ProbeContext(__FUNCTION__);
}

void TestRefCount()
{
    //
    // 1) newly created actctx has refcount==1
    // 2) activated actctx has refcount==1
    // 3) load a library with no deps with actctx, refcount==2
    // 4) freelibrary, refcount==1
    //    directory of library is closed
    // 5) release actctx refcount==0
    //
    // First order, just step through the code to look at the refcount.
    // Second order, "detour" like crazy and look at the memory
    //  (including detouring away RtlFreeHeap, NtUnmapViewOfSection)
    //

    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(RefCountManifest);
    ULONG_PTR Cookie1;
    ActivateActCtx(ActivationContextHandle, &Cookie1);
    FreeLibrary(LoadLibraryW(L"msvcrt.dll"));
    DeactivateActCtx(0, Cookie1);
    ReleaseActCtx(ActivationContextHandle);
}

GUID Guids[100];
WCHAR GuidStrings[100][64];

#include "sxstest_formatguid.cpp"

extern "C" HRESULT __stdcall
DllGetClassObject(
    REFCLSID rclsid,  //CLSID for the class object
    REFIID riid,      //Reference to the identifier of the interface
                    // that communicates with the class object
    LPVOID * ppv      //Address of output variable that receives the
                    // interface pointer requested in riid
    )
{
    WCHAR GuidString[64];

    FormatGuid(GuidString, NUMBER_OF(GuidString), rclsid);
    printf("%s : {%ls}\n", __FUNCTION__, GuidString);

    if (riid == IID_IUnknown)
    {
        *ppv = &g.unknown;
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

void TestGuidSort()
{
    const int MAX = 100;
    FN_TRACE_SMART_TLS();

    CStringBuffer Manifest;
    int i = 0;

    Ole32.CoInitialize(NULL);

    Manifest.Win32ResizeBuffer(1 << 15, eDoNotPreserveBufferContents);
    Manifest.Win32Format(
        L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\"> \
                <assemblyIdentity \
                    type=\"win32\" \
                    name=\"Microsoft.Windows.SxsTest.GuidSort\" \
                    version=\"1.0.0.0\" \
                    processorArchitecture=\"x86\" \
                    publicKeyToken=\"6595b64144ccf1df\" \
                /> \
            <file name=\"sxstest.exe\">");

    for (i = 0 ; i < MAX ; ++i)
    {
        GUID& Guid = Guids[i];
        CoCreateGuid(&Guid);

        FormatGuid(GuidStrings[i], NUMBER_OF(GuidStrings[i]), Guid);
        if (!Manifest.Win32FormatAppend(
            L"\n<comClass description=\"a%d\" clsid=\"{%ls}\"/>",
            i,
            static_cast<PCWSTR>(GuidStrings[i])))
            ThrowLastError();
    }

    if (!Manifest.Win32FormatAppend(L"\n</file>\n</assembly>"))
        ThrowLastError();

    printf("%ls\n", static_cast<PCWSTR>(Manifest));

    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(Manifest);
    ULONG_PTR Cookie1;
    ActivateActCtx(ActivationContextHandle, &Cookie1);
    for (i = 0 ; i < MAX ; ++i)
    {
        HRESULT hr;
        PVOID   pv = NULL;

        hr = Ole32.CoCreateInstance(Guids[i], NULL, CLSCTX_INPROC, IID_IUnknown, &pv);
        printf("CoCreateInstance({%ls}): %08lx%s%s%s\n",

            GuidStrings[i],

            static_cast<unsigned long>(hr),

            ( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            || hr == REGDB_E_CLASSNOTREG
            || (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
            || (hr == E_NOINTERFACE)
           ) ? "(" : "",

            (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                ? "ERROR_FILE_NOT_FOUND"
                : (hr == REGDB_E_CLASSNOTREG)
                ? "REGDB_E_CLASSNOTREG"
                : (hr == ERROR_INVALID_PARAMETER)
                ? "ERROR_INVALID_PARAMETER"
                : (hr == E_NOINTERFACE)
                ? "E_NOINTERFACE (ok)"
                : "",

            ( hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
            || hr == REGDB_E_CLASSNOTREG
            || hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
            || hr == E_NOINTERFACE
            ? ")" : "");
    }
    DeactivateActCtx(0, Cookie1);
    ReleaseActCtx(ActivationContextHandle);
}

void TestStringSort()
{

    /*
    Mike says this takes between 2 and 7 to visit the code.
    */
    const int MAX = 50;
    FN_TRACE_SMART_TLS();
    WCHAR ExePath[MAX_PATH];
    CStringBuffer DllPaths[MAX];

    CStringBuffer Manifest;
    int i = 0;

    if (!Kernel32.GetModuleFileNameW(NULL, ExePath, RTL_NUMBER_OF(ExePath)))
        ThrowLastError();

    if (!Manifest.Win32ResizeBuffer(1 << 15, eDoNotPreserveBufferContents))
        ThrowLastError();
    if (!Manifest.Win32Format(
        L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\"> \
                <assemblyIdentity \
                    type=\"win32\" \
                    name=\"Microsoft.Windows.SxsTest.StringSort\" \
                    version=\"1.0.0.0\" \
                    processorArchitecture=\"x86\" \
                    publicKeyToken=\"6595b64144ccf1df\" \
                /> \
            <file name=\"sxstest.exe\"/>"))
        ThrowLastError();
    for (i = 0 ; i < MAX ; ++i)
    {
        if (!DllPaths[i].Win32Format(L"%ls.%d.dll", ExePath, i))
            ThrowLastError();

        if (!::CopyFileW(ExePath, DllPaths[i], FALSE))
            ThrowLastError();

        SetDllBitInPeImage(DllPaths[i]);

        if (!Manifest.Win32FormatAppend(L"\n<file name=\"%ls\"/>\n", 1 + wcsrchr(static_cast<PCWSTR>(DllPaths[i]), '\\')))
            ThrowLastError();
    }
    if (!Manifest.Win32FormatAppend(L"\n</assembly>"))
        ThrowLastError();

    printf("%ls\n", static_cast<PCWSTR>(Manifest));

    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(Manifest);
    ULONG_PTR Cookie1;
    ActivateActCtx(ActivationContextHandle, &Cookie1);
    for (i = 0 ; i < MAX ; ++i)
    {
        HMODULE h;
        PCWSTR DllName = 1 + wcsrchr(DllPaths[i], '\\');

        h = ::LoadLibraryW(DllName);
        printf("LoadLibrary(%ls):%p, LastError=%d\n",
            DllName,
            h,
            ::GetLastError());
        //FreeLibrary(h);
        Kernel32.DeleteFileW(DllPaths[i]);
    }
    DeactivateActCtx(0, Cookie1);
    ReleaseActCtx(ActivationContextHandle);
}

int
TestSearchPathHelper1(
    PCSTR RunId,
    PCWSTR Path,
    PCWSTR File,
    PCWSTR Extension,
    bool GetFilePart,
    ULONG cch
    )
{
    WCHAR Buffer[65536]; // we know that the underlying code can never use a buffer this big
    PWSTR FilePart = NULL;
    PWSTR *lpFilePart = (GetFilePart ? &FilePart : NULL);
    SetLastError(ERROR_GEN_FAILURE);
    ULONG Result = ::SearchPathW(
        Path,
        File,
        Extension,
        0,
        NULL,
        lpFilePart);

    printf("SearchPath() RunId = %s (Path %s; File %s; Extension %s; GetFilePart %s; cch = %lu; buffer=null) result = %lu ::GetLastError() = %u; FilePart = %s %u\n",
        RunId,
        Path ? "present" : "null",
        File ? "present" : "null",
        Extension ? "present" : "null",
        GetFilePart ? "true" : "false",
        0,
        Result,
        ::GetLastError(),
        FilePart ? "present" : "null",
        FilePart ? (FilePart - Buffer) : 0);

    SetLastError(ERROR_GEN_FAILURE);
    FilePart = NULL;
    ULONG NewResult = ::SearchPathW(
        Path,
        File,
        Extension,
        Result,
        Buffer,
        lpFilePart);

    printf("SearchPath() RunId = %s (Path %s; File %s; Extension %s; GetFilePart %s; cch = %lu) result = %lu ::GetLastError() = %u; FilePart = %s %u\n",
        RunId,
        Path ? "present" : "null",
        File ? "present" : "null",
        Extension ? "present" : "null",
        GetFilePart ? "true" : "false",
        Result,
        NewResult,
        ::GetLastError(),
        FilePart ? "present" : "null",
        FilePart ? (FilePart - Buffer) : 0);

    SetLastError(ERROR_GEN_FAILURE);
    FilePart = NULL;
    Result = ::SearchPathW(
        Path,
        File,
        Extension,
        cch,
        Buffer,
        lpFilePart);

    printf("SearchPath() RunId = %s (Path %s; File %s; Extension %s; GetFilePart %s; cch = %lu) result = %lu ::GetLastError() = %u; FilePart = %s %u\n",
        RunId,
        Path ? "present" : "null",
        File ? "present" : "null",
        Extension ? "present" : "null",
        GetFilePart ? "true" : "false",
        cch,
        Result,
        ::GetLastError(),
        FilePart ? "present" : "null",
        FilePart ? (FilePart - Buffer) : 0);

    return EXIT_SUCCESS;
}

int
TestSearchPathHelper2(
    PCSTR RunId,
    PCWSTR Path,
    PCWSTR File,
    PCWSTR Extension,
    ULONG cch
    )
{
    TestSearchPathHelper1(RunId, NULL, File, NULL, true, cch);
    TestSearchPathHelper1(RunId, NULL, File, NULL, false, cch);
    TestSearchPathHelper1(RunId, Path, File, NULL, true, cch);
    TestSearchPathHelper1(RunId, Path, File, NULL, false, cch);
    TestSearchPathHelper1(RunId, NULL, File, Extension, true, cch);
    TestSearchPathHelper1(RunId, NULL, File, Extension, false, cch);
    TestSearchPathHelper1(RunId, Path, File, Extension, true, cch);
    TestSearchPathHelper1(RunId, Path, File, Extension, false, cch);

    return EXIT_SUCCESS;
}

int
TestSearchPathHelper3(
    PCSTR RunId,
    PCWSTR Path,
    PCWSTR File,
    PCWSTR Extension
    )
{
    ULONG i;

    for (i=0; i<5; i++)
        TestSearchPathHelper2(RunId, Path, File, Extension, i);

    for (i=MAX_PATH-5; i<(MAX_PATH+5); i++)
        TestSearchPathHelper2(RunId, Path, File, Extension, i);

    for (i=32760; i<32770; i++)
        TestSearchPathHelper2(RunId, Path, File, Extension, i);

    return EXIT_SUCCESS;
}

BOOL
TestSearchPath(
    int argc,
    wchar_t** argv,
    int* piNext
    )
{
    ULONG i;
    PWSTR PathToSearch = (PWSTR) malloc(100000* sizeof(WCHAR));
    int iNext = (*piNext) + 1;

    PathToSearch[0] = L'C';
    PathToSearch[1] = L'\\';
    for (i=2; i<60000; i++)
        PathToSearch[i] = L'X';
    wcscpy(&PathToSearch[i], L";C:\\");

    TestSearchPathHelper3("1.0", L"C:\\DirectoryDoesNotExist;C:\\", L"boot.ini", L".ini");
    TestSearchPathHelper3("1.1", L"C:\\DirectoryDoesNotExist;C:\\", L"boot.", L".ini");
    TestSearchPathHelper3("1.2", L"C:\\DirectoryDoesNotExist;C:\\", L"boot", L".ini");
    TestSearchPathHelper3("1.3", L"C:\\DirectoryDoesNotExist;C:\\", L"doesnotexist.doesnotexist", L".ini");
    TestSearchPathHelper3("1.4", L"C:\\DirectoryDoesNotExist;C:\\", L"d:\\readme.txt", L".ini");
    TestSearchPathHelper3("1.5", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32.dll", L".dll");
    TestSearchPathHelper3("1.6", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32.", L".dll");
    TestSearchPathHelper3("1.7", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32", L".dll");
    TestSearchPathHelper3("1.8", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32.dll", L".ini");
    TestSearchPathHelper3("1.9", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32.", L".ini");
    TestSearchPathHelper3("1.10", L"C:\\DirectoryDoesNotExist;C:\\", L"kernel32", L".ini");

    TestSearchPathHelper3("2.0", L"C:\\;C:\\DirectoryDoesNotExist", L"boot.ini", L".ini");
    TestSearchPathHelper3("2.1", L"C:\\;C:\\DirectoryDoesNotExist", L"boot.", L".ini");
    TestSearchPathHelper3("2.2", L"C:\\;C:\\DirectoryDoesNotExist", L"boot", L".ini");
    TestSearchPathHelper3("2.3", L"C:\\;C:\\DirectoryDoesNotExist", L"doesnotexist.doesnotexist", L".ini");
    TestSearchPathHelper3("2.4", L"C:\\;C:\\DirectoryDoesNotExist", L"d:\\readme.txt", L".ini");
    TestSearchPathHelper3("2.5", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32.dll", L".dll");
    TestSearchPathHelper3("2.6", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32.", L".dll");
    TestSearchPathHelper3("2.7", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32", L".dll");
    TestSearchPathHelper3("2.8", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32.dll", L".ini");
    TestSearchPathHelper3("2.9", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32.", L".ini");
    TestSearchPathHelper3("2.10", L"C:\\;C:\\DirectoryDoesNotExist", L"kernel32", L".ini");

    TestSearchPathHelper3("3.0", PathToSearch, L"boot.ini", L".ini");
    TestSearchPathHelper3("3.1", PathToSearch, L"boot", L".ini");
    TestSearchPathHelper3("3.1", PathToSearch, L"boot.", L".ini");
    TestSearchPathHelper3("3.2", PathToSearch, L"doesnotexist.doesnotexist", L".ini");
    TestSearchPathHelper3("3.3", PathToSearch, L"d:\\readme.txt", L".ini");

    *piNext = iNext;

    return EXIT_SUCCESS;
}

BOOL
TestAct(
    int argc,
    wchar_t** argv,
    int* piNext)
{
    ULONG i, c;
    ULONG_PTR *prgCookies = NULL;
    HANDLE hActCtx = NULL;
    CHAR buffer[1024];
    int iNext = (*piNext + 1);
    BOOL fSuccess = FALSE;

    if (iNext >= argc)
    {
        fprintf(stderr, "%S: missing parameter after \"%S\"\n", argv[0], argv[iNext - 1]);
        goto Exit;
    }

    WideCharToMultiByte(CP_ACP, 0, argv[iNext++], -1, buffer, NUMBER_OF(buffer), NULL, NULL);

    ACTCTXA ac;

    ac.cbSize = sizeof(ac);
    ac.dwFlags = 0;
    ac.lpSource = buffer;
    ac.wProcessorArchitecture = g.wProcessorArchitecture;
    ac.wLangId = g.wLangId;

    hActCtx = ::CreateActCtxA(&ac);
    if (hActCtx == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "CreateActCtxA() failed; ::GetLastError() = %d\n", ::GetLastError());
        return EXIT_FAILURE;
    }

    c = 0;

    if (argc > iNext)
        c = _wtoi(argv[iNext++]);

    if (c == 0)
        c = 100;

    prgCookies = NEW(ULONG_PTR[c]);
    if (prgCookies == NULL)
    {
        fprintf(stderr, "Unable to allocate %lu cookies.\n", c);
        goto Exit;
    }

    for (i=0; i<c; i++)
    {
        if (!ActivateActCtx(hActCtx, &prgCookies[i]))
        {
            fprintf(stderr, "Attempt to activate to depth %lu failed; ::GetLastError() = %d\n", i, ::GetLastError());
            goto Exit;
        }
    }

    for (i=0; i<c; i++)
    {
        ULONG j = (c - i) - 1;
        DeactivateActCtx(0, prgCookies[j]);
    }

    ReleaseActCtx(hActCtx);

    fSuccess = TRUE;
    *piNext = iNext;

Exit:
    delete []prgCookies;

    return fSuccess;
}

HRESULT Helper_WriteStream(CBaseStringBuffer * pFileNameBuf,
                           IStream *pStream)
{
    HRESULT     hr          = NOERROR;
    LPBYTE      pBuf[0x4000];
    DWORD       cbBuf       = 0x4000;
    DWORD       dwWritten   = 0;
    DWORD       cbRead      = 0;
    HANDLE      hf          = INVALID_HANDLE_VALUE;

    hf = ::CreateFileW(static_cast<PCWSTR>(*pFileNameBuf), GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hf == INVALID_HANDLE_VALUE){
        hr = HRESULT_FROM_WIN32 (GetLastError());
        goto Exit;
    }

    while (::ReadFile(hf, pBuf, cbBuf, &cbRead, NULL) && cbRead){
        hr = pStream->Write(pBuf, cbRead, &dwWritten);
        if (FAILED(hr))
            goto Exit;
    }

    if (! SUCCEEDED(hr =pStream->Commit(0)))
        goto Exit;

    CloseHandle(hf);

Exit:
    return hr;
}

BOOL
TestMSIInstall(
    int argc,
    wchar_t** argv,
    int* piNext
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    CSmartRef<IAssemblyCache>     pCache;
    CSmartRef<IAssemblyCacheItem> ppCacheItem[4];
    CSmartRef<IStream>            pStream;
    CStringBuffer               SourceFilePathBuf;
    CStringBuffer               SourceFileNameBuf;

    CHAR                        buf[1024];
    FILE*                       fp = NULL;
    LPSTR                       p1, pbuf ;
    int                         i, cAsm;

    int iArg = (*piNext) + 1;
    if (iArg >= argc)
    {
        fprintf(stderr, "%S: missing parameter after \"%S\"\n", argv[0], argv[iArg-1]);
        goto Exit;
    }

    LoadSxs();
    IFCOMFAILED_EXIT((*g_pfnCreateAssemblyCache)(&pCache, 0));


    WideCharToMultiByte(CP_ACP, 0, argv[iArg], -1, buf, NUMBER_OF(buf), NULL, NULL);
    fp = fopen(buf, "r");
    if (!fp)  {
        fprintf(stderr, "%S: Error opening script file \"%S\"\n", argv[0], argv[iArg]);
        goto Exit;
    }
    cAsm = 0;
    while (! feof(fp)) {
        if (! fgets(buf, 80, fp)) { // end of file or error
            if (ferror(fp)){ // error occur
                fprintf(stderr, "%S: Error occur while reading the script file\n", argv[0]);
                goto Exit;
            }
            else{ // end of file
                fprintf(stderr, "%S: end of script file\n", argv[0]);
                break;
            }
        }
        // trim the string
        i = 0 ;
        while (buf[i] == ' ') i++; // skip the whitespace at the beginning of the line
        pbuf = buf + i ; // pointer to the first un-whitespace char in the line
        i = 0 ;
        while (pbuf[i] != '\n') i++;
        pbuf[i] = '\0';

        p1 = NULL;
        p1 = strchr(pbuf, ' ');
        if (p1 == NULL) { // instruction line
            if (strcmp(pbuf, "BeginAsmCacheItem") == 0) {
                IFCOMFAILED_EXIT(pCache->CreateAssemblyCacheItem(0, NULL, &ppCacheItem[cAsm], NULL));
            }else
            if (strcmp(pbuf, "EndAsmCacheItem") == 0) {
                IFCOMFAILED_EXIT(ppCacheItem[cAsm]->Commit(0, NULL));
                cAsm ++;
            }
        }
        else
        { // get the first word of the line
            *p1 = '\0';
            p1++; // p1 points to the filename now
            IFW32FALSE_EXIT(SourceFileNameBuf.Win32Assign(p1, ::strlen(p1)));
            if (strcmp(pbuf,"SourceFilePath") == 0) { // fullpath of source files, which would be in a CD
                IFW32FALSE_EXIT(SourceFilePathBuf.Win32Assign(p1, ::strlen(p1)));
                SourceFilePathBuf.Win32EnsureTrailingPathSeparator();
            }else
            if (strcmp(pbuf, "FILE") == 0) {
                IFCOMFAILED_EXIT(ppCacheItem[cAsm]->CreateStream(0, SourceFileNameBuf, STREAM_FORMAT_WIN32_MODULE, 0, &pStream, NULL));
                IFW32FALSE_EXIT(SourceFileNameBuf.Win32Assign(SourceFilePathBuf, ::wcslen(SourceFilePathBuf)));
                IFW32FALSE_EXIT(SourceFileNameBuf.Win32Append(p1, ::strlen(p1))); // containing full-path of the source file
                IFCOMFAILED_EXIT(Helper_WriteStream(&SourceFileNameBuf, pStream));
                pStream.Release(); // stream should be released since writtingfile has been done

            }else
            if (strcmp(pbuf, "MANIFEST") == 0) {
                IFCOMFAILED_EXIT(ppCacheItem[cAsm]->CreateStream(0, SourceFileNameBuf, STREAM_FORMAT_WIN32_MANIFEST, 0, &pStream, NULL));
                IFW32FALSE_EXIT(SourceFileNameBuf.Win32Assign(SourceFilePathBuf, SourceFilePathBuf.Cch())); // containing full-path of the source file
                IFW32FALSE_EXIT(SourceFileNameBuf.Win32Append(p1, ::strlen(p1)));
                IFCOMFAILED_EXIT(Helper_WriteStream(&SourceFileNameBuf, pStream));
                pStream.Release(); // stream should be released since writtingfile has been done
            }
        } // end of else
    }// end of while

    fSuccess = TRUE;
    *piNext = iArg;
Exit:
    fp ? fclose(fp) : 0;
    return fSuccess;
}

CDirWalk::ECallbackResult
DirWalkCallback(
    CDirWalk::ECallbackReason reason,
    CDirWalk*                 dirWalk,
    DWORD                     dwFlags
    )
{
    PCWSTR parent = dirWalk->m_strParent;
    PCWSTR leaf   = dirWalk->m_fileData.cFileName;
    if (reason == CDirWalk::eFile)
        printf("file %lu, %ls, %ls\n", reason, parent, leaf);
    else
        printf("directory %lu, %ls\n", reason, parent);
    return CDirWalk::eKeepWalking;
}

int
TestDirWalk(
    PCWSTR  root,
    PWSTR   filter
    )
{
#if 0
    CDirWalk dirWalk;
    StdVector<std::wstring> vstrFilter;
    StdVector<PCWSTR> vstrFilter2;
    PWSTR filterTok;

    if (filterTok = wcstok(filter, L";"))
    {
        do
        {
            vstrFilter.push_back(filterTok);
            vstrFilter2.push_back(vstrFilter.back().c_str());
        } while (filterTok = wcstok(NULL, L";"));
    }
    dirWalk.m_fileFiltersBegin = &*vstrFilter2.begin();
    dirWalk.m_fileFiltersEnd = &*vstrFilter2.end();
    dirWalk.m_strParent.Win32Assign(root, ::wcslen(root));
    dirWalk.m_callback = DirWalkCallback;
    dirWalk.Walk();
#endif
    return 0;
}

int
TestMultiAct(
    int argc,
    wchar_t **argv
    )
{
    HANDLE h1, h2;
    ACTCTXW acw;

    memset(&acw, 0, sizeof(acw));

    acw.cbSize = sizeof(acw);
    acw.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
    acw.lpSource = argv[2];
    acw.lpResourceName = MAKEINTRESOURCEW(1);

    h1 = ::CreateActCtxW(&acw);
    if (h1 == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "1st CreateActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());
        return EXIT_FAILURE;
    }

    h2 = ::CreateActCtxW(&acw);
    if (h2 == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "2nd CreateActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

BOOL
ParseProcessorArchitecture(
    int argc,
    wchar_t** argv,
    int* piCurrent
    )
{
    BOOL fSuccess = FALSE;

    int i = *piCurrent;

    i++;

    if (i >= argc)
    {
        fprintf(stderr, "%S: missing parameter after %S\n", argv[0], argv[i - 1]);
        goto Exit;
    }

    if (::FusionpStrCmpI(argv[i], L"x86") == 0)
        g.wProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
    else if (::FusionpStrCmpI(argv[i], L"i386") == 0)
        g.wProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
    else if (::FusionpStrCmpI(argv[i], L"ia64") == 0)
        g.wProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
    else if (::FusionpStrCmpI(argv[i], L"amd64") == 0)
        g.wProcessorArchitecture = PROCESSOR_ARCHITECTURE_AMD64;
    else
    {
        fprintf(stderr, "%S: invalid -pa value \"%S\"\n", argv[0], argv[i]);
        goto Exit;
    }

    *piCurrent = i + 1;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
ParseLangId(
    int argc,
    wchar_t** argv,
    int* piCurrent
    )
{
    BOOL fSuccess = FALSE;

    int i = *piCurrent;

    i++;

    if (i >= argc)
    {
        fprintf(stderr, "%S: missing parameter after %S\n", argv[0], argv[i - 1]);
        goto Exit;
    }

    swscanf(argv[i], L"%hx", &g.wLangId);

    *piCurrent = i + 1;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
TestLoadLibrary(
    int argc,
    wchar_t** argv,
    int* piNext
    )
{
    int i = (*piNext) + 1;
    HINSTANCE hInstance = NULL;
    BOOL fExpectedToFail = FALSE;
    BOOL fSuccess = FALSE;

    while (i < argc)
    {
        if (::FusionpStrCmpI(argv[i], L"-fail-") == 0)
            fExpectedToFail = TRUE;
        else if (::FusionpStrCmpI(argv[i], L"-succeed-") == 0)
            fExpectedToFail = FALSE;
        else
        {
            hInstance = LoadLibraryW(argv[i]);
            if (hInstance == NULL)
            {
                if (!fExpectedToFail)
                {
                    fprintf(stderr, "%S: Failed to LoadLibraryW(\"%S\"); ::GetLastError() = %d\n", argv[0], argv[i], ::GetLastError());
                }
            }
            else
            {
                if (fExpectedToFail)
                {
                    WCHAR LibraryPath[4096];

                    Kernel32.GetModuleFileNameW(hInstance, LibraryPath, NUMBER_OF(LibraryPath));

                    fprintf(stderr, "%S: LoadLibraryW(\"%S\") was supposed to fail, but instead we got \"%S\"\n", argv[0], argv[i], LibraryPath);
                }

                ::FreeLibrary(hInstance);
                hInstance = NULL;
            }
        }

        i++;
    }

    fSuccess = TRUE;
// Exit:
    return fSuccess;
}

int TestAssemblyName()
{
    BOOL fSuccess = FALSE;

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_ASSEMBLYNAME_CONVERSION, 0, NULL, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;

}

int TestPrecomiledManifest(PCWSTR manifestFileName)
{
    BOOL fSuccess = FALSE;

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_PRECOMPILED_MANIFEST, 0, manifestFileName, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

int TestPCMTime(PCWSTR manifestFilename)
{
    BOOL fSuccess = FALSE;

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_TIME_PCM, 0, manifestFilename, NULL);

    if (! fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

int TestCreateMultiLevelDirectory(PCWSTR dirs)
{
    BOOL fSuccess = FALSE;

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_CREAT_MULTILEVEL_DIRECTORY, 0, dirs, NULL);

    if (! fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}


BOOL
TestLeakMemory(
    DWORD dwAmount
    )
{
    BOOL fSuccess = FALSE;

    if (dwAmount < 1) {
        fprintf(stderr, "%s got a bad parameter, %d; rectifying to 1.\n", __FUNCTION__, dwAmount);
        dwAmount = 1;
    }

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_FORCE_LEAK, 0, NULL, (PDWORD)&dwAmount);

    if (! fSuccess)
    {
        fprintf(stderr, "%s failed to leak %d bytes of memory!\n", __FUNCTION__, dwAmount);
        return EXIT_FAILURE;
    }
    else
    {
        fprintf(stdout, "%s leaked %d bytes of memory.\n", __FUNCTION__, dwAmount);
        return EXIT_SUCCESS;
    }
}

BOOL
TestManifestProbing(
    int argc,
    wchar_t **argv,
    int *piNext
    )
{
    BOOL fSuccess = FALSE;
    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_PROBE_MANIFST, 0, NULL, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;

}

BOOL
TestAssemblyProbing(
    int argc,
    wchar_t **argv,
    int *piNext
    )
{
    BOOL fSuccess = FALSE;
    DWORD dwDisposition = 0;

    LoadSxs();

    fSuccess = (*g_pfnSxsProbeAssemblyInstallation)(0, argv[*piNext], &dwDisposition);

    return (fSuccess ? EXIT_SUCCESS : EXIT_FAILURE);
}

int TestCreateProcess2(wchar_t** argv)
{
    STARTUPINFOW StartupInfo = { sizeof(StartupInfo) };
    PROCESS_INFORMATION ProcessInformation = {0};

    *argv += wcsspn(*argv, L" \t\r\n");

    BOOL f = ::CreateProcessW(
        *argv,
        NULL,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation);
    printf("CreateProcess(%S) returned %s\n", *argv, f ? "True" : "False");

    return EXIT_SUCCESS;
}


int TestCreateProcess(wchar_t** argv)
{
    CUnicodeStringBuffer CommandLine;
    STARTUPINFOW StartupInfo = { sizeof(StartupInfo) };
    PROCESS_INFORMATION ProcessInformation = {0};

    while (*argv)
    {
        CommandLine.Win32Append(L" ", 1);
        CommandLine.Win32Append(*argv, ::wcslen(*argv));
        argv++;
    }

    CUnicodeStringBufferAccessor MutableCommandLine(&CommandLine);
    BOOL f = ::CreateProcessW(
        NULL,
        MutableCommandLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation);
    printf("CreateProcess(%S) returned %s\n", static_cast<PCWSTR>(MutableCommandLine), f ? "True" : "False");

    return EXIT_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////
// XMLDOM Helper function:
////////////////////////////////////////////////////////////////////////////
HRESULT XMLDOMHelper_WalkTree(IXMLDOMNode* node, int level)
{
    IXMLDOMNode* pChild, *pNext;
    BSTR nodeName;
    IXMLDOMNamedNodeMap* pattrs;

    node->get_nodeName(&nodeName);
    for (int i = 0; i < level; i++)
        printf(" ");
    printf("%S",nodeName);
    SysFreeString(nodeName);


    if (SUCCEEDED(node->get_attributes(&pattrs)) && pattrs != NULL)
    {
        pattrs->nextNode(&pChild);
        while (pChild)
        {
            BSTR name;
            pChild->get_nodeName(&name);
            printf(" %S='", name);
            ::SysFreeString(name);

            VARIANT value;
            pChild->get_nodeValue(&value);
            if (value.vt == VT_BSTR)
            {
                printf("%S", V_BSTR(&value));
            }
            printf("'");
            VariantClear(&value);
            pChild->Release();
            pattrs->nextNode(&pChild);
        }
        pattrs->Release();
    }
    printf("\n");

    node->get_firstChild(&pChild);
    while (pChild)
    {
        XMLDOMHelper_WalkTree(pChild, level+1);
        pChild->get_nextSibling(&pNext);
        pChild->Release();
        pChild = pNext;
    }

    return S_OK;
}
////////////////////////////////////////////////////////////////////////////
// XMLDOM Helper function:
////////////////////////////////////////////////////////////////////////////
HRESULT XMLDOMHelper_ReportError(IXMLDOMParseError *pXMLError)
{
    long line, linePos;
    LONG errorCode;
    BSTR pBURL = NULL, pBReason = NULL;
    HRESULT hr;

    hr = pXMLError->get_line(&line);
    if (FAILED(hr))
        goto Exit;

    hr = pXMLError->get_linepos(&linePos);
    if (FAILED(hr))
        goto Exit;

    hr = pXMLError->get_errorCode(&errorCode);
    if (FAILED(hr))
        goto Exit;

    hr = pXMLError->get_url(&pBURL);
    if (FAILED(hr))
        goto Exit;

    hr = pXMLError->get_reason(&pBReason);
    if (FAILED(hr))
        goto Exit;


    fprintf(stderr, "%S", pBReason);
    if (line > 0)
    {
        fprintf(stderr, "Error on line %d, position %d in \"%S\".\n",
            line, linePos, pBURL);
    }
    hr= E_FAIL;

Exit:
    SysFreeString(pBURL);
    SysFreeString(pBReason);

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// XMLDOM Helper function: Check load results
////////////////////////////////////////////////////////////////////////////
HRESULT XMLDOMHelper_CheckLoad(IXMLDOMDocument* pDoc)
{
    // And since we don't have the VARIANT_BOOL from load we
    // need to check the parse Error errorCode property to see
    // if everything went ok.
    IXMLDOMParseError  *pXMLError = NULL;
    LONG errorCode;
    HRESULT hr = NOERROR;

    hr = pDoc->get_parseError(&pXMLError);
    if (FAILED(hr))
        goto Exit;

    hr = pXMLError->get_errorCode(&errorCode);
    if (FAILED(hr))
        goto Exit;

    if (errorCode != 0){
        hr = XMLDOMHelper_ReportError(pXMLError);
        goto Exit;
    }

     hr = NOERROR;
Exit:
    if (pXMLError)
        pXMLError->Release();

    return hr;
}
////////////////////////////////////////////////////////////////////////////
// XMLDOM Helper function:
////////////////////////////////////////////////////////////////////////////
HRESULT XMLDOMHelper_LoadDocumentSync(IXMLDOMDocument *pDoc, BSTR pBURL)
{
    IXMLDOMParseError  *pXMLError = NULL;
    VARIANT         vURL;
    VARIANT_BOOL    vb;
    HRESULT         hr;

    hr = pDoc->put_async(VARIANT_FALSE);
    if (FAILED(hr))
        goto Exit;

    // Load xml document from the given URL or file path
    VariantInit(&vURL);
    vURL.vt = VT_BSTR;
    V_BSTR(&vURL) = pBURL;
    hr = pDoc->load(vURL, &vb);
    if (FAILED(hr))
        goto Exit;

    hr = XMLDOMHelper_CheckLoad(pDoc);
    if (FAILED(hr))
        goto Exit;

    hr = NOERROR;

Exit:
    if (pXMLError)
        pXMLError->Release();

    return hr;
}


BOOL TestXMLDOM(PCWSTR pswzXMLFileName)
{
    HRESULT hr = S_OK;
    IXMLDOMDocument *pDoc = NULL;
    IXMLDOMNode* pNode = NULL;
    BSTR pBURL = NULL;

    Ole32.CoInitialize(NULL);

    // Create an empty XML document
    hr = Ole32.CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
                                IID_IXMLDOMDocument, (void**)&pDoc);
    if (FAILED(hr))
        goto Exit;

    pBURL = SysAllocString(pswzXMLFileName);
    hr = XMLDOMHelper_LoadDocumentSync(pDoc, pBURL);
    if (FAILED(hr))
        goto Exit;

    // Now walk the loaded XML document dumping the node names to stdout.
    hr = pDoc->QueryInterface(IID_IXMLDOMNode,(void**)&pNode);
    if (FAILED(hr))
        goto Exit;

    hr = XMLDOMHelper_WalkTree(pNode,0);
    if (FAILED(hr))
        goto Exit;

    hr = NOERROR;

Exit:
    if (pDoc) pDoc->Release();
    SysFreeString(pBURL);
    if (pNode) pNode->Release();

    Ole32.CoUninitialize();

    return hr == 0 ? 0 : 1;

}

BOOL TestFusionArray(PCWSTR dir1, PCWSTR dir2)
{
    BOOL fSuccess = FALSE;
    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_FUSION_ARRAY, 0, dir1, (PVOID)dir2);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

BOOL TestGeneratePathFromIdentityAttributeString(PCWSTR str)
{
    BOOL        fSuccess = FALSE;
    WCHAR       folderName[5000];
    SIZE_T      cch = NUMBER_OF(folderName);

    LoadSxs();

    fSuccess = (*g_pfnGenerateManifestPathOnAssemblyIdentity)((PWSTR) str, folderName, &cch, NULL);

    if (! fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
    {
        wprintf(L"Folder name returned is %s\n", folderName);
        return EXIT_SUCCESS;
    }

}

BOOL
TestDirectoryChangeWatcher(
    int argc,
    wchar_t **argv,
    int *piNext
    )
{
    BOOL fSuccess = FALSE;

    LoadSxs();
    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_DIRECTORY_WATCHER, 0, NULL, NULL);
    return (fSuccess ? EXIT_SUCCESS : EXIT_FAILURE);
}


BOOL
TestRefreshAssembly(
    PCWSTR wsAssemblyManifest
    )
{
    BOOL fSuccess = FALSE;
    SXS_INSTALLW Install = {sizeof(Install)};

    LoadSxs();

    Install.dwFlags = SXS_INSTALL_FLAG_REPLACE_EXISTING;
    Install.lpManifestPath = wsAssemblyManifest;

    if (!g_pfnSxsInstallW(&Install))
    {
        fwprintf(
            stderr,
            L"Failed reinstalling assembly '%ls', 0x%08X\n",
            wsAssemblyManifest,
            ::GetLastError());
    }
    else
    {
        fSuccess = TRUE;
    }

    return fSuccess;
}

BOOL
TestInstallWithInstallInfo(
    PCWSTR wsAssemblyManifest,
    PCWSTR wsReferenceString
    )
{
#define SXS_TEST

    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SXS_INSTALLW InstallParameters = {sizeof(InstallParameters)};
    SXS_INSTALL_REFERENCEW InstallReference = {sizeof(InstallReference)};

    LoadSxs();

    InstallParameters.dwFlags =
        SXS_INSTALL_FLAG_REPLACE_EXISTING |
        SXS_INSTALL_FLAG_CODEBASE_URL_VALID |
        SXS_INSTALL_FLAG_REFERENCE_VALID |
        SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID |
        SXS_INSTALL_FLAG_FROM_CABINET;

    //
    // if the manfiest file is a dll file, set SXS_INSTALL_FLAG_FROM_RESOURCE
    //
    {
        PWSTR p = wcsrchr(wsAssemblyManifest, L'.');
        if ((p) && ((wcscmp(p, L".dll")== 0) || (wcscmp(p, L".exe")== 0)))
            InstallParameters.dwFlags |= SXS_INSTALL_FLAG_FROM_RESOURCE;
    }

    InstallParameters.lpCodebaseURL = wsAssemblyManifest;
    InstallParameters.lpManifestPath = wsAssemblyManifest;
    InstallParameters.lpReference = &InstallReference;
    InstallParameters.lpRefreshPrompt = L"boop";

    InstallReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;
    InstallReference.lpIdentifier = wsReferenceString ? wsReferenceString : L"TempRef";

    if (!(*g_pfnSxsInstallW)(&InstallParameters))
    {
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

BOOL
TestInstallLikeWindowsSetup(
    PCWSTR wsAssemblyManifest,
    PCWSTR wsCodebase
    )
{
    BOOL fSuccess = FALSE;
    FN_TRACE_WIN32(fSuccess);
    SXS_INSTALLW InstallParameters = {sizeof(InstallParameters)};
    SXS_INSTALL_REFERENCEW InstallReference = {sizeof(InstallReference)};

    LoadSxs();

    IFW32FALSE_EXIT(
        (*g_pfnSxsBeginAssemblyInstall)(
            SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL
            | SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY
            | SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING,
            NULL,
            NULL,
            NULL,
            NULL,
            &InstallParameters.pvInstallCookie));

    InstallReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL;
    InstallReference.lpNonCanonicalData = L"Foom";
/*
    InstallParameters.dwFlags |= SXS_INSTALL_FLAG_CODEBASE_URL_VALID
                              |  SXS_INSTALL_FLAG_FROM_DIRECTORY
                              |  SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE
                              |  SXS_INSTALL_FLAG_FROM_CABINET
                              |  SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID
                              |  SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID
                              |  SXS_INSTALL_FLAG_REFERENCE_VALID
                           ;
*/

    //
    // First call - indicate that the given path may contain asmsN.cab
    //
    InstallParameters.lpCodebaseURL = wsCodebase;
    InstallParameters.lpRefreshPrompt = L"like..Windows CD..";
    InstallParameters.lpManifestPath = wsAssemblyManifest;
    InstallParameters.lpReference = &InstallReference;

    InstallParameters.dwFlags = SXS_INSTALL_FLAG_FROM_DIRECTORY |
        SXS_INSTALL_FLAG_REFERENCE_VALID |
        SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID |
        SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID |
        SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
        SXS_INSTALL_FLAG_FROM_CABINET |
        SXS_INSTALL_FLAG_CODEBASE_URL_VALID;

    IFW32FALSE_EXIT((*g_pfnSxsInstallW)(&InstallParameters));

    InstallParameters.dwFlags = SXS_INSTALL_FLAG_FROM_DIRECTORY |
        SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE |
        SXS_INSTALL_FLAG_REFERENCE_VALID |
        SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID |
        SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID |
        SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
        SXS_INSTALL_FLAG_CODEBASE_URL_VALID;

    IFW32FALSE_EXIT((*g_pfnSxsInstallW)(&InstallParameters));

    IFW32FALSE_EXIT(
        (*g_pfnSxsEndAssemblyInstall)(
            InstallParameters.pvInstallCookie,
            SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT,
            NULL));
    InstallParameters.pvInstallCookie = NULL;

    fSuccess = TRUE;
Exit:

    if (InstallParameters.pvInstallCookie != NULL)
    {
        CSxsPreserveLastError ple;
        (void) (*g_pfnSxsEndAssemblyInstall)(InstallParameters.pvInstallCookie, SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT, NULL);
        ple.Restore();
    }

    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

//#define ASM_CPUID { __asm __emit 0fh __asm __emit 0a2h }
#define ASM_CPUID { __asm cpuid }
#define ASM_RDTSC { __asm rdtsc }

inline VOID GetCpuIdLag(LARGE_INTEGER *ref)
{
#if !defined(_WIN64)
    LARGE_INTEGER temp, temp2;
    _asm
    {
        cpuid
        cpuid
        cpuid
        cpuid
        cpuid
        rdtsc
        mov temp.LowPart, eax
        mov temp.HighPart, edx
        cpuid
        rdtsc
        mov temp2.LowPart, eax
        mov temp2.HighPart, edx
    }

    ref->QuadPart = temp2.QuadPart - temp.QuadPart;
#else
    ref->QuadPart = 0;
#endif
}




BOOL
TestOpeningStuff(PCWSTR wsSourceName, PCWSTR wsType, PCWSTR wsCount)
{
    BOOL fSuccess = FALSE;
    LARGE_INTEGER llStartCount, llEndCount, llCountsPerSec, llTotalSizeSoFar;
    LARGE_INTEGER CpuIdLag;
    BYTE bBuffer[65536];
    SIZE_T cNumTries = _wtol(wsCount);
    double dCountsPerSecond, dSeconds, dCountsPerIteration, dSecondsPerIteration;
    int iFinalIterationsPerSecond;

    GetCpuIdLag(&CpuIdLag);

    llTotalSizeSoFar.QuadPart = 0;

    {
        FUSION_PERF_INFO PerfInfo[2];
        HANDLE hFile;

        for (int i = 0; i < 5000; i++)
        {
            PERFINFOTIME(&PerfInfo[0], hFile = ::CreateFileW(wsSourceName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL));
            PERFINFOTIME(&PerfInfo[1], ::CloseHandle(hFile));
        }

        FusionpReportPerfInfo(
            FUSIONPERF_DUMP_TO_STDOUT |
            FUSIONPERF_DUMP_ALL_STATISTICS |
            FUSIONPERF_DUMP_ALL_SOURCEINFO,
            PerfInfo,
            NUMBER_OF(PerfInfo));
    }



    //
    // Map the DLL as a resource a few thousand times.
    //
    if ((wsType[0] == L'd') || (wsType[0] == L's'))
    {
        FUSION_PERF_INFO PerfInfo[7];

        HMODULE     hDllModule;
        HRSRC       hManifestResource;
        HGLOBAL     hResource;
        PVOID       pvResourceData;
        SIZE_T      cbResourceSize;

        for (SIZE_T i = 0; i < cNumTries; i++)
        {
            PERFINFOTIME(&PerfInfo[0], hDllModule = ::LoadLibraryExW(wsSourceName, NULL, DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_AS_DATAFILE));
            PERFINFOTIME(&PerfInfo[1], hManifestResource = ::FindResourceW(hDllModule, L"#1", MAKEINTRESOURCEW(RT_MANIFEST)));
            PERFINFOTIME(&PerfInfo[2], hResource = ::LoadResource(hDllModule, hManifestResource));
            PERFINFOTIME(&PerfInfo[3], pvResourceData = ::LockResource(hResource));
            PERFINFOTIME(&PerfInfo[4], cbResourceSize = ::SizeofResource(hDllModule, hManifestResource));

            PERFINFOTIME(&PerfInfo[5],
                { for (SIZE_T i2 = 0; i2 < cbResourceSize; i2++)
                bBuffer[i2] = ((PBYTE)pvResourceData)[i2]; }
                );

            PERFINFOTIME(&PerfInfo[6], FreeLibrary(hDllModule))
        }

        FusionpReportPerfInfo(
            FUSIONPERF_DUMP_TO_STDOUT |
            FUSIONPERF_DUMP_ALL_STATISTICS |
            FUSIONPERF_DUMP_ALL_SOURCEINFO,
            PerfInfo,
            NUMBER_OF(PerfInfo));
    }
    else if (wsType[0] == L'x')
    {
        HANDLE  hFile;
        HANDLE  hFileMapping;
        PVOID   pvFileData;
        SIZE_T  cbFileSize;

        FUSION_PERF_INFO PerfInfo[9];

        for (SIZE_T i = 0; i < cNumTries; i++)
        {
            PERFINFOTIME(&PerfInfo[0], hFile = ::CreateFileW(wsSourceName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL));
            PERFINFOTIME(&PerfInfo[1], cbFileSize = ::GetFileSize(hFile, 0));
            PERFINFOTIME(&PerfInfo[2], hFileMapping = ::CreateFileMappingW(hFile, NULL, PAGE_READONLY, 0, 0, NULL));
            PERFINFOTIME(&PerfInfo[3], pvFileData = ::MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0));

            PERFINFOTIME(&PerfInfo[4], { for (SIZE_T i2 = 0; i2 < cbFileSize; i2++)
                PERFINFOTIME(&PerfInfo[8], bBuffer[i2] = ((PBYTE)pvFileData)[i2]); });

            PERFINFOTIME(&PerfInfo[5], ::UnmapViewOfFile(pvFileData));
            PERFINFOTIME(&PerfInfo[6], ::CloseHandle(hFileMapping));
            PERFINFOTIME(&PerfInfo[7], ::CloseHandle(hFile));
        }

        FusionpReportPerfInfo(
            FUSIONPERF_DUMP_TO_STDOUT |
            FUSIONPERF_DUMP_ALL_STATISTICS |
            FUSIONPERF_DUMP_ALL_SOURCEINFO,
            PerfInfo,
            NUMBER_OF(PerfInfo));
    }
    else if (wsType[0] == L'r')
    {
        BYTE bTempBlock[8192];
        ULONG cbReadCount;
        FUSION_PERF_INFO PerfInfo[3];

        for (SIZE_T i = 0; i < cNumTries; i++)
        {
            CResourceStream RStream;

            QueryPerformanceCounter(&llStartCount);

            PERFINFOTIME(&PerfInfo[0], RStream.Initialize(wsSourceName, MAKEINTRESOURCEW(RT_MANIFEST)));
            PERFINFOTIME(&PerfInfo[1], RStream.Read(bTempBlock, sizeof(bTempBlock), &cbReadCount));

            PERFINFOTIME(&PerfInfo[2],
                for (SIZE_T i2 = 0; i2 < cbReadCount; i2++)
                {
                    bBuffer[i2] = bTempBlock[i2];
                }
                );

            wprintf(L"%s", bBuffer);

            QueryPerformanceCounter(&llEndCount);
            llTotalSizeSoFar.QuadPart += llEndCount.QuadPart - llStartCount.QuadPart;
        }

        for (int i = 0; i < NUMBER_OF(PerfInfo); i++)
        {
            FusionpDumpPerfInfo(FUSIONPERF_DUMP_TO_STDOUT, PerfInfo + i);
        }
    }
    else if (wsType[0] == L'f')
    {
        BYTE bTempBlock[8192];
        ULONG cbReadCount;

        for (SIZE_T i = 0; i < cNumTries; i++)
        {
            CFileStream RStream;

            QueryPerformanceCounter(&llStartCount);

            RStream.OpenForRead(
                wsSourceName,
                CImpersonationData(),
                FILE_SHARE_READ,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN);

            RStream.Read(bTempBlock, sizeof(bTempBlock), &cbReadCount);

            for (SIZE_T i2 = 0; i2 < cbReadCount; i2++)
            {
                bBuffer[i2] = bTempBlock[i2];
            }

            QueryPerformanceCounter(&llEndCount);
            llTotalSizeSoFar.QuadPart += llEndCount.QuadPart - llStartCount.QuadPart;
        }
    }

    QueryPerformanceFrequency(&llCountsPerSec);

    dCountsPerIteration = (double)llTotalSizeSoFar.QuadPart / cNumTries;
    dCountsPerSecond = (double)llCountsPerSec.QuadPart;
    dSeconds = (double)llTotalSizeSoFar.QuadPart / dCountsPerSecond;
    dSecondsPerIteration = dCountsPerIteration / dCountsPerSecond;

    iFinalIterationsPerSecond = static_cast<int>(1.0 / dSecondsPerIteration);

    fwprintf(
        stdout,
        L"Completed %d runs: %d attempts per second available\n",
        cNumTries,
        iFinalIterationsPerSecond);

    fSuccess = TRUE;

    return fSuccess;
}


BOOL
TestVerifyFileSignature(PCWSTR wsFilename)
{
    WINTRUST_FILE_INFO  fInfo;
    WINTRUST_DATA       wtData;
    GUID                guidTrustType = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    HRESULT             hResult = E_FAIL;
    PWSTR               pwszMessageText = NULL;

    ZeroMemory(&wtData, sizeof(wtData));
    ZeroMemory(&fInfo, sizeof(fInfo));

    fInfo.cbStruct = sizeof(fInfo);
    fInfo.pcwszFilePath = wsFilename;
    fInfo.hFile = NULL;

    wtData.cbStruct = sizeof(wtData);
    wtData.dwUIChoice = WTD_UI_ALL;
    wtData.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
    wtData.dwUnionChoice = WTD_CHOICE_FILE;
    wtData.pFile = &fInfo;

    hResult = WinVerifyTrust(0, &guidTrustType, &wtData);

    if (FAILED(hResult))
    {
        ::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL,
            hResult,
            0,
            (PWSTR)&pwszMessageText,
            500,
            NULL);

        fwprintf(stdout, L"Error: %ls (code 0x%08x)\n", pwszMessageText, hResult);
        LocalFree(pwszMessageText);
    }
    else
    {
        fwprintf(stdout, L"File signature(s) are valid.");
    }

    return TRUE;
}

BOOL TestMessagePerf(int argc, wchar_t **argv, int *piNext)
{
    ATOM a;
    WNDCLASSEXW wc;
    ULONGLONG cc1, cc2, cc3, cc4;
    ULONG i, t;
    HWND hwnd;
    MSG m;
    ULONG mcount;
    HANDLE hActCtx = NULL;
    ULONG_PTR ulCookie;

    wc.cbSize = sizeof(wc);
    wc.style = 0;
    wc.lpfnWndProc = &TestMessagePerfWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = NULL;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = L"SxsMsgPerfTest";
    wc.hIconSm = NULL;

    printf("Beginning message perf test...\n");

    a = ::RegisterClassExW(&wc);
    if (a == NULL)
    {
        printf("RegisterClassExW() failed; ::GetLastError = %d\n", ::GetLastError());
        return FALSE;
    }

    if (argv[*piNext][0] != L'*')
    {
        ACTCTXW ac;

        ac.cbSize = sizeof(ac);
        ac.dwFlags = 0;
        ac.lpSource = argv[*piNext];
        hActCtx = ::CreateActCtxW(&ac);
        if (hActCtx == INVALID_HANDLE_VALUE)
        {
            printf("CreateActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());
            goto ErrorExit;
        }
    }

    if (!ActivateActCtx(hActCtx, &ulCookie))
    {
        printf("ActivateActCtx() failed; ::GetLastError() = %d\n", ::GetLastError());
        goto ErrorExit;
    }

    (*piNext)++;

    hwnd = ::CreateWindowW(
        (LPCWSTR) a,
        L"PerfTestWindow",
        WS_VISIBLE,
        0, // x
        0, // y
        100, // width
        100, // height
        NULL, // hwndParent
        NULL, // hMenu
        NULL, // hInstance
        NULL); // lpParam
    if (hwnd == NULL)
        return FALSE;

    t = _wtoi(argv[*piNext]);
    (*piNext)++;

    mcount = 0;
    cc3 = 0;
    cc4 = 0;

    for (i=0; i<t; i++)
    {
        if (!PostMessageW(hwnd, WM_USER, 0, 0))
        {
            printf("PostMessageW() failed; ::GetLastError() = %d\n", ::GetLastError());
            goto ErrorExit;
        }

        cc1 = GetCycleCount();

        while (::PeekMessage(&m, hwnd, 0, 0, PM_REMOVE))
        {
            mcount++;
            ::TranslateMessage(&m);
            ::DispatchMessage(&m);
        }

        cc2 = GetCycleCount();

        // accumulate the time spend just processing the message...
        cc3 = cc3 + (cc2 - cc1);
    }

    printf("%lu messages in %I64u cycles\n", mcount, cc3);
    printf("   avg cycles/msg: %I64u\n", static_cast<ULONGLONG>((cc3 / static_cast<ULONGLONG>(mcount))));

    return TRUE;

ErrorExit:
    return FALSE;
}

LRESULT CALLBACK TestMessagePerfWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void
TestTrickyMultipleAssemblyCacheItems(PCWSTR pvManifest)
{
    CSmartRef<IAssemblyCache>       AssemblyCache;
    CSmartRef<IAssemblyCacheItem>   AssemblyCacheItems[2];
    CStringBuffer                   sbManifestName;
    HRESULT                         hr;

    LoadSxs();

    sbManifestName.Win32Assign(pvManifest, wcslen(pvManifest));

    for (int i = 0; i < 2; i++)
    {
        CSmartRef<IStream> pStream;
        CSmartRef<IAssemblyCacheItem> AssemblyItemTemp;
        CStringBuffer TempStreamName;

        hr = (*g_pfnCreateAssemblyCacheItem)(
            &AssemblyItemTemp,
            NULL,
            NULL,
            NULL,
            0,
            0);

        //
        // Manifest
        //
        hr = AssemblyItemTemp->CreateStream(0, pvManifest, STREAM_FORMAT_WIN32_MANIFEST, 0, &pStream, NULL);
        TempStreamName.Win32Assign(sbManifestName);
        hr = Helper_WriteStream(&TempStreamName, pStream);
        pStream.Release();

        //
        // Dll
        //
        sbManifestName.Win32ChangePathExtension(L".dll", 4, eAddIfNoExtension);
        hr = AssemblyItemTemp->CreateStream(0, static_cast<PCWSTR>(TempStreamName), STREAM_FORMAT_WIN32_MODULE, 0, &pStream, NULL);
        hr = Helper_WriteStream(&TempStreamName, pStream);
        pStream.Release();

        hr = AssemblyItemTemp->Commit(0, NULL);
        AssemblyCacheItems[i] = AssemblyItemTemp;
    }
    /*
    hr = g_pfnCreateAssemblyCache(&AssemblyCache, 0);
    hr = AssemblyCache->MarkAssembliesVisible((IUnknown**)AssemblyCacheItems, 2, 0);
    */
}


void
TestSfcScanKickoff()
{
    BOOL fSuccess = FALSE;

    LoadSxs();
    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_SFC_SCANNER, 0, NULL, NULL);
}


void
GenerateStrongNameAndPublicKey(PCWSTR wsCertificate)
{
    BOOL                    bSuccess = FALSE;

    CStringBuffer           sbStrings[3];
    PCCERT_CONTEXT          pContext = NULL;
    HCERTSTORE              hCertStore = NULL;

    hCertStore = CertOpenStore(
        CERT_STORE_PROV_FILENAME,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        NULL,
        CERT_STORE_OPEN_EXISTING_FLAG,
        (void*)wsCertificate);

    LoadSxs();

    while (pContext = CertEnumCertificatesInStore(hCertStore, pContext))
    {
        bSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_GET_STRONGNAME, 0, (PCWSTR)pContext, (PVOID)sbStrings);

        wprintf(L"Signer display name: %ls\n\tPublic Key: %ls\n\tPublic Key Token: %ls\n",
            static_cast<PCWSTR>(sbStrings[0]),
            static_cast<PCWSTR>(sbStrings[1]),
            static_cast<PCWSTR>(sbStrings[2]));

    }

    bSuccess = TRUE;

    if (pContext)     CertFreeCertificateContext(pContext);
    if (hCertStore)   CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
}

BOOL CALLBACK
DumpResourceWorker(
    HMODULE hModule,
    PCWSTR lpszType,
    PWSTR lpszName,
    LONG_PTR lParam
    )
{
    HGLOBAL hGlobal;
    HRSRC hResource;
    PVOID pvData;
    SIZE_T cbResource;

    hResource = ::FindResourceW(hModule, lpszName, lpszType);
    hGlobal = ::LoadResource(hModule, hResource);
    pvData = ::LockResource(hGlobal);

    if (lpszName < (PCWSTR)0xFFFF)
    {
        wprintf(L"----\nResource id: %p\n", lpszName);
    }
    else
    {
        wprintf(L"----\nResource name: %ls\n", lpszName);
    }

    cbResource = ::SizeofResource(hModule, hResource);

    for (SIZE_T i = 0; i < cbResource; i++)
    {
        wprintf(L"%c", ((char*)pvData)[i]);
    }
    wprintf(L"\n");


    return TRUE;
}

BOOL
TestDumpContainedManifests(PCWSTR wsFilename)
{
    HMODULE hThing;

    hThing = ::LoadLibraryExW(wsFilename, NULL, LOAD_LIBRARY_AS_DATAFILE);

    if ((hThing == NULL) || (hThing == INVALID_HANDLE_VALUE))
    {
        wprintf(L"Bad mojo: can't open %ls for enumeration.\n", wsFilename);
        return FALSE;
    }

    if (!::EnumResourceNamesW(hThing, MAKEINTRESOURCEW(RT_MANIFEST), DumpResourceWorker, NULL))
    {
        if (GetLastError() == ERROR_RESOURCE_TYPE_NOT_FOUND)
        {
            wprintf(L"No manifests found in %ls\n", wsFilename);
        }
        else
        {
            wprintf(L"Bad mojo: can't enumerate resources from %ls, error=0x%08x\n",
                wsFilename,
                ::GetLastError());
        }
    }
    ::FreeLibrary(hThing);

    return TRUE;
}

BOOL TestGenerateStringWithIdenticalHash(WCHAR iString[33])
{
#define START_VALUE         1
#define STR_LEN             32
#define HASH_SEED           65599
#define MAGIC_ARRAY         {1, 1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1,-1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1, -1, 1, 1} ;

#define UPPER(ch)     if (ch >=L'a' && ch <= L'z') ch = ch- L'a' + L'A';

    WCHAR oString[STR_LEN + 1];
    DWORD i, nLen, a[STR_LEN];
    ULONG hash1, hash2;
    WCHAR ch;

    a[0] = a[1] = START_VALUE;
    nLen = 2;
    while(nLen < STR_LEN) {
            for(i = nLen; i < nLen*2; i++)
                    a[i] = static_cast<ULONG>(-static_cast<LONG>(a[i-nLen]));
            nLen *= 2;
    }

    oString[32] = iString[32] = L'\0';

    // generate the new string
    for (i = 0; i< 32; i++)
        oString[i] = static_cast<WCHAR>(iString[i] + a[i]);

    // verify that these two string have the same hash
    hash1 = 0 ;
    for (i = 0 ; i<STR_LEN; i++) {
        ch = iString[i];
        UPPER(ch);
        hash1 = hash1*HASH_SEED + ch;
    }

    hash2 = 0 ;
    for (i = 0 ; i<STR_LEN; i++){
        ch = oString[i];
        UPPER(ch);
        hash2 = hash2*HASH_SEED + ch;
    }

    return (hash1 == hash2)? TRUE : FALSE;

#undef START_VALUE
#undef STR_LEN
#undef HASH_SEED
}

BOOL TestAssemblyIdentityHash()
{
    BOOL fSuccess = FALSE;
    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_ASSEMBLY_IDENTITY_HASH, 0, 0, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

const static WCHAR Beta2Manifest[] =
L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
L"    <assemblyIdentity type=\"win32\" name=\"cards\" version=\"2.0.0.0\" processorArchitecture=\"X86\" language=\"en-us\" />"
L"    <file name=\"cards.dll\"/>"
L"</assembly>;"
;

// check whether the handle counter of csrss has changed dramatically after running this code.....
VOID TestCreateActctxLeakHandles(DWORD dwCallCounter)
{
    int result = -1;
    BOOL fSuccess = FALSE;

    for (DWORD i =0 ; i < dwCallCounter ; i ++)
    {
        HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(InheritManifest);
        if (ActivationContextHandle  == INVALID_HANDLE_VALUE) {
            result = i ;
            break;
        }

        ULONG_PTR Cookie;
        ActivateActCtx(ActivationContextHandle, &Cookie);

        HINSTANCE hInstanceKernel32 = ::GetModuleHandleW(L"KERNEL32.DLL");
        PQUERYACTCTXW_FUNC pQueryActCtxW = (PQUERYACTCTXW_FUNC) ::GetProcAddress(hInstanceKernel32, "QueryActCtxW");

        SIZE_T CbWritten;

        if (pQueryActCtxW != NULL)
        {
            for ( ULONG ulInfoClass = ActivationContextBasicInformation; ulInfoClass <= FileInformationInAssemblyOfAssemblyInActivationContext; ulInfoClass ++)
            {
                switch (ulInfoClass) {
                case ActivationContextBasicInformation :
                    break;

                case ActivationContextDetailedInformation :
                    {
                    struct
                    {
                        ACTIVATION_CONTEXT_DETAILED_INFORMATION acdi;
                        WCHAR Buffer[_MAX_PATH * 3]; // manifest, policy and appdir
                    } Data;
                    ULONG index = 0 ;
                    fSuccess = (*pQueryActCtxW)(0, ActivationContextHandle, &index, ulInfoClass, &Data, sizeof(Data), &CbWritten);
                    fprintf(stderr, "\ncall QueryActCtxW with ActivationContextDetailedInformation\n" );
                    if (fSuccess)
                    {
                        fprintf(stderr, "1st string: %ls\n", Data.acdi.lpAppDirPath);
                        fprintf(stderr, "2nd string: %ls\n", Data.acdi.lpRootManifestPath);
                    }
                    else
                        fprintf(stderr, "QueryActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());

                    }

                    break;

                case AssemblyDetailedInformationInActivationContext:
                    {
                    struct
                    {
                        ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION acdi;
                        WCHAR Buffer[_MAX_PATH * 4];
                    } Data;
                    ULONG AssemblyIndex = 1;
                    fSuccess = (*pQueryActCtxW)(0, ActivationContextHandle, &AssemblyIndex, ulInfoClass, &Data, sizeof(Data), &CbWritten);

                    fprintf(stderr, "\ncall QueryActCtxW with AssemblyDetailedInformationInActivationContext\n" );
                    if (fSuccess)
                    {
                        fprintf(stderr, "Encoded assembly Identity: %ls\n", Data.acdi.lpAssemblyEncodedAssemblyIdentity);
                        fprintf(stderr, "manifest path: %ls\n", Data.acdi.lpAssemblyManifestPath);
                        fprintf(stderr, "policy path: %ls\n", Data.acdi.lpAssemblyPolicyPath);
                        fprintf(stderr, "Assembly Directory: %ls\n", Data.acdi.lpAssemblyDirectoryName);
                    }
                    else
                        fprintf(stderr, "QueryActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());
                    }
                    break;

                case FileInformationInAssemblyOfAssemblyInActivationContext:
                    {
                    struct
                    {
                        ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION acdi;
                        WCHAR Buffer[_MAX_PATH * 2];
                    } Data;
                    ACTIVATION_CONTEXT_QUERY_INDEX index;
                    index.ulAssemblyIndex = 1;
                    index.ulFileIndexInAssembly = 0;

                    fSuccess = (*pQueryActCtxW)(0, ActivationContextHandle, &index, ulInfoClass, &Data, sizeof(Data), &CbWritten);

                    fprintf(stderr, "\ncall QueryActCtxW with FileInformationInAssemblyOfAssemblyInActivationContext\n" );
                    if (fSuccess)
                    {
                        fprintf(stderr, "file name: %ls\n", Data.acdi.lpFileName);
                        fprintf(stderr, "file path: %ls\n", Data.acdi.lpFilePath);
                    }
                    else
                        fprintf(stderr, "QueryActCtxW() failed; ::GetLastError() = %d\n", ::GetLastError());
                    }
                } // end of switch

            }// end of for
        }

        DeactivateActCtx(0, Cookie);
        // CloseHandle(ActivationContextHandle);
    }
    return;
}

BOOL TestSystemDefaultActivationContextGeneration()
{
    BOOL fSuccess = FALSE;

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_SYSTEM_DEFAULT_ACTCTX_GENERATION, 0, NULL, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

CHAR g_AsyncIOBuffer[16384];

struct AsyncIOBlock
{
    OVERLAPPED ol_input;
    OVERLAPPED ol_output;
    HANDLE hInputFile;
    HANDLE hOutputFile;
} g_AsyncIOBlock;

bool g_AsyncIODone = false;
DWORD g_AsyncIOError = ERROR_SUCCESS;

VOID CALLBACK AsyncReadCompleted(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED ol
    );

VOID CALLBACK AsyncWriteCompleted(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED ol
    );

VOID CALLBACK AsyncReadCompleted(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED ol
    )
{
    if (dwErrorCode != ERROR_SUCCESS)
    {
        fprintf(stderr, "Error passed to AsyncReadCompleted(); error code = %ul; bytes transferred = %ul\n", dwErrorCode, dwBytesTransferred);
        g_AsyncIOError = dwErrorCode;
        g_AsyncIODone = true;
    }
    else
    {
        g_AsyncIOBlock.ol_input.Offset += dwBytesTransferred;
        if (!::WriteFileEx(g_AsyncIOBlock.hOutputFile, g_AsyncIOBuffer, dwBytesTransferred, &g_AsyncIOBlock.ol_output, &AsyncWriteCompleted))
        {
            g_AsyncIOError = ::GetLastError();
            fprintf(stderr, "WriteFileEx() failed; ::GetLastError() = %d\n", g_AsyncIOError);
            g_AsyncIODone = true;
        }
    }
}

VOID CALLBACK AsyncWriteCompleted(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED ol
    )
{
    if (dwErrorCode != ERROR_SUCCESS)
    {
        fprintf(stderr, "Error passed to AsyncWriteCompleted(); error code = %ul; dwBytesTransferred = %ul\n", dwErrorCode, dwBytesTransferred);
        g_AsyncIOError = dwErrorCode;
        g_AsyncIODone = true;
    }
    else
    {
        g_AsyncIOBlock.ol_output.Offset += dwBytesTransferred;
        if (!::ReadFileEx(g_AsyncIOBlock.hInputFile, g_AsyncIOBuffer, sizeof(g_AsyncIOBuffer), &g_AsyncIOBlock.ol_input, &AsyncReadCompleted))
        {
            g_AsyncIOError = ::GetLastError();
            if (g_AsyncIOError != ERROR_HANDLE_EOF)
                fprintf(stderr, "ReadFileEx() failed; ::GetLastError() = %d\n", g_AsyncIOError);
            else
                g_AsyncIOError = ERROR_SUCCESS;
            g_AsyncIODone = true;
        }
    }
}

BOOL
TestAsyncIO(int argc, wchar_t **argv, int *piNext)
{
    HANDLE hFileIn;
    HANDLE hFileOut;
    HANDLE hActCtx = NULL;
    ULONG_PTR cookie = 0;
    PCWSTR pszManifest;
    PCWSTR pszInputFile;
    PCWSTR pszOutputFile;
    ACTCTXW acw;

    pszManifest = argv[(*piNext)++];
    pszInputFile = argv[(*piNext)++];
    pszOutputFile = argv[(*piNext)++];

    if (wcscmp(pszManifest, L"-") != 0)
    {
        acw.cbSize = sizeof(acw);
        acw.dwFlags = 0;
        acw.lpSource = pszManifest;

        hActCtx = ::CreateActCtxW(&acw);
        if (hActCtx == INVALID_HANDLE_VALUE)
        {
            fprintf(stderr, "CreateActCtxW() on %ls failed; ::GetLastError() = %d\n", pszManifest, ::GetLastError());
            return EXIT_FAILURE;
        }
    }

    hFileIn = ::CreateFileW(pszInputFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFileIn == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "CreateFileW() on %ls failed; ::GetLastError() = %d\n", pszInputFile, ::GetLastError());
        return EXIT_FAILURE;
    }

    hFileOut = ::CreateFileW(pszOutputFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, NULL);
    if (hFileOut == INVALID_HANDLE_VALUE)
    {
        fprintf(stderr, "CreateFileW() on %ls failed; ::GetLastError() = %d\n", pszOutputFile, ::GetLastError());
        return EXIT_FAILURE;
    }

    ActivateActCtx(hActCtx, &cookie);

    g_AsyncIOBlock.ol_input.Offset = 0;
    g_AsyncIOBlock.ol_input.OffsetHigh = 0;
    g_AsyncIOBlock.ol_output.Offset = 0;
    g_AsyncIOBlock.ol_output.OffsetHigh = 0;
    g_AsyncIOBlock.hInputFile = hFileIn;
    g_AsyncIOBlock.hOutputFile = hFileOut;

    if (!::ReadFileEx(hFileIn, &g_AsyncIOBuffer, sizeof(g_AsyncIOBuffer), &g_AsyncIOBlock.ol_input, &AsyncReadCompleted))
    {
        fprintf(stderr, "First ReadFileEx() failed; ::GetLastError() = %d\n", ::GetLastError());
        return EXIT_FAILURE;
    }

    while (!g_AsyncIODone)
    {
        ::SleepEx(1000, TRUE);
    }

    if (g_AsyncIOError != ERROR_SUCCESS)
    {
        fprintf(stderr, "Async IO test failed; win32 error code = %d\n", g_AsyncIOError);
        return EXIT_FAILURE;
    }

    CloseHandle(hFileIn);
    CloseHandle(hFileOut);

    return EXIT_SUCCESS;
}

DWORD
WINAPI
TestThreadInheritLeakThreadProc(
    LPVOID lpParameter
    )
{
    // Don't need to do anything...
    return 1;
}

int
TestThreadInheritLeak()
{
    HANDLE ActivationContextHandle = ::CreateActivationContextFromStringW(InheritManifest);
    DWORD dwThreadId;
    ULONG_PTR ulpCookie;
    HANDLE hThread = NULL;

    ::ActivateActCtx(ActivationContextHandle, &ulpCookie);
    hThread = ::CreateThread(NULL, 0, &TestThreadInheritLeakThreadProc, NULL, 0, &dwThreadId);

    if (hThread == NULL)
    {
        fprintf(stderr, "CreateThread() failed with ::GetLastError = %d\n", ::GetLastError());
        return EXIT_FAILURE;
    }

    WaitForSingleObject(hThread, INFINITE);

    fprintf(stderr, "Created thread %lu\n", dwThreadId);
    ::DeactivateActCtx(0, ulpCookie);
    ::ReleaseActCtx(ActivationContextHandle);

    return EXIT_SUCCESS;
}

BOOL
TestNewCatalogSignerThingy(
    PCWSTR CatalogName
    )
{
    BOOL fSuccess = FALSE;

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_CATALOG_SIGNER_CHECK, 0, CatalogName, NULL);

    return fSuccess;
}

HMODULE MyHandle;
WCHAR MyModuleFullPath[MAX_PATH];
WCHAR MyModuleFullPathWithoutExtension[MAX_PATH];

/*
see \\scratch\scratch\JayK\exedll for a slightly different approach
*/
HANDLE GetExeHandle()
{
    return GetModuleHandleW(NULL);
}

extern "C" { extern IMAGE_DOS_HEADER __ImageBase; }

HMODULE GetMyHandle()
{
    //Trace("GetMyHandle():%p\n", &__ImageBase);
    return (HMODULE)&__ImageBase;
}

BOOL AmITheExe()
{
    IamExe = (GetExeHandle() == GetMyHandle());
    IamDll = !IamExe;
    return IamExe;
}

PCWSTR GetMyModuleFullPath()
{
    return
        ((MyModuleFullPath[0]
        || ::GetModuleFileNameW(GetMyHandle(), MyModuleFullPath, RTL_NUMBER_OF(MyModuleFullPath))),
        MyModuleFullPath);
}

PCWSTR GetMyModuleFullPathWithoutExtension()
{
    //
    // not thread safe
    //
    wcscpy(MyModuleFullPathWithoutExtension, GetMyModuleFullPath());
    *wcsrchr(MyModuleFullPathWithoutExtension, '.') = 0;
    return MyModuleFullPathWithoutExtension;
}

void TestExeDll()
{
#if defined(_X86_)
    WCHAR x[MAX_PATH];
    CStringBuffer y;

    Kernel32.GetModuleFileNameW(NULL, x, RTL_NUMBER_OF(x));
    if (!y.Win32Assign(x, StringLength(x)))
        ThrowLastError();

    if (!y.Win32ChangePathExtension(L"dll", 3, eAddIfNoExtension))
        ThrowLastError();

    if (!CopyFileW(x, y, FALSE))
        ThrowLastError();

    SetDllBitInPeImage(y);

    FreeLibrary(LoadLibraryW(y));
#endif
}

void PrintDll()
{
    //Trace("dll %ls\n", GetMyModuleFullPath());
}

void PrintExe()
{
    //Trace("exe %ls\n", GetMyModuleFullPath());
}

extern "C" void __cdecl wmainCRTStartup();
extern "C" BOOL __stdcall _DllMainCRTStartup(HINSTANCE, DWORD, PVOID);

extern "C" BOOL __stdcall DllMain(HINSTANCE DllHandle, DWORD Reason, PVOID SemiReserved)
{
    //Trace("Enter DllMain\n");
    switch (Reason)
    {
    default:
        break;
    case DLL_PROCESS_ATTACH:
        if (
               wcsstr(GetCommandLineW(), L" -tQueryActCtx")
            || wcsstr(GetCommandLineW(), L" -tqueryactctx")
            || wcsstr(GetCommandLineW(), L" /tQueryActCtx")
            || wcsstr(GetCommandLineW(), L" /tqueryactctx")
            )
        {
            TestQueryActCtx();
        }
    }
    //Trace("Exit DllMain\n");
    return TRUE;
}

#if defined(_X86_)

extern "C" void __declspec(naked) Entry()
// This works for .dlls or .exes.
// void ExeMain(void)
// BOOL __stdcall DllMain(HINSTANCE dll, DWORD reason, void* reserved)
{
    static const char* DllReason[] =
    {
        "DllProcessDetach %ls\n",
        "DllProcessAttach %ls\n",
        "DllThreadAttach  %ls\n",
        "DllThreadDetach  %ls\n"
    };
    __asm {
    //int 3
    call AmITheExe
    test eax,eax
    jne  Lexe
//Ldll:
    call GetMyModuleFullPath
    push eax
    mov eax, [esp+12]
    mov eax, DllReason[eax*4]
    push eax
    call Trace
    add esp,8
    jmp _DllMainCRTStartup
Lexe:
    call PrintExe
    jmp  wmainCRTStartup
}
}

#else

extern "C" void Entry()
{
    wmainCRTStartup();
}

#endif


BOOL TestSxsSfcUI()
{
    BOOL fSuccess = FALSE;
    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_SFC_UI_TEST, 0, 0, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;

    return fSuccess;
}

void TestGetModuleHandleEx()
{
#if 0
    HMODULE p;
    BOOL  f;
    HMODULE q;
    unsigned u;
#define GetModuleHandleExA pfnGetModuleHandleExA
#define GetModuleHandleExW pfnGetModuleHandleExW
    HMODULE kernel32 = GetModuleHandleW(L"Kernel32");
    PGET_MODULE_HANDLE_EXA GetModuleHandleExA = reinterpret_cast<PGET_MODULE_HANDLE_EXA>(GetProcAddress(kernel32, "GetModuleHandleExA"));
    PGET_MODULE_HANDLE_EXW GetModuleHandleExW = reinterpret_cast<PGET_MODULE_HANDLE_EXW>(GetProcAddress(kernel32, "GetModuleHandleExW"));

    if (GetModuleHandleExA == NULL || GetModuleHandleExW == NULL)
    {
        return;
    }

    union
    {
         CHAR BufferA[MAX_PATH];
        WCHAR BufferW[MAX_PATH];
    };
    BufferA[0] = 0;
    GetWindowsDirectoryA(BufferA, MAX_PATH);
    std::string windowsA = BufferA;
    std::string systemA = windowsA + "System32";

    BufferW[0] = 0;
    GetWindowsDirectoryW(BufferW, MAX_PATH);
    std::wstring windowsW = BufferW;
    std::wstring systemW = windowsW + L"System32";

#define PIN GET_MODULE_HANDLE_EX_FLAG_PIN
#define NOCHANGE GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
#define ADDRESS GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS

#define X(x) SetLastError(NO_ERROR); p = x; printf("%s:%p,%d\n", #x, p, ::GetLastError());
#define Y(x) SetLastError(NO_ERROR); f = x; printf("%s:%s,%p,%d\n", #x, "false\0true"+f*6, p, ::GetLastError());
    printf("first some basic GetModuleHandle testing\n\n");
    X(GetModuleHandleA(NULL));
    X(GetModuleHandleW(NULL));
    X(GetModuleHandleA("ntdll.dll"));
    X(GetModuleHandleW(L"ntdll.dll"));
    X(GetModuleHandleA("ntdll"));
    X(GetModuleHandleW(L"ntdll"));
    X(GetModuleHandleA("c:\\ntdll"));
    X(GetModuleHandleW(L"c:\\ntdll"));
    X(GetModuleHandleA((systemA + "\\ntdll").c_str()));
    X(GetModuleHandleW((systemW + L"\\ntdll").c_str()));
    X(GetModuleHandleA((systemA + "\\ntdll.dll").c_str()));
    X(GetModuleHandleW((systemW + L"\\ntdll.dll").c_str()));
    X(GetModuleHandleA("sxs"));
    X(GetModuleHandleW(L"sxs.dll"));

    printf("\n\nnow show that FreeLibrary \"works\", GetModuleHandle honors it\n\n");
    X(LoadLibraryA("Sxs.dll"));
    X(GetModuleHandleA("sxs"));
    X(GetModuleHandleW(L"sxs.dll"));
    Y(FreeLibrary(p = GetModuleHandleA("Sxs.dll")));
    X(GetModuleHandleA("sxs"));
    X(GetModuleHandleW(L"sxs.dll"));
    X(LoadLibraryW(L"Sxs.dll"));
    Y(GetModuleHandleExA(0, NULL, &p));
    Y(GetModuleHandleExW(0, NULL, &p));

    printf("\n\nsome invalid parameters (%d)\n\n", ERROR_INVALID_PARAMETER);

    Y(GetModuleHandleExA(PIN | NOCHANGE, "sxs", &p));
    Y(GetModuleHandleExW(PIN | NOCHANGE, L"sxs", &p));
    Y(GetModuleHandleExA(PIN | NOCHANGE, "ntdll", &p));
    Y(GetModuleHandleExW(PIN | NOCHANGE, L"ntdll", &p));

    printf("\n\nshow NOCHANGE's equiv to regular\n\n");

    Y(GetModuleHandleExA(NOCHANGE, "sxs", &p));
    Y(GetModuleHandleExW(NOCHANGE, L"sxs", &p));
    Y(FreeLibrary(p = GetModuleHandleA("Sxs.dll")));
    Y(GetModuleHandleExA(NOCHANGE, "sxs", &p));
    Y(GetModuleHandleExW(NOCHANGE, L"sxs", &p));

    printf("\n\nshow PIN works\n\n");

    X(LoadLibraryW(L"Sxs.dll"));
    Y(GetModuleHandleExA(PIN, "sxs", &p));
    Y(FreeLibrary(p = GetModuleHandleA("Sxs.dll")));
    Y(GetModuleHandleExW(0, L"sxs", &(q = p)));
    Y(GetModuleHandleExW(0, L"c:\\sxs", &p));

    printf("\n\nshow the VirtualQuery form\n\n");

    Y(GetModuleHandleExA(ADDRESS, "sxs", &p)); // string, actually in .exe
    Y(GetModuleHandleExW(ADDRESS, L"c:\\sxs", &p));

    Y(GetModuleHandleExA(ADDRESS, reinterpret_cast<LPCSTR>(q), &p));
    Y(GetModuleHandleExW(ADDRESS, reinterpret_cast<LPCWSTR>(q), &p));

    printf("\n\nsome more invalid parameters (%d)\n\n", ERROR_INVALID_PARAMETER);

    Y(GetModuleHandleExA(0, NULL, NULL));
    Y(GetModuleHandleExW(0, NULL, NULL));

    printf("\n\nshow that static loads can't be unloaded\n\n");
    for (u = 0 ; u < 4 ; ++u)
    {
        printf("%#x\n", u);
        Y(FreeLibrary(p = GetModuleHandleA("kernel32")));
        Y(FreeLibrary(p = GetModuleHandleW(L"sxstest.exe")));
        Y(FreeLibrary(p = GetModuleHandleA("msvcrt.dll")));
    }

    printf("\n\ntry all flag combinations, including invalids ones\n\n");
    for (u = 0 ; u <= (PIN | ADDRESS | NOCHANGE) ; ++u)
    {
        printf("%#x\n", u);
        p = NULL;
        Y(  GetModuleHandleExA(u, NULL, NULL)); p = NULL;
        Y(  GetModuleHandleExW(u, NULL, NULL)); p = NULL;
        Y(  GetModuleHandleExA(u, NULL, &p)); p = NULL;
        Y(  GetModuleHandleExW(u, NULL, &p)); p = NULL;
        if (u & ADDRESS)
        {
            Y(  GetModuleHandleExA(u, "", NULL)); p = NULL;
            Y(  GetModuleHandleExW(u, reinterpret_cast<LPCWSTR>(GetModuleHandleExA), NULL)); p = NULL;
            Y(  GetModuleHandleExW(u, reinterpret_cast<LPCWSTR>(atexit), NULL)); p = NULL;

            Y(  GetModuleHandleExA(u, "", &p)); p = NULL;
            Y(  GetModuleHandleExW(u, reinterpret_cast<LPCWSTR>(GetModuleHandleExA), &p)); p = NULL;
            Y(  GetModuleHandleExW(u, reinterpret_cast<LPCWSTR>(atexit), &p)); p = NULL;
        }
        else
        {
            Y( GetModuleHandleExA(u, "foo32", NULL)); p = NULL;
            Y( GetModuleHandleExW(u, L"kernel32", NULL)); p = NULL;

            Y( GetModuleHandleExA(u, "foo32", &p)); p = NULL;
            Y( GetModuleHandleExW(u, L"kernel32", &p)); p = NULL;
        }
    }
    printf("\n\ntry all bits of flags, should be mostly invalid (%d)\n\n", ERROR_INVALID_PARAMETER);
    for (u = 0 ; u < RTL_BITS_OF(u) ; ++u)
    {
        printf("%#x\n", u);
        Y(GetModuleHandleExW(1<<u, L"kernel32", &p));
    }

    printf("\n\nPIN | ADDRESS wasn't covered\n\n", ERROR_INVALID_PARAMETER);

    X(GetModuleHandleW(L"shell32"));
    X(q = LoadLibraryA("shell32"));
    Y(FreeLibrary(GetModuleHandleA("shell32")));
    Y(GetModuleHandleExW(PIN | ADDRESS, reinterpret_cast<LPCWSTR>(q), &p));

    X(q = LoadLibraryW(L"shell32"));
    Y(GetModuleHandleExW(PIN | ADDRESS, reinterpret_cast<LPCWSTR>(q) + 100, &p));
    Y(FreeLibrary(q)); Y(FreeLibrary(q)); Y(FreeLibrary(q));
    X(GetModuleHandleW(L"shell32.dll"));
    Y(GetModuleHandleExW(ADDRESS, reinterpret_cast<LPCWSTR>(q) + 1000, &p));

#undef X
#undef Y
#undef PIN
#undef NOCHANGE
#undef ADDRESS
#endif
}

void
TestGetFullPathName(
    PCWSTR s
    )
{
    WCHAR FullPath[MAX_PATH * 2];
    PWSTR FilePart = L"";
    DWORD dw;
    DWORD dwError;

    SetLastError(NO_ERROR);
    dw = GetFullPathNameW(s, RTL_NUMBER_OF(FullPath), FullPath, &FilePart);
    dwError = ::GetLastError();
    printf(
        "GetFullPathNameW(%ls):%lu,lastError=%lu,filePart=%ls\n",
        FullPath,
        dw,
        dwError,
        FilePart
        );
}

void
TestCreateFile(
    PCWSTR s
    )
{
    HANDLE handle;
    DWORD dwError;

    SetLastError(NO_ERROR);
    handle = CreateFileW(
        s,
        0,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    dwError = ::GetLastError();
    if (handle != INVALID_HANDLE_VALUE)
        CloseHandle(handle);
    printf(
        "CreateFileW(%ls):%p,lastError=%lu\n",
        s,
        handle,
        dwError
        );
}

/*
from base\ntsetup\dll\sxs.c
*/
VOID
SxspGetPathBaseName(
    LPCWSTR Path,
    LPWSTR  Base
    )
{
    LPCWSTR Dot = wcsrchr(Path, '.');
    LPCWSTR Slash = wcsrchr(Path, '\\');
    //
    // beware \foo.txt\bar
    // beware \bar
    // beware bar
    // beware .bar
    // beware \.bar
    //
    *Base = 0;
    if (Slash == NULL)
        Slash = Path;
    else
        Slash += 1;
    if (Dot == NULL || Dot < Slash)
        Dot = Path + StringLength(Path);
    CopyMemory(Base, Slash, (Dot - Slash) * sizeof(*Base));
    Base[Dot - Slash] = 0;
}

NTSTATUS
NTAPI
RtlCopyMappedMemory(
    PVOID   ToAddress,
    PCVOID  FromAddress,
    SIZE_T  Size
    )
{
    CopyMemory(ToAddress, FromAddress, Size);
    return STATUS_SUCCESS;
}

VOID
TestGetPathBaseName(
    LPCWSTR Path
    )
{
    WCHAR Base[MAX_PATH];

    SxspGetPathBaseName(Path, Base);
    printf("\"%ls\" -> \"%ls\"\n", Path, Base);

}

void TestVersion()
{
    printf(
        "Windows NT %lu.%lu.%lu\n",
        FusionpGetWindowsNtMajorVersion(),
        FusionpGetWindowsNtMinorVersion(),
        FusionpGetWindowsNtBuildVersion()
        );
}

void TestGetProcessImageFileName()
{
    UNICODE_STRING s;

    FusionpGetProcessImageFileName(&s);
    printf("%wZ\n", &s);
}

BOOL TestErrorInfra1()  { FN_PROLOG_WIN32; IFW32FALSE_ORIGINATE_AND_EXIT(LoadLibraryA("1"));       FN_EPILOG; }
BOOL TestErrorInfra2()  { FN_PROLOG_WIN32; IFW32NULL_EXIT(LoadLibraryA("  2  "));                  FN_EPILOG; }
BOOL TestErrorInfra3()  { FN_PROLOG_WIN32; IFFAILED_CONVERTHR_HRTOWIN32_EXIT_TRACE(E_FAIL | 3);   FN_EPILOG; }
BOOL TestErrorInfra4()  { FN_PROLOG_WIN32; IFCOMFAILED_EXIT(E_FAIL | 4);                          FN_EPILOG; }
BOOL TestErrorInfra5()  { FN_PROLOG_WIN32; IFCOMFAILED_ORIGINATE_AND_EXIT(E_FAIL | 5);            FN_EPILOG; }
BOOL TestErrorInfra6()  { FN_PROLOG_WIN32; IFREGFAILED_EXIT(6);                                   FN_EPILOG; }
BOOL TestErrorInfra7()  { FN_PROLOG_WIN32; IFREGFAILED_ORIGINATE_AND_EXIT(7);                     FN_EPILOG; }

HRESULT TestErrorInfra8()   { FN_PROLOG_HR; IFW32FALSE_ORIGINATE_AND_EXIT(LoadLibraryA("8"));       FN_EPILOG; }
HRESULT TestErrorInfra9()   { FN_PROLOG_HR; IFW32NULL_EXIT(LoadLibraryA("!@#   9  \\"));            FN_EPILOG; }
HRESULT TestErrorInfra10()  { FN_PROLOG_HR; IFFAILED_CONVERTHR_HRTOWIN32_EXIT_TRACE(E_FAIL | 10);  FN_EPILOG; }
HRESULT TestErrorInfra11()  { FN_PROLOG_HR; IFCOMFAILED_EXIT(E_FAIL | 11);                         FN_EPILOG; }
HRESULT TestErrorInfra12()  { FN_PROLOG_HR; IFCOMFAILED_ORIGINATE_AND_EXIT(E_FAIL | 12);           FN_EPILOG; }
HRESULT TestErrorInfra13()  { FN_PROLOG_HR; IFREGFAILED_EXIT(13);                                  FN_EPILOG; }
HRESULT TestErrorInfra14()  { FN_PROLOG_HR; IFREGFAILED_ORIGINATE_AND_EXIT(14);                    FN_EPILOG; }

void TestErrorInfra()
{
#define X(x) DbgPrint("%s\n", #x); x()
    X(TestErrorInfra1);
    X(TestErrorInfra2);
    X(TestErrorInfra3);
    X(TestErrorInfra4);
    X(TestErrorInfra5);
    X(TestErrorInfra7);
    X(TestErrorInfra8);
    X(TestErrorInfra9);
    X(TestErrorInfra10);
    X(TestErrorInfra11);
    X(TestErrorInfra12);
    X(TestErrorInfra13);
    X(TestErrorInfra14);
#undef X
}

void TestQueryActCtx3(
    ULONG Flags,
    HANDLE ActCtxHandle
    )
{
    SIZE_T                                          BytesWrittenOrRequired = 0;
    BYTE                                            QueryBuffer[4][4096];
    ACTIVATION_CONTEXT_QUERY_INDEX                  QueryIndex = { 0 };
    PACTIVATION_CONTEXT_BASIC_INFORMATION           BasicInfo = reinterpret_cast<PACTIVATION_CONTEXT_BASIC_INFORMATION>(&QueryBuffer[0]);
    PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION  DllRedir = reinterpret_cast<PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION>(&QueryBuffer[1]);
    PACTIVATION_CONTEXT_DETAILED_INFORMATION        ContextDetailed = reinterpret_cast<PACTIVATION_CONTEXT_DETAILED_INFORMATION>(&QueryBuffer[2]);
    PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION AssemblyDetailed = reinterpret_cast<PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>(&QueryBuffer[3]);
    CStringBuffer decimalContext;

    RtlZeroMemory(&QueryBuffer, sizeof(QueryBuffer));

    if (IS_SPECIAL_ACTCTX(ActCtxHandle))
        decimalContext.Win32Format(L" (%Id)", reinterpret_cast<LONG_PTR>(ActCtxHandle));

#define QueryFailed(x,n) Trace("%s:%ld:QueryActCtx(%s) failed %lu\n", __FUNCTION__, ULONG(n), x, GetLastError())
    if (!QueryActCtxW(
        Flags,
        ActCtxHandle,
        NULL,
        ActivationContextBasicInformation,
        &QueryBuffer,
        sizeof(QueryBuffer),
        &BytesWrittenOrRequired
        ))
        QueryFailed("ActivationContextBasicInformation", __LINE__ - 1);
    else
    {
        if (IS_SPECIAL_ACTCTX(BasicInfo->hActCtx))
            decimalContext.Win32Format(L" (%Id)", reinterpret_cast<LONG_PTR>(BasicInfo->hActCtx));
        Trace(
            "BytesWrittenOrRequired   : 0x%lx\n"
            "BasicInfo->hActCtx       : %p%ls\n"
            "BasicInfo->Flags         : 0x%lx\n",
            BytesWrittenOrRequired,
            BasicInfo->hActCtx,
            static_cast<PCWSTR>(decimalContext),
            BasicInfo->Flags
            );
    }
    Flags = (Flags & ~QUERY_ACTCTX_FLAG_NO_ADDREF);
    if (!QueryActCtxW(Flags, ActCtxHandle, NULL, ActivationContextDetailedInformation, ContextDetailed, 4096, &BytesWrittenOrRequired))
        QueryFailed("ActivationContextDetailedInformation", __LINE__ - 1);
    else
    {
        Trace(
            "BytesWrittenOrRequired                        : 0x%lx\n"
            "ContextDetailed->dwFlags                      : 0x%lx\n"
            "ContextDetailed->ulFormatVersion              : 0x%lx\n"
            "ContextDetailed->ulAssemblyCount              : 0x%lx\n"
            "ContextDetailed->ulRootManifestPathType       : 0x%lx\n"
            "ContextDetailed->ulRootManifestPathChars      : 0x%lx\n"
            "ContextDetailed->ulRootConfigurationPathType  : 0x%lx\n"
            "ContextDetailed->ulRootConfigurationPathChars : 0x%lx\n"
            "ContextDetailed->ulAppDirPathType             : 0x%lx\n"
            "ContextDetailed->ulAppDirPathChars            : 0x%lx\n"
            "ContextDetailed->lpRootManifestPath           : %ls\n"
            "ContextDetailed->lpRootConfigurationPath      : %ls\n"
            "ContextDetailed->lpAppDirPath                 : %ls\n"
           ,
            BytesWrittenOrRequired,
            ContextDetailed->dwFlags,
            ContextDetailed->ulFormatVersion,
            ContextDetailed->ulAssemblyCount,
            ContextDetailed->ulRootManifestPathType,
            ContextDetailed->ulRootManifestPathChars,
            ContextDetailed->ulRootConfigurationPathType,
            ContextDetailed->ulRootConfigurationPathChars,
            ContextDetailed->ulAppDirPathType,
            ContextDetailed->ulAppDirPathChars,
            ContextDetailed->lpRootManifestPath,
            ContextDetailed->lpRootConfigurationPath,
            ContextDetailed->lpAppDirPath
            );
    }
    {
        ULONG AssemblyIndex = 0;
        ULONG FileInAssemblyIndex = 0;

        //
        // 0 produces ERROR_INTERNAL_ERROR
        //
        for (AssemblyIndex = 0 ; AssemblyIndex <= ContextDetailed->ulAssemblyCount ; AssemblyIndex += 1)
        {
            if (!QueryActCtxW(Flags, ActCtxHandle, &AssemblyIndex, AssemblyDetailedInformationInActivationContext, AssemblyDetailed, 4096, &BytesWrittenOrRequired))
            {
                Trace(
                    "%s(%lu):QueryActCtx(Flags=0x%lx, ActCtxHandle=%p%ls, AssemblyIndex=0x%lx, AssemblyDetailedInformationInActivationContext) LastError=%lu (%ls)\n",
                    __FUNCTION__,
                    __LINE__ - 1,
                    Flags,
                    ActCtxHandle,
                    static_cast<PCWSTR>(decimalContext),
                    AssemblyIndex,
                    ::FusionpGetLastWin32Error(),
                    ::FusionpThreadUnsafeGetLastWin32ErrorMessageW()
                    );
            }
            else
            {
                Trace(
                    "AssemblyIndex                                       : 0x%lx\n"
                    "BytesWrittenOrRequired                              : 0x%lx\n"
                    "AssemblyDetailed->ulFlags                           : 0x%lx\n"
                    "AssemblyDetailed->ulEncodedAssemblyIdentityLength   : 0x%lx\n"
                    "AssemblyDetailed->ulManifestPathType                : 0x%lx\n"
                    "AssemblyDetailed->ulManifestPathLength              : 0x%lx\n"
                    "AssemblyDetailed->liManifestLastWriteTime           : 0x%I64x\n"
                    "AssemblyDetailed->ulPolicyPathType                  : 0x%lx\n"
                    "AssemblyDetailed->ulPolicyPathLength                : 0x%lx\n"
                    "AssemblyDetailed->liPolicyLastWriteTime             : 0x%I64x\n"
                    "AssemblyDetailed->ulMetadataSatelliteRosterIndex    : 0x%lx\n"
                    "AssemblyDetailed->ulManifestVersionMajor            : 0x%lx\n"
                    "AssemblyDetailed->ulManifestVersionMinor            : 0x%lx\n"
                    "AssemblyDetailed->ulPolicyVersionMajor              : 0x%lx\n"
                    "AssemblyDetailed->ulPolicyVersionMinor              : 0x%lx\n"
                    "AssemblyDetailed->ulAssemblyDirectoryNameLength     : 0x%lx\n"
                    "AssemblyDetailed->lpAssemblyEncodedAssemblyIdentity : %ls\n"
                    "AssemblyDetailed->lpAssemblyManifestPath            : %ls\n"
                    "AssemblyDetailed->lpAssemblyPolicyPath              : %ls\n"
                    "AssemblyDetailed->lpAssemblyDirectoryName           : %ls\n"
                    "AssemblyDetailed->ulFileCount                       : 0x%lx\n"
                   ,
                    AssemblyIndex,
                    BytesWrittenOrRequired,
                    AssemblyDetailed->ulFlags,
                    AssemblyDetailed->ulEncodedAssemblyIdentityLength,
                    AssemblyDetailed->ulManifestPathType,
                    AssemblyDetailed->ulManifestPathLength,
                    AssemblyDetailed->liManifestLastWriteTime.QuadPart,
                    AssemblyDetailed->ulPolicyPathType,
                    AssemblyDetailed->ulPolicyPathLength,
                    AssemblyDetailed->liPolicyLastWriteTime.QuadPart,
                    AssemblyDetailed->ulMetadataSatelliteRosterIndex,
                    AssemblyDetailed->ulManifestVersionMajor,
                    AssemblyDetailed->ulManifestVersionMinor,
                    AssemblyDetailed->ulPolicyVersionMajor,
                    AssemblyDetailed->ulPolicyVersionMinor,
                    AssemblyDetailed->ulAssemblyDirectoryNameLength,
                    AssemblyDetailed->lpAssemblyEncodedAssemblyIdentity,
                    AssemblyDetailed->lpAssemblyManifestPath,
                    AssemblyDetailed->lpAssemblyPolicyPath,
                    AssemblyDetailed->lpAssemblyDirectoryName,
                    AssemblyDetailed->ulFileCount
                    );

                QueryIndex.ulAssemblyIndex = AssemblyIndex;
                SetLastError(NO_ERROR);
                if (AssemblyDetailed->ulFileCount == 0)
                {
                    Trace("AssemblyDetailed->ulFileCount is 0, working around bug, setting it to 4.\n");
                    AssemblyDetailed->ulFileCount = 4; // bug workaround
                }
                for (FileInAssemblyIndex = 0 ; FileInAssemblyIndex != AssemblyDetailed->ulFileCount ; FileInAssemblyIndex += 1)
                {
                    QueryIndex.ulFileIndexInAssembly = FileInAssemblyIndex;
                    if (!QueryActCtxW(Flags, ActCtxHandle, &QueryIndex, FileInformationInAssemblyOfAssemblyInActivationContext, DllRedir, 4096, &BytesWrittenOrRequired))
                    {
                        Trace(
                            "%s(%lu):QueryActCtx(Flags=0x%lx, ActCtxHandle=%p%ls, QueryIndex={ulAssemblyIndex=0x%lx, ulFileIndexInAssembly=0x%lx}, FileInformationInAssemblyOfAssemblyInActivationContext) LastError=%lu (%ls)\n",
                            __FUNCTION__,
                            __LINE__,
                            Flags,
                            ActCtxHandle,
                            static_cast<PCWSTR>(decimalContext),
                            QueryIndex.ulAssemblyIndex,
                            QueryIndex.ulFileIndexInAssembly,
                            ::FusionpGetLastWin32Error(),
                            ::FusionpThreadUnsafeGetLastWin32ErrorMessageW()
                            );
                        //break;
                    }
                    else
                    {
                        Trace(
                            "AssemblyIndex                          : 0x%lx\n"
                            "FileIndex                              : 0x%lx\n"
                            "BytesWrittenOrRequired                 : 0x%lx\n"
                            "DllRedir[0x%lx,0x%lx]->ulFlags         : 0x%lx\n"
                            "DllRedir[0x%lx,0x%lx]->ulFilenameLength : 0x%lx\n"
                            "DllRedir[0x%lx,0x%lx]->ulPathLength    : 0x%lx\n"
                            "DllRedir[0x%lx,0x%lx]->lpFileName      : %ls\n"
                            "DllRedir[0x%lx,0x%lx]->lpFilePath      : %ls\n"
                            ,
                            AssemblyIndex,
                            FileInAssemblyIndex,
                            BytesWrittenOrRequired,
                            AssemblyIndex, FileInAssemblyIndex, DllRedir->ulFlags,
                            AssemblyIndex, FileInAssemblyIndex, DllRedir->ulFilenameLength,
                            AssemblyIndex, FileInAssemblyIndex, DllRedir->ulPathLength,
                            AssemblyIndex, FileInAssemblyIndex, DllRedir->lpFileName,
                            AssemblyIndex, FileInAssemblyIndex, DllRedir->lpFilePath
                            );
                    }
                }
            }
        }
    }
}

void TestQueryActCtx2()
{
    {
        CFusionActCtxHandle LogonuiActCtxHandle;
        {
            WCHAR LogonuiManifest[MAX_PATH * 2];
            ACTCTXW            LogonuiActCtx = {sizeof(LogonuiActCtx)};

            LogonuiManifest[0] = 0;
            GetSystemDirectoryW(LogonuiManifest, MAX_PATH);
            wcscat(LogonuiManifest, L"\\logonui.exe.manifest");
            LogonuiActCtx.lpSource = LogonuiManifest;
            LogonuiActCtxHandle.Win32Create(&LogonuiActCtx);
        }
        {
            CFusionActCtxScope LogonuiActCtxScope;
            LogonuiActCtxScope.Win32Activate(LogonuiActCtxHandle);

            TestQueryActCtx3(QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX | QUERY_ACTCTX_FLAG_NO_ADDREF, NULL);
        }
        TestQueryActCtx3(QUERY_ACTCTX_FLAG_NO_ADDREF, LogonuiActCtxHandle);
    }
    TestQueryActCtx3(QUERY_ACTCTX_FLAG_NO_ADDREF, ACTCTX_EMPTY);
    TestQueryActCtx3(QUERY_ACTCTX_FLAG_NO_ADDREF, ACTCTX_SYSTEM_DEFAULT);
}

void TestQueryActCtx()
{
    WCHAR ExePath[MAX_PATH];
    CStringBuffer DllPath;
    HMODULE hmod = NULL;
    WCHAR buffer[200];

    if (IamExe)
    {
        if (!Kernel32.GetModuleFileNameW(NULL, ExePath, RTL_NUMBER_OF(ExePath)))
            ThrowLastError();
        if (!DllPath.Win32Format(L"%ls.dll", ExePath))
            ThrowLastError();
        ::CopyFileW(ExePath, DllPath, FALSE);
    }

    if (IamDll)
    {
        hmod = NULL;
        hmod = (HMODULE)RtlPcToFileHeader(InitCommonControls, (PVOID*)&hmod);
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from dll static dep: %p %ls\n", hmod, buffer);

#if defined(ISOLATION_AWARE_ENABLED)
        hmod = IsolationAwareLoadLibraryW(L"comctl32.dll");
        LastError = ::GetLastError();
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from dll IsolationAwareLoadLibraryW: %p %ls\n", hmod, buffer);
#endif

        hmod = LoadLibraryW(L"comctl32.dll");
        LastError = ::GetLastError();
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from dll LoadLibraryW: %p %ls\n", hmod, buffer);

        return;
    }

    {
        hmod = NULL;
        hmod = (HMODULE)RtlPcToFileHeader(InitCommonControls, (PVOID*)&hmod);
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from exe static dep: %p %ls\n", hmod, buffer);

#if defined(ISOLATION_AWARE_ENABLED)
        hmod = IsolationAwareLoadLibraryW(L"comctl32.dll");
        LastError = ::GetLastError();
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from exe IsolationAwareLoadLibraryW: %p %ls\n", hmod, buffer);
#endif
        hmod = LoadLibraryW(L"comctl32.dll");
        LastError = ::GetLastError();
        wcscpy(buffer, L"FAILED");
        if (hmod != NULL)
            Kernel32.GetModuleFileNameW(hmod, buffer, RTL_NUMBER_OF(buffer));
        Trace("from exe LoadLibraryW: %p %ls\n", hmod, buffer);

    }

    SetDllBitInPeImage(DllPath);
    Trace("Enter LoadLibraryW\n");
    hmod = LoadLibraryW(DllPath);
    LastError = ::GetLastError();
    Trace("Exit LoadLibraryW\n");
    void (*pfn)(void) = reinterpret_cast<void (*)(void)>(GetProcAddress(hmod, "TestQueryActCtx"));
    Trace("Enter non DllMain call to TestQueryActCtx\n");
    pfn();
    Trace("Exit non DllMain call to TestQueryActCtx\n");
    FreeLibrary(hmod);
    Kernel32.DeleteFileW(DllPath);
}

DWORD WINAPI Test64kThreadMain(void* pv)
{
    LONG_PTR i = 0;
    HANDLE h = 0;
    ULONG_PTR cookie = 0;
    LONG_PTR j = reinterpret_cast<LONG_PTR>(pv);

    GetCurrentActCtx(&h);

    ActivateActCtx(h, &cookie);
    printf("%Id ", cookie);
    if (cookie == 0) printf("cookie 0\n");
    ActivateActCtx(h, &cookie);
    printf("%Id ", cookie);
    if (cookie == 0) printf("cookie 0\n");

    __try
    {
        for (i = 0 ; i < j ; ++i)
        {
            if (!ActivateActCtx(h, &cookie))
                printf("activate error %lu\n", ::GetLastError());
            else
            {
                if (cookie == 0) printf("cookie 0\n");
                //printf("%Id ", cookie);
                if (!DeactivateActCtx(0, cookie))
                    printf("deactivate error %lu\n", ::GetLastError());
            }
        }
    }
    __except(printf("exception %lx\n", GetExceptionCode()),EXCEPTION_EXECUTE_HANDLER)
    {
    }
    printf("final cookie value %Id\n", cookie);
    return 0;
}

void Test64k()
{
    HANDLE h = 0;
    ULONG_PTR cookie = 0;
    DWORD threadId = 0;
    LONG_PTR i = 0;
    LONG_PTR j = 0;
    HANDLE thread = 0;

    GetCurrentActCtx(&h);

    ActivateActCtx(h, &cookie);
    if (cookie == 0) printf("cookie 0\n");
    printf("%Id ", cookie);
    ActivateActCtx(h, &cookie);
    if (cookie == 0) printf("cookie 0\n");
    printf("%Id ", cookie);

    for (j = 0 ; j < 0xfff0 ; ++j)
    {
        if (!ActivateActCtx(h, &cookie))
            printf("activate error %lu\n", ::GetLastError());
        else
        {
            if (cookie == 0) printf("cookie 0\n");
            if (!DeactivateActCtx(0, cookie))
                printf("deactivate error %lu\n", ::GetLastError());
        }
    }
    for ( ; j < 0xffff + 0xf ; ++j)
    {
        if (!ActivateActCtx(h, &cookie))
            printf("activate error %lu\n", ::GetLastError());
        printf("%Id ", cookie);
        if (cookie == 0) printf("cookie 0\n");
        thread = CreateThread(NULL, 0, Test64kThreadMain, reinterpret_cast<void*>(j), 0, &threadId);
    }
    WaitForSingleObject(thread, INFINITE);
}

void TestDotLocalSingleInstancing()
{
    FILE* File = 0;
    HMODULE DllHandle = 0;

    {
        WCHAR DotLocal[MAX_PATH];
        if (!Kernel32.GetModuleFileNameW(GetMyHandle(), DotLocal, NUMBER_OF(DotLocal) - sizeof(".local")))
            ThrowLastError();
        wcscat(DotLocal, L".local");
        File = _wfopen(DotLocal, L"w");
        fprintf(File, "\n");
        fclose(File);
    }
    {
        WCHAR System32Mshtml[MAX_PATH];
        WCHAR LocalMshtml[MAX_PATH];
        WCHAR ResultingMshtml[MAX_PATH];

        if (!GetSystemDirectoryW(System32Mshtml, NUMBER_OF(System32Mshtml) - sizeof("\\Mshtml.dll")))
            ThrowLastError();
        wcscat(System32Mshtml, L"\\Mshtml.dll");

        if (!Kernel32.GetModuleFileNameW(GetMyHandle(), LocalMshtml, NUMBER_OF(LocalMshtml) - sizeof("\\Mshtml.dll")))
            ThrowLastError();
        *wcsrchr(LocalMshtml, '\\') = 0;
        wcscat(LocalMshtml, L"\\Mshtml.dll");

        //DllHandle = LoadLibraryW(L"Mshtml.dll");
        //Trace("LoadLibrary(Mshtml): %p\n", DllHandle);

        if (!CopyFileW(System32Mshtml, LocalMshtml, FALSE))
            ThrowLastError();
        Trace("copy %ls -> %ls\n", System32Mshtml, LocalMshtml);

        ULONG i;
        for (i = 0 ; i != 4 ; i += 1)
        {
            DllHandle = LoadLibraryW(System32Mshtml);
            wcscpy(ResultingMshtml, L"FAILED");
            if (DllHandle != NULL)
                Kernel32.GetModuleFileNameW(DllHandle, ResultingMshtml, RTL_NUMBER_OF(ResultingMshtml));
            Trace("LoadLibrary(%ls): %p %ls\n", System32Mshtml, DllHandle, ResultingMshtml);
        }
    }
}

void
TestCreateActCtx(
    int n,
    wchar_t **args
    )
{
    ACTCTXW acw;
    int i = 0;
    WCHAR rgwchSource[MAX_PATH];
    PCWSTR pszResource = NULL;
    HANDLE hActCtx = NULL;
    DWORD dwLastError = 0;

    for (i=0; i<n; i++)
    {
        PCWSTR arg = args[i];
        PCWSTR semi = wcschr(arg, L';');

        memset(&acw, 0, sizeof(acw));

        acw.cbSize = sizeof(acw);

        if (semi == NULL)
        {
            acw.lpSource = arg;
        }
        else
        {
            int cch = (int) (semi - arg);

            if (cch >= NUMBER_OF(rgwchSource))
                cch = NUMBER_OF(rgwchSource) - 1;

            memcpy(rgwchSource, arg, cch * sizeof(WCHAR));
            rgwchSource[cch] = L'\0';

            if (semi[1] == L'#')
            {
                wchar_t *pszDummy;
                pszResource = MAKEINTRESOURCEW(wcstoul(semi+1, &pszDummy, 10));
            }
            else
            {
                pszResource = semi+1;
            }

            acw.lpSource = rgwchSource;
            acw.lpResourceName = pszResource;
            acw.dwFlags |= ACTCTX_FLAG_RESOURCE_NAME_VALID;
        }

        hActCtx = ::CreateActCtxW(&acw);
        dwLastError = ::GetLastError();
        printf("CreateActCtxW() on \"%ls\" returned %p\n", arg, hActCtx);
        if (hActCtx == INVALID_HANDLE_VALUE)
        {
            printf("   ::GetLastError() = %lu\n", dwLastError);
        }

        ::ReleaseActCtx(hActCtx);
    }
}

const char comctlv6manifest[]=
"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
"<assemblyIdentity"
"    name=\"Microsoft.Windows.Shell.notepad\""
"    processorArchitecture=\"x86\""
"    version=\"5.1.0.0\""
"    type=\"win32\"/>"
"<dependency>"
"    <dependentAssembly>"
"        <assemblyIdentity"
"            type=\"win32\""
"            name=\"Microsoft.Windows.Common-Controls\""
"            version=\"6.0.0.0\""
"            processorArchitecture=\"x86\""
"            publicKeyToken=\"6595b64144ccf1df\""
"            language=\"*\""
"        />"
"    </dependentAssembly>"
"</dependency>"
"</assembly>"
;

const char comctlv5manifest[]=
"<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
"<assemblyIdentity"
"    name=\"Microsoft.Windows.Shell.notepad\""
"    processorArchitecture=\"x86\""
"    version=\"5.1.0.0\""
"    type=\"win32\"/>"
"</assembly>"
;

void TestCreateActctxAdminOverride()
{
    WCHAR exe[MAX_PATH];
    WCHAR dll[MAX_PATH];
    WCHAR comctl[MAX_PATH];
    WCHAR manifest[MAX_PATH];
    ACTCTXW Actctx = {sizeof(Actctx)};
    FILE* File = NULL;
    ULONG_PTR ulCookie = 0;
    HMODULE DllHandle = 0;
    HANDLE ActctxHandle = NULL;
    GUID Guid = { 0 };

    wcscpy(exe, GetMyModuleFullPath());
    wcscpy(dll, GetMyModuleFullPath());
    wcscat(dll, L".dll");
    CopyFileW(exe, dll, FALSE);
    SetDllBitInPeImage(dll);

    Actctx.lpSource = dll;
    /*
    ActctxHandle = CreateActCtxW(&Actctx);
    if (ActctxHandle == INVALID_HANDLE_VALUE)
        return;
    Trace("CreateActCtxW succeeded\n");
    */

    //
    // manfile is number to put in the manifest file name, 0 for none
    // good is what the contents of the file are, 0=>bad, 1=>v5, 2=>v6
    // res is what resource id to ask for
    //
    for (int manfile = 0 ; manfile != 4 ; manfile += 1)
    {
        WCHAR Number[RTL_BITS_OF(ULONG_PTR) + 3];
        for (int good = 0 ; good != 3 ; good += 1)
        {
            for (int res = -1 ; res != 4 ; res += 1)
            {
                Trace("---------------------------------------------------------------\n");
                Trace("resourceid is %d%s\n", res, (res != -1) ? "" : " (flag not set)");
                if (res != -1)
                {
                    Actctx.lpResourceName = MAKEINTRESOURCEW(res);
                    Actctx.dwFlags |= ACTCTX_FLAG_RESOURCE_NAME_VALID;
                    Actctx.lpResourceName = MAKEINTRESOURCEW(res);
                }
                else
                {
                    Actctx.dwFlags &= ~ACTCTX_FLAG_RESOURCE_NAME_VALID;
                }
                for (int delman = 0 ; delman != 4 ; delman += 1)
                {
                    Number[0] = 0;
                    if (delman)
                        swprintf(Number, L".%d", delman);
                    swprintf(manifest, L"%ls%ls%ls%ls", GetMyModuleFullPathWithoutExtension(), L".dll", Number, L".Manifest");
                    /*
                    CoCreateGuid(&Guid);
                    swprintf(String3, L"%ls%I64x%I64x", GetMyModuleFullPath(), *reinterpret_cast<__int64*>(&Guid), *(1+reinterpret_cast<__int64*>(&Guid)));
                    if (!MoveFileW(String, String3) && ::GetLastError() != ERROR_FILE_NOT_FOUND)
                        Trace("MoveFile(%ls -> %ls) FAILED %d\n", String, String3, ::GetLastError());
                    else
                        ;//Trace("MoveFile(%ls -> %ls)\n", String, String3);
                    */
                    if (!Kernel32.DeleteFileW(manifest) && ::GetLastError() != ERROR_FILE_NOT_FOUND)
                        Trace("DeleteFile(%ls) FAILED %d\n", manifest, ::GetLastError());
                    else
                        ;//Trace("DeleteFile(%ls)\n", String3);
                }
                Number[0] = 0;
                if (manfile != 0)
                {
                    swprintf(Number, L".%d", manfile);
                }
                swprintf(manifest, L"%ls%ls%ls%ls", GetMyModuleFullPathWithoutExtension(), L".dll", Number, L".Manifest");
                //Trace("fopen(%ls)\n", String);
                File = _wfopen(manifest, L"w+");
                if (File == NULL)
                {
                    perror("fopen");
                }
                switch (good)
                {
                case 0:
                    fprintf(File, "bad");
                    Trace("%ls is bad\n", manifest);
                    break;
                case 1:
                    fprintf(File, "%s", comctlv5manifest);
                    Trace("%ls is comctlv5manifest\n", manifest);
                    break;
                case 2:
                    fprintf(File, "%s", comctlv6manifest);
                    Trace("%ls is comctlv6manifest\n", manifest);
                    break;
                }
                fclose(File);

                ActctxHandle = CreateActCtxW(&Actctx);
                if (ActctxHandle == INVALID_HANDLE_VALUE)
                {
                    Trace("CreateActCtxW failed %d\n", ::GetLastError());
                    ulCookie = 0;
                }
                else
                {
                    Trace("CreateActCtxW succeeded %p\n", ActctxHandle);
                    ActivateActCtx(ActctxHandle, &ulCookie);
                }
                __try
                {
                    PWSTR filePart;
                    comctl[0] = 0;
                    SearchPathW(NULL, L"comctl32.dll", NULL, RTL_NUMBER_OF(comctl), comctl, &filePart);
                }
                __finally
                {
                    if (ActctxHandle != INVALID_HANDLE_VALUE)
                        DeactivateActCtx(0, ulCookie);
                }
                Trace("SearchPathW(comctl32.dll): %ls\n", comctl);
            }
        }
    }
}

void TestCreateActctxLikeCreateProcess()
{
#if defined(ACTCTX_FLAG_LIKE_CREATEPROCESS)
    WCHAR comctl[MAX_PATH];
    WCHAR manifest[MAX_PATH];
    ACTCTXW Actctx = {sizeof(Actctx)};
    FILE* File = NULL;
    ULONG_PTR ulCookie = 0;
    HMODULE DllHandle = 0;
    HANDLE ActctxHandle;
    PWSTR filePart = NULL;

    Actctx.lpSource = GetMyModuleFullPath();
    Actctx.dwFlags = ACTCTX_FLAG_LIKE_CREATEPROCESS;

    wcscpy(manifest, GetMyModuleFullPath());
    wcscat(manifest, L".Manifest");
    Kernel32.DeleteFileW(manifest);
    //Trace("DeleteFile(%ls)\n", manifest);

    ActctxHandle = CreateActCtxW(&Actctx);
    if (ActctxHandle == INVALID_HANDLE_VALUE)
    {
        Trace("CreateActCtxW failed %d\n", ::GetLastError());
        ulCookie = 0;
    }
    else
    {
        Trace("CreateActCtxW succeeded %p\n", ActctxHandle);
        ActivateActCtx(ActctxHandle, &ulCookie);
    }
    __try
    {
        comctl[0] = 0;
        SearchPathW(NULL, L"comctl32.dll", NULL, RTL_NUMBER_OF(comctl), comctl, &filePart);
    }
    __finally
    {
        if (ActctxHandle != INVALID_HANDLE_VALUE)
            DeactivateActCtx(0, ulCookie);
    }
    Trace("SearchPathW(comctl32.dll): %ls\n", comctl);

    File = _wfopen(manifest, L"w");
    fprintf(File, "%s", comctlv5manifest);
    fclose(File);
    Trace("%ls == comctlv5manifest\n", manifest);

    ActctxHandle = CreateActCtxW(&Actctx);
    if (ActctxHandle == INVALID_HANDLE_VALUE)
    {
        Trace("CreateActCtxW failed %d\n", ::GetLastError());
        ulCookie = 0;
    }
    else
    {
        Trace("CreateActCtxW succeeded %p\n", ActctxHandle);
        ActivateActCtx(ActctxHandle, &ulCookie);
    }
    __try
    {
        comctl[0] = 0;
        SearchPathW(NULL, L"comctl32.dll", NULL, RTL_NUMBER_OF(comctl), comctl, &filePart);
    }
    __finally
    {
        if (ActctxHandle != INVALID_HANDLE_VALUE)
            DeactivateActCtx(0, ulCookie);
    }
    Trace("SearchPathW(comctl32.dll): %ls\n", comctl);

    File = _wfopen(manifest, L"w");
    fprintf(File, "%ls", comctlv6manifest);
    fclose(File);
    Trace("%ls == comctlv6manifest\n", manifest);

    ActctxHandle = CreateActCtxW(&Actctx);
    if (ActctxHandle == INVALID_HANDLE_VALUE)
    {
        Trace("CreateActCtxW failed %d\n", ::GetLastError());
        ulCookie = 0;
    }
    else
    {
        Trace("CreateActCtxW succeeded %p\n", ActctxHandle);
        ActivateActCtx(ActctxHandle, &ulCookie);
    }
    __try
    {
        comctl[0] = 0;
        SearchPathW(NULL, L"comctl32.dll", NULL, RTL_NUMBER_OF(comctl), comctl, &filePart);
    }
    __finally
    {
        if (ActctxHandle != INVALID_HANDLE_VALUE)
            DeactivateActCtx(0, ulCookie);
    }
    Trace("SearchPathW(comctl32.dll): %ls\n", comctl);
#endif
}

void
TestQueryManifestInformationBasic(
    PCWSTR pszManifest
    )
{
    LoadSxs();
    struct {
        SXS_MANIFEST_INFORMATION_BASIC mib;
        WCHAR rgwchSpaceForIdentity[1024];
        WCHAR rgwchSpaceForDirName[1024];
    } buff;

    if (!(*g_pfnSxsQueryManifestInformation)(0, pszManifest, SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC, 0, sizeof(buff), &buff, NULL)) {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
    }
}

void TestImage()
{
    PIMAGE_RESOURCE_DIRECTORY ImageResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)4;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ImageResourceDirectoryEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)4;;

    printf("ImageResourceDirectory %p\n", ImageResourceDirectory);
    printf("ImageResourceDirectory + 1 %p\n", ImageResourceDirectory + 1);

    printf("ImageResourceDirectoryEntry %p\n", ImageResourceDirectoryEntry);
    printf("ImageResourceDirectoryEntry + 1 %p\n", ImageResourceDirectoryEntry + 1);
}

class CSxsTestCleanup : public CCleanupBase
{
public:
    VOID DeleteYourself() { }
    ~CSxsTestCleanup() { }
};

#define private public
#include "sxsprotect.h"
#undef private

void TestInterlockedAlignment()
{
    __declspec(align(16)) SLIST_HEADER SlistHeader;

    RtlInitializeSListHead(&SlistHeader);

    CSxsTestCleanup* pc = new CSxsTestCleanup();
    printf("%p\n", pc);
    printf("%p\n", static_cast<SLIST_ENTRY*>(pc));
    SxspAtExit(pc);

    CProtectionRequestRecord* pr = new CProtectionRequestRecord;
    printf("%p\n", pr);
    printf("%p\n", &pr->m_ListHeader);

    CStringListEntry* psle = new CStringListEntry;
    printf("%p\n", psle);
    printf("%p\n", static_cast<SLIST_ENTRY*>(psle));

    RtlInterlockedPushEntrySList(&SlistHeader, pc);
    RtlInterlockedPushEntrySList(&SlistHeader, psle);
    RtlQueryDepthSList(&SlistHeader);
    RtlInterlockedPopEntrySList(&SlistHeader);
    RtlInterlockedFlushSList(&SlistHeader);
    // untested: RtlInterlockedPushListSList

    RtlInterlockedPushEntrySList(&pr->m_ListHeader, pc);
    RtlInterlockedPushEntrySList(&pr->m_ListHeader, psle);
    RtlQueryDepthSList(&pr->m_ListHeader);
    RtlInterlockedPopEntrySList(&pr->m_ListHeader);
    RtlInterlockedFlushSList(&pr->m_ListHeader);
    // untested: RtlInterlockedPushListSList

    printf("success\n");
}

void TestCreateActctxWindowsShellManifest()
{
    WCHAR WindowsShellManifestFileName[MAX_PATH];
    ACTCTXW ActCtx = { sizeof(ActCtx) };
    HANDLE ActCtxHandle = 0;
    WindowsShellManifestFileName[0] = 0;

    GetWindowsDirectoryW(WindowsShellManifestFileName, NUMBER_OF(WindowsShellManifestFileName) - 64);
    wcscat(WindowsShellManifestFileName, L"\\WindowsShell.Manifest");
    ActCtx.lpSource = WindowsShellManifestFileName;

    ActCtxHandle = CreateActCtxW(&ActCtx);
    Trace("TestCreateActctxWindowsShellManifest: %p, %lu\n", ActCtxHandle, ::GetLastError());
    ReleaseActCtx(ActCtxHandle);
}

void TestCreateGlobalEvent()
{
    if (!::CreateEventW(NULL, FALSE, FALSE, L"MGRIER"))
        return;
    Sleep(500000);
}


#if 0

class CObjectTypes
{
protected:
    std::vector<BYTE> m_ByteBuffer;
    PSYSTEM_OBJECTTYPE_INFORMATION m_TypedBuffer;
public:
};

class CObjectSnapshot
{
protected:
    //
    // This interface is not very good, but it's easy..the entries
    // are of variable size...
    //
    std::vector<BYTE> m_ByteBuffer;
    SIZE_T            m_Size;

    //
    // Some operations, like sorting, require us to move all the string data
    // out of the elements. We do not manage this data in a lossless way.
    //
    // Ultimately, you may benefit from copying/transforming the data completely.
    //
    std::vector<BYTE> m_StringData;
public:

    SIZE_T size() const { return m_Size; }

    class iterator;

    class const_iterator
    {
    protected:
        const SYSTEM_OBJECT_INFORMATION* m_p;
    public:
        ~const_iterator() { }

        void operator=(const const_iterator& x) { m_p = x.m_p; }
        const_iterator(const const_iterator& x) : m_p(x.m_p) { }
        const_iterator(const BYTE* p = NULL) : m_p(reinterpret_cast<const SYSTEM_OBJECT_INFORMATION*>(p)) { }

        //void operator=(const iterator& x);
        //const_iterator(const iterator& x);

        bool operator==(const const_iterator& i) const
        {
            return (m_p == i.m_p);
        }

        bool operator!=(const const_iterator& i) const
        {
            return (m_p != i.m_p);
        }

        const SYSTEM_OBJECT_INFORMATION& operator*() const { return *m_p; }

        void operator++()
        {
            if (m_p != NULL)
            {
                if (m_p->NextEntryOffset != 0)
                    m_p = reinterpret_cast<const SYSTEM_OBJECT_INFORMATION*>(reinterpret_cast<const BYTE*>(m_p) + m_p->NextEntryOffset);
                else
                    m_p = NULL; // end
            }
        }

        const_iterator operator++(int)
        {
            const_iterator tmp = *this;
            ++*this;;
            return tmp;
        }
    };

    class iterator : public const_iterator
    {
    private:
        void operator=(const const_iterator&);
    public:
        ~iterator() { }
        iterator(BYTE* p = NULL) : const_iterator(p) { }

        SYSTEM_OBJECT_INFORMATION& operator*() { return const_cast<SYSTEM_OBJECT_INFORMATION&>(*m_p); }
    };

    const_iterator begin() const { return const_iterator(&m_ByteBuffer[0]); }
          iterator begin()       { return iterator(&m_ByteBuffer[0]); }
    const_iterator end() const   { return const_iterator(); }
          iterator end()         { return iterator(); }

    void swap(CObjectSnapshot& x)
    {
        std::swap(m_ByteBuffer, x.m_ByteBuffer);
        std::swap(m_Size, x.m_Size);
    }

    CObjectSnapshot() { }
    ~CObjectSnapshot() { }
};

class CHandleSnapshot
{
protected:
    std::vector<BYTE> m_ByteBuffer;
    PSYSTEM_HANDLE_INFORMATION_EX m_TypedBuffer;
public:

    SIZE_T size() const { return m_TypedBuffer->NumberOfHandles; }

    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* begin() { return &m_TypedBuffer->Handles[0]; }
    const SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* begin() const { return &m_TypedBuffer->Handles[0]; }

    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* end() { return begin() + size(); }
    const SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX* end() const { return begin() + size(); }

    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX& operator[](size_t index) { return *(begin() + index); }
    const SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX& operator[](size_t index) const { return *(begin() + index); }

    void reserve(SIZE_T n)
    {
        resize(n); // since there's no constructor..
    }

    void resize(SIZE_T n)
    {
        m_ByteBuffer.resize(sizeof(SYSTEM_HANDLE_INFORMATION_EX) + (n - 1) * sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX));
        Resync();
        m_TypedBuffer->NumberOfHandles = n;
    }

    void swap(CHandleSnapshot& x)
    {
        std::swap(m_ByteBuffer, x.m_ByteBuffer);
        x.Resync();
        Resync();
    }

    CHandleSnapshot() : m_TypedBuffer(NULL) { }
    ~CHandleSnapshot() { }

    void GetHandlesForCurrentProcess()
    {
        GetHandlesForProcess(GetCurrentProcessId());
    }

    void GetHandlesForProcess(ULONG_PTR pid)
    {
        GetHandlesForSystem();
        FilterByProcessId(pid);
    }

    void GetHandlesForSystem()
    {
        //
        // the actual needed size can be very large, over 256k
        //
        ULONG Size = 0;

        m_TypedBuffer = NULL;
        m_ByteBuffer.resize(sizeof(SYSTEM_HANDLE_INFORMATION_EX));
        NTSTATUS Status = NtQuerySystemInformation(SystemExtendedHandleInformation, &m_ByteBuffer[0], static_cast<ULONG>(m_ByteBuffer.size()), &Size);
        while (Status == STATUS_INFO_LENGTH_MISMATCH && Size != 0)
        {
            //
            // since it is transient, let's be safe and double it
            //
            m_ByteBuffer.resize(Size * 2);
            Status = NtQuerySystemInformation(SystemExtendedHandleInformation, &m_ByteBuffer[0], static_cast<ULONG>(m_ByteBuffer.size()), &Size);
        }
        if (!NT_SUCCESS(Status))
        {
            Trace("NtQuerySystemInformation failed 0x%lx\n", Status);
            return;
        }
        m_ByteBuffer.resize(Size);
        m_TypedBuffer = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION_EX>(&m_ByteBuffer[0]);
        Trace("%Id total handles system-wide\n", m_TypedBuffer->NumberOfHandles);
    }

    void FilterByProcessId(ULONG_PTR pid)
    {
        SIZE_T Scan = 0;
        SIZE_T Keep = 0;

        for (Scan = 0 ; Scan != m_TypedBuffer->NumberOfHandles ; Scan += 1)
        {
            if (m_TypedBuffer->Handles[Scan].UniqueProcessId == pid)
            {
                if (Keep != Scan)
                    m_TypedBuffer->Handles[Keep] = m_TypedBuffer->Handles[Scan]; // struct copy
                Keep += 1;
            }
        }
        m_TypedBuffer->NumberOfHandles = Keep;
    }

    void Resync()
    {
        m_TypedBuffer = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION_EX>(&m_ByteBuffer[0]);
    }

    CHandleSnapshot(const CHandleSnapshot& x) : m_TypedBuffer(NULL)
    {
        this->m_ByteBuffer = x.m_ByteBuffer;
        Resync();
    }

    void operator=(const CHandleSnapshot& x)
    {
        this->m_ByteBuffer = x.m_ByteBuffer;
        Resync();
    }

    class CHandleValueOperatorLessThan
    {
    public:
        bool operator()(const SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX& x, const SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX& y)
        {
            return (x.HandleValue < y.HandleValue);
        }
    };

    void SortByHandleValue()
    {
        std::sort(begin(), end(), CHandleValueOperatorLessThan());
    }

    void operator-=(/*const*/CHandleSnapshot& x)
    {
        SortByHandleValue();
        x.SortByHandleValue();
        CHandleSnapshot temp(*this);
        resize(
            std::set_difference(temp.begin(), temp.end(), x.begin(), x.end(), begin(), CHandleValueOperatorLessThan())
            - begin());
    }

    void Dump()
    {
    }
};

class CHandleSnapshots
{
public:
    void Begin() { m_Begin.GetHandlesForCurrentProcess(); }
    void End() { m_End.GetHandlesForCurrentProcess(); m_Diff = m_Begin; m_Diff -= m_End; }

    CHandleSnapshot m_Begin;
    CHandleSnapshot m_End;
    CHandleSnapshot m_Diff;
};

#endif

void Pause()
{
    Trace("Press a key to continue\n");
    getchar();
}

void TestHandleLeaks()
{
#if 0
    WCHAR WindowsDirectory[MAX_PATH];
    ULONG i = 0;
    CFusionFile DevNull;
    //SECURITY_ATTRIBUTES SecurityAttributes = { sizeof(SecurityAttributes), NULL, TRUE};

    WindowsDirectory[0] = 0;

    DevNull = CreateFileW(L"nul:", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL/*&SecurityAttributes*/, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (DevNull == INVALID_HANDLE_VALUE)
        Trace("Open(nul:) failed %ld\n", ::GetLastError());

    GetWindowsDirectoryW(WindowsDirectory, NUMBER_OF(WindowsDirectory) - 64);

    {
        const WCHAR SubFunction[] = L"CreateActCtx";

        CHandleSnapshots handleSnapshots;
        handleSnapshots.Begin();
        Trace("%s Begin %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Begin.size());
        {
            WCHAR WindowsShellManifestFileName[MAX_PATH];
            ACTCTXW ActCtx = { sizeof(ActCtx) };
            HANDLE ActCtxHandle = 0;

            WindowsShellManifestFileName[0] = 0;
            wcscpy(WindowsShellManifestFileName, WindowsDirectory);
            wcscat(WindowsShellManifestFileName, L"\\WindowsShell.Manifest");
            ActCtx.lpSource = WindowsShellManifestFileName;

            for (i = 0 ; i != 100 ; ++i)
            {
                HANDLE ActCtxHandle = CreateActCtxW(&ActCtx);
                if (ActCtxHandle == INVALID_HANDLE_VALUE)
                    Trace("TestCreateActctxWindowsShellManifest: %p, %lu\n", ActCtxHandle, ::GetLastError());
                else
                    ReleaseActCtx(ActCtxHandle);
            }
        }
        handleSnapshots.End();
        Trace("%s End %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_End.size());

        if (handleSnapshots.m_Diff.size() != 0)
        {
            Trace("%s Diff %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Diff.size());
        }
    }

    Pause();
    {
        const WCHAR SubFunction[] = L"CreateActCtx + LoadLibrary(comctl32)";

        CHandleSnapshots handleSnapshots;
        handleSnapshots.Begin();
        Trace("%s Begin %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Begin.size());
        {
            WCHAR WindowsShellManifestFileName[MAX_PATH];
            ACTCTXW ActCtx = { sizeof(ActCtx) };
            HANDLE ActCtxHandle = 0;

            WindowsShellManifestFileName[0] = 0;
            wcscpy(WindowsShellManifestFileName, WindowsDirectory);
            wcscat(WindowsShellManifestFileName, L"\\WindowsShell.Manifest");
            ActCtx.lpSource = WindowsShellManifestFileName;

            for (i = 0 ; i != 100 ; ++i)
            {
                ULONG_PTR ulCookie = 0;

                HANDLE ActCtxHandle = CreateActCtxW(&ActCtx);
                if (ActCtxHandle == INVALID_HANDLE_VALUE)
                    Trace("TestCreateActctxWindowsShellManifest: %p, %lu\n", ActCtxHandle, ::GetLastError());
                else
                {
                    ActivateActCtx(ActCtxHandle, &ulCookie);
                    HMODULE Comctl = LoadLibraryW(L"comctl32.dll");
                    if (i == 1)
                    {
                        CHandleSnapshot handleSnapshot;
                        handleSnapshot.GetHandlesForCurrentProcess();
                        Trace("Comctl32.dll loaded first time %Id\n", handleSnapshot.size());
                        Pause();
                    }
                    FreeLibrary(Comctl);
                    if (i == 1)
                    {
                        CHandleSnapshot handleSnapshot;
                        handleSnapshot.GetHandlesForCurrentProcess();
                        Trace("Comctl32.dll unloaded first time %Id\n", handleSnapshot.size());
                        Pause();
                    }
                    if (ulCookie != 0)
                        DeactivateActCtx(0, ulCookie);
                    ReleaseActCtx(ActCtxHandle);
                    if (i == 1)
                    {
                        CHandleSnapshot handleSnapshot;
                        handleSnapshot.GetHandlesForCurrentProcess();
                        Trace("Comctl32.dll unloaded + ReleaseActCtxfirst time %Id\n", handleSnapshot.size());
                        Pause();
                    }
                }
            }
        }
        handleSnapshots.End();
        Trace("%s End %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_End.size());

        if (handleSnapshots.m_Diff.size() != 0)
        {
            Trace("%s Diff %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Diff.size());
        }
    }

    Pause();
    {
        WCHAR Me[MAX_PATH];
        STARTUPINFOW StartupInfo = {sizeof(StartupInfo)};
        PROCESS_INFORMATION ProcessInfo = {0};
        static const WCHAR SubFunction[] = L"CreateProcess";

        Kernel32.GetModuleFileNameW(NULL, Me, NUMBER_OF(Me));

        CHandleSnapshots handleSnapshots;
        handleSnapshots.Begin();
        Trace("%s Begin %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Begin.size());

        for (i = 0 ; i != 100 ; ++i)
        {
            StartupInfo.hStdOutput = DevNull;
            StartupInfo.hStdError = DevNull;
            StartupInfo.dwFlags = STARTF_USESTDHANDLES;

            if (!CreateProcessW(Me, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInfo))
            {
                Trace("CreateProcess failed %ld\n", ::GetLastError());
            }
            else
            {
                WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
                WaitForSingleObject(ProcessInfo.hThread, INFINITE);
                if (!CloseHandle(ProcessInfo.hProcess))
                    Trace("CloseHandle(Process %p) failed %ld\n", ProcessInfo.hProcess, ::GetLastError());
                if (!CloseHandle(ProcessInfo.hThread))
                    Trace("CloseHandle(Thread %p) failed %ld\n", ProcessInfo.hThread, ::GetLastError());
            }
        }
        handleSnapshots.End();
        Trace("%s End %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_End.size());

        if (handleSnapshots.m_Diff.size() != 0)
        {
            Trace("%s Diff %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Diff.size());
        }
    }
    Pause();
    {
        WCHAR SubFunction[sizeof("LoadLibrary xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")];
        WCHAR DllPath[MAX_PATH];
        ULONG j = 0;

        const static PCWSTR Leaves[] = {
            L"mshtml.dll",
            L"wintrust.dll",
            L"shell32.dll",
            L"crypt32.dll",
            L"msxml.dll",
            L"shdocvw.dll",
            L"msxml2.dll",
            L"msxml3.dll"
            };

        for (j = 0 ; j != NUMBER_OF(Leaves) ; ++j)
        {
            SubFunction[0] = 0;
            wcscat(SubFunction, L"LoadLibrary ");
            wcscat(SubFunction, Leaves[j]);

            DllPath[0] = 0;
            wcscat(DllPath, WindowsDirectory);
            wcscat(DllPath, L"\\system32\\");
            wcscat(DllPath, Leaves[j]);

            CHandleSnapshots handleSnapshots;
            handleSnapshots.Begin();
            Trace("%s Begin %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Begin.size());
            for (i = 0 ; i != 20 ; ++i)
            {
                HMODULE DllHandle;

                if ((DllHandle = LoadLibraryW(DllPath)) != NULL)
                    FreeLibrary(DllHandle);
                else
                    Trace("LoadLibraryW(%ls) failed %ld\n", DllPath, ::GetLastError());
            }
            handleSnapshots.End();
            Trace("%s End %ls : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_End.size());
            if (handleSnapshots.m_Diff.size() != 0)
            {
                Trace("%s Diff %s : %Id handles\n", __FUNCTION__, SubFunction, handleSnapshots.m_Diff.size());
            }
        }
    }
    Pause();
#endif
}

#define YET_ANOTHER_PASTE(x,y) x##y
#define YET_YET_ANOTHER_PASTE(x,y) YET_ANOTHER_PASTE(x,y)
#define LSXS_PROCESSOR_ARCHITECTURE YET_YET_ANOTHER_PASTE(L, SXS_PROCESSOR_ARCHITECTURE)

const WCHAR ToolsCrtManifest[]=
L"<?xml version=\"1.0\" standalone=\"yes\"?>"
L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
L"<assemblyIdentity"
L"    name=\"Microsoft.Windows.SxsTest.ToolsCrtClient\""
L"    processorArchitecture=\"" LSXS_PROCESSOR_ARCHITECTURE L"\"" /* Note that this only actually exists on x86 */
L"    version=\"5.1.0.0\""
L"    type=\"win32\"/>"
L"<dependency>"
L"    <dependentAssembly>"
L"        <assemblyIdentity"
L"            type=\"win32\""
L"            name=\"Microsoft.Tools.VisualCPlusPlus.Runtime-Libraries\""
L"            version=\"6.0.0.0\""
L"            processorArchitecture=\"" LSXS_PROCESSOR_ARCHITECTURE L"\""
L"            publicKeyToken=\"6595b64144ccf1df\""
L"            language=\"*\""
L"        />"
L"    </dependentAssembly>"
L"</dependency>"
L"</assembly>"
;

const WCHAR WindowsCrtManifest[]=
L"<?xml version=\"1.0\" standalone=\"yes\"?>"
L"<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">"
L"<assemblyIdentity"
L"    name=\"Microsoft.Windows.SxsTest.WindowsCrtClient\""
L"    processorArchitecture=\"" LSXS_PROCESSOR_ARCHITECTURE L"\""
L"    version=\"5.1.0.0\""
L"    type=\"win32\"/>"
L"<dependency>"
L"    <dependentAssembly>"
L"        <assemblyIdentity"
L"            type=\"win32\""
L"            name=\"Microsoft.Windows.CPlusPlusRuntime\""
L"            version=\"7.0.0.0\""
L"            processorArchitecture=\"" LSXS_PROCESSOR_ARCHITECTURE L"\""
L"            publicKeyToken=\"6595b64144ccf1df\""
L"            language=\"*\""
L"        />"
L"    </dependentAssembly>"
L"</dependency>"
L"</assembly>"
;

void TestCRuntimeAsms()
{
    CFusionActCtxHandle WindowsCrtActCtxHandle;
    CFusionActCtxHandle ToolsCrtActCtxHandle;

    WindowsCrtActCtxHandle = ::CreateActivationContextFromStringW(WindowsCrtManifest);
    if (WindowsCrtActCtxHandle == INVALID_HANDLE_VALUE)
        ::Trace("CreateActCtx(WindowsCrtManifest %p) failed %ld\n", WindowsCrtManifest, ::GetLastError());
    ToolsCrtActCtxHandle = ::CreateActivationContextFromStringW(ToolsCrtManifest);
    if (ToolsCrtActCtxHandle == INVALID_HANDLE_VALUE)
        ::Trace("CreateActCtx(WindowsCrtManifest %p) failed %ld\n", WindowsCrtManifest, ::GetLastError());

    CFusionActCtxScope ToolsCrtActCtxScope;
    CFusionActCtxScope WindowsCrtActCtxScope;

    if (!WindowsCrtActCtxScope.Win32Activate(WindowsCrtActCtxHandle))
        ::Trace("Activate(WindowsCrtActCtxHandle %p) failed %ld\n", WindowsCrtActCtxHandle, ::GetLastError());

    if (!ToolsCrtActCtxScope.Win32Activate(ToolsCrtActCtxHandle))
        ::Trace("Activate(ToolsCrtActCtxHandle %p) failed %ld\n", ToolsCrtActCtxHandle, ::GetLastError());

    CStringBuffer MsvcrtBuffer;
    CStringBuffer AtlBuffer;

    //::SearchPathW();
}

/*
    <comInterfaceExternalProxyStub
        name="IPropertyPage"
        iid="{B196B28D-BAB4-101A-B69C-00AA00341D07}"
        proxyStubClsid32="{B196B286-BAB4-101A-B69C-00AA00341D07}"
        numMethods="14"
        baseInterface="{00000000-0000-0000-C000-000000000046}"
    >

    <comInterfaceExternalProxyStub
        name="IPropertyPage2"
        iid="{01E44665-24AC-101B-84ED-08002B2EC713}"
        proxyStubClsid32="{B196B286-BAB4-101A-B69C-00AA00341D07}"
        numMethods="15"
        baseInterface="{B196B28D-BAB4-101A-B69C-00AA00341D07}"
    >

    <comInterfaceExternalProxyStub
        name="IPropertyNotifySink"
        iid="{9BFBBC02-EFF1-101A-84ED-00AA00341D07}"
        proxyStubClsid32="{B196B286-BAB4-101A-B69C-00AA00341D07}"
        baseInterface="{00000000-0000-0000-C000-00 00 00 00 00 46}"
        numMethods="5"
    >
*/

BOOL Win32Append(
    CBaseStringBuffer& s,
    PCWSTR             t
    )
{
    FN_PROLOG_WIN32
    IFW32FALSE_EXIT(s.Win32Append(t, wcslen(t)));
    FN_EPILOG
}

typedef struct _FUSIONTESTP_REG_DATA
{
#define FUSIONTESTP_REG_TYPE_INTERFACE (1)
#define FUSIONTESTP_REG_TYPE_CLASS     (2)
    ULONG  Type;
    PCWSTR Name; // for debugging/tracing purposes (should coincide with InterfaceName)
    PCWSTR Guid;
    union
    {
        struct
        {
            WCHAR  InprocServerFilePath[MAX_PATH];
            WCHAR  ThreadingModel[64];
        };
        struct
        {
            WCHAR  InterfaceName[MAX_PATH];
            WCHAR  NumMethods[64];
            WCHAR  ProxyStubClsid[64];
            //
            // These usually aren't provided.
            //
            // WCHAR BaseInterface[64];
            // WCHAR OLEViewerIViewerCLSID[64];
            //
        };
    };
#define FUSIONTESTP_REG_ROOT_CURRENT_USER  (1)
#define FUSIONTESTP_REG_ROOT_LOCAL_MACHINE (2)
#define FUSIONTESTP_REG_ROOT_CLASSES_ROOT  (3)
    ULONG  Root;

//
// It is perhaps a bit inelegant to put this data here, perhaps not..
// We are deliberately a bit sloppy on the refcounting of these right now.
//
//#define FUSIONTESTP_PLAIN_COM_POINTER(t) CSmartRef<t>
#define FUSIONTESTP_PLAIN_COM_POINTER(t) t*
//#define FUSIONTESTP_PLAIN_COM_POINTER(t) void*
    FUSIONTESTP_PLAIN_COM_POINTER(IUnknown)   CoCreatedObject;
    //FUSIONTESTP_PLAIN_COM_POINTER(IUnknown)   InterfaceIntoObjectInCreatingThread;
    //FUSIONTESTP_PLAIN_COM_POINTER(IUnknown)   InterfaceIntoObjectInAnotherThread;
    //WCHAR                               ModulePathInOtherThread[MAX_PATH]; // expected to be oleaut32.dll, but possibly already unloaded
    //IID                                 InterfaceIdOfObject;
    DWORD                               GlobalInterfaceTableCookie;
} FUSIONTESTP_REG_DATA, *PFUSIONTESTP_REG_DATA;
typedef const FUSIONTESTP_REG_DATA* PCFUSIONTESTP_REG_DATA;

#define OLEAUT_MARSHALER_CLSID_STRING L"{B196B286-BAB4-101A-B69C-00AA00341D07}"

FUSIONTESTP_REG_DATA FusionTestpMfcRegData[] =
{
    { FUSIONTESTP_REG_TYPE_CLASS, L"Font Property Page", L"{0BE35200-8F91-11CE-9DE3-00AA004BB851}" },
    { FUSIONTESTP_REG_TYPE_CLASS, L"Color Property Page", L"{0BE35201-8F91-11CE-9DE3-00AA004BB851}" },
    { FUSIONTESTP_REG_TYPE_CLASS, L"Picture Property Page", L"{0BE35202-8F91-11CE-9DE3-00AA004BB851}" },
    { FUSIONTESTP_REG_TYPE_INTERFACE, L"IPropertyPage",  L"{B196B28D-BAB4-101A-B69C-00AA00341D07}" },
    { FUSIONTESTP_REG_TYPE_INTERFACE, L"IPropertyPage2", L"{01E44665-24AC-101B-84ED-08002B2EC713}" },
    { FUSIONTESTP_REG_TYPE_INTERFACE, L"IPropertyNotifySink", L"{9BFBBC02-EFF1-101A-84ED-00AA00341D07}" },
    // Leave this registered, since the manifest does not specify a file.
    //{ FUSIONTESTP_REG_TYPE_CLASS,     L"oleaut32 marshaller (PSFactoryBuffer)", OLEAUT_MARSHALER_CLSID_STRING }
};

FUSIONTESTP_REG_DATA FusionTestpAtlRegData[1];

const HKEY FusionTestpHkeyRoots[] = { NULL, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT };
const PCWSTR FusionTestpClassStringRoots[] = { NULL, L"Software\\Classes\\CLSID\\", L"Software\\Classes\\CLSID\\", L"CLSID\\" };
const PCWSTR FusionTestpInterfaceStringRoots[] = { NULL, L"Software\\Classes\\Interface\\", L"Software\\Classes\\Interface\\", L"Interface\\" };
const PCWSTR* FusionTestpStringRoots[] = { NULL, FusionTestpInterfaceStringRoots, FusionTestpClassStringRoots};

#define FUSIONTESTP_REG_DELETE    (1)
#define FUSIONTESTP_REG_RESTORE   (2)
#define FUSIONTESTP_REG_BACKUP    (3)

BOOL FusionTestpEnumerateRegistryData(FUSIONTESTP_REG_DATA* RegData, ULONG Count, ULONG Mode)
{
    BOOL Success = FALSE;
    FN_PROLOG_WIN32(Success);

    for (ULONG i = 0 ; i != Count ; i += 1)
    {
        FUSIONTESTP_REG_DATA* const p = &RegData[i];
        ULONG MinRoot = 0;
        ULONG MaxRoot = 0;
        switch (Mode)
        {
        case FUSIONTESTP_REG_RESTORE:
        case FUSIONTESTP_REG_DELETE:
            MinRoot = p->Root;
            if (MinRoot == 0)
                continue;
            MaxRoot = MinRoot;
            break;
        case FUSIONTESTP_REG_BACKUP:
            MinRoot = 1;
            MaxRoot = 3;
            break;
        }
        //
        // It'd be nice if you could embed the if within a switch..
        //
        for (ULONG root = MinRoot ; root <= MaxRoot ; root += 1)
        {
            CFusionRegKey regKey;
            CFusionRegKey inprocServerKey;
            CStringBuffer stringBuffer;
            CFusionRegKey numMethodsKey;
            CFusionRegKey proxyStubClsidKey;
            DWORD dwSize = 0;
            DWORD dwType = 0;

            CFusionRegKey rootKey(FusionTestpHkeyRoots[root]);

            IFW32FALSE_EXIT(Win32Append(stringBuffer, FusionTestpStringRoots[p->Type][root]));
            IFW32FALSE_EXIT(Win32Append(stringBuffer, p->Guid));
            switch (Mode)
            {
            case FUSIONTESTP_REG_DELETE:
            case FUSIONTESTP_REG_BACKUP:
                rootKey.OpenSubKey(regKey, stringBuffer);
                break;
            case FUSIONTESTP_REG_RESTORE:
                IFW32FALSE_EXIT(rootKey.OpenOrCreateSubKey(regKey, stringBuffer));
                break;
            }
            if (regKey != regKey.GetInvalidValue())
            {
                switch (Mode)
                {
                case FUSIONTESTP_REG_BACKUP:
                    p->Root = root;
                    break;
                case FUSIONTESTP_REG_DELETE:
                case FUSIONTESTP_REG_RESTORE:
                    break;
                }
                switch (p->Type)
                {
                case FUSIONTESTP_REG_TYPE_CLASS:
                    switch (Mode)
                    {
                    case FUSIONTESTP_REG_BACKUP:
#define FusionTestpQueryRegString(hkey, name, value) \
    do { dwSize = sizeof(value); \
         RegQueryValueExW(hkey, name, NULL, &dwType, reinterpret_cast<BYTE*>(value), &dwSize); \
    } while(false)
                        if (regKey.OpenSubKey(inprocServerKey, L"InprocServer32"))
                        {
                            FusionTestpQueryRegString(inprocServerKey, NULL, p->InprocServerFilePath);
                            FusionTestpQueryRegString(inprocServerKey, L"ThreadingModel", p->ThreadingModel);
                        }
                        break;
                    case FUSIONTESTP_REG_RESTORE:
                        if (regKey.OpenOrCreateSubKey(inprocServerKey, L"InprocServer32"))
                        {
#define FusionTestpRegStringSize(x) static_cast<ULONG>(((wcslen(x) + 1)*sizeof((x)[0])))
#define FusionTestpSetRegString(hkey, name, value) \
    do { if (value[0] != 0) \
            RegSetValueExW(hkey, name, NULL, REG_SZ, reinterpret_cast<const BYTE*>(value), FusionTestpRegStringSize(value)); \
    } while(false)
                            FusionTestpSetRegString(inprocServerKey, NULL, p->InprocServerFilePath);
                            FusionTestpSetRegString(inprocServerKey, L"ThreadingModel", p->ThreadingModel);
                        }
                        break;
                    case FUSIONTESTP_REG_DELETE:
                        break;
                    }
                    break;
                case FUSIONTESTP_REG_TYPE_INTERFACE:
                    switch (Mode)
                    {
                    case FUSIONTESTP_REG_BACKUP:
                        FusionTestpQueryRegString(regKey, NULL, p->InterfaceName);
                        if (regKey.OpenSubKey(numMethodsKey, L"NumMethods"))
                            FusionTestpQueryRegString(numMethodsKey, NULL, p->NumMethods);
                        if (regKey.OpenSubKey(proxyStubClsidKey, L"ProxyStubClsid32"))
                            FusionTestpQueryRegString(proxyStubClsidKey, NULL, p->ProxyStubClsid);
                        break;
                    case FUSIONTESTP_REG_RESTORE:
                        FusionTestpSetRegString(regKey, NULL, p->InterfaceName);
                        if (regKey.OpenOrCreateSubKey(numMethodsKey, L"NumMethods"))
                            FusionTestpSetRegString(numMethodsKey, NULL, p->NumMethods);
                        if (regKey.OpenOrCreateSubKey(proxyStubClsidKey, L"ProxyStubClsid32"))
                            FusionTestpSetRegString(proxyStubClsidKey, NULL, p->ProxyStubClsid);
                    case FUSIONTESTP_REG_DELETE:
                        break;
                    }
                    break;
                }
                switch (Mode)
                {
                case FUSIONTESTP_REG_DELETE:
                    regKey.DestroyKeyTree();
                    break;
                case FUSIONTESTP_REG_BACKUP:
                case FUSIONTESTP_REG_RESTORE:
                    break;
                }
                break;
            }
        }
    }
    FN_EPILOG
}

HMODULE FusionTestpHmoduleFromComObject(IUnknown* unk)
{
    void** ppv = reinterpret_cast<void**>(unk);
    void* pv = *ppv;
    MEMORY_BASIC_INFORMATION MemBasicInfo = { 0 };
    SIZE_T dw = 0;

    if ((dw = Kernel32.VirtualQuery(pv, &MemBasicInfo, sizeof(MemBasicInfo))) == 0
        || (dw < RTL_SIZEOF_THROUGH_FIELD(MEMORY_BASIC_INFORMATION, BaseAddress)))
    {
        ::Trace("VirtualQuery(%p) failed %lu\n", pv, ::GetLastError());
        return NULL;
    }
    return reinterpret_cast<HMODULE>(MemBasicInfo.AllocationBase);
}


DWORD WINAPI FusionTestpMfcCreateAndMarshalThreadMain(LPVOID pvShouldBeAbleToMarshal)
{
    BOOL Success = FALSE;
    FN_PROLOG_WIN32(Success);
    HRESULT hr = 0;
    const bool ShouldBeAbleToMarshal = (pvShouldBeAbleToMarshal != NULL ? true : false);
    Ole32.CoInitialize(NULL);

    //
    // For each interface, make sure we can unmarshal at least one object.
    //
    for (ULONG InterfaceIndex = 0 ; InterfaceIndex != NUMBER_OF(::FusionTestpMfcRegData) ; InterfaceIndex += 1)
    {
        FUSIONTESTP_REG_DATA* const pi = &::FusionTestpMfcRegData[InterfaceIndex];

        switch (pi->Type)
        {
        case FUSIONTESTP_REG_TYPE_CLASS:
            continue;
        case FUSIONTESTP_REG_TYPE_INTERFACE:
            IID InterfaceId = { 0 };
            FUSIONTESTP_PLAIN_COM_POINTER(IUnknown) InterfaceIntoObjectInAnotherThread = NULL;

            IFCOMFAILED_EXIT(hr = Ole32.IIDFromString(const_cast<PWSTR>(pi->Guid), &InterfaceId));

            // nested loop..
            for (ULONG ClassIndex = 0 ;
                ClassIndex != NUMBER_OF(::FusionTestpMfcRegData) ;
                ClassIndex += 1)
            {
                CLSID ClassId = { 0 };
                FUSIONTESTP_REG_DATA* const pc = &::FusionTestpMfcRegData[ClassIndex];

                switch (pc->Type)
                {
                case FUSIONTESTP_REG_TYPE_INTERFACE:
                    continue;
                case FUSIONTESTP_REG_TYPE_CLASS:

                    WCHAR ModulePathInOtherThread[MAX_PATH];
                    ModulePathInOtherThread[0] = 0;

                    ASSERT(pc->GlobalInterfaceTableCookie != 0);
                    IFCOMFAILED_EXIT(hr = Ole32.CLSIDFromString(const_cast<PWSTR>(pc->Guid), &ClassId));

                    hr = g.GlobalInterfaceTable->GetInterfaceFromGlobal(
                        pc->GlobalInterfaceTableCookie, InterfaceId,
                        reinterpret_cast<void**>(&InterfaceIntoObjectInAnotherThread));

                    if (SUCCEEDED(hr))
                    {
                        IFW32FALSE_EXIT(Kernel32.GetModuleFileNameW(
                            ::FusionTestpHmoduleFromComObject(InterfaceIntoObjectInAnotherThread),
                            ModulePathInOtherThread, NUMBER_OF(ModulePathInOtherThread)));
                    }
                    if (SUCCEEDED(hr) && ShouldBeAbleToMarshal)
                    {
                        Trace("%s SUCCESSfully marshaled interface %ls on class %ls using proxy/stub in %ls\n",
                            __FUNCTION__, pi->Name, pc->Name, ModulePathInOtherThread);
                        g.Successes += 1;
                    }
                    else if (SUCCEEDED(hr) && !ShouldBeAbleToMarshal)
                    {
                        // unexpected success -> ERROR

                        Trace("%s FAILED to fail to marshal interface %ls on class %ls (using proxy/stub in %ls)\n",
                            __FUNCTION__, pi->Name, pc->Name, ModulePathInOtherThread);
                        g.Failures += 1;
                    }
                    else if (FAILED(hr) && ShouldBeAbleToMarshal)
                    {
                        // keep looping, try other objects
                    }
                    else if (FAILED(hr) && !ShouldBeAbleToMarshal)
                    {
                        // keep looping, make sure none succeed
                        //::Trace("%s OK Unable to marshal interface %ls (%ls) 0x%lx (fac 0x%lx code 0x%lx)\n", __FUNCTION__, pi->Name, pi->Guid, hr, HRESULT_FACILITY(hr), HRESULT_CODE(hr));
                    }
                    break;
                }
                if (InterfaceIntoObjectInAnotherThread != NULL && ShouldBeAbleToMarshal)
                {
                    // one successful unmarshal is enough
                    break;
                }
            }
            // use the nullness of InterfaceIntoObjectInAnotherThread as a summary of the loop
            if (InterfaceIntoObjectInAnotherThread == NULL && ShouldBeAbleToMarshal)
            {
                ::Trace("%s FAILURE Unable to marshal interface %ls (%ls)\n", __FUNCTION__, pi->Name, pi->Guid);
                g.Failures += 1;
            }
            else if (InterfaceIntoObjectInAnotherThread == NULL && !ShouldBeAbleToMarshal)
            {
                ::Trace("%s GOOD Unable to marshal interface %ls without actctx as expected\n", __FUNCTION__, pi->Name);
                g.Successes += 1;
            }
            break;
        }
    }
    Ole32.CoUninitialize();
    FN_EPILOG
}

BOOL TestMfcCreateAndMarshal()
{
    BOOL Success = FALSE;
    FN_PROLOG_WIN32(Success);

    ULONG i = 0;
    HRESULT hr = 0;
    HANDLE ThreadHandle = 0;
    DWORD Ignored = 0;

    CFusionActCtxHandle ToolsCrtActCtxHandle;

    ::FusionTestpEnumerateRegistryData(::FusionTestpMfcRegData, NUMBER_OF(::FusionTestpMfcRegData), FUSIONTESTP_REG_BACKUP);
    ::FusionTestpEnumerateRegistryData(::FusionTestpMfcRegData, NUMBER_OF(::FusionTestpMfcRegData), FUSIONTESTP_REG_DELETE);

    Ole32.CoInitialize(NULL);

    //
    // Verify that we cannot create any of the classes.
    //
    for (i = 0 ; i != NUMBER_OF(::FusionTestpMfcRegData) ; i += 1)
    {
        CSmartRef<IUnknown> unk;
        CLSID ClassId = { 0 };

        FUSIONTESTP_REG_DATA* const p = &::FusionTestpMfcRegData[i];
        switch (p->Type)
        {
        case FUSIONTESTP_REG_TYPE_INTERFACE:
            break;
        case FUSIONTESTP_REG_TYPE_CLASS:
            IFCOMFAILED_EXIT(hr = Ole32.CLSIDFromString(const_cast<PWSTR>(p->Guid), &ClassId));
            hr = Ole32.CoCreateInstance(ClassId, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, reinterpret_cast<void**>(&unk));
            if (SUCCEEDED(hr))
            {
                ::Trace("%s BAD, no registry, no actctx CoCreate(%ls) SUCCEEDED, not expected\n", __FUNCTION__, p->Name);
                g.Failures += 1;
            }
            else
            {
                ::Trace("%s GOOD, no registry, no actctx CoCreate(%ls) FAILed 0x%lx, as expected\n", __FUNCTION__, p->Name, hr);
                g.Successes += 1;
            }
            break;
        }
    }

    //
    // Create and activate the context.
    //

    ToolsCrtActCtxHandle = ::CreateActivationContextFromStringW(ToolsCrtManifest);
    if (ToolsCrtActCtxHandle == INVALID_HANDLE_VALUE)
        ::Trace("CreateActCtx(WindowsCrtManifest %p) failed %ld\n", WindowsCrtManifest, ::GetLastError());

    {
        CFusionActCtxScope ToolsCrtActCtxScope;
        if (!ToolsCrtActCtxScope.Win32Activate(ToolsCrtActCtxHandle))
            ::Trace("Activate(ToolsCrtActCtxHandle %p) failed %ld\n", ToolsCrtActCtxHandle, ::GetLastError());

        //
        // Now create each class and print the .dll it came from.
        // And put it in the global interface table for later unmarshalling.
        //

        IFCOMFAILED_EXIT(hr = Ole32.CoCreateInstance(CLSID_StdGlobalInterfaceTable,NULL, CLSCTX_INPROC_SERVER,
            IID_IGlobalInterfaceTable, reinterpret_cast<void**>(&g.GlobalInterfaceTable)));

        for (i = 0 ; i != NUMBER_OF(::FusionTestpMfcRegData)  ; i += 1)
        {
            CLSID ClassId = { 0 };

            FUSIONTESTP_REG_DATA* const p = &::FusionTestpMfcRegData[i];

            //
            // We are not supposed to be able to cocreate this here.
            //
            if (FusionpStrCmpI(p->Guid, OLEAUT_MARSHALER_CLSID_STRING) == 0)
                continue;

            switch (p->Type)
            {
            case FUSIONTESTP_REG_TYPE_INTERFACE:
                break;
            case FUSIONTESTP_REG_TYPE_CLASS:
                IFCOMFAILED_EXIT(hr = Ole32.CLSIDFromString(const_cast<PWSTR>(p->Guid), &ClassId));
                hr = Ole32.CoCreateInstance(ClassId, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown,
                    reinterpret_cast<void**>(&p->CoCreatedObject));
                if (FAILED(hr))
                {
                    Trace("%s Failure: CoCreate(%ls) FAILED\n", __FUNCTION__, p->Name);
                    g.Failures += 1;
                }
                else
                {
                    WCHAR ComObjectModule[MAX_PATH];
                    ComObjectModule[0] = 0;

                    IFW32FALSE_EXIT(Kernel32.GetModuleFileNameW(
                        ::FusionTestpHmoduleFromComObject(p->CoCreatedObject), ComObjectModule, NUMBER_OF(ComObjectModule)));
                    Trace("%s SUCCESSfully cocreated %p of type %ls from %ls with actctx influence\n",
                        __FUNCTION__, p->CoCreatedObject, p->Name, ComObjectModule);

                    g.Successes += 1;

                    //
                    // It'll still have to look for the proxy/stub at unmarshal time. This is fine.
                    //
                    IFCOMFAILED_EXIT(hr = g.GlobalInterfaceTable->RegisterInterfaceInGlobal(
                        p->CoCreatedObject,
                        IID_IUnknown,
                        &p->GlobalInterfaceTableCookie
                        ));
                }
                break;
            }
        }
    }

    {
        CFusionActCtxScope ToolsCrtActCtxScope;
        if (!ToolsCrtActCtxScope.Win32Activate(ToolsCrtActCtxHandle))
            ::Trace("Activate(ToolsCrtActCtxHandle %p) failed %ld\n", ToolsCrtActCtxHandle, ::GetLastError());
        //
        // try marshalling with the actctx activated, it should work (not NULL => expected success==TRUE)
        //
        ThreadHandle = CreateThread(NULL, 0, FusionTestpMfcCreateAndMarshalThreadMain, &Ignored, 0, &Ignored);
        CoWaitForMultipleHandles(0, INFINITE, 1, &ThreadHandle, &Ignored);
        CloseHandle(ThreadHandle);
    }

    Ole32.CoUninitialize();

    //::FusionTestpEnumerateRegistryData(::FusionTestpMfcRegData, NUMBER_OF(::FusionTestpMfcRegData), FUSIONTESTP_REG_RESTORE);

    FN_EPILOG
}


void TestAtlCreate()
{
    ::FusionTestpEnumerateRegistryData(FusionTestpAtlRegData, NUMBER_OF(FusionTestpAtlRegData), FUSIONTESTP_REG_BACKUP);
    ::FusionTestpEnumerateRegistryData(FusionTestpAtlRegData, NUMBER_OF(FusionTestpAtlRegData), FUSIONTESTP_REG_DELETE);

    ::FusionTestpEnumerateRegistryData(FusionTestpAtlRegData, NUMBER_OF(FusionTestpAtlRegData), FUSIONTESTP_REG_RESTORE);
}

BOOL TestPrivateSha1Impl(
    PCWSTR pcwszDirName
    )
{
    FN_PROLOG_WIN32

    CFusionArray<BYTE> rgbShaState;
    CSmallStringBuffer sbHashedString;
    CSmallStringBuffer sbFileName;

    IFW32FALSE_EXIT(sbFileName.Win32Assign(pcwszDirName, ::wcslen(pcwszDirName)));
    IFW32FALSE_EXIT(SxspCreateFileHash(0, CALG_SHA1, sbFileName, rgbShaState));
    IFW32FALSE_EXIT(SxspHashBytesToString(rgbShaState.GetArrayPtr(), rgbShaState.GetSize(), sbHashedString));
    wprintf(
        L"%ls hashed via sxspcreatefilehash to %ls\r\n",
        static_cast<PCWSTR>(sbFileName),
        static_cast<PCWSTR>(sbHashedString));

    FN_EPILOG
}

void TestAlignment()
{
    CCleanupBase* p = reinterpret_cast<CCleanupBase*>(ULONG_PTR(0xffff0000));
    SLIST_ENTRY* q = p;

    printf("%p %Ix\n", q, ULONG_PTR(q) % 16);
}

void TestCreateActCtx_PE_flags0()
{
    WCHAR SyssetupDll[MAX_PATH * 2];
    ACTCTXW ActCtx = {sizeof(ActCtx)};
    CFusionActCtxHandle ActCtxHandle;

    GetSystemDirectoryW(SyssetupDll, MAX_PATH);
    wcscat(SyssetupDll, L"\\syssetup.dll");
    ActCtx.lpSource = SyssetupDll;

    printf("%s\n", ActCtxHandle.Win32Create(&ActCtx) ? "true" : "false");
}

void
TestUninstall(
    PCWSTR ManifestPath,
    PCWSTR ReferenceString
    )
{
    SXS_UNINSTALLW UninstallParameters = {sizeof(UninstallParameters)};
    SXS_INSTALL_REFERENCEW Reference = {sizeof(Reference)};
    DWORD Disposition = 0;
    BOOL  Success = FALSE;
    CFusionArray<BYTE> ManifestInformationBuffer;
    if (!ManifestInformationBuffer.Win32SetSize(1UL << 16))
        return;
    const PSXS_MANIFEST_INFORMATION_BASIC ManifestBasicInfo = reinterpret_cast<PSXS_MANIFEST_INFORMATION_BASIC>(&ManifestInformationBuffer[0]);

    LoadSxs();

    Success = (*g_pfnQueryManifestInformation)(0, ManifestPath,
                SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC, 0, ManifestInformationBuffer.GetSize(),
                ManifestBasicInfo, NULL);

    printf("QueryManifestInformation(%ls)->(%ls, %ls)\n", ManifestPath, ManifestBasicInfo->lpIdentity, ManifestBasicInfo->lpShortName);

    UninstallParameters.dwFlags |= SXS_UNINSTALL_FLAG_REFERENCE_VALID;
    UninstallParameters.lpInstallReference = &Reference;
    UninstallParameters.lpAssemblyIdentity = ManifestBasicInfo->lpIdentity;

    Reference.lpIdentifier = ReferenceString;
    Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;

    Success = (*g_pfnSxsUninstallW)(&UninstallParameters, &Disposition);

    printf("TestUninstall(%ls, %ls) : %s, 0x%lx\n", ManifestPath, ReferenceString, Success ? "true" : "false", Disposition);
}

BOOL
TestNewSxsInstallAPI(
    PCWSTR pcwszManifest
)
{
    BOOL fSuccess = FALSE;
    SXS_INSTALLW Info = {sizeof(Info)};
    SXS_INSTALL_REFERENCEW Reference = {sizeof(Reference)};
    SXS_UNINSTALLW Uninstall = {sizeof(Uninstall)};
    DWORD dwDisposition;

    Info.dwFlags = SXS_INSTALL_FLAG_REPLACE_EXISTING |
        SXS_INSTALL_FLAG_REFERENCE_VALID |
        SXS_INSTALL_FLAG_CODEBASE_URL_VALID |
        SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID;
    Info.lpManifestPath = pcwszManifest;
    Info.lpCodebaseURL = Info.lpManifestPath;
    Info.lpReference = &Reference;
    Info.lpLogFileName = L"c:\\thelogfile";

    DWORD dwAttribute = ::GetFileAttributesW(pcwszManifest);
    if ( dwAttribute == 0xffffffff)  // non-exist
        goto Exit;
    if ( dwAttribute & FILE_ATTRIBUTE_DIRECTORY) // install from a directory recursively
    {
        Info.dwFlags |= SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE;
    }

    Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;
    Reference.lpIdentifier = L"Sxs installation";

    // init the log file
    if (::GetFileAttributesW(Info.lpLogFileName) != (DWORD)(-1))
    {
        ::DeleteFileW(Info.lpLogFileName);
    }

    LoadSxs();

    if (!(*g_pfnSxsInstallW)(&Info))
    {
        goto Exit;
    }

    Uninstall.dwFlags = SXS_UNINSTALL_FLAG_USE_INSTALL_LOG;
    Uninstall.lpInstallLogFile = L"c:\\thelogfile";

    if (!(*g_pfnSxsUninstallW)(&Uninstall, &dwDisposition))
    {
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    if (!fSuccess)
    {
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
        return EXIT_FAILURE;
    }
    else
        return EXIT_SUCCESS;
}

void DumpXmlErrors()
{
#define ENTRY(x) printf("%s 0x%lx\n", #x, x);
    ENTRY(XML_E_PARSEERRORBASE)
    ENTRY(XML_E_ENDOFINPUT)
    ENTRY(XML_E_MISSINGEQUALS)
    ENTRY(XML_E_MISSINGQUOTE)
    ENTRY(XML_E_COMMENTSYNTAX)
    ENTRY(XML_E_BADSTARTNAMECHAR)
    ENTRY(XML_E_BADNAMECHAR)
    ENTRY(XML_E_BADCHARINSTRING)
    ENTRY(XML_E_XMLDECLSYNTAX)
    ENTRY(XML_E_BADCHARDATA)
    ENTRY(XML_E_MISSINGWHITESPACE)
    ENTRY(XML_E_EXPECTINGTAGEND)
    ENTRY(XML_E_BADCHARINDTD)
    ENTRY(XML_E_BADCHARINDECL)
    ENTRY(XML_E_MISSINGSEMICOLON)
    ENTRY(XML_E_BADCHARINENTREF)
    ENTRY(XML_E_UNBALANCEDPAREN)
    ENTRY(XML_E_EXPECTINGOPENBRACKET)
    ENTRY(XML_E_BADENDCONDSECT)
    ENTRY(XML_E_INTERNALERROR)
    ENTRY(XML_E_UNEXPECTED_WHITESPACE)
    ENTRY(XML_E_INCOMPLETE_ENCODING)
    ENTRY(XML_E_BADCHARINMIXEDMODEL)
    ENTRY(XML_E_MISSING_STAR)
    ENTRY(XML_E_BADCHARINMODEL)
    ENTRY(XML_E_MISSING_PAREN)
    ENTRY(XML_E_BADCHARINENUMERATION)
    ENTRY(XML_E_PIDECLSYNTAX)
    ENTRY(XML_E_EXPECTINGCLOSEQUOTE)
    ENTRY(XML_E_MULTIPLE_COLONS)
    ENTRY(XML_E_INVALID_DECIMAL)
    ENTRY(XML_E_INVALID_HEXIDECIMAL)
    ENTRY(XML_E_INVALID_UNICODE)
    ENTRY(XML_E_WHITESPACEORQUESTIONMARK)
    ENTRY(XML_E_TOKEN_ERROR)
    ENTRY(XML_E_SUSPENDED)
    ENTRY(XML_E_STOPPED)
    ENTRY(XML_E_UNEXPECTEDENDTAG)
    ENTRY(XML_E_UNCLOSEDTAG)
    ENTRY(XML_E_DUPLICATEATTRIBUTE)
    ENTRY(XML_E_MULTIPLEROOTS)
    ENTRY(XML_E_INVALIDATROOTLEVEL)
    ENTRY(XML_E_BADXMLDECL)
    ENTRY(XML_E_MISSINGROOT)
    ENTRY(XML_E_UNEXPECTEDEOF)
    ENTRY(XML_E_BADPEREFINSUBSET)
    ENTRY(XML_E_PE_NESTING)
    ENTRY(XML_E_INVALID_CDATACLOSINGTAG)
    ENTRY(XML_E_UNCLOSEDPI)
    ENTRY(XML_E_UNCLOSEDSTARTTAG)
    ENTRY(XML_E_UNCLOSEDENDTAG)
    ENTRY(XML_E_UNCLOSEDSTRING)
    ENTRY(XML_E_UNCLOSEDCOMMENT)
    ENTRY(XML_E_UNCLOSEDDECL)
    ENTRY(XML_E_UNCLOSEDMARKUPDECL)
    ENTRY(XML_E_UNCLOSEDCDATA)
    ENTRY(XML_E_BADDECLNAME)
    ENTRY(XML_E_BADEXTERNALID)
    ENTRY(XML_E_BADELEMENTINDTD)
    ENTRY(XML_E_RESERVEDNAMESPACE)
    ENTRY(XML_E_EXPECTING_VERSION)
    ENTRY(XML_E_EXPECTING_ENCODING)
    ENTRY(XML_E_EXPECTING_NAME)
    ENTRY(XML_E_UNEXPECTED_ATTRIBUTE)
    ENTRY(XML_E_ENDTAGMISMATCH)
    ENTRY(XML_E_INVALIDENCODING)
    ENTRY(XML_E_INVALIDSWITCH)
    ENTRY(XML_E_EXPECTING_NDATA)
    ENTRY(XML_E_INVALID_MODEL)
    ENTRY(XML_E_INVALID_TYPE)
    ENTRY(XML_E_INVALIDXMLSPACE)
    ENTRY(XML_E_MULTI_ATTR_VALUE)
    ENTRY(XML_E_INVALID_PRESENCE)
    ENTRY(XML_E_BADXMLCASE)
    ENTRY(XML_E_CONDSECTINSUBSET)
    ENTRY(XML_E_CDATAINVALID)
    ENTRY(XML_E_INVALID_STANDALONE)
    ENTRY(XML_E_UNEXPECTED_STANDALONE)
    ENTRY(XML_E_DOCTYPE_IN_DTD)
    ENTRY(XML_E_MISSING_ENTITY)
    ENTRY(XML_E_ENTITYREF_INNAME)
    ENTRY(XML_E_DOCTYPE_OUTSIDE_PROLOG)
    ENTRY(XML_E_INVALID_VERSION)
    ENTRY(XML_E_DTDELEMENT_OUTSIDE_DTD)
    ENTRY(XML_E_DUPLICATEDOCTYPE)
    ENTRY(XML_E_RESOURCE)
    ENTRY(XML_E_LASTERROR)
#undef ENTRY
}

class CStringGuidPair
{
public:
    UNICODE_STRING  String;
    const GUID *    Guid;
};

class CStringIntegerPair
{
public:
    UNICODE_STRING String;
    ULONG          Integer;
};

const CStringGuidPair StringToClassIdMap[] =
{
    { RTL_CONSTANT_STRING(L"F"), &CLSID_CSxsTest_FreeThreaded },
    { RTL_CONSTANT_STRING(L"S"), &CLSID_CSxsTest_SingleThreaded },
    { RTL_CONSTANT_STRING(L"A"), &CLSID_CSxsTest_ApartmentThreaded },
    { RTL_CONSTANT_STRING(L"B"), &CLSID_CSxsTest_BothThreaded },

    { RTL_CONSTANT_STRING(L"Free"), &CLSID_CSxsTest_FreeThreaded },
    { RTL_CONSTANT_STRING(L"Single"), &CLSID_CSxsTest_SingleThreaded },
    { RTL_CONSTANT_STRING(L"Apartment"), &CLSID_CSxsTest_ApartmentThreaded },
    { RTL_CONSTANT_STRING(L"Apt"), &CLSID_CSxsTest_ApartmentThreaded },
    { RTL_CONSTANT_STRING(L"Both"), &CLSID_CSxsTest_BothThreaded },

    { RTL_CONSTANT_STRING(L"FreeThreaded"), &CLSID_CSxsTest_FreeThreaded },
    { RTL_CONSTANT_STRING(L"SingleThreaded"), &CLSID_CSxsTest_SingleThreaded },
    { RTL_CONSTANT_STRING(L"ApartmentThreaded"), &CLSID_CSxsTest_ApartmentThreaded },
    { RTL_CONSTANT_STRING(L"AptThreaded"), &CLSID_CSxsTest_ApartmentThreaded },
    { RTL_CONSTANT_STRING(L"BothThreaded"), &CLSID_CSxsTest_BothThreaded }
};

#define FUSIONP_COINIT_SINGLE_THREADED (ULONG(~(COINIT_APARTMENTTHREADED | COINIT_MULTITHREADED)))

const CStringIntegerPair StringToCoinitMap[] =
{
    { RTL_CONSTANT_STRING(L"A"), COINIT_APARTMENTTHREADED },
    { RTL_CONSTANT_STRING(L"M"), COINIT_MULTITHREADED },

    { RTL_CONSTANT_STRING(L"S"), FUSIONP_COINIT_SINGLE_THREADED },
    { RTL_CONSTANT_STRING(L"STA"), FUSIONP_COINIT_SINGLE_THREADED },
    { RTL_CONSTANT_STRING(L"Single"), FUSIONP_COINIT_SINGLE_THREADED },
    { RTL_CONSTANT_STRING(L"SingleThreaded"), FUSIONP_COINIT_SINGLE_THREADED },

    { RTL_CONSTANT_STRING(L"MTA"), COINIT_APARTMENTTHREADED },
    { RTL_CONSTANT_STRING(L"FTA"), COINIT_MULTITHREADED },

    { RTL_CONSTANT_STRING(L"Apartment"), COINIT_APARTMENTTHREADED },
    { RTL_CONSTANT_STRING(L"Multi"), COINIT_MULTITHREADED },
    { RTL_CONSTANT_STRING(L"Multiple"), COINIT_MULTITHREADED },
    { RTL_CONSTANT_STRING(L"ApartmentThreaded"), COINIT_APARTMENTTHREADED },
    { RTL_CONSTANT_STRING(L"MultiThreaded"), COINIT_MULTITHREADED },
    { RTL_CONSTANT_STRING(L"MultipleThreaded"), COINIT_MULTITHREADED }
};

BOOL StringToGuid(PCUNICODE_STRING s, const CStringGuidPair * rg, ULONG n, bool & Found, GUID & Value)
{
    // dumb linear search..
    ULONG i = 0;
    Found = false;
    for ( i = 0 ; i != n ; ++i)
    {
        if (FusionpEqualStringsI(s, &rg[i].String))
        {
            Found = true;
            Value = *rg[i].Guid;
            break;
        }
    }
    return TRUE;
}

BOOL StringToClsid(PCUNICODE_STRING s, bool & Found, CLSID & Value)
{
    return StringToGuid(s, StringToClassIdMap, NUMBER_OF(StringToClassIdMap), Found, Value);
}

BOOL StringToInteger(PCUNICODE_STRING s, const CStringIntegerPair * rg, ULONG n, bool & Found, ULONG & Value)
{
    // dumb linear search..
    ULONG i = 0;
    Found = false;
    for (i = 0 ; i != n ; ++i)
    {
        if (FusionpEqualStringsI(s, &rg[i].String))
        {
            Found = true;
            Value = rg[i].Integer;
            break;
        }
    }
    return TRUE;
}

BOOL StringToCoinit(PCUNICODE_STRING s, bool & Found, ULONG & Value)
{
    return StringToInteger(s, StringToCoinitMap, NUMBER_OF(StringToCoinitMap), Found, Value);
}

class CArgvMap
{
public:
    UNICODE_STRING   ArgName;
    UNICODE_STRING * ArgValue;
};

BOOL ProcessArgvMap(wchar_t ** argv, CArgvMap * map, ULONG n)
{
    for (PCWSTR arg = *argv ; arg = *argv ; ++argv)
    {
        arg += (wcschr(L"-/:", *arg) != NULL); // skip these chars
        CUnicodeString ArgString(arg);
        for (ULONG i = 0 ; i != n ; ++i)
        {
            if (RtlPrefixUnicodeString(&map[i].ArgName, &ArgString, TRUE))
            {
                arg = arg + RTL_STRING_GET_LENGTH_CHARS(&map[i].ArgName);
                arg += (wcschr(L":=", *arg) != NULL); // skip these chars
                FusionpRtlInitUnicodeString(map[i].ArgValue, arg);
                break;
            }
        }
    }
    return TRUE;
}

BOOL TestCoCreate(wchar_t ** argv)
{
    UNICODE_STRING CoinitString = { 0 };
    UNICODE_STRING ClsidString = { 0 };
    CLSID Clsid = GUID_NULL;
    ULONG Coinit = ~0UL;
    bool  CoinitFound = false;
    bool  ClsidFound = false;
    BOOL  Success = FALSE;
    HRESULT hrCoinit = 0;
    HRESULT hrCoCreate = 0;
    ::ATL::CComPtr<IUnknown> Unknown;

    CArgvMap ArgvMap[] =
    {
        { RTL_CONSTANT_STRING(L"coinit"), &CoinitString },
        { RTL_CONSTANT_STRING(L"clsid"), &ClsidString },
    };

    if (!ProcessArgvMap(argv, ArgvMap, NUMBER_OF(ArgvMap)))
        goto Exit;

    if (!StringToCoinit(&CoinitString, CoinitFound, Coinit))
        goto Exit;

    if (!StringToClsid(&ClsidString, ClsidFound, Clsid))
        goto Exit;

    switch (Coinit)
    {
    default:
        goto Exit;

    case FUSIONP_COINIT_SINGLE_THREADED:
        hrCoinit = CoInitialize(NULL);

    case COINIT_APARTMENTTHREADED:
    case COINIT_MULTITHREADED:
        hrCoinit = CoInitializeEx(NULL, Coinit);
        break;
    }
    if (FAILED(hrCoinit))
        goto Exit;

    hrCoCreate = CoCreateInstance(Clsid, NULL, CLSCTX_ALL, IID_IUnknown, reinterpret_cast<void**>(&Unknown));
    if (FAILED(hrCoCreate))
        goto Exit;

    Success = TRUE;
Exit:
    return Success;
}


#define WINFUSIONB_DFS_SERVER_NAME          L"\\\\xiaoyuw-1"
#define WINFUSIONB_DFS_SERVER_SHARE_NAME    L"BuildLabRelease"
#define WINFUSIONB_DFS_SERVER_COMMENT       L"test on xiaoyuw-1"

#define NEWNAME_XIAOYUW_1                   L"\\\\xiaoyuw-1\\BuildLabRelease\\release"
#define NEWNAME_XIAOYUW_DEV                 L"\\\\xiaoyuw-dev\\release\\1"

#define X86CHK_SHARELINK_NAME               L"x86chk"
#define X86FRE_SHARELINK_NAME               L"x86fre"

VOID TestDFS()
{
    //
    // create dfs root at a physical server
    //
    DWORD res;
    res = NetDfsAddStdRoot(
      WINFUSIONB_DFS_SERVER_NAME,
      WINFUSIONB_DFS_SERVER_SHARE_NAME,
      WINFUSIONB_DFS_SERVER_COMMENT,
      0);

    if ((res != ERROR_SUCCESS) && (res != ERROR_FILE_EXISTS))
    {
        printf("NetDfsAddStdRoot");
        goto Exit;
    }

    res = NetDfsAddStdRoot(
            L"\\\\xiaoyuw-dev",
            L"release",
            NULL,
            0);

    if ((res != ERROR_SUCCESS) && (res != ERROR_FILE_EXISTS))
    {
        printf("NetDfsAddStdRoot");
        goto Exit;
    }

    //
    // create Links
    //
    res = NetDfsAdd(
          L"\\\\xiaoyuw-dev\\release\\1",
          L"\\\\xiaoyuw-1\\BuildLabRelease",
          L"x86chk",
          NULL, 0);

    if ( res != ERROR_SUCCESS)
    {
        printf("NetDfsAddStdRoot");
        goto Exit;
    }

    printf("GOOD");
Exit:
    return;

}

void FusionpSystemTimeToCrtTm(const SYSTEMTIME & st, struct tm & tm)
{
/*
tm_hour Hours since midnight (0 - 23)
tm_isdst Positive if daylight saving time is in effect; 0 if daylight saving time is not in effect; negative if status of daylight saving time is unknown. The C run-time library assumes the United Statess rules for implementing the calculation of Dayligh
t Saving Time (DST).
tm_mday Day of month (1 - 31)
tm_min Minutes after hour (0 - 59)
tm_mon Month (0 - 11; January = 0)
tm_sec Seconds after minute (0 - 59)
tm_wday Day of week (0 - 6; Sunday = 0)
tm_yday Day of year (0 - 365; January 1 = 0)
tm_year Year (current year minus 1900)

wYear Specifies the current year.
wMonth Specifies the current month; January = 1, February = 2, and so on.
wDayOfWeek  Specifies the current day of the week; Sunday = 0, Monday = 1, and so on.
wDay Specifies the current day of the month.
wHour Specifies the current hour.
wMinute Specifies the current minute.
wSecond Specifies the current second.
wMilliseconds Specifies the current millisecond
*/
    tm.tm_hour = st.wHour;
    tm.tm_mday = st.wDay;
    tm.tm_min = st.wMinute;
    tm.tm_mon = st.wMonth - 1;
    tm.tm_sec  = st.wSecond;
    tm.tm_wday = st.wDayOfWeek;
    tm.tm_year = st.wYear - 1900;
    tm.tm_yday = 0;
}

PCSTR
FusionpLameFormatTime(
    LARGE_INTEGER li
    )
{
    FILETIME FileTime = { 0 };
    SYSTEMTIME SystemTime = { 0 };
    struct tm tm;

    FileTime.dwLowDateTime = li.LowPart;
    FileTime.dwHighDateTime = li.HighPart;

    FileTimeToSystemTime(&FileTime, &SystemTime);
    FusionpSystemTimeToCrtTm(SystemTime, tm);
    char * s = asctime(&tm);
    if (s && *s)
    {
        char * t = s + strlen(s);
        while (strchr(" \r\n\t", *--t))
        {
        }
        *(t + 1) = 0;
    }
    return s;
}

BOOL TestFindActCtx_AssemblyInfo(PCWSTR * args)
{
    FN_PROLOG_WIN32;

    ACTCTXW ActCtx = {sizeof(ActCtx)};
    ACTCTX_SECTION_KEYED_DATA askd = {sizeof(askd)};

    for ( ; *args != NULL ; args += 2)
    {
        CFusionActCtxHandle ActCtxHandle;
        CFusionActCtxScope  ActCtxScope;

        ActCtx.lpSource = args[0];

        IFW32FALSE_EXIT(ActCtxHandle.Win32Create(&ActCtx));
        IFW32FALSE_EXIT(ActCtxScope.Win32Activate(ActCtxHandle));
        if (!IsolationAwareFindActCtxSectionStringW(0, NULL, ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, args[1], &askd))
        {
            printf("IsolationAwareFindActCtxSectionStringW failed %ls (%d)\n",
                FusionpThreadUnsafeGetLastWin32ErrorMessageW(),
                FusionpGetLastWin32Error()
                );
            continue;
        }

        const ULONG64 Bases[] = { reinterpret_cast<ULONG_PTR>(askd.AssemblyMetadata.lpSectionBase) };
        const static FUSIONP_DUMP_CALLBACKS Callbacks = { printf, FusionpLameFormatTime };

#if DBG // until we work out factoring between sxs.dll, sxstest.dll, fusiondbg.dll.
        FusionpDumpStruct(
            &Callbacks,
            &StructInfo_ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION,
            reinterpret_cast<ULONG_PTR>(askd.AssemblyMetadata.lpInformation),
            "AssemblyInformation",
            Bases
            );
#endif
    }

    FN_EPILOG;
}

void
FusionpTestOleAut2()
{
    FusionpTestOleAut1(COINIT_APARTMENTTHREADED);
}

void
FusionpTestOleAut1(DWORD dwCoInit)
{
    HRESULT hr = 0;
    ::ATL::CComPtr<IUnknown> punk;
    ::ATL::CComQIPtr<ISxsTest_SingleThreadedDual> SingleThreaded;

    hr = Ole32.CoInitializeEx(NULL, dwCoInit);
    printf("line %d, hr 0x%lx\n", int(__LINE__) - 1, hr);

    hr = Ole32.CoCreateInstance(CLSID_CSxsTest_SingleThreadedDual, NULL, CLSCTX_INPROC, __uuidof(punk), reinterpret_cast<void**>(&punk));
    printf("line %d, hr 0x%lx\n", int(__LINE__) - 1, hr);
    printf("line %d, punk %p\n", int(__LINE__) - 2, static_cast<IUnknown*>(punk));

    if (punk == NULL)
        return;

    hr = punk->QueryInterface(__uuidof(SingleThreaded), reinterpret_cast<void**>(&SingleThreaded));
    printf("line %d, hr 0x%lx\n", int(__LINE__) - 1, hr);
    printf("line %d, SingleThreaded %p\n", int(__LINE__) - 2, static_cast<IUnknown*>(SingleThreaded));

    if (SingleThreaded == NULL)
        return;

    SingleThreaded->OutputDebugStringA("foo\n");
}

BOOL
FusionpGetComObjectFileName(
    IUnknown * p,
    CBaseStringBuffer & StringBuffer
    )
// a bit hacky
{
    FN_PROLOG_WIN32;

    HMODULE kernel32 = GetModuleHandleW(L"Kernel32");
    PGET_MODULE_HANDLE_EXW GetModuleHandleExW = reinterpret_cast<PGET_MODULE_HANDLE_EXW>(GetProcAddress(kernel32, "GetModuleHandleExW"));
    CDynamicLinkLibrary Dll;

    PVOID * pp = reinterpret_cast<PVOID *>(p); // hacky

    IFW32FALSE_EXIT(GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, reinterpret_cast<PCWSTR>(*pp), &Dll));
    IFW32FALSE_EXIT(FusionpGetModuleFileName(0/*flags*/, Dll, StringBuffer));

    FN_EPILOG;
}

#define FUSIONP_TEST_COM_CACHE_OLE1       (0x00000001)
#define FUSIONP_TEST_COM_CACHE_NOMANIFEST (0x00000002)
#define FUSIONP_TEST_COM_CACHE_PROGID1    (0x00000004)

BOOL
FusionpTestComCacheCommon(ULONG Flags, ULONG ManifestIndex)
{
    FN_PROLOG_WIN32;
    HRESULT hr = E_FAIL;

    CLSID Clsid = CLSID_CSxsTest_BothThreaded;
    WCHAR ClsidString[64];
    ::ATL::CComPtr<IUnknown> punk;
    CStringBuffer StringBuffer;
    CFusionActCtxHandle ActCtxHandle;
    WCHAR Manifest[] = L"sxstest_dll1.dll";
    ACTCTXW ActCtx = {sizeof(ActCtx)};
    CFusionActCtxScope ActCtxScope;

    if ((Flags & FUSIONP_TEST_COM_CACHE_NOMANIFEST) == 0)
    {
        *(wcsrchr(Manifest, L'.') - 1) = static_cast<WCHAR>(ManifestIndex + L'0'); // hacky
        ActCtx.lpSource = Manifest;
        ActCtx.lpResourceName = ISOLATIONAWARE_MANIFEST_RESOURCE_ID;
        ActCtx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;

        IFW32FALSE_EXIT(ActCtxHandle.Win32Create(&ActCtx));
        IFW32FALSE_EXIT(ActCtxScope.Win32Activate(ActCtxHandle));
    }
    if (Flags & FUSIONP_TEST_COM_CACHE_PROGID1)
    {
	    IFCOMFAILED_EXIT(hr = ::CLSIDFromProgID(L"SxS_COM.SxS_COMObject", &Clsid));
    }
    if (Flags & FUSIONP_TEST_COM_CACHE_OLE1)
    {
        IFCOMFAILED_EXIT(hr = ::CoCreateInstance(Clsid, NULL, CLSCTX_ALL, __uuidof(punk), reinterpret_cast<PVOID*>(&punk)));
    }
    IFW32FALSE_EXIT(FusionpGetComObjectFileName(punk, StringBuffer));
    FormatGuid(ClsidString, NUMBER_OF(ClsidString), Clsid);
    ::Trace("%s(0x%lx, 0x%lx, clsid=%ls):%ls\n", __FUNCTION__, Flags, ManifestIndex, ClsidString, static_cast<PCWSTR>(StringBuffer));

    FN_EPILOG;
}

void
FusionpTestOle32Cache()
{
    const ULONG Flags = FUSIONP_TEST_COM_CACHE_OLE1;
    CoInitialize(NULL);
    FusionpTestComCacheCommon(FUSIONP_TEST_COM_CACHE_NOMANIFEST | Flags, 0);
    FusionpTestComCacheCommon(Flags, 1);
    FusionpTestComCacheCommon(Flags, 2);
}

void
FusionpTestProgidCache()
{
    const ULONG Flags = FUSIONP_TEST_COM_CACHE_OLE1 | FUSIONP_TEST_COM_CACHE_PROGID1;
    CoInitialize(NULL);
    //FusionpTestComCacheCommon(FUSIONP_TEST_COM_CACHE_NOMANIFEST | Flags, 0);
    FusionpTestComCacheCommon(Flags, 1);
    FusionpTestComCacheCommon(Flags, 2);
}

BOOL TestComctl5Comctl6()
{
    FN_PROLOG_WIN32;

    CFusionActCtxHandle ActCtxHandle;
    WCHAR Manifest[] = L"5.man";
    ACTCTXW ActCtx = {sizeof(ActCtx)};
    CFusionActCtxScope ActCtxScope;
    HWND hWnd = NULL;

    ActCtx.lpSource = Manifest;

    IFW32FALSE_EXIT(ActCtxHandle.Win32Create(&ActCtx));
    IFW32FALSE_EXIT(ActCtxScope.Win32Activate(ActCtxHandle));

    ::Trace("create NoVersioned windowClass : ReBarWindow32 \n");
    hWnd = CreateWindowW(L"ReBarWindow32", L"noVersioned Classes", 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL);
    if (hWnd == NULL){
        DWORD dwLastError = ::GetLastError();
        printf("the last error got for CreateWindow is %d", dwLastError);
    }

    ::Trace("create windowClass :  Statci\n");
    hWnd = CreateWindowW(L"Static", L"Classes not in 5.0", 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL);
    if (hWnd == NULL){
        DWORD dwLastError = ::GetLastError();
        printf("the last error got for CreateWindow is %d", dwLastError);
    }

    FN_EPILOG;

}

BOOL FusionpTestUniqueValues()
{
    FN_PROLOG_WIN32

    SXSP_LOCALLY_UNIQUE_ID Luid[4];
    CStringBuffer Buff;

    IFW32FALSE_EXIT(SxspCreateLocallyUniqueId(Luid));
    IFW32FALSE_EXIT(SxspCreateLocallyUniqueId(Luid + 1));
    IFW32FALSE_EXIT(SxspCreateLocallyUniqueId(Luid + 2));
    IFW32FALSE_EXIT(SxspCreateLocallyUniqueId(Luid + 3));

    for (int i = 0; i < NUMBER_OF(Luid); i++)
    {
        IFW32FALSE_EXIT(SxspFormatLocallyUniqueId(Luid[i], Buff));
        wprintf(L"SXSP_LUID: %ls\n", static_cast<PCWSTR>(Buff));
    }

    FN_EPILOG
}

BOOL GenerateHashOfFileLikeSxsDoes(PCWSTR pcwszFileName)
{
    FN_PROLOG_WIN32;

    CStringBuffer FileName;
    CSmallStringBuffer strFileHashText;
    CFusionArray<BYTE> rgsbFileHash;

    IFW32FALSE_EXIT(FileName.Win32Assign(pcwszFileName, ::wcslen(pcwszFileName)));

    IFW32FALSE_EXIT(SxspCreateFileHash(HASHFLAG_AUTODETECT, CALG_SHA1, FileName, rgsbFileHash));
    IFW32FALSE_EXIT(SxspHashBytesToString(rgsbFileHash.GetArrayPtr(), rgsbFileHash.GetSize(), strFileHashText));

    wprintf(L"%ls : %ls\n", pcwszFileName, static_cast<PCWSTR>(strFileHashText));

    FN_EPILOG
}


void TestParsePatchInfo(PCWSTR PatchInfoFile)
{
    BOOL fSuccess = FALSE;

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_PARSE_PATCH_FILE, 0, PatchInfoFile, NULL);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
    }
}

void TestExpandCabinet(PCWSTR CabinetPath, PCWSTR TargetPath)
{
    BOOL fSuccess = FALSE;

    LoadSxs();

    fSuccess = (*g_pfnSxspDebug)(SXS_DEBUG_EXPAND_CAB_FILE, 0, CabinetPath, (PVOID)TargetPath);

    if (! fSuccess){
        fprintf(stderr, "%s failed!\n", __FUNCTION__);
    }
}

BOOL GenerateFileHash(PCWSTR pcwszFile)
{
    FN_PROLOG_WIN32;

    CFusionArray<BYTE> fFileHash;
    CMediumStringBuffer buffFileName;
    CMediumStringBuffer buffHashValue;

    IFW32FALSE_EXIT(buffFileName.Win32Assign(pcwszFile, ::wcslen(pcwszFile)));
    IFW32FALSE_EXIT(::SxspCreateFileHash(0, CALG_SHA1, buffFileName, fFileHash));
    IFW32FALSE_EXIT(::SxspHashBytesToString(
        fFileHash.GetArrayPtr(),
        fFileHash.GetSize(),
        buffHashValue));

    wprintf(L"File %ls hashed to \"%ls\"\n",
        static_cast<PCWSTR>(buffFileName),
        static_cast<PCWSTR>(buffHashValue));

    FN_EPILOG;

}


void
FusionpTestDllLoad(PCWSTR pwzBareDllName)
{
	HMODULE hm1 = NULL;
	HMODULE hm2 = NULL;
    HMODULE hm3 = NULL;
    CStringBuffer buf;
    WCHAR ModulePath[128];

	hm1 = LoadLibraryW(pwzBareDllName);
	if ( hm1 == NULL)
	{
		printf("load %ls failed!", pwzBareDllName);
    }else {
        if (GetModuleFileNameW(hm1, ModulePath, 128))
        {
            printf("%ls is loaded from %ls\n", pwzBareDllName, ModulePath);
        }
        else
        {
            printf("GetModuleFileNameW for hm1 failed!!!\n");
        }
    }

    printf("\n");

    buf.Win32Assign(L"d:\\windows\\system32\\", wcslen(L"d:\\windows\\system32\\"));
    buf.Win32Append(pwzBareDllName, wcslen(pwzBareDllName));

	hm2 = LoadLibraryW(buf);
	if ( hm2 == NULL)
	{
		printf("load d:\\windows\\system32\\%ls failed!", pwzBareDllName);
    } else {

        if (GetModuleFileNameW(hm2, ModulePath, 128))
        {
            printf("d:\\windows\\system32\\%ls is loaded from %ls\n", pwzBareDllName, ModulePath);
        }
        else
        {
            printf("GetModuleFileNameW for system32 dll failed!!!\n");
        }
    }
    printf("\n");

    buf.Win32Assign(L"d:\\tests\\SystemDefault\\", wcslen(L"d:\\tests\\SystemDefault\\"));
    buf.Win32Append(pwzBareDllName, wcslen(pwzBareDllName));

	hm3 = LoadLibraryW(buf);
	if ( hm3 == NULL)
	{
		printf("load d:\\tests\\SystemDefault\\%ls failed!", pwzBareDllName);
    } else {

	    if (GetModuleFileNameW(hm3, ModulePath, 128))
        {
            printf("d:\\tests\\SystemDefault\\%ls is loaded from %ls\n", pwzBareDllName, ModulePath);
        }
        else
        {
            printf("GetModuleFileNameW for d:\\tests\\SystemDefault\\ failed!!!\n");
        }
    }

    printf("\n--------------------------------------------------\n");

	if ( hm1 != NULL) {
		FreeLibrary(hm1);
	}

	if ( hm2 != NULL) {
		FreeLibrary(hm2);
	}
	if ( hm3 != NULL) {
		FreeLibrary(hm3);
	}
    return;
}


//
// this test case should run for testing under 3 situation
// (1) clean sxstest.exe running:
//          has no manifest about depend on comctl32.dll
// (2) add a sxstest.exe.local
// (3) add a sxstest.exe.manifest which depends on 6.0.0.0 comctl32.dll
//
void TestSystemDefaultDllRedirection()
{
    //
    // this test is for xiaoyuw own purpose. If you call this function, I assme:
    // (1) your os is installed at D:\windows
    // (2) you have d:\tests\systemdefault
    // (3) under d:\tests\systemdefault\, you have comctl32.dll, gdiplus.dll, es.dll and a.dll
    //
    FusionpTestDllLoad(L"comctl32.dll");
    FusionpTestDllLoad(L"es.dll");
    FusionpTestDllLoad(L"gdiplus.dll");
    FusionpTestDllLoad(L"a.dll");
    return;
}


VOID
NTAPI
SimpleContextNotification(
    IN ULONG NotificationType,
    IN PACTIVATION_CONTEXT ActivationContext,
    IN const VOID *ActivationContextData,
    IN PVOID NotificationContext,
    IN PVOID NotificationData,
    IN OUT PBOOLEAN DisableNotification
    )
{
    switch (NotificationType)
    {
    case ACTIVATION_CONTEXT_NOTIFICATION_DESTROY:
        RTL_SOFT_VERIFY(NT_SUCCESS(NtUnmapViewOfSection(NtCurrentProcess(), (PVOID) ActivationContextData)));
        break;

    default:
        // Otherwise, we don't need to see this notification ever again.
        *DisableNotification = TRUE;
        break;
    }
}


BOOL
MakeActCtxFromCurrentSxsDll(
    PCWSTR pcwszFileName,
    PCWSTR pcwszConfigFileName,
    HANDLE *phActCtx
    )
{
    FN_PROLOG_WIN32;

    SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters = {0};
    PACTIVATION_CONTEXT pContextCreated = NULL;
    CStringBuffer   AssemblyDirectory;
    CStringBuffer   PolicyPath;
    CFileStream     SourceManifestStream;
    CFileStream     PolicyStream;
    PVOID           pvMappedSection = NULL;
    NTSTATUS status;

    *phActCtx = INVALID_HANDLE_VALUE;

    LoadSxs();

    IFW32FALSE_EXIT(SourceManifestStream.OpenForRead(pcwszFileName, CImpersonationData(), FILE_SHARE_READ, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN));
    Parameters.Manifest.Path = pcwszFileName;
    Parameters.Manifest.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;
    Parameters.Manifest.Stream = &SourceManifestStream;

    IFW32FALSE_EXIT(AssemblyDirectory.Win32Assign(pcwszFileName, ::wcslen(pcwszFileName)));
    IFW32FALSE_EXIT(AssemblyDirectory.Win32RemoveLastPathElement());
    Parameters.AssemblyDirectory = AssemblyDirectory;
    Parameters.ProcessorArchitecture = 0;
    Parameters.LangId = GetUserDefaultUILanguage();

    if (pcwszConfigFileName != NULL) 
    {
        IFW32FALSE_EXIT(PolicyStream.OpenForRead(pcwszConfigFileName, CImpersonationData(), FILE_SHARE_READ, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN));
        Parameters.Policy.Path = pcwszConfigFileName;
        Parameters.Policy.PathType = ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE;
        Parameters.Policy.Stream = &PolicyStream;
    }

    IFW32FALSE_EXIT(g_pfnSxsGenerateActivationContext(&Parameters));
    IFW32NULL_EXIT(pvMappedSection = MapViewOfFile(Parameters.SectionObjectHandle, FILE_MAP_READ, 0, 0, 0));

    status = RtlCreateActivationContext(
        0,
        (PCACTIVATION_CONTEXT_DATA)pvMappedSection,
        0,
        SimpleContextNotification,
        NULL,
        &pContextCreated);

    if (!NT_SUCCESS(status)) {
        ORIGINATE_WIN32_FAILURE_AND_EXIT(RtlCreateActivationContext, RtlNtStatusToDosError(status));
    }

    *phActCtx = pContextCreated;

    FN_EPILOG;
}


BOOL
CreateActCtxLocally(
    PCWSTR pcwszManifestFile,
    PCWSTR pcwszConfigFile
    )
{
    HANDLE hActCtx;

    if (MakeActCtxFromCurrentSxsDll(pcwszManifestFile, pcwszConfigFile, &hActCtx))
    {
        ReleaseActCtx(hActCtx);
        return TRUE;
    }

    return FALSE;    
}



BOOL
TestSxsExportedSurrogateStuff(
    PCWSTR pcwszManifest,
    PCWSTR pcwszWhat,
    PCWSTR pcwszData
    )
{
    FN_PROLOG_WIN32;

    SIZE_T cbRequired = 0;
    BOOL f = false;
    PVOID pvTargetBuffer = NULL;
    PCSXS_CLR_SURROGATE_INFORMATION pSurrogateInfo = NULL;
    PCSXS_CLR_CLASS_INFORMATION pClassInfo = NULL;
    CFusionActCtxHandle hActCtxCreated;
    CFusionActCtxScope ActivationScope;
    ACTCTXW ActCtxStruct = {sizeof(ActCtxStruct)};

    LoadSxs();

    IFW32FALSE_EXIT(MakeActCtxFromCurrentSxsDll(pcwszManifest, NULL, &hActCtxCreated));
    IFW32FALSE_EXIT(ActivationScope.Win32Activate(hActCtxCreated));

    if (lstrcmpiW(pcwszWhat, L"clrprogid") == 0)
    {
        f = g_pfnClrClass(
            SXS_FIND_CLR_CLASS_SEARCH_PROGID | SXS_FIND_CLR_CLASS_GET_ALL,
            (PVOID)pcwszData,
            hActCtxCreated,
            NULL, 0, &cbRequired);

        if (!f)
        {
            SIZE_T cbWritten = 0;
            pvTargetBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired);
            g_pfnClrClass(
                SXS_FIND_CLR_CLASS_SEARCH_PROGID | SXS_FIND_CLR_CLASS_GET_ALL,
                (PVOID)pcwszData,
                hActCtxCreated,
                pvTargetBuffer,
                cbRequired,
                &cbWritten);

            pClassInfo = (PCSXS_CLR_CLASS_INFORMATION)pvTargetBuffer;
        }
    }
    else if (lstrcmpiW(pcwszWhat, L"clrguid") == 0)
    {
        GUID ParsedGuid;
        IFW32FALSE_EXIT(SxspParseGUID(pcwszData, wcslen(pcwszData), ParsedGuid));

        f = g_pfnClrClass(
            SXS_FIND_CLR_CLASS_SEARCH_GUID | SXS_FIND_CLR_CLASS_GET_ALL,
            (PVOID)&ParsedGuid,
            hActCtxCreated,
            NULL, 0, &cbRequired);

        if (!f)
        {
            SIZE_T cbWritten = 0;
            pvTargetBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired);
            g_pfnClrClass(
                SXS_FIND_CLR_CLASS_SEARCH_GUID | SXS_FIND_CLR_CLASS_GET_ALL,
                (PVOID)&ParsedGuid,
                hActCtxCreated,
                pvTargetBuffer, cbRequired, &cbWritten);

            pClassInfo = (PCSXS_CLR_CLASS_INFORMATION)pvTargetBuffer;
        }

    }
    else if (lstrcmpiW(pcwszWhat, L"lookup") == 0)
    {
        GUID ParsedGuid;
        PCSXS_GUID_INFORMATION_CLR pGuidInfo = NULL;

        IFW32FALSE_EXIT(SxspParseGUID(pcwszData, wcslen(pcwszData), ParsedGuid));

        f = g_pfnClrLookup(
            SXS_LOOKUP_CLR_GUID_FIND_ANY,
            &ParsedGuid,
            hActCtxCreated,
            NULL,
            0,
            &cbRequired);

        if (!f)
        {
            SIZE_T cbWritten = 0;
            pvTargetBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired);

            f = g_pfnClrLookup(
                SXS_LOOKUP_CLR_GUID_FIND_ANY,
                &ParsedGuid,
                hActCtxCreated,
                pvTargetBuffer,
                cbRequired,
                &cbWritten);

            pGuidInfo = (PCSXS_GUID_INFORMATION_CLR)pvTargetBuffer;
        }
    }
    else if (lstrcmpiW(pcwszWhat, L"surrogate") == 0)
    {
        GUID ParsedGuid;

        IFW32FALSE_EXIT(SxspParseGUID(pcwszData, wcslen(pcwszData), ParsedGuid));

        f = g_pfnClrSurrogate(
            SXS_FIND_CLR_SURROGATE_USE_ACTCTX | SXS_FIND_CLR_SURROGATE_GET_ALL,
            &ParsedGuid,
            hActCtxCreated,
            NULL, 0, &cbRequired);

        if (!f)
        {
            SIZE_T cbWritten = 0;
            pvTargetBuffer = HeapAlloc(GetProcessHeap(), 0, cbRequired);
            g_pfnClrSurrogate(
                SXS_FIND_CLR_SURROGATE_USE_ACTCTX | SXS_FIND_CLR_SURROGATE_GET_ALL,
                &ParsedGuid,
                hActCtxCreated,
                pvTargetBuffer, cbRequired, &cbWritten);

            pSurrogateInfo = (PCSXS_CLR_SURROGATE_INFORMATION)pvTargetBuffer;
        }
    }

    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include $(PROJECT_ROOT)\win32\fusion\fusion.inc

USE_MAKEFILE_INC=1

!if !defined(TARGETTYPE)
TARGETTYPE=PROGLIB
!endif
!if !defined(TARGETNAME)
TARGETNAME=sxstest
!endif

MAJORCOMP=fusion
MINORCOMP=sxstest

TARGETPATH=$(FUSION_PATH)\$(FUSION_BUILD_LEAF_DIRECTORY)\$(_OBJ_DIR)
DLLDEF=..\$(TARGETNAME).def

C_DEFINES=$(C_DEFINES) $(SXS_MANIFEST_DEFINES)

# for merging proxy/stub .dll
#C_DEFINES=$(C_DEFINES) -DENTRY_PREFIX=Prx
C_DEFINES=$(C_DEFINES) -D_MERGE_PROXYSTUB
C_DEFINES=$(C_DEFINES) -DUNICODE
C_DEFINES=$(C_DEFINES) -D_UNICODE

ISOLATION_AWARE_ENABLED=1
C_DEFINES=$(C_DEFINES) -DISOLATION_AWARE_ENABLED_OBJBASE

USE_MSVCRT=1
USE_NATIVE_EH=1
USE_STATIC_ATL=1
ATL_VER=30
#USE_STL=1

# -fixed:no because we turn the .exe into a .dll at runtime
LINKER_FLAGS=$(LINKER_FLAGS) -fixed:no

INCLUDES= \
 ..\idl\$(O); \
 ..\..\idl\$(O); \
 ..; \
 ..\..; \
 $(FUSION_PATH)\sxs; \
 $(FUSION_INC_PATH); \
 $(FUSION_PATH)\xmlparser; \
 $(FUSION_PATH)\id; \
 $(FUSION_PATH)\inc; \
 $(FUSION_PATH)\eventlog\whistler\$(O); \
 $(FUSION_PATH)\idl\$(O); \
 $(INCLUDES); \
 $(FUSION_PATH)\dll\whistler; \
 $(FUSION_PATH)\dll\; \
 $(COM_INC_PATH)

UMTYPE=console
UMENTRYABS=Entry

LINKLIBS= \
 $(LINKLIBS) \
 $(FUSION_PATH)\$(FUSION_BUILD_LEAF_DIRECTORY)\$(O)\sxstestlib.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxs1.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxs2.lib \

TARGETLIBS= \
 $(SDK_LIB_PATH)\ntdll.lib \
 $(TARGETLIBS) \
 $(FUSION_PATH)\$(O)\sxstest_idl.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)sxsmain.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)utils.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)xmlparser.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)id.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)eventlog.lib \
 $(FUSION_PATH)\$(O)\fusion_uuid.lib \
 $(FUSION_PATH)\$(O)\fusion_dump.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)xml.lib \
 $(FUSION_LIB_PATH)\$(FUSION_BUILD_TYPE_PREFIX)eventlog.lib \
 $(SDK_LIB_PATH)\uuid.lib \
 $(SDK_LIB_PATH)\kernel32.lib \
 $(SDK_LIB_PATH)\kernl32p.lib \
 $(SDK_LIB_PATH)\advapi32.lib \
 $(SDK_LIB_PATH)\crypt32.lib \
 $(SDK_LIB_PATH)\rpcrt4.lib \
 $(SDK_LIB_PATH)\setupapi.lib \
 $(SDK_LIB_PATH)\imagehlp.lib \
 $(SDK_LIB_PATH)\user32.lib \
 $(SDK_LIB_PATH)\wintrust.lib \
 $(SDK_LIB_PATH)\mpr.lib \
 $(SDK_LIB_PATH)\ole32.lib \
 $(SDK_LIB_PATH)\oleaut32.lib \
 $(SDK_LIB_PATH)\comctl32.lib \
 $(SDK_LIB_PATH)\netapi32.lib \
 $(FUSION_SLIST_LIB) \

!ifdef MAN1
C_DEFINES=$(C_DEFINES) -DMAN1
SXS_MANIFEST_RESOURCE_ID=1
!endif
!ifdef MAN2
C_DEFINES=$(C_DEFINES) -DMAN2
SXS_MANIFEST_RESOURCE_ID=2
!endif
!ifdef MAN3
C_DEFINES=$(C_DEFINES) -DMAN3
SXS_MANIFEST_RESOURCE_ID=3
!endif

!if !defined(NOMAN)
SXS_MANIFEST=..\sxstest.manifest
SXS_ASSEMBLY_NAME=Microsoft.Windows.SideBySide.Test
SXS_NO_BINPLACE=1
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
!if !defined(MANFILE)
SXS_MANIFEST_IN_RESOURCES=1
!endif
NO_BINPLACE=1
!endif

!if "$(MAN1)$(MAN2)$(MAN3)" == ""
NUMBER_OF_MANIFESTS=0
!elseif "$(MAN1)$(MAN2)$(MAN3)" == "1"
NUMBER_OF_MANIFESTS=1
!elseif "$(MAN1)$(MAN2)$(MAN3)" == "11"
NUMBER_OF_MANIFESTS=2
!elseif "$(MAN1)$(MAN2)$(MAN3)" == "111"
NUMBER_OF_MANIFESTS=3
!endif
C_DEFINES=$(C_DEFINES) -DNUMBER_OF_MANIFESTS=$(NUMBER_OF_MANIFESTS)
!if "$(NUMBER_OF_MANIFESTS)" != "0" && "$(NUMBER_OF_MANIFESTS)" != "1"
USE_MAKEFILE_INC=1
!endif

MANIFEST_PREPROCESSOR_NAME=$(FUSION_PATH)\tests\sxstest\manifest_preprocessor.bat $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS) -EP $(USE_FC)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxstestc.c ===
/*
Make sure code in the headers is valid C.
*/
struct _CRYPT_PROVIDER_DATA;
struct _CRYPT_PROVIDER_SGNR;
struct _CRYPT_PROVIDER_PRIVDATA;
struct _CRYPT_PROVIDER_DEFUSAGE;
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "lm.h"
#include "lmdfs.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include "sxsapi.h"
#include "wintrust.h"
#include <setupapi.h>
#include "commctrl.h"
#include "winbasep.h"
#include "sxstest_idl.h"
#include <time.h>
#include "objbase.h"
#include "ole2.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\idlgen.c ===
/* A little program to combinatorialy generate some .idl */

#include "windows.h"
#include <stdio.h>
#undef INTERFACE
#undef UuidToString

#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

#define DUAL                (0x001)
#define OBJECT              (0x002)
#define OLEAUTOMATION       (0x004)
#define BRACES              (0x008)
#define DISPINTERFACE       (0x010)
#define BASE_NONE           (0x020)
#define BASE_IUNKNOWN       (0x040)
#define BASE_IDISPATCH      (0x080)
#define FUNCTION            (0x100)
#define NUM                 (0x200)

void UuidToString(const UUID * Uuid, char * s)
{
    sprintf(s, "%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x", Uuid->Data1, Uuid->Data2, Uuid->Data3, Uuid->Data4[0], Uuid->Data4[1], Uuid->Data4[2], Uuid->Data4[3], Uuid->Data4[4], Uuid->Data4[5], Uuid->Data4[6], Uuid->Data4[7]);
}

typedef struct INTERFACE
{
    UUID    InterfaceId;
    CLSID   ClassId;
} INTERFACE;

void strcatf(char * s, const char * format, ...)
{
    va_list args;

    va_start(args, format);
    s += strlen(s);
    vsprintf(s, format, args);
    va_end(args);
}

void Identifierize(char * s)
{
    int ch;
    for ( ; ch = *s ; ++s )
    {
        if (ch >= 'a' && ch <= 'z')
            continue;
        if (ch >= 'A' && ch <= 'Z')
            continue;
        if (ch >= '0' && ch <= '9')
            continue;
        if (ch == '_')
            continue;
        *s = '_';
    }
}

BOOL IsValid(ULONG i)
{
    switch (i & (BASE_NONE | BASE_IUNKNOWN | BASE_IDISPATCH))
    {
        case BASE_NONE:
        case BASE_IUNKNOWN:
        case BASE_IDISPATCH:
            break;
        default:
            return FALSE;
    }

    if ((i & FUNCTION) && (i & BRACES) == 0)
        return FALSE;

    //if (i & (BASE_IUNKNOWN|BASE_IDISPATCH))
    //   return FALSE;
    if ((i & BASE_IUNKNOWN) && (i & DISPINTERFACE))
        return FALSE;
    if ((i & BASE_IDISPATCH) && (i & DISPINTERFACE))
        return FALSE;
    if ((i & BASE_NONE) && (i & OBJECT))
        return FALSE;
    if ((i & DUAL) && (i & DISPINTERFACE))
        return FALSE;
    if ((i & OLEAUTOMATION) && (i & DISPINTERFACE))
        return FALSE;

    // unsatisfied forward declaration
    if ((i & BRACES) == 0)
        return FALSE;

    return TRUE;
}

void IdlGen()
{
    ULONG i;
    char        IdlBuffer[1UL<<16];
    INTERFACE   Interfaces[NUM];
    INTERFACE * Interface;
    char        UuidStringBuffer[64];
    UUID        LibraryId;
    char        LibraryIdStringBuffer[64];
    char        IdentifierizedLibraryIdStringBuffer[64];

    IdlBuffer[0] = 0;

    strcatf(IdlBuffer,
        "import \"oaidl.idl\";\n"
        );

    UuidCreate(&LibraryId);
    UuidToString(&LibraryId, LibraryIdStringBuffer);
    strcpy(IdentifierizedLibraryIdStringBuffer, LibraryIdStringBuffer);
    Identifierize(IdentifierizedLibraryIdStringBuffer);

    for ( i = 0 ; i != NUMBER_OF(Interfaces) ; ++i)
    {
        char Function[1024];

        if (!IsValid(i))
            continue;

        UuidCreate(&Interfaces[i].InterfaceId);
        UuidCreate(&Interfaces[i].ClassId);

        UuidToString(&Interfaces[i].InterfaceId, UuidStringBuffer);

        Function[0] = 0;
        if (i & FUNCTION)
            sprintf(
                Function,
                "%sHRESULT Foo_0x%x([in] const char * s, [out] int * i);",
                (i & DISPINTERFACE) ? "properties: methods:[id(0)]" : "",
                i
                );

        strcatf(IdlBuffer, "[ %s%s%suuid(%s)] %sinterface ISxsTest_IdlGen_0x%x%s%s%s%s;\n",
            (i & DUAL) ? "dual," : "     ",
            (i & OBJECT) ? "object,": "       ",
            (i & OLEAUTOMATION) ? "oleautomation," : "              ",
            UuidStringBuffer,
            (i & DISPINTERFACE) ? "disp" : "    ",
            i,
            (i & BASE_IUNKNOWN) ? ":IUnknown" : (i & BASE_IDISPATCH) ? ":IDispatch" : "",
            (i & BRACES) ? "{" : "",
            Function,
            (i & BRACES) ? "}" : ""
            );
            
    }
    strcatf(IdlBuffer,
        "[uuid(%s)]library SxsTest_IdlGen_%s\n{\n"
        "importlib(\"stdole32.tlb\");\n"
        "importlib(\"stdole2.tlb\");\n",
        LibraryIdStringBuffer,
        IdentifierizedLibraryIdStringBuffer
        );
    for ( i = 0 ; i != NUMBER_OF(Interfaces) ; ++i)
    {
        if (!IsValid(i))
            continue;

        UuidToString(&Interfaces[i].ClassId, UuidStringBuffer);
        strcatf(IdlBuffer, "[uuid(%s)]coclass CSxsTest_IdlGen_0x%x {[default] interface ISxsTest_IdlGen_0x%x;};\n",
            UuidStringBuffer, i, i);
    }
    strcatf(IdlBuffer, "};\n");

    printf("%s\n", IdlBuffer);
}

int __cdecl main()
{
    IdlGen();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxstest_exe.cpp ===
/*
Copyright (c) Microsoft Corporation
*/
#include "windows.h"

int Main(int argc, wchar_t** argv);

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int i = Main(argc, argv);
    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxstest_formatguid.cpp ===
void FormatGuid(WCHAR* String, SIZE_T StringSize, const GUID& Guid)
{
    if (StringSize > 0)
    {
        _snwprintf(
            String,
            StringSize,
            L"%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
            Guid.Data1,
            Guid.Data2,
            Guid.Data3,
            Guid.Data4[0], Guid.Data4[1], Guid.Data4[2], Guid.Data4[3],
            Guid.Data4[4], Guid.Data4[5], Guid.Data4[6], Guid.Data4[7]);
        String[StringSize - 1] = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxstest_trace.cpp ===
void __cdecl Trace(const char* FormatString, ...)
{
    char buffer[2000];
    va_list args;

    va_start(args, FormatString);
    _vsnprintf(buffer, RTL_NUMBER_OF(buffer), FormatString, args);
    buffer[RTL_NUMBER_OF(buffer) - 1] = 0;
    for (PSTR s = buffer ; *s != 0 ; )
    {
        PSTR t = strchr(s, '\n');

        if (t != NULL)
            *t = 0;

                    printf("stdout  : %s\n", s);
        OutputDebugStringA("debugger: ");
        OutputDebugStringA(s);
        OutputDebugStringA("\n");

        if (t != NULL)
            s = t + 1;
    }
    va_end(args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxstest.h ===
// Copyright (c) Microsoft Corporation
#pragma once

class CUnknown : public IUnknown
{
public:
    virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv)
    {
        return E_NOINTERFACE;
    }
    virtual ULONG __stdcall AddRef()
    {
        return 1;
    }
    virtual ULONG __stdcall Release()
    {
        return 1;
    }
};

class CSxsTestGlobals
{
public:
    HINSTANCE sxsDll;
    USHORT wProcessorArchitecture;
    LANGID wLangId;
    HANDLE MainThread;
    INT    NumberOfThreads;
    HANDLE Threads[MAXIMUM_WAIT_OBJECTS];
    HANDLE ThreadExitEvent;
    wchar_t lastOperation[256];
    CUnknown unknown;

    CSmartRef<IGlobalInterfaceTable> GlobalInterfaceTable;

    //
    // the start of some automation / record keeping..
    //
    ULONG Failures;
    ULONG Successes;
};
extern CSxsTestGlobals g;

BOOL TestInstallLikeWindowsSetup(PCWSTR szDirectory, PCWSTR szCodebase);

void __cdecl Trace(const char* FormatString, ...);

VOID FusionpSetSystemSetupInProgress(bool f);

BOOLEAN
FusionpStringPrefixI(
    PCWSTR str,
    PCWSTR prefix
    );

BOOLEAN
FusionpProcessArgument(
    PCWSTR Arg
    );

#if defined(__cplusplus)
extern "C"
#endif
BOOL
WINAPI
SxsDllMain(
    HINSTANCE hInst,
    DWORD dwReason,
    PVOID pvReserved
    );

int Main(int argc, wchar_t** argv);

void SetLastOperation(const wchar_t* format, ...);
const wchar_t* GetLastOperation(const wchar_t* format, ...);

template <typename PFN>
inline void GetSxsProc(int name, PFN* ppfn)
{
    SetLastOperation(L"GetProcAddress(#%d)", name);
    if (!(*ppfn = reinterpret_cast<PFN>(GetProcAddress(g.sxsDll, reinterpret_cast<PCSTR>(IntToPtr(name))))))
    {
        ThrowLastError();
    }
}

template <typename PFN>
inline void GetSxsProc(PCSTR name, PFN* ppfn)
{
    SetLastOperation(L"GetProcAddress(%hs)", name);
    if (!(*ppfn = reinterpret_cast<PFN>(GetProcAddress(g.sxsDll, name))))
    {
        ThrowLastError();
    }
}

void __stdcall ThrowLastError(DWORD error = ::GetLastError());

extern SXSP_DEBUG_FUNCTION pfnSxspDebug;

#if 0
#elif defined(_AMD64_)
#define SXSP_PROCESSOR_X86_IS_I386_W L"amd64"
#elif defined(_IA64_)
#define SXSP_PROCESSOR_X86_IS_I386_W L"ia64"
#elif defined(_X86_)
#define SXSP_PROCESSOR_X86_IS_I386_W L"i386"
#endif

#if 0
#elif defined(_AMD64_)
#define SXSP_PROCESSOR_I386_IS_X86_W L"amd64"
#elif defined(_IA64_)
#define SXSP_PROCESSOR_I386_IS_X86_W L"ia64"
#elif defined(_X86_)
#define SXSP_PROCESSOR_I386_IS_X86_W L"x86"
#endif

#define SXSP_PROCESSOR_BUILD_OBJ_DIRECTORY_W    SXSP_PROCESSOR_X86_IS_I386_W
#define SXSP_PROCESSOR_INSTALL_DIRECTORY_W      SXSP_PROCESSOR_X86_IS_I386_W

BOOL
SxspConvertX86ToI386(
    CBaseStringBuffer & buffProcessor
    );

BOOL
SxspConvertI386ToX86(
    CBaseStringBuffer & buffProcessor
    );

#define SxspConvertProcessorToProcessorInstallDirectory   SxspConvertX86ToI386
#define SxspConvertProcessorToProcessorBuildObjDirectory  SxspConvertX86ToI386

extern const UNICODE_STRING x86String;
extern const UNICODE_STRING i386String;
extern const UNICODE_STRING BackslashString;
extern const UNICODE_STRING asms01_dot_cabString;
extern const UNICODE_STRING ProcessorBuildObjString;
extern const UNICODE_STRING ProcessorInstallDirectoryString;
extern const UNICODE_STRING sxs_dot_dll_UnicodeString;
extern const UNICODE_STRING sxs_dot_cap_dot_dll_UnicodeString;
extern const UNICODE_STRING d_UnicodeString;
extern const UNICODE_STRING obj_UnicodeString;
extern const UNICODE_STRING dll_backslash_whistler_UnicodeString;
extern const UNICODE_STRING base_backslash_win32_backslash_fusion_backslash_dll_whistler_UnicodeString;

BOOL
LoadBuiltSxsDll(
    VOID
    );

BOOL
LoadInstalledSxsDll(
    VOID
    );

BOOL
UseStaticSxsDll(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\teb.c ===
/*
This file is meant only to assist in ensuring offsets in peb and teb
are maintained while editing base\published\pebteb.w.
*/
#define _WIN32_WINNT 0x0501
#include <stdio.h>
#include <assert.h>
#include <limits.h>
#include <stddef.h>

#include "nt.h"
#include "ntrtl.h"
#include "wow64t.h"

void Test1()
{
#undef TEB_MEMBER
#define TEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(TEB, name), (long)RTL_FIELD_SIZE(TEB, name));
#ifdef _IA64_
#define TEB_MEMBER_IA64(name) TEB_MEMBER(name)
#else
#define TEB_MEMBER_IA64(name) /* nothing */
#endif
#define TEB TEB
    printf("\n\nnative TEB %ld\n\n", (long)sizeof(TEB));
    #include "teb.h"
#undef TEB

#undef TEB_MEMBER
#define TEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(TEB32, name), (long)RTL_FIELD_SIZE(TEB32, name));
#undef TEB_MEMBER_IA64
#define TEB_MEMBER_IA64(name) /* nothing */
    printf("\n\nTEB32 %ld\n\n", (long)sizeof(TEB32));
    #include "teb.h"

#undef TEB_MEMBER
#define TEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(TEB64, name), (long)RTL_FIELD_SIZE(TEB64, name));
#if defined(_X86_)
#undef TEB_MEMBER_IA64
#define TEB_MEMBER_IA64(name) TEB_MEMBER(name)
#endif
#define TEB64 TEB64
    printf("\n\nTEB64 %ld\n\n", (long)sizeof(TEB64));
    #include "teb.h"
#undef TEB64

#define PEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(PEB, name), (long)RTL_FIELD_SIZE(PEB, name));
#define PEB PEB
    printf("\n\nnative PEB %ld\n\n", (long)sizeof(PEB));
    #include "peb.h"
#undef PEB

#undef PEB_MEMBER
#define PEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(PEB32, name), (long)RTL_FIELD_SIZE(PEB32, name));
    printf("\n\nPEB32 %ld\n\n", (long)sizeof(PEB32));
    #include "peb.h"

#undef PEB_MEMBER
#define PEB_MEMBER(name) printf("%s %ld %ld\n", #name, (long)FIELD_OFFSET(PEB64, name), (long)RTL_FIELD_SIZE(PEB64, name));
    printf("\n\nPEB64 %ld\n\n", (long)sizeof(PEB64));
    #include "peb.h"

    printf("\n\npadding\n\n");

    printf("TEB %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB, ActivationContextStack, ExceptionCode));
    printf("TEB %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB, ExceptionCode, ActivationContextStack));
    printf("TEB32 %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB32, ActivationContextStack, ExceptionCode));
    printf("TEB32 %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB32, ExceptionCode, ActivationContextStack));
    printf("TEB64 %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB64, ActivationContextStack, ExceptionCode));
    printf("TEB64 %ld\n", (long)RTL_PADDING_BETWEEN_FIELDS(TEB64, ExceptionCode, ActivationContextStack));

    if ((sizeof(PVOID)*CHAR_BIT) == 32)
    {
        assert(sizeof(PEB) == sizeof(PEB32));
        assert(sizeof(TEB) == sizeof(TEB32));
    }
    if ((sizeof(PVOID)*CHAR_BIT) == 64)
    {
        assert(sizeof(PEB) == sizeof(PEB64));
        assert(sizeof(TEB) == sizeof(TEB64));
    }
}

int main()
{
    Test1();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\teb.h ===
/*
This file is meant only to assist in ensuring offsets in peb and teb
are maintained while editing base\published\pebteb.w.
*/
TEB_MEMBER(NtTib)
TEB_MEMBER(EnvironmentPointer)
TEB_MEMBER(ClientId)
TEB_MEMBER(ActiveRpcHandle)
TEB_MEMBER(ThreadLocalStoragePointer)
TEB_MEMBER(ProcessEnvironmentBlock)
TEB_MEMBER(LastErrorValue)
TEB_MEMBER(CountOfOwnedCriticalSections)
TEB_MEMBER(CsrClientThread)
TEB_MEMBER(Win32ThreadInfo)
TEB_MEMBER(User32Reserved)
TEB_MEMBER(UserReserved)
TEB_MEMBER(WOW32Reserved)
TEB_MEMBER(CurrentLocale)
TEB_MEMBER(FpSoftwareStatusRegister)
TEB_MEMBER(SystemReserved1)
TEB_MEMBER(ExceptionCode)
TEB_MEMBER(ActivationContextStack)
TEB_MEMBER(SpareBytes1)
TEB_MEMBER(GdiTebBatch)
TEB_MEMBER(RealClientId)
TEB_MEMBER(GdiCachedProcessHandle)
TEB_MEMBER(GdiClientPID)
TEB_MEMBER(GdiClientTID)
TEB_MEMBER(GdiThreadLocalInfo)
TEB_MEMBER(Win32ClientInfo)
TEB_MEMBER(glDispatchTable)
TEB_MEMBER(glReserved1)
TEB_MEMBER(glReserved2)
TEB_MEMBER(glSectionInfo)
TEB_MEMBER(glSection)
TEB_MEMBER(glTable)
TEB_MEMBER(glCurrentRC)
TEB_MEMBER(glContext)
TEB_MEMBER(LastStatusValue)
TEB_MEMBER(StaticUnicodeString)
TEB_MEMBER(StaticUnicodeBuffer)
TEB_MEMBER(DeallocationStack)
TEB_MEMBER(TlsSlots)
TEB_MEMBER(TlsLinks)
TEB_MEMBER(Vdm)
TEB_MEMBER(ReservedForNtRpc)
TEB_MEMBER(DbgSsReserved)
TEB_MEMBER(HardErrorsAreDisabled)
TEB_MEMBER(Instrumentation)
TEB_MEMBER(WinSockData)
TEB_MEMBER(GdiBatchCount)
TEB_MEMBER(InDbgPrint)
TEB_MEMBER(FreeStackOnTermination)
TEB_MEMBER(HasFiberData)
TEB_MEMBER(IdealProcessor)
TEB_MEMBER(Spare3)
TEB_MEMBER(ReservedForPerf)
TEB_MEMBER(ReservedForOle)
TEB_MEMBER(WaitingOnLoaderLock)
TEB_MEMBER(Wx86Thread)
TEB_MEMBER(TlsExpansionSlots)
TEB_MEMBER(ImpersonationLocale)
TEB_MEMBER(IsImpersonating)
TEB_MEMBER(NlsCache)
TEB_MEMBER(pShimData)
TEB_MEMBER(HeapVirtualAffinity)
TEB_MEMBER(CurrentTransactionHandle)
TEB_MEMBER(ActiveFrame)
TEB_MEMBER(FlsData)
TEB_MEMBER_IA64(DeallocationBStore)
TEB_MEMBER_IA64(BStoreLimit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\cboththreaded.h ===
// Copyright (c) Microsoft Corporation
// CBothThreaded.h : Declaration of the CCBothThreaded

#ifndef CBOTHTHREADED_H_
#define CBOTHTHREADED_H_
#pragma once

#include "resource.h"       // main symbols
#include "sxstest_idl.h"

/////////////////////////////////////////////////////////////////////////////
// CCBothThreaded
class ATL_NO_VTABLE CCBothThreaded : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCBothThreaded, &CLSID_CSxsTest_BothThreaded>,
	public ISxsTest_BothThreaded
{
public:
	CCBothThreaded()
	{

        PrintComctl32Path("CCBothThreaded");
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CBOTHTHREADED)
DECLARE_AGGREGATABLE(CCBothThreaded)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCBothThreaded)
	COM_INTERFACE_ENTRY(ISxsTest_BothThreaded)
END_COM_MAP()

// ICBothThreaded
public:
};

#endif //CBOTHTHREADED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\capartmentthreaded.h ===
// Copyright (c) Microsoft Corporation
// CApartmentThreaded.h : Declaration of the CApartmentThreaded

#ifndef CAPARTMENTTHREADED_H_
#define CAPARTMENTTHREADED_H_
#pragma once

#include "resource.h"       // main symbols
#include "sxstest_idl.h"

/////////////////////////////////////////////////////////////////////////////
// CApartmentThreaded
class ATL_NO_VTABLE CApartmentThreaded : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CApartmentThreaded, &CLSID_CSxsTest_ApartmentThreaded>,
    public ISxsTest_ApartmentThreaded
{
public:
    CApartmentThreaded()
    {
        m_pUnkMarshaler = NULL;

        PrintComctl32Path("CApartmentThreaded");
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CAPARTMENTTHREADED)
DECLARE_AGGREGATABLE(CApartmentThreaded)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CApartmentThreaded)
    COM_INTERFACE_ENTRY(ISxsTest_ApartmentThreaded)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// ICApartmentThreaded
public:
};

#endif // CAPARTMENTTHREADED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\csinglethreaded.h ===
// Copyright (c) Microsoft Corporation
// CSingleThreaded.h : Declaration of the CSingleThreaded

#ifndef CSINGLETHREADED_H_
#define CSINGLETHREADED_H_
#pragma once

#include "resource.h"       // main symbols
#include "sxstest_idl.h"

/////////////////////////////////////////////////////////////////////////////
// CSingleThreaded
class ATL_NO_VTABLE CSingleThreaded : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CSingleThreaded, &CLSID_CSxsTest_SingleThreaded>,
    public ISxsTest_SingleThreaded
{
public:
    CSingleThreaded()
    {

        PrintComctl32Path("CSingleThreaded");
    }

    STDMETHOD(OutputDebugStringA)(const char * s)
    {
        ::OutputDebugStringA(s);
        return NOERROR;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CSINGLETHREADED)
DECLARE_AGGREGATABLE(CSingleThreaded)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSingleThreaded)
    COM_INTERFACE_ENTRY(ISxsTest_SingleThreaded)
END_COM_MAP()

// ICSingleThreaded
public:
};

#endif // CSINGLETHREADED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\cfreethreaded.h ===
// Copyright (c) Microsoft Corporation
// CFreeThreaded.h : Declaration of the CFreeThreaded

#ifndef CFREETHREADED_H_
#define CFREETHREADED_H_
#pragma once

#include "resource.h"       // main symbols
#include "sxstest_idl.h"

/////////////////////////////////////////////////////////////////////////////
// CFreeThreaded
class ATL_NO_VTABLE CFreeThreaded : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CFreeThreaded, &CLSID_CSxsTest_FreeThreaded>,
    public ISxsTest_FreeThreaded
{
public:
    CFreeThreaded()
    {
        m_pUnkMarshaler = NULL;

        PrintComctl32Path("CFreeThreaded");
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CFREETHREADED)
DECLARE_AGGREGATABLE(CFreeThreaded)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFreeThreaded)
    COM_INTERFACE_ENTRY(ISxsTest_FreeThreaded)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// ICFreeThreaded
public:
};

#endif //CFREETHREADED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\dll1.cpp ===
// Copyright (c) Microsoft Corporation
#include "stdinc.h"

void PrintComctl32Path(PCSTR Class)
{
    WCHAR Buffer[MAX_PATH];
    PWSTR FilePart;

    Buffer[0] = 0;
    SearchPathW(NULL, L"comctl32.dll", NULL, MAX_PATH, Buffer, &FilePart);

    //DebugBreak();
    DbgPrint("Class %s, Thread 0x%lx, comctl32 %ls\n", Class, GetCurrentThreadId(), Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\dlldatay.c ===
// Copyright (c) Microsoft Corporation
#include "..\..\dlldatax.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\dllmain.cpp ===
// Copyright (c) Microsoft Corporation
// dll1.cpp

#include "stdinc.h"
#include "resource.h"
#include "initguid.h"
#include "sxstest_idl.h"
#include "CFreeThreaded.h"
#include "CSingleThreaded.h"
#include "CApartmentThreaded.h"
#include "CBothThreaded.h"
#include "CSingleThreadedDual.h"
#include "dlldatax.h"
#include <stdio.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

#include "sxstest_trace.cpp"
#include "sxstest_formatguid.cpp"

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CSxsTest_FreeThreaded, CFreeThreaded)
    OBJECT_ENTRY(CLSID_CSxsTest_SingleThreaded, CSingleThreaded)
    OBJECT_ENTRY(CLSID_CSxsTest_ApartmentThreaded, CApartmentThreaded)
    OBJECT_ENTRY(CLSID_CSxsTest_BothThreaded, CCBothThreaded)
    OBJECT_ENTRY(CLSID_CSxsTest_SingleThreadedDual, CSingleThreadedDual)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C" BOOL WINAPI _DllMainCRTStartup(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

extern "C"
BOOL WINAPI SxsTest_Dll1_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance /*, &LIBID_ATL_DLL1Lib */);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

extern "C"
BOOL WINAPI DllEntry(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    DWORD Detach = DLL_PROCESS_DETACH;
    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:
        Detach = DLL_THREAD_DETACH; // FALLTHROUGH
    case DLL_PROCESS_ATTACH:
        if (!_DllMainCRTStartup(hInstance, dwReason, lpReserved))
            return FALSE;
        if (!SxsTest_Dll1_DllMain(hInstance, dwReason, lpReserved))
        {
            _DllMainCRTStartup(hInstance, Detach, lpReserved);
            return FALSE;
        }
        return TRUE;

    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        SxsTest_Dll1_DllMain(hInstance, dwReason, lpReserved);
        _DllMainCRTStartup(hInstance, dwReason, lpReserved);
        return TRUE;

    default:
        return FALSE;
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    WCHAR ClsidBuffer[64];
    WCHAR IidBuffer[64];

    PrintComctl32Path("DllGetClassObject");
    FormatGuid(ClsidBuffer, NUMBER_OF(ClsidBuffer), rclsid);
    FormatGuid(IidBuffer, NUMBER_OF(IidBuffer), riid);
    Trace("DllGetClassObject(clsid={%ls}, iid={%ls}\n", ClsidBuffer, IidBuffer);
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\makefile.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

$(O)\dll1.res : \
    $(O)\CApartmentThreaded.rgs \
    $(O)\CBothThreaded.rgs \
    $(O)\CFreeThreaded.rgs \
    $(O)\CSingleThreaded.rgs

.SUFFIXES: .rgssrc .rgs

{..}.rgssrc{$(O)\}.rgs:
    $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS) -EP $(USE_FC) $< | perl <<$(O)\cleanup_rgs.pl > $@
$$file = join("", <>);      # read all the lines into one string
$$file =~ s/^#.+$$//gm;     # remove preprocessor directives
$$file =~ s/\n+/\n/gms;     # remove empty lines
print($$file);              # and print it all back out
<<KEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dll1.rc
//
#define IDR_CFREETHREADED               101
#define IDR_CSINGLETHREADED             102
#define IDR_CAPARTMENTTHREADED          103
#define IDR_CBOTHTHREADED               104
#define IDR_CSINGLETHREADED_DUAL        105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\csinglethreadeddual.h ===
// Copyright (c) Microsoft Corporation
// CSingleThreadedDual.h : Declaration of the CSingleThreadedDual

#ifndef CSINGLETHREADEDDUAL_H_
#define CSINGLETHREADEDDUAL_H_
#pragma once

#include "resource.h"       // main symbols
#include "sxstest_idl.h"

/////////////////////////////////////////////////////////////////////////////
// CSingleThreadedDual
class ATL_NO_VTABLE CSingleThreadedDual : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CSingleThreadedDual, &CLSID_CSxsTest_SingleThreadedDual>,
    public IDispatchImpl<ISxsTest_SingleThreadedDual, &IID_ISxsTest_SingleThreadedDual>
{
public:
    CSingleThreadedDual()
    {

        PrintComctl32Path("CSingleThreadedDual");
    }

    STDMETHOD(OutputDebugStringA)(const char * s)
    {
        ::OutputDebugStringA(s);
        return NOERROR;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CSINGLETHREADED_DUAL)
DECLARE_AGGREGATABLE(CSingleThreadedDual)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSingleThreadedDual)
    COM_INTERFACE_ENTRY(ISxsTest_SingleThreadedDual)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ICSingleThreadedDual
public:
};

#endif // CSINGLETHREADED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

FUSION_BUILD_TYPE=WIN
!include ..\..\sources.inc
ATL_VER=30
USE_MSVCRT=1
USE_STATIC_ATL=1
NO_BINPLACE=1
TARGETPATH=$(FUSION_PATH)\$(FUSION_BUILD_LEAF_DIRECTORY)\$(_OBJ_DIR)
TARGETNAME=sxstest_dll$(VERSION)
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dll1.def
DLLENTRY=DllEntry
!undef LINKLIBS
TARGETLIBS=\
 $(FUSION_PATH)\$(O)\sxstest_idl.lib \
 $(SDK_LIB_PATH)\uuid.lib \
 $(SDK_LIB_PATH)\kernel32.lib \
 $(SDK_LIB_PATH)\advapi32.lib \
 $(SDK_LIB_PATH)\user32.lib \
 $(SDK_LIB_PATH)\ole32.lib \
 $(SDK_LIB_PATH)\oleaut32.lib \
 $(SDK_LIB_PATH)\rpcrt4.lib \

SOURCES=\
 ..\dll1.cpp \
 ..\dllmain.cpp \
 ..\dll1.rc \
 ..\dlldatay.c

NTTARGETFILE0=\
 $(O)\CApartmentThreaded.rgs \
 $(O)\CBothThreaded.rgs \
 $(O)\CFreeThreaded.rgs \
 $(O)\CSingleThreaded.rgs \
 $(O)\CSingleThreadedDual.rgs \

SXS_MANIFEST=dll1.manifest
SXS_ASSEMBLY_NAME=Microsoft.Windows.SideBySide.Test.Dll$(VERSION)
SXS_NO_BINPLACE=1
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST_IN_RESOURCES=1
NO_BINPLACE=1

C_DEFINES=$(C_DEFINES) -DVERSION=$(VERSION)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\2\makefile.inc ===
# Copyright (c) Microsoft Corporation
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\stdinc.h ===
// Copyright (c) Microsoft Corporation
#pragma once

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

void PrintComctl32Path(const char * Class);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\idl\makefile.inc ===
# 

#$(O)\sxstest_i.c:
#    -mkdir $(O) 2>nul
#    if exist sxstest_i.c copy sxstest_i.c $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\dll1\1\makefile.inc ===
# Copyright (c) Microsoft Corporation
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\lib\makefile.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\lib\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

#SYNCHRONIZE_DRAIN=1
SYNCHRONIZE_BLOCK=1

TARGETTYPE=LIBRARY
TARGETNAME=sxstestlib
SOURCES= \
 ..\sxstest_lib.cpp
!include ..\..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\lib\sxstest_lib.cpp ===
/*
Copyright (c) Microsoft Corporation
*/

#include "..\..\sxstest.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\testdata\buildmultifileassembly\empty.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\lib\win2000\makefile.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\lib\whistler\makefile.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxsofflineinstall\whistler\makefile.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxsofflineinstall\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

NOMAN=1
NO_BINPLACE=1

TARGETTYPE=PROGRAM
TARGETNAME=sxsofflineinstall
SOURCES= \
 ..\sxsofflineinstall.cpp

!include ..\..\sources.inc

!undef UMENTRYABS
UMENTRY=wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxsofflineinstall\makefile.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\whistler\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxsofflineinstall\win2000\makefile.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\xpman1\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\xpman12\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\xpman13\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\xpman2\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\xpman23\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\sxsofflineinstall\sxsofflineinstall.cpp ===
/*
Copyright (c) Microsoft Corporation

This program performs "offline" setup of side-by-side assemblies.
"Offline" meaning to a directory other than the current windows directory.
*/
#include "stdinc.h"
#if DBG // free builds have known problems, not worth fixing
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "sxsapi.h"
#include "fusionlastwin32error.h"
#include "fusionbuffer.h"
#include "sxstest.h"
#include "cassemblyrecoveryinfo.h"

#define SXSP_TOOL_KNOWS_ABOUT_BUILD 0

#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)

extern "C" BOOL g_fForceInOsSetupMode; // this feature not available in free builds
extern BOOL g_SxsOfflineInstall; // this feature not available in free builds

BOOL
SxspQueryEnvironmentVariable(
    PCWSTR pcwszName,
    CBaseStringBuffer &Value,
    bool &fFound
    )
{
    FN_PROLOG_WIN32;

    CStringBufferAccessor sba;
    SIZE_T cchRequired = 0;
    DWORD dwLastError = 0;

    fFound = false;
    Value.Clear();

    if (Value.GetBufferCch() < 2)
    {
        IFW32FALSE_EXIT(
            Value.Win32ResizeBuffer(
                2,
                eDoNotPreserveBufferContents));
    }

    sba.Attach(&Value);
    while (TRUE)
    {
        sba.GetBufferPtr()[sba.GetBufferCch() - 1] = 0;
        cchRequired = ::GetEnvironmentVariableW(pcwszName, sba.GetBufferPtr(), sba.GetBufferCchAsDWORD() - 1);
        if (
            cchRequired != 0
            && cchRequired < sba.GetBufferCch()
            && sba.GetBufferPtr()[sba.GetBufferCch() - 1] == 0)
        {
            break;
        }
        dwLastError = ::FusionpGetLastWin32Error();
        if (cchRequired == 0 && dwLastError != ERROR_ENVVAR_NOT_FOUND)
        {
            ORIGINATE_WIN32_FAILURE_AND_EXIT(GetEnvironmentVariableW, dwLastError);
        }
        if (cchRequired == 0)
        {
            cchRequired = (Value.GetBufferCch() + 1) * 2;
        }
        sba.Detach();
        IFW32FALSE_EXIT(Value.Win32ResizeBuffer(cchRequired + 1, eDoNotPreserveBufferContents));
        sba.Attach(&Value);
    }
    sba.Detach();

    FN_EPILOG;
}


class CSxspOfflineInstall
{
public:
    typedef CFusionArray<CStringBuffer, CBaseStringBuffer> CSourceDirectories;

    CSxspOfflineInstall() : fIgnoreMissingDirectories(false), fDefaultInstall(false)
    {
    }

    int
    SxsOfflineInstall(
        int argc,
        wchar_t ** argv
        );

    CSmallStringBuffer      buffToolnameFromArgv0;
    CSmallStringBuffer      buffWinsxs;
    CSmallStringBuffer      buffRegResultTarget;
    CStringBuffer           buffHostRegPathTemp;
    CSmallStringBuffer      buffCodeBaseURL;
    CSourceDirectories      DirectoriesToInstall;
    CSmallStringBuffer      buffNoncanonicalData;
    bool                    fIgnoreMissingDirectories;
    bool                    fDefaultInstall;
#if SXSP_TOOL_KNOWS_ABOUT_BUILD
    CSmallStringBuffer      buffBuildArch;
#endif

    BOOL MiniSetupInstall(PCWSTR pcwszSourcePath);

    BOOL Initialize()
    {
        FN_PROLOG_WIN32;
        IFW32FALSE_EXIT(DirectoriesToInstall.Win32Initialize());
        FN_EPILOG;
    }

    BOOL LoadParameters(int argc, wchar_t **argv);
    void DisplayUsage();

    BOOL
    FindAndWriteRegistryResults(
        const CBaseStringBuffer &OutputFile,
        HKEY hkActualBase
        );

private:
    static const UNICODE_STRING opt_Winsxs;;
    static const UNICODE_STRING opt_Sourcedir;
    static const UNICODE_STRING opt_RegResult;
    static const UNICODE_STRING opt_IgnoreMissingDirectories;
    static const UNICODE_STRING opt_CodeBaseURL;
    static const UNICODE_STRING opt_NoncanonicalData;
#if SXSP_TOOL_KNOWS_ABOUT_BUILD
    static const UNICODE_STRING opt_BuildArch;
#endif

    enum COption
    {
        eWinsxsOpt,
        eSourceDirectoryOpt,
        eRegistryOutputFile,
        eBuildArchOpt,
        eIgnoreMissingDirectoriesOpt,
        eCodeBaseURL,
        eNoncanonicalData,
        eUnknownOption
    };

    class CMapOption
    {
    public:
        PCUNICODE_STRING Str;
        COption Option;
        CMapOption(PCUNICODE_STRING src, COption o) : Str(src), Option(o) { }
    };

    static const CMapOption m_Options[];
    static const SIZE_T m_cOptionCount;

    COption MapOption(const UNICODE_STRING &str) const
    {
        for (SIZE_T c = 0; c < m_cOptionCount; c++)
        {
            if (::FusionpEqualStringsI(&str, m_Options[c].Str))
            {
                return m_Options[c].Option;
            }
        }
        return eUnknownOption;
    }

    bool StartsWithSwitchChar(PCWSTR pcwsz)
    {
        return (pcwsz && (*pcwsz == L'-'));
    }

    PCWSTR GetPureOption(PCWSTR pcwsz)
    {
        PCWSTR pcwszOption = pcwsz;
        while (StartsWithSwitchChar(pcwszOption))
        {
            pcwszOption++;
        }
        return pcwszOption;
    }

};

const UNICODE_STRING CSxspOfflineInstall::opt_Winsxs      = RTL_CONSTANT_STRING(L"windir");
const UNICODE_STRING CSxspOfflineInstall::opt_Sourcedir   = RTL_CONSTANT_STRING(L"source");
const UNICODE_STRING CSxspOfflineInstall::opt_RegResult   = RTL_CONSTANT_STRING(L"registryoutput");
const UNICODE_STRING CSxspOfflineInstall::opt_IgnoreMissingDirectories = RTL_CONSTANT_STRING(L"IgnoreMissingDirectories");
const UNICODE_STRING CSxspOfflineInstall::opt_CodeBaseURL = RTL_CONSTANT_STRING(L"CodebaseUrl");
const UNICODE_STRING CSxspOfflineInstall::opt_NoncanonicalData = RTL_CONSTANT_STRING(L"buffNoncanonicalData");
#if SXSP_TOOL_KNOWS_ABOUT_BUILD
const UNICODE_STRING CSxspOfflineInstall::opt_BuildArch = RTL_CONSTANT_STRING(L"buffBuildArch");
#endif

const CSxspOfflineInstall::CMapOption CSxspOfflineInstall::m_Options[] =
{
    CMapOption(&opt_Winsxs, eWinsxsOpt),
    CMapOption(&opt_Sourcedir, eSourceDirectoryOpt),
    CMapOption(&opt_RegResult, eRegistryOutputFile),
    CMapOption(&opt_IgnoreMissingDirectories, eIgnoreMissingDirectoriesOpt),
    CMapOption(&opt_CodeBaseURL, eCodeBaseURL),
    CMapOption(&opt_NoncanonicalData, eNoncanonicalData),
#if SXSP_TOOL_KNOWS_ABOUT_BUILD
    CMapOption(&opt_BuildArch, eBuildArchOpt),
#endif
};

const SIZE_T CSxspOfflineInstall::m_cOptionCount = NUMBER_OF(CSxspOfflineInstall::m_Options);

void
CSxspOfflineInstall::DisplayUsage()
{
#define Lx(x) L##x
#define L(x) Lx(x)

    static const WCHAR wchUsage[] =
        L"Offline installer postbuild tool - mail WinFuse with problems\r\n"
        L"Version: " L(__DATE__) L" " L(__TIME__) L" "
#if defined(_WIN64)
        L"Win64"
#elif defined(_WIN32)
        L"Win32"
#endif
        L" "
#if DBG
        L"chk"
#else
        L"fre"
#endif
        L"\r\n"
        L"-source <path> : specifies where to pick up files, like %_nttree%\\asms\r\n"
        L"    You may specify it multiple times to pick up several asms trees,\r\n"
        L"    which is useful in the case of Wow/Win64\r\n"
        L"\r\n"
        L"-windir <path> : specifies the target WinSxS pseudo-root to be installed to.\r\n"
        L"    This directory should exist before running the tool.\r\n"
        L"\r\n"
        L"-registryoutput <file> : Specifies what file should contain the INF that\r\n"
        L"    contains all the registry manipulation done.\r\n"
        L"\r\n"
        L"-DefaultInstall : add a [DefaultInstall] section so that\r\n"
        L"    right clicking the .inf works in Explorer.\r\n"
        L"\r\n"
        L"-CodebaseUrl <url>\r\n"
        L"\r\n"
        L"-NoncanonicalData <text>\r\n"
        ;

    wprintf(wchUsage);
}

BOOL
CSxspOfflineInstall::LoadParameters(
    int argc,
    wchar_t **argv
    )
{
#if 0
    if (argc == 0)
    {
        return FALSE;
    }
#endif
    FN_PROLOG_WIN32;

    CStringBuffer NewItem;
    bool fNotFound = false;

    for (int i = 0; i < argc; i++)
    {
        UNICODE_STRING usThisOption;

        PARAMETER_CHECK(StartsWithSwitchChar(argv[i]));
        ::FusionpRtlInitUnicodeString(&usThisOption, GetPureOption(argv[i]));

        switch (MapOption(usThisOption))
        {
        case eIgnoreMissingDirectoriesOpt:
            this->fIgnoreMissingDirectories = true;
            break;

        case eNoncanonicalData:
            i++;
            PARAMETER_CHECK(i < argc);

            IFW32FALSE_EXIT(this->buffNoncanonicalData.Win32Assign(argv[i], ::wcslen(argv[i])));
            break;

        case eCodeBaseURL:
            i++;
            PARAMETER_CHECK(i < argc);

            IFW32FALSE_EXIT(this->buffCodeBaseURL.Win32Assign(argv[i], ::wcslen(argv[i])));
            break;

        case eSourceDirectoryOpt:
            i++;
            PARAMETER_CHECK(i < argc);

            IFW32FALSE_EXIT(NewItem.Win32Assign(argv[i], ::wcslen(argv[i])));
            IFW32FALSE_EXIT(this->DirectoriesToInstall.Win32Append(NewItem));
            break;

        case eWinsxsOpt:
            i++;
            PARAMETER_CHECK(i < argc);
            IFW32FALSE_EXIT(this->buffWinsxs.Win32Assign(argv[i], ::wcslen(argv[i])));
            break;

        case eRegistryOutputFile:
            i++;
            PARAMETER_CHECK(i < argc);
            IFW32FALSE_EXIT(this->buffRegResultTarget.Win32Assign(argv[i], ::wcslen(argv[i])));
            break;

        default:
        case eUnknownOption:
            PARAMETER_CHECK(false);
            break;
        }
    }

    if (this->buffWinsxs.Cch() == 0)
    {
        IFW32FALSE_EXIT(::SxspGetAssemblyRootDirectory(this->buffWinsxs));
    }

#if SXSP_TOOL_KNOWS_ABOUT_BUILD
    fNotFound = false;
    IFW32FALSE_EXIT(::SxspQueryEnvironmentVariable(L"_BuildArch", this->buffBuildArch, fNotFound));

    if (this->DirectoriesToInstall.GetSize() == 0)
    {
        CTinyStringBuffer BasePath;
        CTinyStringBuffer ToInstall;

        fNotFound = false;
        IFW32FALSE_EXIT(::SxspQueryEnvironmentVariable(L"_ntpostbld", BasePath, fNotFound));
        if (fNotFound)
        {
            IFW32FALSE_EXIT(::SxspQueryEnvironmentVariable(L"_nttree", BasePath, fNotFound));
            if (fNotFound)
            {
                wprintf(L"Unable to find environment variable _nttree, and no source directories set.\r\n");
                ORIGINATE_WIN32_FAILURE_AND_EXIT(NoDirectories, ERROR_INVALID_PARAMETER);
            }
        }

        IFW32FALSE_EXIT(ToInstall.Win32Assign(BasePath));
        IFW32FALSE_EXIT(ToInstall.Win32AppendPathElement(L"asms", 4));
        if (::GetFileAttributesW(ToInstall) != INVALID_FILE_ATTRIBUTES)
        {
            IFW32FALSE_EXIT(DirectoriesToInstall.Win32Append(ToInstall));
        }

        IFW32FALSE_EXIT(ToInstall.Win32Assign(BasePath));
        IFW32FALSE_EXIT(ToInstall.Win32AppendPathElement(L"wowbins\\asms", NUMBER_OF(L"wowbins\\asms") - 1));
        if (::GetFileAttributesW(ToInstall) != INVALID_FILE_ATTRIBUTES)
        {
            IFW32FALSE_EXIT(DirectoriesToInstall.Win32Append(ToInstall));
        }

        IFW32FALSE_EXIT(ToInstall.Win32Assign(BasePath));
        IFW32FALSE_EXIT(ToInstall.Win32AppendPathElement(L"wowbins\\wasms", NUMBER_OF(L"wowbins\\wasms") - 1));
        if (::GetFileAttributesW(ToInstall) != INVALID_FILE_ATTRIBUTES)
        {
            IFW32FALSE_EXIT(DirectoriesToInstall.Win32Append(ToInstall));
        }
    }
#endif

    FN_EPILOG;
}

#if SXSP_TOOL_KNOWS_ABOUT_BUILD
__declspec(selectany) extern const UNICODE_STRING x86String = RTL_CONSTANT_STRING(L"x86");
__declspec(selectany) extern const UNICODE_STRING i386String = RTL_CONSTANT_STRING(L"i386");
__declspec(selectany) extern const UNICODE_STRING BackslashString = RTL_CONSTANT_STRING(L"\\");
__declspec(selectany) extern const UNICODE_STRING asms01_dot_cabString = RTL_CONSTANT_STRING(L"asms01.cab");
__declspec(selectany) extern const UNICODE_STRING ProcessorBuildObjString = RTL_CONSTANT_STRING(SXSP_PROCESSOR_BUILD_OBJ_DIRECTORY_W);
__declspec(selectany) extern const UNICODE_STRING ProcessorInstallDirectoryString = RTL_CONSTANT_STRING(SXSP_PROCESSOR_INSTALL_DIRECTORY_W);

inline
BOOL
SxspConvertX86ToI386(
    CBaseStringBuffer & buffProcessor
    )
{
    FN_PROLOG_WIN32;
    if (::FusionpEqualStringsI(buffProcessor, x86String.Buffer, RTL_STRING_GET_LENGTH_CHARS(&x86String)))
    {
        IFW32FALSE_EXIT(buffProcessor.Win32Assign(&i386String));
    }
    FN_EPILOG;
}
#endif

BOOL
CSxspOfflineInstall::MiniSetupInstall(PCWSTR pcwszSourcePath)
{
    FN_PROLOG_WIN32;

    SXS_INSTALLW InstallParameters = {sizeof(InstallParameters)};
    SXS_INSTALL_REFERENCEW InstallReference = {sizeof(InstallReference)};

    g_fForceInOsSetupMode = TRUE;

    InstallReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL;
    InstallReference.lpNonCanonicalData = this->buffNoncanonicalData;

    if (this->buffCodeBaseURL.Cch() != 0)
    {
        InstallParameters.lpCodebaseURL = this->buffCodeBaseURL;
    }
    else
    {
#if SXSP_TOOL_KNOWS_ABOUT_BUILD
        if (this->buffBuildArch.Cch() == 0)
#endif
        {
            InstallParameters.lpCodebaseURL = pcwszSourcePath;
        }
#if SXSP_TOOL_KNOWS_ABOUT_BUILD
        else
        {
            CTinyStringBuffer buffCompactDiskBuildArch;

            IFW32FALSE_EXIT(buffCompactDiskBuildArch.Win32Assign(this->buffBuildArch));
            ::SxspConvertX86ToI386(buffCompactDiskBuildArch);

            IFW32FALSE_EXIT(this->buffCodeBaseURL.Win32Assign(&UnicodeString_URLHEAD_WINSOURCE));
            IFW32FALSE_EXIT(this->buffCodeBaseURL.Win32Append(buffCompactDiskBuildArch));
            IFW32FALSE_EXIT(this->buffCodeBaseURL.Win32Append(&BackslashString));
            IFW32FALSE_EXIT(this->buffCodeBaseURL.Win32Append(&asms01_dot_cabString));

            InstallParameters.lpCodebaseURL = this->buffCodeBaseURL;
        }
#endif
    }
    InstallParameters.lpManifestPath = pcwszSourcePath;
    InstallParameters.lpRefreshPrompt = SXSP_OFFLINE_INSTALL_REFRESH_PROMPT_PLACEHOLDER;
    InstallParameters.lpReference = &InstallReference;
    InstallParameters.dwFlags = SXS_INSTALL_FLAG_FROM_DIRECTORY |
        SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE |
        SXS_INSTALL_FLAG_REFERENCE_VALID |
        SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID |
        SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
        SXS_INSTALL_FLAG_NOT_TRANSACTIONAL |
        SXS_INSTALL_FLAG_CODEBASE_URL_VALID;

    if (::SxsInstallW(&InstallParameters))
    {
        wprintf(
            L"(%ls) SxsInstallW of %ls completed\r\n",
            static_cast<PCWSTR>(this->buffToolnameFromArgv0),
            pcwszSourcePath
            );
        FN_SUCCESSFUL_EXIT();
    }
    else
    {
        wprintf(
            L"(%ls) SxsInstallW of %ls failed, lasterror 0x%lx\r\n",
            static_cast<PCWSTR>(this->buffToolnameFromArgv0),
            pcwszSourcePath,
            ::GetLastError()
            );
        ORIGINATE_WIN32_FAILURE_AND_EXIT(SxsInstallW, ::FusionpGetLastWin32Error());
    }
    FN_EPILOG;
}

HKEY g_hkRedirectionRoot;
SXSP_LOCALLY_UNIQUE_ID g_uuidRedirection;

BOOL SxspTurnOnRedirection(CStringBuffer &RegPath);
BOOL SxspTurnOffRedirection(const CStringBuffer &RegPath);

BOOL
WriteFileString(
    HANDLE hFile,
    PCSTR pcszFormat,
    ...
    )
{
    FN_PROLOG_WIN32;

    CHAR cBuffer[2048];
    PSTR pszBuffer = cBuffer;
    DWORD dwBuffer = NUMBER_OF(cBuffer);
    DWORD dwWritten;
    CSmartArrayPtr<CHAR> SmartArray;
    int iRequired = 0;
    int iWritten = 0;
    va_list va;

    va_start(va, pcszFormat);
    iRequired = ::_vscprintf(pcszFormat, va);

    if (iRequired > dwBuffer)
    {
        IFW32FALSE_EXIT(SmartArray.Win32Allocate(iRequired + 1, __FILE__, __LINE__));
        pszBuffer = SmartArray;
        dwBuffer = iRequired;
    }

    iWritten = ::_vsnprintf(pszBuffer, dwBuffer - 1, pcszFormat, va);
    pszBuffer[iWritten] = '\0';
    pszBuffer[dwBuffer - 1] = '\0';

    IFW32FALSE_EXIT(::WriteFile(hFile, pszBuffer, iWritten, &dwWritten, NULL));

    FN_EPILOG;
}



BOOL
FindRegHelper(
    HANDLE hFile,
    CBaseStringBuffer &FullPath,
    CBaseStringBuffer &Child,
    CRegKey &hkSourceKey
    )
{
    FN_PROLOG_WIN32;

    DWORD iIndex = 0;
    CTinyStringBuffer tsb;

    //
    // First, enum the values in this key.
    //
    do
    {
        BOOL fDone = FALSE;
        DWORD dwType = 0;

        IFW32FALSE_EXIT(hkSourceKey.EnumValue(iIndex++, Child, &dwType, &fDone));

        if (fDone)
        {
            break;
        }
        else
        {
            //
            // Form up the output
            //
            ::WriteFileString(hFile, "HKLM,\"%S\",\"%S\",",
                static_cast<PCWSTR>(FullPath),
                static_cast<PCWSTR>(Child));

            if (dwType == REG_SZ)
            {
                IFW32FALSE_EXIT(::FusionpRegQuerySzValueEx(0, hkSourceKey, Child, tsb));

                //
                // if it contains any quotes, go one character at a time,
                // doubling quotes
                //
                // if it has no quotes, write it all at once
                //
                if (::wcschr(tsb, '\"') != NULL)
                {
                    IFW32FALSE_EXIT(::WriteFileString(hFile, "0x%08lx,\"",
                        FLG_ADDREG_TYPE_SZ | FLG_ADDREG_64BITKEY));
                    for (SIZE_T d = 0; d < tsb.Cch(); d++)
                    {
                        if (tsb[d] == '\"')
                            IFW32FALSE_EXIT(::WriteFileString(hFile, "\"\""));
                        else
                            IFW32FALSE_EXIT(::WriteFileString(hFile, "%c", tsb[d]));
                    }
                    IFW32FALSE_EXIT(::WriteFileString(hFile, "\"\r\n"));
                }
                else
                {
                    IFW32FALSE_EXIT(::WriteFileString(hFile, "0x%08lx,\"%S\"\r\n",
                        FLG_ADDREG_TYPE_SZ | FLG_ADDREG_64BITKEY,
                        static_cast<PCWSTR>(tsb)));
                }
            }
            else if (dwType == REG_DWORD)
            {
                DWORD dwValue = 0;
                IFW32FALSE_EXIT(
                    ::FusionpRegQueryDwordValueEx(
                        FUSIONP_REG_QUERY_DWORD_MISSING_VALUE_IS_FAILURE,
                        hkSourceKey,
                        Child,
                        &dwValue,
                        0));
                IFW32FALSE_EXIT(::WriteFileString(hFile, "0x%08lx,0x%08lx\r\n",
                    FLG_ADDREG_TYPE_DWORD | FLG_ADDREG_64BITKEY,
                    dwValue));
            }
            else if (dwType == REG_BINARY)
            {
                CFusionArray<BYTE> bBytes;
                IFW32FALSE_EXIT(::FusionpRegQueryBinaryValueEx(0, hkSourceKey, Child, bBytes));
                IFW32FALSE_EXIT(::WriteFileString(
                    hFile,
                    "0x%08lx,",
                    FLG_ADDREG_TYPE_BINARY | FLG_ADDREG_64BITKEY));

                for (SIZE_T c = 0; c < bBytes.GetSize(); c++)
                {
                    if (c == 0)
                        IFW32FALSE_EXIT(::WriteFileString(hFile, "%02x", bBytes[c]));
                    else
                        IFW32FALSE_EXIT(::WriteFileString(hFile, ",%02x", bBytes[c]));
                }

                IFW32FALSE_EXIT(::WriteFileString(hFile, "\r\n"));
            }
            else
            {
                ORIGINATE_WIN32_FAILURE_AND_EXIT(ErrorInvalidType, ERROR_INVALID_PARAMETER);
            }
        }
    }
    while (true);

    //
    // Now enum the keys
    //
    iIndex = 0;
    do
    {
        BOOL fDone = FALSE;

        IFW32FALSE_EXIT(hkSourceKey.EnumKey(iIndex++, Child, NULL, &fDone));
        if (fDone)
        {
            break;
        }
        //
        // Append this to the current key,
        else
        {
            const SIZE_T cch = FullPath.Cch();
            CRegKey ThisKey;

            //
            // no leading slash
            //
            if (FullPath.Cch() == 0)
            {
                IFW32FALSE_EXIT(FullPath.Win32Append(Child));
            }
            else
            {
                IFW32FALSE_EXIT(FullPath.Win32AppendPathElement(Child));
            }
            IFW32FALSE_EXIT(hkSourceKey.OpenSubKey(ThisKey, Child, KEY_READ, 0));
            IFW32FALSE_EXIT(::FindRegHelper(hFile, FullPath, Child, ThisKey));

            FullPath.Left(cch);
        }
    }
    while (true);

    FN_EPILOG;
}

BOOL
CSxspOfflineInstall::FindAndWriteRegistryResults(
    const CBaseStringBuffer &OutputFile,
    HKEY hkActualBase
    )
{
    FN_PROLOG_WIN32;

    CTinyStringBuffer Path;
    CTinyStringBuffer ChildTemp;
    CFusionFile hOutputFile;
    CRegKey hkBase = hkActualBase;

    IFW32FALSE_EXIT(hOutputFile.Win32CreateFile(OutputFile, GENERIC_WRITE, FILE_SHARE_READ, CREATE_ALWAYS));
    IFW32FALSE_EXIT(::WriteFileString(hOutputFile,
        "[Version]\r\n"
        "Signature = \"$Windows NT$\"\r\n\r\n"
        // stampinf inserts DriverVer here, like other hiv*.inf
        ));

    if (this->fDefaultInstall)
    {
        IFW32FALSE_EXIT(::WriteFileString(hOutputFile,
            "[fDefaultInstall]\r\n"
            "AddReg=AddReg\r\n\r\n"
            ));
    }
    IFW32FALSE_EXIT(::WriteFileString(hOutputFile,
        "[AddReg]\r\n"
        ));
    IFW32FALSE_EXIT(::FindRegHelper(hOutputFile, Path, ChildTemp, hkBase));

    FN_EPILOG;
}

BOOL
CSxspOfflineInstall::SxsOfflineInstall(
    int argc,
    wchar_t ** argv
    )
{
    BOOL fSuccess = FALSE;
    int i = 0;
    DWORD FileAttributes = 0;
    BOOLEAN AppendWinsxs = TRUE;
    bool fFound = false;
    CTinyStringBuffer buffArgv0;
    CTinyStringBuffer CommandLineFromFileW;

    g_SxsOfflineInstall = TRUE;

    if (argc < 2)
    {
        this->DisplayUsage();
        ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    if (!::SxsDllMain(::GetModuleHandleW(NULL), DLL_PROCESS_ATTACH, NULL))
        goto Exit;
    if (!buffArgv0.Win32Assign(argv[0], ::wcslen(argv[0])))
        goto Exit;
    if (!buffArgv0.Win32GetLastPathElement(this->buffToolnameFromArgv0))
        goto Exit;

    if (!this->Initialize() || !this->LoadParameters(argc - 1, argv + 1))
    {
        this->DisplayUsage();
        ::FusionpSetLastWin32Error(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    ::SxspDebug(SXS_DEBUG_SET_ASSEMBLY_STORE_ROOT, 0, this->buffWinsxs, NULL);
    g_WriteRegistryAnyway = TRUE;

    ::FusionpCreateDirectories(this->buffWinsxs, this->buffWinsxs.Cch());
    ::SxspTurnOnRedirection(this->buffHostRegPathTemp);

    for (int i = 0; i < this->DirectoriesToInstall.GetSize(); i++)
    {
        CStringBuffer &Buffer = this->DirectoriesToInstall[i];

        if (!this->fIgnoreMissingDirectories
            || ::GetFileAttributesW(Buffer) != INVALID_FILE_ATTRIBUTES)
        {
            this->MiniSetupInstall(Buffer);
        }
    }

    ::SxspDeleteShortNamesInRegistry();

    if (this->buffRegResultTarget.Cch() != 0)
    {
        this->FindAndWriteRegistryResults(this->buffRegResultTarget, HKEY_LOCAL_MACHINE);
    }

    ::SxspTurnOffRedirection(this->buffHostRegPathTemp);

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

int
__cdecl
wmain(
  int argc,
  wchar_t ** argv
  )
{
    CSxspOfflineInstall This;
    DWORD dwWin32Error = NO_ERROR;

    ::FusionpSetLastWin32Error(dwWin32Error);
    if (!This.SxsOfflineInstall(argc, argv))
    {
        dwWin32Error = ::FusionpGetLastWin32Error();
        if (dwWin32Error == NO_ERROR)
            dwWin32Error = ERROR_INTERNAL_ERROR;
    }
    return dwWin32Error;
}

BOOL
SxspTurnOnRedirection(CStringBuffer &RegPath)
{
    FN_PROLOG_WIN32;

    CSmallStringBuffer UniqueId;

    IFW32FALSE_EXIT(::SxspCreateLocallyUniqueId(&g_uuidRedirection));
    IFW32FALSE_EXIT(::SxspFormatLocallyUniqueId(g_uuidRedirection, UniqueId));
    IFW32FALSE_EXIT(RegPath.Win32Assign(L"SxsOfflineInstall", NUMBER_OF(L"SxsOfflineInstall") - 1));
    IFW32FALSE_EXIT(RegPath.Win32AppendPathElement(UniqueId));

    IFREGFAILED_EXIT(::RegCreateKeyExW(
        HKEY_CURRENT_USER,
        RegPath,
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &g_hkRedirectionRoot,
        NULL));

    IFREGFAILED_EXIT(::RegOverridePredefKey(HKEY_LOCAL_MACHINE, g_hkRedirectionRoot));

    FN_EPILOG;
}

BOOL
SxspTurnOffRedirection(const CStringBuffer &RegPath)
{
    FN_PROLOG_WIN32;

    CRegKey TempKey(g_hkRedirectionRoot);
    CSmallStringBuffer Uid;

    IFW32FALSE_EXIT(TempKey.DestroyKeyTree());
    IFREGFAILED_EXIT(::RegOverridePredefKey(HKEY_LOCAL_MACHINE, NULL));

    IFREGFAILED_EXIT(::RegDeleteKeyW(HKEY_CURRENT_USER, RegPath));
    IFREGFAILED_EXIT(::RegDeleteKeyW(HKEY_CURRENT_USER, L"SxsOfflineInstall"));

    FN_EPILOG;
}


#else // free builds have known problems

int __cdecl wmain(int argc, wchar_t ** argv)
{
    fputs("free build does not work, sorry\n", stderr);
    return -1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\xpman3\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\xpmanfile\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\testdata\hello\exemultires\makefile.inc ===
$(O)\MultiExe.res: $(O)\2.manifest $(O)\3.manifest

.SUFFIXES: .manifest-cpp .manifest

{}.manifest-cpp{$(O)}.manifest:
    $(C_PREPROCESSOR_NAME) $(SXS_MANIFEST_DEFINES) $(C_PREPROCESSOR_FLAGS) $< > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\testdata\hello\exe.c ===
#include "windows.h"
#include <stdio.h>

#define FOUR_K 0x1000

int __cdecl wmain(int argc, wchar_t** argv)
{
    WCHAR Buffer[2] = {0};
    HANDLE Dll;
    int i;
    int LoadLibraryError;
    int LoadStringError;
    int Error;

    for (i = 0 ; i < 2 ; ++i)
    {
        // steal the address to force a collision on the next load
        if (i == 1)
        {
            fprintf(stderr, "VirtualAlloc:%p\n", VirtualAlloc(Dll, 1, MEM_RESERVE, PAGE_READONLY));
            fprintf(stderr, "Error:%d\n", Error = GetLastError());
        }

        Dll = LoadLibraryW(L"Dll");
        LoadLibraryError = GetLastError();
        Buffer[0] = 0;
        LoadStringW(Dll, 1, Buffer, sizeof(Buffer)/sizeof(Buffer[0]));
        LoadStringError = GetLastError();
        FreeLibrary(Dll);
        //ZeroMemory(Dll, FOUR_K);
        fprintf(stderr, 
            "%ls: Dll:%p, String:%ls, LoadLibraryError:%d, LoadStringError:%d.\n",
            argv[0],
            Dll,
            Buffer,
            LoadLibraryError,
            LoadStringError);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\sxstest\testdata\hello\exemultires\multiexe.c ===
#include "windows.h"
#include <stdio.h>
#include <stdlib.h>

BOOL
ExtractResourceToFile(
    HMODULE Module,
    PCWSTR  ResourceType,
    PCWSTR  ResourceName,
    WCHAR*  TempFilePath,
    HANDLE* TempFileHandle
    )
{
    WCHAR TempDirectory[MAX_PATH];
    DWORD Dword = 0;
    int ResourceSize = 0;
    void* ResourceAddress = 0;
    HRSRC ResourceInfo = 0;
    BOOL Success = FALSE;

    TempFilePath[0] = 0;
    TempDirectory[0] = 0;
    *TempFileHandle = 0;

#define X(x) do { if (!(x)) { printf("%s failed\n", #x); goto Exit; } } while(0)
    X(ResourceInfo = FindResourceW(Module, ResourceName, ResourceType));
    X(ResourceAddress = LockResource(LoadResource(Module, ResourceInfo)));
    X(ResourceSize = SizeofResource(Module, ResourceInfo));
    X(GetTempPathW(RTL_NUMBER_OF(TempDirectory), TempDirectory));
    X(GetTempFileNameW(TempDirectory, NULL, 0, TempFilePath));
    *TempFileHandle = CreateFileW(TempFilePath, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    X(*TempFileHandle != INVALID_HANDLE_VALUE);
    X(WriteFile(*TempFileHandle, ResourceAddress, ResourceSize, &Dword, NULL));
#undef X
    Success = TRUE;
Exit:
    if (!Success)
    {
        int Error;
        printf("%s() failed %d\n", __FUNCTION__, Error = GetLastError());
    }
    return Success;
}

int __cdecl wmain(int argc, wchar_t** argv)
{
    PCWSTR BaseNames[]  = { L"dll", L"DLL",  L"Dll" };
    PCWSTR Extensions[] = { L"", L".dll", L".DLL",  L".Dll" };
    const static int Flags1[] = { 0, LOAD_LIBRARY_AS_DATAFILE };
    const static int Flags2[] = { LOAD_LIBRARY_AS_DATAFILE, 0 };
    const int* Flags = Flags1;
    const int NumberOfFlags = 2;
    int i=0, j=0, k=0;
    const PCWSTR CommandLine = GetCommandLineW();

    struct ActivationContext
    {
        HANDLE Handle;
        ULONG  Cookie;
    } ActivationContexts[2] = {0}; // INVALID_HANDLE_VALUE is not convenient.
    HANDLE Handle = NULL;
    INT    ResourceId = 0;
    INT    Error = 0;
    WCHAR  Argv0[MAX_PATH];
    PWSTR  FilePart = 0;
    //
    // This is to target this test at older sxs without the resource feature.
    //
    DWORD  ResourceFlag = ACTCTX_FLAG_RESOURCE_NAME_VALID;

    if ((wcsstr(CommandLine, L"-swapFlagOrder") != 0) ||
        (wcsstr(CommandLine, L"-swapflagorder") != 0) ||
        (wcsstr(CommandLine, L"-swap-flag-order") != 0) ||
        (wcsstr(CommandLine, L"-alterFlagOrder") != 0) ||
        (wcsstr(CommandLine, L"-alterflagorder") != 0) ||
        (wcsstr(CommandLine, L"-alter-flag-order") != 0))
    {
       Flags = Flags2;
    }

    if ((wcsstr(CommandLine, L"-filesInsteadOfResources") != 0) ||
        (wcsstr(CommandLine, L"-filesinsteadofresources") != 0) ||
        (wcsstr(CommandLine, L"-files-instead-of-resources") != 0))
    {
        ResourceFlag = 0;
    }

    if ((wcsstr(CommandLine, L"-alterEmptyExtensionOrder") != 0) ||
        (wcsstr(CommandLine, L"-alteremptyextensionorder") != 0) ||
        (wcsstr(CommandLine, L"-alter-empty-extension-order") != 0))
    {
        Extensions[0] = Extensions[1];
        Extensions[1] = L"";
    }

    if ((wcsstr(CommandLine, L"-alterCaseOrder") != 0) ||
        (wcsstr(CommandLine, L"-altercaseorder") != 0) ||
        (wcsstr(CommandLine, L"-alter-case-order") != 0))
    {
        // flip the case of each letter, this actually creates previously nonexistant
        // cases: .dLL
        WCHAR* String = 0;
        const WCHAR* ConstString = 0;
        for (i = 0 ; i < RTL_NUMBER_OF(BaseNames) ; ++i)
        {
            ConstString = BaseNames[i];
#define X \
            if (ConstString) \
            { \
                String = _wcsdup(ConstString); \
                BaseNames[i] = String; \
                while (*String) \
                    if (*String != '.') *String++ ^= 0x20; \
                    else String++; \
            }
            X
        }
        for (i = 0 ; i < RTL_NUMBER_OF(Extensions) ; ++i)
        {
            ConstString = Extensions[i];
            X
#undef X
        }
    }

    //printf("argv[0]: %ls\n", argv[0]);
    Argv0[0] = 0;
    if (!GetFullPathNameW(argv[0], RTL_NUMBER_OF(Argv0), Argv0, NULL))
    {
        printf("GetFullPathNameW(%ls) failed %d\n", argv[0], Error = GetLastError());
        exit(Error);
    }
    //printf("Argv0: %ls\n", Argv0);
    __try
    {
        for (ResourceId = 0 ; ResourceId < RTL_NUMBER_OF(ActivationContexts) ; ++ResourceId)
        {
            HANDLE ManifestFileHandle = 0;
            WCHAR  ManifestFile[MAX_PATH];
            ACTCTXW CreateActivationContextParameters = {sizeof(CreateActivationContextParameters)};
            ManifestFile[0] = 0;

            CreateActivationContextParameters.dwFlags = ResourceFlag;
            CreateActivationContextParameters.lpResourceName = (PCWSTR)(INT_PTR)(ResourceId + 2);
            CreateActivationContextParameters.lpSource = Argv0;

            if (!ResourceFlag)
            {
                ExtractResourceToFile(
                    NULL,
                    //GetModuleHandleW(NULL),
                    (PCWSTR)RT_MANIFEST,
                    CreateActivationContextParameters.lpResourceName,
                    ManifestFile,
                    &ManifestFileHandle);
                CreateActivationContextParameters.lpSource = ManifestFile;

                printf("dwFlags:0x%lx\n", CreateActivationContextParameters.dwFlags);
                printf("lpSource:%ls\n", CreateActivationContextParameters.lpSource);
            }

            // switch access to readonly
            // keep the file open to prevent deletion
            if (ManifestFileHandle)
            {
                if (!DuplicateHandle(
                    GetCurrentProcess(),
                    ManifestFileHandle,
                    GetCurrentProcess(),
                    &ManifestFileHandle,
                    GENERIC_READ,
                    FALSE,
                    DUPLICATE_CLOSE_SOURCE))
                {
                    ManifestFileHandle = 0;
                }
            }

            Handle = CreateActCtxW(&CreateActivationContextParameters);

            if (Handle == INVALID_HANDLE_VALUE)
                Error = GetLastError();
            if (ManifestFileHandle)
            {
                CloseHandle(ManifestFileHandle);
                ManifestFileHandle = 0;
            }
            if (ManifestFile[0])
            {
                //DeleteFileW(ManifestFile);
                ManifestFile[0] = 0;
            }
            if (Handle == INVALID_HANDLE_VALUE)
            {
                printf("CreateActCtxW(ResourceId:%d) failed %d\n", (ResourceId + 2), Error);
            }
            else
            {
                printf("CreateActCtxW(ResourceId:%d):%p\n", (ResourceId + 2), Handle);
                if (!ActivateActCtx(Handle, &ActivationContexts[ResourceId].Cookie))
                {
                    printf("ActivateActCtx(ResourceId:%d, Handle:%p) failed %d\n", (ResourceId + 2), Handle, Error = GetLastError());
                    ReleaseActCtx(Handle);
                }
                else
                {
                    ActivationContexts[ResourceId].Handle = Handle;
                }
            }
            for (i = 0 ; i < RTL_NUMBER_OF(BaseNames) ; ++i)
            {
                for (j = 0 ; j < RTL_NUMBER_OF(Extensions) ; ++j)
                {
                    for (k = 0 ; k < NumberOfFlags ; ++k)
                    {
                        HRSRC  ResourceInfo = NULL;
                        WCHAR  StringResourceBuffer[2] = {0};
                        HANDLE Dll = 0;
                        WCHAR  Name[8+1+3+1];
                        WCHAR  ModuleNameBuffer[MAX_PATH];
                        Name[0] = 0;
                        ModuleNameBuffer[0] = 0;

                        wcscat(Name, BaseNames[i]);
                        wcscat(Name, Extensions[j]);

                        Dll = LoadLibraryExW(Name, NULL, Flags[k]);
                        Error = GetLastError();
                        if (Dll)
                        {
                            LoadStringW(Dll, 1, StringResourceBuffer, RTL_NUMBER_OF(StringResourceBuffer));
                            GetModuleFileNameW(Dll, ModuleNameBuffer, RTL_NUMBER_OF(ModuleNameBuffer));
                            ResourceInfo = FindResourceW(Dll, (PCWSTR)1, (PCWSTR)RT_STRING);
                            FreeLibrary(Dll);
                        }
                        printf(
                            "LoadLibraryExW(%ls, 0x%x):%p, Error:%d, ResourceInfo:%p, String:%ls, ModuleName:%ls.\n",
                            Name,
                            Flags[k],
                            Dll,
                            Error,
                            ResourceInfo,
                            StringResourceBuffer,
                            ModuleNameBuffer);
                    }
                }
            }
        }
        for (ResourceId = RTL_NUMBER_OF(ActivationContexts) - 1 ; ResourceId >= 0 ; --ResourceId)
        {
            Handle = ActivationContexts[ResourceId].Handle;
            if (Handle)
            {
                ULONG Cookie = ActivationContexts[ResourceId].Cookie;
                if (!DeactivateActCtx(0, Cookie))
                {
                    printf(
                        "DeactivateActCtx(ResourceId:%d, Handle:%p, Cookie:0x%lx) failed %d\n",
                        ResourceId + 2,
                        Handle,
                        Cookie,
                        Error = GetLastError());
                }
                ReleaseActCtx(Handle);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        printf("0x%x\n", Error = GetExceptionCode());
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\xiaoyuw\actctx\sxspool\encode.h ===
#include "basic.h"

NTSTATUS SxspUCS2StringToUTF8String(
    DWORD dwFlags,
    PCWSTR Ucs2Str,
    DWORD CchUcs2Str,
    PBYTE Buf,
    DWORD *chBuf    
    );

NTSTATUS SxspUTF82StringToUCS2String(
    IN      DWORD    dwFlags,
    IN      PBYTE    Buf,
    IN      DWORD    chBuf, // size in byte
    IN OUT  PWSTR    Ucs2String,
    IN OUT  DWORD    *chUcs2String
    );

#define FUSION_HASH_ALGORITHM HASH_STRING_ALGORITHM_X65599

NTSTATUS SxspHashString(PCWSTR String, SIZE_T cch, PULONG HashValue, bool CaseInsensitive);
NTSTATUS SxspHashGUID(REFGUID rguid, ULONG &rulPseudoKey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\xiaoyuw\actctx\sxspool\pool.cpp ===
#include "sxspool.h"


// save data into pool and set the index table

NTSTATUS SXS_STRING_POOL::GetDataFromPoolBasedOnIndexTable(
    IN SXS_STRING_POOL_INDEX_ENTRY & indexData, 
    OUT SXS_STRING_POOL_DATA & pooldata
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    IF_NOT_NTSTATUS_SUCCESS_EXIT(pooldata.NtAssign(m_pbPool + indexData.GetOffset(), indexData.GetLength()));

    FN_EPILOG;
}

NTSTATUS SXS_GUID_POOL::GetDataFromPoolBasedOnIndexTable(
    IN SXS_GUID_POOL_INDEX_ENTRY & indexData, 
    OUT SXS_GUID_POOL_DATA & pooldata
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    pooldata.SetValue(*((GUID*)m_pbPool + indexData.GetOffset() / sizeof(GUID)));

    FN_EPILOG;
}

NTSTATUS SXS_GUID_POOL::HashData(
    IN DWORD            dwFlags,
    IN const GUID&      data, 
    OUT ULONG&          ulHashValue
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    PARAMETER_CHECK(dwFlags == 0);
    IF_NOT_NTSTATUS_SUCCESS_EXIT(SxspHashGUID(data, ulHashValue));

    FN_EPILOG;    
}

NTSTATUS SXS_STRING_POOL::HashData(
    IN DWORD                                dwFlags,
    IN const SXS_STRING_POOL_INPUT_DATA&    data, 
    OUT ULONG&                              ulHash
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    PARAMETER_CHECK(dwFlags == 0);    
    IF_NOT_NTSTATUS_SUCCESS_EXIT(
        SxspHashString(data.GetStr(), data.GetCch(), &ulHash, m_ePooltype == SXS_POOL_TYPE_CASE_INSENSITIVE_STRING ? true : false));

    FN_EPILOG;    
}

NTSTATUS SXS_STRING_POOL::ConvertPoolDataToOutputData(
    IN DWORD dwFlags,
    IN SXS_STRING_POOL_DATA & dataInPool, 
    OUT SXS_STRING_POOL_INPUT_DATA & dataOut
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);
    DWORD len = dataOut.GetCch();    

    PARAMETER_CHECK(dwFlags == 0);    
    IF_NOT_NTSTATUS_SUCCESS_EXIT(SxspUTF82StringToUCS2String(
        0, dataInPool.GetPtr(), dataInPool.GetCch(), dataOut.GetBuffer(), &len));

    FN_EPILOG;
}

NTSTATUS SXS_GUID_POOL::ConvertPoolDataToOutputData(
    IN DWORD dwFlags,
    IN SXS_GUID_POOL_DATA & dataInPool, 
    OUT GUID & dataOut
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    PARAMETER_CHECK(dwFlags == 0);    
    dataInPool.GetValue(dataOut);

    FN_EPILOG;
}


NTSTATUS SXS_STRING_POOL::ConverInputDataIntoPoolData(
    IN DWORD dwFlags,
    IN const SXS_STRING_POOL_INPUT_DATA   & dataInput, 
    OUT SXS_STRING_POOL_DATA        & dataInPool
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    IF_NOT_NTSTATUS_SUCCESS_EXIT(dataInPool.NtAssign(dataInput.GetStr(), dataInput.GetCch()));

    FN_EPILOG;
}

NTSTATUS SXS_GUID_POOL::ConverInputDataIntoPoolData(
    IN DWORD dwFlags,
    IN const GUID & dataInput, 
    OUT SXS_GUID_POOL_DATA        & dataInPool
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    dataInPool.SetValue(dataInput);   

    FN_EPILOG;
}

NTSTATUS SXS_STRING_DATA<WCHAR>::NtAssign(PCWSTR Str, DWORD Cch)
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    INTERNAL_ERROR_CHECK(m_fValueAssigned == false);
    m_fValueAssigned = true;

    m_pstrData = const_cast<WCHAR *>(Str);
    m_Cch = Cch;

    FN_EPILOG;
}

NTSTATUS SXS_STRING_DATA<WCHAR>::NtAssign(PBYTE Str, DWORD Ccb)
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    INTERNAL_ERROR_CHECK(m_fValueAssigned == false);
    m_fValueAssigned = true;

    IF_NOT_NTSTATUS_SUCCESS_EXIT(SxspUTF82StringToUCS2String(0, Str, Ccb, NULL, &m_Cch));
    IFALLOCFAILED_EXIT(m_pstrData = FUSION_NEW_ARRAY(WCHAR, m_Cch));
    m_fMemoryAllocatedInside = true;
    IF_NOT_NTSTATUS_SUCCESS_EXIT(SxspUTF82StringToUCS2String(0, Str, Ccb, m_pstrData, &m_Cch));

    FN_EPILOG;
}


NTSTATUS SXS_STRING_DATA<BYTE>::NtAssign(PCWSTR Str, DWORD Cch)
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    INTERNAL_ERROR_CHECK(m_fValueAssigned == false);
    m_fValueAssigned = true;

    IF_NOT_NTSTATUS_SUCCESS_EXIT(SxspUCS2StringToUTF8String(0, Str, Cch, NULL, &m_Cch));
    IFALLOCFAILED_EXIT(m_pstrData = FUSION_NEW_ARRAY(BYTE, m_Cch));
    m_fMemoryAllocatedInside = true;
    IF_NOT_NTSTATUS_SUCCESS_EXIT(SxspUCS2StringToUTF8String(0, Str, Cch, m_pstrData, &m_Cch));

    FN_EPILOG;
}

NTSTATUS SXS_STRING_DATA<BYTE>::NtAssign(PBYTE Str, DWORD Ccb)
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    INTERNAL_ERROR_CHECK(m_fValueAssigned == false);
    m_fValueAssigned = true;

    m_pstrData = Str;
    m_Cch = Ccb;

    FN_EPILOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\xiaoyuw\actctx\sxspool\basic.h ===
#pragma once

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "malloc.h"

#define MAX(a,b) a>b? a : b

#define FN_TRACE_NTSTATUS(x)
#define IF_NOT_NTSTATUS_SUCCESS_EXIT(x) do { Status = (x); if (!(NT_SUCCESS(Status))) goto Exit;} while(0);
#define FUSION_NEW_BLOB(x) (BYTE *)malloc(x)
#define FUSION_DELETE_BLOB(x) free(x)
#define FUSION_NEW_ARRAY(TYPE, dwEntryCount) (TYPE *)malloc(sizeof(TYPE) * dwEntryCount)
#define FUSION_FREE_ARRAY(x) free(x)
#define IFALLOCFAILED_EXIT(x) do { (x); if( (x) == NULL) {Status = STATUS_NO_MEMORY; goto Exit; }} while(0)
#define IF_ZERO_EXIT(x) do {if ((x) == 0) {Status = STATUS_UNSUCCESSFUL; goto Exit;}} while (0)
#define PARAMETER_CHECK(x) do {if (!(x)) {Status = STATUS_INVALID_PARAMETER; goto Exit;}} while(0)
#define FN_EPILOG if (false) goto Exit; Exit: return Status;
#define INTERNAL_ERROR_CHECK(x) do {if (!(x)) {Status = STATUS_INTERNAL_ERROR; goto Exit;} } while(0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\xiaoyuw\actctx\sxspool\sxspool.h ===
#pragma once
#include "basic.h"
#include "encode.h"

// there are 3 types of pool: 
//      (1). case-insensitive string pool
//      (2). case-sensitive string pool
//      (3). GUID pool

#define MAX_DWORD 0xFFFF
typedef enum _sxs_pool_type_{
    SXS_POOL_TYPE_UNIDENTIFIED,
    SXS_POOL_TYPE_GUID,
    SXS_POOL_TYPE_CASE_INSENSITIVE_STRING,
    SXS_POOL_TYPE_CASE_SENSITIVE_STRING
}SXS_POOL_TYPE;

// default action is error if already exist in the pool
#define SXS_POOL_ADD_IF_ALREADY_IN_POOL_IGNORE      0x0001

#define SXS_STRING_POOL_DEFAULT_SIZE_IN_BYTE        1024
#define SXS_GUID_POOL_DEFAULT_SIZE_IN_BYTE          1024

#define SXS_POOL_DEFAULT_INDEX_TABLE_SIZE           32

#define SXS_POOL_INDEXTABLE_PROBE_ONLY                      0x0000
#define SXS_POOL_INDEXTABLE_PROBE_IF_NOT_EXIST_INSERT_DATA  0x0001

#define SXS_POOL_ADD_CONVERTED_DATA_INTO_POOL               0x0001
#define SXS_POOL_ADD_DATA_INTOP_OOL_CONVERT_FIRST           0x0002
/*
class SXS_POOL_INDEX_ENTRY{
private:
    inline VOID SetOffset(DWORD offset) {m_offset = offset;};
    virtual VOID SetLength(DWORD length) = 0;

    inline DWORD GetOffset() const {return m_offset; }
    virtual DWORD GetLength() const = 0;

    DWORD m_offset;
}
*/
class SXS_POOL_INDEX_ENTRY{
public:
    SXS_POOL_INDEX_ENTRY(){}

    virtual VOID SetIndexEntry(DWORD offset, DWORD length) = 0;
    virtual VOID GetIndexEntry(DWORD & offset, DWORD * length) = 0;
    inline DWORD GetOffset() const {return m_offset;}
    inline VOID SetOffset(DWORD offset) {m_offset = offset;}

protected:    
    DWORD m_offset;
};

class SXS_STRING_POOL_INDEX_ENTRY : public SXS_POOL_INDEX_ENTRY{
public:
    inline VOID SetIndexEntry(DWORD offset, DWORD length) { m_offset = offset; m_length = length;}
    inline VOID GetIndexEntry(DWORD & offset, DWORD * length){ offset = m_offset; ASSERT(length != NULL); *length = m_length;}
    inline DWORD GetLength() const { return m_length; }
private:    
    DWORD m_length;
};

class SXS_GUID_POOL_INDEX_ENTRY : public SXS_POOL_INDEX_ENTRY{
public:
    inline VOID SetIndexEntry(DWORD offset, DWORD length = 0){ m_offset = offset; }
    inline VOID GetIndexEntry(DWORD & offset, DWORD * length = NULL) {offset = m_offset; }
};

class SXS_POOL_DATA{
public:
    SXS_POOL_DATA(DWORD dwUnitSize):m_dwCount(1), m_dwUnitSize(dwUnitSize){}
    SXS_POOL_DATA(DWORD dwUnitSize, DWORD c):m_dwCount(c), m_dwUnitSize(dwUnitSize){}

    inline BOOL IsContentEqual(SXS_POOL_DATA & b)
    {   
        if (this->GetSizeInByte() == b.GetSizeInByte())
            return (memcmp(this->GetPtr(), b.GetPtr(), GetSizeInByte()) == 0);
        return FALSE;
    }
    inline DWORD GetSizeInByte() const { return m_dwCount * m_dwUnitSize; }
    virtual PBYTE GetPtr() const = 0;

protected:
    DWORD m_dwCount;    
    DWORD m_dwUnitSize;
};

template <typename TSimpleDataType>
class SXS_SIMPLEDATA_POOL_DATA : public SXS_POOL_DATA
{
public:
    SXS_SIMPLEDATA_POOL_DATA(TSimpleDataType & d): m_data(d) {SXS_SIMPLEDATA_POOL_DATA(); }
    SXS_SIMPLEDATA_POOL_DATA(TSimpleDataType d): m_data(d) {SXS_SIMPLEDATA_POOL_DATA(); }
    inline VOID SetValue(const TSimpleDataType & data) {m_data = data;}
    inline VOID GetValue(TSimpleDataType & data) {data = m_data;}
    inline PBYTE GetPtr() const { return (PBYTE)&m_data; }; // since it is already a ref

protected:
    TSimpleDataType & m_data;
    SXS_SIMPLEDATA_POOL_DATA():SXS_POOL_DATA(sizeof(TSimpleDataType)){}
};
//
// this class is never been reassigned, that is, once it is assigned value, it will keep this value until it is deconstructed
//
template <typename TCHAR> 
class SXS_STRING_DATA : public SXS_POOL_DATA{
public:
    SXS_STRING_DATA():
      m_pstrData(NULL), m_fMemoryAllocatedInside(false), m_fValueAssigned(false), SXS_POOL_DATA(sizeof(TCHAR), 0), m_Cch(m_dwCount){}
      
    ~SXS_STRING_DATA()
    {
        if (m_fMemoryAllocatedInside) {
            FUSION_FREE_ARRAY(m_pstrData);
        }        
    }    
    NTSTATUS NtAssign(PCWSTR Str, DWORD Cch);
    NTSTATUS NtAssign(PBYTE Str, DWORD Ccb);
    
    NTSTATUS NtResize(DWORD cch)
    {
        NTSTATUS Status = STATUS_SUCCESS;
        FN_TRACE_NTSTATUS(Status);

        INTERNAL_ERROR_CHECK(m_fValueAssigned == false);    
        INTERNAL_ERROR_CHECK(m_pstrData == NULL);

        IFALLOCFAILED_EXIT(m_pstrData = FUSION_NEW_ARRAY(TCHAR, cch));
        m_Cch = cch;

        FN_EPILOG;
    }

    inline VOID Clean() const {ASSERT(m_pstrData != NULL); m_pstrData[0] = 0;}


    inline DWORD  GetCch() const { return m_Cch; }
    inline TCHAR* GetStr() const { return m_pstrData;}
    inline TCHAR* GetBuffer() { return m_pstrData;}
    inline PBYTE GetPtr() const { return (PBYTE)m_pstrData; }; // since it is already a ref

private:
    TCHAR*  m_pstrData;         // offset in the pool
    DWORD   &m_Cch;             // length of TCHAR
    bool    m_fValueAssigned;
    bool    m_fMemoryAllocatedInside;
};


template <typename TInputData, typename TIndexTableData, typename TPoolData, DWORD dwPoolSize = 0, DWORD dwIndexTableSize = 0>
class SxsPool{
public:
    SxsPool():m_fInitialized(false), m_ePooltype(SXS_POOL_TYPE_UNIDENTIFIED), m_dwPoolSizeInByte(0),
        m_pbPool(NULL), m_cursor(NULL), m_IndexData(NULL), m_IndexTableSize(0), m_cConflict(0) {}

    ~SxsPool(){        
        switch(m_ePooltype)
        {
        default:
            ASSERT(FALSE); // never happen
            break;
        case SXS_POOL_TYPE_UNIDENTIFIED:
            {
                ASSERT(m_pbPool == NULL);
                ASSERT(m_dwPoolSizeInByte == 0);
                ASSERT(m_cursor == NULL);            
                ASSERT(m_IndexData == NULL);
                ASSERT(m_IndexTableSize == 0);           
                
                break;
            }
        case SXS_POOL_TYPE_GUID:
        case SXS_POOL_TYPE_CASE_INSENSITIVE_STRING:
        case SXS_POOL_TYPE_CASE_SENSITIVE_STRING:
            {
                FUSION_DELETE_BLOB(m_pbPool);            
                FUSION_FREE_ARRAY(m_IndexData);

                break;
            }
        }// end of switch
    }

    NTSTATUS Initialize(IN SXS_POOL_TYPE ePoolType)
    {
        NTSTATUS Status = STATUS_SUCCESS;
        FN_TRACE_NTSTATUS(Status);

        PARAMETER_CHECK((ePooltype == SXS_GUID_POOL) || 
            (ePooltype == SXS_CASE_INSENSITIVE_STRING_POOL) || 
            (ePooltype == SXS_CASE_SENSITIVE_STRING_POOL));

        INTERNAL_ERROR_CHECK(m_fInitialized == false);
        m_fInitialized = true;
        m_ePooltype = ePooltype;

        m_dwPoolSizeInByte = dwPoolSize;
        if (m_dwPoolSizeInByte == 0)
            m_dwPoolSizeInByte = (ePooltype != SXS_GUID_POOL ? SXS_STRING_POOL_DEFAULT_SIZE_IN_BYTE : SXS_GUID_POOL_DEFAULT_SIZE_IN_BYTE);
        IFALLOCFAILED_EXIT(m_pbPool = FUSION_NEW_BLOB(m_dwPoolSizeInByte));
        m_cursor = NULL;

        m_IndexTableSize = dwIndexTableSize > 0 ? dwIndexTableSize : SXS_POOL_DEFAULT_INDEX_TABLE_SIZE;    
        IFALLOCFAILED_EXIT(m_IndexData = FUSION_NEW_ARRAY(TIndexTableData, m_IndexTableSize));
        ZeroMemory(m_IndexData, sizeof(TIndexTableData) * m_IndexTableSize);

        FN_EPILOG;
    }

    // Function:
    //  
    //  adding a string/guid into pool, adding entry to index table
    //  return the index in the index table
    //  this function is used mostly
    //
    NTSTATUS Add(
        IN DWORD                dwFlags,
        IN const TInputData&    data,         
        OUT BOOL&               fAlreadyExist,
        OUT DWORD&              dwIndexInTable
        )
    {        
        NTSTATUS Status = STATUS_SUCCESS;
        FN_TRACE_NTSTATUS(Status);
        DWORD dwIndex;
        TIndexTableData dataInIndexTable;
        TPoolData poolData;
        ULONG ulHash;

        PARAMETER_CHECK((dwFlags & ~SXS_POOL_ADD_IF_ALREADY_IN_POOL_IGNORE) == 0);

        INTERNAL_ERROR_CHECK(m_fInitialized == true); 

        IF_NOT_NTSTATUS_SUCCESS_EXIT(ConverInputDataIntoPoolData(0, data, poolData));
        IF_NOT_NTSTATUS_SUCCESS_EXIT(HashData(0, data, ulHash));
        // check whether the data has already in the pool and whether this is allowed
        IF_NOT_NTSTATUS_SUCCESS_EXIT(LocateEntryInIndexTable(0, poolData, ulHash, fAlreadyExist, dwIndex));
        
        if ((fAlreadyExist) && (!(dwFlags & SXS_POOL_ADD_IF_ALREADY_IN_POOL_IGNORE)))
        {
            Status = STATUS_DUPLICATE_NAME;
            goto Exit;
        }

        IF_NOT_NTSTATUS_SUCCESS_EXIT(SaveDataIntoPool(0, dwIndex, poolData));
        dwIndexInTable = dwIndex;

        FN_EPILOG;
    }


    // Function:
    //  
    //  fetch data (string or a guid) from pool
    //  if data == NULL, length will be returned about the required bytes
    //
    NTSTATUS FetchDataFromPool(
        IN DWORD dwFlags,            
        IN DWORD dwIndex,      
        OUT TInputData & data
        )
    {
        NTSTATUS Status = STATUS_SUCCESS;
        FN_TRACE_NTSTATUS(Status);
        TPoolData PoolData;

        PARAMETER_CHECK(dwFlags == 0);

        IF_NOT_NTSTATUS_SUCCESS_EXIT(GetDataFromPoolBasedOnIndexTable(m_IndexData[dwIndex], PoolData));
        IF_NOT_NTSTATUS_SUCCESS_EXIT(ConvertPoolDataToOutputData(0, PoolData, data));
           
        FN_EPILOG;
    }

private:    
    // private functions

    // functions must be instantiated
    inline VOID SetIndexTableEntry(TIndexTableData & entry, DWORD offset, DWORD length =0);
    
    NTSTATUS GetDataFromPoolBasedOnIndexTable(
        IN TIndexTableData & indexData, 
        OUT TPoolData & pooldata
        );
 
    NTSTATUS HashData(
        IN DWORD                dwFlags,
        IN const TInputData&    data, 
        OUT ULONG&              ulHashValue
        );

    NTSTATUS ConvertPoolDataToOutputData(
        IN DWORD dwFlags,
        IN TPoolData & dataInPool, 
        OUT TInputData & dataOut
        );

    NTSTATUS ConverInputDataIntoPoolData(
        IN DWORD dwFlags,
        IN const TInputData & dataOut, 
        OUT TPoolData & dataInPool
        );

    // "real" template functions
    NTSTATUS ExtendPool(DWORD dwMiniRequirement)
    {
        NTSTATUS Status = STATUS_SUCCESS;
        FN_TRACE_NTSTATUS(Status);
        BYTE * tpool = NULL;

        DWORD dwExtend = MAX(dwMiniRequirement, m_dwPoolSizeInByte / 2);
        if ( dwExtend + m_dwPoolSizeInByte > MAX_DWORD)
        {
            Status = STATUS_INTEGER_OVERFLOW;
            goto Exit;
        }

        IFALLOCFAILED_EXIT(tpool = FUSION_NEW_BLOB(dwExtend + m_dwPoolSizeInByte));
        DWORD dwOccupied = m_cursor - m_pbPool;
        memcpy(tpool, m_pbPool, dwOccupied);
        FUSION_DELETE_BLOB(m_pbPool);
        m_pbPool = tpool;
        tpool = NULL;
        m_dwPoolSizeInByte = dwExtend + m_dwPoolSizeInByte;
        m_cursor = m_pbPool + dwOccupied;

    Exit:
        if (tpool != NULL)
            FUSION_DELETE_BLOB(tpool);

        return Status;
    }

    NTSTATUS LocateEntryInIndexTable(    
        IN DWORD                dwFlags,        
        IN const TPoolData&     poolData, 
        IN ULONG                ulHash,
        OUT BOOL&               fAlreadyExist,
        OUT DWORD&              dwIndexOut
        )
    {
        NTSTATUS Status = STATUS_SUCCESS;
        FN_TRACE_NTSTATUS(Status);

        ULONG ulHash2;
        ULONG ulIndex;
        TPoolData StoredData;
        DWORD dwSizeMask = m_IndexTableSize - 1;
        BOOL fExist = false;
        
        PARAMETER_CHECK(dwFlags == 0);
        fAlreadyExist = FALSE;

        ulIndex = ulHash & dwSizeMask;
        ulHash2 = ((ulHash * 17) & dwSizeMask) | 1;
        while(1) {
            if (m_IndexData[ulIndex].GetOffset() == 0) // index empty
                break;
     
            IF_NOT_NTSTATUS_SUCCESS_EXIT(GetDataFromPoolBasedOnIndexTable(m_IndexData[ulIndex], StoredData));
            if (StoredData.IsContentEqual(const_cast<TPoolData &>(poolData)))
            {
                fExist = TRUE;
                break;
            }

            // rehash
            ulIndex = (ulIndex + ulHash2) & dwSizeMask;
            m_cConflict ++;
        }

        fAlreadyExist = fExist;
        dwIndexOut = (DWORD)ulIndex;

        FN_EPILOG;
    }

    NTSTATUS SaveDataIntoPool(
        IN DWORD                dwFlags,
        IN DWORD                dwEntryIndexTable,
        IN const TPoolData &    poolData    
        )
    {
        NTSTATUS Status = STATUS_SUCCESS;
        FN_TRACE_NTSTATUS(Status);

        PARAMETER_CHECK(dwFlags == 0);

        DWORD dwRequiredDataSizeInByte = poolData.GetSizeInByte();

        if ( dwRequiredDataSizeInByte > m_dwPoolSizeInByte - (m_cursor - m_pbPool))
        {
            IF_NOT_NTSTATUS_SUCCESS_EXIT(ExtendPool(dwRequiredDataSizeInByte));
        }

        memcpy(m_cursor, poolData.GetPtr(), dwRequiredDataSizeInByte);
        m_IndexData[dwEntryIndexTable].SetIndexEntry(m_cursor - m_pbPool, poolData.GetCch());
        m_cursor += dwRequiredDataSizeInByte;

        FN_EPILOG;    
    }

    // private data member
    bool                                m_fInitialized;
    SXS_POOL_TYPE                       m_ePooltype;    
    PBYTE                               m_pbPool;          
    DWORD                               m_dwPoolSizeInByte;      
    PBYTE                               m_cursor;          

    TIndexTableData*                    m_IndexData;      // only needed for string pool
    DWORD                               m_IndexTableSize;    

    // for statistics purpose
    DWORD                               m_cConflict;
    DWORD                               m_cSearch;

};

typedef SXS_STRING_DATA<BYTE>           SXS_STRING_POOL_DATA;
typedef SXS_STRING_DATA<WCHAR>          SXS_STRING_POOL_INPUT_DATA;
typedef SXS_SIMPLEDATA_POOL_DATA<GUID>  SXS_GUID_POOL_DATA;

typedef SxsPool<SXS_STRING_POOL_INPUT_DATA, SXS_STRING_POOL_INDEX_ENTRY, SXS_STRING_POOL_DATA> SXS_STRING_POOL;
typedef SxsPool<GUID, SXS_GUID_POOL_INDEX_ENTRY, SXS_GUID_POOL_DATA> SXS_GUID_POOL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\xiaoyuw\actctx\sxspool\test.cpp ===
#include "basic.h"
#include "sxspool.h"
#include "stdio.h"

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    SXS_STRING_POOL strPool;
    NTSTATUS Status;
  
    WCHAR * myStrings[] ={L"111", L"222", L"333", L"444", L"555", L"666"};
    DWORD dwStringCounter = 6;
    SXS_STRING_POOL_INPUT_DATA strOutput; 
    //
    // test for String Pool
    //

    // step1: adding strings into string pool
    for (DWORD i = 0; i < dwStringCounter; i++)
    {
        SXS_STRING_POOL_INPUT_DATA strInput; 
        BOOL fAlreadyExist = FALSE;
        DWORD dwIndex;

        IF_NOT_NTSTATUS_SUCCESS_EXIT(strInput.NtAssign(myStrings[i], wcslen(myStrings[i])));
        IF_NOT_NTSTATUS_SUCCESS_EXIT(strPool.Add(0, strInput, fAlreadyExist, dwIndex));
    }

    // step2: get out string based on index from stringpool
    
    IF_NOT_NTSTATUS_SUCCESS_EXIT(strOutput.NtResize(20));
    printf(" Index \t  String\n");
    printf("------------------------------");
    for ( DWORD i =0 ; i < 32; i++)
    {
        strOutput.Clean();
        IF_NOT_NTSTATUS_SUCCESS_EXIT(strPool.FetchDataFromPool(0, i, strOutput)); 
        printf("%d\t%S\n", i, strOutput.GetCch() == 0 ? L"NoString" : strOutput.GetStr());
        
    }
    printf("------------------------------");

    /*

    //
    // Test for GUID pool
    //

    // {928096A8-734F-4f8e-BA83-A1E8927B4605}
    DEFINE_GUID(guid_1, 
    0x928096a8, 0x734f, 0x4f8e, 0xba, 0x83, 0xa1, 0xe8, 0x92, 0x7b, 0x46, 0x5);

    // {9372D783-12E2-4985-8CDA-A6E75E5CBADD}
    DEFINE_GUID(guid_2, 
    0x9372d783, 0x12e2, 0x4985, 0x8c, 0xda, 0xa6, 0xe7, 0x5e, 0x5c, 0xba, 0xdd);

    // {18139889-8DC9-4fc1-8103-026A902609A2}
    DEFINE_GUID(guid_3, 
    0x18139889, 0x8dc9, 0x4fc1, 0x81, 0x3, 0x2, 0x6a, 0x90, 0x26, 0x9, 0xa2);

    // {4205E06C-C92F-441e-A03C-211E4A1BF476}
    DEFINE_GUID(guid_4, 
    0x4205e06c, 0xc92f, 0x441e, 0xa0, 0x3c, 0x21, 0x1e, 0x4a, 0x1b, 0xf4, 0x76);


    GUID myGuids[4] ={};



    */


Exit:
    return (Status == STATUS_SUCCESS ? 0 : 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tests\xiaoyuw\actctx\sxspool\encode.cpp ===
#include "encode.h"

NTSTATUS SxspUCS2StringToUTF8String(
    IN      DWORD    dwFlags,
    IN      PCWSTR   Ucs2String,
    IN      DWORD    CchUcs2Str,
    IN OUT  PBYTE    Buf,
    IN OUT  DWORD    *chBuf    
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);

    PARAMETER_CHECK(chBuf != NULL);     // if *chBuf == 0, this function will return the length in BYTE;
                                        // else, it specifies the capacity of byte buffer;
    int iRet;
    IF_ZERO_EXIT(iRet = WideCharToMultiByte(CP_UTF8, 0, Ucs2String, CchUcs2Str, (PSTR)Buf, *chBuf, NULL, NULL));
    *chBuf = iRet;
    
    FN_EPILOG;
}

NTSTATUS SxspUTF82StringToUCS2String(
    IN      DWORD    dwFlags,
    IN      PBYTE    Buf,
    IN      DWORD    chBuf, // size in byte
    IN OUT  PWSTR    Ucs2String,
    IN OUT  DWORD    *chUcs2String
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    FN_TRACE_NTSTATUS(Status);
    
    PARAMETER_CHECK(chUcs2String != NULL);  // if *chUcs2String == 0, this function will return the length in WCHAR;
                                            // else, it specifies the capacity of wchar buffer;
    int iRet;
    IF_ZERO_EXIT(iRet = MultiByteToWideChar(CP_UTF8, 0, (PSTR)Buf, chBuf, Ucs2String, *chUcs2String));
    *chUcs2String = iRet;
    
    FN_EPILOG;
}

NTSTATUS SxspHashString(
    PCWSTR String, 
    SIZE_T cch,
    PULONG HashValue,
    bool CaseInsensitive = true
    )
{   
    NTSTATUS Status = STATUS_SUCCESS;    
    FN_TRACE_NTSTATUS(Status);

    UNICODE_STRING s;
    s.MaximumLength = static_cast<USHORT>(cch * sizeof(WCHAR));
    // check for overflow
    ASSERT(s.MaximumLength == (cch * sizeof(WCHAR)));
    s.Length = s.MaximumLength;
    s.Buffer = const_cast<PWSTR>(String);

    IF_NOT_NTSTATUS_SUCCESS_EXIT(::RtlHashUnicodeString(&s, CaseInsensitive, FUSION_HASH_ALGORITHM, HashValue));

    FN_EPILOG;
}

/* 
sxs hash algorithm for GUID
*/
NTSTATUS SxspHashGUID(REFGUID rguid, ULONG &rulPseudoKey)
{
    const ULONG *p = (const ULONG *) &rguid;
    rulPseudoKey = p[0] + p[1] + p[2] + p[3];
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\append\append.cpp ===
#include "windows.h"
#include "ntverp.h"
#include <string>
#include <xstring>
#include <utility>
#include <vector>

using namespace std;

bool g_BufferStdInFully = false;
bool g_LockPerItem = false;

HANDLE ObtainFileHandle(wstring& wsFileName);

class CTargetFile
{
    wstring m_wsTargetName;
    HANDLE hFile;
public:
    CTargetFile(wstring& wsT) : m_wsTargetName(wsT), hFile(INVALID_HANDLE_VALUE) { };
    ~CTargetFile()
    {
        CloseFile();
    }

    BOOL EnsureOpen()
    {
        if (hFile == INVALID_HANDLE_VALUE)
        {
            hFile = ObtainFileHandle(m_wsTargetName);
        }

        return hFile != INVALID_HANDLE_VALUE;
    }

    BOOL CloseFile()
    {
        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
        }

        return hFile == INVALID_HANDLE_VALUE;
    }

    BOOL SetFilePointerToEnd()
    {
        DWORD dwResult = SetFilePointer(hFile, 0, NULL, FILE_END);
        if ((dwResult == INVALID_SET_FILE_POINTER) && GetLastError())
        {
            dwResult = GetLastError();
            return FALSE;
        }

        return TRUE;
    }

    BOOL AppendData(PBYTE pbData, DWORD dwDataSize, DWORD& dwWritten)
    {
        LONG dwHighFileOffset = 0;
        DWORD dwResult = 0;
        BOOL fResult = FALSE;
        OVERLAPPED ol;

        if (EnsureOpen() && SetFilePointerToEnd())
        {
            fResult = WriteFile(hFile, pbData, dwDataSize, &dwWritten, NULL);
            if (!fResult)
            {
                dwResult = GetLastError();
            }
        }

        return fResult;
    }
};


//
// Append from stdin
//
BOOL AppendStdIn(CTargetFile& Target)
{
    HANDLE hStdInput;
    DWORD dwReadChars, dwWritten;
    vector<BYTE> vbDataBlob;
    vector<BYTE> vbDataBlobIntermediate;

    vbDataBlobIntermediate.resize(4096);
    
    hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    if ((hStdInput == INVALID_HANDLE_VALUE) || !hStdInput) 
    {
        return FALSE;
    }
    
    while (ReadFile(hStdInput, &vbDataBlobIntermediate.front(), vbDataBlobIntermediate.size(), &dwReadChars, NULL))
    {
        if (!dwReadChars)
        {
            break;
        }
        else 
        {
            if (g_BufferStdInFully)
            {
                vbDataBlob.insert(
                    vbDataBlob.end(), 
                    vbDataBlobIntermediate.begin(), 
                    vbDataBlobIntermediate.end());
            }
            else
            {
                if (!Target.AppendData(&vbDataBlobIntermediate.front(), dwReadChars, dwWritten))
                {
                    return FALSE;
                }
            }
        }
    }

    if ((dwReadChars == 0) && g_BufferStdInFully)
    {
        if (!Target.AppendData(&vbDataBlob.front(), vbDataBlob.size(), dwWritten))
        {
            return FALSE;
        }
    }

    return (dwReadChars == 0);
}

vector< wstring > AppendingSources;

BOOL WorkHorse(wstring& wsTargetFile)
{
    BOOL bOk = FALSE;
    bool bHasReadStdIn = false;
    CTargetFile TargetFile(wsTargetFile);

    if (!g_LockPerItem) TargetFile.EnsureOpen();

    for (vector<wstring>::const_iterator i = AppendingSources.begin(); 
          i != AppendingSources.end(); 
          i++)
    {
        if (*i == L"-")
        {
            if (g_LockPerItem) TargetFile.EnsureOpen();

            if (!bHasReadStdIn)
            {
                bHasReadStdIn = true;
                if (!AppendStdIn(TargetFile))
                {
                    goto Exit;
                }
            }
            else
            {
                fwprintf(stderr, L"Can't read from stdin multiple times - found '-' twice!\n");
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Exit;
            }

            if (g_LockPerItem) TargetFile.CloseFile();
        }
        else
        {
            fwprintf(stderr, L"We don't support reading in files yet, sorry.\n");
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Exit;
        }
    }
    
    bOk = TRUE;

Exit:
    return bOk;

}


HANDLE
ObtainFileHandle(wstring& wsFileName)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwSleepTime = 250;                // Start at 250ms sleep
    float flBackoffRate = 1.1f;             // Backoff at 1.1x the sleep length
    DWORD dwMaxSleepTime = 5000;            // Don't ever sleep for more than 5 seconds at a time
    DWORD dwMaxTicksAtThisSleepTime = 10;   // Try the sleep time 10 times in a row
    DWORD dwTicksAtThisSleepTime = dwMaxTicksAtThisSleepTime;
    DWORD dwError = 0;

    //
    // We attempt to lock the file based on no sharing.  If it fails with a sharing
    // violation, then we back off for a while and try again later.
    //
    while (true)
    {
        hFile = CreateFileW(
            wsFileName.c_str(), 
            GENERIC_WRITE, 
            0,
            NULL,
            OPEN_ALWAYS, 
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        dwError = ::GetLastError();

        // If we've gotten a good handle back, stop looking.
        if ((hFile != INVALID_HANDLE_VALUE) && (hFile != NULL))
        {
            break;
        }
        else
        {
            // If the error was a sharing violation, then back off for a bit and
            // try again.
            if (dwError == ERROR_SHARING_VIOLATION)
            {
                Sleep(dwSleepTime);
                if (dwTicksAtThisSleepTime == 0)
                {
                    dwTicksAtThisSleepTime = dwMaxTicksAtThisSleepTime;
                    dwSleepTime = (DWORD)((float)dwSleepTime * flBackoffRate);
                    continue;
                }
            }
            // Otherwise, something else bad happened, so quit trying
            else
            {
                hFile = INVALID_HANDLE_VALUE;
                break;
            }
        }
    }

    return hFile;

}

void PrintUsage()
{
    wprintf(L"<-file <output>> [-verbose] [-bufferstdin] [-atomicperitem] <[-] [file [...]]>\n");
    wprintf(L"\n");
    wprintf(L"-bufferstdin     Buffer all of stdin (-) before writing\n");
    wprintf(L"-atomicperitem   Lock the file per item, not per run\n");
    wprintf(L"-file <name>     What file should be written out to\n");
    wprintf(L"-verbose         Up the verbosity of debug spew (if any)\n");
    wprintf(L"-                Read from stdin into the output file.\n");
}

int __cdecl wmain(int argc, WCHAR** argv)
{
    wstring             wsAppendTarget;
    vector<wstring>     wstParams;
    bool                 bInGatheringData = false;
    DWORD                dwVerbosity = 0;
    HANDLE               hFile = INVALID_HANDLE_VALUE;

    for (int i = 1; i < argc; i++)
    {
        wstParams.push_back(argv[i]);
    }

    if (wstParams.empty())
    {
        PrintUsage();
        return 1;
    }

    //
    // Syntax:
    //
    // <-file <output>> [-verbose] [-] file1 file2 ... 
    //
    // -                        - Indicates that the console should be read for input at this point
    // -file <output file>      - Specify output destination
    // -verbose                 - How noisy? +1 noise level per instance
    // 
    for (vector<wstring>::iterator i = wstParams.begin(); i != wstParams.end(); i++)
    {
        if (bInGatheringData)
        {
            AppendingSources.push_back(*i);
        }
        else if (*i == wstring(L"-file"))
        {
            wsAppendTarget = *++i;
        }
        else if (*i == wstring(L"-?"))
        {
            PrintUsage();
            return 1;
        }
        else if (*i == wstring(L"-bufferstdin"))
        {
            g_BufferStdInFully = true;
        }
        else if (*i == wstring(L"-atomicperitem"))
        {
            g_LockPerItem = true;
        }
        else if (*i == L"-verbose")
        {
            dwVerbosity++;
        }
        else 
        {
            bInGatheringData = true;
            AppendingSources.push_back(*i);
        }
    }

    //
    // No target or sources?
    //
    if ((wsAppendTarget.size() == 0) || (AppendingSources.size() == 0))
    {
        PrintUsage();
        return 1;
    }


    WorkHorse(wsAppendTarget);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\buildtool\catalogs.cpp ===
#include "stdinc.h"

using std::ofstream;
using std::basic_string;

bool GenerateCatalogContents( const CPostbuildProcessListEntry& item )
{
    wstring cdfOutputPath;
    wstring catalogName;
    ofstream cdfOutput;

    cdfOutputPath = item.getManifestPathOnly() + wstring(L"\\") + item.getManifestFileName() + wstring(L".cdf");
    catalogName = item.getManifestFileName().substr( 0, item.getManifestFileName().find_last_of(L'.') ) + wstring(L".cat");

    cdfOutput.open(ConvertWString(cdfOutputPath).c_str());
    if ( !cdfOutput.is_open() ) {
        wstringstream ss;
        ss << wstring(L"Can't open the output cdf file ") << cdfOutputPath;
        ReportError( ErrorFatal, ss );
        return false;
    }

    cdfOutput << "[CatalogHeader]" << endl;
    cdfOutput << "Name=" << ConvertWString(catalogName) << endl;
    cdfOutput << "ResultDir=" << ConvertWString(item.getManifestPathOnly()) << endl;
    cdfOutput << endl;
    cdfOutput << "[CatalogFiles]" << endl;
    cdfOutput << "<HASH>" << ConvertWString(item.getManifestFileName()) << "=" << ConvertWString(item.getManifestFileName()) << endl;
    cdfOutput << ConvertWString(item.getManifestFileName()) << "=" << ConvertWString(item.getManifestFileName()) << endl;

    cdfOutput.close();

    if ( g_GlobalParameters.m_CdfOutputPath.size() > 0 ) {
        ofstream cdflog;
        cdflog.open(ConvertWString(g_GlobalParameters.m_CdfOutputPath).c_str(), wofstream::app | wofstream::out);
        if ( !cdflog.is_open() )
        {
            wstringstream ss;
            ss << wstring(L"Can't open cdf logging file ") << g_GlobalParameters.m_CdfOutputPath;
            ReportError( ErrorWarning, ss );
        }
        else
        {
            cdflog << ConvertWString(cdfOutputPath) << endl;
            cdflog.close();
        }

    }


    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\shfusion1.cpp ===
#pragma warning(disable:4786)
#include <string>
#include <map>
#include <vector>
#include <stdio.h>
#include <algorithm>
#include "windows.h"
#include "io.h"
#include <limits.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#include <assert.h>

#if defined(_WIN64)
typedef unsigned __int64 ULONG_PTR;
#else
typedef unsigned long ULONG_PTR;
#endif

struct tagACTCTXW;
typedef const tagACTCTXW* PCACTCTXW;

typedef std::string::size_type size_type;

// we also wrap user and loadlibrary
const char Namespace[] = "SideBySide";
const char NamespaceComCtl[] = "SideBySideCommonControls";
#define NAMESPACE "SideBySide"
#define NAMESPACE_COMCTL "SideBySideCommonControls"

/*
enum ETokenType
{
	ttComment,
	ttChar,
	ttIdentifer
};

class CToken
{
public:
	ETokenType  m_etype;
	std::string m_string;
};

enum EType
{
	tVoid,
	tBool,
	tInt,
	tHRESULT,
	tOther
};
*/

class CType
{
public:
	//EType       m_etype;
	std::string m_string; // right from a CToken, we ignore the multiple token case for now
};

class CParameter
{
public:
	CType       m_type;
	std::string m_name;
};


std::string BaseFunctions[] =
{
    "LoadLibrary"
};

std::string UserFunctions[] =
{
    "RegisterClass",
    "RegisterClassEx",
    "CreateWindow",
    "CreateWindowEx",
    "GetClassInfo",
    "GetClassInfoEx",
    "DialogBoxParam",
    "DialogBoxIndirectParam",
    "CreateDialogIndirect",
    "CreateDialogIndirectParam",
    "CreateDialogParam"
};

#define BEGIN(x) x
#define END(x) ((x) + sizeof(x) / sizeof((x)[0]))

std::string  AlsoNoFusionFunctions[] =
{
    //"CreateDialogIndirectT",
    //"CreateDialogParamT",
    "CreateWindowExT",
    //"CreateWindowT",
    "CreateDialogIndirectParamT",
    "CreatePropertySheetPageT"
};

const static char prefix[]=
"\n\
#include \"windows.h\"\n\
\n\
HMODULE g_" NAMESPACE_COMCTL "DllHandle;\n\
\n\
DWORD " NAMESPACE_COMCTL "GetLastError()\n\
{\n\
    DWORD Error = GetLastError();\n\
    if (Error == NO_ERROR)\n\
    {\n\
        Error = -1;//ERROR_UNSUCCESSFUL;\n\
    }\n\
    return Error;\n\
}\n\
\n\
\n\
HANDLE g_" NAMESPACE_COMCTL "ActCtx;\n\
\n\
BOOL\n\
WINAPI\n\
" NAMESPACE_COMCTL "DeactivateActCtx_DownLevel(\n\
    DWORD dwFlags,\n\
    ULONG_PTR ulCookie\n\
    )\n\
{\n\
    return TRUE;\n\
}\n\
\n\
BOOL\n\
WINAPI\n\
" NAMESPACE_COMCTL "DeactivateActCtx(\n\
    DWORD dwFlags,\n\
    ULONG_PTR ulCookie\n\
    )\n\
{\n\
    typedef BOOL (WINAPI* PFN)(DWORD dwFlags, ULONG_PTR ulCookie);\n\
    static PFN pfn;\n\
    BOOL Success = FALSE;\n\
\n\
    if (pfn == NULL)\n\
    {\n\
        HMODULE Kernel32 = GetModuleHandleW(L\"Kernel32.dll\");\n\
        if (Kernel32 == NULL) // this is fatal, even downlevel\n\
            goto Exit;\n\
        pfn = (PFN)GetProcAddress(Kernel32, \"DeactivateActCtx\");\n\
        if (pfn == NULL)\n\
            pfn = " NAMESPACE_COMCTL "DeactivateActCtx_DownLevel;\n\
    }\n\
    Success = pfn(dwFlags, ulCookie);\n\
Exit:\n\
    return Success;\n\
}\n\
\n\
BOOL\n\
WINAPI\n\
" NAMESPACE_COMCTL "ActivateActCtx_DownLevel(\n\
    HANDLE hActCtx,\n\
    ULONG_PTR *lpCookie\n\
    )\n\
{\n\
    return TRUE;\n\
}\n\
\n\
BOOL\n\
WINAPI\n\
" NAMESPACE_COMCTL "ActivateActCtx(\n\
    HANDLE hActCtx,\n\
    ULONG_PTR *lpCookie\n\
    )\n\
{\n\
    typedef BOOL (WINAPI* PFN)(HANDLE hActCtx, ULONG_PTR *lpCookie);\n\
    static PFN pfn;\n\
    BOOL Success = FALSE;\n\
\n\
    if (pfn == NULL)\n\
    {\n\
        HMODULE Kernel32 = GetModuleHandleW(L\"Kernel32.dll\");\n\
        if (Kernel32 == NULL) // this is fatal, even downlevel\n\
            goto Exit;\n\
        pfn = (PFN)GetProcAddress(Kernel32, \"ActivateActCtx\");\n\
        if (pfn == NULL)\n\
            pfn = " NAMESPACE_COMCTL "ActivateActCtx_DownLevel;\n\
    }\n\
    Success = pfn(hActCtx, lpCookie);\n\
Exit:\n\
    return Success;\n\
}\n\
\n\
BOOL\n\
WINAPI\n\
" NAMESPACE_COMCTL "CreateActCtxW_DownLevel(\n\
    PCACTCTXW pActCtx\n\
    )\n\
{\n\
    return TRUE;\n\
}\n\
\n\
BOOL\n\
WINAPI\n\
" NAMESPACE_COMCTL "CreateActCtxW(\n\
    PCACTCTXW pActCtx\n\
    )\n\
{\n""\
    typedef BOOL (WINAPI* PFN)(PCACTCTXW pActCtx);\n\
    static PFN pfn;\n\
    BOOL Success = FALSE;\n\
\n\
    if (pfn == NULL)\n\
    {\n\
        HMODULE Kernel32 = GetModuleHandleW(L\"Kernel32.dll\");\n\
        if (Kernel32 == NULL) // this is fatal, even downlevel\n\
            goto Exit;\n\
        pfn = (PFN)GetProcAddress(Kernel32, \"CreateActCtxW\");\n\
        if (pfn == NULL)\n\
            pfn = " NAMESPACE_COMCTL "CreateActCtxW_DownLevel;\n\
    }\n\
    Success = pfn(pActCtx);\n\
Exit:\n\
    return Success;\n\
}\n\
\n\
/* Requires NT4.0, Win98. SideBySide functionality is currently only on Whistler,\n\
and will fail before it tries this. */\n\
PVOID "NAMESPACE_COMCTL"InterlockedCompareExchangePointer(PVOID* Dest, PVOID Exch, PVOID Comperand)\n\
{\n\
#if defined(_X86_)\n\
    typedef PVOID (WINAPI* PFN)(PVOID*, PVOID, PVOID);\n\
    static PFN pfn;\n\
    /* Note, the export has a different name; this is correct. */\n\
    pfn = (PFN)GetProcAddress(GetModuleHandle(TEXT(\"Kernel32.dll\"), \"InterlockedCompareExchange\"));\n\
    /* UNDONE Error handling here.. */\n\
    return pfn(Dest, Exch, Comperand);\n\
#else\n\
    /* always available on IA64, and most other processors */\n\
    return InterlockedCompareExchangePointer(Dest, Exch, Comperand);\n\
#endif\n\
}\n\
\n\
HANDLE g_" NAMESPACE_COMCTL "ActCtxHandle = INVALID_HANDLE_VALUE;\n\
\n\
#if defined(__cplusplus)\n\
extern \"C\"\n\
#endif\n\
int __ImageBase; /* requires VC6 linker */\n\
\n\
BOOL\n\
WINAPI\n\
" NAMESPACE_COMCTL "CreateMyActCtx(\n\
    )\n\
{\n\
    ACTCTX ActCtx;\n\
    HANDLE LocalActCtxHandle = INVALID_HANDLE_VALUE;\n\
    static DWORD  Error;\n\
    PTSTR  ModuleFileName = NULL;\n\
    DWORD  ModuleNameBufferSize = 32;\n\
    DWORD  ModuleNameSize;\n\
    BOOL   Success = FALSE;\n\
    BOOL   First = TRUE;\n\
\n\
    if (Error != 0)\n\
    {\n\
        SetLastError(Error);\n\
        goto Exit;\n\
    }\n\
    if (g_"NAMESPACE_COMCTL"ActCtxHandle == INVALID_HANDLE_VALUE)\n\
    {\n\
        do\n\
        {\n\
            if (ModuleName == NULL)\n\
            {\n\
                ModuleFileName = (PTSTR)HeapAlloc(GetProcessHeap(), 0, ModuleNameBufferSize * sizeof(*ModuleName));\n\
                if (ModuleName == NULL)\n\
                {\n\
                    Error = ERROR_NOT_ENOUGH_MEMORY;\n\
                    goto Exit;\n\
                }\n\
            }\n\
            else\n\
            {\n\
                PTSTR ModuleNameLonger\n\
                ModuleBufferSize *= 2;\n\
                ModuleNameLonger = (PSTR)HeapReAlloc(GetProcessHeap(), 0, ModuleFileName, ModuleBufferSize * sizeof(*ModuleNameLonger));\n\
                if (ModuleNameLonger == NULL)\n\
                {\n\
                    Error = ERROR_NOT_ENOUGH_MEMORY;\n\
                    goto Exit;\n\
                }\n\
                ModuleFileName = ModuleNameLonger;\n\
            }\n\
            ModuleFileName[ModuleNameBufferSize - 2] = 0;\n\
            if (!GetModuleFileName(&__ImageBase, ModuleFileName, ModuleNameBufferSize))\n\
            {\n\
                Error = " NAMESPACE_COMCTL "GetLastError();\n\
                goto Exit;\n\
            }\n\
        } while (ModuleName[ModuleNameBufferSize - 2] != 0)\n\
        ActCtx.cbSize = sizeof(ActCtx);\n\
        ActCtx.dwFlags = 0;\n\
        ActCtx.lpSource = ModuleName;\n\
        LocalActCtxHandle = NAMESPACE_COMCTL CreateActCtx(&ActCtx);\n\
        if (LocalActCtxHandle == INVALID_HANDLE_VALUE)\n\
            goto Exit;\n\
        NAMESPACE_COMCTL InterlockedCompareExchangePointer((PVOID*)&g_"NAMESPACE_COMCTL"ActCtxHandle, LocalActCtxHandle, INVALID_HANDLE_VALUE);\n\
    }\n\
    Success = TRUE;\n\
Exit:\n\
    /* If out of memory, let it be retried. */\n\
    if (Error != ERROR_NOT_ENOUGH_MEMORY)\n\
        Initialized = TRUE;\n\
    if (ModuleFileName != NULL)\n\
    {\n\
        DWORD LastError = GetLastError();\n\
        HeapFree(GetProcessHeap(), 0, ModuleFileName);\n\
        SetLastError(LastError);\n\
    }\n\
\n\
    return Success;\n\
}\n\
\n\
BOOL " NAMESPACE_COMCTL "DelayLoad(HMODULE* Module, DWORD* Error)\n\
{\n\
    BOOL Success = FALSE;\n\
    ULONG_PTR Cookie;\n\
    BOOL      ActivateSuccess = FALSE;\n\
\n\
    if (*Module != NULL)\n\
    {\n\
        Success = TRUE;\n\
        goto Exit;\n\
    }\n\
    if (*Error != 0)\n\
    {\n\
        SetLastError(*Error);\n\
        goto Exit;\n\
    }\n\
    Success = " NAMESPACE_COMCTL "ActivateActCtx(g_" NAMESPACE_COMCTL "ActCtxHandle, &Cookie);\n\
    if (!Success)\n\
    {\n\
        *Error = " NAMESPACE_COMCTL "GetLastError();\n\
        goto Exit;\n\
    }\n\
    __try\n\
    {\n\
        *Module = LoadLibrary(TEXT(\"comctl32.dll\"));\n\
        if (*Module == NULL)\n\
        {\n\
            *Error = " NAMESPACE_COMCTL "GetLastError();\n\
            goto Exit;\n\
        }\n\
    }\n\
    __finally\n\
    {\n\
        if (AbnormalTermination())\n\
        {\n\
            DWORD LastError = GetLastError();\n\
            " NAMESPACE_COMCTL "DeactivateActCtx(0, Cookie);\n\
            SetLastError(LastError);\n\
        }\n\
        else\n\
        {\n\
            if (!" NAMESPACE_COMCTL "DeactivateActCtx(0, Cookie))\n\
            {\n\
                *Error = " NAMESPACE_COMCTL "GetLastError();\n\
                goto Exit;\n\
            }\n\
        }\n\
    }\n\
    Success = TRUE;\n\
Exit:\n\
    return Success;\n\
}\n\
\n" "\n\
\n\
/* TODO wrapping up multiple const-static parameters in a struct is a code size win */\n\
#if 0\n\
typedef "NAMESPACE_COMCTL"GetProcAddressParameters\n\
{\n\
    PCSTR    Name;\n\
    FARPROC* Address;\n\
    DWORD*   Error;\n\
} "NAMESPACE_COMCTL"GetProcAddressParameters\n\
#endif\n\
\n\
BOOL " NAMESPACE_COMCTL "GetProcAddress(PCSTR ProcedureName, FARPROC* ppfn, DWORD* GetProcAddressError)\n\
/*\n\
We have an error per function, as well as one overriding error, because\n\
we can error on LoadLibrary or we could succeed LoadLibrary but then\n\
error on some GetProcAddresses. Error on LoadLibrary propatated to all GetProcAddresses\n\
with no retries. Errors on GetProcAddresses are isolated to GetProcAddresses.\n\
*/\n\
{\n\
    static HMODULE Module;\n\
    static DWORD   LoadLibraryError;\n\
    BOOL Success = FALSE;\n\
\n\
    if (*ppfn != NULL)\n\
    {\n\
        Success = TRUE;\n\
        goto Exit;\n\
    }\n\
    if (*GetProcAddressError != 0)\n\
    {\n\
        SetLastError(*GetProcAddressError);\n\
        goto Exit;\n\
    }\n\
    if (LoadLibraryError != 0)\n\
    {\n\
        SetLastError(LoadLibraryError);\n\
        *GetProcAddressError = LoadLibraryError;\n\
        goto Exit;\n\
    }\n\
    if (!" NAMESPACE_COMCTL "DelayLoad(&Module, &LoadLibraryError))\n\
    {\n\
        *GetProcAddressError = LoadLibraryError;\n\
        goto Exit;\n\
    }\n\
    if ((*ppfn = GetProcAddress(Module, ProcedureName)) == NULL)\n\
    {\n\
        *GetProcAddressError = " NAMESPACE_COMCTL "GetLastError();\n\
        /*\n\
        Don't touch LoadLibraryError for GetProcAddress.\n\
        */\n\
        goto Exit;\n\
    }\n\
    Success = TRUE;\n\
Exit:\n\
    return Success;\n\
}\n\
";

#if 0 // FUTURE We should make this be multipass, it's easier.
class CStreamBuffer : public IStream
{
public:
    CStreamBuffer(IStream* Stream) : m_Stream(Stream) { }

    STDMETHOD(Read)(void* pv, ULONG cb, ULONG* pcbRead)
    {
        ULONG cbRead = 0;
        HRESULT hr;

        if (pcbRead != NULL)
            *pcbRead = 0;

        if (cb == 0)
        {
            hr = S_OK;
            goto Exit;
        }
        if (FAILED(hr = FlushWriteBuffer()))
            goto Exit;
        if (m_BufferSize != 0)
        {
            cbRead = MIN(cb, m_BufferSize);
            CopyMemory(pv, m_Buffer + m_BufferPosition, cbRead);
            cb -= cbRead;
            m_BufferPosition += cbRead;
            m_BufferSize -= cbRead;
        }
        if (cb == 0)
        {
            hr = S_OK;
            goto Exit;
        }
        /*
        depending on the client, we could stop here with a partial read
        for more compatibility, we will push ahead and fill the buffer in order
        to give them all that they asked for
        */
        if (cb >= NUMBER_OF(m_Buffer))
        {
            hr = m_Stream->Read(pv, cb, pcbRead);
            if (pcbRead != NULL)
                cbRead += *pcbRead;
            goto Exit;
        }
        if (FAILED(hr = FillReadBuffer()))
            return hr;
        CopyMemory(pv, reinterpret_cast<PBYTE>(m_Buffer) + m_BufferPosition, cb);
        m_BufferPosition += cb;
        m_BufferSize -= cb;
        cbRead += cb;
        hr = S_OK;
Exit:
        if (pcbRead != NULL)
            *pcbRead = cbRead;
        return hr;
    }

    HRESULT FillReadBuffer()
    {
        ULONG cb;
        m_fReadBuffer = true;
        HRESULT hr = m_Stream->Read(m_Buffer, NUMBER_OF(m_Buffer), &cb);
        m_BufferPosition = 0;
        m_BufferSize = cb;
        return hr;
    }

    HRESULT FlushWriteBuffer()
    {
        ULONG cb;
        if (m_fWriteBuffer && m_BufferSize != 0)
        {
            HRESULT hr = m_Stream->Write(m_Buffer, m_BufferSize, &cb);
            m_BufferPosition = 0;
            m_BufferSize = cb;
            return hr;
        }
        return S_OK;
    }

    IStream* m_Stream;
    BYTE  m_Buffer[4096];
    ULONG m_BufferPosition;
    ULONG m_BufferSize;
    bool  m_fReadBuffer;
    bool  m_fWriteBuffer;
};
#endif //  FUTURE

class CFunction
{
public:

    CFunction()
    {
        Clear();
    }

    void PrinDefine(FILE* File, const char* FromPrefix, const char* ToPrefix) const
    {
        fprintf(File, "#define %s%s %s%s\n", FromPrefix, m_name.c_str(), ToPrefix, m_name.c_str());
    }

    void PrintStub(FILE* File) const
    {
        if (m_isComctl)
        {
            fprintf(
                File,
                "%s\n"
                "WINAPI\n"
                "SideBySide%s(%s)\n"
                "{\n"
                "    static DWORD Error\n"
                "    typedef %s (WINAPI* PFN)(%s);\n"
                "    static PFN pfn;\n"
                "    if (pfn == NULL)\n"
                "      " NAMESPACE_COMCTL "GetProcAddress(\"%s\", (FARPROC*)&pfn, &Error);\n"
                "    if (pfn != NULL)\n"
                "        return pfn(%s);\n"
                "    SetLastError(Error);\n"
                "    return %s;\n"
                "}\n\n",

                m_returnType.m_string.c_str(),
                m_name.c_str(),
                m_parameterTypesNamesString.c_str(),

                m_returnType.m_string.c_str(),
                m_parameterTypesNamesString.c_str(),

                m_name.c_str(),

                m_parameterNamesString.c_str(),

                m_error.c_str()
                );
        }
        else
        {
            fprintf(
                File,
                "%s\n"
                "WINAPI\n"
                "SideBySide%s(%s)\n"
                "{\n"
                "    ULONG_PTR ActCtxCookie;\n"
                "    %s %s %s;
                "    BOOL ActivateActCtxSuccess;
                "
                "    ActivateActCtxSuccess

                "        return %s(%s);\n"
                "    SetLastError(Error);\n"
                "    return %s;\n"
                "}\n\n",

                m_returnType.m_string.c_str(),
                m_name.c_str(),
                m_parameterTypesNamesString.c_str(),

                m_returnType.m_string.c_str(),
                m_parameterTypesNamesString.c_str(),

                m_name.c_str(),

                m_parameterNamesString.c_str(),

                m_error.c_str()
                );
        }
    }

    void FormParameterStrings()
    {
        m_parameterTypesNamesString.erase();
        m_parameterNamesString.erase();

        bool first = true;
        if (m_parameters.begin() != m_parameters.end())
        {
            for (CParameters::const_iterator i = m_parameters.begin() ; i != m_parameters.end() ; ++i)
            {
                if (!first)
                {
                    m_parameterTypesNamesString += ", ";
                    m_parameterNamesString += ", ";
                }
                first = false;
                m_parameterTypesNamesString += i->m_type.m_string;
                m_parameterTypesNamesString += " ";
                m_parameterTypesNamesString += i->m_name.c_str();
                m_parameterNamesString += i->m_name.c_str();
            }
            m_isVoid = false;
        }
        else
        {
            m_parameterTypesNamesString = "void";
            m_isVoid = true;
        }
    }

    void Clear()
    {
        m_isVoid = false;
        m_isBase = false;
        m_isUser = false;
        m_isComctl = false;
        m_parameters.clear();
        m_parameterTypesNamesString.erase();
        m_parameterNamesString.erase();
        m_name.erase();
        m_error.erase();
        m_returnType.m_string.erase();

        // temporary, until we finish annotating commctrl.h
        m_error = "0";
    }

	CType m_returnType;
    typedef std::vector<CParameter> CParameters;
	CParameters m_parameters;
    std::string m_parameterTypesNamesString;
    std::string m_parameterNamesString;
	std::string m_name;
	std::string m_nameGeneric;
    std::string m_error;
    bool        m_isVoid;
    bool        m_isBase;   // WINBASEAPI (just LoadLibrary)
    bool        m_isUser;   // WINUSERAPI
    bool        m_isComctl; // WINCOMMCTRLAPI
};

std::string GetEnvironmentVariable(const std::string& s)
{
	char buffer[4000];

	buffer[0] = 0;
	GetEnvironmentVariableA(s.c_str(), buffer, NUMBER_OF(buffer));

	return buffer;
}

std::vector<std::string> SplitStringOnChar(std::string s, char c)
{
	std::vector<std::string> result;
#if 0
	std::string::const_iterator i;
	std::string::const_iterator j;

	for (i = s.begin() ; i != s.end() ; ++i)
	{
		i += findf_first
	}
#endif
	return result;
}

void ThrowErrno()
{
	throw errno;
}

class CStdioFile
{
public:
	CStdioFile(FILE* file = NULL) : m_file(file) { }

	operator FILE*()
	{
		return m_file;
	}

	void operator=(FILE* file)
	{
		Close();
		m_file = file;
	}

	FILE* operator->()
	{
		return m_file;
	}

	~CStdioFile()
	{
		Close();
	}

	void Close()
	{
		FILE* file = m_file;
		m_file = NULL;
		if (file != NULL)
		{
			if (fclose(file) != 0)
			{
				ThrowErrno();
			}
		}
	}

	FILE* m_file;
};

class CMakeSideBySideCommonControls
{
public:

	CMakeSideBySideCommonControls() { }

	std::string   m_path;
	std::string   m_string;
	//std::vector<CToken> m_tokens;
    typedef std::vector<CFunction> CFunctions;
	CFunctions m_functions;

    void OpenAndRead(const std::string& filename)
	{
		std::string ntDrive = GetEnvironmentVariable("_NTDRIVE");
		std::string ntRoot = GetEnvironmentVariable("_NTROOT");
		std::string include = GetEnvironmentVariable("include"); // future
		std::vector<std::string> includes = SplitStringOnChar(include, ';');  // future

#if 0
        if (ntDrive == "")
		{
			ntDrive = "Z:";
		}
		if (ntRoot == "")
		{
			ntRoot = "nt";
		}
#else
        if (ntDrive == "")
		{
			ntDrive = "x:";
		}
		if (ntRoot == "")
		{
			ntRoot = "sh1";
		}
#endif

        std::string directory = ntDrive + "\\" + ntRoot + "\\public\\sdk\\inc\\";


        m_path = directory + filename;
	    CStdioFile file = fopen(m_path.c_str(), "rb");
		if (file == NULL)
			ThrowErrno();

		__int64 size = _filelengthi64(_fileno(file));
		if (size == -1)
			ThrowErrno();

        //size_type previousSize = m_string.size();
        size_type previousSize = 0;
		m_string.resize(previousSize + static_cast<size_type>(size));

		size_t elementsRead = fread(&m_string[previousSize], sizeof(char), size, file);
		if (elementsRead != size)
			ThrowErrno();
        m_string.append("\n\n");
    }

    static void FindAndReplaceChar(std::string& s, char from, char to)
    {
        for (std::string::iterator i = s.begin(); i != s.end() ; ++i)
        {
            if (*i == from)
                *i = to;
        }
    }

#define STRIPCOMMENTS_SLASHSLASH 0x000001
#define STRIPCOMMENTS_SLASHSTAR  0x000002
#define STRIPCOMMENTS_SLASHSLASH_UNAWARE 0x000004
#define STRIPCOMMENTS_SLASHSTAR_UNAWARE 0x000008

    static void StripComments(int flags, std::string& s)
    /*
    We generally want to be "aware" of both types so that we don't
    strip nested comments. Consider the comments that follow.
    */

    // /* slash star in slsh slash */

    /* // slashslash
          in slash star
     */
    {
        std::string t;
        std::string::const_iterator i;
        const std::string::const_iterator j = s.end();
        std::string::const_iterator k;
        bool closed = true;

        t.reserve(s.size());
        for (i = s.begin() ; closed && i != j && i + 1 != j; )
        {
            if (
                ((flags & STRIPCOMMENTS_SLASHSTAR) || (flags & STRIPCOMMENTS_SLASHSTAR_UNAWARE) == 0)
                && *i == '/'
                && *(i + 1) == '*'
                )
            {
                closed = false;
                for (k = i + 2 ; k != j && k + 1 != j && !(closed = (*k == '*' && *(k + 1) == '/')) ; ++k)
                {
                }
                if (flags & STRIPCOMMENTS_SLASHSTAR)
                    t.append(1, ' ');
                else
                    t.append(i, k + 2);
                i = k + 2;
            }
            else if (
                ((flags & STRIPCOMMENTS_SLASHSLASH) || (flags & STRIPCOMMENTS_SLASHSLASH_UNAWARE) == 0)
                && *i == '/'
                && *(i + 1) == '/'
                )
            {
                closed = false;
                for (k = i + 2 ; k != j && !(closed = (*k == '\r' || *k == '\n')) ; ++k)
                {
                }
                for ( ; k != j && *k == '\r' || *k == '\n' ; ++k)
                {
                }
                if (flags & STRIPCOMMENTS_SLASHSLASH)
                    t.append(1, '\n');
                else
                    t.append(i, k);
                i = k;
            }
            if (closed && i != j)
                t.append(1, *i++);
        }
        if (closed)
        {
            for ( ; i != j ; ++i )
            {
                t.append(1, *i);
            }
        }
        s = t;
    }

	void ProcessDeclaration(CFunction function, const std::string& comment, std::string declaration)
	{
		size_type i = 0;
		size_type j = 0;
        const static char whitespaceCommaLparen[] = ",) \t\r\n";
        const static char whitespace[] = " \t\r\n";
		const static char beforeParamsDelims[] = " \t\n\r(";
		const static char intracommaLparen[] = " \t\n\r*&"; // crude way to detect
                                                            // void F(char*) vs. void F(char x)
		const static char commaLparen[] = ",)";
        const static char identifierCharacters[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";
        bool rparen = false;
        bool end = false;
        bool comma = false;
        const size_type npos = std::string::npos;

        //
        // This way our ban on [] can be less strict.
        // We ban [] because aren't smart about multi token types.
        // We allow parameters like const char * foo, because commctrl does have parameters
        // whose types are multiple tokens.
        //
        StripComments(STRIPCOMMENTS_SLASHSLASH | STRIPCOMMENTS_SLASHSTAR, declaration);
        if (declaration.find_first_of("[]") != npos)
        {
            assert(declaration.find("WriteFileGather") != npos
                || declaration.find("ReadFileScatter") != npos
                );
        }

		i = declaration.find_first_not_of(beforeParamsDelims, j);
		j = declaration.find_first_of(beforeParamsDelims, i);
		assert(declaration.substr(i, j - i) == "WINBASEAPI"
            || declaration.substr(i, j - i) == "WINUSERAPI"
            || declaration.substr(i, j - i) == "WINCOMMCTRLAPI"
            );

		i = declaration.find_first_not_of(beforeParamsDelims, j);
		j = declaration.find_first_of(beforeParamsDelims, i);
		if (
               declaration.substr(i, j - i) == "DECLSPEC_NORETURN"
            )
        {
		    i = declaration.find_first_not_of(beforeParamsDelims, j);
		    j = declaration.find_first_of(beforeParamsDelims, i);
        }

        function.m_returnType.m_string.assign(declaration.substr(i, j != npos ? j - i : npos));

		i = declaration.find_first_not_of(beforeParamsDelims, j);
		j = declaration.find_first_of(beforeParamsDelims, i);
		if (
               declaration.substr(i, j - i) == "WINAPI"
            || declaration.substr(i, j - i) == "WINAPIV"
            || declaration.substr(i, j - i) == "NTAPI"
            || declaration.substr(i, j - i) == "_stcall"
            || declaration.substr(i, j - i) == "__stcall"
            || declaration.substr(i, j - i) == "_cdecl"
            || declaration.substr(i, j - i) == "__cdecl"
            || declaration.substr(i, j - i) == "APIENTRY"
            || declaration.substr(i, j - i) == "FASTCALL"
            || declaration.substr(i, j - i) == "_fastcall"
            || declaration.substr(i, j - i) == "__fastcall"
            )
        {
		    i = declaration.find_first_not_of(beforeParamsDelims, j);
		    j = declaration.find_first_of(beforeParamsDelims, i);
        }
		function.m_name.assign(declaration.substr(i, j != npos ? j - i : npos));

        if (   *(function.m_name.end() - 1) == 'A'
            || *(function.m_name.end() - 1) == 'W'
            )
        {
    		function.m_nameGeneric.assign(function.m_name.begin(), function.m_name.end() - 1);
        }


        j += (j != npos);

        //
        // now split mainly on comma
        //

		while (
		       i != declaration.size()
            && j != declaration.size()
			&& i != npos
			&& j != npos
			)
		{
			CParameter parameter;

            i = declaration.find_first_not_of(whitespaceCommaLparen, j);
			if (i == npos)
				break;
			j = declaration.find_first_of(commaLparen, i);

            //
            // temporary, we still might split off the name
            //
            parameter.m_type.m_string = declaration.substr(i, j != npos ? j - i : npos);
            if (   parameter.m_type.m_string == "void"
                || parameter.m_type.m_string == "VOID"
                || parameter.m_type.m_string == ""
                )
            {
                break;
            }
#if 0
            size_type splitParamNameFromType = parameter.m_type.m_string.find_last_of(typeTokenDelims);
            if (splitParamNameFromType != npos)
            {
                // the parameter has a name
                parameter.m_name = parameter.m_type.m_string.substr(splitParamNameFromType);
                parameter.m_type.m_string.resize(splitParamNameFromType);
            }
#else
            size_type splitParamNameFromType = parameter.m_type.m_string.find_last_not_of(identifierCharacters);
            if (splitParamNameFromType != npos)
            {
                // the parameter has a name
                parameter.m_name = parameter.m_type.m_string.substr(splitParamNameFromType + 1);
                parameter.m_type.m_string.resize(splitParamNameFromType);
            }
#endif
            else
            {
				char buffer[sizeof(int) * CHAR_BIT];
				sprintf(buffer, "%d", static_cast<int>(function.m_parameters.size()));
                parameter.m_name = "UnnamedParameter";
                parameter.m_name += buffer;
            }
            j += (j != npos);

            
            if (!comment.empty())
            {
                char functionFromComment[100];
                char errorFromComment[100];

                functionFromComment[0] = 0;
                errorFromComment[0] = 0;
                if (2 == sscanf(comment.c_str(), " @Function %s @Error %s ", functionFromComment, errorFromComment))
                {
                    if (function.m_name != functionFromComment)
                    {
                        printf(
                            "comment /* %s */ has different function than expected %s in %s\n",
                            comment.c_str(),
                            function.m_name.c_str(),
                            m_path.c_str()
                            );
                        throw -1;
                    }
                    function.m_error = errorFromComment;
                }
            }
            function.m_parameters.push_back(parameter);
		}
        if (function.m_name == "LoadLibraryA")
        {
            ;//DebugBreak();
        }
        if (function.m_name == "RegisterClassA")
        {
            ;//DebugBreak();
        }
        if (
            
               (function.m_isBase &&  (std::binary_search(BEGIN(BaseFunctions), END(BaseFunctions), function.m_name)
                                    || std::binary_search(BEGIN(BaseFunctions), END(BaseFunctions), function.m_nameGeneric)))
            || (function.m_isUser &&  (std::binary_search(BEGIN(UserFunctions), END(UserFunctions), function.m_name)
                                    || std::binary_search(BEGIN(UserFunctions), END(UserFunctions), function.m_nameGeneric)))
            || function.m_isComctl
            
            //true
            )
        {
            function.FormParameterStrings();
            m_functions.push_back(function);
        }
        else
        {
            // just ignore it
        }
	}

	void HackInsteadOfTokenizeAndParse()
	{
		/*
		This is not a proper C/C++ tokenizer.
		It works well enough for our purposes with commctrl.h.

		We are interested in function declarations that start
		WINCOMMCTRLAPI, and comments precending them that contain @Function.
		Declarations end with a semicolon.

		We ignore preprocessor directives.
		We ignore slash continuation.
		*/

		std::string comment;
		std::string declaration;
		std::string::const_iterator i;
		std::string::const_iterator j;
		std::string::const_iterator startOfDeclaration = m_string.end();
		std::string::const_iterator endOfDeclaration;
		std::string::const_iterator startOfComment;
		std::string::const_iterator endOfComment;
		std::string::const_iterator startOfLine = m_string.begin();
        bool gotRparen = false;
        bool gotLparen = false;

		/* This might become useful.
		std::vector<std::string> typeNames;

		static const char* typenamesConstData[] =
		{
			"bool", "char", "short", "int", "long", "float", "double", "void",

			"BOOL", "LRESULT", "HRESULT" "HIMAGELIST", "WORD", "DWORD", "ULONG"
			"UINT", "INT", "BYTE", "COLORREF", "void *", "HDPA",
			"HANDLE, "HWND", "POINT", "LPRECT", "LPINT", "LPSCROLLINFO",
			"INT_PTR", "UINT_PTR", "LONG_PTR", "ULONG_PTR",
		};
		for (const char** pp = typenamesConstData ; pp != typenamesConstData + NUMBER_OF(typenamesConstData) ; ++pp)
		{
			typeNames.push_back(*pp);
		}
		*/

        CFunction function;
		for (i = m_string.begin() ; i != m_string.end() ; )
		{
			switch (*i)
			{
			Ldefault:
			 default:
				startOfLine = m_string.end();
				++i;
				break;

			case '#':
				/*
				Macros happen do not occur in the middle of declarations that we care about.
                They do keep us away from declrations that might otherwise mess us up, lik
                WinMain.
				*/
				startOfDeclaration = m_string.end();
				goto Ldefault;

			case ';':
				if (startOfDeclaration == m_string.end()
                    || !gotLparen
                    || !gotRparen
                    )
					goto Ldefault;
				endOfDeclaration = i;
				declaration.assign(startOfDeclaration, endOfDeclaration);
				startOfDeclaration = m_string.end();
				ProcessDeclaration(function, comment, declaration);
                comment.erase();
                declaration.erase();
                function.Clear();
                gotLparen = false;
                gotRparen = false;
				goto Ldefault;

			case 'W':
				if (startOfLine == m_string.end()
                    || (i + 1) == m_string.end()
                    || (i + 2) == m_string.end()
                    || (i + 3) == m_string.end()
                    || (i + 4) == m_string.end()
                    || (i + 5) == m_string.end()
                    || *(i + 1) != 'I'
                    || *(i + 2) != 'N'
                    || *(i + 3) == 'A'
                    || *(i + 4) == 'P'
                    || *(i + 5) == 'I'
                    )
					goto Ldefault;

				const char* s;
				startOfDeclaration = i;
                gotLparen = false;
                gotRparen = false;
                ++i;
				for (j = startOfDeclaration, s = "WINCOMMCTRLAPI"; j != m_string.end() && *s ; ++s, ++j)
				{
					if (*j != *s)
						break;
				}
                if (*s == 0)
                {
                    function.m_isComctl = true;
                    break;
                }
				for (j = startOfDeclaration, s = "WINUSERAPI"; j != m_string.end() && *s ; ++s, ++j)
				{
					if (*j != *s)
						break;
				}
                if (*s == 0)
                {
                    function.m_isUser = true;
                    break;
                }
				for (j = startOfDeclaration, s = "WINBASEAPI"; j != m_string.end() && *s ; ++s, ++j)
				{
					if (*j != *s)
						break;
				}
                if (*s == 0)
                {
                    function.m_isBase = true;
                    break;
                }
                startOfDeclaration = m_string.end();
                break;
            case '(':
                gotLparen = (startOfDeclaration != m_string.end());
				goto Ldefault;
            case ')':
                gotRparen = (gotLparen && startOfDeclaration != m_string.end());
				goto Ldefault;

			case '/':
				if (startOfLine == m_string.end())
					goto Ldefault;
				++i;
				if (*i == '*')
				{
					++i;
					startOfComment = i;
					comment.erase();
					for (; i != m_string.end() && comment.empty(); ++i)
					{
						switch (*i)
						{
						default:
							break;
						case '*':
							endOfComment = i;
							i++;
							/* allow for comments like this ***/
							while (*i == '*')
							{
								endOfComment = i;
								i++;
							}
							if (*i == '/')
							{
								++i;
								comment.assign(startOfComment, endOfComment);
								//printf("/*\n%s\n*/\n", comment.c_str());
							}
							break;
						}
					}
				}
				break;

			case '\n':
			case '\r':
				for ( ; i != m_string.end() && (*i == '\n' || *i == '\r'); ++i )
				{
					/* nothing */
				}
				startOfLine = i;
				break;

			case ' ':
			case '\t':
				for ( ; i != m_string.end() && (*i == ' ' || *i == '\t'); ++i )
				{
					/* nothing */
				}
				// leave startOfLine unchanged
				break;
			}
		}
	}

	void PrintStubs()
	{
        for (CFunctions::const_iterator i = m_functions.begin() ; i != m_functions.end() ; ++i)
        {
            i->PrintStub(stdout);
        }
	}

    /*
    -in foo.c -out x.h
    */

    void System(const char* s)
    {
        printf("%s\n", s);
        system(s);
    }

    std::string m_defines;
    std::string m_includes;

	void operator()(int argc, char** argv)
	{
        std::sort(BEGIN(BaseFunctions), END(BaseFunctions));
        std::sort(BEGIN(UserFunctions), END(UserFunctions));
        std::sort(BEGIN(AlsoNoFusionFunctions), END(AlsoNoFusionFunctions));

		OpenAndRead("winbase.h");
        StripComments(STRIPCOMMENTS_SLASHSLASH, m_string);
		HackInsteadOfTokenizeAndParse();

		OpenAndRead("winuser.h");
        StripComments(STRIPCOMMENTS_SLASHSLASH, m_string);
		HackInsteadOfTokenizeAndParse();

		OpenAndRead("commctrl.h");
        StripComments(STRIPCOMMENTS_SLASHSLASH, m_string);
		HackInsteadOfTokenizeAndParse();

		OpenAndRead("prsht.h");
        StripComments(STRIPCOMMENTS_SLASHSLASH, m_string);
		HackInsteadOfTokenizeAndParse();

        printf("%s\n", prefix);
#if 0
        while (*++argv)
        {
            std::string s = *argv;
            FindAndReplaceChar(s, 'n', '\n');
            FindAndReplaceChar(s, 'r', '\r');
            StripComments(0, s);
            printf("%s\n", s.c_str());
        }
#endif

		PrintStubs();
	}
};

int main(int argc, char** argv)
{
	CMakeSideBySideCommonControls makeSideBySideCommonControls;

	makeSideBySideCommonControls(argc, argv);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\buildtool\helpers.cpp ===
#include "stdinc.h"

HRESULT
SxspExtractPathPieces(
                      _bstr_t bstSourceName,
                      _bstr_t &bstPath,
                      _bstr_t &bstName
                      )
{
    HRESULT hr = S_OK;
    
    PCWSTR cwsOriginal = static_cast<PCWSTR>(bstSourceName);
    PWSTR cwsSlashSpot;
    
    cwsSlashSpot = wcsrchr( cwsOriginal, L'\\' );
    if ( cwsSlashSpot )
    {
        *cwsSlashSpot = L'\0';
        bstName = _bstr_t( cwsSlashSpot + 1 );
        bstPath = cwsSlashSpot;
    }
    else
    {
        bstPath = L"";
        bstName = bstSourceName;
    }
    
    return hr;
}


HRESULT
SxspSimplifyPutAttribute(
                         ISXSManifestPtr Document,
                         ::ATL::CComPtr<IXMLDOMNamedNodeMap> Attributes,
                         const wstring AttribName,
                         const wstring Value,
                         const wstring NamespaceURI
                         )
{
    ::ATL::CComPtr<IXMLDOMNode>       pAttribNode;
    ::ATL::CComPtr<IXMLDOMAttribute>  pAttribActual;
    ::ATL::CComPtr<IXMLDOMNode>       pTempNode;
    HRESULT                hr;
    
    //
    // Get the attribute from our namespace
    //
    hr = Attributes->getQualifiedItem(
        _bstr_t(AttribName.c_str()),
        _bstr_t(NamespaceURI.c_str()),
        &pAttribNode);
    
    if ( SUCCEEDED( hr ) )
    {
        //
        // If we had success, but the attribute node is null, then we have to
        // go create one, which is tricky.
        //
        if ( pAttribNode == NULL )
        {
            VARIANT vt;
            vt.vt = VT_INT;
            vt.intVal = NODE_ATTRIBUTE;
            
            //
            // Do the actual creation part
            //
            hr = Document->createNode(
                vt,
                _bstr_t(AttribName.c_str()),
                _bstr_t(NamespaceURI.c_str()),
                &pTempNode);
            
            if ( FAILED( hr ) )
            {
                wstringstream ss;
                ss << wstring(L"Can't create the new attribute node ") << AttribName;
                ReportError( ErrorFatal, ss );
                goto lblGetOut;
            }
            
            //
            // Now we go and put that item into the map.
            //
            if ( FAILED( hr = Attributes->setNamedItem( pTempNode, &pAttribNode ) ) )
                goto lblGetOut;
        }
        
        hr = pAttribNode->put_text( _bstr_t(Value.c_str()) );
    }
    
lblGetOut:
    //    SAFERELEASE( pAttribNode );
    //    SAFERELEASE( pTempNode );
    return hr;
}


HRESULT
SxspSimplifyGetAttribute(
                         ::ATL::CComPtr<IXMLDOMNamedNodeMap> Attributes,
                         wstring AttribName,
                         wstring &Destination,
                         wstring NamespaceURI
                         )
{
    ::ATL::CComPtr<IXMLDOMNode>   NodeValue;
    HRESULT                    hr = S_OK;
    BSTR                    _bst_pretemp;
    
    Destination = L"";
    
    if ( FAILED( hr = Attributes->getNamedItem(
        _bstr_t(AttribName.c_str()),
        &NodeValue
        ) ) )
    {
        goto lblBopOut;
    }
    else if ( NodeValue == NULL )
    {
        goto lblBopOut;
    }
    else
    {
        if ( FAILED( hr = NodeValue->get_text( &_bst_pretemp ) ) )
        {
            goto lblBopOut;
        }
        Destination = _bstr_t(_bst_pretemp,FALSE);
    }
    
lblBopOut:
    return hr;
}




wostream& operator<<(
                     wostream& ost,
                     const CPostbuildProcessListEntry& thing
                     )
{
    ost << wstring(L"(path=") << thing.manifestFullPath.c_str()
        << wstring(L" name=")<< thing.name.c_str()
        << wstring(L" version=") << thing.version.c_str()
        << wstring(L" language=") << thing.language.c_str() << wstring(L")");
    return ost;
}

bool g_bDisplaySpew = false, g_bDisplayWarnings = true;


bool FileExists( const wstring& str )
{
    return (GetFileAttributesW(str.c_str()) != -1) && 
        ((GetLastError() == ERROR_FILE_NOT_FOUND) || (GetLastError() == ERROR_PATH_NOT_FOUND));
}

wstring JustifyPath( const wstring& str )
{
    vector<WCHAR> vec;
    DWORD dwCount = GetLongPathNameW( str.c_str(), NULL, 0 );
    
    if (dwCount == 0)
    {
        wstringstream ws;
        
        dwCount = ::GetLastError();
        
        ws << wstring(L"Unable to get the length of the 'long name' of ") << str 
            << wstring(L" error ") << dwCount;
        ReportError( ErrorFatal, ws);
        exit(1);
    }
    
    vec.resize( dwCount );
    GetLongPathNameW( str.c_str(), &vec.front(), vec.size() );
    
    return wstring( &vec.front() );
}


void CPostbuildProcessListEntry::setManifestLocation( wstring root, wstring where )
{
    manifestFullPath = root + L"\\" + where;
    manifestPathOnly = manifestFullPath.substr( 0, manifestFullPath.find_last_of( L'\\' ) );
    manifestFileName = manifestFullPath.substr( manifestFullPath.find_last_of( L'\\' ) + 1 );
    
    if ( !FileExists( manifestFullPath ) )
    {
        wstringstream ss;
        ss << wstring(L"Referenced manifest ") << where << wstring(L" does not exist.");
        ReportError(ErrorSpew, ss);
    }
}



//
// Converts a series of strings, foo=bar chunklets, space-seperated, into a map
// from 'foo' to 'bar'
//
StringStringMap
MapFromDefLine(const wstring& source, wchar_t wchBreakValue)
{
    wstring::const_iterator here = source.begin();
    StringStringMap rvalue;
    
    //
    //
    // The tricky bit is that there could be spaces in quoted strings...
    //
    while ( here != source.end() )
    {
        wstring tag, value;
        wchar_t end_of_value = L' ';
        wstring::const_iterator equals;
        
        //
        // Look for an equals first
        //
        equals = find( here, source.end(), L'=' );
        
        //
        // If there is no equals sign, stop.
        //
        if (equals == source.end())
            break;
        
        tag.assign( here, equals );
        
        //
        // Hop over the equals
        //
        here = equals;
        here++;
        
        //
        // If the equals sign was the last character in the wstring, stop.
        //
        if (here == source.end())
            break;
        
        //
        // Is 'here' at an open quote?  Then extract everything to the next
        // quote, remembering to skip this quote as well
        //
        if ( *here == L'\"' )
        {
            end_of_value = L'\"';
            here++;
            
            //
            // If the quote was the last character in the wstring, stop.
            //
            if (here == source.end())
                break;
        }
        
        //
        // Now go and look for the end of the wstring, or a quote or a space.
        //
        wstring::const_iterator fullstring = find( here, source.end(), end_of_value );
        
        value.assign( here, fullstring );
        
        //
        // If it was a quote or a space, skip it. If end of wstring, stay put.
        //
        if (fullstring != source.end())
            here = fullstring + 1;
        
        rvalue.insert( pair<wstring,wstring>( tag, value ) );
        
        //
        // Skip whitespace, but stop if we hit the end of the wstring.
        //
        while (here != source.end() && (*here == L' ' || *here == L'\t' || *here == '\n' || *here == '\r' || iswspace(*here)))
            here++;
    }
    
    return rvalue;
}


const wstring c_wsp_usage           = wstring(L"-?");
const wstring c_wsp_nologo          = wstring(L"-nologo");
const wstring c_wsp_verbose         = wstring(L"-verbose");
const wstring c_wsp_manifest        = wstring(L"-manifest");
const wstring c_wsp_hashupdate      = wstring(L"-hashupdate");
const wstring c_wsp_makecdfs        = wstring(L"-makecdfs");
const wstring c_wsp_razzle          = wstring(L"-razzle");
const wstring c_wsp_binplacelog     = wstring(L"-binplacelog");
const wstring c_wsp_asmsroot        = wstring(L"-asmsroot");
const wstring c_wsp_cdfpath         = wstring(L"-cdfpath");
const wstring c_wsp_version         = wstring(L"-version");
const wstring c_wsp_name            = wstring(L"-name");
const wstring c_wsp_language        = wstring(L"-language");
const wstring c_wsp_type            = wstring(L"-type");
const wstring c_wsp_pkt             = wstring(L"-publickeytoken");
const wstring c_wsp_procarch        = wstring(L"-processorarchitecture");
const wstring c_wsp_depends         = wstring(L"-dependency");
const wstring c_wsp_freshassembly   = wstring(L"-freshassembly");


CParameters::CParameters() : m_fVerbose(false), m_fNoLogo(false), m_fUpdateHash(false), m_fUsage(false),
m_fCreateCdfs(false), m_fDuringRazzle(false), m_fSingleItem(false), m_fCreateNewAssembly(false)
{
}

bool
CParameters::ChunkifyParameters(UINT uiP, WCHAR** ppwszParams)
{
    for (UINT i = 0; i < uiP; i++)
    {
        this->m_Parameters.push_back(wstring(ppwszParams[i]));
    }
    
    return true;
}



bool
CParameters::ParseDependentString(const wstring & ws, CSimpleIdentity & target)
{
    wstring::const_iterator here = ws.begin();
    wstring::const_iterator i;
    
    target.wsLanguage = wstring(L"*");
    target.wsProcessorArchitecture = wstring(L"*");
    target.wsName = target.wsPublicKeyToken = target.wsType = target.wsVersion = wstring(L"");
    
    //
    // Find the name part of the identity
    //
    if ((i = find(ws.begin(), ws.end(), L',')) == ws.end())
        return false;
    
    target.wsName = wstring(ws.begin(), i);
    
    here = i + 1;
    
    //
    // Now, let's look for the name:namespace= part of the name-value pair
    //
    while (here != ws.end())
    {   
        std::wstring wsThisAttributePart;
        std::wstring wsValueName;
        std::wstring wsValueValue;
        std::wstring wsValueNamespace;
        std::wstring::const_iterator close_quote;
        
        i = std::find(here, ws.end(), L'=');
        if (i == ws.end())
            return false;
        
        wsThisAttributePart = wstring(here, i++);
        
        //
        // The cursor had better not be at the end of the string yet.
        //
        if (i == ws.end())
            return false;
        
        // No namespace thing in this string, so we can skip it
        if (find(wsThisAttributePart.begin(), wsThisAttributePart.end(), L':') == wsThisAttributePart.end())
        {
            wsValueName = wsThisAttributePart;
        }
        
        //
        // i should be at the quote right after the =.  Make sure of that.
        //
        if (*i++ != L'\'')
            return false;
        
        close_quote = find(i, ws.end(), L'\'');
        if (close_quote == ws.end())
            return false;
        
        wsValueValue = wstring(i, close_quote);
        
        static const std::wstring c_ws_version = wstring(L"version");
        static const std::wstring c_ws_language = wstring(L"language");
        static const std::wstring c_ws_publicKeyToken = wstring(L"publicKeyToken");
        static const std::wstring c_ws_type = wstring(L"type");
        static const std::wstring c_ws_processorArchitecture = wstring(L"processorArchitecture");
        
        if (wsValueNamespace.length() == 0)
        {
            if (wsValueName == c_ws_version) {
                target.wsVersion = wsValueValue;
            }
            else if (wsValueName == c_ws_language) {
                target.wsLanguage = wsValueValue;
            }
            else if (wsValueName == c_ws_publicKeyToken) {
                target.wsPublicKeyToken = wsValueValue;
            }
            else if (wsValueName == c_ws_type) {
                target.wsType = wsValueValue;
            }
            else if (wsValueName == c_ws_processorArchitecture) {
                target.wsProcessorArchitecture = wsValueValue;
            }
            else {
                return false;
            }
        }
        else
        {
            target.OtherValues.push_back(
                CSimpleIdentity::CUnknownIdentityThing(
                wsValueNamespace, 
                wsValueName, 
                wsValueValue));
        }
        
        here = close_quote + 1;
        if (here == ws.end())
            break;
        else if (*here != L',')
            return false;
        
        here++;        
    }
    
    return true;    
}



CParameters::SetParametersResult
CParameters::SetComandLine(UINT uiParameters, WCHAR** wszParameters) 
{
    
    std::vector<wstring>::const_iterator ci;
    
    class CMatching {
    public:
        const wstring &wsparam;
        wstring &wstarget;
        CMatching(const wstring& p, wstring &t) : wsparam(p), wstarget(t) { }
    };
    
    CMatching SingleParamThings[] = {
        CMatching(c_wsp_binplacelog,       m_BinplaceLog),
            CMatching(c_wsp_cdfpath,           m_CdfOutputPath),
            CMatching(c_wsp_asmsroot,          m_AsmsRoot),
            CMatching(c_wsp_manifest,          m_SingleEntry.wsManifestPath),
            CMatching(c_wsp_version,           m_SingleEntry.wsVersion),
            CMatching(c_wsp_name,              m_SingleEntry.wsName),
            CMatching(c_wsp_language,          m_SingleEntry.wsLanguage),
            CMatching(c_wsp_procarch,          m_SingleEntry.wsProcessorArchitecture),
            CMatching(c_wsp_type,              m_SingleEntry.wsType),
            CMatching(c_wsp_pkt,               m_SingleEntry.wsPublicKeyToken)
    };
    
    if (!ChunkifyParameters(uiParameters, wszParameters)) 
    {
        return eCommandLine_usage;
    }
    
    for (ci = m_Parameters.begin(); ci != m_Parameters.end(); ci++)
    {
        wstring ws = *ci;
        
        m_fVerbose              |= (*ci == c_wsp_verbose);
        m_fNoLogo               |= (*ci == c_wsp_nologo);
        m_fUpdateHash           |= (*ci == c_wsp_hashupdate);
        m_fCreateCdfs           |= (*ci == c_wsp_makecdfs);
        m_fDuringRazzle         |= (*ci == c_wsp_razzle);
        m_fCreateNewAssembly    |= (*ci == c_wsp_freshassembly);
        
        //
        // Things that have a single parameter
        //
        for (int i = 0; i < NUMBER_OF(SingleParamThings); i++)
        {
            if (SingleParamThings[i].wsparam == *ci)
            {
                std::vector<wstring>::const_iterator cinext = ci + 1;
                
                if ((cinext == m_Parameters.end()) || ((*cinext).at(0) == L'-'))
                {
                    std::wstringstream wss;
                    wss << *ci << wstring(L" requires an extra parameter");
                    ReportError(ErrorFatal, wss);
                    return eCommandLine_usage;
                }
                
                SingleParamThings[i].wstarget = *cinext;
            }
        }
        
        //
        // Injecting a dependency gathers up a 'textual identity' string that's
        // turned into an assemblyIdentity statement and added to the dependency
        //
        if (*ci == c_wsp_depends)
        {
            CSimpleIdentity Dependent;
            
            if ((ci + 1) == m_Parameters.end() || ((*(ci+1)).at(0) == L'-'))
            {
                std::wstringstream wss;
                wss << *ci << wstring(L" needs a parameter blob");
                ReportError(ErrorFatal, wss);
                return eCommandLine_usage;
            }
            
            // These can be defaulted
            Dependent.wsLanguage = Dependent.wsProcessorArchitecture = wstring(L"*");
            if (ParseDependentString(*++ci, Dependent))
            {
                this->m_InjectDependencies.push_back(Dependent);
            }
            else
            {
                std::wstringstream wss;
                wss << *ci << wstring(L" isn't a valid dependency statement");
                ReportError(ErrorFatal, wss);
                return eCommandLine_usage;
            }
        }
        
    }
    
    //
    // Was there a single manifestish thing?
    //
    if (this->m_SingleEntry.wsManifestPath.length() != 0)
    {
        WCHAR wchBlob[MAX_PATH];
        this->m_fSingleItem = TRUE;
        
        GetCurrentDirectoryW(NUMBER_OF(wchBlob), wchBlob);
        m_SinglePostbuildItem.setManifestLocation(wstring(wchBlob), m_SingleEntry.wsManifestPath);
        m_SinglePostbuildItem.language = m_SingleEntry.wsLanguage;
        m_SinglePostbuildItem.version = m_SingleEntry.wsVersion;
        m_SinglePostbuildItem.name = m_SingleEntry.wsName;        
    }
    
    return m_fNoLogo ? eCommandLine_nologo : eCommandLine_normal;
}


std::string ConvertWString(const wstring& src)
{
    vector<CHAR> chBuffer;
    int iChars;
    
    iChars = WideCharToMultiByte(CP_ACP, 0, src.c_str(), -1, NULL, 0, NULL, NULL);
    if (iChars > 0)
    {
        chBuffer.resize(iChars);
        WideCharToMultiByte(CP_ACP, 0, src.c_str(), -1, &chBuffer.front(), chBuffer.size(), NULL, NULL);
    }
    
    return std::string(&chBuffer.front());
}


std::wstring ConvertString(const std::string& source)
{
    std::vector<WCHAR> wch;
    wch.resize( MultiByteToWideChar( CP_ACP, 0, source.data(), source.size(), NULL, 0 ) );
    MultiByteToWideChar( CP_ACP, 0, source.data(), source.size(), &wch.front(), wch.size() );
    
    return std::wstring( wch.begin(), wch.end() );
} 

bool AllWhitespace(const wstring& ws)
{
    return (ws.find_first_not_of(L"\r\n \t") == wstring::npos);
}

//
// Strip out all whitespace
//
HRESULT UglifyXmlNode(::ATL::CComPtr<IXMLDOMNode> Parent)
{
    ::ATL::CComPtr<IXMLDOMNode> Iterator;
    HRESULT hr;
    
    
    Parent->get_firstChild(&Iterator);
    while (Iterator != NULL)
    {
        DOMNodeType NodeType;
        ::ATL::CComPtr<IXMLDOMNode> ThisNode;
        
        ThisNode = Iterator;
        Iterator = NULL;
        
        //
        // Move the iterator forward one, but keep ThisNode put
        //
        if (FAILED(hr = ThisNode->get_nextSibling(&Iterator)))
            return hr;
        
        if (FAILED(hr = ThisNode->get_nodeType(&NodeType)))
            return hr;
        
        if (NodeType == NODE_TEXT)
        {
            BSTR bst;

            if (FAILED(hr = ThisNode->get_text(&bst)))
                return hr;

            if (AllWhitespace(wstring(_bstr_t(bst, false))))
            {
                if (FAILED(hr = Parent->removeChild(ThisNode, NULL)))
                    return hr;
            }
        }
        else if (NodeType == NODE_ELEMENT)
        {
            if (FAILED(hr = UglifyXmlNode(ThisNode)))
                return hr;
        }
    }
    
    return S_OK;
}

HRESULT UglifyXmlDocument(ISXSManifestPtr DocumentPtr)
{
    ::ATL::CComPtr<IXMLDOMElement> RootElement;
    ::ATL::CComPtr<IXMLDOMNode> RootNode;
    HRESULT hr;
    
    //
    // Clean up all adjacent-whitespace chunklets
    //
    if (FAILED(hr = DocumentPtr->get_documentElement(&RootElement)))
        return hr;
    
    if (FAILED(hr = RootElement->normalize()))
        return hr;
    
    if (FAILED(hr = RootElement.QueryInterface(&RootNode)))
        return hr;

    if (FAILED(hr = UglifyXmlNode(RootNode)))
        return hr;

    return S_OK;
}


HRESULT PrettyFormatXmlNode(::ATL::CComPtr<IXMLDOMNode> ThisNode, int iLevel)
{
    ::ATL::CComPtr<IXMLDOMDocument> Document;
    ::ATL::CComPtr<IXMLDOMNode> pIterator;
    bool fHasChildren = false;
    DOMNodeType NodeType = NODE_INVALID;
    HRESULT hr;
    
    if (FAILED(hr = ThisNode->get_ownerDocument(&Document)))
        return hr;
    
    
    ThisNode->get_firstChild(&pIterator);
    while (pIterator != NULL)
    {
        ::ATL::CComPtr<IXMLDOMText> CreatedNode;
        ::ATL::CComPtr<IXMLDOMNode> pNext;
        fHasChildren = true;
        
        wstring ws = wstring(L"\r\n");
        ws.append(iLevel * 2, L' ');
        
        if (FAILED(hr = pIterator->get_nodeType(&NodeType)))
            return hr;

        if (NodeType != NODE_TEXT)
        {
            if (FAILED(hr = Document->createTextNode(_bstr_t(ws.c_str()), &CreatedNode)))
                return hr;
        
            if (FAILED(hr = ThisNode->insertBefore(CreatedNode, _variant_t(pIterator), NULL)))
                return hr;
        
            if (FAILED(PrettyFormatXmlNode(pIterator, iLevel + 1)))
                return hr;
        
            if (FAILED(hr = pIterator->get_nextSibling(&pNext)))
                return hr;
        }

        pIterator = pNext;        
    }
    
    if (fHasChildren && (NodeType != NODE_TEXT))
    {
        ::ATL::CComPtr<IXMLDOMText> CreatedNode;
        
        wstring ws = wstring(L"\r\n");
        ws.append((iLevel - 1) * 2, L' ');
        
        
        if (FAILED(hr = Document->createTextNode(_bstr_t(ws.c_str()), &CreatedNode)))
            return hr;
        
        if (FAILED(hr = ThisNode->appendChild(CreatedNode, NULL)))
            return hr;
    }
    
    return hr;
    
}


HRESULT PrettyFormatXmlDocument(ISXSManifestPtr DocumentPtr)
{
    ::ATL::CComPtr<IXMLDOMElement> RootElement;
    ::ATL::CComPtr<IXMLDOMNode> RootNode;
    HRESULT hr;
    
    if (FAILED(hr = DocumentPtr->get_documentElement(&RootElement)))
        return hr;
    
    if (FAILED(hr = RootElement.QueryInterface(&RootNode)))
        return hr;
    
    if (FAILED(hr = PrettyFormatXmlNode(RootNode, 1)))
        return hr;
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\buildtool\hasheditor.cpp ===
#include "stdinc.h"

#define SHA1_HASH_SIZE_BYTES	( 160 / 8 )
#define HASHFLAG_AUTODETECT		( 0x0001 )
#define HASHFLAG_STRAIGHT_HASH 	( 0x0002 )
#define HASHFLAG_PROCESS_IMAGE	( 0x0004 )


const wstring XML_ATTRIBUTE_NAME = (L"name");

HRESULT FreshenFileNodeHashes( PVOID, int argc, WCHAR *argv[] );
HRESULT ProcessSingleFileNode( ISXSManifestPtr pDocument, IXMLDOMNode *pDocNode );

BOOL	
SxspCreateFileHash(
    DWORD dwFlags,
	ALG_ID PreferredAlgorithm,
	wstring pwsFileName,
	wstring &HashBytes
    );

const wstring p_bstHashAlgName = (L"SHA1");

wstring
ConvertHashToString( std::vector<BYTE> Hash )
{
    wstringstream output;
    output << hex;
    output.fill(L'0');
    output.width(2);

    for ( std::vector<BYTE>::const_iterator it = Hash.begin(); it != Hash.end(); it++ )
    {
        output << *it;
    }

    return output.str();
}


HRESULT
ProcessSingleFileNode(
    ISXSManifestPtr Document,
    ::ATL::CComPtr<IXMLDOMNode> DocNode
    )
{
	//
	// Here, we're dealing with a single file.  So, we have to go and see if
	// there's a Verification subtag of this file, and process it properly.
	//
	
	wstring				            bstFileName;
	wstring				            bstNamespace, bstPrefix;
	::ATL::CComPtr<IXMLDOMNamedNodeMap>   Attributes;
	::ATL::CComPtr<IXMLDOMNode>           Dump;
	HRESULT					        hr;
    wstring                          Hash;

	//
	// So we get the attributes of this node, which should contain the file
	// name and hash information.
	//
	if ( FAILED( hr = DocNode->get_attributes( &Attributes ) ) )
		goto lblGetOut;

	//
	// Now just the values out
	//
	SxspSimplifyGetAttribute( Attributes, XML_ATTRIBUTE_NAME, bstFileName, ASM_NAMESPACE_URI );

	//
	// Now we use this to gather information about the file, and to fix
	// the values in the hash entry if need be.
	//
    if (::SxspCreateFileHash(HASHFLAG_AUTODETECT, CALG_SHA1, bstFileName, Hash))
	{
		//
		// Write the data back into the node, don't change the file name at all
		//
        ::ATL::CComPtr<IXMLDOMNode> Dump;
        Attributes->removeNamedItem( _bstr_t(L"hash"), &Dump );
        Attributes->removeNamedItem( _bstr_t(L"hashalg"), &Dump );
		SxspSimplifyPutAttribute( Document, Attributes, L"hash", Hash );
		SxspSimplifyPutAttribute( Document, Attributes, L"hashalg", p_bstHashAlgName );
		{
		    wstringstream ss;
		    ss << bstFileName.c_str() << wstring(L" hashed to ") << Hash.c_str();
		    ReportError( ErrorSpew, ss );
		}
	}
	else
	{
	    wstringstream ss;
	    ss << wstring(L"Unable to create hash for file ") << bstFileName.c_str();
	    ReportError( ErrorWarning, ss );
		goto lblGetOut;
	}

lblGetOut:
	return hr;
	
}

wstring AssemblyFileXSLPattern = (L"/assembly/file");

bool UpdateManifestHashes( const CPostbuildProcessListEntry& item )
{
    ISXSManifestPtr document;
    ::ATL::CComPtr<IXMLDOMElement> rootElement;
    ::ATL::CComPtr<IXMLDOMNodeList> fileTags;
    ::ATL::CComPtr<IXMLDOMNode> fileNode;
    HRESULT hr = S_OK;

    if ( FAILED(hr = ConstructXMLDOMObject( item.getManifestFullPath(), document )) )
    {
        wstringstream ss;
        ss << wstring(L"Failed opening the manifest ") << item.getManifestFullPath()
           << wstring(L" for input under the DOM.");
        ReportError( ErrorFatal, ss );
        return false;
    }

    if ( FAILED(document->get_documentElement( &rootElement ) ) )
    {
        wstringstream ss;
        ss << wstring(L"The manifest ") << item.getManifestFullPath() << wstring(L" may be malformed,")
           << wstring(L" as we were unable to load the root element!");
        ReportError( ErrorFatal, ss );
        return false;
    }

    //
    // Now, let's select all the 'file' nodes under 'assembly' tags:
    //
    hr = document->selectNodes( _bstr_t(AssemblyFileXSLPattern.c_str()), &fileTags );
    if ( FAILED(hr) )
    {
        wstringstream ss;
        ss << wstring(L"Unable to select the file nodes under this assembly tag, can't proceed.");
        ReportError( ErrorFatal, ss );
    }

    long length;
    fileTags->get_length( &length );

    //
    // And for each, process it
    //
    fileTags->reset();
    while ( SUCCEEDED(fileTags->nextNode( &fileNode ) ) )
    {
        //
        // All done
        //
        if ( fileNode == NULL )
        {
            break;
        }

        SetCurrentDirectoryW( item.getManifestPathOnly().c_str() );
        ProcessSingleFileNode( document, fileNode );
    }

    if ( FAILED( hr = document->save( _variant_t(_bstr_t(item.getManifestFullPath().c_str())) ) ) )
    {
        wstringstream ss;
        ss << wstring(L"Unable to save manifest ") << item.getManifestFullPath()
           << wstring(L" back after updating hashes! Changes will be lost.");
        ReportError( ErrorFatal, ss );
    }

    return true;
}


//
// HUGE HACKHACK
//
// There has to be some nice way of including this code (which otherwise lives
// in hashfile.cpp in the fusion\dll\whistler tree) other than just glomping
// it here.
//

BOOL
ImageDigesterFunc(
	DIGEST_HANDLE hSomething,
	PBYTE pbDataBlock,
	DWORD dwLength
    )
{
	return CryptHashData( (HCRYPTHASH)hSomething, pbDataBlock, dwLength, 0 );
}


BOOL
pSimpleHashRoutine(
	HCRYPTHASH hHash,
	HANDLE hFile
    )
{
	static const DWORD FILE_BUFFER = 64 * 1024;
	BYTE pbBuffer[FILE_BUFFER];
	DWORD dwDataRead;
	BOOL b = FALSE;
    BOOL bKeepReading = TRUE;
	
	while ( bKeepReading )
	{
		b = ReadFile( hFile, pbBuffer, FILE_BUFFER, &dwDataRead, NULL );
		if ( b && ( dwDataRead == 0 ) )
		{
			bKeepReading = FALSE;
			b = TRUE;
			continue;
		}
		else if ( !b )
		{
		    WCHAR ws[8192];
		    FormatMessageW(
		        FORMAT_MESSAGE_FROM_SYSTEM,
		        NULL,
		        ::GetLastError(),
		        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
		        ws,
		        0,
		        NULL
		    );
		    bKeepReading = FALSE;
		    continue;
		}
		
		if ( CryptHashData( hHash, pbBuffer, dwDataRead, 0 ) == 0 )
		{
		    b = FALSE;
			break;
		}
	}

	return b;
}


BOOL
pImageHashRoutine(
	HCRYPTHASH hHash,
	HANDLE hFile
    )
{
	return ImageGetDigestStream(
		hFile,
		CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO,
		ImageDigesterFunc,
		(DIGEST_HANDLE)hHash
	);
}

BOOL	
SxspCreateFileHash(DWORD dwFlags,
			   ALG_ID PreferredAlgorithm,
			   wstring pwsFileName,
			   wstring &HashBytes
    )
{
	BOOL			fSuccessCode = FALSE;
	HCRYPTPROV		hProvider;
	HCRYPTHASH		hCurrentHash;
	HANDLE			hFile;

	// Initialization
	hProvider = (HCRYPTPROV)INVALID_HANDLE_VALUE;
	hCurrentHash = (HCRYPTHASH)INVALID_HANDLE_VALUE;
	hFile = INVALID_HANDLE_VALUE;

	//
	// First try and open the file.  No sense in doing anything else if we
	// can't get to the data to start with.  Use a very friendly set of
	// rights to check the file.  Future users might want to be sure that
	// you're in the right security context before doing this - system
	// level to check system files, etc.
	//
	hFile = CreateFileW(
		pwsFileName.c_str(),
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN,
		NULL
		);
		
	if ( hFile == INVALID_HANDLE_VALUE ) {
		return FALSE;
	}
	
	//
	// Create a cryptological provider that supports everything RSA needs.
	//
	if (!CryptAcquireContextW(&hProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
		goto lblCleanup;
	
	//
	// We'll be using SHA1 for the file hash
	//
	if ( !CryptCreateHash( hProvider, PreferredAlgorithm, 0, 0, &hCurrentHash ) )
		goto lblCleanup;


	//
	// So first try hashing it via the image, and if that fails, try the
	// normal file-reading hash routine instead.
	//
	if ( dwFlags & HASHFLAG_AUTODETECT )
	{
		if ( !pImageHashRoutine( hCurrentHash, hFile ) )
		{
			//
			// Oops, the image-hasher wasn't happy.  Let's try the straight
			// hasher instead.
			//
			if ( !pSimpleHashRoutine( hCurrentHash, hFile ) )
			{
				goto lblCleanup;
			}
			else
			{
				fSuccessCode = TRUE;
			}
		}
		else
		{
			fSuccessCode = TRUE;
		}
		
	}
	else if ( dwFlags & HASHFLAG_STRAIGHT_HASH )
	{
		fSuccessCode = pSimpleHashRoutine( hCurrentHash, hFile );
	}
	else if ( dwFlags & HASHFLAG_PROCESS_IMAGE )
	{
		fSuccessCode = pImageHashRoutine( hCurrentHash, hFile );
	}
	else
	{
		::SetLastError( ERROR_INVALID_PARAMETER );
		goto lblCleanup;
	}


	//
	// We know the buffer is the right size, so we just call down to the hash parameter
	// getter, which will be smart and bop out (setting the pdwDestinationSize parameter)
	// if the user passed an invalid parameter.
	//
	if ( fSuccessCode )
	{
        wstringstream ss;
	    DWORD dwSize, dwDump;
	    BYTE *pb = NULL;
        fSuccessCode = CryptGetHashParam( hCurrentHash, HP_HASHSIZE, (BYTE*)&dwSize, &(dwDump=sizeof(dwSize)), 0 );
        if ( !fSuccessCode || ( pb = new BYTE[dwSize] ) == NULL ) {
            goto lblCleanup;
        }
		fSuccessCode = CryptGetHashParam( hCurrentHash, HP_HASHVAL, pb, &dwSize, 0);
		if ( !fSuccessCode ) {
		    delete[] pb;
		    goto lblCleanup;
		}


        for ( dwDump = 0; dwDump < dwSize; dwDump++ ) {
            ss << hex;
            ss.fill('0');
            ss.width(2);
		    ss << (unsigned int)pb[dwDump];
        }

        HashBytes = ss.str();
		delete[] pb;
	}

	
lblCleanup:
	DWORD dwLastError = ::GetLastError();
	if ( hFile != INVALID_HANDLE_VALUE )
	{
		CloseHandle( hFile );
	}

	//
	// We just destroy the hash and the crypto context blindly.  If they were
	// invalid before, the release and destroy would just return with a failure,
	// not an exception or fault.
	//
	CryptDestroyHash( hCurrentHash );
	CryptReleaseContext( hProvider, 0 );

	::SetLastError( dwLastError );
	return fSuccessCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\buildtool\manglers.h ===
#pragma once

class CPostbuildProcessListEntry;

bool GenerateCatalogContents( const CPostbuildProcessListEntry& item );
bool UpdateManifestHashes( const CPostbuildProcessListEntry& item );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\buildtool\filestream.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    filestream.cpp

Abstract:

    Implementation of IStream over a win32 file.

Author:

    Michael J. Grier (MGrier) 23-Feb-2000

Revision History:

--*/

#include "stdinc.h"
#include "helpers.h"
#include <windows.h>
#define UNUSED(x)

BOOL
MySetFilePointerEx(
  HANDLE         File,                    // handle to file
  LARGE_INTEGER  DistanceToMove,  // bytes to move pointer
  PLARGE_INTEGER NewFilePointer, // new file pointer
  DWORD          MoveMethod               // starting point
)
{
    LONG DistanceToMoveLow  = static_cast<LONG>(DistanceToMove.LowPart);
    LONG DistanceToMoveHigh = DistanceToMove.HighPart;
    DWORD NewPositionLow = SetFilePointer(File, DistanceToMoveLow, &DistanceToMoveHigh, MoveMethod);

    if (NewPositionLow == INVALID_SET_FILE_POINTER)
    {
        if (GetLastError() != NO_ERROR)
            return FALSE;
    }
    if (NewFilePointer != NULL)
    {
        NewFilePointer->LowPart =  NewPositionLow;
        NewFilePointer->HighPart = DistanceToMoveHigh;
    }
    return TRUE;
}

CFileStreamBase::~CFileStreamBase()
{
    const DWORD dwLastError = ::GetLastError();
    Close();
    ::SetLastError(dwLastError);
}

bool
CFileStreamBase::OpenForWrite(wstring pszPath)
{
    if (m_hFile != INVALID_HANDLE_VALUE)
        return false;

    m_hFile = ::CreateFileW(
        pszPath.c_str(),
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    return (m_hFile != INVALID_HANDLE_VALUE);
}

bool
CFileStreamBase::OpenForRead(wstring pszPath)
{
    if (m_hFile != INVALID_HANDLE_VALUE)
        return false;

    m_hFile = ::CreateFileW(
        pszPath.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    return (m_hFile != INVALID_HANDLE_VALUE);
}

bool
CFileStreamBase::Close()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        if (!::CloseHandle(m_hFile))
        {
            return false;
        }
        m_hFile = INVALID_HANDLE_VALUE;
    }

    return true;
}

ULONG
CFileStreamBase::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

ULONG
CFileStreamBase::Release()
{
    const ULONG ulRefCount = ::InterlockedDecrement(&m_cRef);
    if ( ulRefCount == 0 ) 
    {
        delete this;
        return 0;
    }
    else
    {
        return ulRefCount;
    }
}

HRESULT
CFileStreamBase::QueryInterface(
    REFIID riid,
    PVOID *ppvObj
    )
{
    HRESULT hr = NOERROR;

    IUnknown *pIUnknown = NULL;

    if (ppvObj != NULL)
        *ppvObj = NULL;

    if (ppvObj == NULL)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if ((riid == IID_IUnknown) ||
        (riid == IID_ISequentialStream) ||
        (riid == IID_IStream))
        pIUnknown = static_cast<IStream *>(this);

    if (pIUnknown == NULL)
    {
        hr = E_NOINTERFACE;
        goto Exit;
    }

    pIUnknown->AddRef();
    *ppvObj = pIUnknown;

    hr = NOERROR;

Exit:
    return hr;
}


HRESULT
CFileStreamBase::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = NOERROR;
    ULONG cbRead = 0;

    if (pcbRead != NULL)
        *pcbRead = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    if (!m_bSeenFirstCharacter)
    {
#ifdef AWFUL_SPACE_HACK
        while (true)
        {
            CHAR ch;
            ReadFile(m_hFile, &ch, 1, &cbRead, NULL);
            if ((ch != '\n') && (ch != '\r') && (ch != ' ') && (ch != '\t')) {
                m_bSeenFirstCharacter = true;
                LARGE_INTEGER li;
                li.QuadPart = -1;
                ::MySetFilePointerEx(m_hFile, li, NULL, FILE_CURRENT);
                break;
            }
        }
#endif
    }

    if (!::ReadFile(m_hFile, pv, cb, &cbRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (cbRead == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if (pcbRead != NULL)
        *pcbRead = cbRead;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Write(
    void const *pv,
    ULONG cb,
    ULONG *pcbWritten
    )
{
    HRESULT hr = NOERROR;
    ULONG cbWritten = 0;

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    if (!::WriteFile(m_hFile, pv, cb, &cbWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    if (cbWritten == 0)
        hr = S_FALSE;
    else
        hr = NOERROR;

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

Exit:
    return hr;
}

HRESULT
CFileStreamBase::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition
    )
{
    HRESULT hr = NOERROR;
    DWORD dwWin32Origin = 0;

    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    switch (dwOrigin)
    {
    default:
        hr = E_INVALIDARG;
        goto Exit;

    case STREAM_SEEK_SET:
        dwWin32Origin = FILE_BEGIN;
        break;

    case STREAM_SEEK_CUR:
        dwWin32Origin = FILE_CURRENT;
        break;

    case STREAM_SEEK_END:
        dwWin32Origin = FILE_END;
        break;
    }

    if (!::MySetFilePointerEx(
                m_hFile,
                dlibMove,
                (LARGE_INTEGER *) plibNewPosition,
                dwWin32Origin))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
    }

    hr = NOERROR;
Exit:
    return hr;
}

HRESULT
CFileStreamBase::SetSize(
    ULARGE_INTEGER libNewSize
    )
{
    UNUSED(libNewSize);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten
    )
{
    if (pcbRead != NULL)
        pcbRead->QuadPart = 0;

    if (pcbWritten != NULL)
        pcbWritten->QuadPart = 0;

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Commit(
    DWORD grfCommitFlags
    )
{
    HRESULT hr = NOERROR;

    if (grfCommitFlags != 0)
        return E_INVALIDARG;

    if (!Close())
        hr = HRESULT_FROM_WIN32 (GetLastError());

    return hr;
}

HRESULT
CFileStreamBase::Revert()
{
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    UNUSED(libOffset);
    UNUSED(cb);
    UNUSED(dwLockType);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType
    )
{
    UNUSED(libOffset);
    UNUSED(cb);
    UNUSED(dwLockType);
    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag
    )
{
    if (pstatstg != NULL)
        memset(pstatstg, 0, sizeof(*pstatstg));

    return E_NOTIMPL;
}

HRESULT
CFileStreamBase::Clone(
    IStream **ppIStream
    )
{
    if (ppIStream != NULL)
        *ppIStream = NULL;

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\buildtool\helpers.h ===
#pragma once

extern const wstring ASM_NAMESPACE_URI;

#define AWFUL_SPACE_HACK TRUE

#include "msxml2.h"

typedef ::ATL::CComPtr<MSXML2::IXMLDOMDocument2> ISXSManifestPtr;
extern ::ATL::CComPtr<IClassFactory> g_XmlDomClassFactory;

class CPostbuildProcessListEntry
{
private:
    wstring manifestFullPath;
    wstring manifestFileName;
    wstring manifestPathOnly;

public:
    wstring version;
    wstring name;
    wstring language;

    ISXSManifestPtr DocumentPointer;

    wstring getManifestFullPath() const { return manifestFullPath; }
    wstring getManifestFileName() const { return manifestFileName; }
    wstring getManifestPathOnly() const { return manifestPathOnly; }

    void setManifestLocation( wstring root, wstring where );

	bool operator==(const CPostbuildProcessListEntry& right) const
    {
        return !(*this < right) && !(right < *this);
    }

    static bool wstringPointerLessThan(const std::wstring* x, const std::wstring* y)
    {
        return x->compare(*y) < 0;
    }

	bool operator<(const CPostbuildProcessListEntry& right) const
    {
        // the order is arbitrary, 
        const std::wstring* leftwstrings[] =
            { &this->name, &this->version, &this->language, &this->manifestFullPath, &this->manifestFileName, &this->manifestPathOnly  };
        const std::wstring* rightwstrings[] =
            { &right.name, &right.version, &right.language, &right.manifestFullPath, &right.manifestFileName, &right.manifestPathOnly  };
        return std::lexicographical_compare(
            leftwstrings, leftwstrings + NUMBER_OF(leftwstrings),
            rightwstrings, rightwstrings + NUMBER_OF(rightwstrings),
            wstringPointerLessThan
            );
    }

	friend wostream& operator<<(wostream& ost, const CPostbuildProcessListEntry& thing );
};


class CSimpleIdentity {
public:
    wstring wsVersion;
    wstring wsName;
    wstring wsLanguage;
    wstring wsProcessorArchitecture;
    wstring wsType;
    wstring wsPublicKeyToken;
    wstring wsManifestPath;

    class CUnknownIdentityThing {
    public:
        wstring wsNamespace;
        wstring wsName;
        wstring wsValue;

        CUnknownIdentityThing(wstring& a, wstring &b, wstring &c)
            : wsNamespace(a), wsName(b), wsValue(c) {
        }
    };

    CSimpleIdentity() { wsLanguage = wsProcessorArchitecture = L"*"; }

    std::vector<CUnknownIdentityThing> OtherValues;
    
};


class CParameters {
public:

    bool m_fVerbose;
    bool m_fNoLogo;
    bool m_fUpdateHash;
    bool m_fCreateCdfs;
    bool m_fUsage;
    bool m_fDuringRazzle;
    bool m_fSingleItem;
    bool m_fCreateNewAssembly;

    wstring m_BinplaceLog;
    wstring m_CdfOutputPath;
    wstring m_AsmsRoot;

    CSimpleIdentity m_SingleEntry;
    CPostbuildProcessListEntry m_SinglePostbuildItem;
    std::vector<CSimpleIdentity> m_InjectDependencies;

    enum SetParametersResult {
        eCommandLine_nologo,
        eCommandLine_usage,
        eCommandLine_normal
    };
        
    CParameters();
    SetParametersResult SetComandLine(UINT uiParameters, WCHAR** wszParameters);

private:
    std::vector<wstring> m_Parameters;

    bool ParseDependentString(const wstring& ws, CSimpleIdentity &target);
    bool ChunkifyParameters(UINT uiParameters, WCHAR **pwszParameters);
    
};

extern CParameters g_GlobalParameters;



HRESULT
SxspSimplifyGetAttribute(
	::ATL::CComPtr<IXMLDOMNamedNodeMap> Attributes,
	wstring bstAttribName,
	wstring &bstDestination,
	wstring bstNamespaceURI = ASM_NAMESPACE_URI
    );

HRESULT
SxspSimplifyPutAttribute(
    ISXSManifestPtr Document,
	::ATL::CComPtr<IXMLDOMNamedNodeMap> Attributes,
	const wstring bstAttribName,
	const wstring bstValue,
	const wstring bstNamespaceURI = ASM_NAMESPACE_URI
    );

HRESULT
SxspExtractPathPieces(
	_bstr_t bstSourceName,
	_bstr_t &bstPath,
	_bstr_t &bstName
    );


HRESULT
CreateDocumentNode(
	VARIANT vt,
	_bstr_t bstAttribName,
	_bstr_t bstNamespace,
	IXMLDOMNode **pNewNode
    );

HRESULT
ConstructXMLDOMObject(
	wstring		SourceName,
	ISXSManifestPtr &result
    );


enum ErrorLevel
{
    ErrorFatal,
    ErrorWarning,
    ErrorSpew
};

inline void ReportError( ErrorLevel el, std::wstringstream& message )
{
    if ((el == ErrorSpew) && g_GlobalParameters.m_fVerbose)
    {
        wcout << wstring(L"SPEW: ") << message.str() << endl;
    }
    else 
    {
        if (el == ErrorWarning)
        {
            wcout << wstring(L"WARNING: ");
        }
        else
        {
            wcout << wstring(L"ERROR: ");
        }
        wcout << message.str() << endl;
    }
}

typedef vector<CPostbuildProcessListEntry> CPostbuildItemVector;
extern CPostbuildItemVector PostbuildEntries;

class CFileStreamBase : public IStream
{
public:
    CFileStreamBase()
        : m_cRef(0),
          m_hFile(INVALID_HANDLE_VALUE),
          m_bSeenFirstCharacter(false)
    { }

    virtual ~CFileStreamBase();

    bool OpenForRead( wstring pszPath );
    bool OpenForWrite( wstring pszPath );

    bool Close();

    // IUnknown methods:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // ISequentialStream methods:
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);

    // IStream methods:
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppIStream);

protected:
    LONG                m_cRef;
    HANDLE              m_hFile;
    bool                m_bSeenFirstCharacter;

private:
    CFileStreamBase(const CFileStreamBase &r); // intentionally not implemented
    CFileStreamBase &operator =(const CFileStreamBase &r); // intentionally not implemented
};

typedef std::map<wstring, wstring> StringStringMap;
typedef std::map<wstring, wstring> StringStringPair;
typedef wstring InvalidEquivalence;

StringStringMap   MapFromDefLine( const wstring& source, wchar_t wchBreakValue = L' ' );

wstring JustifyPath( const wstring& path );


std::string ConvertWString(const wstring& src);
std::wstring ConvertString(const std::string& src);

HRESULT UglifyXmlDocument(ISXSManifestPtr DocumentPtr);
HRESULT PrettyFormatXmlDocument(ISXSManifestPtr DocumentPtr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\buildtool\manifestmangler.cpp ===
// manifestmanlger.cpp : Defines the entry point for the console application.
//

#include "stdinc.h"
#include "atlbase.h"
#include "msxml2.h"
#if defined(JAYKRELL_UPDATEDEPENDENTS_BUILD_FIX)
#include "updatedependents.h"
#endif

BOOL g_bIgnoreMalformedXML = FALSE;

#define MAX_OPERATIONS (20)

extern const wstring ASM_NAMESPACE_URI = (L"urn:schemas-microsoft-com:asm.v1");

WCHAR MicrosoftCopyrightLogo[] = L"Microsoft (R) Side-By-Side Manifest Tool 1.1.0.0\nCopyright (C) Microsoft Corporation 2000-2002.  All Rights Reserved.\n\n";

//
// Global flags used in processing
//
::ATL::CComPtr<IClassFactory> g_XmlDomClassFactory;

#define XMLDOMSOURCE_FILE    (1)
#define XMLDOMSOURCE_STRING (2)
#define MAX_ARGUMENTS (500)
#define MAX_ARGUMENT_LENGTH (8192)

bool
InitializeMSXML3()
{
    static HMODULE hMsXml3 = NULL;
    ::ATL::CComPtr<IClassFactory> pFactory;
    HRESULT hr;
    typedef HRESULT (__stdcall * PFN_DLL_GET_CLASS_OBJECT)(REFCLSID, REFIID, LPVOID*);
    PFN_DLL_GET_CLASS_OBJECT pfnGetClassObject = NULL;

    if (hMsXml3 == NULL)
    {
        hMsXml3 = LoadLibraryA("msxml3.dll");
        if (hMsXml3 == NULL)
        {
            wcerr << "Unable to load msxml3, trying msxml2" << endl;
            hMsXml3 = LoadLibraryA("msxml2.dll");
            if (hMsXml3 == NULL)
            {
                wcerr << "Unable to load msxml2, trying msxml" << endl;
                hMsXml3 = LoadLibraryA("msxml.dll");
            }
        }
    }

    if (hMsXml3 == NULL) {
        wcerr << "Very Bad Things - no msxml exists on this machine?" << endl;
        return false;
    }

    pfnGetClassObject = (PFN_DLL_GET_CLASS_OBJECT)GetProcAddress(hMsXml3, "DllGetClassObject");
    if (!pfnGetClassObject)
    {
        return false;
    }

    hr = pfnGetClassObject(__uuidof(MSXML2::DOMDocument30), __uuidof(pFactory), (void**)&pFactory);
    if (FAILED(hr))
    {
        wcerr << "Can't load version 3.0, trying 2.6" << endl;

        hr = pfnGetClassObject(__uuidof(MSXML2::DOMDocument26), __uuidof(pFactory), (void**)&pFactory);
        if (FAILED(hr))
        {
            wcerr << "Can't load version 2.6, trying 1.0" << endl;

            // from msxml.h, not msxml2.h
//            hr = pfnGetClassObject(__uuidof(DOMDocument), __uuidof(pFactory), (void**)&pFactory);
            if (FAILED(hr))
            {
                wcerr << "Poked: no XML v1.0" << endl;
            }
        }
    }

    if (FAILED(hr))
    {
        return false;
    }

    g_XmlDomClassFactory = pFactory;

    return true;
}


HRESULT
ConstructXMLDOMObject(
    wstring       SourceName,
    ISXSManifestPtr &document
   )
{
    HRESULT hr = S_OK;
    VARIANT_BOOL vb;

    hr = g_XmlDomClassFactory->CreateInstance(NULL, __uuidof(document), (void**)&document);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // If they're willing to deal with bad XML, then so be it.
    //
    if (FAILED(hr = document->put_validateOnParse(VARIANT_FALSE)))
    {
        wstringstream ss;
        ss << wstring(L"MSXMLDOM Refuses to be let the wool be pulled over its eyes!");
        ReportError(ErrorSpew, ss);
    }

    hr = document->put_preserveWhiteSpace(VARIANT_TRUE);
    hr = document->put_resolveExternals(VARIANT_FALSE);

    CFileStreamBase *fsbase = new CFileStreamBase; // LEAK out of paranoia
    ::ATL::CComPtr<IStream> istream = fsbase;

    if (!fsbase->OpenForRead(SourceName))
    {
        wstringstream ss;
        ss << wstring(L"Failed opening ") << SourceName << wstring(L" for read.");
        ReportError(ErrorFatal, ss);

        return E_FAIL;
    }

    hr = document->load(_variant_t(istream), &vb);
    if (vb != VARIANT_TRUE)
    {
        ::ATL::CComPtr<IXMLDOMParseError> perror;
        hr = document->get_parseError(&perror);
        long ecode, filepos, linenumber, linepos;
        BSTR reason, src;

        perror->get_errorCode(&ecode);
        perror->get_filepos(&filepos);
        perror->get_line(&linenumber);
        perror->get_linepos(&linepos);
        perror->get_reason(&reason);
        perror->get_srcText(&src);

        wstringstream ss;
        ss << wstring(L"Error: ") << hex << ecode << dec << wstring(L" ") << (char*)_bstr_t(reason)
           << wstring(L" at position ") << filepos << wstring(L", line ") << linenumber << wstring(L" column ") 
           << linepos << endl
           << wstring(L" the text was: ") << endl << wstring(_bstr_t(src)) << endl;
        ReportError(ErrorFatal, ss);

        hr = E_FAIL;
    }

    fsbase->Close();

    return hr;
}

void dispUsage()
{
    const WCHAR HelpMessage[] =
        L"Modes of operation:\n"
        L"   -hashupdate         Update hashes of member files\n"
        L"   -makecdfs           Generate CDF files to make catalogs\n"
        L"   -verbose            Disply piles of debugging information\n"
        L"\n"
        L"Modifiers:\n"
        L"   -manifest <foo.man> The name of the manifest to work with\n"
        L"\n"
        L"Normal usage:"
        L"   mt.exe -hashupdate -makecdfs -manifest foo.man\n"
        L"\n";
        
    wcout << wstring(HelpMessage);

}


CParameters g_GlobalParameters;

int __cdecl wmain(int argc, WCHAR* argv[])
{
    using namespace std;
    HRESULT hr;

    switch(g_GlobalParameters.SetComandLine(argc, argv))
	{
    case CParameters::eCommandLine_normal:
        wcout << wstring(MicrosoftCopyrightLogo);
        break;
    case CParameters::eCommandLine_usage:
        wcout << wstring(MicrosoftCopyrightLogo);
        dispUsage();
        return -1;
    }


    //
    // Start COM
    //
    if (FAILED(hr = ::CoInitialize(NULL)))
    {
        wstringstream ss;

        ss << "Unable to start com, error " << hex << hr;
        ReportError(ErrorFatal, ss);
        return 1;
    }

    if (!InitializeMSXML3())
    {
        return 2;
    }

    
    if (g_GlobalParameters.m_fSingleItem)
    {
        PostbuildEntries.push_back(g_GlobalParameters.m_SinglePostbuildItem);
        goto StartProcessing;
    }

    //
    // Populate the processing list, but only if we're really in a Razzle
    // environment
    //
    if (g_GlobalParameters.m_fDuringRazzle)
    {
        //        wstring chName = convertWCharToAnsi(argv[1]);
        ifstream BinplaceLog;

        BinplaceLog.open(ConvertWString(g_GlobalParameters.m_BinplaceLog).c_str());
        if (!BinplaceLog.is_open()) {
            wcerr << wstring(L"Failed opening '") << g_GlobalParameters.m_BinplaceLog 
                    << wstring(L"' as the binplace log?") << endl
                    << wstring(L"Ensure that the path passed by '-binplacelog' is valid.") << endl;
            return 1;
        }

        while (!BinplaceLog.eof())
        {
            string sourceLine;
            wstring wSourceLine;
            CPostbuildProcessListEntry item;
            StringStringMap ValuePairs;

            getline(BinplaceLog, sourceLine);
            wSourceLine = ConvertString(sourceLine);

            ValuePairs = MapFromDefLine(wSourceLine);
            if (!ValuePairs.size())
                continue;

            item.name = ValuePairs[L"SXS_ASSEMBLY_NAME"];
            item.version = ValuePairs[L"SXS_ASSEMBLY_VERSION"];
            item.language = ValuePairs[L"SXS_ASSEMBLY_LANGUAGE"];
            item.setManifestLocation(g_GlobalParameters.m_AsmsRoot, ValuePairs[L"SXS_MANIFEST"]);

            if (item.getManifestFullPath().find(L"asms\\") == -1) {
                wstringstream ss;
                ss << wstring(L"Skipping manifested item ") << item << wstring(L" because it's not under asms.");
                ReportError(ErrorSpew, ss);
            } else {
                PostbuildEntries.push_back(item);
            }
        }

        std::sort(PostbuildEntries.begin(), PostbuildEntries.end());
        PostbuildEntries.resize(std::unique(PostbuildEntries.begin(), PostbuildEntries.end()) - PostbuildEntries.begin());
    }
    else if (!g_GlobalParameters.m_fSingleItem)
    {
        //
        // No -razzle and no -manifest?  Whoops...
        //
        dispUsage();
        return 1;
    }

StartProcessing:

    if (!g_GlobalParameters.m_fCreateCdfs && 
        !g_GlobalParameters.m_fUpdateHash && 
        (g_GlobalParameters.m_InjectDependencies.size() == 0) &&
        !g_GlobalParameters.m_fCreateNewAssembly)
    {
        wcout << wstring(L"Nothing to do!") << endl;
        dispUsage();
        return 1;
    }

    for (vector<CPostbuildProcessListEntry>::const_iterator cursor = PostbuildEntries.begin(); cursor != PostbuildEntries.end(); cursor++)
    {
#if defined(JAYKRELL_UPDATEDEPENDENTS_BUILD_FIX)
        //
        // If we were supposed to be making this into a new assembly, then do so.
        //
        if (g_GlobalParameters.m_fCreateNewAssembly)
            CreateNewManifest(*cursor, g_GlobalParameters.m_SingleEntry);
#endif

        //
        // First, mash the hashes around.
        //
        if (g_GlobalParameters.m_fUpdateHash)
            UpdateManifestHashes(*cursor);

		//
		// Then, inject dependencies
		//
		if (g_GlobalParameters.m_InjectDependencies.size() != 0)
		{
#if defined(JAYKRELL_UPDATEDEPENDENTS_BUILD_FIX)
			AddManifestDependencies(*cursor, g_GlobalParameters.m_InjectDependencies);
#endif
		}

        //
        // Second, generate catalogs
        //
        if (g_GlobalParameters.m_fCreateCdfs)
            GenerateCatalogContents(*cursor);
    }

    hr = S_OK;

    return (hr == S_OK) ? 0 : 1;
}


CPostbuildItemVector PostbuildEntries;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\buildtool\stdinc.h ===
#define __USE_MSXML2_NAMESPACE__
#include <utility>
#pragma warning(disable:4512) /* assignment operator could not be generated */
#pragma warning(disable:4511) /* copy constructor could not be generated */
#pragma warning(disable:4663) /* C++ language change */
#if defined(_WIN64)
#pragma warning(disable:4267) /* conversion, possible loss of data */
#pragma warning(disable:4244) /* conversion, possible loss of data */
#endif
#include "windows.h"
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <algorithm>
#include <sstream>
#include <map>
#include <stdio.h>
#include "comdef.h"
#include "comutil.h"
#include "wincrypt.h"
#include "msxml.h"
#include "msxml2.h"
#include "imagehlp.h"
#include "share.h"
#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))
using std::wcerr;
using std::wcout;
using std::dec;
using std::endl;
using std::find;
using std::getline;
using std::hex;
using std::pair;
using std::wstringstream;
using std::vector;
using std::wifstream;
using std::wofstream;
using std::wostream;
using std::wistream;
using std::wstring;
#include "atlbase.h"
#include "manglers.h"
#include "helpers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\cd_and_run_bigpath\cd_and_run.cpp ===
//
// Simple wrapper around SetCurrentDirectoryW and CreateProcessW that allows \\? form.
//

#define DO_SET_CURRENT_DIRECTORY 1
#define DO_PASS_CURRENT_DIRECTORY_TO_CREATEPROCESS 0
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include "yvals.h"
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#pragma warning(disable: 4389) /* signed/unsigned mismatch */
#pragma warning(disable: 4018) /* signed/unsigned mismatch */
#pragma warning(disable: 4663)
#include <vector>
#include <string.h>
#include <stdarg.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define FusionpGetLastWin32Error GetLastError
#define FusionpSetLastWin32Error SetLastError
#include <string.h>
#include <stdarg.h>
BOOL FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);
BOOL FusionpSkipBigPathRoot(PCWSTR s, OUT SIZE_T*);
BOOL FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }
extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
BOOL FusionpInitializeHeap(HINSTANCE hInstance);
VOID FusionpUninitializeHeap();
};

void ExeEntry()
{
    if (!::FusionpInitializeHeap(GetModuleHandleW(NULL)))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    FusionpUninitializeHeap();
}

FILE* g_pLogFile;
const static WCHAR g_pszImage[] = L"cd_and_run_bigpath";

void
ReportFailure(
    const char* szFormat,
    ...
    )
{
    const DWORD dwLastError = ::FusionpGetLastWin32Error();
    va_list ap;
    char rgchBuffer[4096];
    WCHAR rgchWin32Error[4096];

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, sizeof(rgchBuffer) / sizeof(rgchBuffer[0]), szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::FusionpGetLastWin32Error();
        _snwprintf(rgchWin32Error, sizeof(rgchWin32Error) / sizeof(rgchWin32Error[0]), L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
        fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

void MyCloseHandle(HANDLE * ph)
{
    HANDLE h = *ph;
    *ph = NULL;
    if (h != NULL && h != INVALID_HANDLE_VALUE)
    {
        DWORD dw = GetLastError();
        CloseHandle(h);
        SetLastError(dw);
    }
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;
    std::vector<WCHAR> arg1;
    std::vector<WCHAR> commandLine;
    std::vector<SIZE_T> argvLengths;
    SIZE_T commandLineLength = 0;
    SIZE_T i = 0;
    STARTUPINFOW StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    DWORD dwWait = 0;
    DWORD dwExitCode = 0;

    ZeroMemory(&StartupInfo, sizeof(StartupInfo));
    ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));

    if (argc < 3)
    {
        fprintf(stderr,
            "%ls: Usage:\n"
            "   %ls <directory-to-cd-to> <commandline-to-run>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    arg1.resize((1UL << 15) + 1);

    arg1[0] = 0;
    if (!FusionpConvertToBigPath(argv[1], arg1.size(), &arg1[0]))
        goto Exit;

    if (!FusionpSkipBigPathRoot(&arg1[0], &i))
        goto Exit;
#if DO_SET_CURRENT_DIRECTORY
    if (!SetCurrentDirectoryW(&arg1[0]))
    {
        ::ReportFailure("SetCurrentDirectoryW\n");
        goto Exit;
    }
#endif
    argvLengths.resize(1 + argc);
    for ( i = 2 ; i != argc ; ++i)
    {
        if (argv[i] == NULL)
            continue;
        argvLengths[i] = wcslen(argv[i]);
        commandLineLength += 1 + argvLengths[i];
    }
    commandLine.reserve(1 + commandLineLength);
    for ( i = 2 ; i != argc ; ++i)
    {
        if (argv[i] == NULL)
            continue;
        commandLine.insert(commandLine.end(), argv[i], argv[i] + argvLengths[i]);
        commandLine.push_back(' ');
    }
    commandLine.push_back(0);
    StartupInfo.cb = sizeof(StartupInfo);
    if (!CreateProcessW(
            NULL,
            &commandLine[0],
            NULL, // IN LPSECURITY_ATTRIBUTES lpProcessAttributes
            NULL, // IN LPSECURITY_ATTRIBUTES lpThreadAttributes
            FALSE, // IN BOOL bInheritHandles
            0, // IN DWORD dwCreationFlags
            NULL, // IN LPVOID lpEnvironment
#if DO_PASS_CURRENT_DIRECTORY_TO_CREATEPROCESS
            &arg1[0], // IN LPCSTR lpCurrentDirectory
#else
            NULL, // IN LPCSTR lpCurrentDirectory
#endif
            &StartupInfo,
            &ProcessInfo
            ))
    {
        ::ReportFailure("CreateProcessW\n");
        goto Exit;
    }
    CloseHandle(ProcessInfo.hThread);
    ProcessInfo.hThread = NULL;
    dwWait = WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
    if (dwWait != WAIT_OBJECT_0)
    {
        if (dwWait != WAIT_FAILED)
        {
            SetLastError(dwWait);
        }
        ::ReportFailure("WaitForSingleObject\n");
        goto Exit;
    }
    if (!GetExitCodeProcess(ProcessInfo.hProcess, &dwExitCode))
    {
        ::ReportFailure("GetExitCodeProcess\n");
        goto Exit;
    }
    CloseHandle(ProcessInfo.hProcess);
    ProcessInfo.hProcess = NULL;
    printf("Process %ld exited with status %ld\n", (long)ProcessInfo.dwProcessId, (long)dwExitCode);

//Success:
    iReturnStatus = EXIT_SUCCESS;
Exit:
    MyCloseHandle(&ProcessInfo.hProcess);
    MyCloseHandle(&ProcessInfo.hThread);
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\catinfo\catinfo.cpp ===
#include "windows.h"
#include "wincrypt.h"
#include "mscat.h"
#include <stdio.h>
#include <stdlib.h>
#include <vector>

VOID
DumpBytes(PBYTE pbBuffer, DWORD dwLength)
{
    for (DWORD dw = 0; dw < dwLength; dw++)
    {
        if ((dw % 4 == 0) && (dw != 0))
            ::wprintf(L" ");
        if ((dw % 32 == 0) && (dw != 0))
            ::wprintf(L"\n");
        ::wprintf(L"%02x", pbBuffer[dw]);
    }
}


#pragma pack(1)
typedef struct _PublicKeyBlob
{
    unsigned int SigAlgID;
    unsigned int HashAlgID;
    ULONG cbPublicKey;
    BYTE PublicKey[1];
} PublicKeyBlob, *PPublicKeyBlob;

VOID
GenerateFusionStrongNameAndKeyFromCertificate(PCCERT_CONTEXT pContext)
{
    HCRYPTPROV      hProvider = NULL;
    HCRYPTKEY       hKey = NULL;
    std::vector<BYTE> pbBlobData;
    DWORD           cbBlobData = 8192;
    pbBlobData.resize(cbBlobData);
    DWORD           cbFusionKeyBlob = 0;
    DWORD           dwTemp = 0;
    PPublicKeyBlob  pFusionKeyStruct = NULL;

    if (!::CryptAcquireContextW(
            &hProvider,
            NULL,
            NULL,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT))
    {
        // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
        //          will format the win32 last error.
        ::wprintf(L"Failed opening the crypt context: 0x%08x", ::GetLastError());
        return;
    }

    //
    // Load the public key info into a key to start with
    //
    if (!::CryptImportPublicKeyInfo(
        hProvider,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        &pContext->pCertInfo->SubjectPublicKeyInfo,
        &hKey))
    {
        // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
        //          will format the win32 last error.
        ::wprintf(L"Failed importing public key info from the cert-context, 0x%08x", ::GetLastError());
        return;
    }

    //
    // Export the key info to a public-key blob
    //
    if (!::CryptExportKey(
            hKey,
            NULL,
            PUBLICKEYBLOB,
            0,
            &pbBlobData[0],
            &cbBlobData))
    {
        // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
        //          will format the win32 last error.
        ::wprintf(L"Failed exporting public key info back from an hcryptkey: 0x%08x\n", ::GetLastError());
        return;
    }

    //
    // Allocate the Fusion public key blob
    //
    // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - use of -1 here obscure; use offsetof instead
    cbFusionKeyBlob = sizeof(PublicKeyBlob) + cbBlobData - 1;
    pFusionKeyStruct = (PPublicKeyBlob)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbFusionKeyBlob);
    // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - missing allocation failure check

    //
    // Key parameter for the signing algorithm
    //
    dwTemp = sizeof(pFusionKeyStruct->SigAlgID);
    // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - missing return status check; missing
    //      verification of dwTemp
    ::CryptGetKeyParam(hKey, KP_ALGID, (PBYTE)&pFusionKeyStruct->SigAlgID, &dwTemp, 0);

    //
    // Move over the public key bits from CryptExportKey
    //
    pFusionKeyStruct->cbPublicKey = cbBlobData;
    pFusionKeyStruct->HashAlgID = CALG_SHA1;
    ::memcpy(pFusionKeyStruct->PublicKey, &pbBlobData[0], cbBlobData);

    ::wprintf(L"\n  Public key structure:\n");
    ::DumpBytes((PBYTE)pFusionKeyStruct, cbFusionKeyBlob);

    //
    // Now let's go hash it.
    //
    {
        HCRYPTHASH  hKeyHash = NULL;
        DWORD       cbHashedKeyInfo = 8192;
        std::vector<BYTE> bHashedKeyInfo;
        bHashedKeyInfo.resize(cbHashedKeyInfo);

        if (!::CryptCreateHash(hProvider, pFusionKeyStruct->HashAlgID, NULL, 0, &hKeyHash))
        {
            // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
            //          will format the win32 last error.
            ::wprintf(L"Failed creating a hash for this key: 0x%08x\n", ::GetLastError());
            return;
        }

        if (!::CryptHashData(hKeyHash, (PBYTE)pFusionKeyStruct, cbFusionKeyBlob, 0))
        {
            // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
            //          will format the win32 last error.
            ::wprintf(L"Failed hashing data: 0x%08x\n", ::GetLastError());
            return;
        }

        if (!::CryptGetHashParam(hKeyHash, HP_HASHVAL, &bHashedKeyInfo[0], &cbHashedKeyInfo, 0))
        {
            // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
            //          will format the win32 last error.
            ::wprintf(L"Can't get hashed key info 0x%08x\n", ::GetLastError());
            return;
        }

        ::CryptDestroyHash(hKeyHash);
        hKeyHash = NULL;

        ::wprintf(L"\n  Hash of public key bits:       ");
        ::DumpBytes(&bHashedKeyInfo[0], cbHashedKeyInfo);
        ::wprintf(L"\n  Fusion-compatible strong name: ");
        ::DumpBytes(&bHashedKeyInfo[0] + (cbHashedKeyInfo - 8), 8);
    }
}



// NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - this function should be static
VOID
PrintKeyContextInfo(PCCERT_CONTEXT pContext)
{
    DWORD cbHash = 0;
    std::vector<BYTE> bHash;
    const SIZE_T sizeof_bHash = 8192;
    bHash.resize(sizeof_bHash);

    DWORD cchBuffer = 8192;
    std::vector<WCHAR> wszBuffer;
    wszBuffer.resize(cchBuffer);

    ::wprintf(L"\n\n");

    // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - missing error check
    ::CertGetNameStringW(pContext, CERT_NAME_FRIENDLY_DISPLAY_TYPE,
        0, NULL, &wszBuffer[0], cchBuffer);

    ::wprintf(L"Certificate owner: %ls\n", &wszBuffer[0]);

    //
    // Spit out the key bits
    //
    ::wprintf(L"Found key info:\n");
    ::DumpBytes(
        pContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
        pContext->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

    //
    // And now the "strong name" (ie: sha1 hash) of the public key bits
    //
    if (::CryptHashPublicKeyInfo(
                NULL,
                CALG_SHA1,
                0,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &pContext->pCertInfo->SubjectPublicKeyInfo,
                &bHash[0],
                &(cbHash = sizeof_bHash)))
    {
        ::wprintf(L"\nPublic key hash: ");
        ::DumpBytes(&bHash[0], cbHash);
        ::wprintf(L"\nStrong name is:  ");
        ::DumpBytes(&bHash[0], cbHash < 8 ? cbHash : 8);
    }
    else
    {
        // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
        //          will format the win32 last error.
        ::wprintf(L"Unable to hash public key info: 0x%08x\n", ::GetLastError());
    }

    ::GenerateFusionStrongNameAndKeyFromCertificate(pContext);

    ::wprintf(L"\n\n");
}

int __cdecl wmain(int argc, WCHAR* argv[])
{
    HANDLE              hCatalog = NULL;
    HANDLE              hMapping = NULL;
    PBYTE               pByte = NULL;
    SIZE_T              cBytes = 0;
    PCCTL_CONTEXT       pContext = NULL;

    hCatalog = ::CreateFileW(argv[1], GENERIC_READ,
        FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hCatalog == INVALID_HANDLE_VALUE)
    {
        // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
        //          will format the win32 last error.
        ::wprintf(L"Ensure that %ls exists.\n", argv[1]);
        return 0;
    }

    hMapping = ::CreateFileMappingW(hCatalog, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!hMapping || (hMapping == INVALID_HANDLE_VALUE))
    {
        ::CloseHandle(hCatalog);
        // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
        //          will format the win32 last error.  Don't forget that calling CloseHandle
        //          may have overwritten the last error
        ::wprintf(L"Unable to map file into address space.\n");
        return 1;
    }

    pByte = (PBYTE) ::MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
    ::CloseHandle(hMapping);
    hMapping = INVALID_HANDLE_VALUE;

    if (pByte == NULL)
    {
        // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - MapViewOfFile failure cause not reported;
        //      don't forget that above call to CloseHandle may have lost the last error
        ::wprintf(L"Unable to open view of file.\n");
        ::CloseHandle(hCatalog);
        return 2;
    }

    // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - GetFileSize error cause not reported
    if (((cBytes = ::GetFileSize(hCatalog, NULL)) == -1) || (cBytes < 1))
    {
        ::wprintf(L"Bad file size %d\n", cBytes);
        return 3;
    }

    if (pByte[0] != 0x30)
    {
        ::wprintf(L"File is not a catalog.\n");
        return 4;
    }

    pContext = (PCCTL_CONTEXT) ::CertCreateCTLContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pByte,
        (DWORD)cBytes);

    if (pContext != NULL)
    {
        BYTE    bIdent[8192];
        DWORD   cbIdent = 0;
        PCERT_ID  cIdent = NULL;

        if (!::CryptMsgGetParam(
            pContext->hCryptMsg,
            CMSG_SIGNER_CERT_ID_PARAM,
            0,
            bIdent,
            &(cbIdent = sizeof(bIdent))))
        {
            // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
            //          will format the win32 last error.
            ::wprintf(L"Unable to get top-level signer's certificate ID: 0x%08x\n", ::GetLastError());
            return 6;
        }


        cIdent = (PCERT_ID)bIdent;
        HCERTSTORE hStore = NULL;

        //
        // Maybe it's there in the message?
        //
        {
            PCCERT_CONTEXT pThisContext = NULL;

            hStore = ::CertOpenStore(
                CERT_STORE_PROV_MSG,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                NULL,
                0,
                pContext->hCryptMsg);

            // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - What does hStore == NULL indicate?
            //          There seems to be a lack of error path handling here.
            if ((hStore != NULL) && (hStore != INVALID_HANDLE_VALUE))
            {
                while (pThisContext = ::CertEnumCertificatesInStore(hStore, pThisContext))
                {
                    ::PrintKeyContextInfo(pThisContext);
                }

                // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - CertEnumCertificatesInStore could
                //      fail for reasons other than end-of-list.
            }
        }

    }
    else
    {
        // NTRAID#NTBUG9 - 590964 - 2002/03/30 - mgrier - Use common error reporting function that
        //          will format the win32 last error.
        ::wprintf(L"Failed creating certificate context: 0x%08x\n", ::GetLastError());
        return 5;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\clean\clean.cpp ===
/*
This program cleans build.exe trees.
*/
#ifndef BUILD_STABILIZE_EXPORTS
#include "windows.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// error messages
const static wchar_t errorNT[] = L"This program requires Windows NT.\n";

#define NumberOf(x) (sizeof(x)/sizeof((x)[0]))

void Log(const char* s, const wchar_t* q)
{
	printf(s, q);
}

void Log(const wchar_t* s)
{
	printf("%ls\n", s);
}

void Fail(const wchar_t* s)
{
	Log(s);
	exit(EXIT_FAILURE);
}

void LogRecurse(const wchar_t* s)
{
	printf("Recurse %ls\n", s);
}

void LogDelete(const wchar_t* s)
{
	printf("Delete %ls\n", s);
}

bool IsDotOrDotDot(const wchar_t* s)
{
	return
		(
			s[0] == '.' &&
			(
					(s[1] == 0)
				||	(s[1] == '.' && s[2] == 0)
			)
		);
}
#endif /* BUILD_STABILIZE_EXPORTS */

#ifdef BUILD_STABILIZE_EXPORTS

#define LogRecurse(x) /* nothing */
#define LogDelete(x) /* nothing */
#define wchar_t char
#define WIN32_FIND_DATAW WIN32_FIND_DATAA
#define FindFirstFileW FindFirstFileA
#define wcscpy strcpy
#define DeleteFileW DeleteFileA
#define RemoveDirectoryW RemoveDirectoryA
#define wcslen strlen
#define FindNextFileW FindNextFileA

#endif /* BUILD_STABILIZE_EXPORTS */

void DeleteDirectory(wchar_t* directory, int length, WIN32_FIND_DATAW* wfd)
{
	directory[length] = 0;
	LogRecurse(directory);

	directory[length] = '\\';
	directory[length+1] = '*';
	directory[length+2] = 0;
	HANDLE hFind = FindFirstFileW(directory, wfd);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		__try
		{
			do
			{
				if (IsDotOrDotDot(wfd->cFileName))
				{
					continue;
				}
				DWORD dwFileAttributes = wfd->dwFileAttributes;
				directory[length] = '\\';
				wcscpy(directory + length + 1, wfd->cFileName);
				if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					DeleteDirectory(directory, length + 1 + wcslen(wfd->cFileName), wfd);
				}
				else
				{
					if (dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY))
					{
						//if (!SetFileAttributesW(directory, dwFileAttributes & ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)))
						{
							// ...
						}

					}
					if (DeleteFileW(directory))
					{
						LogDelete(directory);
					}
					else
					{
						// ...
					}
				}
			} while (FindNextFileW(hFind, wfd));
		}
		__finally
		{
			FindClose(hFind);
		}
	}
	directory[length] = 0;
	RemoveDirectoryW(directory);
	LogDelete(directory);
}

#ifndef BUILD_STABILIZE_EXPORTS

void CleanDirectory(
	const wchar_t* obj,
	wchar_t* directory,
	int length,
	WIN32_FIND_DATAW* wfd
	)
{
	directory[length] = 0;
	LogRecurse(directory);

	// clean build[d,fre,chk].[log,wrn,err] builds
	const static wchar_t dfrechk[][4] = { L"", L"d", L"fre", L"chk" };
	const static wchar_t logwrnerr[][4] = { L"log", L"wrn", L"err" };
	for (int b = 0 ; b < NUMBER_OF(dfrechk); b++)
	{
		for (int g = 0 ; g < NUMBER_OF(logwrnerr) ; ++g)
		{
			swprintf(directory + length, L"\\build%s.%s", dfrechk[b], logwrnerr[g]);
			if (DeleteFileW(directory))
			{
				LogDelete(directory);
			}
			else
			{
				// ...
			}
		}
	}
	// Dangerous to clean files out of source directory, but:
	// FUTURE clean *.plg (VC Project Log?) files
	// FUTURE clean *.rsp files that sometimes appear in source dir?
	// FUTURE clean MSG*.bin files that sometimes appear in source dir?
	// FUTURE clean RC* files that sometimes appear in source dir?

	directory[length] = '\\';
	wcscpy(directory + length + 1, obj);
	HANDLE hFind = FindFirstFileW(directory, wfd);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		__try
		{
			do
			{
				directory[length] = '\\';
				wcscpy(directory + length + 1, wfd->cFileName);
				DeleteDirectory(directory, length + 1 + wcslen(wfd->cFileName), wfd);
			}
			while (FindNextFileW(hFind, wfd));
		}
		__finally
		{
			FindClose(hFind);
		}
	}

	directory[length] = '\\';
	directory[length+1] = '*';
	directory[length+2] = 0;

	hFind = FindFirstFileW(directory, wfd);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		__try
		{
			do
			{
				if (IsDotOrDotDot(wfd->cFileName))
				{
					continue;
				}
				if (!(wfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					continue;
				}
				directory[length] = '\\';
				wcscpy(directory + length + 1, wfd->cFileName);
				CleanDirectory(obj, directory, length + 1 + wcslen(wfd->cFileName), wfd);
			} while (FindNextFileW(hFind, wfd));
		}
		__finally
		{
			FindClose(hFind);
		}
	}
	directory[length] = 0;
}

#define Lx(x) L ## x
#define  L(x)  Lx(x)

int Clean(
	int argc,
	wchar_t** argv
	)
{
	Log(L"Clean version " L(__TIME__) L" " L(__DATE__));

// are we running on NT?
	long version = GetVersion();
	int  build = ((version >> 16) & 0x7fff);
	int  majorVersion = (version & 0xff);
	bool nt = !(version & 0x80000000);
	if (!nt)
	{
		Fail(errorNT);
	}

// These two buffers are shared by the whole call tree. Be careful.
	WIN32_FIND_DATAW wfd;
	wchar_t currentDirectory[1U << 15];

	if (argc != 2)
	{
		Log(
			"Usage: %ls [delete string].\n"
			" Typical deletion strings are obj, objd, and obj?.\n"
			" This will recursively delete directories matching\n"
			" the deletion string. It will also delete\n"
			" all files named build[d,fre,chk].[log,wrn,err].\n",
			argv[0] ? argv[0] : L"xxx.exe"
			);
		return EXIT_FAILURE;
	}
// I prefer GetCurrentDirectory, but other programs just print '.'
//	if (!GetCurrentDirectoryW(NUMBER_OF(currentDirectory), currentDirectory))
//	{
//		Fail();
//	}
	currentDirectory[0] = '.';
	currentDirectory[1] = 0;
	CleanDirectory(argv[1], currentDirectory, wcslen(currentDirectory), &wfd);

	return EXIT_SUCCESS;
}

int __cdecl wmain(
	int argc,
	wchar_t** argv
	)
{
	return Clean(argc, argv);
}

#endif /* BUILD_STABILIZE_EXPORTS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\copy_bigpath\copy.cpp ===
//
// Simple wrapper around GetFullPathname and CopyFile that converts to \\? form,
// and also appends leaf file to directory name if necessary.
//
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#include "yvals.h"
#pragma warning(disable: 4663)
#pragma warning(pop)
#pragma warning(disable: 4018) /* signed/unsigned mismatch */
#pragma warning(disable: 4290) /* exception specification */
#include <vector>
#include <string.h>
#include <stdarg.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define FusionpGetLastWin32Error GetLastError
#define FusionpSetLastWin32Error SetLastError
#include <string.h>
#include <stdarg.h>
BOOL
FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);
BOOL
FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }
extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
BOOL FusionpInitializeHeap(HINSTANCE hInstance);
VOID FusionpUninitializeHeap();
};

void ExeEntry()
{
    if (!::FusionpInitializeHeap(GetModuleHandleW(NULL)))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    FusionpUninitializeHeap();
}

FILE* g_pLogFile;
const static WCHAR g_pszImage[] = L"copy_bigpath";

void
ReportFailure(
    const char* szFormat,
    ...
    )
{
    const DWORD dwLastError = ::GetLastError();
    va_list ap;
    char rgchBuffer[4096] = { 0 };
    WCHAR rgchWin32Error[4096] = { 0 };

    va_start(ap, szFormat);
    ::_vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer) - 1, szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error) - 1,
            &ap))
    {
        const DWORD dwLastError2 = ::GetLastError();
        ::_snwprintf(rgchWin32Error, NUMBER_OF(rgchWin32Error) - 1, L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    ::fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
        ::fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}


extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;
    PWSTR p = NULL;
    std::vector<WCHAR> arg1;
    std::vector<WCHAR> arg2;
    BOOL Success = FALSE;
    PCWSTR Leaf = NULL;
    ULONG FileAttributes = 0;
    DWORD Error = 0;

    if (argc != 3)
    {
        ::fprintf(stderr,
            "%ls: Usage:\n"
            "   %ls <from> <to>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    arg1.resize(1UL << 15);
    arg2.resize(1UL << 15);
    arg1[0] = 0;
    arg2[0] = 0;
    if (!FusionpConvertToBigPath(argv[1], arg1.size(), &arg1[0]))
        goto Exit;
    if (!FusionpConvertToBigPath(argv[2], arg2.size(), &arg2[0]))
        goto Exit;
    arg1.resize(1 + ::wcslen(&arg1[0]));
    arg2.resize(1 + ::wcslen(&arg2[0]));
    Error = NO_ERROR;
    Success = CopyFileW(&arg1[0], &arg2[0], FALSE);
    if (!Success
        && ((Error = ::FusionpGetLastWin32Error()) == ERROR_ACCESS_DENIED
            || Error == ERROR_PATH_NOT_FOUND)
        && (FileAttributes = GetFileAttributesW(&arg1[0])) != 0xffffffff
        && (FileAttributes = GetFileAttributesW(&arg2[0])) != 0xffffffff
        && (FileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0
        && (Leaf = wcsrchr(&arg1[0], '\\')) != NULL
        )
    {
        arg2.insert(arg2.end() - 1, Leaf, arg1.end() - 1);
        Success = CopyFileW(&arg1[0], &arg2[0], FALSE);
    }
    if (!Success && Error != NO_ERROR)
    {
        ::FusionpSetLastWin32Error(Error);
    }
    if (!Success)
    {
        ::ReportFailure("CopyFile\n");
        goto Exit;
    }
    ::printf("%ls -> %ls\n", &arg1[0], &arg2[0]);

    iReturnStatus = EXIT_SUCCESS;
Exit:
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\columns\columns.cpp ===
/*
This program reads in a file (or multiple files) of lines with whitespace seperate columns.
After reading the whole file, it outputs the content formatted such that each field is padded
on the right..err, left actually, with spaces to be the width of the longest value of that colume.

There are two modes of operation.
 multiple files in place
 multiple files all written to one file (possibly among those read in)
 one file to itself falls out of either


columns -inplace foo bar abc
  read each of foo bar abc and write each on top of itself

columns -concat foo bar abc
  read foo and bar and write out abc

columns -concat foo bar abc abc
  read foo, bar, and abc and write out abc

columns - -
    read stdin, write stdout

columns
    read stdin, write stdout

All data must fit in memory.
*/
#define NOMINMAX
#include "yvals.h"
#undef _MAX
#undef _MIN
#define _cpp_min    min
#define _cpp_max    max
#define _MIN	    min
#define _MAX	    max
#define min         min
#define max         max
#pragma warning(disable:4100)
#pragma warning(disable:4663)
#pragma warning(disable:4511)
#pragma warning(disable:4512)
#pragma warning(disable:4127)
#pragma warning(disable:4018)
#pragma warning(disable:4389)
#pragma warning(disable:4702)
#include <vector>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <string>
#include <string.h>
#include "windows.h"
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))

//
// get msvcrt.dll wildcard processing on the command line
//
extern "C" { int _dowildcard = 1; }

class String_t : public std::string
{
    typedef std::string Base;
public:
    String_t(const std::string & s) : Base(s) { }
    String_t() { }
    ~String_t() { }
    String_t(const String_t & s) : Base(s) { }
    String_t(const char * s) : Base(s) { }
    String_t(const_iterator i, const_iterator j) : Base(i, j) { }

    bool operator<( const String_t & s) const
    {
        return _stricmp(c_str(), s.c_str()) < 0;
    }

    bool operator==( const String_t & s) const
    {
        return _stricmp(c_str(), s.c_str()) == 0;
    }

    operator const char * () const { return c_str(); }
};

void Error(const char * s) { fprintf(stderr, "%s\n", s); exit(EXIT_FAILURE); }

class Filename_t : public String_t
{
private:
    typedef String_t Base_t;
public:

    Filename_t(const char * x)  : Base_t(x), m_IsStdin(false), m_IsStdout(false) { }
    Filename_t(const Base_t& x) : Base_t(x), m_IsStdin(false), m_IsStdout(false) { }
    Filename_t()                : m_IsStdin(false), m_IsStdout(false) { }

    ~Filename_t() { }

    static Filename_t Stdin()   { Filename_t fn; fn.m_IsStdin  = true; return fn; }
    static Filename_t Stdout()  { Filename_t fn; fn.m_IsStdout = true; return fn; }

    bool m_IsStdin;
    bool m_IsStdout;

    void Open(std::fstream & File, std::ios_base::open_mode Flags)
    {
        switch ((m_IsStdin ? 1 : 0) | (m_IsStdout ? 2 : 0))
        {
        case 0:
            File.open(*this, Flags);
            break;
        case 1:
            static_cast<std::basic_ios<char>&>(File).rdbuf(std::cin.rdbuf());
            break;
        case 2:
            static_cast<std::basic_ios<char>&>(File).rdbuf(std::cout.rdbuf());
            break;
        case 3:
            Error("stdin and stdout");
            break;
        }
    }
};

template <typename Iterator>
Iterator FindFirstNotOf(Iterator first1, Iterator last1, Iterator first2, Iterator last2)
{
    if (first2 == last2)
        return last1;
    for ( ; first1 != last1 ; ++first1)
    {
        if (std::find(first2, last2, *first1) == last2)
        {
            break;
        }
    }
    return first1;
}

template <typename Iterator>
Iterator FindFirstOf(Iterator first1, Iterator last1, Iterator first2, Iterator last2)
{
    return std::find_first_of(first1, last1, first2, last2);
}

void SplitString(const String_t& String, const String_t& Delim, std::vector<String_t>& Fields)
{
    String_t::const_iterator FieldBegin;
    String_t::const_iterator FieldEnd = String.begin();

    while ((FieldBegin = FindFirstNotOf(FieldEnd, String.end(), Delim.begin(), Delim.end())) != String.end())
    {
        FieldEnd = FindFirstOf(FieldBegin, String.end(), Delim.begin(), Delim.end());
        Fields.push_back(String_t(FieldBegin, FieldEnd));
    }
}

const String_t HorizontalWhitespace(" \t");

class Row_t : public std::vector<String_t>
{
public:
    static void FromLine(Row_t & This, const String_t &);
};

class Columns_t
{
public:
    void Main(unsigned Argc, char ** Argv);

    Columns_t() : m_StdinSeen(false), m_StdoutSeen(false), m_Inplace(false), m_Concat(false) { }
    ~Columns_t() { }

    void Error(const char * s) { fprintf(stderr, "%s\n", s); exit(EXIT_FAILURE); }

    void Usage() { }

    bool            m_StdinSeen;
    bool            m_StdoutSeen;
    bool            m_Inplace;
    bool            m_Concat;
    std::vector<size_t> m_ColumWidths;
    std::vector<Row_t>   m_Rows;
    std::vector<Filename_t> m_Filenames;
};

void PrintSpaces(std::ostream & Stream, size_t i)
{
    const static char Spaces[] = "            ";
    for ( ; i >= NUMBER_OF(Spaces) ; i -= NUMBER_OF(Spaces) - 1 )
        Stream << Spaces;
    Stream << (Spaces + NUMBER_OF(Spaces) - 1 - i);
}

void Columns_t::Main(unsigned Argc, char ** Argv)
{
    unsigned Arg = 0;
    if (Argc == 0)
    {
        m_Filenames.push_back(Filename_t::Stdin());
        m_StdinSeen = true;
        m_Filenames.push_back(Filename_t::Stdout());
        m_StdoutSeen = true;
        m_Concat = true;
    }
    else
    {
        if (_stricmp(Argv[Arg], "-inplace") == 0)
        {
            ++Arg;
            m_Inplace = true;
        }
        else if (_stricmp(Argv[Arg], "-concat") == 0)
        {
            ++Arg;
            m_Concat = true;
        }
        for ( ; Arg < Argc ; Arg++)
        {
            if (_stricmp(Argv[Arg], "-") == 0)
            {
                if (m_StdinSeen)
                {
                    if (m_StdoutSeen)
                    {
                        return Error("can't specify - more than twice");
                    }
                    if (Arg != (Argc - 1))
                    {
                        return Error("stdout must be last parameter");
                    }
                    m_StdoutSeen = true;
                    m_Filenames.push_back(Filename_t::Stdout());
                }
                else
                {
                    m_StdinSeen = true;
                    m_Filenames.push_back(Filename_t::Stdin());
                }
            }
            else if (
                   _stricmp(Argv[Arg], "-?") == 0
                || _stricmp(Argv[Arg], "/?") == 0
                || _stricmp(Argv[Arg], "-h") == 0
                || _stricmp(Argv[Arg], "/h") == 0
                || _stricmp(Argv[Arg], "-help") == 0
                || _stricmp(Argv[Arg], "/help") == 0
                )
            {
                return Usage();
            }
            else
            {
                m_Filenames.push_back(Argv[Arg]);
            }
        }
    }
    if (Argc == 2 && m_StdinSeen && m_StdoutSeen && !m_Inplace && !m_Concat)
    {
        m_Inplace = true;
    }
    if (m_StdinSeen && m_Inplace)
    {
        return Error("can't mix stdin and inplace");
    }
    if (!m_Inplace && !m_Concat)
    {
        return Error("must specify -inplace or -concat");
    }
    for (unsigned Filename = 0 ; Filename < m_Filenames.size() ; ++Filename)
    {
        if (Filename < m_Filenames.size() - (m_Concat ? 1 : 0))
        {
            std::fstream File;
            m_Filenames[Filename].Open(File, File.in);

            String_t Line;
            while (std::getline(File, Line))
            {
                Row_t Row;
                SplitString(Line, HorizontalWhitespace, Row);
                m_Rows.push_back(Row);
                m_ColumWidths.resize(std::max(m_ColumWidths.size(), Row.size()), 0);
                for (unsigned j = 0 ; j != Row.size() ; ++j)
                {
                    size_t k = std::max(m_ColumWidths[j], Row[j].size());
                    m_ColumWidths[j] = k;
                }
            }
        }
        if (m_Inplace || (m_Concat && Filename == m_Filenames.size() - 1))
        {
            if (!m_Filenames[Filename].m_IsStdin && !m_Filenames[Filename].m_IsStdout)
            {
                remove(m_Filenames[Filename]);
            }
            std::fstream File;
            m_Filenames[Filename].Open(File, File.out);
            File.fill(' ');
            for (unsigned RowIndex = 0 ; RowIndex != m_Rows.size() ; ++RowIndex)
            {
                const Row_t & Row = m_Rows[RowIndex];
                for (unsigned Column = 0 ; Column != Row.size() ; ++Column)
                {
                    File << Row[Column];
                    PrintSpaces(File, m_ColumWidths[Column] + 1 - Row[Column].size());
                }
                File << "\n";
            }
            if (m_Inplace)
            {
                m_Rows.clear();
                m_ColumWidths.clear();
            }
        }
    }
}

int __cdecl main(int argc, char ** argv)
{
    Columns_t c;
    c.Main(static_cast<unsigned>(argc - (argc != 0)) , argv + 1);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\certinfo\certinfo.cpp ===
#include "windows.h"
#include "stdio.h"
#include "wchar.h"
#include "wincrypt.h"
#include "stddef.h"

#ifndef NUMBER_OF
#define NUMBER_OF(x) (sizeof(x)/sizeof(*(x)))
#endif

static const WCHAR wchMicrosoftLogo[] = 
    L"Microsoft (R) Side-By-Side Public Key Token Extractor 1.1.3.0\n"
    L"Copyright (C) Microsoft Corporation 2000-2002. All Rights Reserved\n\n";


#define STRONG_NAME_BYTE_LENGTH ( 8 )

typedef struct _SXS_PUBLIC_KEY_INFO
{
    unsigned int SigAlgID;
    unsigned int HashAlgID;
    ULONG KeyLength;
    BYTE pbKeyInfo[1];
} SXS_PUBLIC_KEY_INFO, *PSXS_PUBLIC_KEY_INFO;


#define BUFFER_SIZE ( 8192 )

BOOL
ParseArgs( WCHAR **argv, int argc, PCWSTR* ppcwszFilename, BOOL *fQuiet )
{
    if ( fQuiet )
        *fQuiet = FALSE;
    if ( ppcwszFilename )
        *ppcwszFilename = NULL;

    if (argv == NULL)
        return FALSE;

    if ( !fQuiet || !ppcwszFilename )
    {
        return FALSE;
    }

    for ( int i = 1; i < argc; i++ )
    {
        if (argv[i] == NULL)
        {
            ::fwprintf(stderr, L"Bad parameter in argument list\n");
            return FALSE;
        }
    
        if ( ( argv[i][0] == L'-' ) || ( argv[i][0] == L'/' ) )
        {
            PCWSTR pval = argv[i] + 1;
            if (::_wcsicmp(pval, L"nologo") == 0)
            {
            }
            else if (::_wcsicmp(pval, L"quiet") == 0)
            {
                if ( fQuiet ) *fQuiet = TRUE;
            }
            else if (::_wcsicmp(pval, L"?") == 0 )
            {
                return FALSE;
            }
            else
            {
                ::fwprintf(stderr, L"Unrecognized parameter %ls\n", argv[i]);
                return FALSE;
            }
        }
        else
        {
            if ( *ppcwszFilename == NULL )
            {
                *ppcwszFilename = argv[i];
            }
            else
            {
                ::fwprintf(stderr, L"Only one filename parameter at a time.\n");
                return FALSE;
            }
        }
    }

    return TRUE;
}


void DispUsage( PCWSTR pcwszExeName )
{
    const static WCHAR wchUsage[] = 
        L"Extracts public key tokens from certificate files, in a format\n"
        L"usable in Side-By-Side assembly identities.\n"
        L"\n"
        L"Usage:\n"
        L"\n"
        L"%ls <filename.cer> [-quiet]\n";

    ::wprintf(wchUsage, pcwszExeName);
}

BOOL
HashAndSwizzleKey(
    HCRYPTPROV hProvider,
    BYTE *pbPublicKeyBlob,
    SIZE_T cbPublicKeyBlob,
    BYTE *pbKeyToken,
    SIZE_T &cbKeyToken
    )
{
    BOOL fResult = FALSE;
    HCRYPTHASH hHash = NULL;
    DWORD dwHashSize, dwHashSizeSize;
    ULONG top = STRONG_NAME_BYTE_LENGTH - 1;
    ULONG bottom = 0;


    if (cbKeyToken < STRONG_NAME_BYTE_LENGTH) {
        return FALSE;
    }

    if ( !::CryptCreateHash( hProvider, CALG_SHA1, NULL, 0, &hHash ) )
    {
        ::fwprintf(stderr, L"Unable to create cryptological hash object, error %ld\n", ::GetLastError());
        goto Exit;
    }

    if ( !::CryptHashData( hHash, pbPublicKeyBlob, static_cast<DWORD>(cbPublicKeyBlob), 0 ) )
    {
        ::fwprintf(stderr, L"Unable to hash public key information, error %ld\n", ::GetLastError());
        goto Exit;
    }

    if ( !::CryptGetHashParam( hHash, HP_HASHSIZE, (PBYTE)&dwHashSize, &(dwHashSizeSize = sizeof(dwHashSize)), 0))
    {
        ::fwprintf(stderr, L"Unable to determine size of hashed public key bits, error %ld\n", ::GetLastError());
        goto Exit;
    }

    if ( dwHashSize > cbKeyToken )
    {
        ::fwprintf(stderr, L"Hashed data is too large - space for %ld bytes, got %ld.\n",
            cbKeyToken, dwHashSize);
        goto Exit;
    }

    if ( !::CryptGetHashParam( hHash, HP_HASHVAL, pbKeyToken, &(dwHashSize = (DWORD)cbKeyToken), 0))
    {
        ::fwprintf(stderr, L"Unable to get hash of public key bits, error %ld\n", ::GetLastError());
        goto Exit;
    }

    cbKeyToken = dwHashSize;

    if (cbKeyToken < STRONG_NAME_BYTE_LENGTH)
    {
        ::fwprintf(stderr, L"Internal error - length of hash object (%d) is less than strong name length (%d)\n",
            cbKeyToken,
            STRONG_NAME_BYTE_LENGTH);
        goto Exit;
    }

    //
    // Now, move down the last eight bytes, then reverse them.
    //
    ::memmove(pbKeyToken,
        pbKeyToken + (cbKeyToken  - STRONG_NAME_BYTE_LENGTH),
        STRONG_NAME_BYTE_LENGTH);

    while ( bottom < top )
    {
        const BYTE b = pbKeyToken[top];
        pbKeyToken[top] = pbKeyToken[bottom];
        pbKeyToken[bottom] = b;
        bottom++;
        top--;
    }

    //
    // The tokens are always this long.
    //
    cbKeyToken = STRONG_NAME_BYTE_LENGTH;
    
    fResult = TRUE;
Exit:
    if ( hHash != NULL )
    {
        ::CryptDestroyHash(hHash);
        hHash = NULL;
    }
    return fResult;
}


BOOL
GetTokenOfKey(
    PCERT_PUBLIC_KEY_INFO pKeyInfo,
    PBYTE prgbBuffer,
    SIZE_T &cbPublicKeyTokenLength
    )
{
    PBYTE rgbWorkingSpace = NULL;
    DWORD dwRequiredSpace = 0;
    PSXS_PUBLIC_KEY_INFO pKeyBlobWorkspace = NULL;
    HCRYPTPROV hContext = NULL;
    HCRYPTKEY hCryptKey = NULL;
    BOOL fResult = FALSE;

    if ( !CryptAcquireContext(&hContext, NULL, NULL, PROV_RSA_FULL, CRYPT_SILENT | CRYPT_VERIFYCONTEXT))
    {
        ::fwprintf(stderr, L"Unable to aquire cryptological context, error %ld.\n", ::GetLastError());
        goto Exit;
    }

    ::ZeroMemory(prgbBuffer, cbPublicKeyTokenLength);

    //
    // Set up the public key info blob for hashing.  Import the key to a real
    // HCRYPTKEY, then export the bits back out to a buffer.  Set up the various
    // other settings in the blob as well, the type of key and the alg. used to
    // sign it.
    //
    if ( !::CryptImportPublicKeyInfoEx(
        hContext,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pKeyInfo,
        CALG_RSA_SIGN,
        0,
        NULL,
        &hCryptKey) )
    {
        ::fwprintf(stderr, L"Unable to import the public key from this certificate. Error %ld.\n", ::GetLastError());
        goto Exit;
    }

    if (!::CryptExportKey(hCryptKey, NULL, PUBLICKEYBLOB, 0, NULL, &dwRequiredSpace))
    {
        ::fwprintf(stderr, L"Unable to get required space for exporting public key data\n");
        goto Exit;
    }

    dwRequiredSpace += sizeof(SXS_PUBLIC_KEY_INFO);
    rgbWorkingSpace = (PBYTE)HeapAlloc(GetProcessHeap(), 0, dwRequiredSpace);
    if (rgbWorkingSpace == NULL)
    {
        ::fwprintf(stderr, L"Not enough memory to export public key data\n");
        goto Exit;
    }
    
    pKeyBlobWorkspace = reinterpret_cast<PSXS_PUBLIC_KEY_INFO>(rgbWorkingSpace);
    pKeyBlobWorkspace->KeyLength = dwRequiredSpace - offsetof(SXS_PUBLIC_KEY_INFO, pbKeyInfo);

    if ( !::CryptExportKey(
        hCryptKey,
        NULL,
        PUBLICKEYBLOB,
        0,
        pKeyBlobWorkspace->pbKeyInfo,
        &pKeyBlobWorkspace->KeyLength) )
    {
        ::fwprintf(stderr, L"Unable to extract public key bits from this certificate. Error %ld.\n", ::GetLastError());
        goto Exit;
    }

    pKeyBlobWorkspace->SigAlgID = CALG_RSA_SIGN;
    pKeyBlobWorkspace->HashAlgID = CALG_SHA1;

    //
    // We now need to hash the public key bytes with SHA1.
    //
    dwRequiredSpace = pKeyBlobWorkspace->KeyLength + offsetof(SXS_PUBLIC_KEY_INFO, pbKeyInfo);
    if (!::HashAndSwizzleKey(
            hContext,
            (PBYTE)pKeyBlobWorkspace, 
            dwRequiredSpace,
            prgbBuffer,
            cbPublicKeyTokenLength))
    {
        goto Exit;
    }

    fResult = TRUE;
Exit:
    if ( hCryptKey != NULL )
    {
        ::CryptDestroyKey(hCryptKey);
        hCryptKey = NULL;
    }
    if (rgbWorkingSpace != NULL)
    {
        ::HeapFree(GetProcessHeap(), 0, rgbWorkingSpace);
        rgbWorkingSpace = NULL;
    }
    if ( hContext != NULL )
    {
        ::CryptReleaseContext(hContext, 0);
        hContext = NULL;
    }

    return fResult;
        
}


int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HCERTSTORE hCertStore = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    BOOL fNoLogoDisplay = FALSE;
    BOOL fQuiet = FALSE;
    DWORD STRONG_NAME_LENGTH = 8;
    PCWSTR pcwszFilename = NULL;
    DWORD dwRetVal = ERROR_SUCCESS;

    //
    // Quick check - are we to display the logo?
    for ( int j = 0; j < argc; j++ )
    {
        if (::_wcsicmp(argv[j], L"-nologo") == 0)
            fNoLogoDisplay = TRUE;
    }

    if ( !fNoLogoDisplay )
    {
        ::fputws(wchMicrosoftLogo, stdout);
    }

    //
    // Now go look for the arguments.
    //
    if ((argc < 2) || !ParseArgs( argv, argc, &pcwszFilename, &fQuiet ))
    {
        ::DispUsage( argv[0] );
        dwRetVal = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    else if ( !pcwszFilename )
    {
        ::DispUsage( argv[0] );
        dwRetVal = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    hCertStore = ::CertOpenStore(
        CERT_STORE_PROV_FILENAME,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        NULL,
        CERT_STORE_OPEN_EXISTING_FLAG,
        (void*)pcwszFilename);

    if ( !hCertStore )
    {
        ::fwprintf( 
            stderr, 
            L"Unable to open the input file %ls, error %ld\n", 
            pcwszFilename,
            dwRetVal = ::GetLastError());
        goto Exit;
    }

    while ( pCertContext = ::CertEnumCertificatesInStore( hCertStore, pCertContext ) )
    {
        if ( !pCertContext->pCertInfo )
        {
            ::fwprintf( stderr, L"Oddity with file %ls - Certificate information not decodable\n", pcwszFilename );
            continue;
        }

        // NTRAID#NTBUG9 - 536275 - jonwis - 2002/04/25 - Stack buffers are bad, replace with heap allocated blobs
        WCHAR wsNiceName[BUFFER_SIZE] = { L'\0' };
        BYTE bBuffer[BUFFER_SIZE];
        SIZE_T cbBuffer = BUFFER_SIZE;
        DWORD dwKeyLength = 0;
        PCERT_PUBLIC_KEY_INFO pKeyInfo = &(pCertContext->pCertInfo->SubjectPublicKeyInfo);
        DWORD dwDump = 0;

        dwDump = ::CertGetNameStringW(
            pCertContext,
            CERT_NAME_FRIENDLY_DISPLAY_TYPE,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            wsNiceName,
            BUFFER_SIZE
            );
            
        if ( dwDump == 0 )
        {
            ::fwprintf(stderr, L"Unable to get certificate name string! Error %ld.", GetLastError());
            ::wcsncpy(wsNiceName, L"(Unknown)", NUMBER_OF(wsNiceName));
            wsNiceName[NUMBER_OF(wsNiceName) - 1] = 0;
        }

        if ( !fQuiet )
        {
            dwKeyLength = CertGetPublicKeyLength( X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pKeyInfo );

            ::wprintf(L"\nCertificate: \"%ls\" - %ld bits long\n", wsNiceName, dwKeyLength);

            if ( dwKeyLength < 2048 )
            {
                ::wprintf(L"\tWarning! This key is too short to sign SxS assemblies with.\n\tSigning keys need to be 2048 bits or more.\n");
            }
        }
        
        if (!::GetTokenOfKey( pKeyInfo, bBuffer, cbBuffer ))
        {
            ::fwprintf(stderr, L"Unable to generate public key token for this certificate.\n");
        }
        else
        {
            if ( !fQuiet ) ::wprintf(L"\tpublicKeyToken=\"");
            for ( SIZE_T i = 0; i < cbBuffer; i++ )
            {
                ::wprintf(L"%02x", bBuffer[i] );
            }
            if ( !fQuiet ) 
                ::wprintf(L"\"\n");
            else
                ::wprintf(L"\n");
            
        }
        
    }

Exit:

    if ( hCertStore != NULL )
    {
        ::CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
        hCertStore = NULL;
    }

    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\csrdbgmon\csrdbgmon.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    csrdbgmon.cpp

Abstract:

Author:

    Michael Grier (MGrier) June 2002

Revision History:

    Jay Krell (Jaykrell) June 2002
        make it compile for 64bit
        tabs to spaces
        init some locals
        make some tables const

--*/
#include <windows.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <dbghelp.h>

#define ASSERT(x) do { /* nothing */ } while(0)

#define NUMBER_OF(_x) (sizeof(_x) / sizeof((_x)[0]))

static const char g_szImage[] = "csrdbgmon";
static const char *g_pszImage = g_szImage;

static HANDLE g_hWorkerThread;
static DWORD g_tidWorkerThread;
static HANDLE g_hCompletionPort;
static HANDLE g_hCSRSS;
static DWORD g_pidCSRSS;

static bool g_fDebuggingCSRSS = false;
static DWORD64 g_dw64NtdllBaseAddress;
static DWORD g_dwOldKdFusionMask = 0;
static bool g_fKdFusionMaskSet = false;

void ReportFailure(const char szFormat[], ...);
DWORD WINAPI WorkerThreadThreadProc(LPVOID);
BOOL EnableDebugPrivilege();

FILE *fp;

void
ReportFailure(
    const char szFormat[],
    ...
    )
{
    const DWORD dwLastError = ::GetLastError();
    va_list ap;
    char rgchBuffer[4096];
    WCHAR rgchWin32Error[4096];

    // Stop debugging csrss so that we can actually issue the error message.
    if (g_fDebuggingCSRSS)
        ::DebugActiveProcessStop((DWORD) -1);

    va_start(ap, szFormat);
    ::_vsnprintf(rgchBuffer, sizeof(rgchBuffer) / sizeof(rgchBuffer[0]), szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error),
            &ap))
    {
        const DWORD dwLastError2 = ::GetLastError();
        ::_snwprintf(rgchWin32Error, sizeof(rgchWin32Error) / sizeof(rgchWin32Error[0]), L"Error formatting Win32 error %lu (0x%08lx)\nError from FormatMessage is %lu", dwLastError, dwLastError, dwLastError2);
    }

    ::fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

BOOL
FormatAndQueueString(
    const WCHAR szFormat[],
    ...
    )
{
    BOOL fSuccess = FALSE;

    ::SetLastError(ERROR_INTERNAL_ERROR);

    WCHAR rgwchBuffer[2048];
    SIZE_T cch;
    LPOVERLAPPED lpo = NULL;
    PWSTR psz = NULL;
    const HANDLE Heap = ::GetProcessHeap();

    va_list ap;
    va_start(ap, szFormat);
    cch = ::_vsnwprintf(rgwchBuffer, NUMBER_OF(rgwchBuffer), szFormat, ap);
    va_end(ap);

    lpo = (LPOVERLAPPED) ::HeapAlloc(Heap, 0, sizeof(OVERLAPPED) + ((cch + 1) * sizeof(WCHAR)));
    if (lpo == NULL)
    {
        ::SetLastError(ERROR_OUTOFMEMORY);
        ::ReportFailure("HeapAlloc(%p, 0, %lu) failed", Heap, sizeof(OVERLAPPED) + ((cch + 1) * sizeof(WCHAR)));
        goto Exit;
    }

    ::ZeroMemory(lpo, sizeof(OVERLAPPED));

    psz = (PWSTR) (lpo + 1);

    ::wcscpy(psz, rgwchBuffer);

    if (!::PostQueuedCompletionStatus(g_hCompletionPort, 0, NULL, lpo))
    {
        ::ReportFailure("PostQueuedCompletionStatus(%p, 0, NULL, %p) failed", g_hCompletionPort, 0, NULL, lpo);
        goto Exit;
    }

    lpo = NULL;

    fSuccess = TRUE;

Exit:
    if (lpo != NULL)
    {
        const DWORD dwLastError = ::GetLastError();
        ::HeapFree(Heap, 0, lpo);
        ::SetLastError(dwLastError);
    }

    return fSuccess;
}

BOOL CALLBACK EnumModules(
    LPSTR ModuleName, 
    ULONG BaseOfDll,  
    PVOID UserContext )
{
    ::printf("%08X %s\n", BaseOfDll, ModuleName);
    return TRUE;
}

typedef HANDLE (__stdcall * PCSR_GET_PROCESS_ID)();

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;
    DEBUG_EVENT de;
    SYMBOL_INFO si = { sizeof(si) };
    PCSR_GET_PROCESS_ID pfn = NULL;
    DWORD dwNewKdMask = 0x40000000;
    SIZE_T nBytesWritten = 0;
    DWORD dwSymOptions = 0;
    const HANDLE Heap = ::GetProcessHeap();

#if 0
    fp = fopen("csrdbgmon.log", "w");
    if (!fp)
    {
        perror("unable to create csrdbgmon.log");
        goto Exit;
    }
#endif // 0

    if (!::EnableDebugPrivilege())
    {
        ::ReportFailure("EnableDebugPrivilege() failed");
        goto Exit;
    }

    if ((pfn = (PCSR_GET_PROCESS_ID) GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "CsrGetProcessId")) == NULL)
    {
        ::ReportFailure("GetProcessAddress(GetModuleHandleW(L\"ntdll\"), \"CsrGetProcessId\") failed");
        goto Exit;
    }

    g_pidCSRSS = (DWORD)(DWORD_PTR)(*pfn)();

    if ((g_hCSRSS = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, g_pidCSRSS)) == NULL)
    {
        ::ReportFailure("OpenProcess(PROCESS_ALL_ACCESS, FALSE, 0x%lx) failed", g_pidCSRSS);
        goto Exit;
    }

    dwSymOptions = ::SymGetOptions();
    if (!::SymSetOptions(dwSymOptions | SYMOPT_DEFERRED_LOADS))
    {
        ::ReportFailure("SymSetOptions(dwSymOptions (= 0x%08lx) | SYMOPT_DEFERRED_LOADS (= 0x%08x)) failed", dwSymOptions, SYMOPT_DEFERRED_LOADS);
        goto Exit;
    }

    if (!::SymInitialize(g_hCSRSS, NULL, TRUE))
    {
        ::ReportFailure("SymInitialize(%p, NULL, TRUE) failed", g_hCSRSS);
        goto Exit;
    }

    if (!::SymFromName(g_hCSRSS, "sxs!kd_fusion_mask", &si))
    {
        ::ReportFailure("SymFromName(%p, \"sxs!kd_fusion_mask\", %p) failed", g_hCSRSS, &si);
        goto Exit;
    }

    if (!::ReadProcessMemory(g_hCSRSS, (PVOID) si.Address, &g_dwOldKdFusionMask, sizeof(g_dwOldKdFusionMask), &nBytesWritten))
    {
        ::ReportFailure("ReadProcessMemory(%p, %p, %p, %lu, %p) failed", g_hCSRSS, (PVOID) si.Address, &g_dwOldKdFusionMask, sizeof(g_dwOldKdFusionMask), &nBytesWritten);
        goto Exit;
    }

    dwNewKdMask = g_dwOldKdFusionMask | 0x40000000;

    if (!::WriteProcessMemory(g_hCSRSS, (PVOID) si.Address, &dwNewKdMask, sizeof(dwNewKdMask), &nBytesWritten))
    {
        ::ReportFailure("WriteProcessMemory(%p, %p, %p (-> %lx), %lu, %p) failed", g_hCSRSS, (PVOID) si.Address, &dwNewKdMask, dwNewKdMask, sizeof(dwNewKdMask), &nBytesWritten);
        goto Exit;
    }

    g_fKdFusionMaskSet = true;

    if ((g_hCompletionPort = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1)) == NULL)
    {
        ::ReportFailure("CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1) failed");
        goto Exit;
    }

    if ((g_hWorkerThread = ::CreateThread(NULL, 0, &WorkerThreadThreadProc, NULL, 0, &g_tidWorkerThread)) == NULL)
    {
        ::ReportFailure("CreateThread(NULL, 0, %p (==&WorkerThreadThreadProc), NULL, 0, %p (== &g_tidWorkerThread))", &WorkerThreadThreadProc, &g_tidWorkerThread);
        goto Exit;
    }

    if (!::FormatAndQueueString(L"Found ntdll!kd_fusion_mask at %I64x\n", si.Address))
    {
        ::ReportFailure("FormatAndQueueString() failed");
        goto Exit;
    }

    if (!::DebugActiveProcess(g_pidCSRSS))
    {
        ::ReportFailure("DebugActiveProcess(0x%lx) failed", g_pidCSRSS);
        goto Exit;
    }

    // First, if we die, we don't want to take the system with us.
    if (!::DebugSetProcessKillOnExit(FALSE))
    {
        const DWORD dwLastError = ::GetLastError();
        ::DebugActiveProcessStop(g_pidCSRSS);
        ::SetLastError(dwLastError);
        ::ReportFailure("DebugSetProcessKillOnExit(FALSE) failed");
        goto Exit;
    }

    g_fDebuggingCSRSS = true;

    for (;;)
    {
        SIZE_T t = 0;
        PCSTR EventName = "<Event not in map>";

        if (!::WaitForDebugEvent(&de, INFINITE))
        {
            ::ReportFailure("WaitForDebugEvent(%p, INFINITE) failed", &de);
            goto Exit;
        }

        if (fp != NULL)
        {
            const static struct { PCSTR psz; DWORD dwEventCode; } s_rgMap[] = {
#define ENTRY(x) { #x, x }
                ENTRY(EXCEPTION_DEBUG_EVENT),
                ENTRY(CREATE_THREAD_DEBUG_EVENT),
                ENTRY(CREATE_PROCESS_DEBUG_EVENT),
                ENTRY(EXIT_THREAD_DEBUG_EVENT),
                ENTRY(EXIT_PROCESS_DEBUG_EVENT),
                ENTRY(LOAD_DLL_DEBUG_EVENT),
                ENTRY(UNLOAD_DLL_DEBUG_EVENT),
                ENTRY(OUTPUT_DEBUG_STRING_EVENT),
                ENTRY(RIP_EVENT),
#undef ENTRY
            };

            for (t=0; t<NUMBER_OF(s_rgMap); t++)
            {
                if (s_rgMap[t].dwEventCode == de.dwDebugEventCode)
                {
                    EventName = s_rgMap[t].psz;
                    break;
                }
            }

            ::fprintf(fp, "%s { p: %lu; t: %lu } ", EventName, de.dwProcessId, de.dwThreadId);
        }

        switch (de.dwDebugEventCode)
        {
        case CREATE_PROCESS_DEBUG_EVENT:
            g_hCSRSS = de.u.CreateProcessInfo.hProcess;
            break;

        case EXIT_PROCESS_DEBUG_EVENT:
            break;

#if 0
        case LOAD_DLL_DEBUG_EVENT:
            {
                LOAD_DLL_DEBUG_INFO &rlddi = de.u.LoadDll;

                if (!::FormatAndQueueString(
                        L"Loaded:\n"
                        L"   hFile: %p\n"
                        L"   lpBaseOfDll: %p\n"
                        L"   dwDebugInfoFileOffset: %lu (0x%lx)\n"
                        L"   nDebugInfoSize: %lu (0x%lx)\n"
                        L"   lpImageName: %p\n"
                        L"   fUnicode: %u\n",
                        rlddi.hFile,
                        rlddi.lpBaseOfDll,
                        rlddi.dwDebugInfoFileOffset, rlddi.dwDebugInfoFileOffset,
                        rlddi.nDebugInfoSize, rlddi.nDebugInfoSize,
                        rlddi.lpImageName,
                        rlddi.fUnicode))
                {
                    ::ReportFailure("FormatAndQueueString() for LOAD_DLL_DEBUG_EVENT failed");
                    goto Exit;
                }

                break;
            }
#endif // 0

        case OUTPUT_DEBUG_STRING_EVENT:
            {
                DWORD BytesReadDword = 0;
                SIZE_T BytesReadSizeT = 0;
                OUTPUT_DEBUG_STRING_INFO &rodsi = de.u.DebugString;
                PWSTR pszLocalString = NULL;
                LPOVERLAPPED lpo = NULL;
                SIZE_T len = rodsi.nDebugStringLength;

                if (rodsi.nDebugStringLength != 0)
                {
                    if (rodsi.fUnicode)
                    {
                        if ((lpo = (LPOVERLAPPED) ::HeapAlloc(Heap, 0, sizeof(OVERLAPPED) + ((len + 1) * sizeof(WCHAR)))) == NULL)
                        {
                            ::ReportFailure("HeapAlloc(%p (== GetProcessHeap()), 0, %lu) failed", GetProcessHeap(), sizeof(OVERLAPPED) + (rodsi.nDebugStringLength * sizeof(WCHAR)));
                            goto Exit;
                        }

                        pszLocalString = (PWSTR) (lpo + 1);

                        BytesReadSizeT = BytesReadDword;
                        if (!::ReadProcessMemory(g_hCSRSS, rodsi.lpDebugStringData, pszLocalString, rodsi.nDebugStringLength * sizeof(WCHAR), &BytesReadSizeT))
                        {
                            ::ReportFailure("ReadProcessMemory(%p, %p, %p, %lu, %p) failed", g_hCSRSS, rodsi.lpDebugStringData, pszLocalString, rodsi.nDebugStringLength * sizeof(WCHAR), &BytesReadSizeT);
                            goto Exit;
                        }
                        BytesReadDword = (DWORD)BytesReadSizeT;
                        ASSERT(BytesReadDword == BytesReadSizeT);

                        pszLocalString[rodsi.nDebugStringLength] = L'\0';
                    }
                    else
                    {
                        PSTR pszTempString = NULL;
                        INT i = 0;
                        INT j = 0;
                        
                        if ((pszTempString = (PSTR) ::HeapAlloc(Heap, 0, rodsi.nDebugStringLength)) == NULL)
                        {
                            ::ReportFailure("HeapAlloc(%p (== GetProcessHeap()), 0, %lu) failed", GetProcessHeap(), rodsi.nDebugStringLength);
                            goto Exit;
                        }

                        BytesReadSizeT = BytesReadDword;
                        if (!::ReadProcessMemory(g_hCSRSS, rodsi.lpDebugStringData, pszTempString, rodsi.nDebugStringLength, &BytesReadSizeT))
                        {
                            ::ReportFailure("ReadProcessMemory(%p, %p, %p, %lu, %p) failed", g_hCSRSS, rodsi.lpDebugStringData, pszTempString, rodsi.nDebugStringLength, &BytesReadSizeT);
                            goto Exit;
                        }
                        BytesReadDword = (DWORD)BytesReadSizeT;
                        ASSERT(BytesReadDword == BytesReadSizeT);

                        if ((i = ::MultiByteToWideChar(CP_ACP, 0, pszTempString, BytesReadDword, NULL, 0)) == 0)
                        {
                            ::ReportFailure("MultiByteToWideChar(CP_ACP, 0, %p, %lu, NULL, 0) failed", pszTempString, BytesReadDword);
                            goto Exit;
                        }

                        if ((lpo = (LPOVERLAPPED) ::HeapAlloc(Heap, 0, sizeof(OVERLAPPED) + ((i + 1) * sizeof(WCHAR)))) == NULL)
                        {
                            ::ReportFailure("HeapAlloc(%p (== GetProcessHeap()), 0, %lu) failed", GetProcessHeap(), sizeof(OVERLAPPED) + ((i + 1) * sizeof(WCHAR)));
                            goto Exit;
                        }

                        pszLocalString = (PWSTR) (lpo + 1);

                        if ((j = ::MultiByteToWideChar(CP_ACP, 0, pszTempString, BytesReadDword, pszLocalString, i * sizeof(WCHAR))) == 0)
                        {
                            ::ReportFailure("MultiByteToWideChar(CP_ACP, 0, %p, %lu, %p, %lu) failed", pszTempString, BytesReadDword, pszLocalString, i * sizeof(WCHAR));
                            goto Exit;
                        }

                        pszLocalString[j] = L'\0';

                        ::HeapFree(Heap, 0, pszTempString);
                    }

                    ::ZeroMemory(lpo, sizeof(OVERLAPPED));

                    if (!::PostQueuedCompletionStatus(g_hCompletionPort, 0, NULL, lpo))
                    {
                        ::ReportFailure("PostQueuedCompletionStatus(%p, 0, NULL, %p) failed", g_hCompletionPort, 0, NULL, lpo);
                        goto Exit;
                    }
                }
                break;
            }
        }

        if (!::ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_EXCEPTION_NOT_HANDLED))
        {
            ::ReportFailure("ContinueDebugEvent(%lu, %lu, DBG_EXCEPTION_NOT_HANDLED) failed", de.dwProcessId, de.dwThreadId);
            goto Exit;
        }

        if (fp != NULL)
        {
            ::fprintf(fp, "\n");
            ::fflush(fp);
        }
    }

    iReturnStatus = EXIT_SUCCESS;

Exit:
    if (g_fKdFusionMaskSet)
    {
        const DWORD dwLastError = ::GetLastError();
        ::WriteProcessMemory(g_hCSRSS, (PVOID) si.Address, &g_dwOldKdFusionMask, sizeof(g_dwOldKdFusionMask), &nBytesWritten);
        ::SetLastError(dwLastError);
    }

    return iReturnStatus;
}

DWORD
WINAPI
WorkerThreadThreadProc(
    LPVOID
    )
{
    ULONG n = 0;
    LPOVERLAPPED lpoPrevious = NULL;
    ULONG nReps = 0;
    DWORD dwMSTimeout = 100;
    const HANDLE Heap = ::GetProcessHeap();

    for (;;)
    {
        DWORD dwNumberOfBytes = 0;
        ULONG_PTR ulpCompletionKey = 0;
        LPOVERLAPPED lpOverlapped = NULL;

        if (!::GetQueuedCompletionStatus(g_hCompletionPort, &dwNumberOfBytes, &ulpCompletionKey, &lpOverlapped, dwMSTimeout))
        {
            if (lpOverlapped == NULL)
            {
                if (lpoPrevious != NULL)
                {
                    // timeout...
                    PCWSTR psz2 = (PCWSTR) (lpoPrevious + 1);

                    if (nReps != 0)
                        ::printf("[%08lx:%lu] %ls", n++, nReps + 1, psz2);
                    else
                        ::printf("[%08lx] %ls", n++, psz2);

                    ::fflush(stdout);

                    ::HeapFree(Heap, 0, lpoPrevious);
                    lpoPrevious = lpOverlapped;
                    nReps = 0;
                    dwMSTimeout = INFINITE;
                }
            }
            else
            {
                ::ReportFailure("GetQueuedCompletionStatus(%p, %p, %p, %p, INFINITE) failed", g_hCompletionPort, &dwNumberOfBytes, &ulpCompletionKey, &lpOverlapped);
            }
        }
        else
        {
            PCWSTR psz = (PCWSTR) (lpOverlapped + 1);

            dwMSTimeout = 100;

            if (lpoPrevious != NULL)
            {
                PCWSTR psz2 = (PCWSTR) (lpoPrevious + 1);

                if (::wcscmp(psz, psz2) == 0)
                {
                    psz = NULL;
                    nReps++;
                    ::HeapFree(Heap, 0, lpOverlapped);
                }
                else
                {
                    if (nReps != 0)
                        ::printf("[%08lx:%lu] %ls", n++, nReps + 1, psz2);
                    else
                        ::printf("[%08lx] %ls", n++, psz2);

                    ::fflush(stdout);

                    ::HeapFree(Heap, 0, lpoPrevious);
                    lpoPrevious = lpOverlapped;
                    nReps = 0;
                }
            }
            else
            {
                // first one...
                lpoPrevious = lpOverlapped;
            }
        }
    }

    return 0;
}

BOOL
EnableDebugPrivilege()
{
    LUID             PrivilegeValue;
    BOOL             Result = FALSE;
    TOKEN_PRIVILEGES TokenPrivileges;
    TOKEN_PRIVILEGES OldTokenPrivileges;
    DWORD            ReturnLength = 0;
    HANDLE           TokenHandle = NULL;

    //
    // First, find out the LUID Value of the privilege
    //

    if(!::LookupPrivilegeValueW(NULL, L"SeDebugPrivilege", &PrivilegeValue)) {
        ::ReportFailure("LookupPrivilegeValueW(NULL, L\"SeDebugPrivilege\", %p) failed", &PrivilegeValue);
        goto Exit;
    }

    //
    // Get the token handle
    //
    if (!::OpenProcessToken (
        ::GetCurrentProcess(),
             TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
             &TokenHandle
             ))
    {
        ::ReportFailure("OpenProcessToken() failed");
        goto Exit;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = PrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    ReturnLength = sizeof(TOKEN_PRIVILEGES);
    if (!::AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof(OldTokenPrivileges),
                &OldTokenPrivileges,
                &ReturnLength
                ))
    {
        ::ReportFailure("AdjustTokenPrivileges(%p, FALSE, %p, %lu, %p, %p) failed", TokenHandle, &TokenPrivileges, sizeof(OldTokenPrivileges), &OldTokenPrivileges, &ReturnLength);
        goto Exit;
    }

    Result = TRUE;
Exit:

    if (TokenHandle != NULL)
    {
        const DWORD dwLastError = ::GetLastError();
        ::CloseHandle(TokenHandle);
        ::SetLastError(dwLastError);
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\delayload_tool\stdinc.h ===
#define FUSION_ENABLE_UNWRAPPED_DELETE 1
#define STRICT
#define UNICODE
#define _UNICODE
#include "yvals.h"
#pragma warning(disable:4127)
#pragma warning(disable:4663)
#pragma warning(disable:4100)
#pragma warning(disable:4511)
#pragma warning(disable:4512)
#pragma warning(disable:4018) /* signed/unsigned mismatch */
#pragma warning(disable:4786) /* long symbols */
#if defined(_WIN64)
#pragma warning(disable:4267) /* conversion from size_t to int */
#endif
#undef _MIN
#undef _MAX
#define _MIN min
#define _MAX max
#define min min
#define max max
#define NOMINMAX
#define _cpp_min min
#define _cpp_max max
#include <string>
#include <vector>
#include <set>
#include <algorithm>
#include <map>
#include <stdio.h>
#pragma warning(disable:4201) /* nonstandard extension : nameless struct/union */
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "debmacro.h"
#include "handle.h"
#include "mystring.h"
#include <functional>
#include <set>
#include "fusion_msxml_sax_attributes.h"
#include "fusion_msxml_sax_writer.h"
#include "filestream.h"
#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\dir_bigpath\dir.cpp ===
//
// Simple wrapper around GetFullPathname and FindFirstFile/FindNextFile
// that converts to \\? form.
//
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(push)
#pragma warning(disable: 4511)
#pragma warning(disable: 4512)
#include "yvals.h"
#pragma warning(disable: 4663)
#include <vector>
#pragma warning(pop)
#include <string.h>
#include <stdarg.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define FusionpGetLastWin32Error GetLastError
#define FusionpSetLastWin32Error SetLastError
#include <string.h>
#include <stdarg.h>
#include "fusionhandle.h"
BOOL FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);
BOOL FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }
extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
BOOL FusionpInitializeHeap(HINSTANCE hInstance);
VOID FusionpUninitializeHeap();
};

void ExeEntry()
{
    if (!::FusionpInitializeHeap(GetModuleHandleW(NULL)))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    FusionpUninitializeHeap();
}

FILE* g_pLogFile;
const static WCHAR g_pszImage[] = L"mkdir_bigpath";

void
ReportFailure(
    const char* szFormat,
    ...
    )
{
    const DWORD dwLastError = ::GetLastError();
    va_list ap;
    char rgchBuffer[4096] = { 0 };
    WCHAR rgchWin32Error[4096] = { 0 };

    va_start(ap, szFormat);
    _vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer) - 1, szFormat, ap);
    va_end(ap);

    if (!::FormatMessageW(
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwLastError,
            0,
            rgchWin32Error,
            NUMBER_OF(rgchWin32Error) - 1,
            &ap))
    {
        const DWORD dwLastError2 = ::GetLastError();
        _snwprintf(rgchWin32Error, NUMBER_OF(rgchWin32Error) - 1, L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
    }

    fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
        fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;
    std::vector<WCHAR> arg1;
    PWSTR p = NULL;
    ULONG i = 0;
    WIN32_FIND_DATAW wfd;
    CFindFile FindFileHandle;

    if (argc != 2)
    {
        fprintf(stderr,
            "%ls: Usage:\n"
            "   %ls <directory-to-list>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    arg1.resize(1 + (1UL << 15));
    arg1[0] = 0;
    if (!::FusionpConvertToBigPath(argv[1], arg1.size(), &arg1[0]))
    {
        ::ReportFailure("FusionpConvertToBigPath\n");
        goto Exit;
    }
    arg1.resize(1 + ::wcslen(&arg1[0]));
    arg1.insert(arg1.end() - 1, '\\');
    arg1.insert(arg1.end() - 1, '*');
    if (!FindFileHandle.Win32FindFirstFile(&arg1[0], &wfd))
    {
        ::ReportFailure("FindFirstFile\n");
        goto Exit;
    }
    do
    {
        LARGE_INTEGER Size;
        Size.HighPart = wfd.nFileSizeHigh;
        Size.LowPart = wfd.nFileSizeLow;

        printf("%I64u, %ls%ls\n", Size.QuadPart, wfd.cFileName, (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? L"/" : L"");

    } while(::FindNextFileW(FindFileHandle, &wfd));

//Success:
    iReturnStatus = EXIT_SUCCESS;
Exit:
    return iReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\delayload_tool\delayload_tool.h ===
typedef std::vector<String_t> StringVector_t;

VOID ThrowLastWin32Error();
VOID Throw(PCWSTR);

class BuildFlavor_t;
class Error_t;
class FindFirstFileError_t;
class DelayloadTool_t;
class File_t;
class Image_t;

class Error_t
{
public:
};

class FindFirstFileError_t : public Error_t
{
public:
    HRESULT m_hresult;
    DWORD   m_dwLastError;
    String_t m_strParameter;
};

VOID
CollectDirectoryPathsNonRecursively(
    const String_t& directory,
    StringVector_t& paths
    );

typedef BOOL (CALLBACK * PFN_COLLECTION_FILE_PATHS_RECURSIVELY_FILTER)(PVOID FilterContext, PCWSTR Directory, WIN32_FIND_DATAW * wfd);

VOID
CollectFilePathsRecursivelyHelper(
    const String_t& directory,
    StringVector_t& paths,
    PFN_COLLECTION_FILE_PATHS_RECURSIVELY_FILTER Filter,
    PVOID FilterContext,
    WIN32_FIND_DATAW& wfd
    );

VOID
CollectFilePathsRecursively(
    const String_t& directory,
    StringVector_t& paths,
    PFN_COLLECTION_FILE_PATHS_RECURSIVELY_FILTER Filter = NULL,
    PVOID FilterContext = NULL
    );

class DelayloadTool_t
{
private:
    typedef DelayloadTool_t This_t;
    DelayloadTool_t(const DelayloadTool_t&);
    VOID operator=(const DelayloadTool_t&);
public:

    ~DelayloadTool_t()
    {
        m_XmlWriter.Release();
        m_XmlAttributes.Release();
    }

    DelayloadTool_t() { }

    typedef String_t FilePath_t;
    typedef std::vector<FilePath_t> FilePaths_t;

    VOID ProcessBuild(const BuildFlavor_t& b);
    VOID ProcessFile(const FilePath_t& root, const FilePath_t& f);
    VOID Main(const StringVector_t& args);

    F::CXmlWriter       m_XmlWriter;
    F::CXmlAttributes   m_XmlAttributes;
    std::vector<BYTE>   m_HeadersBuffer;
    ULONG               m_OffsetToPe;
    PIMAGE_SECTION_HEADER m_HintSection;
    CFileStream         m_OutFileStream;
    PIMAGE_OPTIONAL_HEADER32 m_OptionalHeader32;
    PIMAGE_OPTIONAL_HEADER64 m_OptionalHeader64;

    PIMAGE_NT_HEADERS GetNtHeaders() { return reinterpret_cast<PIMAGE_NT_HEADERS>(&m_HeadersBuffer[m_OffsetToPe]); }
    PVOID GetMappedBase() { return &m_HeadersBuffer[0]; }
    SIZE_T GetSizeOfPointer() { return (m_OptionalHeader32 ? 4 : m_OptionalHeader64 ? 8 : ~0); }

    String_t ReadOneDelayload(HANDLE FileHandle);
};

#define GET_OPTIONAL_HEADER_FIELD(o32, o64, f) ((o32) ? (o32)->f : (o64)->f)

VOID DelayloadToolAssertFailed(const char* Expression, const char* File, unsigned long Line);
VOID DelayloadToolInternalErrorCheckFailed(const char* Expression, const char* File, unsigned long Line);
String_t NumberToString(ULONG Number, PCWSTR Format = L"0x%lx");
String_t GetLastErrorString();
String_t RemoveOptionChar(const String_t& s);
VOID __cdecl Error(const wchar_t* s, ...);
String_t GetEnv(PCWSTR s);
String_t FindLatestReleaseOnServer(const String_t& Server);
BOOL DelayloadTool_Filter(PVOID FilterContext, PCWSTR Directory, WIN32_FIND_DATAW * wfd);

class BuildFlavor_t
{
public:
    WCHAR Name[12];
    WCHAR Processor[8];
    WCHAR ChkOrFre[8];
    WCHAR ReleaseServer[12]; // or "local"
    String_t * ActualRoot;
};

class File_t
{
public:
    String_t    m_FullPath;
    String_t    m_RelativePath;
    String_t    m_LeafPath;
    String_t    m_Error;
};

class Delayload_t
{
public:
    String_t m_LeafPath;
};

class Image_t : public File_t
{
public:
    std::vector<Delayload_t> m_Delayloads;
};

VOID SeekTo(HANDLE FileHandle, ULONG64 Offset);
VOID SeekForward(HANDLE FileHandle, ULONG64 Offset);
VOID SeekBackward(HANDLE FileHandle, LONG64 Offset);
VOID Read(HANDLE FileHandle, VOID * Buffer, ULONG BytesToRead);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\delayload_tool\delayload_tool.cpp ===
#include "stdinc.h"
static const char File[] = __FILE__;
#include "delayload_tool.h"
#include "fusionstring.h"
#include "setfilepointerex.c"
#include "getfilesizeex.c"
#include <assert.h>
#include "delayimp.h"
#include "imagehlp.h"
#define BITS_OF(x) (sizeof(x) * 8)
String_t GetErrorString(DWORD Error);

//
// delayimp.h doesn't work when tool bitness != image bitness
//
typedef ULONG32 PImgThunkData32;
typedef ULONG32 PCImgThunkData32;
typedef ULONG32 LPCSTR32;
typedef ULONG32 PHMODULE32;
typedef ULONG64 PImgThunkData64;
typedef ULONG64 PCImgThunkData64;
typedef ULONG64 LPCSTR64;
typedef ULONG64 PHMODULE64;

typedef struct ImgDelayDescrV1_32 {
    DWORD            grAttrs;        // attributes
    LPCSTR32         szName;         // pointer to dll name
    PHMODULE32       phmod;          // address of module handle
    PImgThunkData32  pIAT;           // address of the IAT
    PCImgThunkData32 pINT;           // address of the INT
    PCImgThunkData32 pBoundIAT;      // address of the optional bound IAT
    PCImgThunkData32 pUnloadIAT;     // address of optional copy of original IAT
    DWORD            dwTimeStamp;    // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
    } ImgDelayDescrV1_32, * PImgDelayDescrV1_32;

typedef struct ImgDelayDescrV1_64 {
    DWORD            grAttrs;        // attributes
    LPCSTR64         szName;         // pointer to dll name
    PHMODULE64       phmod;          // address of module handle
    PImgThunkData64  pIAT;           // address of the IAT
    PCImgThunkData64 pINT;           // address of the INT
    PCImgThunkData64 pBoundIAT;      // address of the optional bound IAT
    PCImgThunkData64 pUnloadIAT;     // address of optional copy of original IAT
    DWORD            dwTimeStamp;    // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
    } ImgDelayDescrV1_64, * PImgDelayDescrV1_64;

//
// get msvcrt.dll wildcard processing on the command line
//
extern "C" { int _dowildcard = 1; }

void Spinner()
{
    static char s[] = "-\\|/";
    static unsigned i;

    fprintf(stderr, "%c\r", s[i++ % (sizeof(s) - 1)]);
}

void Throw(PCWSTR s)
{
    if (::IsDebuggerPresent())
    {
        DbgPrint("Throw(%ls)\n", s);
        DebugBreak();
    }
    throw (s);
}

void F::ThrowHresult(HRESULT hr)
{
    if (::IsDebuggerPresent())
    {
        DbgPrint("ThrowHresult:0x%lx|%ld|%ls\n", hr, (hr & 0xffff), GetErrorString(hr).c_str());
        DebugBreak();
    }
    throw (hr);
}

void ThrowLastWin32Error()
{
    DWORD dw = GetLastError();
    if (::IsDebuggerPresent())
    {
        DbgPrint("ThrowLastWin32Error:0x%lx|%ld|%ls\n", dw, dw, GetErrorString(dw).c_str());
        DebugBreak();
    }
    throw (dw);
}

void
CollectDirectoryPathsNonRecursively(
    const String_t& directory,
    StringVector_t& paths
    )
{
    WIN32_FIND_DATAW wfd;
    DFindFile FindFile;
    HRESULT hr = 0;
    String_t directory_slash_star = directory + L"\\*";

    if (FAILED(hr = FindFile.HrCreate(directory_slash_star, &wfd)))
    {
        FindFirstFileError_t err;
        err.m_hresult = hr;
        err.m_dwLastError = GetLastError();
        std::swap(err.m_strParameter, directory_slash_star);
        throw err;
    }
    directory_slash_star.clear();
    do
    {
        if (FusionpIsDotOrDotDot(wfd.cFileName))
        {
            continue;
        }
        if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
        {
            paths.insert(paths.end(), directory + L"\\" + wfd.cFileName);
        }
    } while (::FindNextFileW(FindFile, &wfd));
}

typedef BOOL (CALLBACK * PFN_COLLECTION_FILE_PATHS_RECURSIVELY_FILTER)(PVOID FilterContext, PCWSTR Directory, WIN32_FIND_DATAW * wfd);

void
CollectFilePathsRecursivelyHelper(
    const String_t& directory,
    StringVector_t& paths,
    PFN_COLLECTION_FILE_PATHS_RECURSIVELY_FILTER Filter,
    PVOID FilterContext,
    WIN32_FIND_DATAW& wfd
    )
{
    DFindFile FindFile;
    HRESULT hr = 0;
    String_t directory_slash_star = directory + L"\\*";

    if (FAILED(hr = FindFile.HrCreate(directory_slash_star, &wfd)))
    {
        FindFirstFileError_t err;
        err.m_hresult = hr;
        err.m_dwLastError = GetLastError();
        std::swap(err.m_strParameter, directory_slash_star);
        throw err;
    }
    directory_slash_star.clear();
    do
    {
        if (FusionpIsDotOrDotDot(wfd.cFileName))
        {
            continue;
        }
        if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
        {
            if (Filter == NULL || (*Filter)(FilterContext, directory, &wfd))
            {
                CollectFilePathsRecursivelyHelper(directory + L"\\" + wfd.cFileName, paths, Filter, FilterContext, wfd);
            }
        }
        else
        {
            if (Filter == NULL || (*Filter)(FilterContext, directory, &wfd))
            {
                paths.insert(paths.end(), directory + L"\\" + wfd.cFileName);
            }
        }
    } while (::FindNextFileW(FindFile, &wfd));
}

void
CollectFilePathsRecursively(
    const String_t& directory,
    StringVector_t& paths,
    PFN_COLLECTION_FILE_PATHS_RECURSIVELY_FILTER Filter,
    PVOID FilterContext
    )
{
    WIN32_FIND_DATAW wfd;

    CollectFilePathsRecursivelyHelper(directory, paths, Filter, FilterContext, wfd);
}

void DelayloadToolAssertFailed(const char* Expression, const char* File, unsigned long Line)
{
    fprintf(stderr, "ASSERTION FAILURE: File %s, Line %lu, Expression %s\n", File, Line, Expression);
    abort();
}

void DelayloadToolInternalErrorCheckFailed(const char* Expression, const char* File, unsigned long Line)
{
    fprintf(stderr, "INTERNAL ERROR: File %s, Line %lu, Expression %s\n", File, Line, Expression);
    abort();
}

String_t NumberToString(ULONG Number, PCWSTR Format)
{
    // the size needed is really dependent on Format..
    WCHAR   NumberAsString[BITS_OF(Number) + 5];

    _snwprintf(NumberAsString, NUMBER_OF(NumberAsString), Format, Number);
    NumberAsString[NUMBER_OF(NumberAsString) - 1] = 0;

    return NumberAsString;
}

String_t GetErrorString(DWORD Error)
{
    PWSTR s = NULL;
    String_t ErrorString = NumberToString(Error, L"%lu");
    PWSTR FormatMessageAllocatedBuffer = NULL;

    if (!FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER
        | FORMAT_MESSAGE_FROM_SYSTEM
        | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        Error,
        0,
        reinterpret_cast<PWSTR>(&FormatMessageAllocatedBuffer),
        100,
        NULL
        )
        || FormatMessageAllocatedBuffer == NULL
        )
    {
        goto Exit;
    }
    if (FormatMessageAllocatedBuffer[0] == 0)
    {
        goto Exit;
    }

    //
    // Error messages often end with vertical whitespce, remove it.
    //
    s = FormatMessageAllocatedBuffer + StringLength(FormatMessageAllocatedBuffer) - 1;
    while (s != FormatMessageAllocatedBuffer && (*s == '\n' || *s == '\r'))
        *s-- = 0;
    ErrorString = ErrorString + L" (" + FormatMessageAllocatedBuffer + L")";
Exit:
    LocalFree(FormatMessageAllocatedBuffer);
    return ErrorString;
}

String_t GetLastErrorString()
{
    return GetErrorString(GetLastError());
}

String_t RemoveOptionChar(const String_t& s)
{
    if (s.Length() != 0)
    {
        if (s[0] == '-')
            return s.substr(1);
        else if (s[0] == '/')
            return s.substr(1);
        else if (s[0] == ':') // hacky..
            return s.substr(1);
        else if (s[0] == '=') // hacky..
            return s.substr(1);
    }
    return s;
}

void __cdecl Error(const wchar_t* s, ...)
{
	printf("%s\n", s);
	exit(EXIT_FAILURE);
}

String_t GetEnv(PCWSTR Name)
{
    DWORD               LengthIn = 64;
    DWORD               LengthOut = 0;
    std::vector<WCHAR>  Buffer;

    while (true)
    {
        Buffer.resize(LengthIn);
        Buffer[0] = 0;
        LengthOut = GetEnvironmentVariableW(Name, &Buffer[0], LengthIn);
        if (LengthOut < LengthIn)
        {
            break;
        }
        LengthIn = 1 + std::max(2 * LengthIn, LengthOut);
    }
    return &Buffer[0];
}

String_t FindLatestReleaseOnServer(const String_t& Server)
{
    StringVector_t Releases;
    String_t ServerRelease;

    ServerRelease += L"\\\\";
    ServerRelease += Server;
    ServerRelease += L"\\release";

    CollectDirectoryPathsNonRecursively(ServerRelease, Releases);
    std::sort(Releases.begin(), Releases.end());
    return Releases.back();
}

BOOL DelayloadTool_Filter(PVOID FilterContext, PCWSTR Directory, WIN32_FIND_DATAW * wfd)
{
const static UNICODE_STRING directoriesToIgnore[] =
{
#define X(x) RTL_CONSTANT_STRING(x)
    X(L"pro"), X(L"srv"), X(L"ads"), X(L"dtc"), X(L"bla"), X(L"per"),
    X(L"sbs"),
    X(L"proinf"), X(L"srvinf"), X(L"adsinf"), X(L"dtcinf"), X(L"blainf"), X(L"perinf"),
    X(L"procd1"), X(L"procd2"),
    X(L"ifs_cd"), X(L"symbols"), X(L"ifs_flat"), X(L"build_logs"),
    X(L"symbols.pri"), X(L"processor_cd"), X(L"processor_flat"),
    X(L"asmscab"),
    X(L"ddk_flat"),
    X(L"scp_wpa"),
    X(L"hu"),
    X(L"ara"), X(L"br"), X(L"chs"), X(L"cht"), X(L"cs"), X(L"da"), X(L"el"), X(L"es"),
    X(L"euq"), X(L"fi"), X(L"fr"), X(L"ger"), X(L"heb"), X(L"hun"), X(L"it"), X(L"jpn"),
    X(L"kor"), X(L"nl"), X(L"no"), X(L"pl"), X(L"pt"), X(L"ru"), X(L"sky"), X(L"slv"),
    X(L"sv"), X(L"tr"), X(L"usa"),
    X(L"congeal_scripts"),
    X(L"lanman"),
    X(L"dos"), X(L"lanman.os2"), X(L"tcp32wfw"), X(L"update.wfw"), X(L"msclient"),
    X(L"bootfloppy"),
    X(L"opk"),
    X(L"winpe"),
    X(L"presign"),
    X(L"prerebase"),
};
const static UNICODE_STRING extensionsToIgnore[] =
{
    X(L"txt"), X(L"htm"), X(L"gif"), X(L"bmp"), X(L"pdb"),
    X(L"inf"), X(L"sif"), X(L"pnf"), X(L"png"),
    X(L"sys"), X(L"ttf"), X(L"vbs"), X(L"hlp"), X(L"ini"), X(L"cat"),
    X(L"cab"), X(L"nls"), X(L"gpd"), X(L"chm"), X(L"cur"), X(L"jpg"),
    X(L"cer"), X(L"ani"), X(L"fon"), X(L"css"), X(L"hash"),
    X(L"lst"), X(L"icm"), X(L"msg"), X(L"386"),
    X(L"ico"), X(L"dos"), X(L"asp"), X(L"sld"),
    X(L"pif"), X(L"cnt"), X(L"mof"), X(L"man"), X(L"msm"),
    X(L"cdf"), X(L"img"), X(L"doc"), X(L"dns"), X(L"cpx"), X(L"mib"), X(L"ppd")
    X(L"map"), X(L"sym")
#undef X
};


    CUnicodeString cFileName(wfd->cFileName);
    SIZE_T i;

    if ((wfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
    {
        Spinner();
        //fprintf(stderr, "%wZ\n", &cFileName);
        for (i = 0 ; i != RTL_NUMBER_OF(directoriesToIgnore) ; ++i)
        {
            if (FusionpEqualStringsI(&directoriesToIgnore[i], &cFileName))
                return FALSE;
        }
    }
    else
    {
        PCWSTR dot;
        if (RTL_STRING_GET_LAST_CHAR(&cFileName) == L'_')
            return FALSE;
        if (RTL_STRING_GET_LAST_CHAR(&cFileName) == L'$')
            return FALSE;
        dot = wcsrchr(wfd->cFileName, '.');
        if (dot != NULL && wcslen(dot + 1) == 3)
        {
            CUnicodeString dotString(dot + 1);
            for (i = 0 ; i != RTL_NUMBER_OF(extensionsToIgnore) ; ++i)
            {
                if (FusionpEqualStringsI(&extensionsToIgnore[i], &dotString))
                    return FALSE;
            }
        }
    }
    _wcslwr(wfd->cFileName);
    return TRUE;
}

void
SeekTo(
    HANDLE  FileHandle,
    ULONG64 Offset
    )
{
    LARGE_INTEGER liOffset;

    liOffset.QuadPart = Offset;
    if (!FusionpSetFilePointerEx(FileHandle, liOffset, NULL, FILE_BEGIN))
    {
        DbgPrint("SeekTo:0x%I64x failing\n", Offset);
        ThrowLastWin32Error();
    }
}

void
SeekBackward(
    HANDLE  FileHandle,
    LONG64  Offset
    )
{
    LARGE_INTEGER liOffset;

    liOffset.QuadPart = -Offset;
    if (!FusionpSetFilePointerEx(FileHandle, liOffset, NULL, FILE_CURRENT))
        ThrowLastWin32Error();
}

ULONG64
GetCurrentSeekPointer(
    HANDLE  FileHandle
    )
{
    LARGE_INTEGER li;
    LARGE_INTEGER li2;

    li.QuadPart = 0;
    li2.QuadPart = 0;

    if (!FusionpSetFilePointerEx(FileHandle, li, &li2, FILE_CURRENT))
        ThrowLastWin32Error();
    return li2.QuadPart;
}

void
SeekForward(
    HANDLE  FileHandle,
    ULONG64 Offset
    )
{
    LARGE_INTEGER liOffset;

    liOffset.QuadPart = Offset;
    if (!FusionpSetFilePointerEx(FileHandle, liOffset, NULL, FILE_CURRENT))
        ThrowLastWin32Error();
}

PBYTE
FindRunOfZeros(
    PBYTE pb,
    PBYTE pbEnd,
    SIZE_T elementSize
    )
{
    SIZE_T k = 0;
    SIZE_T mod = ((pbEnd - pb) % elementSize);
    assert(mod == 0);
    if (mod != 0)
    {
        return pbEnd;
    }

    if (pb + elementSize >= pbEnd)
        return pbEnd;

    for ( ; pb != pbEnd ; pb += elementSize)
    {
        for (k = 0 ; k != elementSize ; ++k)
        {
            if (pb[k] != 0)
            {
                break;
            }
        }
        if (k == elementSize)
        {
            break;
        }
    }
    return pb;
}

void
ReadImportFunctionNames(
    HANDLE File,
    SIZE_T SizeOfPointer,
    const std::vector<ULONG64>& IatRvas
    std::vector<String_t>& IatRvas
    )
{
}

void
ReadIatRvas(
    HANDLE File,
    SIZE_T SizeOfPointer,
    std::vector<ULONG64>& Iat
    )
//
// This leaves the seek pointer in an arbitrary location.
//
{
    union
    {
        ULONG32 Iat32[64];
        ULONG64 Iat64[32];
        BYTE    Bytes[64 * 4];
    } u;

    ULONG BytesRead;
    ULONG Mod;
    Iat.resize(0);

    assert(SizeOfPointer == 4 || SizeOfPointer == 8);

    while (true)
    {
        BytesRead = 0;
        if (!ReadFile(File, &u, sizeof(u), &BytesRead, NULL))
            ThrowLastWin32Error(/*"ReadFile"*/);
        Mod = (BytesRead % SizeOfPointer);
        if (Mod != 0)
        {
            SeekBackward(File, Mod);
            BytesRead -= Mod;
        }
        if (BytesRead == 0)
        {
            Throw(L"end of file without nul terminal\n");
        }
        PBYTE pb = FindRunOfZeros(u.Bytes, u.Bytes + BytesRead, SizeOfPointer);
        switch (SizeOfPointer)
        {
        case 4:
            std::copy(u.Iat32, reinterpret_cast<ULONG32*>(pb), std::inserter(Iat.end()));
            break;
        case 8:
            std::copy(u.Iat64, reinterpret_cast<ULONG64*>(pb), std::inserter(Iat.end()));
            break;
        default:
            Throw("unknown sizeof pointer");
            break;
        }
        if (pb != u.Bytes + BytesRead)
        {
            break;
        }
    }
}


String_t
ReadDllName(
    HANDLE File
    )
//
// This leaves the seek pointer in an arbitrary location.
//
{
    String_t Result;
    CHAR BufferA[65];
    WCHAR BufferW[65];
    DWORD BytesRead = 0;

    BufferA[NUMBER_OF(BufferA) - 1] = 0;
    BufferW[NUMBER_OF(BufferW) - 1] = 0;

    while (true)
    {
        BytesRead = 0;
        if (!ReadFile(File, &BufferA[0], (NUMBER_OF(BufferA) - 1) * sizeof(BufferA[0]), &BytesRead, NULL))
            ThrowLastWin32Error(/*"ReadFile"*/);
        if (BytesRead == 0)
        {
            Throw(L"end of file without nul terminal\n");
        }
        _strlwr(BufferA);
        for (ULONG i = 0 ; i != BytesRead ; ++i)
        {
            if ((BufferW[i] = BufferA[i]) == 0)
            {
                Result += BufferW;
                return Result;
            }
        }
        Result += BufferW;
    }
}

void
Read(
    HANDLE FileHandle,
    VOID * Buffer,
    ULONG BytesToRead
    )
{
    DWORD BytesRead;

    if (!ReadFile(FileHandle, Buffer, BytesToRead, &BytesRead, NULL))
        ThrowLastWin32Error(/*"ReadFile"*/);
    if (BytesToRead != BytesRead)
    {
        Throw(L"wrong number of bytes read");
    }
}

void DelayloadTool_t::ProcessBuild(const BuildFlavor_t& b)
{
    FilePaths_t FilePaths;

    CollectFilePathsRecursively(*b.ActualRoot, FilePaths, DelayloadTool_Filter);
    for (FilePaths_t::const_iterator i = FilePaths.begin() ; i != FilePaths.end() ; ++i)
    {
        ProcessFile(*b.ActualRoot, *i);
        Spinner();
    }
}

String_t
DelayloadTool_t::ReadOneDelayload(
    HANDLE File
    )
{
    ImgDelayDescrV1_32 delay1_32 = { 0 };
    ImgDelayDescrV1_64 delay1_64 = { 0 };
    ImgDelayDescrV2 delay2 = { 0 };
    LONG64 FileOffsetToDelayLoadedName = 0;
    DWORD dwDelayFlags = 0;
 
    Read(File, &dwDelayFlags, 4);
    SeekBackward(File, 4);
    bool rvaFlag = ((dwDelayFlags & dlattrRva) != 0);
    if (rvaFlag)
    {
        Read(File, &delay2, sizeof(delay2));
    }
    else
    {
        if (m_OptionalHeader32 != NULL)
        {
            Read(File, &delay1_32, sizeof(delay1_32));
            if (delay1_32.szName == 0)
            {
                delay2.rvaDLLName = 0;
            }
            else
            {
                delay2.rvaDLLName = static_cast<RVA>(delay1_32.szName - m_OptionalHeader32->ImageBase);
            }
        }
        else if (m_OptionalHeader64 != NULL)
        {
            Read(File, &delay1_64, sizeof(delay1_64));
            if (delay1_64.szName == 0)
            {
                delay2.rvaDLLName = 0;
            }
            else
            {
                delay2.rvaDLLName = static_cast<RVA>(delay1_64.szName - m_OptionalHeader64->ImageBase);
            }
        }
        else
        {
            Throw(L"unknown image format");
        }
    }
    if (delay2.rvaDLLName == 0)
    {
        FileOffsetToDelayLoadedName = 0;
    }
    else
    {
        PBYTE pb = reinterpret_cast<PBYTE>(ImageRvaToVa(GetNtHeaders(), GetMappedBase(), delay2.rvaDLLName, &m_HintSection));
        FileOffsetToDelayLoadedName = (pb - &m_HeadersBuffer[0]); 
    }

    if (FileOffsetToDelayLoadedName == 0)
    {
        return L"";
    }
    ULONG64 CurrentOffset = GetCurrentSeekPointer(File);
    SeekTo(File, FileOffsetToDelayLoadedName);
    String_t DllName = ReadDllName(File);
    SeekTo(File, CurrentOffset);

    return DllName;
}

void DelayloadTool_t::ProcessFile(const FilePath_t & RootPath, const FilePath_t & FilePath)
{
    DFile File;
    Image_t Image;
    LARGE_INTEGER FileSize =  { 0 };
    PIMAGE_FILE_HEADER FileHeader = 0;
    m_OptionalHeader32 = 0;
    m_OptionalHeader64 = 0;
    PIMAGE_SECTION_HEADER SectionHeaders = 0;
    PIMAGE_DATA_DIRECTORY DelayloadDataDirectory = 0;
    HRESULT hr = 0;
    m_OffsetToPe = 0;
    ULONG OffsetToFileHeader = 0;
    ULONG OffsetToOptionalHeader = 0;
    ULONG OffsetToSectionHeaders = 0;
    ULONG SizeOfOptionalHeader = 0;
    ULONG SizeofSectionHeaders = 0;
    ULONG NumberOfSections = 0;
    m_HintSection = 0;
    String_t DllName;
    struct
    {
        IMAGE_IMPORT_DESCRIPTOR RawDescriptor;
        String_t DllName;
        std::vector<ULONG64>  Iat;
        std::vector<String_t> FunctionNames;
    } Import;

    Image.m_FullPath = FilePath;
    if (RootPath.GetLength() != 0)
    {
        assert(RootPath.GetLength() > Image.m_FullPath.GetLength());
        Image.m_RelativePath = Image.m_FullPath.substr(1 + RootPath.GetLength());
    }
    else
    {
        Image.m_RelativePath = L"";
    }
    Image.m_LeafPath = Image.m_FullPath.substr(1 + Image.m_FullPath.find_last_of(L"\\/"));

    //fprintf(stderr, "\n%ls", Image.m_RelativePath.c_str());

    hr = File.HrCreate(FilePath, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING);
    if (FAILED(hr))
    {
        goto Error;
    }
    if (!FusionpGetFileSizeEx(File, &FileSize))
    {
        goto Error;
    }
    if (FileSize.QuadPart < 64)
    {
        goto NotAnImage;
    }
    m_HeadersBuffer.resize(64);
    Read(File, &m_HeadersBuffer[0], 2);
    if (memcmp(&m_HeadersBuffer[0], "MZ", 2) != 0)
        goto NotAnImage;
    SeekTo(File, 60);
    Read(File, &m_HeadersBuffer[60], 4);
    m_OffsetToPe = *reinterpret_cast<ULONG*>(&m_HeadersBuffer[60]);
    OffsetToFileHeader = m_OffsetToPe + 4;
    OffsetToOptionalHeader = OffsetToFileHeader + sizeof(IMAGE_FILE_HEADER);
    if (m_OffsetToPe > MAXULONG - 4)
        goto NotAnImage;
    if (m_OffsetToPe + 4 > FileSize.QuadPart)
        goto NotAnImage;
    SeekTo(File, m_OffsetToPe);
    m_HeadersBuffer.resize(m_OffsetToPe + 4 + sizeof(IMAGE_FILE_HEADER));
    Read(File, &m_HeadersBuffer[m_OffsetToPe], 4);
    if (memcmp(&m_HeadersBuffer[m_OffsetToPe], "PE\0\0", 4) != 0)
        goto NotAnImage;
    Read(File, &m_HeadersBuffer[OffsetToFileHeader], sizeof(IMAGE_FILE_HEADER));
    FileHeader = reinterpret_cast<PIMAGE_FILE_HEADER>(&m_HeadersBuffer[OffsetToFileHeader]);
    SizeOfOptionalHeader = FileHeader->SizeOfOptionalHeader;
    NumberOfSections = FileHeader->NumberOfSections;
    OffsetToSectionHeaders = OffsetToOptionalHeader + SizeOfOptionalHeader;
    SizeofSectionHeaders = NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    m_HeadersBuffer.resize(OffsetToOptionalHeader + SizeOfOptionalHeader + SizeofSectionHeaders);
    Read(File, &m_HeadersBuffer[OffsetToOptionalHeader], SizeOfOptionalHeader + SizeofSectionHeaders);
    FileHeader = reinterpret_cast<PIMAGE_FILE_HEADER>(&m_HeadersBuffer[OffsetToFileHeader]);
    m_OptionalHeader32 = reinterpret_cast<PIMAGE_OPTIONAL_HEADER32>(&m_HeadersBuffer[OffsetToOptionalHeader]);
    m_OptionalHeader64 = reinterpret_cast<PIMAGE_OPTIONAL_HEADER64>(&m_HeadersBuffer[OffsetToOptionalHeader]);
    SectionHeaders = reinterpret_cast<PIMAGE_SECTION_HEADER>(&m_HeadersBuffer[SizeofSectionHeaders]);

    switch (m_OptionalHeader32->Magic)
    {
        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
            m_OptionalHeader64 = NULL;
            break;
        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
            m_OptionalHeader32 = NULL;
            break;
        case IMAGE_ROM_OPTIONAL_HDR_MAGIC:
            goto IgnoreRomImages;
            break;
        default:
            goto UnrecognizableImage;
    }
    if (GET_OPTIONAL_HEADER_FIELD(m_OptionalHeader32, m_OptionalHeader64, NumberOfRvaAndSizes)
        < IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT)
    {
        goto NoDelayloads;
    }
    DelayloadDataDirectory = &GET_OPTIONAL_HEADER_FIELD(m_OptionalHeader32, m_OptionalHeader64, DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT]);
    if (DelayloadDataDirectory->VirtualAddress == NULL)
    {
        goto NoDelayloads;
    }
    if (DelayloadDataDirectory->Size == NULL)
    {
        goto NoDelayloads;
    }

    fprintf(stderr, "\r%ls\n", Image.m_RelativePath.c_str());

    PBYTE pb;
    pb = reinterpret_cast<PBYTE>(ImageRvaToVa(GetNtHeaders(), GetMappedBase(), DelayloadDataDirectory->VirtualAddress, &m_HintSection));
    LONG64 OffsetToDelayloads;
    OffsetToDelayloads = pb - &m_HeadersBuffer[0];

    SeekTo(File, OffsetToDelayloads);
    DllName = ReadOneDelayload(File);
    if (DllName == L"")
    {
        goto NoDelayloads;
    }

    if (GET_OPTIONAL_HEADER_FIELD(m_OptionalHeader32, m_OptionalHeader64, NumberOfRvaAndSizes)
        < IMAGE_DIRECTORY_ENTRY_IMPORT)
    {
        goto NoImports;
    }
    ImportDataDirectory = &GET_OPTIONAL_HEADER_FIELD(m_OptionalHeader32, m_OptionalHeader64, DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
    if (ImportDataDirectory->VirtualAddress == NULL)
    {
        goto NoImports;
    }
    if (ImportDataDirectory->Size == NULL)
    {
        goto NoImports;
    }
    pb = reinterpret_cast<PBYTE>(ImageRvaToVa(GetNtHeaders(), GetMappedBase(), ImportDataDirectory->VirtualAddress, &m_HintSection));
    LONG64 OffsetToImport;
    OffsetToImport = pb - &m_HeadersBuffer[0];
    SeekTo(File, OffsetToImport);
    Read(File, &Import.RawDescriptor, sizeof(Import.RawDescriptor));
    OffsetToImport += sizeof(ImportDescriptor);

    SeekTo(File, Import.RawDescriptor.Name);
    Import.DllName = ReadDllName(File);
    SeekTo(File, Import.RawDescriptor.OriginalFirstThunk);
    ReadIatRvas(File, GetSizeOfPointer(), Import.Iat); 
    ReadImportFunctionNames(File, GetSizeOfPointer(), Import.Iat, Import.FunctionNames); 

NoImports:

    m_XmlWriter.startElement(L"file");
        m_XmlWriter.startElement(L"type");
            m_XmlWriter.characters(L"pe/coff image");
        m_XmlWriter.endElement(L"type");
        m_XmlWriter.startElement(L"full-path");
            m_XmlWriter.characters(Image.m_FullPath);
        m_XmlWriter.endElement(L"full-path");
        if (Image.m_RelativePath != L"")
        {
            m_XmlWriter.startElement(L"relative-path");
                m_XmlWriter.characters(Image.m_RelativePath);
            m_XmlWriter.endElement(L"relative-path");
        }
        m_XmlWriter.startElement(L"leaf-path");
            m_XmlWriter.characters(Image.m_LeafPath);
        m_XmlWriter.endElement(L"leaf-path");
        m_XmlWriter.startElement(L"delay-loads");
        for ( ; DllName != L""; DllName = ReadOneDelayload(File) )
        {
            m_XmlWriter.startElement(L"delay-load");
                m_XmlWriter.characters(DllName);
            m_XmlWriter.endElement(L"delay-load");
        }
        m_XmlWriter.endElement(L"delay-loads");
    m_XmlWriter.endElement(L"file");
    return;
/*
BytesReadError;
    Image.m_Error = L"bad number of bytes read";
    return;
*/
Error:
    Image.m_Error = GetLastErrorString();
    fprintf(stderr, "%ls", Image.m_Error.c_str());
    return;
UnrecognizableImage:
    Image.m_Error = L" unrecognizable image";
    fprintf(stderr, " unrecognizable image");
    return;
IgnoreRomImages:
    fprintf(stderr, " ignore rom image");
    return;
NoDelayloads:
    //fprintf(stderr, " no delayloads");
    return;
NotAnImage:
    //fprintf(stderr, " not an image");
    return;
}

void DelayloadTool_t::Main(const StringVector_t& args)
{
    typedef std::vector<FilePath_t> Files_t;
    Files_t Files;

    typedef std::vector<BuildFlavor_t> Builds_t;
    Builds_t Builds;

    String_t Nttree = GetEnv(L"_Nttree");
    BuildFlavor_t localBuild = { L"", L"", L"", L"" };
    localBuild.ActualRoot = &Nttree;

    BuildFlavor_t buildFlavors[] =
    {
        { L"x86fre", L"x86", L"fre", L"robsvbl11" },
        { L"x86chk", L"x86", L"chk", L"robsvbl2" },
        { L"ia64fre", L"ia64", L"fre", L"robsvbl3" },
        { L"ia64chk", L"ia64", L"chk", L"robsvbl4" },
        //{ L"amd64fre", "amd64", L"fre", L"robsvbl5" },
        //{ L"amd64chk", "amd64", L"chk", L"robsvbl6" },
    };

    std::vector<String_t> ActualRoots;
    ActualRoots.reserve(NUMBER_OF(buildFlavors));

    for (StringVector_t::const_iterator i = args.begin() ; i != args.end() ; ++i)
    {
        String_t arg = *i;
        if (arg == L"checkall")
        {
           SIZE_T j;
           for (j = 0 ; j != NUMBER_OF(buildFlavors); ++j)
           {
                if (buildFlavors[j].ActualRoot == NULL)
                {
                    ActualRoots.insert(ActualRoots.end(), FindLatestReleaseOnServer(buildFlavors[j].ReleaseServer));
                    buildFlavors[j].ActualRoot = &ActualRoots.back();
                    Builds.insert(Builds.end(), buildFlavors[j]);
                }
           }
        }
        else if (arg == L"checklocal")
        {
            if (Nttree == L"")
            {
                Error(L"nttree not set\n");
            }
            Builds.insert(Builds.end(), localBuild);
        }
        else if (arg == L"dlllist")
        {
            //
            // feedback loop optimization..
            //
        }
        else
        {
            SIZE_T k;
            for (k = 0 ; k != NUMBER_OF(buildFlavors) ; ++k)
            {
                if (arg == buildFlavors[k].Name)
                {
                    if (buildFlavors[k].ActualRoot == NULL)
                    {
                        ActualRoots.insert(ActualRoots.end(), FindLatestReleaseOnServer(buildFlavors[k].ReleaseServer));
                        buildFlavors[k].ActualRoot = &ActualRoots.back();
                        Builds.insert(Builds.end(), buildFlavors[k]);
                    }
                    break;
                }
            }
            if (k == NUMBER_OF(buildFlavors))
            {
                DWORD dw = GetFileAttributesW(arg);
                if (dw != 0xFFFFFFFF && (dw & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    Files.insert(Files.end(), arg);
                }
            }
        }
    }
    this->m_XmlWriter.encoding = L"ISO-8859-1";
    this->m_XmlWriter.output = static_cast<IStream*>(&this->m_OutFileStream);
    this->m_XmlWriter.indent = VARIANT_TRUE;

    if (!m_OutFileStream.OpenForWrite(
        L"c:\\delayload_out.xml",
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL
        ))
    {
        ThrowLastWin32Error();
    }

    this->m_XmlWriter.startDocument();
    this->m_XmlWriter.startElement(L"files");

    for (Builds_t::const_iterator m = Builds.begin() ; m != Builds.end() ; ++m)
    {
        ProcessBuild(*m);
    }
    for (Files_t::const_iterator n = Files.begin() ; n != Files.end() ; ++n)
    {
        ProcessFile(L"", *n);
    }
    this->m_XmlWriter.endElement(L"files");
    this->m_XmlWriter.endDocument();
//Exit:
    return;
}

extern "C"
{
	void __cdecl mainCRTStartup(void);
	void __cdecl wmainCRTStartup(void);
}

int __cdecl main(int argc, char** argv)
{
	wmainCRTStartup();
	return 0;
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    CoInitialize(NULL);
    FusionpInitializeHeap(GetModuleHandleW(NULL));
    DelayloadTool_t tool;
    StringVector_t args;
    args.reserve(argc);
    std::copy(argv + 1, argv + argc, std::back_inserter(args));
    tool.Main(args);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\exptodef\exptodef.cpp ===
/*
Read in an .exp. Produce a .def file like so:
EXPORTS
  Foo = expFoo
  Bar = expBar PRIVATE
  Abc = ntdll.RtlAbc

An .exp file is really just an .obj. We just read its symbols.
*/
#include "yvals.h"
#pragma warning(disable:4100)
#pragma warning(disable:4663)
#pragma warning(disable:4511)
#pragma warning(disable:4512)
#pragma warning(disable:4127)
#include <vector>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <string>
#include <map>
#include <string.h>
#include <set>
#include "strtok_r.h"
#include "windows.h"

class Export_t
{
public:
    string ExternalName;
    string InternalName;
    string ForwarderDll;
    string ForwarderFunction;

    void Write(FILE *);
};

class DefFile_t
{
public:
    vector<Export_t> Exports;

    void AddExport(const Export_t & e)
    {
        Exports.push_back(e);
    }

    void Read(const char *);
    void Write(const char *);
};

class ObjFile_t
{
public:
    ObjFile_t() : File(NULL) { }
    ~ObjFile_t() { if (File != NULL) { fclose(File); } }

    void ReadHeader(const char *);
    void ReadSymbols();
    bool AnySymbols() const;
    ULONG Machine() const;

    IMAGE_FILE_HEADER FileHeader;
    vector<string> Symbols;
    FILE * File;
};

class ExpFile_t : public ObjFile_t
{
public:
    ExpFile_t() { }
};

class IoError_t
{
public:
    IoError_t() { }
};

class StdIoError_t : public IoError_t
{
public:
    StdIoError_t(const char * function, int error) { }
};

class StdioError_fread_t : public StdIoError_t
{
public:
    StdioError_fread_t(int error) { }
};

class StdioError_fopen_t : public StdIoError_t
{
public:
    StdioError_fopen_t(const char * filename, const char * mode, int error) { }
};

FILE * FileOpen(const char * filename, const char * mode)
{
    FILE * file = fopen(filename, mode);
    if (file == NULL)
        throw StdioError_fopen_t(filename, mode, errno);
    return file;
}

void FileRead(FILE * File, void * Buffer, SIZE_T BytesToRead)
{
    if (!fread(Buffer, 1, BytesToRead, File))
        throw StdioError_fread_t(errno);
}

void FileSeek(FILE * File, long HowFar, int FromWhere)
{
    fseek(File, HowFar, FromWhere);
}

void ObjFile_t::ReadHeader(const char * s)
{
    File = FileOpen(s, "rb");
    FileRead(File, &this->FileHeader, sizeof(this->FileHeader));
}

bool ObjFile_t::AnySymbols() const { return (FileHeader.PointerToSymbolTable != 0 && FileHeader.NumberOfSymbols != 0); }
ULONG ObjFile_t::Machine() const { return FileHeader.Machine; }

unsigned long GetLittleEndianInteger(const unsigned char * Bytes, unsigned long Size)
{
    unsigned long i = 0;

    For ( ; Size != 0 ; (--Size, ++Bytes))
    {
        i <<= 8;
        i |= *Bytes;
    }
    return i;
}

class StringTable_t
{
public:
    unsigned long Size;
    const unsigned char * Base;

    StringTable_t() : Size(0), Base(0) { }

    void Attach(const unsigned char * s)
    {
        this->Base = s;
        this->Size = GetLittleEndianInteger(s, 4);
    }

    void RangeCheck(unsigned long Offset) const
    {
        if (Offset > this->Size)
            throw RangeError_t("StringTable");
    }

    const unsigned char * GetAtOffset(unsigned long Offset) const
    {
        return reinterpret_cast<const char*>(this->Base + Offset);
    }
};

class RawSymbols_t
{
public:
    unsigned char Bytes[18];

    string GetShortName() const
    {
        char ShortName[9];
        memcpy(ShortName, Bytes, 8);
        ShortName[8] = 0;
        return ShortName;
    }
    bool  IsShortName() const { return GetLittleEndianInteger(&this->Bytes[0], 4) == 0; }

    const char * GetLongName(StringTable_t * StringTable) const
    {
        unsigned long Offset = GetLittleEndiangInteger(&this->Bytes[4], 4);
        return StringTable->GetAtOffset(Offset);
    }

    ULONG GetValue() const { return GetLittleEndianInteger(&Bytes[8], 4); }
     LONG SectionNumber() const { return GetLittleEndianInteger(&Bytes[12], 2); }
    ULONG GetType() const { return GetLittleEndianInteger(&Bytes[14], 2); }
     LONG GetStorageClass() const { return GetLittleEndianInteger(&Bytes[16], 1); }
    ULONG NumberOfAuxSymbols() const { return GetLittleEndianInteger(&Bytes[17], 1); }
};

void ObjFile_t::ReadSymbols()
{
    FileSeek(File, FileHeader.PointerToSymbolsTable, SEEK_SET);
}

class ExpToDef_t
{
public:
    ExpFile_t InExpFile;
    DefFile_t OutDefFile;

    void Main(const char * in1, const char * in2, const char * out);
};

void ExpToDef_t::Main(const char * in, const char * out)
{
    this->InExpFile.Read(in);
    
    FILE * outfile = NULL;
    if (_stricmp(out, "-") == 0)
        outfile = stdout;
    else
    {
        outfile = fopen(out, "w");
        if (outfile == NULL)
        {
            Error("fopen(%s)\n", out);
            return;
        }
    }
    this->OutDefFile.Write(outfile);

}

int main()
{
    ExpToDef_t expToDef;

    expToDef.Main();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\fusion\tools\del_bigpath\del.cpp ===
//
// Simple wrapper around GetFullPathname and FindFirstFile/FindNextFile and DeleteFile
// that converts to \\? form.
//
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#pragma warning(disable:4511)
#pragma warning(disable:4512)
#include "yvals.h"
#pragma warning(disable:4663)
#pragma warning(disable:4018)
#include <vector>
#include <string.h>
#include <stdarg.h>
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#define FusionpGetLastWin32Error GetLastError
#define FusionpSetLastWin32Error SetLastError
#include <string.h>
#include <stdarg.h>
#include "fusionhandle.h"
BOOL FusionpConvertToBigPath(PCWSTR Path, SIZE_T BufferSize, PWSTR Buffer);
BOOL FusionpSkipBigPathRoot(PCWSTR s, OUT SIZE_T*);
BOOL FusionpAreWeInOSSetupMode(BOOL* pfIsInSetup) { *pfIsInSetup = FALSE; return TRUE; }
extern "C"
{
BOOL WINAPI SxsDllMain(HINSTANCE hInst, DWORD dwReason, PVOID pvReserved);
void __cdecl wmainCRTStartup();
BOOL FusionpInitializeHeap(HINSTANCE hInstance);
VOID FusionpUninitializeHeap();
};

void ExeEntry()
{
    if (!::FusionpInitializeHeap(GetModuleHandleW(NULL)))
        goto Exit;
    ::wmainCRTStartup();
Exit:
    FusionpUninitializeHeap();
}

FILE* g_pLogFile;
const static WCHAR g_pszImage[] = L"del_bigpath";

void
ReportFailure(
    const char* szFormat,
    ...
    )
{
    const DWORD dwLastError = ::GetLastError();
    va_list ap;
    char rgchBuffer[4096] = { 0 };
    WCHAR rgchWin32Error[4096] = { 0 };

    va_start(ap, szFormat);
    ::_vsnprintf(rgchBuffer, NUMBER_OF(rgchBuffer) - 1, szFormat, ap);
    va_end(ap);

    if (dwLastError != 0)
    {
        if (!::FormatMessageW(
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwLastError,
                0,
                rgchWin32Error,
                NUMBER_OF(rgchWin32Error) - 1,
                &ap))
        {
            const DWORD dwLastError2 = ::GetLastError();
            ::_snwprintf(rgchWin32Error, NUMBER_OF(rgchWin32Error) - 1, L"Error formatting Win32 error %lu\nError from FormatMessage is %lu", dwLastError, dwLastError2);
        }
    }
    ::fprintf(stderr, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);

    if (g_pLogFile != NULL)
    {
        ::fprintf(g_pLogFile, "%ls: %s\n%ls\n", g_pszImage, rgchBuffer, rgchWin32Error);
    }
}

extern "C" int __cdecl wmain(int argc, wchar_t** argv)
{
    int iReturnStatus = EXIT_FAILURE;
    std::vector<WCHAR> arg1;
    WIN32_FIND_DATAW wfd;
    CFindFile FindFileHandle;
    SIZE_T BigPathRootLength = 0;
    SIZE_T NonwildcardLength = 0;
    SIZE_T AllButLastPathElementlength = 0;
    SIZE_T LastPathElementLength = 0;

    if (argc != 2)
    {
        ::fprintf(stderr,
            "%ls: Usage:\n"
            "   %ls <file-to-delete-wildcards-ok>\n",
            argv[0], argv[0]);
        goto Exit;
    }

    arg1.resize(1 + (1UL << 15));
    arg1[0] = 0;
    if (!FusionpConvertToBigPath(argv[1], arg1.size(), &arg1[0]))
    {
        ::ReportFailure("FusionpConvertToBigPath\n");
       