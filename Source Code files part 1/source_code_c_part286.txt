 S_OK;
        }
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::IsSystemMoniker
//
//  Synopsis:
//
//  Arguments:  [pdwType]
//
//  Returns:
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::IsSystemMoniker  (THIS_ LPDWORD pdwType)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::IsSystemMoniker(%x,%x)\n",
                this, pdwType));

    __try
    {
	    *pdwType = MKSYS_OBJREFMONIKER;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::CommonPrefixWith
//
//  Synopsis:
//
//  Arguments:  [pmkOther]
//              [ppmkPrefix]
//
//  Returns:
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::CommonPrefixWith	(LPMONIKER pmkOther,
                                                 LPMONIKER *ppmkPrefix)
{
    M_PROLOG(this);
    VDATEPTROUT(ppmkPrefix,LPMONIKER);
    *ppmkPrefix = NULL;
    VDATEIFACE(pmkOther);

    if (S_OK == IsEqual(pmkOther))
    {
        *ppmkPrefix = this;
        AddRef();
        return MK_S_US;
    }

    return CBaseMoniker::CommonPrefixWith(pmkOther, ppmkPrefix);
}









//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::RelativePathTo
//
//  Synopsis:
//
//  Arguments:  [pmkOther]
//              [ppmkRelPath]
//
//  Returns:
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::RelativePathTo  (THIS_ LPMONIKER pmkOther,
                                               LPMONIKER *ppmkRelPath)
{
    return CBaseMoniker::RelativePathTo(pmkOther, ppmkRelPath);
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::IsDirty
//
//  Synopsis:   Checks the object for changes since it was last saved.
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::IsDirty()
{
    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::IsDirty(%x)\n",
                this));

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::Load
//
//  Synopsis:   Loads an objref moniker from a stream
//
//  Notes:      objref monikers are loaded as marshalled data
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::Load(IStream *pStream)
{
    HRESULT hr;
    ULONG   cbRead;

    mnkDebugOut((DEB_ITRACE, "CObjrefMoniker::Load(%x,%x)\n", this, pStream));
    __try
    {
        // Unmarshal the object we're wrapping
        hr = CoUnmarshalInterface(pStream, IID_IUnknown,(LPVOID *) &m_pUnk);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::Save
//
//  Synopsis:   Save the objref moniker to a stream
//
//  Notes:      Objref moniker is saved as table marshalled data
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::Save(IStream *pStream, BOOL fClearDirty)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::Save(%x,%x,%x)\n",
                this, pStream, fClearDirty));

    if (!m_pUnk)
        return E_UNEXPECTED;

    __try
    {
        // Marshal the wrapped object
        hr = CoMarshalInterface(pStream,
                            IID_IUnknown,
                            m_pUnk,
                            MSHCTX_DIFFERENTMACHINE,
                            0,
                            MSHLFLAGS_TABLEWEAK);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::GetSizeMax
//
//  Synopsis:   Get the maximum size required to serialize this moniker
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::GetSizeMax(ULARGE_INTEGER * pcbSize)
{
    HRESULT hr = E_FAIL;

    mnkDebugOut((DEB_ITRACE,
				"CObjrefMoniker::GetSizeMax(%x,%x)\n",
                this, pcbSize));

    if (!m_pUnk)
        return E_UNEXPECTED;

    __try
    {
        DWORD dwSize;
        hr = CoGetMarshalSizeMax(&dwSize, IID_IUnknown, m_pUnk,
                            MSHCTX_DIFFERENTMACHINE,
                            0,
                            MSHLFLAGS_TABLEWEAK);
        if (SUCCEEDED(hr))
            ULISet32(*pcbSize, dwSize);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::GetDisplayName - IMoniker implementation
//
//  Synopsis:   Get the display name of this moniker.
//
//  Notes:      Call ProgIDFromClassID to get the ProgID
//              Append a ':' to the end of the string.
//              If no ProgID is available, then use
//              objref:<marshalling data in base64>:
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::GetDisplayName(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    LPWSTR   * lplpszDisplayName)
{
    HRESULT hr = S_OK;
    LPWSTR pszDisplayName;

    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::GetDisplayName(%x,%x,%x,%x)\n",
                this, pbc, pmkToLeft, lplpszDisplayName));

    // check that we are holding a valid interface and that there is no
    // moniker to the left of us
    if ((!m_pUnk) || pmkToLeft)
        return E_UNEXPECTED;

    __try
    {
        LPWSTR pszPrefix = NULL;
        WCHAR szClassID[37];

        *lplpszDisplayName = NULL;


        // if we don't have a cached display name , build one
        if (!m_lpszDisplayName)
        {
            //Get the prefix
            hr = ProgIDFromCLSID(CLSID_ObjrefMoniker, &pszPrefix);

            if (!SUCCEEDED(hr))
            {
                // set the prefix to "objref"
                pszPrefix = (LPWSTR)CoTaskMemAlloc(7 * sizeof(WCHAR));
                lstrcpyW(pszPrefix, L"objref");
                hr = S_OK;
            }

            // build up marshalling information for display name
            // note we can only cache data based on TABLE MARSHALLED DATA
            IStream *pIStream = NULL;

            if (SUCCEEDED(hr))
            {
                hr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);
            }

            if (SUCCEEDED(hr))
            {
                hr = Save(pIStream, TRUE);
                if(SUCCEEDED(hr))
                {
                    // determine string buffer size needed
                    ULONG  cName = lstrlenW(pszPrefix) + 1; // colon

                    // GetStreamSize
                    ULARGE_INTEGER uli;
                    ULISet32(uli, 0);

                    hr = GetSizeMax(&uli);
                    if (SUCCEEDED(hr))
                    {
                        // max size of output buffer for base64 data will be
                        // 4/3 of stream size;
                        ULONG ulStreamSize;

                        ULIGet32(uli, ulStreamSize);
                        ulStreamSize = ((DWORD)((ulStreamSize+2)/3)) * 4;
                        ulStreamSize++; // allow for null terminator

                        // rewind the stream to starting position
                        LARGE_INTEGER liPos;
                        ULARGE_INTEGER uliNewPos;

                        LISet32(liPos, 0);
                        hr = pIStream -> Seek(liPos, STREAM_SEEK_SET, &uliNewPos);
                        if (SUCCEEDED(hr))
                        {
                            // total size is size of prefix + 2 (for : and null terminators)
                            m_lpszDisplayName = (LPWSTR) CoTaskMemAlloc((cName + ulStreamSize+1)* sizeof(wchar_t));
                            if(m_lpszDisplayName != NULL)
                            {
                                // write out prefix
                                lstrcpyW(m_lpszDisplayName, pszPrefix);
                                lstrcatW(m_lpszDisplayName, L":");

                                // write out marshalling data
                                hr = utIStreamToBase64(pIStream, &m_lpszDisplayName[cName], ulStreamSize *sizeof(wchar_t));

                                // write terminating colon
                                if (SUCCEEDED(hr))
                                    lstrcatW(m_lpszDisplayName, L":");
                            }
                            else
                                hr = E_OUTOFMEMORY;
                        }
                    }
                }
                pIStream -> Release();
            }

            if (pszPrefix)
                CoTaskMemFree(pszPrefix);
        }

        // create copy of display name to return
        if (m_lpszDisplayName && SUCCEEDED(hr))
        {
            int dnameLen = lstrlenW(m_lpszDisplayName);

            // CODEWORK - special case for display name greater than 2048
            if (dnameLen && (dnameLen >= 2048))
            {
                // downlevel MSIE 3.0 clients have a hardwired limit of 2048
                hr = E_INVALIDARG;

                mnkDebugOut((DEB_ERROR, "Error: CObjrefMoniker::GetDisplayName - name too long \n"));
            }
            else if (dnameLen)
            {
            *lplpszDisplayName =  (LPWSTR) CoTaskMemAlloc((dnameLen+1)* sizeof(wchar_t));
            if (*lplpszDisplayName)
                {
                lstrcpyW(*lplpszDisplayName, m_lpszDisplayName);
                hr = S_OK;
                }
            else
                hr = E_OUTOFMEMORY;
            }
            else
                hr = E_FAIL;
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CObjrefMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    M_PROLOG(this);
    VDATEPTROUT(ppenumMoniker,LPMONIKER);
    *ppenumMoniker = NULL;
    return S_OK;
}

STDMETHODIMP CObjrefMoniker::GetTimeOfLastChange(THIS_ LPBC pbc, LPMONIKER pmkToLeft, FILETIME *pfiletime)
{
    M_PROLOG(this);
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    VDATEPTROUT(pfiletime, FILETIME);

    return MK_E_UNAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cptrmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cptrmon.cxx
//
//  Contents:   Implementation of CPointerMoniker
//
//  Classes:
//
//  Functions:
//
//  History:	12-27-93   ErikGav   Created
//		06-14-94   Rickhi    Fix type casting
//              07-06-95   BruceMa   Make remotable
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "cptrmon.hxx"
#include "cantimon.hxx"
#include "mnk.h"

NAME_SEG(CPtrMon)







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::CPointerMoniker
//
//  Synopsis:   Constructor
//
//  Arguments:  [pUnk] -- 
//
//  Returns:    -
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
CPointerMoniker::CPointerMoniker( LPUNKNOWN pUnk ) CONSTR_DEBUG
{
    // We allow pUnk == NULL initially when remoting a pointer moniker
    if (pUnk)
    {
        pUnk->AddRef();
    }
    m_pUnk        = pUnk;
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::~CPointerMoniker
//
//  Synopsis:   Destructor
//
//  Arguments:  -
//
//  Returns:    -
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
CPointerMoniker::~CPointerMoniker( void )
{
    M_PROLOG(this);

    if (m_pUnk)
    {
        m_pUnk->Release();
    }
}






//+---------------------------------------------------------------------------
//
//  Function:   IsPointerMoniker : Private
//
//  Synopsis:   Constructor
//
//  Arguments:  [pmk] -- 
//
//  Returns:    pmk if it supprts CLSID_PointerMoniker
//              NULL otherwise
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
INTERNAL_(CPointerMoniker *) IsPointerMoniker ( LPMONIKER pmk )
{
    CPointerMoniker *pCPM;

    if ((pmk->QueryInterface(CLSID_PointerMoniker, (void **)&pCPM)) == S_OK)
    {
	// we release the AddRef done by QI but return the pointer
	pCPM->Release();
	return pCPM;
    }

    // dont rely on user implementations to set pCPM to NULL on failed QI
    return NULL;
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::Create
//
//  Synopsis:   Create a new pointer moniker
//
//  Arguments:  [pmk] -- 
//
//  Returns:    pmk if it supprts CLSID_PointerMoniker
//              NULL otherwise
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
CPointerMoniker *CPointerMoniker::Create(
	LPUNKNOWN pUnk )
{
    CPointerMoniker *pCIM = new CPointerMoniker(pUnk);

    return pCIM;
}








//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::QueryInterface
//
//  Synopsis:   
//
//  Arguments:  [riid]
//              [ppvObj]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::QueryInterface (THIS_ REFIID riid,
                                              LPVOID *ppvObj)
{
    M_PROLOG(this);
    VDATEIID (riid);
    VDATEPTROUT(ppvObj, LPVOID);

    *ppvObj = NULL;

#ifdef _DEBUG
    if (riid == IID_IDebug)
    {
	*ppvObj = &(m_Debug);
	return NOERROR;
    }
#endif

    if (IsEqualIID(riid, CLSID_PointerMoniker))
    {
	//  called by IsPointerMoniker.
	AddRef();
	*ppvObj = this;
	return S_OK;
    }

    if (IsEqualIID(riid, IID_IMarshal))
    {
	AddRef();
	*ppvObj = (IMarshal *) this;
	return S_OK;
    }

    if (IsEqualIID(riid, IID_IROTData))
    {
	return E_NOINTERFACE;
    }


    return CBaseMoniker::QueryInterface(riid, ppvObj);
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::AddRef
//
//  Synopsis:   
//
//  Arguments:  -
//
//  Returns:    New reference count
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPointerMoniker::AddRef (void)
{
    M_PROLOG(this);

    CBaseMoniker::AddRef();
    return m_refs;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::Release
//
//  Synopsis:   
//
//  Arguments:  -
//
//  Returns:    Current reference count
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPointerMoniker::Release (void)
{
    M_PROLOG(this);
    Assert(m_refs != 0);

    ULONG ul = m_refs;

    if (InterlockedDecrement((long *)&m_refs) == 0)
    {
    	delete this;
    	return 0;
    }
    return ul - 1;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::GetClassId
//
//  Synopsis:   
//
//  Arguments:  [riid]
//              [ppvObj]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::GetClassID (LPCLSID lpClassId)
{
    M_PROLOG(this);
    VDATEPTROUT(lpClassId, CLSID);

    *lpClassId = CLSID_PointerMoniker;
    return S_OK;
}





        

//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::GetUnmarshalClass
//
//  Synopsis:   Return the unmarshaling class
//
//  Arguments:  [riid]
//              [pv]
//              [dwMemctx]
//              [pvMemctx]
//              [mshlflags]
//              [pClsid]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::GetUnmarshalClass(THIS_ REFIID riid,
                                                LPVOID pv,
                                                DWORD dwMemctx,
                                                LPVOID pvMemctx,
                                                DWORD mshlflags,
                                                LPCLSID pClsid)
{
    M_PROLOG(this);

    // ronans - objref moniker changes
    return GetClassID(pClsid);
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::GetMarshalSizeMax
//
//  Synopsis:   Return the maximum stream size needed
//
//  Arguments:  [riid]
//              [pv]
//              [dwMemctx]
//              [pvMemctx]
//              [mshlflags]
//              [lpdwSize]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::GetMarshalSizeMax(THIS_ REFIID riid,
                                                LPVOID pv,
                                                DWORD dwMemctx,
                                                LPVOID pvMemctx,
                                                DWORD mshlflags,
                                                LPDWORD lpdwSize)
{
    M_PROLOG(this);

    
    return CoGetMarshalSizeMax(lpdwSize, riid, m_pUnk, dwMemctx,
                               pvMemctx, mshlflags);
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::MarshalInterface
//
//  Synopsis:   Marshal the object we're wrapping
//
//  Arguments:  [pStm]
//              [riid]
//              [pv]
//              [dwMemctx]
//              [pvMemctx]
//              [mshlflags]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::MarshalInterface(THIS_ LPSTREAM pStm,
                                               REFIID riid,
                                               LPVOID pv,
                                               DWORD dwMemctx,
                                               LPVOID pvMemctx,
                                               DWORD mshlflags)
{
    HRESULT hr;
    LPVOID  pUnk;
    
    M_PROLOG(this);

    // Make sure we support the requested interface
    if (FAILED(hr = QueryInterface(riid, &pUnk)))
    {
        return hr;
    }
    Release();

    // Marshal the wrapped object
    hr = CoMarshalInterface(pStm,
                            IID_IUnknown,
                            m_pUnk,
                            dwMemctx,
                            pvMemctx,
                            mshlflags);
    return hr;
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::UnmarshalInterface
//
//  Synopsis:   Unmarshal the object we're wrapping
//
//  Arguments:  [pStm]
//              [riid]
//              [ppv]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::UnmarshalInterface(THIS_ LPSTREAM pStm,
                                                 REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    LPVOID  pUnk;
    
    M_PROLOG(this);

    // Unmarshal the object we're wrapping
    if (FAILED(hr = CoUnmarshalInterface(pStm, IID_IUnknown,
                                         (LPVOID *) &m_pUnk)))
    {
        return hr;
    }

    // Make sure we support the requested interface - this also takes
    // the reference we need
    if (FAILED(hr = QueryInterface(riid, &pUnk)))
    {
        return hr;
    }

    // Return ourselves as the unmarshaled object
    *ppv = this;

    return S_OK;
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::ReleaseMarshalData
//
//  Synopsis:   Don't do anything
//
//  Arguments:  [pStm]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::ReleaseMarshalData(THIS_ LPSTREAM pStm)
{
    M_PROLOG(this);

    return CoReleaseMarshalData(pStm);;
}







//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::DisconnectObject
//
//  Synopsis:   Don't do anything
//
//  Arguments:  [pStm]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::DisconnectObject(THIS_ DWORD dwReserved)
{
    M_PROLOG(this);

    return CoDisconnectObject(m_pUnk, NULL);
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::BindToObject
//
//  Synopsis:   
//
//  Arguments:  [pbc]
//              [pmkToLeft]
//              [iidResult]
//              [ppvResult]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::BindToObject ( LPBC pbc,
	LPMONIKER pmkToLeft, REFIID iidResult,
	VOID **ppvResult)
{
    HRESULT        hr;
    LARGE_INTEGER  cMove = {0, 0};

    M_PROLOG(this);
    VDATEPTROUT(ppvResult, LPVOID);
    *ppvResult = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    VDATEIID(iidResult);
    
    // Attempt to return the requested interface
    if (m_pUnk)
    {
        return m_pUnk->QueryInterface(iidResult, ppvResult);
    }

    // No object
    return E_UNEXPECTED;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::BindToStorage
//
//  Synopsis:   
//
//  Arguments:  [lpbc]
//              [pmkToLeft]
//              [riid]
//              [ppvResult]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::BindToStorage (LPBC pbc, LPMONIKER
	pmkToLeft, REFIID riid, LPVOID *ppvObj)
{
    M_PROLOG(this);

    // Same logic as for BindToStorage
    return BindToObject(pbc, pmkToLeft, riid, ppvObj);
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::ComposeWith
//
//  Synopsis:   
//
//  Arguments:  [pmkRight]
//              [fOnlyIfNotGeneric]
//              [ppmkComposite]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::ComposeWith (LPMONIKER pmkRight,
	BOOL fOnlyIfNotGeneric, LPMONIKER *ppmkComposite)
{

    VDATEPTROUT(ppmkComposite,LPMONIKER);
    *ppmkComposite = NULL;
    VDATEIFACE(pmkRight);

    HRESULT hresult = NOERROR;

    //
    // If this is an AntiMoniker, then we are going to ask the AntiMoniker
    // for the composite. This is a backward compatibility problem. Check
    // out the CAntiMoniker::EatOne() routine for details.
    //

    CAntiMoniker *pCAM = IsAntiMoniker(pmkRight);
    if (pCAM)
    {
	pCAM->EatOne(ppmkComposite);
    }
    else
    {
	if (!fOnlyIfNotGeneric)
	{
	    hresult = CreateGenericComposite( this, pmkRight, ppmkComposite );	
	}
	else
	{
	    hresult = ResultFromScode(MK_E_NEEDGENERIC);
	    *ppmkComposite = NULL;
	}
    }
    return hresult;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::IsEqual
//
//  Synopsis:   
//
//  Arguments:  [pmkOtherMoniker]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::IsEqual  (THIS_ LPMONIKER pmkOtherMoniker)
{
    M_PROLOG(this);
    VDATEIFACE(pmkOtherMoniker);

    CPointerMoniker FAR* pCIM = IsPointerMoniker(pmkOtherMoniker);
    if (pCIM)
    {
        // the other moniker is a ptr moniker.
        if (m_pUnk == pCIM->m_pUnk)
        {
            return S_OK;
        }
    }

    return S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::Hash
//
//  Synopsis:   
//
//  Arguments:  [pdwHash]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::Hash  (THIS_ LPDWORD pdwHash)
{
    M_PROLOG(this);
    VDATEPTROUT(pdwHash, DWORD);

//
// REVIEW Sundown - v-thief 06/98:
//
//    In this first pass, I have considered Hash values are DWORDs for all the class members/methods.
//    This has to be checked with ScottRob or RickHi especially in terms of consumers.
//
    *pdwHash = PtrToUlong(m_pUnk);	
    noError;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::GetTimeOfLastChange
//
//  Synopsis:   
//
//  Arguments:  [pbc]
//              [pmkToLeft]
//              [pFileTime]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::GetTimeOfLastChange(THIS_ LPBC pbc,
                                                  LPMONIKER pmkToLeft,
                                                  FILETIME *pfiletime)
{
    M_PROLOG(this);
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    VDATEPTROUT(pfiletime, FILETIME);

    return E_NOTIMPL; // GetTimeOfLastChange not implemented
                      // for pointer monikers
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::Inverse
//
//  Synopsis:   
//
//  Arguments:  [ppmk]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::Inverse  (THIS_ LPMONIKER *ppmk)
{
    M_PROLOG(this);
    VDATEPTROUT(ppmk, LPMONIKER);
    return CreateAntiMoniker(ppmk);
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::CommonPrefixWith
//
//  Synopsis:   
//
//  Arguments:  [pmkOther]
//              [ppmkPrefix]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::CommonPrefixWith	(LPMONIKER pmkOther,
                                                 LPMONIKER *ppmkPrefix)
{
    M_PROLOG(this);
    VDATEPTROUT(ppmkPrefix,LPMONIKER);
    *ppmkPrefix = NULL;
    VDATEIFACE(pmkOther);

    if (S_OK == IsEqual(pmkOther))
    {
        *ppmkPrefix = this;
        AddRef();
        return MK_S_US;
    }
    
    return MK_E_NOPREFIX;
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::RelativePathTo
//
//  Synopsis:   
//
//  Arguments:  [pmkOther]
//              [ppmkRelPath]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::RelativePathTo  (THIS_ LPMONIKER pmkOther,
                                               LPMONIKER *ppmkRelPath)
{
    M_PROLOG(this);
    VDATEPTROUT(ppmkRelPath, LPMONIKER);
    *ppmkRelPath = NULL;
    VDATEIFACE(pmkOther);
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::GetDisplayName
//
//  Synopsis:   
//
//  Arguments:  [pbc]
//              [pmkToLeft]
//              [lplpszisplayName]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::GetDisplayName (LPBC pbc,
                                              LPMONIKER pmkToLeft,
                                              LPWSTR  *lplpszDisplayName )
{
    M_PROLOG(this);
    VDATEPTROUT(lplpszDisplayName, LPWSTR);
    *lplpszDisplayName = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }

    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::ParseDisplayName
//
//  Synopsis:   
//
//  Arguments:  [pbc]
//              [pmkToLeft]
//              [lpszDisplayName]
//              [pchEaten]
//              [ppmkOut]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::ParseDisplayName (LPBC pbc,
                                                LPMONIKER pmkToLeft,
                                                LPWSTR lpszDisplayName,
                                                ULONG *pchEaten,
                                                LPMONIKER *ppmkOut)
{
    M_PROLOG(this);
    VDATEPTROUT(ppmkOut,LPMONIKER);
    *ppmkOut = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    VDATEPTRIN(lpszDisplayName, WCHAR);
    VDATEPTROUT(pchEaten,ULONG);

    IParseDisplayName FAR * lpPDN;
    HRESULT hresult;

    hresult = m_pUnk->QueryInterface(IID_IParseDisplayName, (LPLPVOID)&lpPDN);
    if (hresult == S_OK)
    {
        hresult = lpPDN->ParseDisplayName(pbc, lpszDisplayName,
                                          pchEaten, ppmkOut);
        lpPDN->Release();
    }

    return hresult;
}








//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::IsRunning
//
//  Synopsis:   Objects that pointer monikers point to must be running, since
//		the pointer moniker holds an active reference to it.
//		Therefore, this routine will validate the parameters, then
//		always return S_OK.
//
//  Effects:
//
//  Arguments:  [pbc] --
//		[pmkToLeft] --
//		[pmkNewlyRunning] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    3-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::IsRunning (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
	      LPMONIKER pmkNewlyRunning)
{
    M_PROLOG(this);
    VDATEIFACE (pbc);
    if (pmkToLeft)
    {
	VDATEIFACE (pmkToLeft);
    }

    if (pmkNewlyRunning)
    {
	VDATEIFACE (pmkNewlyRunning);
    }

    //
    // Always running.
    //
    return(S_OK);
}











//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::IsSystemMoniker
//
//  Synopsis:   
//
//  Arguments:  [pdwType]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP CPointerMoniker::IsSystemMoniker  (THIS_ LPDWORD pdwType)
{
    M_PROLOG(this);
    *pdwType = MKSYS_POINTERMONIKER;
    return S_OK;		
}


STDMETHODIMP CPointerMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::CDebug::Dump
//
//  Synopsis:   
//
//  Arguments:  [riid]
//              [ppvObj]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
#ifdef _DEBUG
STDMETHODIMP_(void) NC(CPointerMoniker,CDebug)::Dump ( IDebugStream *pdbstm)
{
    VOID_VDATEIFACE( pdbstm );
	
    *pdbstm << "CPointerMoniker @" << (VOID FAR *)m_pPointerMoniker;
    *pdbstm << '\n';
    pdbstm->Indent();
    *pdbstm << "Refcount is " << (int)(m_pPointerMoniker->m_refs) << '\n';
    *pdbstm << "Pointer is " << (LPVOID)m_pPointerMoniker->m_pUnk << '\n';
    pdbstm->UnIndent();
}









//+---------------------------------------------------------------------------
//
//  Method:     CPointerMoniker::CDebug::IsValid
//
//  Synopsis:   
//
//  Arguments:  [fSuspicious]
//
//  Returns:    
//
//  Algorithm:
//
//  History:    06-Jul-95  BruceMa      Added this header
//
//----------------------------------------------------------------------------
STDMETHODIMP_(BOOL) NC(CPointerMoniker,CDebug)::IsValid ( BOOL fSuspicious )
{
    return ((LONG)(m_pPointerMoniker->m_refs) > 0);
    //	add more later, maybe
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\csessmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       csessmon.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-25-98   GilleG    Created
//
//  The purpose of a Session moniker is to active an object on a given
//  session id.
//
//
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include <cbasemon.hxx>
#include <csessmon.hxx>
#include <immact.hxx>
#include "mnk.h"


#define SESSION_MONIKER_NAME L"Session:"
#define SESSION_MONIKER_DELIMITER L"!"
#define CONSOLE_SESSION_TOKEN L"Console"

//+---------------------------------------------------------------------------
//
//  Function:   FindSessionMoniker
//
//  Synopsis:   Interpreting a display name as a SessionID, derive a
//              moniker from it.
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//
//  Returns:    S_OK if successful
//              MK_E_UNAVAILABLE or the return value from ParseDisplayName.
//
//  Algorithm:  Parse the first part of the display name to see if it's a
//              session moniker and create a session moniker.
//
//----------------------------------------------------------------------------
STDAPI FindSessionMoniker(
    IBindCtx * pbc,
    LPCWSTR    pszDisplayName,
    ULONG    * pcchEaten,
    IMoniker **ppmk)
{
    HRESULT      hr = S_OK;
    WCHAR*       pwch;
    ULONG        ullength;
    ULONG        ulchcount;
    ULONG        ulSessionID = 0;
    BOOL         bUseConsole = FALSE;

    mnkDebugOut((DEB_ITRACE,
                "FindSessionMoniker(%x,%ws,%x,%x)\n",
                pbc, pszDisplayName, pcchEaten, ppmk));

    *ppmk = NULL;
    ulchcount = 0;

    ullength = sizeof (SESSION_MONIKER_NAME) / sizeof (WCHAR) - 1;

    //
    // We now support two different syntaxes:
    //
    //  "Session:XX" -- where XX is a numeric session id
    //  "Session:Console" -- this means direct the activation to the
    //       currently active TS user session.
    //
    if(_wcsnicmp(pszDisplayName, SESSION_MONIKER_NAME, ullength ) == 0)
    {
        WCHAR* pwchTmp;
        pwch = (LPWSTR)pszDisplayName + ullength;
        ulchcount = ullength;
        
        ullength = sizeof (CONSOLE_SESSION_TOKEN) / sizeof (WCHAR) - 1;

        // First look for "Console"
        if (_wcsnicmp(pwch, CONSOLE_SESSION_TOKEN, ullength) == 0) 
        {
            pwchTmp = pwch + ullength;

            if ((*pwchTmp == L'\0') || (*pwchTmp == L'!')) 
            {
                ulchcount += ullength;
                
                if (*pwchTmp == L'!') 
                {
                    ulchcount++;
                }
                
                ulSessionID = 0; // doesn't matter, but init it anyway
                bUseConsole = TRUE;

            } 
            else 
            {
                hr = MK_E_UNAVAILABLE;
                ulchcount = 0;
            }
        } 
        else 
        {
            // else it must be the original syntax

            //
            // verify that we've got a correct session id
            //
            ulSessionID = wcstoul( pwch, &pwchTmp, 10 );
            if ((*pwchTmp == L'\0') || (*pwchTmp == L'!')) 
            {

                ulchcount += (ULONG)((ULONG_PTR)pwchTmp - (ULONG_PTR)pwch)/sizeof(WCHAR);

                if (*pwchTmp == L'!') 
                {
                    ulchcount++;
                }

                bUseConsole = FALSE;  // user was specific

            } 
            else 
            {
                hr = MK_E_UNAVAILABLE;
                ulchcount = 0;
            }
        }
    } 
    else 
    {
        hr = MK_E_UNAVAILABLE;
    }
    
    if (hr == S_OK) 
    {
        CSessionMoniker *pCSM = new CSessionMoniker( ulSessionID, bUseConsole );
        if (pCSM) 
        {
            *ppmk = pCSM;
            hr = S_OK;
        } 
        else 
        {
            hr = E_OUTOFMEMORY;
            ulchcount = 0;                          
        }
    }

    *pcchEaten = ulchcount;

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::QueryInterface
//
//  Synopsis:   Gets a pointer to the specified interface.  The session
//              moniker supports the IMarshal, IMoniker, IPersistStream,
//              IPersist, IROTData, IClassActivator and IUnknown interfaces.
//              The session moniker also supports CLSID_SessionMoniker so that
//              the IsEqual method can directly access the data members.
//
//  Arguments:  [iid] -- the requested interface
//              [ppv] -- where to put the interface pointer
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//  Notes:      Bad parameters will raise an exception.  The exception
//              handler catches exceptions and returns E_INVALIDARG.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::QueryInterface(
    REFIID riid,
    void **ppv)
{
    HRESULT hr;

    __try
    {
        mnkDebugOut((DEB_ITRACE,
                    "CSessionMoniker::QueryInterface(%x,%I,%x)\n",
                    this, &riid, ppv));

        //Parameter validation.
        *ppv = NULL;

        // assume success
        hr = S_OK;

        if (IsEqualIID(riid, IID_IClassActivator))
        {
            AddRef();
            *ppv = (IClassActivator *)this;
        }
        // not supported by the CBaseMoniker::QueryInterface
        else if (IsEqualIID(riid, IID_IPersist))
        {
            AddRef();
            *ppv = (IMoniker *) this;
        }
        else if (IsEqualIID(riid, CLSID_SessionMoniker))
        {
            AddRef();
            *ppv = (CSessionMoniker *) this;
        }
        else
        {
            hr = CBaseMoniker::QueryInterface(riid, ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetClassID
//
//  Synopsis:   Gets the class ID of the object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetClassID(
    CLSID *pClassID)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::GetClassID(%x,%x)\n",
                this, pClassID));

    __try
    {

        *pClassID = CLSID_SessionMoniker;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::Load
//
//  Synopsis:   Loads a session moniker from a stream
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::Load(
    IStream *pStream)
{
    HRESULT hr;
    ULONG   cbRead;
    DWORD   sessionid;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::Load(%x,%x)\n",
                this, pStream));

    __try
    {
        hr = pStream->Read(&sessionid, sizeof(sessionid), &cbRead);

        if(SUCCEEDED(hr))
        {
            if(sizeof(sessionid) == cbRead)
            {
                m_sessionid = sessionid;
                hr = S_OK;
            }
            else
            {
                hr = STG_E_READFAULT;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::Save
//
//  Synopsis:   Saves the session moniker to a stream
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::Save(
    IStream *pStream,
    BOOL     fClearDirty)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::Save(%x,%x,%x)\n",
                this, pStream, fClearDirty));

    __try
    {
        hr = pStream->Write(&m_sessionid, sizeof(m_sessionid), NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetSizeMax
//
//  Synopsis:   Get the maximum size required to serialize this moniker
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetSizeMax(
    ULARGE_INTEGER * pcbSize)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::GetSizeMax(%x,%x)\n",
                this, pcbSize));

    __try
    {
        ULISet32(*pcbSize, sizeof(CLSID) + sizeof(m_sessionid));
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::BindToObject
//
//  Synopsis:   Bind to the session specified by this moniker.
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSessionMoniker::BindToObject (
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    riid,
    void **   ppv)
{
    HRESULT    hr;

    __try
    {
        mnkDebugOut((DEB_ITRACE,
                    "CSessionMoniker::BindToObject(%x,%x,%x,%I,%x)\n",
                    this, pbc, pmkToLeft, &riid, ppv));

        //Validate parameters
        *ppv = NULL;


        //
        // This is being called by the ClassMoniker.
        // The actual binding is done in GetClassObject
        //
        if (riid == IID_IClassActivator) 
        {
            m_bindopts2.cbStruct = sizeof(BIND_OPTS2);

            hr = pbc->GetBindOptions(&m_bindopts2);
            if (SUCCEEDED(hr))
            {              
              m_bHaveBindOpts = TRUE;
              AddRef();
              *ppv = (IClassActivator*)this;
            }

        } else {

            hr = E_NOINTERFACE;

        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::BindToStorage
//
//  Synopsis:   Bind to the storage for the session specified by the moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::BindToStorage(
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    riid,
    void **   ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::BindToStorage(%x,%x,%x,%I,%x)\n",
                this, pbc, pmkToLeft, &riid, ppv));

    hr = BindToObject(pbc, pmkToLeft, riid, ppv);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::ComposeWith
//
//  Synopsis:   Compose this moniker with another moniker.
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::ComposeWith(
    IMoniker * pmkRight,
    BOOL       fOnlyIfNotGeneric,
    IMoniker **ppmkComposite)
{
    HRESULT   hr;
    IMoniker *pmk;

    mnkDebugOut((DEB_ITRACE,
          "CSessionMoniker::ComposeWith(%x,%x,%x,%x)\n",
          this, pmkRight, fOnlyIfNotGeneric, ppmkComposite));

    __try
    {
        //Validate parameters.
        *ppmkComposite = NULL;

        //Check for an anti-moniker
        hr = pmkRight->QueryInterface(CLSID_AntiMoniker, (void **)&pmk);

        if(FAILED(hr))
        {
          //pmkRight is not an anti-moniker.
          if (!fOnlyIfNotGeneric)
          {
              hr = CreateGenericComposite(this, pmkRight, ppmkComposite);
          }
          else
          {
              hr = MK_E_NEEDGENERIC;
          }
        }
        else
        {
          //pmkRight is an anti-moniker.
          pmk->Release();
          hr = S_OK;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::IsEqual
//
//  Synopsis:   Compares with another moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::IsEqual(
    IMoniker *pmkOtherMoniker)
{
    HRESULT        hr;
    CSessionMoniker *pSessionMoniker;

    mnkDebugOut((DEB_ITRACE,
                 "CSessionMoniker::IsEqual(%x,pmkOther(%x))\n",
                 this,
                 pmkOtherMoniker));

    __try
    {
        hr = pmkOtherMoniker->QueryInterface(CLSID_SessionMoniker,
                                      (void **) &pSessionMoniker);

        if(SUCCEEDED(hr))
        {
            if( m_sessionid == pSessionMoniker->m_sessionid )
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }

            pSessionMoniker->Release();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;

}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::Hash
//
//  Synopsis:   Computes a hash value
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::Hash(
    DWORD * pdwHash)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::Hash(%x,%x)\n",
                this, pdwHash));

    __try
    {
        *pdwHash = m_sessionid;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetTimeOfLastChange
//
//  Synopsis:  Returns the time when the object identified by this moniker
//             was changed.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetTimeOfLastChange (
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    FILETIME * pFileTime)
{
    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::GetTimeOfLastChange(%x,%x,%x,%x)\n",
                this, pbc, pmkToLeft, pFileTime));

    return MK_E_UNAVAILABLE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::Inverse
//
//  Synopsis:  Returns the inverse of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::Inverse(
    IMoniker ** ppmk)
{
    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::Inverse(%x,%x)\n",
                this, ppmk));

    return CreateAntiMoniker(ppmk);
}



//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::CommonPrefixWith
//
//  Synopsis:  Returns the common prefix shared by this moniker and the
//             other moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::CommonPrefixWith(
    IMoniker *  pmkOther,
    IMoniker ** ppmkPrefix)
{
    HRESULT        hr;
    CSessionMoniker *pSessionMoniker;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::CommonPrefixWith(%x,%x,%x)\n",
                this, pmkOther, ppmkPrefix));

    __try
    {
        //Validate parameters.
        *ppmkPrefix = NULL;

        hr = pmkOther->QueryInterface(CLSID_SessionMoniker,
                                      (void **) &pSessionMoniker);

        if(SUCCEEDED(hr))
        {
            if( m_sessionid == pSessionMoniker->m_sessionid )
            {
                AddRef();
                *ppmkPrefix = (IMoniker *) this;
                hr = MK_S_US;
            }
            else
            {
                hr = MK_E_NOPREFIX;
            }

            pSessionMoniker->Release();
        }
        else
        {
            hr = MonikerCommonPrefixWith(this, pmkOther, ppmkPrefix);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetDisplayName
//
//  Synopsis:   Get the display name of this moniker.
//
//  Notes:      The name is returned in the format:
//              "Session:3" if the session id is 3.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetDisplayName(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    LPWSTR   * lplpszDisplayName)
{
    HRESULT hr = E_FAIL;
    LPWSTR pszDisplayName;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::GetDisplayName(%x,%x,pmkLeft(%x),%x)\n",
                this, pbc, pmkToLeft, lplpszDisplayName));

    __try
    {
        WCHAR szSessionID[20];
        ULONG cName;

        //Validate parameters.
        *lplpszDisplayName = NULL;

        //Create a display name from the session ID.
        //Get the session ID string.
        wsprintfW( szSessionID, L"%d", m_sessionid );

        cName = lstrlenW(SESSION_MONIKER_NAME) + lstrlenW(szSessionID) +
                lstrlenW(SESSION_MONIKER_DELIMITER) + 2;

        pszDisplayName = (LPWSTR) CoTaskMemAlloc(cName * sizeof(WCHAR));
        if(pszDisplayName != NULL)
        {
            lstrcpyW(pszDisplayName, SESSION_MONIKER_NAME);
            lstrcatW(pszDisplayName, szSessionID);

            lstrcatW(pszDisplayName, SESSION_MONIKER_DELIMITER);
            *lplpszDisplayName = pszDisplayName;
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::ParseDisplayName
//
//  Synopsis:   Parses the display name.
//
//  Algorithm:
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::ParseDisplayName (
    IBindCtx *  pbc,
    IMoniker *  pmkToLeft,
    LPWSTR      lpszDisplayName,
    ULONG    *  pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT      hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::ParseDisplayName(%x,%x,pmkLeft(%x),lpszDisplayName(%ws),%x,%x)\n",
                this, pbc, pmkToLeft, lpszDisplayName, pchEaten, ppmkOut));

    __try
    {
        //Validate parameters
        *ppmkOut = NULL;
        *pchEaten = 0;

        ULONG chEaten;
        IMoniker* pmkNext;

        //
        // Parse the remaining display name.
        //
        hr = MkParseDisplayName(pbc, lpszDisplayName, &chEaten, &pmkNext);

        if (SUCCEEDED(hr)) {
            *ppmkOut = pmkNext;
            *pchEaten = chEaten;
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::IsSystemMoniker
//
//  Synopsis:   Determines if this is one of the system supplied monikers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::IsSystemMoniker(
    DWORD * pdwType)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::IsSystemMoniker(%x,%x)\n",
                this, pdwType));

    __try
    {
        *pdwType = MKSYS_SESSIONMONIKER;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetComparisonData
//
//  Synopsis:   Gets comparison data for registration in the ROT
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetComparisonData(
    byte * pbData,
    ULONG  cbMax,
    DWORD *pcbData)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CSessionMoniker::GetComparisonData(%x,%x,%x,%x)\n",
                this, pbData, cbMax, pcbData));

    __try
    {
        *pcbData = 0;
        if(cbMax >= sizeof(CLSID_SessionMoniker) + sizeof(m_sessionid))
        {
            memcpy(pbData, &CLSID_SessionMoniker, sizeof(CLSID_SessionMoniker));
            memcpy(pbData + sizeof(CLSID_SessionMoniker), &m_sessionid, sizeof(m_sessionid));
            *pcbData = sizeof(CLSID_SessionMoniker) + sizeof(m_sessionid);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CSessionMoniker::GetClassObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP CSessionMoniker::GetClassObject(
    REFCLSID pClassID,
    DWORD dwClsContext,
    LCID locale,
    REFIID riid,
    void** ppv)
{
    HRESULT    hr;

    __try
    {
        mnkDebugOut((DEB_ITRACE,
                    "CSessionMoniker::GetClassObject(%x,%x,%x,%x,%I,%x)\n",
                    this, pClassID, dwClsContext, &locale, &riid, ppv));

        //Validate parameters
        *ppv = NULL;


        CComActivator *pComAct;
        ISpecialSystemProperties *pSSp;

        hr = CoCreateInstance( CLSID_ComActivator,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IStandardActivator,
                               (void **) &pComAct);
        if(SUCCEEDED(hr))
        {
            hr = pComAct->QueryInterface( IID_ISpecialSystemProperties,
                                          (void**) &pSSp );

            if(SUCCEEDED(hr))
            {
                // Pass in TRUE here since we want session moniker-specified 
                // id's to go off-machine:
                hr = pSSp->SetSessionId( m_sessionid, m_bUseConsoleSession, TRUE);

                if(SUCCEEDED(hr))
                {
                    hr = pComAct->StandardGetClassObject( pClassID,
                                                          dwClsContext,
                                                          m_bHaveBindOpts ? m_bindopts2.pServerInfo : NULL,
                                                          riid,
                                                          ppv );
                }

                pSSp->Release();
            }

            pComAct->Release();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\mkparse.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mkparse.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    06-Nov-92  jasonful  Created
//              12-27-93   ErikGav   Commented
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "ccompmon.hxx"
#include "citemmon.hxx"
#include "mnk.h"

// Moved here as a temporary measure since this macro is not used in 32 bit
#define RetErr(x) {HRESULT hresult; if (NOERROR != (hresult=(x))) {return hresult;}}

// INTERNAL Ole10_ParseMoniker
//
// If pmk is a file moniker or a file::item composite, then return
// the obvious strings in *pszFile and *pszItem.
// NOTE: these strings must be deleted.
// Return error if moniker is of some other type.
//
// Can pass NULL, meaning you don't care about the strings
//
INTERNAL Ole10_ParseMoniker
	(LPMONIKER pmk,
	LPWSTR FAR* pszFile,
	LPWSTR FAR* pszItem)
{
	LPWSTR	  szFile = NULL;
	LPWSTR	  szItem = NULL;
	LPMONIKER pmkFile= NULL;
	LPMONIKER pmkItem= NULL;
	HRESULT   hr 	 = ResultFromScode (E_UNSPEC);
	LPBC	pbc = NULL;

	CCompositeMoniker *pCMk = NULL;
	CItemMoniker	  *pIMk = NULL;

    if (pmk == NULL)
    {
		hr = ResultFromScode (E_UNSPEC);
		goto errRtn;
	}

	if (IsFileMoniker(pmk))
	{
		RetErr (CreateBindCtx(0, &pbc));
		Assert(pbc != NULL);
		if (NOERROR != pmk->GetDisplayName (pbc, NULL, &szFile))
		{
			Assert(szFile == NULL);
			CairoleAssert(0 && "Could not get Display name for file piece");
			goto errRtn;
		}
		// AssertOutPtrParam(NOERROR, szFile);
	}
	else if ((pCMk = IsCompositeMoniker(pmk)) != NULL)
	{
		pmkFile = pCMk->First();
		if (NULL==pmkFile)
		{
			CairoleAssert(0 && "Composite moniker does not have car");
			hr = ResultFromScode(E_UNSPEC);
			goto errRtn;	
		}
		// Is first piece a file moniker?
		if (IsFileMoniker (pmkFile))
		{
			RetErr (CreateBindCtx(0, &pbc));
			Assert(pbc != NULL);
			if (NOERROR != pmkFile->GetDisplayName (pbc, NULL, &szFile))
			{
				Assert(szFile == NULL);
				CairoleAssert(0 && "Could not get Display name for file piece");
				goto errRtn;
			}
			// AssertOutPtrParam(NOERROR, szFile);
		}
		else
		{
			CairoleAssert(0 && "First piece is not a file moniker");
			hr = NOERROR;
			goto errRtn;
		}

		// Get Item Moniker

		pmkItem = pCMk->AllButFirst();
		if (NULL==pmkItem)
		{
			CairoleAssert(0 && "Composite moniker does not have cdr");
			hr = ResultFromScode(E_UNSPEC);
			goto errRtn;	
		}
		if ((pIMk = IsItemMoniker (pmkItem)) != NULL)
		{
			// This is the case we want: FileMoniker :: ItemMoniker

			if (NULL==(szItem = pIMk->m_lpszItem))
			{
				CairoleAssert(0 && "Could not get string for item moniker");
				goto errRtn;
			}
			szItem = UtDupString (szItem); // so it'll be allocated like
 										  // an out parm from GetDisplayName
		}
		else
		{
			// This is the FileMoniker - ItemMoniker - ItemMoniker... case
			// We cannot convert this to 1.0
			hr = ResultFromScode(S_FALSE);
			goto errRtn;
		}
	}
	else
	{
		CairoleAssert(0 && "Cannot identify moniker type");
		hr = ResultFromScode (E_UNSPEC);
		goto errRtn;
	}

	if (pszFile)
		*pszFile = szFile;
	else
		CoTaskMemFree(szFile);

	if (pszItem)
		*pszItem = szItem;
	else
		CoTaskMemFree(szItem);

	if (pmkFile)
		pmkFile->Release();
	if (pmkItem)
		pmkItem->Release();

	if (pbc)
		pbc->Release();

	return NOERROR;

  errRtn:
	CoTaskMemFree(szFile);
	CoTaskMemFree(szItem);
	if (pmkFile)
		pmkFile->Release();
	if (pmkItem)
		pmkItem->Release();
	if (pbc)
		pbc->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   moniker
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..
INCLUDES=     $(INCLUDES);..\..\inc;..\..\rot;..\..\objact;
INCLUDES=     $(INCLUDES);..\..\dcomrem;..\..\..\actprops
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)
INCLUDES=     $(INCLUDES);$(DS_INC_PATH)

LINKLIBS=     ..\..\common\daytona\$(O)\common.lib

SOURCES=      \
              ..\cantimon.cxx \
              ..\cbindctx.cxx \
              ..\ccompmon.cxx \
              ..\cfactory.cxx \
              ..\cfilemon.cxx \
              ..\classmon.cxx \
              ..\extents.cxx \
              ..\citemmon.cxx \
              ..\cmonimp.cxx  \
              ..\cptrmon.cxx  \
              ..\mkparse.cxx  \
              ..\cbasemon.cxx \
              ..\cmarshal.cxx \
              ..\progress.cxx \
              ..\cdialog.cxx  \
              ..\cobjrmon.cxx \
              ..\csessmon.cxx


UMTYPE=       windows
!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\extents.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       extents.cxx
//
//  Contents:   Implmentation for CExtentList
//
//  Classes:	CExtentList
//
//  Functions:
//
//  History:    1-08-94   kevinro   Created
//              31-Jan-95 BruceMa   Set size to 0 if E_OUTOFMEMORY
//              17-Jul-95 BruceMa   Add mutex to protect AddExtent (Cairo only)
//              10-13-95  stevebl   moved mutex to CFileMoniker as part of
//                                  adding general threadsafety to monikers
//
//----------------------------------------------------------------------------
#include <ole2int.h>

#include "extents.hxx"
#include "mnk.h"


CExtentList::CExtentList():
    m_pchMonikerExtents(NULL),
     m_cbMonikerExtents(0)
{
    ;
}
CExtentList::~CExtentList()
{
    if (m_pchMonikerExtents != NULL)
    {
	CoTaskMemFree(m_pchMonikerExtents);
    }


}

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::Copy
//
//  Synopsis:   Make a copy of a CExtentList
//
//  Effects:
//
//  Arguments:  [newExtent] --	Recieving list
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CExtentList::Copy(CExtentList & newExtent)
{
    newExtent.m_cbMonikerExtents = m_cbMonikerExtents;
    newExtent.m_pchMonikerExtents = (BYTE *) CoTaskMemAlloc(m_cbMonikerExtents);

    if ( newExtent.m_pchMonikerExtents == NULL )
    {
        newExtent.m_cbMonikerExtents = 0;
	return(E_OUTOFMEMORY);
    }

    memcpy(newExtent.m_pchMonikerExtents,
	   m_pchMonikerExtents,
	   m_cbMonikerExtents);

    return(NOERROR);

}

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::FindExtent
//
//  Synopsis:   Searches the extent list, looking for a matching extent.
//
//  Effects:
//
//  Arguments:  [usKeyValue] --
//
//  Requires:
//
//  Returns:	NULL	not found
//		UNALIGNED POINTER to extent.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//  WARNINGS:
//
//  The pointer returned is not aligned.
//
//  The pointer will become invalide if an extent is added to the block.
//  This falls under the not multi-thread safe category. This is done for
//  efficiency reasons, since we don't ever expect to both add and lookup
//  at the same time.
//
//----------------------------------------------------------------------------
MONIKEREXTENT UNALIGNED *
CExtentList::FindExtent(USHORT usKeyValue)
{
    ULONG ulOffset = 0;

    while(ulOffset < m_cbMonikerExtents)
    {

	MONIKEREXTENT UNALIGNED *pExtent = (MONIKEREXTENT UNALIGNED *)
					  &m_pchMonikerExtents[ulOffset];

	//
	// There had better be enough bytes left to look at! If not, there
	// is some corruption in the extent block. Not much we can do about
	// it, other than return NULL
        // If the end minus the pointer is less than sizeof MONIKEREXTENT
        // we have a problem.

	if( (m_pchMonikerExtents + m_cbMonikerExtents) - ((BYTE*)pExtent ) <
            sizeof(MONIKEREXTENT) )
	{
	    return(NULL);
	}

	//
	// Get the key value from the buffer and compare against what we want.
	// Be careful about alignment here.
	//


	if (pExtent->usKeyValue == usKeyValue )
	{
	    return(pExtent);
	}

	ulOffset += MonikerExtentSize(pExtent);
    }
    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::DeleteExtent
//
//  Synopsis:   Deletes the given extent if it exists.
//
//  Effects:
//
//  Arguments:  [usKeyValue] --
//
//  Requires:
//
//  Returns:	S_OK -- found and deleted.
//              S_FALSE -- not found.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-95   BillMo   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifdef _TRACKLINK_
HRESULT
CExtentList::DeleteExtent(USHORT usKeyValue)
{
    MONIKEREXTENT UNALIGNED *pExtent = FindExtent(usKeyValue);
    BYTE *pbExtent = (BYTE *)pExtent;

    if (pExtent != NULL)
    {
        ULONG cbRemove = MonikerExtentSize(pExtent);
        BYTE * pbFrom = pbExtent + cbRemove;

        MoveMemory(pbExtent,
               pbFrom,
               m_cbMonikerExtents - (pbFrom - m_pchMonikerExtents));

        m_cbMonikerExtents -= cbRemove;
        return(S_OK);
    }
    return(S_FALSE);
}
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::AddExtent
//
//  Synopsis:   Adds an extent to the list. This function adds a copy
//		of the data.
//  Effects:
//
//  Arguments:  [pExtent] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CExtentList::AddExtent(MONIKEREXTENT const * pExtent)
{
    //
    // Reallocate the current buffer to make room for the new extent
    // The new extent is appended to the end of the current list.
    //

    ULONG	ulNewSize = m_cbMonikerExtents + MonikerExtentSize(pExtent);
    BYTE *	pchNewBuffer;

    pchNewBuffer =  (BYTE *)CoTaskMemRealloc(m_pchMonikerExtents,ulNewSize);

    if (pchNewBuffer == NULL)
    {
	return(E_OUTOFMEMORY);
    }

    m_pchMonikerExtents = pchNewBuffer;

    //
    // Append new extent
    //

    memcpy(m_pchMonikerExtents + m_cbMonikerExtents,
	   pExtent,
	   MonikerExtentSize(pExtent));

    m_cbMonikerExtents = ulNewSize;

    return(NOERROR);
}

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::PutExtent
//
//  Synopsis:   Deletes the extent (if it exists) and then adds it back.
//
//  Effects:
//
//  Arguments:  [pExtent] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-15-95   BillMo   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifdef _TRACKLINK_
HRESULT
CExtentList::PutExtent(MONIKEREXTENT const * pExtent)
{
    DeleteExtent(pExtent->usKeyValue);
    return(AddExtent(pExtent));
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   Save
//
//  Synopsis:   Save the extent to a stream
//
//  Effects:    Nice straightforward write of the entire blob to a stream
//
//  Arguments:  [pStm] -- Stream to write to
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CExtentList::Save(IStream * pStm)
{
    HRESULT hr;

    //
    // It must be true that both are zero, or neither is zero
    //

    Assert( ((m_cbMonikerExtents == 0) && (m_pchMonikerExtents == NULL)) ||
    	    ((m_pchMonikerExtents != NULL) && (m_cbMonikerExtents != 0)));

    //
    // First, write the length, then write the blob
    //
    hr = pStm->Write((void *)&m_cbMonikerExtents,
		     sizeof(m_cbMonikerExtents),
		     NULL);

    if (FAILED(hr))
    {
	return(hr);
    }

    //
    // Only write moniker extents if some exist
    //

    if (m_cbMonikerExtents != 0)
    {
	hr = pStm->Write((void *)m_pchMonikerExtents,
			 m_cbMonikerExtents,
			 NULL);
    }

    return(hr);

}

//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::Load
//
//  Synopsis:   Load the moniker extents from stream
//
//  Effects:
//
//  Arguments:  [pStm] -- Stream to load from
//		[ulSize] -- Size of extents, in bytes
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CExtentList::Load(IStream * pStm, ULONG ulSize)
{
    HRESULT hr;

    //
    // In the debugging verision, we should never have an extent larger
    // than say about 2k. This should catch any errors
    //

    Assert( ulSize < (2 * 1024));

    //
    // Be sure not to drop any memory. This normally should never happen.
    //

    if (m_pchMonikerExtents != NULL)
    {
	CoTaskMemFree(m_pchMonikerExtents);
    }

    m_cbMonikerExtents = ulSize;

    m_pchMonikerExtents = (BYTE *)CoTaskMemAlloc(m_cbMonikerExtents);

    if (m_pchMonikerExtents == NULL)
    {
        m_cbMonikerExtents = 0;
	return(E_OUTOFMEMORY);
    }

    hr = StRead(pStm, m_pchMonikerExtents, m_cbMonikerExtents);

    return(hr);

}
//+---------------------------------------------------------------------------
//
//  Method:     CExtentList::GetSize
//
//  Synopsis:	Returns the size needed to serialize this object
//
//  Effects:
//
//  Arguments:  [pcbSize] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
CExtentList::GetSize()
{
    return sizeof(m_cbMonikerExtents)+m_cbMonikerExtents;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\mnk.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       mnk.h
//
//  Contents:   Internal moniker functions
//
//  Classes:
//
//  Functions:
//
//  History:	12-27-93   ErikGav   Created
//		06-14-94   Rickhi    Fix type casting
//              12-01-95   MikeHill  Added prototype for ValidateBindOpts().
//
//----------------------------------------------------------------------------

INTERNAL_(DWORD) GetMonikerType( LPMONIKER pmk );

//  The following APIs determine if the given moniker is of the specified
//  class and if so, return a pointer to the C++ class IN A TYPE SAFE WAY!
//
//  NEVER do the casting directly, always use these APIs to do it for you!

class CCompositeMoniker;
class CPointerMoniker;
class CAntiMoniker;
class CFileMoniker;
class CItemMoniker;

INTERNAL_(CCompositeMoniker *) IsCompositeMoniker( LPMONIKER pmk );
INTERNAL_(CPointerMoniker *) IsPointerMoniker( LPMONIKER pmk );
INTERNAL_(CAntiMoniker *) IsAntiMoniker( LPMONIKER pmk );
INTERNAL_(CFileMoniker *) IsFileMoniker( LPMONIKER pmk );
INTERNAL_(CItemMoniker *) IsItemMoniker( LPMONIKER pmk );

STDAPI Concatenate( LPMONIKER pmkFirst, LPMONIKER pmkRest,
	LPMONIKER FAR* ppmkComposite );

#define BINDRES_INROTREG 1

#define DEF_ENDSERVER 0xFFFF

// STDAPI CreateOle1FileMoniker(LPWSTR, REFCLSID, LPMONIKER FAR*);

#ifdef _CAIRO_
extern
BOOL ValidateBindOpts( const LPBIND_OPTS pbind_opts );
#endif

extern
HRESULT DupWCHARString( LPCWSTR lpwcsString,
			LPWSTR & lpwcsOutput,
			USHORT & ccOutput);
extern
HRESULT ReadAnsiStringStream( IStream *pStm,
			      LPSTR & pszAnsiPath ,
			      USHORT &cbAnsiPath);
extern
HRESULT WriteAnsiStringStream( IStream *pStm,
			       LPSTR pszAnsiPath ,
			       ULONG cbAnsiPath);
extern
HRESULT MnkMultiToUnicode(LPSTR pszAnsiPath,
			  LPWSTR &pWidePath,
			  ULONG ccWidePath,
			  USHORT &ccNewString,
			  UINT nCodePage);
extern
HRESULT
MnkUnicodeToMulti(LPWSTR 	pwcsWidePath,
		  USHORT 	ccWidePath,
		  LPSTR &	pszAnsiPath,
		  USHORT &	cbAnsiPath,
		  BOOL &	fFastConvert);

extern
DWORD CalcFileMonikerHash(LPWSTR lp, ULONG cch);

extern
BOOL IsAbsoluteNonUNCPath (LPCWSTR szPath);

extern
BOOL IsAbsolutePath (LPCWSTR szPath);


#define WIDECHECK(x) (x?x:L"<NULL>")
#define ANSICHECK(x) (x?x:"<NULL>")


#if DBG == 1
    DECLARE_DEBUG(mnk)
#   define mnkDebugOut(x) mnkInlineDebugOut x
#   define mnkAssert(x)   Win4Assert(x)
#   define mnkVerify(x)	 mnkAssert(x)
#else
#   define mnkDebugOut(x)
#   define mnkAssert(x)
#   define mnkVerify(x) 	x

#endif

#define MNK_P_STREAMOP	0x01000000
#define MNK_P_RESOURCE  0x02000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\actapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       actapi.cxx
//
//  Contents:   Functions that activate objects residing in persistent storage.
//
//  Functions:  CoGetPersistentInstanceEx
//
//  History:    20-Sep-95  GregJen    Created
//              21-Oct-98  SteveSw    104665; 197253;
//                                    fix COM+ persistent activation
//
//--------------------------------------------------------------------------
#include <ole2int.h>

#include    <iface.h>
#include    <objsrv.h>
#include    <security.hxx>
#include    "resolver.hxx"
#include    "smstg.hxx"
#include    "objact.hxx"
#include    "clsctx.hxx"
#include    "immact.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   CoGetClassObject
//
//  Synopsis:   External entry point that returns an instantiated class object
//
//  Arguments:  [rclsid] - class id for class object
//              [dwContext] - kind of server we wish
//              [pvReserved] - Reserved for future use
//              [riid] - interface to bind class object
//              [ppvClassObj] - where to put interface pointer
//
//  Returns:    S_OK - successfully bound class object
//
//  Algorithm:  Validate all then parameters and then pass this to the
//              internal version of the call.
//
//  History:    11-May-93 Ricksa    Created
//              11-May-94 KevinRo   Added OLE 1.0 support
//              23-May-94 AlexT     Make sure we're initialized!
//              15-Nov-94 Ricksa    Split into external and internal calls
//
//--------------------------------------------------------------------------
STDAPI CoGetClassObject(
                       REFCLSID rclsid,
                       DWORD dwContext,
                       LPVOID pvReserved,
                       REFIID riid,
                       void FAR* FAR* ppvClassObj)
{
    // Make sure not being called from DllMain
    CoVrfDllMainCheck();

    OLETRACEIN((API_CoGetClassObject, PARAMFMT("rclsid= %I, dwContext= %x, pvReserved= %p, riid= %I, ppvClassObj= %p"),
                &rclsid, dwContext, pvReserved, &riid, ppvClassObj));

    HRESULT hr = CComActivator::DoGetClassObject(rclsid,
                                                 dwContext,
                                                 (COSERVERINFO *) pvReserved,
                                                 riid,
                                                 ppvClassObj,
                                                 NULL);


    OLETRACEOUT((API_CoGetClassObject, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoCreateInstance    (public)
//
//  Synopsis:   helper function to create instance in given context
//
//  Arguments:  [rclsid]    - the class of object to create
//              [pUnkOuter] - the controlling unknown (for aggregation)
//              [dwContext] - class context
//              [riid]      - interface id
//              [ppv]       - pointer for returned object
//
//  Returns:    REGDB_E_CLASSNOTREG, REGDB_E_READREGDB, REGDB_E_WRITEREGDB
//
//--------------------------------------------------------------------------
STDAPI CoCreateInstance(
    REFCLSID rclsid,
    LPUNKNOWN pUnkOuter,
    DWORD dwContext,
    REFIID riid,
    LPVOID * ppv)
{
    MULTI_QI    OneQI;
    HRESULT     hr;

    // Make sure not being called from DllMain
    CoVrfDllMainCheck();

    if (ppv == NULL) 
    {
        return E_INVALIDARG;
    }

    OneQI.pItf = NULL;
    OneQI.pIID = &riid;

    hr = CoCreateInstanceEx( rclsid, pUnkOuter, dwContext, NULL, 1, &OneQI );

    *ppv = OneQI.pItf;
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoCreateInstanceEx
//
//  Synopsis:   Returns an instantiated interface to an object
//
//
// Arguments:   [Clsid] - requested CLSID
//              [pServerInfo] - server information block
//              [punkOuter] - controlling unknown for aggregating
//              [dwCtrl] - kind of server required
//              [dwCount] - count of interfaces
//              [pResults] - MULTI_QI struct of interfaces
//
//  Returns:    S_OK - object bound successfully
//      MISSING
//
//
//--------------------------------------------------------------------------
STDAPI CoCreateInstanceEx(
    REFCLSID                    Clsid,
    IUnknown    *               punkOuter, // only relevant locally
    DWORD                       dwClsCtx,
    COSERVERINFO *              pServerInfo,
    DWORD                       dwCount,
    MULTI_QI        *           pResults )
{
    // Make sure not being called from DllMain
    CoVrfDllMainCheck();

    return CComActivator::DoCreateInstance(
                Clsid,
                punkOuter,
                dwClsCtx,
                pServerInfo,
                dwCount,
                pResults,
                NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   CoGetInstanceFromFile
//
//  Synopsis:   Returns an instantiated interface to an object whose
//              stored state resides on disk.
//
//  Arguments:  [pServerInfo] - server information block
//              [dwCtrl] - kind of server required
//              [grfMode] - how to open the storage if it is a file.
//              [pwszName] - name of storage if it is a file.
//              [pstg] - IStorage to use for object
//              [pclsidOverride]
//              [ppvUnk] - where to put bound interface pointer
//
//  Returns:    S_OK - object bound successfully
//      MISSING
//--------------------------------------------------------------------------

STDAPI CoGetInstanceFromFile(
    COSERVERINFO *              pServerInfo,
    CLSID       *               pclsidOverride,
    IUnknown    *               punkOuter, // only relevant locally
    DWORD                       dwClsCtx,
    DWORD                       grfMode,
    OLECHAR *                   pwszName,
    DWORD                       dwCount,
    MULTI_QI        *           pResults )
{
    // Make sure not being called from DllMain
    CoVrfDllMainCheck();

    return CComActivator::DoGetInstanceFromFile( pServerInfo,
                              pclsidOverride,
                              punkOuter,
                              dwClsCtx,
                              grfMode,
                              pwszName,
                              dwCount,
                              pResults ,
                              NULL);
}


//+-------------------------------------------------------------------------
//
//  Function:   CoGetInstanceFromIStorage
//
//  Synopsis:   Returns an instantiated interface to an object whose
//              stored state resides on disk.
//
//  Arguments:  [pServerInfo] - server information block
//              [dwCtrl] - kind of server required
//              [grfMode] - how to open the storage if it is a file.
//              [pwszName] - name of storage if it is a file.
//              [pstg] - IStorage to use for object
//              [pclsidOverride]
//              [ppvUnk] - where to put bound interface pointer
//
//  Returns:    S_OK - object bound successfully
//      MISSING
//
//--------------------------------------------------------------------------

STDAPI CoGetInstanceFromIStorage(
    COSERVERINFO *              pServerInfo,
    CLSID       *               pclsidOverride,
    IUnknown    *               punkOuter, // only relevant locally
    DWORD                       dwClsCtx,
    struct IStorage *           pstg,
    DWORD                       dwCount,
    MULTI_QI        *           pResults )
{
    // Make sure not being called from DllMain
    CoVrfDllMainCheck();

    return CComActivator::DoGetInstanceFromStorage( pServerInfo,
                            pclsidOverride,
                            punkOuter,
                            dwClsCtx,
                            pstg,
                            dwCount,
                            pResults,
                            NULL );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\actvator.cxx ===
//+-------------------------------------------------------------------
//
//  File:       actvator.cxx
//
//  Contents:   Implementation of client context system activator.
//
//  Classes:    CClientContextActivator
//
//  History:    21-Feb-98   SatishT     Created
//              22-Jun-98   CBiks       See comments in code.
//              27-Jun-98   CBiks       See RAID# 171549 and comments
//                                      in the code.
//              14-Sep-98   CBiks       Fixed RAID# 214719.
//              10-Oct-98   CBiks       Fixed RAID# 151056.
//              21-Oct-98   SteveSw     104665; 197253;
//                                      fix COM+ persistent activation
//              03-Nov-98   CBiks       Fix RAID# 231613.
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <actvator.hxx>
#include    <resolver.hxx>
#include    <dllcache.hxx>
#include    <objact.hxx>
#include    <marshal.hxx>
#include    <context.hxx>

#if DBG==1
// Debugging hack: set this to TRUE to break on unexpected failures
// in debug builds.
BOOL gfDebugHResult = FALSE;
#endif


//+------------------------------------------------------------------------
//
//  Secure references hash table buckets. This is defined as a global
//  so that we dont have to run any code to initialize the hash table.
//
//+------------------------------------------------------------------------
SHashChain ApartmentBuckets[23] =
{
    {&ApartmentBuckets[0],  &ApartmentBuckets[0]},
    {&ApartmentBuckets[1],  &ApartmentBuckets[1]},
    {&ApartmentBuckets[2],  &ApartmentBuckets[2]},
    {&ApartmentBuckets[3],  &ApartmentBuckets[3]},
    {&ApartmentBuckets[4],  &ApartmentBuckets[4]},
    {&ApartmentBuckets[5],  &ApartmentBuckets[5]},
    {&ApartmentBuckets[6],  &ApartmentBuckets[6]},
    {&ApartmentBuckets[7],  &ApartmentBuckets[7]},
    {&ApartmentBuckets[8],  &ApartmentBuckets[8]},
    {&ApartmentBuckets[9],  &ApartmentBuckets[9]},
    {&ApartmentBuckets[10], &ApartmentBuckets[10]},
    {&ApartmentBuckets[11], &ApartmentBuckets[11]},
    {&ApartmentBuckets[12], &ApartmentBuckets[12]},
    {&ApartmentBuckets[13], &ApartmentBuckets[13]},
    {&ApartmentBuckets[14], &ApartmentBuckets[14]},
    {&ApartmentBuckets[15], &ApartmentBuckets[15]},
    {&ApartmentBuckets[16], &ApartmentBuckets[16]},
    {&ApartmentBuckets[17], &ApartmentBuckets[17]},
    {&ApartmentBuckets[18], &ApartmentBuckets[18]},
    {&ApartmentBuckets[19], &ApartmentBuckets[19]},
    {&ApartmentBuckets[20], &ApartmentBuckets[20]},
    {&ApartmentBuckets[21], &ApartmentBuckets[21]},
    {&ApartmentBuckets[22], &ApartmentBuckets[22]}
};

CApartmentHashTable gApartmentTbl;    // global table of apartment entries
COleStaticMutexSem CApartmentHashTable::_mxsAptTblLock;

const GUID *GetPartitionIDForClassInfo(IComClassInfo *pCI);

//+--------------------------------------------------------------------------
//
//  Function:   CheckMemoryGate
//
//  Synopsis:   Helper function to check memory gate. This code must
//              be executed in two activators, so I wrote it as an inline
//              function to maintain brevity of activator code.
//
//  History:    01-Nov-99   a-sergiv    Created to implement Memory Gates
//
//----------------------------------------------------------------------------

HRESULT CheckMemoryGate(IUnknown *punk, ResourceGateId id)
{
	HRESULT hr = S_OK;
	IResourceGates *pResGates = NULL;

	if(punk->QueryInterface(IID_IResourceGates, (void**) &pResGates) == S_OK)
	{		
		BOOL bResult = TRUE;
		hr = pResGates->Test(id, &bResult);
		pResGates->Release();

		if(SUCCEEDED(hr) && !bResult)
		{
			// The gate said NO!
			hr = E_OUTOFMEMORY;
		}
		else
		{
			// Make it S_OK
			hr = S_OK;
		}
	}

	return hr;
}

//----------------------------------------------------------------------------
// CClientContextActivator Implementation.
//----------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Member:     CClientContextActivator::CheckInprocClass , private
//
//  Synopsis:   Check various parameters to determine if activation should be
//              inproc and clear the ClientContextOK flag if not
//
//  History:    21-Feb-98   SatishT     Created
//              04-Apr-98   CBiks       Added updated support for Wx86 that was removed
//                                      during the Com+ merge.
//              23-Jun-98   CBiks       See RAID# 169589.  Added activation
//                                      flags to NegotiateDllInstantiationProperties().
//
//              09-Oct-09   vinaykr     Changed to not give RSN priority
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientContextActivator::CheckInprocClass(
                    IActivationPropertiesIn *pInActProperties,
                    DLL_INSTANTIATION_PROPERTIES *pdip,
                    BOOL &bActivateInproc,
                    ILocalSystemActivator **ppAct)
{
    DWORD dwClsCtx;

    *ppAct = NULL;

    IComClassInfo *pClassInfo = NULL;
    IServerLocationInfo *pSrvLocInfo = NULL;
    HRESULT hrNegotiate = S_OK;

    ActivationPropertiesIn *pActIn=NULL;
    // This does not need to be released
    HRESULT hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );
    Win4Assert((hr == S_OK) && (pActIn != NULL));

    hr = pInActProperties->GetClsctx(&dwClsCtx);
    CHECK_HRESULT(hr);

    // This does not need to be released
    pClassInfo = pActIn->GetComClassInfo();
    Win4Assert(pClassInfo != NULL);

    // Pick up RSN from Server Location Info
    pSrvLocInfo = pActIn->GetServerLocationInfo();
    Win4Assert(pSrvLocInfo != NULL);
    PWSTR pwstrRSN = NULL;

    // Note that, by the memory management rules
    // of the catalog interfaces, this string is
    // a direct pointer to the buffer in the
    // properties object, and should not be deleted
    hr = pSrvLocInfo->GetRemoteServerName(&pwstrRSN);

    CLSID *pClsid;
    hr = pClassInfo->GetConfiguredClsid(&pClsid);

    if (dwClsCtx & CLSCTX_INPROC_MASK1632)
    {
        // Now see if the activation should occur INPROC

        //  CBiks, 10-Oct-98
        //      Cleaned up the code to let NegotiateDllInstantiationProperties()
        //      do all the work.

        DWORD actvflags;
        hr = pInActProperties->GetActivationFlags(&actvflags);
        CHECK_HRESULT(hr)

        hr = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties(
            dwClsCtx,
            actvflags,
            *pClsid,
            *pdip,
            pClassInfo,
            TRUE);

        bActivateInproc = SUCCEEDED(hr);

        // Propagate BADTHREADINGMODEL return code.
        if (REGDB_E_BADTHREADINGMODEL == hr)
            hrNegotiate = hr;

        hr = S_OK;

    }
    else
    {
        bActivateInproc = FALSE;
    }

    IActivationStageInfo *pStageInfo = (IActivationStageInfo*)pActIn;

    if (bActivateInproc)    // get ready for server process stage
    {
        pActIn->SetDip(pdip);
        hr = pStageInfo->SetStageAndIndex(SERVER_PROCESS_STAGE,0);
        CHECK_HRESULT(hr);
    }
    else
    {
        if (((dwClsCtx &
             ~(CLSCTX_INPROC_MASK1632|CLSCTX_NO_CODE_DOWNLOAD|CLSCTX_NO_CUSTOM_MARSHAL)) != 0) ||
            (pwstrRSN != NULL))
        {
            if (pwstrRSN == NULL)
            {
            //Try to intercept case where we are already running
            //in a complus server app for which this activation
            //is destined.
                GUID *pProcessGuid=NULL;
                if (CSurrogateActivator::AmIComplusProcess(&pProcessGuid))
                {
                    Win4Assert(pProcessGuid);
                    IClassClassicInfo *pIClassCI;
                    hr = pClassInfo->QueryInterface (IID_IClassClassicInfo,
                                     (void**) &pIClassCI );

                    if ((pIClassCI != NULL) &&
                        (SUCCEEDED(hr)))
                    {
                        IComProcessInfo *pProcessInfo;

                        hr = pIClassCI->GetProcess(IID_IComProcessInfo,
                                               (void**) &pProcessInfo);

                        pIClassCI->Release();

                        if (SUCCEEDED(hr) && pProcessInfo)
                        {

                            GUID *pGuid;
                            hr = pProcessInfo->GetProcessId(&pGuid);

                            HRESULT hr2 = S_OK;

                            if (SUCCEEDED(hr) &&
                                (*pGuid == *pProcessGuid))
                            {
                                bActivateInproc = TRUE;
                                //DebugBreak();
                                *ppAct = (ILocalSystemActivator*)
                                    CSurrogateActivator::GetSurrogateActivator();
                                Win4Assert(*ppAct);

                                DWORD actvflags;
                                hr2 = pInActProperties->GetActivationFlags(&actvflags);
                                CHECK_HRESULT(hr2)

                                hr2 = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties(
                                    CLSCTX_INPROC,
                                    actvflags,
                                    *pClsid,
                                    *pdip,
                                    pClassInfo,
                                    TRUE);

                                if (SUCCEEDED(hr2))
                                    pActIn->SetDip(pdip);

                            }

                            pProcessInfo->Release();

                            if (FAILED(hr2))
                            {
                                return hr2;
                            }
                        }
                    }

                    hr = S_OK;
                }
            }

            if (!bActivateInproc)
            {
            // get ready for client SCM stage
             ContextInfo *pActCtxInfo;

             pActCtxInfo = pActIn->GetContextInfo();
             Win4Assert(pActCtxInfo != NULL);

             hr = pActCtxInfo->SetClientContextNotOK();
             CHECK_HRESULT(hr);

             hr = pStageInfo->SetStageAndIndex(CLIENT_MACHINE_STAGE,0);
             CHECK_HRESULT(hr);
            }
        }
        else
        {
             hr = (hrNegotiate == S_OK) ? REGDB_E_CLASSNOTREG : hrNegotiate;
        }
    }



    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CClientContextActivator::GetClassObject , public
//
//  Synopsis:   Delegate to server process stage if the activation will be
//              completed inproc, otherwise, clear the ClientContextOK flag
//              and delegate to the client SCM stage.
//
//  History:    21-Feb-98   SatishT      Created
//              01-Nov-99   a-sergiv     Implemented Memory Gates
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientContextActivator::GetClassObject(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    ComDebOut((DEB_ACTIVATE, "CClientContextActivator::GetClassObject [IN]\n"));

    HRESULT hr;
    BOOL bActivateInproc;
    DLL_INSTANTIATION_PROPERTIES *pdip;
    int nRetries = 0;

    GETREFCOUNT(pInActProperties,__relCount__);

    ActivationPropertiesIn *pActIn=NULL;
    // This does not need to be released
    hr = pInActProperties->QueryInterface(
                                          CLSID_ActivationPropertiesIn,
                                          (LPVOID*)&pActIn
                                          );
    Win4Assert((hr == S_OK) && (pActIn != NULL));

RETRY_ACTIVATION:
	
    // Check CreateObjectMemoryGate
    hr = CheckMemoryGate(pActIn->GetComClassInfo(), CreateObjectMemoryGate);
    if(FAILED(hr)) goto exit_point;

    pdip = (DLL_INSTANTIATION_PROPERTIES *) pActIn->GetDip();
    if (!pdip)
    {
        pdip = (DLL_INSTANTIATION_PROPERTIES *) _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
        pdip->_pDCE = NULL;
    }


    ILocalSystemActivator *pAct;
    hr = CheckInprocClass(pInActProperties, pdip, bActivateInproc, &pAct);

    if (SUCCEEDED(hr))
    {
        if (bActivateInproc)    // just move to the process stage already set
        {
            if (pAct)
                hr = pAct->GetClassObject(pInActProperties,
                                          ppOutActProperties);
            else
	    {
	       hr = pInActProperties->DelegateGetClassObject(ppOutActProperties);
	       // Sajia-support for partitions
	       // If the delegated activation returns ERROR_RETRY,
	       // we walk the chain again, but AT MOST ONCE.
	       if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr) 
	       {
		  Win4Assert(!nRetries);
		  if (!nRetries)
		  {
		     nRetries++;
		     goto RETRY_ACTIVATION;
		  }
	       }
	    }
        }
        else
        {
            // Go to the SCM
            hr = gResolver.GetClassObject(
                                          pInActProperties,
                                          ppOutActProperties
                                          );
        }
    }

exit_point:

    CHECKREFCOUNT(pInActProperties,__relCount__);

    ComDebOut((DEB_ACTIVATE, "CClientContextActivator::GetClassObject [OUT] hr:%x\n", hr));

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CClientContextActivator::CreateInstance , public
//
//  Synopsis:
//
//  History:    21-Feb-98   SatishT      Created
//              01-Nov-99   a-sergiv     Implemented Memory Gates
//
//----------------------------------------------------------------------------
STDMETHODIMP CClientContextActivator::CreateInstance(
                    IN  IUnknown *pUnkOuter,
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    ComDebOut((DEB_ACTIVATE, "CClientContextActivator::CreateInstance [IN]\n"));
    
    HRESULT hr;
    BOOL bActivateInproc;
    DLL_INSTANTIATION_PROPERTIES *pdip;
    int nRetries = 0;
    
    GETREFCOUNT(pInActProperties,__relCount__);
    ActivationPropertiesIn *pActIn=NULL;

    // This does not need to be released
    hr = pInActProperties->QueryInterface(
                                CLSID_ActivationPropertiesIn,
                                (LPVOID*)&pActIn
                                );
    Win4Assert((hr == S_OK) && (pActIn != NULL));
    
RETRY_ACTIVATION:
    // Check CreateObjectMemoryGate
    hr = CheckMemoryGate(pActIn->GetComClassInfo(), CreateObjectMemoryGate);
    if(FAILED(hr)) goto exit_point;
    
    pdip = (DLL_INSTANTIATION_PROPERTIES *) pActIn->GetDip();
    if (!pdip)
    {
        pdip = (DLL_INSTANTIATION_PROPERTIES *) _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
        pdip->_pDCE = NULL;
    }
    
    ILocalSystemActivator *pAct;
    hr = CheckInprocClass(pInActProperties, pdip, bActivateInproc, &pAct);    
    if (SUCCEEDED(hr))
    {
        if (bActivateInproc)    // just move to the process stage already set
        {
            if (pAct)
            {
                hr = pAct->CreateInstance(pUnkOuter,
                                pInActProperties,
                                ppOutActProperties);
            }
            else
            {
                hr = pInActProperties->DelegateCreateInstance(pUnkOuter, ppOutActProperties);
                // Sajia-support for partitions
                // If the delegated activation returns ERROR_RETRY,
                // we walk the chain again, but AT MOST ONCE.
                if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr) 
                {
                    Win4Assert(!nRetries);
                    if (!nRetries)
                    {
                        nRetries++;
                        goto RETRY_ACTIVATION;
                    }
                }
            }
        }
        else
        {
            IInstanceInfo* pInstanceInfo = NULL;
            
            if ( pUnkOuter )    // can't send this to the SCM
            {
                hr = CLASS_E_NOAGGREGATION;
            }
            else if ( FAILED(pInActProperties->QueryInterface(IID_IInstanceInfo, (void**) &pInstanceInfo)) )
            {
                // Go to the SCM
                hr = gResolver.CreateInstance(
                                        pInActProperties,
                                        ppOutActProperties
                                        );
            }
            else
            {
                BOOL    FoundInROT  = FALSE;
                DWORD   cLoops      = 0;
                
                pInstanceInfo->Release();
                do
                {
                    hr = gResolver.GetPersistentInstance(pInActProperties, ppOutActProperties, &FoundInROT);
                }
                while ( (hr != S_OK) && (FoundInROT) && (++cLoops < 5) );
            }
        }
    }
    
    
exit_point:
    CHECKREFCOUNT(pInActProperties,__relCount__);
    
    ComDebOut((DEB_ACTIVATE, "CClientContextActivator::CreateInstance [OUT] hr:%x\n", hr));
    
    return hr;
}



//----------------------------------------------------------------------------
// CServerContextActivator Implementation.
//----------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Member:     CServerContextActivator::GetClassObject , public
//
//  Synopsis:
//
//  History:    21-Feb-98   SatishT     Created
//              22-Jun-98   CBiks       See RAID# 164432.  Added code to set
//                                      OleStubInvoked when Wx86 is calling so
//                                      whOleDllGetClassObject will allow
//                                      the return of unknown interfaces.
//                                      See RAID# 159589.  Added the activation
//                                      flags to ACTIVATION_PROPERTIES constructor.
//              12-Feb-01   JohnDoty    Widened ACTIVATION_PROPERTIES for partitions.
//
//----------------------------------------------------------------------------
STDMETHODIMP CServerContextActivator::GetClassObject(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    ComDebOut((DEB_ACTIVATE, "CServerContextActivator::GetClassObject [IN]\n"));

    CLSID *pClsid  = NULL;
    HRESULT hrSave = E_FAIL;

    ActivationPropertiesIn *pActIn=NULL;
    // This does not need to be released
    HRESULT hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );
    Win4Assert((hr == S_OK) && (pActIn != NULL));

    // This does not need to be released
    IComClassInfo *pComClassInfo;
    pComClassInfo = pActIn->GetComClassInfo();
    Win4Assert(pComClassInfo != NULL);

    hr = pComClassInfo->GetConfiguredClsid(&pClsid);
    CHECK_HRESULT(hr);
    Win4Assert(pClsid && "Configured class id missing in class info");

    DWORD ulCount = 0;
    IID *prgIID = NULL;
    IUnknown *pUnk = NULL;

    hr = pInActProperties->GetRequestedIIDs(&ulCount, &prgIID);
    CHECK_HRESULT(hr);
    Win4Assert(ulCount == 1);

    DWORD dwClsCtx = 0;

    DWORD actvflags;
    hr = pActIn->GetActivationFlags( &actvflags );
    CHECK_HRESULT(hr);


    // NOTE:  Do not change the IID passed below.  There are some objects in which
    //        IUnknown is broken and the object cannot be QI'd for the interface
    //        later.  The work around for these objects relies on this code
    //        asking for the correct IID when calling DllGetClassObject.

    DLL_INSTANTIATION_PROPERTIES *pdip = (DLL_INSTANTIATION_PROPERTIES *)pActIn->GetDip();
    if (pdip && pdip->_pDCE)
    {
        //
        // we have the cache line already, so just activate it
        //

        hr = hrSave = pdip->_pDCE->GetClassObject(*pClsid, prgIID[0], &pUnk, dwClsCtx);
    }
    else
    {
         if (pdip)
         {
             dwClsCtx = pdip->_dwContext;
         }
         else
         {
             hr = pInActProperties->GetClsctx(&dwClsCtx);
             CHECK_HRESULT(hr)
         }

         // Grab the partition ID, if possible.         
         const GUID *pguidPartition = GetPartitionIDForClassInfo(pComClassInfo);
         
         // This goes to the class cache to actually lookup the DPE and get the factory
         //
         ACTIVATION_PROPERTIES ap(*pClsid, 
                                  *pguidPartition,
                                  prgIID[0], 
                                  0, 
                                  dwClsCtx, 
                                  actvflags, 
                                  0,
                                  NULL, 
                                  &pUnk, 
                                  pComClassInfo);
         hr = hrSave = CCGetClassObject(ap);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Grammatik has reference counting problems.  The old class cache did
        // not call AddRef or Release before returning the object to the app.
        // We will special case Grammatik for the same behavior.
        //

        Win4Assert((pUnk != NULL) && "CCGetClassObject Succeeded but ..");
        hr = pInActProperties->GetReturnActivationProperties(pUnk,ppOutActProperties);


        if (!IsBrokenRefCount(pClsid))
        {
            // The out activation properties should have a ref on this
            pUnk->Release();
        }
    }

    ComDebOut((DEB_ACTIVATE, "CServerContextActivator::GetClassObject [OUT] hr:%x\n", hr));

    if (SUCCEEDED(hr))
    {
       Win4Assert(SUCCEEDED(hrSave));
       return hrSave;
    }
    else
    {
       return hr;
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CServerContextActivator::CreateInstance , public
//
//  Synopsis:
//
//  History:    21-Feb-98   SatishT     Created
//              22-Jun-98   CBiks       See RAID# 164432.  Added code to set
//                                      OleStubInvoked when Wx86 is calling so
//                                      whOleDllGetClassObject will allow
//                                      the return of unknown interfaces.
//                                      See RAID# 159589.  Added the activation
//                                      flags to ACTIVATION_PROPERTIES constructor.
//
//----------------------------------------------------------------------------
STDMETHODIMP CServerContextActivator::CreateInstance(
                    IN  IUnknown *pUnkOuter,
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    ComDebOut((DEB_ACTIVATE, "CServerContextActivator::CreateInstance [IN]\n"));

    CLSID *pClsid = NULL;

    // This does not need to be released
    ActivationPropertiesIn *pActIn=NULL;
    HRESULT hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );

    Win4Assert((hr == S_OK) && (pActIn != NULL));

    // This code checks to make sure we're not doing cross-context aggregation
    hr = CheckCrossContextAggregation (pActIn, pUnkOuter);
    if (FAILED (hr))
    {
        return hr;
    }

    // This does not need to be released
    IComClassInfo *pComClassInfo;
    pComClassInfo = pActIn->GetComClassInfo();
    Win4Assert(pComClassInfo != NULL);

    hr = pComClassInfo->GetConfiguredClsid(&pClsid);
    CHECK_HRESULT(hr);
    Win4Assert(pClsid && "Configured class id missing in class info");

    IClassFactory *pCF = NULL;
    IUnknown *pUnk = NULL;

    DWORD dwClsCtx = 0;

    DWORD actvflags;
    hr = pActIn->GetActivationFlags( &actvflags );
    CHECK_HRESULT(hr);

    DLL_INSTANTIATION_PROPERTIES *pdip = (DLL_INSTANTIATION_PROPERTIES *)pActIn->GetDip();
    if (pdip && pdip->_pDCE)
    {
        //
        // we have the cache line already, so just activate it
        //

        hr = pdip->_pDCE->GetClassObject(*pClsid, IID_IClassFactory,
                                         (IUnknown **) &pCF, dwClsCtx);
    }
    else
    {
        if (pdip)
        {
            dwClsCtx = ((DLL_INSTANTIATION_PROPERTIES *)pActIn->GetDip())->_dwContext;
        }
        else
        {
            hr = pInActProperties->GetClsctx(&dwClsCtx);
            CHECK_HRESULT(hr);            
        }

        // Grab the partition ID, if possible.
        const GUID *pguidPartition = GetPartitionIDForClassInfo(pComClassInfo);

        // This goes to the class cache to actually lookup the DPE and get the factory
        ACTIVATION_PROPERTIES ap(*pClsid, 
                                 *pguidPartition,
                                 IID_IClassFactory, 
                                 0, 
                                 dwClsCtx, 
                                 actvflags, 
                                 0, 
                                 NULL,
                                 (IUnknown **)&pCF, 
                                 pComClassInfo);
        hr = CCGetClassObject(ap);
    }

    if (SUCCEEDED(hr) && (NULL == pCF))
    {
        Win4Assert(!"Should have a pCF here but don't");
        hr = E_UNEXPECTED;
    }

    if (SUCCEEDED(hr))
    {
        DWORD ulCount = 0;
        IID *prgIID = NULL;

        // This mysterious piece of code is here to take care of VB4 which sometimes
        // produces "COM objects" that refuse to supply IUnknown when requested.
        //
        // jsimmons 5/21/00 -- in addition to handling buggy VB4 objects, people get 
        // upset when their class factory CreateInstance method is called and we don't
        // ask for the same IID that was passed to CoCreateInstance.
        hr = pInActProperties->GetRequestedIIDs(&ulCount, &prgIID);
        if (SUCCEEDED(hr))
        {
            for (DWORD i=0;i<ulCount; i++)
            {
                // 
                // Actually create the object
                //
                hr = pCF->CreateInstance(pUnkOuter, prgIID[i], (LPVOID*)&pUnk);
                if (SUCCEEDED(hr))
                {
                    if (pUnk == NULL)
                        CoVrfNotifyCFSuccessWithNULL(pCF, *pClsid, prgIID[i], hr);

                    break;
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        Win4Assert((pUnk != NULL) && "pCF->CreateInstance Succeeded but ..");

        // This not only sets the object interface, it also applies any constructors that
        // are required such as those involved in persistent instances
        hr = pActIn->GetReturnActivationPropertiesWithCF(pUnk,
                                                         pCF,
                                                         ppOutActProperties);

        // The out activation properties should have a ref on this
        pUnk->Release();
    }

    // If Activation Succeeded, Out Actprops should have reference on this
    if (pCF)
        pCF->Release();

    ComDebOut((DEB_ACTIVATE, "CServerContextActivator::CreateInstance [OUT] hr:%x\n", hr));

    return hr;
}

HRESULT CServerContextActivator::CheckCrossContextAggregation (
                                IN ActivationPropertiesIn *pActIn,
                                IN IUnknown* pUnkOuter
                                )
{
    CObjectContext* pCtx = NULL;
    CObjectContext* pClientCtxUnk = NULL;
    CObjectContext* pCurrentCtxUnk = NULL;
    ContextInfo *cInfo = NULL;
    CObjectContext *pContext = NULL;

    HRESULT hr = S_OK, hrRet = S_OK;

    // Short cut
    if (pUnkOuter == NULL)
    {
        return S_OK;
    }

    // This does not need to be released
    cInfo = pActIn->GetContextInfo();
    Win4Assert(cInfo != NULL);

    hr = cInfo->GetInternalClientContext(&pCtx);
    if (SUCCEEDED(hr) && pCtx)
    {
        hr = pCtx->InternalQueryInterface(IID_IUnknown, (void**) &pClientCtxUnk);
        pCtx->InternalRelease();
        pCtx = NULL;
    }
    if (SUCCEEDED(hr) && pClientCtxUnk)
    {
        pContext = GetCurrentContext();
        if (pContext)
        {
            hr = pContext->InternalQueryInterface(IID_IUnknown, (void**) &pCurrentCtxUnk);
            pContext = NULL;
        }
    }
    if (SUCCEEDED(hr) && pCurrentCtxUnk && pClientCtxUnk)
    {
        if (pClientCtxUnk != pCurrentCtxUnk)
        {
            hrRet = CLASS_E_NOAGGREGATION;
        }
    }

    if (pClientCtxUnk)
    {
        pClientCtxUnk->InternalRelease();
        pClientCtxUnk = NULL;
    }

    if (pCurrentCtxUnk)
    {
        pCurrentCtxUnk->InternalRelease();
        pCurrentCtxUnk = NULL;
    }

    return hrRet;
}

//----------------------------------------------------------------------------
// CProcessActivator Implementation.
//----------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Member:     CProcessActivator::GetApartmentActivator , private
//
//  Synopsis:   Check if a custom activator set the apartment and if not
//              call the class cache to find or create the default apartment
//              in which this class should run.
//
//  History:    25-Feb-98   SatishT     Created
//              23-Jun-98   CBiks       See RAID# 169589.  Added activation
//                                      flags to NegotiateDllInstantiationProperties().
//
//----------------------------------------------------------------------------
STDMETHODIMP CProcessActivator::GetApartmentActivator(
            IN  ActivationPropertiesIn *pInActProperties,
            OUT ISystemActivator      **ppActivator)
{
    HRESULT hr = E_FAIL;
    IServerLocationInfo *pSrvLoc;

    pSrvLoc = pInActProperties->GetServerLocationInfo();
    Win4Assert(pSrvLoc != NULL);

    HActivator hActivator = 0;

    hr = pSrvLoc->GetApartment(&hActivator);

    // HACK ALERT:  This should only be entered if hActivator==0
    // But in lieu of restructuring the DllCache to load the DLL in the
    // server context, we currently do this for all activations to make sure
    // that the DLL is actually loaded in the process and a ref is held to the
    // DllPathEntry until activation is either completed or aborted

    // The downsides of the hack are:
    // 1.  default DLL HOST based apartment created even when not needed
    // 2.  DLL unloading logic is broken because the DLL is validated in
    //     an apartment in which it may never be used

    {
        // none of the custom activators set the apartment

        // This code will find or create the default apartment
        // in which this class should run

        CLSID *pClsid = NULL;
        DWORD ClassContext;

        HActivator hStdActivator = 0;


        IComClassInfo *pComClassInfo = pInActProperties->GetComClassInfo();
        Win4Assert(pComClassInfo != NULL);

        hr = pComClassInfo->GetConfiguredClsid(&pClsid);
        CHECK_HRESULT(hr);
        Win4Assert(pClsid && "Configured class id missing in class info");

        DWORD actvflags;
        hr = pInActProperties->GetActivationFlags(&actvflags);
        CHECK_HRESULT(hr)

        DLL_INSTANTIATION_PROPERTIES *pdip =
            (DLL_INSTANTIATION_PROPERTIES *) pInActProperties->GetDip();

        if (!pdip)
        {
            //
            // this can happen in a surrogate activation
            //

            pdip = (DLL_INSTANTIATION_PROPERTIES *) _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
            pdip->_pDCE = NULL;
            hr = pInActProperties->GetClsctx(&(pdip->_dwContext));
            CHECK_HRESULT(hr)

            hr = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties(
                         pdip->_dwContext,
                         actvflags,
                         *pClsid,
                         *pdip,
                         pComClassInfo,
                         TRUE);
        }

        if (SUCCEEDED(hr))
        {
            // Go to the class cache for the apartment creation
            hr = FindOrCreateApartment(
                                       *pClsid,
                                       actvflags,
                                       pdip,
                                       &hStdActivator
                                       );


            // this is part of the HACK ALERT above
            if (SUCCEEDED(hr) && (hActivator == 0))
            {
                hActivator = hStdActivator;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        Win4Assert(hActivator != 0);

        if (CURRENT_APARTMENT_TOKEN != hActivator)
        {
            // cross apartment activation
            *ppActivator = NULL;
            hr = GetInterfaceFromStdGlobal(hActivator,
                                           IID_ISystemActivator,
                                           (LPVOID*)ppActivator);

            if (SUCCEEDED(hr))
            {
                // Since we are going cross apartment, the client context
                // won't do as the server context, so set the flag appropriately
                ContextInfo *pActCtxInfo = NULL;

                pActCtxInfo = pInActProperties->GetContextInfo();
                Win4Assert(pActCtxInfo != NULL);
                hr = pActCtxInfo->SetClientContextNotOK();
            }
        }
        else
        {
            // same apartment activation, just get the raw pointer
            *ppActivator = gApartmentActivator.GetSystemActivator();
        }
    }

    ComDebOut((DEB_ACTIVATE, "CProcessActivator::GetApartmentActivator [OUT] hr:%x\n", hr));

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CProcessActivator::GetClassObject , public
//
//  Synopsis:   End of the server process activation stage.
//              Responsibilities:
//
//                  1. Find or create apartment for activation
//                  2. Find a match for the prototype context in the right
//                     apartment, and if none, freeze the prototype into a new
//                     context to be used for the class object.
//
//              If we got this far with GetClassObject, the class factory will be
//              born in a fixed context and all instances of the factory will most
//              likely live there unless the factory does something unusual.
//
//  History:    24-Feb-98   SatishT      Created
//              07-Mar-98   Gopalk       Fixup leaking ISystemActivator
//              01-Nov-99   a-sergiv     Implemented Memory Gates
//
//----------------------------------------------------------------------------
STDMETHODIMP CProcessActivator::GetClassObject(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    ComDebOut((DEB_ACTIVATE, "CProcessActivator::GetClassObject [IN]\n"));

    GETREFCOUNT(pInActProperties,__relCount__);

    HRESULT hr = E_FAIL;


    ActivationPropertiesIn *pActIn=NULL;
    hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );

    Win4Assert((hr == S_OK) && (pActIn != NULL));

    // Check CreateObjectMemoryGate
    hr = CheckMemoryGate(pActIn->GetComClassInfo(), CreateObjectMemoryGate);
    if(FAILED(hr)) goto exit_point;

    //
    // We must retry for each CLSCTX separately because the handler
    // case could go to a different apartment or context than the
    // inproc server
    //

    hr = ActivateByContext(pActIn, NULL, pInActProperties,
                           ppOutActProperties, GCOCallback);



    if (FAILED(hr)) goto exit_point;

    /*

    If we arrive at the end of the server process activation stage without
    running into an activator that short circuits CGCO due to a desire to
    intercept instance creation, do we then proceed to construct a context
    for it as though it were an instance of the said class and park the
    class factory in that context?  Is this consistent with JIT/Pooling
    and other strange activators?  Even if the interface required from
    the class is not a standard factory interface?  There has been some
    concern about object pooling in particular.

    */

exit_point:

    CHECKREFCOUNT(pInActProperties,__relCount__);

    ComDebOut((DEB_ACTIVATE, "CProcessActivator::GetClassObject [OUT] hr:%x\n", hr));

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CProcessActivator::CreateInstance , public
//
//  Synopsis:   End of the server process activation stage.
//              Responsibilities:
//
//                  1. Find or create apartment for activation
//                  2. Find a match for the prototype context in the right
//                     apartment, and if none, freeze the prototype into a new
//                     context to be used for the instance object.
//
//  History:    25-Feb-98   SatishT      Created
//              07-Mar-98   Gopalk       Fixup leaking ISystemActivator
//              01-Nov-99   a-sergiv     Implemented Memory Gates
//
//----------------------------------------------------------------------------
STDMETHODIMP CProcessActivator::CreateInstance(
                    IN  IUnknown *pUnkOuter,
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    ComDebOut((DEB_ACTIVATE, "CProcessActivator::GetClassObject [IN]\n"));

    HRESULT hr = E_FAIL;

    GETREFCOUNT(pInActProperties,__relCount__);

    ActivationPropertiesIn *pActIn=NULL;
    hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );
    Win4Assert((hr == S_OK) && (pActIn != NULL));

    // Check CreateObjectMemoryGate
    hr = CheckMemoryGate(pActIn->GetComClassInfo(), CreateObjectMemoryGate);
    if(FAILED(hr)) goto exit_point;


    hr = ActivateByContext(pActIn, pUnkOuter, pInActProperties,
                           ppOutActProperties, CCICallback);

    if (FAILED(hr)) goto exit_point;


exit_point:

    CHECKREFCOUNT(pInActProperties,__relCount__);

    ComDebOut((DEB_ACTIVATE, "CProcessActivator::CreateInstance [OUT] hr:%x\n", hr));

    return hr;
}


// See comments in ActivateByContext below that explain
// reason for this tiny helper function to exist.
ULONG ActErrorPriority(HRESULT hr)
{
    switch (hr)
    {
    case CLASS_E_NOTLICENSED:
        return 3;
        break;
    case CLASS_E_CLASSNOTAVAILABLE:
        return 2;
        break;
    case REGDB_E_CLASSNOTREG:
        return 1;
        break;
    default:
        return 0;
        break;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:        CProcessActivator::ActivateByContext
//
//  Synopsis:      Tries each context in the correct order.
//
//  History:       27-Apr-98  MattSmit  Created
//                 22-Jun-98  CBiks     See RAID# 169589.  Fixed an order of
//                                      operations typo the Wx86 detection
//                                      code that resulted Wx86 never working.
//                                      HEY MATT! == binds stronger than & !!
//                 09-Oct-98  CBiks     Modified the INPROCs to check for
//                                      x86 activation first on Alpha.
//
//-----------------------------------------------------------------------------
STDMETHODIMP  CProcessActivator::ActivateByContext(ActivationPropertiesIn     *pActIn,
                                                   IUnknown                   *pUnkOuter,
                                                   IActivationPropertiesIn    *pInActProperties,
                                                   IActivationPropertiesOut  **ppOutActProperties,
                                                   PFNCTXACTCALLBACK           pfnCtxActCallback)

{
    ClsCacheDebugOut((DEB_TRACE, "CProcessActivator::ActivateByContext IN "
                      "pActIn:0x%x, pInActProperties:0x%x, ppOutActProperties:0x%x,"
                      " pfnCtxActCallback:0x%x\n", pActIn, pInActProperties,
                       ppOutActProperties, pfnCtxActCallback));

    //
    // jsimmons 09/17/2002
    //
    // Error handling in this function is funky.   The different errors we might get
    // have a certain order of precedence, borne from long experience (with regressions,
    // that is).   
    //
    // 1) CLASS_E_NOTLICENSED -- certain VB scenarios involving licensed OCX's need this behavior.
    //    Please see COM+ bug 20644.
    //
    // 2) CLASS_E_CLASSNOTAVAILABLE -- somebody forgot to replace their dll with a newer 
    //    implementation.   Note that this is more specific than REGDB_E_CLASSNOTREG, which is
    //    why it's in the #2 slot.
    //
    // 3) REGDB_E_CLASSNOTREG -- VB apps have a nice behavior where if they get this error when
    //    creating a dll/ocx-based object that they were compiled against, they will look in their 
    //    current directory for the dll/ocx and use it directly.   They expect this even if the
    //    dll exists on the machine but has been moved (see COM+ 32822), thus leaving an incorrect
    //    InprocServer32 entry in the registry.  Sigh.  What can you do?
    //
    // 4) other - who knows.  
    //
    // Note that the above behavior I'm describing is not necessarily logical...but it's way, 
    // way too late to be considering changes.  Apps (esp VB) expect certain things of us, so 
    // we need to try to maintain a status quo behavior.
    //
    
    HRESULT hrFinal, hrtmp;
    DWORD dwContext;
    BOOL  triedOne = FALSE;

    hrtmp = pInActProperties->GetClsctx(&dwContext);
    if (FAILED(hrtmp))
        return hrtmp;

    hrFinal = S_OK;  // overwritten by the first error, or set to CLASS_E_CLASSNOTAVAILABLE 
                     // if none of the below cases apply (unexpected for this to happen)
    hrtmp = E_FAIL;

    // try an INPROC_SERVER first
    if (dwContext & CLSCTX_INPROC_SERVERS)
    {
        if (FAILED(hrtmp))
        {
            hrtmp = AttemptActivation(pActIn, pUnkOuter, pInActProperties,
                                      ppOutActProperties, pfnCtxActCallback,
                                      dwContext & CLSCTX_INPROC_SERVERS);            
            if (FAILED(hrtmp))
            {
                if (SUCCEEDED(hrFinal))
                {
                    hrFinal = hrtmp;
                }
                else
                {
                    // Current hrFinal is failed, see which one wins
                    if (ActErrorPriority(hrtmp) > ActErrorPriority(hrFinal))
                    {
                        hrFinal = hrtmp;
                    }            			
                }
            }
            else
            {
                hrFinal = hrtmp;
            }
            triedOne = TRUE;
        }
    }

    // Try for an inproc handler
    if (FAILED(hrtmp) && (dwContext & CLSCTX_INPROC_HANDLERS))
    {
        if (FAILED(hrtmp))
        {
            hrtmp = AttemptActivation(pActIn, pUnkOuter, pInActProperties,
                                   ppOutActProperties, pfnCtxActCallback,
                                   dwContext & CLSCTX_INPROC_HANDLERS);
            if (FAILED(hrtmp))
            {
                if (SUCCEEDED(hrFinal))
                {
                    hrFinal = hrtmp;
                }
                else
                {
                    // Current hrFinal is failed, see which one wins
                    if (ActErrorPriority(hrtmp) > ActErrorPriority(hrFinal))
                    {
                        hrFinal = hrtmp;
                    }            			
                }
            }
            else
            {
                hrFinal = hrtmp;
            }
            triedOne = TRUE;
        }
    }

    // that didn't work, so try a LOCAL_SERVER
    if (FAILED(hrtmp) && (dwContext & CLSCTX_LOCAL_SERVER))
    {
        // Don't need to release this
        IComClassInfo *pCI = pActIn->GetComClassInfo();
        Win4Assert(pCI);

        DWORD stage;
        BOOLEAN fComplusForSure=FALSE;

        if (triedOne)
        for ( stage = CLIENT_CONTEXT_STAGE;
              stage <= SERVER_CONTEXT_STAGE;
              stage++ )
        {
            DWORD cCustomActForStage = 0;
            pCI->GetCustomActivatorCount((ACTIVATION_STAGE)stage,
                                              &cCustomActForStage);

            if (cCustomActForStage)
            {
                fComplusForSure = TRUE;
                break;
            }
        }

        // Retry only if no custom activators
        if (!fComplusForSure || !triedOne)
        {
            hrtmp = AttemptActivation(pActIn, pUnkOuter, pInActProperties,
                               ppOutActProperties, pfnCtxActCallback,
                               CLSCTX_LOCAL_SERVER);
            if (FAILED(hrtmp) && SUCCEEDED(hrFinal))
                hrFinal = hrtmp;
            else if (SUCCEEDED(hrtmp))
                hrFinal = hrtmp;
            triedOne = TRUE;
        }
    }
    
    // If we never even tried one of the above, then we need to reset the hr
    // to CLASS_E_CLASSNOTAVAILABLE
    if (!triedOne)
    {
        hrFinal = CLASS_E_CLASSNOTAVAILABLE;
    }

    ClsCacheDebugOut((DEB_TRACE, "CProcessActivator::ActivateByContext OUT hr:0x%x\n", hrFinal));
    return hrFinal;
}



//+----------------------------------------------------------------------------
//
//  Member:        CProcessActivator::AttemptActivation
//
//  Synopsis:      Attempts to activate given a CLSCTX
//
//  History:       27-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CProcessActivator::AttemptActivation(ActivationPropertiesIn     *pActIn,
                                                  IUnknown                   *pUnkOuter,
                                                  IActivationPropertiesIn    *pInActProperties,
                                                  IActivationPropertiesOut  **ppOutActProperties,
                                                  PFNCTXACTCALLBACK           pfnCtxActCallback,
                                                  DWORD                       dwContext)
{
    ISystemActivator *pAptActivator;
    HRESULT hr;

    ASSERT_ONE_CLSCTX(dwContext);

    ClsCacheDebugOut((DEB_TRACE, "CProcessActivator::AttemptActivation IN dwContext:0x%x,"
                      " pActIn:0x%x, pInActProperties:0x%x, ppOutActProperties:0x%x\n",
                       dwContext, pActIn, pInActProperties, ppOutActProperties));

    if (pActIn->GetDip())
    {
        ((DLL_INSTANTIATION_PROPERTIES *)(pActIn->GetDip()))->_dwContext = dwContext;
    }

    hr = (this->*pfnCtxActCallback)(dwContext, pUnkOuter,
                                    pActIn, pInActProperties,
                                    ppOutActProperties);
    ClsCacheDebugOut((DEB_TRACE, "CProcessActivator::AttemptActivation OUT hr:0x%x\n", hr));
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:      GCOCallback
//
//  Synopsis:      Call back for each context attemp
//
//  History:       27-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CProcessActivator::GCOCallback(DWORD                       dwContext,
                                       IUnknown                   *pUnkOuter,
                                       ActivationPropertiesIn     *pActIn,
                                       IActivationPropertiesIn    *pInActProperties,
                                       IActivationPropertiesOut  **ppOutActProperties)
{

    ClsCacheDebugOut((DEB_TRACE, "GCOCallback IN dwContext:0x%x, pActIn:0x%x,"
                      " pInActProperties:0x%x, ppOutActProperties:0x%x\n",
                      dwContext, pActIn, pInActProperties, ppOutActProperties));

    Win4Assert(pUnkOuter == NULL);

    HRESULT hr;
    ISystemActivator *pAptActivator;

    ASSERT_ONE_CLSCTX(dwContext);



    //
    // get the apartment activator
    //

    hr = GetApartmentActivator(pActIn, &pAptActivator);
    if (SUCCEEDED(hr))
    {
        //
        // switch to the server apartment and attempt the
        // activation there
        //

        hr = pAptActivator->GetClassObject(pInActProperties,ppOutActProperties);
        pAptActivator->Release();
    }

    ClsCacheDebugOut((DEB_TRACE, "GCOCallback OUT hr:0x%x\n", hr));
    return hr;

}

//+----------------------------------------------------------------------------
//
//  Function:      CCICallback
//
//  Synopsis:      callback for each context attempt
//
//  History:       27-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CProcessActivator::CCICallback(DWORD                       dwContext,
                                       IUnknown                   *pUnkOuter,
                                       ActivationPropertiesIn     *pActIn,
                                       IActivationPropertiesIn    *pInActProperties,
                                       IActivationPropertiesOut  **ppOutActProperties)
{
    ISystemActivator *pAptActivator;
    HRESULT hr;


    ASSERT_ONE_CLSCTX(dwContext);

    hr = GetApartmentActivator(pActIn, &pAptActivator);

    if (SUCCEEDED(hr))
    {


        // Figure out of we have aggregation and if it is OK
        // Note: if the apartment activatior is in a different
        // apartment the flag should be set to false already
        if (pUnkOuter)
        {
            ContextInfo *pActCtxInfo = NULL;

            pActCtxInfo = pActIn->GetContextInfo();

            Win4Assert(pActCtxInfo != NULL);

            BOOL fClientContextOK;

            hr = pActCtxInfo->IsClientContextOK(&fClientContextOK);
            CHECK_HRESULT(hr);

            if (!fClientContextOK)
            {
                hr = CLASS_E_NOAGGREGATION;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pAptActivator->CreateInstance(pUnkOuter,pInActProperties,ppOutActProperties);
        }

        pAptActivator->Release();
    }

    ClsCacheDebugOut((DEB_TRACE, "CCICallBack OUT hr:0x%x\n", hr));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentActivator::ContextMaker , private
//
//  Synopsis:
//
//  History:    06-Mar-98   SatishT      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CApartmentActivator::ContextSelector(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT BOOL &fCurrentContextOK,
                    OUT CObjectContext *&pContext)
{
    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::ContextMaker [IN]\n"));

    HRESULT hr = E_FAIL;

    // This is a fake QI that gives back a non-refcounted pointer to the
    // actual class
    ActivationPropertiesIn *pActIn=NULL;
    hr = pInActProperties->QueryInterface(
                                        CLSID_ActivationPropertiesIn,
                                        (LPVOID*)&pActIn
                                        );
    Win4Assert((hr == S_OK) && (pActIn != NULL));

    IActivationStageInfo *pStageInfo = (IActivationStageInfo*) pActIn;

    hr = pStageInfo->SetStageAndIndex(SERVER_CONTEXT_STAGE,0);
    CHECK_HRESULT(hr);

    ContextInfo *pActCtxInfo = pActIn->GetContextInfo();
    Win4Assert(pActCtxInfo != NULL);

    // Check whether the target context was overridden. If it was,
    // then I can tell you right now that client context is not OK.

    if(pActCtxInfo->_ctxOverride != GUID_NULL)
    {
        // Client context is NOT OK
        fCurrentContextOK = FALSE;

        // Lookup the existing context
        LOCK(gContextLock);
        pContext = CCtxTable::LookupExistingContext(pActCtxInfo->_ctxOverride);
        UNLOCK(gContextLock);

        if(!pContext)
            return E_UNEXPECTED;
        else
            pContext->InternalAddRef();
        
        return S_OK;
    }

    // This initialization assumes fCurrentContextOK -- we will reset
    // if we conclude later after much debate that fCurrentContextOK==FALSE
    pContext = NULL;

    hr = pActCtxInfo->IsClientContextOK(&fCurrentContextOK);
    CHECK_HRESULT(hr);

    // Pick the context we are going to use as the server context
    if (!fCurrentContextOK)
    {
        // Note: fProtoExists does not imply !fProtoEmpty
        //       fProtoEmpty does not imply !fProtoExists
        //       !fProtoExists does imply fProtoEmpty
        BOOL fProtoExists = TRUE,   //  was the prototype context ever created?
             fProtoEmpty = TRUE;    //  is the theoretical prototype context empty?
        CObjectContext *pProtoContext = NULL;
        hr = pActCtxInfo->PrototypeExists(&fProtoExists);
        CHECK_HRESULT(hr);

        if (fProtoExists)
        {
            // we initialized fProtoEmpty to TRUE but it might be FALSE
            hr = pActCtxInfo->GetInternalPrototypeContext(&pProtoContext);
            CHECK_HRESULT(hr);
            Win4Assert(pProtoContext);
            fProtoEmpty = IsEmptyContext(pProtoContext);
        }

        if (fProtoEmpty)
        {
            // prototype context is empty -- if the current context is
            // also empty we will just activate in the current context
            CObjectContext *pCurrentContext = NULL;
            hr = PrivGetObjectContext(IID_IStdObjectContext,
                                      (LPVOID*)&pCurrentContext);
            CHECK_HRESULT(hr);
            Win4Assert(pCurrentContext);

            if (pCurrentContext->GetCount() == 0)
            {
                fCurrentContextOK = TRUE;
            }

            pCurrentContext->InternalRelease();
        }

        // Here is where we find an existing context if possible
        // This should set fCurrentContextOK if prototype is
        // found to be equivalent
        if (!fCurrentContextOK)
        {
            CObjectContext* pMatchingContext = NULL;

            // Prefix says we might not have a prototype context available 
            // here.  Should never happen with our current code, but humor
            // the prefix gods anyway.  
            hr = E_UNEXPECTED;
            Win4Assert(pProtoContext);

            if (pProtoContext)
            {
                // Freeze the prototype context for now and forever..
                hr = pProtoContext->Freeze();

                if(SUCCEEDED(hr))
                {
                    // Here is where we find an existing context if possible
                    ASSERT_LOCK_NOT_HELD(gContextLock);
                    LOCK(gContextLock);

                    pMatchingContext = CCtxTable::LookupExistingContext(pProtoContext);

                    // Release lock
                    UNLOCK(gContextLock);
                    ASSERT_LOCK_NOT_HELD(gContextLock);

                    if(NULL != pMatchingContext)
                    {
                        ComDebOut((DEB_ACTIVATE, "CApartmentActivator::ContextSelector found matching context %p [IN]\n", pMatchingContext));

                        // We found an existing context which matches the prototype context
                        // Discard the prototype context and use the existing context
                        // Lookup would have addrefed the context
                        pProtoContext->InternalRelease();
                        pProtoContext = pMatchingContext;

                        // Check if the client context is the same as the
                        // matched context
                        CObjectContext* pClientContext = NULL;
                        hr = pActIn->GetContextInfo()->GetInternalClientContext(&pClientContext);
                        if(SUCCEEDED(hr) && pClientContext)
                        {
                            if (pMatchingContext == pClientContext)
                            {
                                CObjectContext *pCurrentContext;
                                hr = PrivGetObjectContext(IID_IStdObjectContext,
                                                    (void **) &pCurrentContext);

                                Win4Assert(SUCCEEDED(hr));

                                // If the client context is the same as the
                                // matched context and current context
                                // then the current context is OK
                                if (pCurrentContext == pClientContext)
                                    fCurrentContextOK = TRUE;

                                pCurrentContext->InternalRelease();
                            }

                            pClientContext->InternalRelease();
                        }
                    }
                    else
                    {
                        // Darn! We did not find an existing context matching the prototype
                        // context.

                        // Add the context to the hash table which will facilitate finding
                        // a matching context later
                        hr = CCtxTable::AddContext((CObjectContext *)pProtoContext);
                    }
                }
            }
        }

        if (FAILED(hr))
            goto exit_point;

        if(!fCurrentContextOK)
        {
            // Check to see if we are allowed to switch contexts
            // for this requested class
            IComClassInfo *pClassInfo = NULL;
            //This does not need to be released
            pClassInfo = pActIn->GetComClassInfo();
            BOOL fCreateOnlyInCC=FALSE;
            hr = pClassInfo->MustRunInClientContext(&fCreateOnlyInCC);
            if (SUCCEEDED(hr) && fCreateOnlyInCC)
            {
               pProtoContext->InternalRelease();
               hr = CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT;
               goto exit_point;
            }

            pContext = pProtoContext;
        }
        else
        {
            // get rid of our reference to pProtoContext if we have one
            if (pProtoContext) pProtoContext->InternalRelease();
        }
    }

exit_point:

    // at this point we own a reference to pContext if it is not NULL

    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::ContextMaker [OUT] hr:%x\n", hr));

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentActivator::ContextCallHelper , private
//
//  Synopsis:
//
//  History:    06-Mar-98   SatishT      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CApartmentActivator::ContextCallHelper(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties,
                    PFNCTXCALLBACK pfnCtxCallBack,
                    CObjectContext *pContext)
{
    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::ContextCallHelper [IN]\n"));

    HRESULT hr = E_FAIL;
    HRESULT hrSave = E_FAIL;

    // Must use new since there is a constructor/destructor for one of the fields
    ServerContextWorkData *pServerContextWorkData = new ServerContextWorkData;
    if ( pServerContextWorkData == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {

        pServerContextWorkData->pInActProps = pInActProperties;

        // Get inside the server context, do the work and get out with marshalled
        // out activation properties -- the function parameter does CGCO or CCI
        hr = hrSave = pContext->DoCallback(pfnCtxCallBack,
                                           pServerContextWorkData,
                                           IID_ISystemActivator,
                                           0
                                           );
    }

    // Our reference should now be released
    pContext->InternalRelease();

    if ( SUCCEEDED(hr) )
    {
        IStream *pStream = &pServerContextWorkData->xrpcOutProps;

        // reset the stream to the beginning before unmarshalling
        LARGE_INTEGER  lSeekStart;
        lSeekStart.LowPart  = 0;
        lSeekStart.HighPart = 0;
        hr = pStream->Seek(lSeekStart, STREAM_SEEK_SET, NULL);
        CHECK_HRESULT(hr);

        hr = CoUnmarshalInterface(
                         pStream,
                         IID_IActivationPropertiesOut,
                         (LPVOID*) ppOutActProperties
                         );
    }

    if ( pServerContextWorkData != NULL)
    {
        delete pServerContextWorkData;
    }

    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::ContextCallHelper [OUT] hr:%x\n", hr));

    if (SUCCEEDED(hr))
    {
       Win4Assert(SUCCEEDED(hrSave));
       if (*ppOutActProperties)
       {
           CHECKREFCOUNT(*ppOutActProperties,1);
       }
       return hrSave;
    }
    else
    {
       return hr;
    }

}

//+-------------------------------------------------------------------------
//
//  Implementation of callback functions for server context activation.
//
//+-------------------------------------------------------------------------

HRESULT __stdcall DoServerContextGCO(void *pv)
{
    ServerContextWorkData *pData = (ServerContextWorkData*) pv;
    IActivationPropertiesOut *pOutActProperties = NULL;

    HRESULT hrSave;
    HRESULT hr = hrSave = pData->pInActProps->DelegateGetClassObject(&pOutActProperties);

    if ( SUCCEEDED(hr) )
    {
        hr = CoMarshalInterface(&pData->xrpcOutProps,
                                IID_IActivationPropertiesOut,
                                (IUnknown*)pOutActProperties,
                                MSHCTX_CROSSCTX,
                                NULL,
                                MSHLFLAGS_NORMAL);
    }

    // the ref is now in the marshalled packet if we had anything useful
    if (pOutActProperties) pOutActProperties->Release();

    if (SUCCEEDED(hr))
    {
       Win4Assert(SUCCEEDED(hrSave));
       return hrSave;
    }
    else
    {
       return hr;
    }

}

HRESULT __stdcall DoServerContextCCI(void *pv)
{
    ServerContextWorkData *pData = (ServerContextWorkData*) pv;
    IActivationPropertiesOut *pOutActProperties = NULL;
	
    // Code to prevent cross-context aggregation is in CServerContextActivator::CreateInstance
    HRESULT hrSave;
    HRESULT hr = hrSave = pData->pInActProps->DelegateCreateInstance(NULL,&pOutActProperties);

    if(SUCCEEDED(hr))
    {
        hr = CoMarshalInterface(&pData->xrpcOutProps,
                                IID_IActivationPropertiesOut,
                                (IUnknown*)pOutActProperties,
                                MSHCTX_CROSSCTX,
                                NULL,
                                MSHLFLAGS_NORMAL);
    }

    // the ref is now in the marshalled packet if we had anything useful
    if (pOutActProperties) pOutActProperties->Release();

    if (SUCCEEDED(hr))
    {
       Win4Assert(SUCCEEDED(hrSave));
       return hrSave;
    }
    else
    {
       return hr;
    }

}

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentActivator::GetClassObject , public
//
//  Synopsis:
//
//  History:    06-Mar-98   SatishT      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CApartmentActivator::GetClassObject(
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::GetClassObject [IN]\n"));

    CObjectContext *pContext = NULL;
    BOOL fCurrentContextOK = FALSE;

    Win4Assert(NULL == *ppOutActProperties);


    HRESULT hr = ContextSelector(
                            pInActProperties,
                            fCurrentContextOK,
                            pContext
                            );

    if ( SUCCEEDED(hr) )
    {
        if (fCurrentContextOK)
        {
            Win4Assert(pContext == NULL);
            // we are instantiating in the current context, so just delegate
            hr = pInActProperties->DelegateGetClassObject(ppOutActProperties);
        }
        else
        {
            hr = ContextCallHelper(
                                pInActProperties,
                                ppOutActProperties,
                                DoServerContextGCO,
                                pContext
                                );
        }
    }

    if (*ppOutActProperties)
    {
        CHECKREFCOUNT(*ppOutActProperties,1);
    }

    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::GetClassObject [OUT] hr:%x\n", hr));

    return hr;
}

STDAPI CoGetDefaultContext(APTTYPE aptType, REFIID riid, void** ppv);

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentActivator::CreateInstance , public
//
//  Synopsis:
//
//  History:    06-Mar-98   SatishT      Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CApartmentActivator::CreateInstance(
                    IN  IUnknown *pUnkOuter,
                    IN  IActivationPropertiesIn *pInActProperties,
                    OUT IActivationPropertiesOut **ppOutActProperties)
{
    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::GetClassObject [IN]\n"));

    Win4Assert(NULL == *ppOutActProperties);

    // First, handle MustRunInDefaultContext property. This must be done
    // here as it requires knowledge of object's intended apartment.
    // COM Services doesn't have such knowledge, Stage-5 activators execute
    // AFTER the target context is selected, so this is only logical...

    IComClassInfo2 *pClassInfo2 = NULL;
    HRESULT hr = pInActProperties->GetClassInfo(IID_IComClassInfo2, (void**) &pClassInfo2);
    if(SUCCEEDED(hr))
    {
        BOOL bMustRunInDefaultContext = FALSE;
        hr = pClassInfo2->MustRunInDefaultContext(&bMustRunInDefaultContext);
        pClassInfo2->Release();

        if(SUCCEEDED(hr) && bMustRunInDefaultContext)
        {
            IGetContextId *pGetCtxtId = NULL;
            IOverrideTargetContext *pOverride = NULL;
            GUID ctxtId;

            hr = CoGetDefaultContext(APTTYPE_CURRENT, IID_IGetContextId, (void**) &pGetCtxtId);
            if(FAILED(hr)) goto exit;

            hr = pGetCtxtId->GetContextId(&ctxtId);
            pGetCtxtId->Release();
            if(FAILED(hr)) goto exit;

            hr = pInActProperties->QueryInterface(IID_IOverrideTargetContext, (void**) &pOverride);
            if(FAILED(hr)) goto exit;

            pOverride->OverrideTargetContext(ctxtId);
            pOverride->Release();
        }
    }

    // Then go about our other business...

    CObjectContext *pContext;
    BOOL fCurrentContextOK;

    pContext = NULL;
    fCurrentContextOK = FALSE;

    hr = ContextSelector(
                            pInActProperties,
                            fCurrentContextOK,
                            pContext
                            );

    if ( SUCCEEDED(hr) )
    {
        if (fCurrentContextOK)
        {
            Win4Assert(pContext == NULL);
            // we are instantiating in the current context, so just delegate
            hr = pInActProperties->DelegateCreateInstance(pUnkOuter,ppOutActProperties);
        }
        else
        {
            hr = ContextCallHelper(
                                pInActProperties,
                                ppOutActProperties,
                                DoServerContextCCI,
                                pContext
                                );
        }
    }

    if (*ppOutActProperties)
    {
        CHECKREFCOUNT(*ppOutActProperties,1);
    }

exit:
    ComDebOut((DEB_ACTIVATE, "CApartmentActivator::CreateInstance [OUT] hr:%x\n", hr));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Helpers related to the activator architecture.
//
//+-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Helper to register apartment activator for current apartment.
//  Do the registration only if the current apartment is unregistered.
//
//+-------------------------------------------------------------------------
HRESULT RegisterApartmentActivator(HActivator &hActivator)
{
    CURRENT_CONTEXT_EMPTY   // don't do this in a non-default context

    HRESULT hr = E_FAIL;

    HAPT hApt = GetCurrentApartmentId();
    ApartmentEntry *pEntry = gApartmentTbl.Lookup(hApt);

    if (NULL == pEntry)     // the expected case
    {
        hr = gApartmentTbl.AddEntry(hApt,hActivator);
    }
    else
    {
        Win4Assert(0 && "RegisterApartmentActivator found existing entry");
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Helper to revoke apartment activator for current apartment.
//  Used in cleanup in CDllHost.
//
//+-------------------------------------------------------------------------
HRESULT RevokeApartmentActivator()
{
    HRESULT hr = S_OK;

    HAPT hApt = GetCurrentApartmentId();
    ApartmentEntry *pEntry = gApartmentTbl.Lookup(hApt);

    if (pEntry == NULL)
    {
        hr = E_FAIL;
    }
    else
    {
        // This call will delete the pEntry memory
        hr = gApartmentTbl.ReleaseEntry(pEntry);
    }

    return hr;
}


// CODEWORK:  These aren't the most efficient ways to do this -- we should switch
//          over to agile proxies as in the previous DllHost code ASAP



//+-------------------------------------------------------------------------
//
//  Helper to find or create apartment activator for current apartment.
//
//+-------------------------------------------------------------------------
HRESULT GetCurrentApartmentToken(HActivator &hActivator, BOOL fCreate)
{
    HRESULT hr = E_FAIL;

    HAPT hApt = GetCurrentApartmentId();
    ApartmentEntry *pEntry = gApartmentTbl.Lookup(hApt);
    if (NULL != pEntry)     // Previously registered
    {
        hActivator = pEntry->hActivator;
        hr = S_OK;
    }
    else if(fCreate)       // Not yet registered
    {
        hr = RegisterApartmentActivator(hActivator);
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Globals related to the activator architecture.
//
//+-------------------------------------------------------------------------


// The One and Only Client Context Standard Activator
CClientContextActivator gComClientCtxActivator;

// The One and Only Process Standard Activator
CProcessActivator gComProcessActivator;

// The One and Only Server Context Standard Activator
CServerContextActivator gComServerCtxActivator;

// The One and Only Apartment Activator
CApartmentActivator gApartmentActivator;


//+-------------------------------------------------------------------------
//
//  Helper to find the end of delegation chain at each activation stage.
//
//+-------------------------------------------------------------------------
ISystemActivator *GetComActivatorForStage(ACTIVATION_STAGE stage)
{
    switch (stage)
    {
    case CLIENT_CONTEXT_STAGE:
        return gComClientCtxActivator.GetSystemActivator();

    case CLIENT_MACHINE_STAGE:
        Win4Assert(0 && "CLIENT_MACHINE_STAGE reached in OLE32");
        return NULL;

    case SERVER_MACHINE_STAGE:
        Win4Assert(0 && "SERVER_MACHINE_STAGE reached in OLE32");
        return NULL;

    case SERVER_PROCESS_STAGE:
        return gComProcessActivator.GetSystemActivator();

    case SERVER_CONTEXT_STAGE:
        return gComServerCtxActivator.GetSystemActivator();
    default:
        Win4Assert(0 && "Default reached in GetComActivatorForStage");
        return NULL;

    }
}


//+-------------------------------------------------------------------------
//
//  Helper to check if a context is empty/default.
//
//+-------------------------------------------------------------------------
BOOL IsEmptyContext(CObjectContext *pContext)
{
    Win4Assert(pContext && "IsEmptyContext called with NULL context");
    BOOL fResult = pContext->GetCount() == 0;
    return fResult;
}


//+------------------------------------------------------------------------
//
//       Implementations of CApartmentHashTable methods
//
//+------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Member:     CApartmentHashTable::AddEntry , public
//
//  Synopsis:   Register a new apartment activator in the global table.
//
//  History:    28-Feb-98   SatishT      Created
//
//----------------------------------------------------------------------------
HRESULT CApartmentHashTable::AddEntry(HAPT hApt, HActivator &hActivator)
{
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);

    DWORD dwAAmshlflags = MSHLFLAGS_TABLESTRONG | MSHLFLAGS_AGILE | MSHLFLAGS_NOPING;
    HRESULT hr = RegisterInterfaceInStdGlobal((IUnknown*)&gApartmentActivator,
                                              IID_ISystemActivator,
                                              dwAAmshlflags,
                                              &hActivator);

    if (SUCCEEDED(hr))
    {
        ApartmentEntry *pApartmentEntry = new ApartmentEntry;
        if ( pApartmentEntry == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pApartmentEntry->hActivator = hActivator;
            ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
            LOCK(_mxsAptTblLock);
            _hashtbl.Add(hApt, hApt, &pApartmentEntry->node);
            UNLOCK(_mxsAptTblLock);
            ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
        }
    }

    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentHashTable::Lookup , public
//
//  Synopsis:   Lookup an apartment activator in the global table,
//              given the current apartment ID.
//
//  History:    28-Feb-98   SatishT      Created
//
//----------------------------------------------------------------------------
ApartmentEntry *CApartmentHashTable::Lookup(HAPT hApt)
{
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    LOCK(_mxsAptTblLock);

    ApartmentEntry *pResult = (ApartmentEntry*) _hashtbl.Lookup(hApt, hApt);

    UNLOCK(_mxsAptTblLock);
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    return pResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CApartmentHashTable::ReleaseEntry , public
//
//  Synopsis:   Remove an apartment's entry in the global table,
//              given the entry itself.
//
//  History:    28-Feb-98   SatishT      Created
//
//----------------------------------------------------------------------------
HRESULT CApartmentHashTable::ReleaseEntry(ApartmentEntry *pEntry)
{
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    HRESULT hr = RevokeInterfaceFromStdGlobal(pEntry->hActivator);

    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    LOCK(_mxsAptTblLock);

    _hashtbl.Remove(&pEntry->node.chain);

    UNLOCK(_mxsAptTblLock);
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);

    delete pEntry;

    return hr;
}


//  This is defined in ..\com\dcomrem\hash.cxx
void DummyCleanup( SHashChain *pIgnore );


//+--------------------------------------------------------------------------
//
//  Member:     CApartmentHashTable::Cleanup , public
//
//  Synopsis:   Remove an apartment's entry in the global table,
//              given the entry itself.
//
//  History:    28-Feb-98   SatishT      Created
//
//----------------------------------------------------------------------------
void CApartmentHashTable::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
    LOCK(_mxsAptTblLock);

    if(_fTableInitialized){
        _hashtbl.Cleanup(DummyCleanup);
    }

    UNLOCK(_mxsAptTblLock);
    ASSERT_LOCK_NOT_HELD(_mxsAptTblLock);
}


//+--------------------------------------------------------------------------
//
//  Member:     ActivationThreadCleanup, public
//
//  Synopsis:   This routine is called when an apartment is being uninitialized
//              It should cleanup per apartment structures
//
//  History:    07-Mar-98   Gopalk      Created
//
//----------------------------------------------------------------------------
void ActivationAptCleanup()
{
    // Delete ObjServer
    ObjactThreadUninitialize();

    // Revoke apartment activator
    RevokeApartmentActivator();

    return;
}


//+--------------------------------------------------------------------------
//
//  Member:     ActivationProcessCleanup, public
//
//  Synopsis:   This routine is called when an process is being uninitialized
//              It should cleanup per process structures
//
//  History:    07-Mar-98   Gopalk      Created
//
//----------------------------------------------------------------------------
void ActivationProcessCleanup()
{
    // Cleanup apartment table
    gApartmentTbl.Cleanup();

    return;
}


//+--------------------------------------------------------------------------
//
//  Member:     ActivationProcessInit, public
//
//  Synopsis:   This routine is called when an process is being initialized
//              It should initialize per process structures
//
//  History:    07-Mar-98   Gopalk      Created
//
//----------------------------------------------------------------------------
HRESULT ActivationProcessInit()
{
    HRESULT hr = S_OK;

    // Initialize apartment table
    gApartmentTbl.Initialize();

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     LoadPersistentObject, public
//
//  Synopsis:
//
//  History:    18-Mar-98   Vinaykr      Created
//
//----------------------------------------------------------------------------
HRESULT LoadPersistentObject(
                             IUnknown *pobj,
                             IInstanceInfo *pInstanceInfo)
{
    HRESULT hr = E_FAIL;

    XIPersistStorage xipstg;
    XIPersistFile xipfile;
    IStorage *pstg;
    hr = pInstanceInfo->GetStorage(&pstg);
    if (FAILED(hr))
        return hr;

    // First check if storage is requested
    if (pstg)
    {
        // Load the storage requested as a template
        if ((hr = pobj->QueryInterface(IID_IPersistStorage, (void **) &xipstg))
                == S_OK)
        {
            hr = xipstg->Load(pstg);
        }
        pstg->Release();
    }
    else // check for File
    {
        DWORD mode;
        WCHAR *path;
        pInstanceInfo->GetFile(&path, &mode);
        if ((hr = pobj->QueryInterface(IID_IPersistFile, (void **) &xipfile))
                == S_OK)
        {
            hr = xipfile->Load(path, mode);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\progress.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       progress.cxx
//
//  Contents:   standard IBindStatusCallback implementation used by OLE
//              during network component installations
//
//  Functions:  GetDefaultIBindStatusCallback
//
//  History:    7-01-1997   stevebl   Created
//
//---------------------------------------------------------------------------

#include <ole2int.h>
#include <classmon.hxx>
#include <commctrl.h>
#include "cdialog.h"
#include "resource.h"

#define WM_UPDATECONTROLS WM_USER

//+--------------------------------------------------------------------------
//
//  Class:      DefaultIBindStatusCallback
//
//  Purpose:    default implementation for IBindStatusCallback
//
//  Interface:  QueryInterface              --
//              AddRef                      --
//              Release                     --
//              GetBindInfo                 --
//              OnStartBinding              --
//              GetPriority                 --
//              OnProgress                  --
//              OnDataAvailable             --
//              OnObjectAvailable           --
//              OnLowResource               --
//              OnStopBinding               --
//              DefaultIBindStatusCallback  --
//              Init                        --
//              ~DefaultIBindStatusCallback --
//
//  History:    7-02-1997   stevebl   Created
//
//  Notes:      puts up a window with a progress bar and a cancel button
//
//---------------------------------------------------------------------------

class DefaultIBindStatusCallback : IBindStatusCallback, ICodeInstall, CHlprDialog
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(
                             REFIID iid,
                             void ** ppvObject
                             );
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IBindStatusCallback methods
    STDMETHOD(GetBindInfo)(
                          DWORD * pgrfBINDF,
                          BINDINFO * pbindinfo
                          );
    STDMETHOD(OnStartBinding)(
                             DWORD dwReserved,
                             IBinding * pbinding
                             );
    STDMETHOD(GetPriority)(LONG * pnPriority);
    STDMETHOD(OnProgress)(
                         ULONG ulProgress,
                         ULONG ulProgressMax,
                         ULONG ulStatusCode,
                         LPCOLESTR szStatusText
                         );
    STDMETHOD(OnDataAvailable)(
                              DWORD grfBSCF,
                              DWORD dwSize,
                              FORMATETC * pfmtetc,
                              STGMEDIUM * pstgmed
                              );
    STDMETHOD(OnObjectAvailable)(
                                REFIID riid,
                                IUnknown * punk
                                );
    STDMETHOD(OnLowResource)(DWORD dwReserved);
    STDMETHOD(OnStopBinding)(
                            HRESULT hrStatus,
                            LPCOLESTR szStatusText
                            );

    // IWindowForBindingUI methods
    STDMETHOD(GetWindow)(
        REFGUID rguidReason,
        HWND* phwnd
        );

    // ICodeInstall methods
    STDMETHOD(OnCodeInstallProblem)(
        ULONG ulStatusCode,
        LPCWSTR szDestination,
        LPCWSTR szSource,
        DWORD dwReserved
        );

    // constructor
    DefaultIBindStatusCallback(HWND hwndParent, IBindStatusCallback * pibsc);

    // extra initialization, call after contstructor but before other methods
    BOOL Init(LPCOLESTR m_pszTitle);

    // destructor
    ~DefaultIBindStatusCallback();

private:
    // CHlprDialog method
    INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    IBindStatusCallback * m_pibsc;
    LONG        m_lRef;
    IBinding *  m_pBinding;
    HWND        m_hwndParent;
    HWND        m_hDlg;
    ULONG       m_ulProgress;
    ULONG       m_ulProgressMax;
    WCHAR       m_szStatusText[MAX_PATH];
    BOOL        m_fShown;
};

DefaultIBindStatusCallback::DefaultIBindStatusCallback(HWND hwndParent, IBindStatusCallback * pibsc)
{
    // Initialize with no references since it will be QIed right after
    // creation.
    m_lRef = 0;

    m_pBinding = NULL;
    m_hwndParent = hwndParent;
    m_pibsc = pibsc;
    if (pibsc)
    {
        pibsc->AddRef();
    }

    m_szStatusText[0] = 0;
    m_ulProgress = 0;
    m_ulProgressMax = 1;
    m_fShown = FALSE;
    m_hDlg = NULL;
}

typedef WINCOMMCTRLAPI void (WINAPI *PFNINITCOMMONCONTROLS) (void);

BOOL CallInitCommonControls(void)
{
    static PFNINITCOMMONCONTROLS pfnInitCommonControls = NULL;

    if ( pfnInitCommonControls == NULL )
    {
        HINSTANCE hLibrary = NULL;
        PFNINITCOMMONCONTROLS pfnICCTemp = NULL;

        hLibrary = LoadLibrary ( L"comctl32.dll" );
        if ( hLibrary == NULL )
        {
            return FALSE;
        }

        pfnICCTemp = (PFNINITCOMMONCONTROLS) GetProcAddress ( hLibrary, "InitCommonControls" );
        if ( pfnICCTemp == NULL )
        {
            return FALSE;
        }

        if ( NULL != InterlockedCompareExchangePointer ( (PVOID*) &pfnInitCommonControls, 
                                                         (PVOID) pfnICCTemp,
                                                         NULL 
                                                       ) )
        {
            FreeLibrary ( hLibrary );
        }
    }

    if ( pfnInitCommonControls != NULL )
    {
        pfnInitCommonControls();
    }

    return pfnInitCommonControls != NULL ;
}

BOOL DefaultIBindStatusCallback::Init(LPCOLESTR pszTitle)
{
    if (!CallInitCommonControls()) 
    {
        return FALSE;
    }

    // Create and show the dialog
    m_hDlg = CreateDlg(g_hinst, MAKEINTRESOURCE(IDD_DIALOG1), m_hwndParent);
    if (m_hDlg)
    {
        // set title if a different one is provided
        if (pszTitle)
        {
            SetWindowTextW(m_hDlg, pszTitle);
        }
        // Going to move this dialog so it's always in the center of our
        // parent window's client area.

        RECT rectDLG;
        RECT rectParent;
        GetWindowRect(m_hDlg, &rectDLG);
        if (m_hwndParent)
        {
            GetClientRect(m_hwndParent, &rectParent);
        }
        else
        {
            GetClientRect(GetDesktopWindow(), &rectParent);
        }
        LONG dx = rectDLG.right - rectDLG.left;
        LONG dy = rectDLG.bottom - rectDLG.top;
        LONG x = ((rectParent.right - rectParent.left) - dx)/2;
        LONG y = ((rectParent.bottom - rectParent.top) - dy)/2;
        MoveWindow(m_hDlg, x, y, dx, dy, FALSE);
    }
    return (NULL != m_hDlg);
}

DefaultIBindStatusCallback::~DefaultIBindStatusCallback()
{
    // cleanup
    if (m_hDlg)
    {
       DestroyWindow(m_hDlg);
    }
    if (m_pBinding)
    {
        m_pBinding->Release();
    }
    if (m_pibsc)
    {
        m_pibsc->Release();
    }
}

HRESULT DefaultIBindStatusCallback::QueryInterface(
                                                  REFIID iid,
                                                  void ** ppvObject
                                                  )
{
    if (IsEqualCLSID(iid, IID_IUnknown) ||
        IsEqualCLSID(iid, IID_IBindStatusCallback))
    {
        AddRef();
        *ppvObject = (IBindStatusCallback *)this;
        return S_OK;
    }
    else if (IsEqualCLSID(iid, IID_ICodeInstall))
    {
        AddRef();
        *ppvObject = (ICodeInstall *)this;
        return S_OK;
    }
    else if (IsEqualCLSID(iid, IID_IWindowForBindingUI))
    {
        AddRef();
        *ppvObject = (IWindowForBindingUI *)this;
        return S_OK;
    }

    return E_NOTIMPL;
}

ULONG DefaultIBindStatusCallback::AddRef(void)
{
    return InterlockedIncrement(&m_lRef);
}

ULONG DefaultIBindStatusCallback::Release(void)
{
    LONG lTemp = InterlockedDecrement(&m_lRef);
    if (0 == lTemp)
    {
        delete this;
    }
    return lTemp;
}

HRESULT DefaultIBindStatusCallback::GetBindInfo(
                                               DWORD * pgrfBINDF,
                                               BINDINFO * pbindinfo
                                               )
{
    *pgrfBINDF = BINDF_ASYNCHRONOUS;
    return S_OK;
}

HRESULT DefaultIBindStatusCallback::OnStartBinding(
                                                  DWORD dwReserved,
                                                  IBinding * pbinding
                                                  )
{
    if (m_pibsc)
    {
        m_pibsc->OnStartBinding(dwReserved, pbinding);
    }
    m_pBinding = pbinding;
    m_pBinding->AddRef();

    ShowWindow(m_hDlg, SW_SHOWNORMAL);
    m_fShown = TRUE;

    return S_OK;
}

HRESULT DefaultIBindStatusCallback::GetPriority(LONG * pnPriority)
{
    if (m_pibsc)
    {
        return m_pibsc->GetPriority(pnPriority);
    }
    else
    {
        return E_NOTIMPL;
    }
}

HRESULT DefaultIBindStatusCallback::OnProgress(
                                              ULONG ulProgress,
                                              ULONG ulProgressMax,
                                              ULONG ulStatusCode,
                                              LPCOLESTR szStatusText
                                              )
{
    if (m_pibsc)
    {
        m_pibsc->OnProgress(ulProgress, ulProgressMax, ulStatusCode, szStatusText);
    }
    m_ulProgress = ulProgress;
    m_ulProgressMax = ulProgressMax;
    lstrcpynW(m_szStatusText, szStatusText, MAX_PATH);

    // UNDONE - send a message to update the dialog controls

    if (!m_fShown)
    {
        ShowWindow(m_hDlg, SW_SHOWNORMAL);
        m_fShown = TRUE;
    }
    else
    {
        SendMessage(m_hDlg, WM_UPDATECONTROLS, 0, 0);
    }
    return S_OK;
}

HRESULT DefaultIBindStatusCallback::OnDataAvailable(
                                                   DWORD grfBSCF,
                                                   DWORD dwSize,
                                                   FORMATETC * pfmtetc,
                                                   STGMEDIUM * pstgmed
                                                   )
{
    if (m_pibsc)
    {
        return m_pibsc->OnDataAvailable(grfBSCF, dwSize, pfmtetc, pstgmed);
    }
    else
    {
        return E_NOTIMPL;
    }
}

HRESULT DefaultIBindStatusCallback::OnObjectAvailable(
                                                     REFIID riid,
                                                     IUnknown * punk
                                                     )
{
    if (m_pibsc)
    {
        return m_pibsc->OnObjectAvailable(riid, punk);
    }
    else
    {
        return E_NOTIMPL;
    }
}

HRESULT DefaultIBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    if (m_pibsc)
    {
        return m_pibsc->OnLowResource(dwReserved);
    }
    else
    {
        return E_NOTIMPL;
    }
}

HRESULT DefaultIBindStatusCallback::OnStopBinding(
                                                 HRESULT hrStatus,
                                                 LPCOLESTR szStatusText
                                                 )
{
    if (m_pibsc)
    {
        m_pibsc->OnStopBinding(hrStatus, szStatusText);
    }
    ShowWindow(m_hDlg, SW_HIDE);
    m_fShown = FALSE;

    return S_OK;
}

HRESULT DefaultIBindStatusCallback::GetWindow(
    REFGUID rguidReason,
    HWND* phwnd
    )
{
    *phwnd = GetDesktopWindow();
    return S_OK;
}

HRESULT DefaultIBindStatusCallback::OnCodeInstallProblem(
    ULONG ulStatusCode,
    LPCWSTR szDestination,
    LPCWSTR szSource,
    DWORD dwReserved
    )
{
    return S_OK;
}
    
INT_PTR DefaultIBindStatusCallback::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return TRUE;
    case WM_SHOWWINDOW:
        {
            if (NULL == m_pBinding)
            {
                // remove the cancel button
                ShowWindow(GetDlgItem(hwndDlg, IDCANCEL),SW_HIDE);
            }
            SendMessage(hwndDlg, WM_UPDATECONTROLS, 0, 0);
        }
        break;
    case WM_UPDATECONTROLS:
        {
            // update the dialog controls
            SendDlgItemMessage(hwndDlg, IDC_PROGRESS1, PBM_SETRANGE, 0, MAKELPARAM(0, m_ulProgressMax));
            SendDlgItemMessage(hwndDlg, IDC_PROGRESS1, PBM_SETPOS, m_ulProgress, 0);
            SetDlgItemTextW(hwndDlg, IDC_TEXT, m_szStatusText);
        }
        break;
    case WM_COMMAND:
        if (IDCANCEL == LOWORD(wParam))
        {
            // user has clicked cancel
            if (NULL != m_pBinding)
            {
                WCHAR szText[256];
                WCHAR szCaption[256];
                LoadStringW(m_hInstance, IDS_TEXT, szText, 256);
                LoadStringW(m_hInstance, IDS_CAPTION, szCaption, 256);
                m_pBinding->Suspend();
                if (IDYES == MessageBoxW(hwndDlg, szText, szCaption, MB_YESNO))
                {
                    m_pBinding->Abort();
                }
                else
                {
                    m_pBinding->Resume();
                }
            }

            // don't let the dialog box close itself
            return TRUE;
        }
        break;
    default:
        break;
    }

    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   CreateStdProgressIndicator
//
//  Synopsis:   retrieves a standard implementation of the
//              IBindStatusCallback interface
//
//  Arguments:  [hwndParent]  - (in) handle to the parent window (may be NULL)
//              [pszTitle]    - (in) optional text for the dialog's title bar
//              [pIbscCaller] - (in) optional IBindStatusCallback interface
//                               to recieve notifications (see notes)
//              [ppIbsc]      - (out) standard IBindStatusCallback
//                               implementation
//
//  Returns:    S_OK          - success
//              E_OUTOFMEMORY - not enough memory to create the dialog object
//              E_UNEXPECTED  - error initializing the dialog
//
//  History:    7-01-1997   stevebl   Created
//              7-07-1997   stevebl   Added pszTitle and pIbsc parameters
//
//  Notes:      The implementation of IBindStatusStatusCallback provided by
//              this function will forward any notifications it recieves
//              (i.e. method calls) to the pIbsc pointer (if one provided).
//              This provides a mechanism for a program to monitor the
//              progress of the operation and thereby determine when it has
//              completed.
//
//              NOTE: The IBindStatusCallback::GetBindInfo method is _NOT_
//              forwarded.  This implementation always requests asynchronous
//              binding by setting *pgrfBINDF to BIND_ASYNCHRONOUS.
//
//              Typically, the caller will want to implement only
//              IBindStatusCallback::StopBinding, returning E_NOTIMPL for
//              the other methods.
//
//---------------------------------------------------------------------------

STDMETHODIMP CreateStdProgressIndicator(HWND hwndParent,
    LPCOLESTR pszTitle,
    IBindStatusCallback * pIbscCaller,
    IBindStatusCallback ** ppIbsc)
{
    DefaultIBindStatusCallback * p = new DefaultIBindStatusCallback(hwndParent, pIbscCaller);
    if (p)
    {
        if (p->Init(pszTitle))
        {
            p->QueryInterface(IID_IBindStatusCallback, (void **) ppIbsc);
            return S_OK;
        }
        else
        {
            delete p;
            return E_UNEXPECTED;
        }
    }
    else
        return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\dllapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dllapi.cxx
//
//  Contents:   API entry points for DLL manipulation
//
//  Functions:  CoLoadLibrary
//              CoFreeLibrary
//              CoFreeAllLibraries
//              CoFreeUnusedLibraries
//
//  History:    12-May-93 Ricksa    Created
//              31-Dec-93 ErikGav   Chicago port
//
//--------------------------------------------------------------------------

#include    <ole2int.h>
#include    <objact.hxx>

STDAPI_(void) CoFreeUnusedLibrariesEx(DWORD dwUnloadDelay, DWORD dwReserved);

//+-------------------------------------------------------------------------
//
//  Function:   CoLoadLibrary
//
//  Synopsis:   Loads a DLL
//
//  Arguments:  [pLibName] - name of DLL to load
//              [fAutoLoad] - whether DLL s/b unloaded automatically.
//
//  Returns:    HINSTANCE
//
//  Algorithm:  Just calls through to the Windows.
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      This API is provided for Cross Platform portability.
//
//--------------------------------------------------------------------------
STDAPI_(HINSTANCE) CoLoadLibrary(LPWSTR pLibName, BOOL fAutoLoad)
{
    OLETRACEIN((API_CoLoadLibrary, PARAMFMT("pLibName= %ws, fAutoLoad= %B"), pLibName, fAutoLoad));

    HINSTANCE hInst = NULL;

    hInst = LoadLibraryEx(pLibName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    OLETRACEOUTEX((API_CoLoadLibrary, RETURNFMT("%x"), hInst));

    return hInst;
}


//+-------------------------------------------------------------------------
//
//  Function:   CoFreeLibrary
//
//  Synopsis:   Used to free a DLL loaded by CoLoadLibrary.
//
//  Arguments:  [hInst] - handle to DLL
//
//  Algorithm:  Just passes through call to the OS
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      This API is provided for Cross Platform portability.
//
//--------------------------------------------------------------------------
STDAPI_(void) CoFreeLibrary(HINSTANCE hInst)
{
    OLETRACEIN((API_CoFreeLibrary, PARAMFMT("hInst= %x"), hInst));

    FreeLibrary(hInst);

    OLETRACEOUTEX((API_CoFreeLibrary, NORETURN));
}


//+-------------------------------------------------------------------------
//
//  Function:   CoFreeAllLibraries
//
//  Synopsis:   Free all libraries
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      All libraries are freed at process exit in Win32 anyway
//              so we just notify any unused libraries that they can
//              go way in the DEV build so memory can be totally cleaned
//              up to facilitate the discovery of memory leaks.
//
//--------------------------------------------------------------------------
STDAPI_(void) CoFreeAllLibraries(void)
{
    OLETRACEIN((API_CoFreeAllLibraries, NOPARAM));

#if DBG == 1
    CoFreeUnusedLibraries();
#endif // DBG

    OLETRACEOUTEX((API_CoFreeAllLibraries, NORETURN));
}

//+-------------------------------------------------------------------------
//
//  Function:   CoFreeUnusedLibraries
//
//  Synopsis:   Free any unused single-threaded DLLS.
//
//  Algorithm:  Ask DLL cache objects to free any DLLs that respond
//              to DllCanUnloadNow with TRUE.
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      The DllCanUnloadNow protocol is as follows:
//
//              Apartment Model DLLs: CoFreeUnusedLibraries must be called on
//              each thread that has loaded an object from the DLL, before the
//              DLL will realy be unloaded.
//
//              FreeThreaded DLLs: OLE will wait 10 minutes from the last
//              use of the DLL before unloading it.
//
//--------------------------------------------------------------------------
STDAPI_(void) CoFreeUnusedLibraries(void)
{
    OLETRACEIN((API_CoFreeUnusedLibraries, NOPARAM));

    CoFreeUnusedLibrariesEx(INFINITE, 0);

    OLETRACEOUTEX((API_CoFreeUnusedLibraries, NORETURN));
}

//+-------------------------------------------------------------------------
//
//  Function:   CoFreeUnusedLibraries
//
//  Synopsis:   Free any unused single-threaded DLLS.
//
//  Algorithm:  Ask DLL cache objects to free any DLLs that respond
//              to DllCanUnloadNow with TRUE.
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      The DllCanUnloadNow protocol is as follows:
//
//              Apartment Model DLLs: CoFreeUnusedLibraries must be called on
//              each thread that has loaded an object from the DLL, before the
//              DLL will realy be unloaded.
//
//              ThreadNeutral and FreeThreaded DLLs: OLE will wait dwUnloadDelay
//              milliseconds from the last use of the DLL before unloading it.
//
//--------------------------------------------------------------------------
STDAPI_(void) CoFreeUnusedLibrariesEx(DWORD dwUnloadDelay, DWORD dwReserved)
{
    OLETRACEIN((API_CoFreeUnusedLibraries, PARAMFMT("dwUnloadDelay= %x"), dwUnloadDelay));

    HRESULT hr;
    COleTls tls(hr);    // ensure TLS exists

    if (SUCCEEDED(hr))
    {
        if (!IsWOWProcess())
        {
            CCFreeUnused(dwUnloadDelay);
        }
    }

    OLETRACEOUTEX((API_CoFreeUnusedLibraries, NORETURN));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\dllhost.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dllhost.cxx
//
//  Contents:   code for activating inproc dlls of one threading model
//              from apartments of a different threading model.
//
//  History:    04-Mar-96   Rickhi      Created
//              06-Feb-98   JohnStra    Add NTA (Neutral Threaded Apartment)
//                                      support.
//              18-Jun-98   GopalK      Fixed shutdown races
//
//  Notes:      the basic idea is to call over to an apartment of the
//              appropriate type, get it to do the object creation, then
//              marshal the object back to the calling apartment.
//
//              NTA objects are different in that the can be on the same
//              thread as STA or MTA objects.  This means we dont always
//              need a full-blown proxy/channel/stub between objects just
//              because they are in different apartments.  We still need
//              to marshal a pointer to an interface on the object back to
//              the client, though, because we will need a way to put in a
//              lightweight switcher when they are available.
//
//+-------------------------------------------------------------------------
#include <ole2int.h>
#include <dllcache.hxx>
#include <dllhost.hxx>
#include <comsrgt.hxx>
#include <..\dcomrem\marshal.hxx>

// globals for the various thread-model hosts
CDllHost    gSTHost;      // single-threaded host object for STA clients
CDllHost    gSTMTHost;    // single-threaded host object for MTA clients
CDllHost    gATHost;      // apartment-threaded host object fo MTA clients
CDllHost    gMTHost;      // mutli-threaded host object for STA client
CDllHost    gNTHost;      // neutral-threaded host object for STA/MTA clients

ULONG       gcHostProcessInits = 0; // count of DLL host threads.
ULONG       gcNAHosts = 0;          // count of NA hosts.
UINT_PTR    gTimerId = 0;           // Timer Id for STAHost thread.



//+-------------------------------------------------------------------
//
//  Member:     CDllHost::QueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CDllHost::QueryInterface(REFIID riid, void **ppv)
{
    // only valid to call this from within the host apartment
    Win4Assert(NeutralHost() || _dwHostAptId == GetCurrentApartmentId());

    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IDLLHost) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IDLLHost *) this;
        AddRef();
        hr = S_OK;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CDllHost::AddRef, public
//
//  Synopsis:   we dont refcnt this object so this is a noop
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------
ULONG CDllHost::AddRef(void)
{
    // only valid to call this from within the host apartment, or in the process of getting
    // the activator token.
    Win4Assert(NeutralHost() || _dwHostAptId == GetCurrentApartmentId() || (_hActivator == NULL));
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CDllHost::Release, public
//
//  Synopsis:   we dont refcnt this object so this is a noop
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------
ULONG CDllHost::Release(void)
{
    // only valid to call this from within the host apartment
    Win4Assert(NeutralHost() || _dwHostAptId == GetCurrentApartmentId() || (_hActivator == NULL));
    return 1;
}

//+-------------------------------------------------------------------------
//
//  Function:   DoSTClassCreate / DoATClassCreate / DoMTClassCreate
//
//  Synopsis:   Package up get class object so that happens on the proper
//              thread
//
//  Arguments:  [fnGetClassObject] - DllGetClassObject entry point
//              [rclsid] - class id of class object
//              [riid] - interface requested
//              [ppunk] - where to put output interface.
//
//  Returns:    NOERROR - Successfully returned interface
//              E_OUTOFMEMORY - could not allocate memory buffer.
//
//  Algorithm:  pass on to the CDllHost object for the correct apartment.
//
//  History:    06-Nov-94   Ricksa      Created
//              22-Feb-96   KevinRo     Changed implementation drastically
//              06-Mar-96   Rickhi      Use CDllHost
//
//--------------------------------------------------------------------------
HRESULT DoSTClassCreate(CClassCache::CDllPathEntry *pDPE,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk)
{
    ComDebOut((DEB_DLL, "DoSTClassCreate rclsid:%I\n", &rclsid));

    HActivator hActivator;
    gSTHost.GetApartmentToken(hActivator);

    return gSTHost.GetClassObject((ULONG64) pDPE, rclsid, riid, ppunk, DLLHOST_IS_DPE);
}

HRESULT DoSTMTClassCreate(CClassCache::CDllPathEntry *pDPE,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk)
{
    ComDebOut((DEB_DLL, "DoSTClassCreate rclsid:%I\n", &rclsid));

    HActivator hActivator;
    gSTMTHost.GetApartmentToken(hActivator);

    return gSTMTHost.GetClassObject((ULONG64) pDPE, rclsid, riid, ppunk, DLLHOST_IS_DPE);
}

HRESULT DoATClassCreate(CClassCache::CDllPathEntry *pDPE,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk)
{
    ComDebOut((DEB_DLL, "DoATClassCreate rclsid:%I\n", &rclsid));
    return gATHost.GetClassObject((ULONG64) pDPE, rclsid, riid, ppunk, DLLHOST_IS_DPE);
}

HRESULT DoATClassCreate(LPFNGETCLASSOBJECT pfn,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk)
{
    ComDebOut((DEB_DLL, "DoATClassCreate rclsid:%I\n", &rclsid));
    HActivator hActivator;

    gATHost.GetApartmentToken(hActivator);
    return gATHost.GetClassObject((ULONG64) pfn, rclsid, riid, ppunk, DLLHOST_IS_PFN);
}

HRESULT DoMTClassCreate(CClassCache::CDllPathEntry *pDPE,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk)
{
    ComDebOut((DEB_DLL, "DoMTClassCreate rclsid:%I\n", &rclsid));
    return gMTHost.GetClassObject((ULONG64) pDPE, rclsid, riid, ppunk, DLLHOST_IS_DPE);
}
//+-------------------------------------------------------------------------
//
//  Function:   DoSTApartmentCreate / DoATApartmentCreate / DoMTApartmentCreate
//
//  Synopsis:   Package up get class object so that happens on the proper
//              thread
//
//  Arguments:  [fnGetClassObject] - DllGetClassObject entry point
//              [rclsid] - class id of class object
//              [riid] - interface requested
//              [ppunk] - where to put output interface.
//
//  Returns:    NOERROR - Successfully returned interface
//              E_OUTOFMEMORY - could not allocate memory buffer.
//
//  Algorithm:  pass on to the CDllHost object for the correct apartment.
//
//  History:    06-Nov-94   Ricksa      Created
//              22-Feb-96   KevinRo     Changed implementation drastically
//              06-Mar-96   Rickhi      Use CDllHost
//
//--------------------------------------------------------------------------
HRESULT DoSTApartmentCreate(HActivator &hActivator)
{
    ComDebOut((DEB_DLL, "DoSTApartmentCreate\n"));
    return gSTHost.GetApartmentToken(hActivator);
}

HRESULT DoSTMTApartmentCreate(HActivator &hActivator)
{
    ComDebOut((DEB_DLL, "DoSTApartmentCreate\n"));
    return gSTMTHost.GetApartmentToken(hActivator);
}

HRESULT DoATApartmentCreate(HActivator &hActivator)
{
    ComDebOut((DEB_DLL, "DoATApartmentCreate\n"));
    return gATHost.GetApartmentToken(hActivator);
}

HRESULT DoMTApartmentCreate(HActivator &hActivator)
{
    ComDebOut((DEB_DLL, "DoMTApartmentCreate\n"));
    return gMTHost.GetApartmentToken(hActivator);
}

HRESULT DoNTApartmentCreate(HActivator &hActivator)
{
    ComDebOut((DEB_DLL, "DoNTApartmentCreate\n" ));
    return gNTHost.GetApartmentToken(hActivator);
}

HRESULT DoNTClassCreate(
    CClassCache::CDllPathEntry* pDPE,
    REFCLSID                    rclsid,
    REFIID                      riid,
    IUnknown**                  ppunk
    )
{
    ComDebOut((DEB_DLL, "DoNTClassCreate rclsid:%I STA:%d\n", &rclsid, IsSTAThread()));
    return gNTHost.GetClassObject((ULONG64) pDPE, rclsid, riid, ppunk, DLLHOST_IS_DPE);
}

HRESULT ATHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj)
{
    ComDebOut((DEB_DLL, "ATHostActivatorGetClassObject\n"));

    HActivator hActivator;
    HRESULT hr;

    hr = gATHost.GetApartmentToken(hActivator);

    if (SUCCEEDED(hr))
    {
        hr = GetInterfaceFromStdGlobal(hActivator,
                                       riid,
                                       ppvClassObj);
    }
    return hr;
}

HRESULT MTHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj)
{
    ComDebOut((DEB_DLL, "MTHostActivatorGetClassObject\n"));

    HActivator hActivator;
    HRESULT hr;

    hr = gMTHost.GetApartmentToken(hActivator);

    if (SUCCEEDED(hr))
    {
        hr = GetInterfaceFromStdGlobal(hActivator,
                                       riid,
                                       ppvClassObj);
    }
    return hr;
}

HRESULT NTHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj)
{
    ComDebOut((DEB_DLL, "NTHostActivatorGetClassObject\n"));

    HActivator hActivator;
    HRESULT hr;

    hr = gNTHost.GetApartmentToken(hActivator);

    if (SUCCEEDED(hr))
    {
        hr = GetInterfaceFromStdGlobal(hActivator,
                                       riid,
                                       ppvClassObj);
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::GetClassObject
//
//  Synopsis:   called by an apartment to get a class object from
//              a host apartment.
//
//  History:    04-Mar-96   Rickhi      Created
//              06-Feb-98   JohnStra    Added NTA (NEUTRAL) support
//
//--------------------------------------------------------------------------
HRESULT CDllHost::GetClassObject(
    ULONG64  hDPE,
    REFCLSID   rclsid,
    REFIID     riid,
    IUnknown** ppUnk,
    DWORD      dwFlags
    )
{
    ComDebOut((DEB_DLL, "CDllHost::GCO this:%x tid:%x hDPE:%I64x rclsid:%I riid:%I ppUnk:%x\n", this, GetCurrentThreadId(), hDPE, &rclsid, &riid, ppUnk));

    // Get a pointer to a proxy for the host running in the appropriate
    // appartment.  When we've acquired the proxy, we can call its
    // DllGetClassObject method.  The class factory will then get
    // marshaled and we will have a pointer to the factory's proxy.

    HRESULT hr = CO_E_DLLNOTFOUND;

    IDLLHost *pIDLLHost = GetHostProxy();
    if (pIDLLHost)
    {
    	GUID guidProcessSecret;

    	hr = gProcessSecret.GetProcessSecret(&guidProcessSecret);
        if (SUCCEEDED(hr))
        {
            hr = pIDLLHost->DllGetClassObject(hDPE, guidProcessSecret, rclsid, riid, ppUnk, dwFlags);
        }
        pIDLLHost->Release();
    }

    ComDebOut((DEB_DLL, "CDllHost::GetClassObject this:%x hr:%x\n", this, hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::DllGetClassObject
//
//  Synopsis:   Calls the passed in DllGetClassObject on the current thread.
//              Used by an apartment of one threading model to load a DLL
//              of another threading model.
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CDllHost::DllGetClassObject(ULONG64 hDPE, GUID guidCallersSecret,
                REFCLSID rclsid, REFIID riid, IUnknown **ppUnk, DWORD dwFlags)
{
    ComDebOut((DEB_DLL,
        "CDllHost::DllGetClassObject this:%x tid:%x hDPE:%I64x rclsid:%I riid:%I ppUnk:%x\n",
        this, GetCurrentThreadId(), hDPE, &rclsid, &riid, ppUnk));

    // only valid to call this from within the host apartment
    Win4Assert(NeutralHost() || _dwHostAptId == GetCurrentApartmentId());
    Win4Assert((dwFlags == DLLHOST_IS_DPE) || (dwFlags == DLLHOST_IS_PFN));

    HRESULT hr;

    // Verify that caller knows the correct secret.  IDllHost should
    // never be invoked by out-of-process code.
    hr = gProcessSecret.VerifyMatchingSecret(guidCallersSecret);
    if (FAILED(hr))
        return hr;

    if (dwFlags == DLLHOST_IS_DPE)
    {
        hr = ((CClassCache::CDllPathEntry *)hDPE)->DllGetClassObject(rclsid, riid, ppUnk, TRUE);
    }
    else
    {
        hr = ((LPFNGETCLASSOBJECT)hDPE)(rclsid, riid, (void **) ppUnk);
    }

    ComDebOut((DEB_DLL,"CDllHost::DllGetClassObject this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::GetHostProxy
//
//  Synopsis:   returns the host proxy, AddRef'd.  Creates it (and
//              potentially the host apartment) if it does not yet exist.
//
//  History:    04-Mar-96   Rickhi      Created
//              06-Feb-98   JohnStra    Added NTA (NEUTRAL) support
//              24-Jun-98   GopalK      Simplified by removing redundant
//                                      functionality
//--------------------------------------------------------------------------
IDLLHost *CDllHost::GetHostProxy()
{
    // We could be called from any thread, esp one that has not done any
    // marshaling/unmarshaling yet, so we need to initialize the channel
    // if not already done.
    if (FAILED(InitChannelIfNecessary()))
        return NULL;

    // Prevent two threads from creating the proxy simultaneously.
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    // Check if the host is shutting down before attempting to do anything
    // with it.  If its shutting down, return NULL.
    IDLLHost *pIDH = NULL;
    if ((_dwType & HDLLF_SHUTTINGDOWN) == 0)
    {
        pIDH = _pIDllProxy;
        if (pIDH == NULL)
        {
            // The host thread marshaled the interface pointer into _objref and
            // placed the hresult into _hrMarshal. Check it and unmarshal to
            // get the host interface proxy.
            if (SUCCEEDED(_hrMarshal))
            {
                Win4Assert(_pIDllProxy == NULL);
                Unmarshal();
                pIDH = _pIDllProxy;
            }
        }

        // AddRef the proxy before releasing the lock.
        if (pIDH)
            pIDH->AddRef();
    }

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    return pIDH;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::GetApartmentToken
//
//  Synopsis:   returns GIT cookie for host apartment's activator.
//              Creates the host apartment if it does not yet exist.
//
//  History:    25-Feb-98   SatishT      Created
//
//--------------------------------------------------------------------------
HRESULT CDllHost::GetApartmentToken(HActivator &hActivator)
{
    // we could be called from any thread, esp one that has not done any
    // marshaling/unmarshaling yet, so we need to initialized the channel
    // if not already done.

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
    {
        return hr;
    }

    // prevent two threads from creating the apartment simultaneously.
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    hActivator = NULL;
    hr = CO_E_SERVER_STOPPING;

    if (!(_dwType & HDLLF_SHUTTINGDOWN))
    {
        hr = S_OK;

        // host is still active, get or create the proxy
        if (_hActivator == NULL)
        {
            // apartment does not yet exist, create it -- only
            // done for apartment-threaded and multi-threaded.
            DWORD dwType = _dwType & HDLLF_HOSTTYPEMASK;
            if (dwType == HDLLF_SINGLETHREADED && gdwMainThreadId == 0)
            {
                // single threaded DLL and there is no main thread yet, so we
                // create an apartment thread that will also act as the main
                // thread.
                dwType = HDLLF_APARTMENTTHREADED;
            }            

            switch (dwType)
            {
            case HDLLF_SINGLETHREADED:
                {
                    COleTls Tls;
                    CObjectContext *pSavedCtx = NULL;
                    CObjectContext *pDefaultCtx = IsSTAThread() ? Tls->pNativeCtx : g_pMTAEmptyCtx;
                    BOOL fRestore = (GetCurrentThreadId()==gdwMainThreadId) && IsThreadInNTA();

                    // If the current thread itself is the main thread,
                    // restore native state
                    if(fRestore)
                    {
                        pSavedCtx = LeaveNTA(pDefaultCtx);
                    }

                    // send a message to the single-threaded host apartment (the
                    // OleMainThread) to marshal the host interface.
                    //
                    CComApartment *pApt = NULL;
                    hr = GetApartmentByID(gdwMainThreadId, &pApt);
                    if (SUCCEEDED(hr))
                    {
                        hr = pApt->QueueMessage(WM_OLE_GETCLASS, (IMessageParam *)this);
                        Win4Assert(SUCCEEDED(hr));
                        if (SUCCEEDED(hr))
                        {
                            _hr = CO_E_SERVER_STOPPING;
                            if (!SSSendMessage(ghwndOleMainThread, 
                                               WM_OLE_GETCLASS,
                                               WMSG_MAGIC_VALUE, 
                                               (LPARAM)((IMessageParam *)this)))
                            {
                                HRESULT hr2 = pApt->RemoveMessage(WM_OLE_GETCLASS, 
                                                                  (IMessageParam *)this);
                                if (SUCCEEDED(hr2))
                                    this->Release();
                            }
                            hr = _hr;
                        }

                        pApt->Release();
                    }

                    // If we switched out of the NA above, switch back now.
                    if (fRestore)
                    {
                        pSavedCtx = EnterNTA(pSavedCtx);
                        Win4Assert(pSavedCtx == pDefaultCtx);
                    }

                    break;
                }

            case HDLLF_NEUTRALTHREADED:
                {
                    // Increment the host process inits
                    InterlockedIncrement( (LONG *)&gcHostProcessInits );
                    InterlockedIncrement( (LONG *)&gcNAHosts );

                    // Unconditionally enter the NTA.  We must enter it to
                    // initialize the NTA channel and get a token for the
                    // apartment.
                    COleTls tls;
                    CObjectContext* pCurrentCtx;
                    BOOL fSwitched = EnterNTAIfNecessary(tls, &pCurrentCtx);

                    // Create an apartment activator cookie.
                    _dwHostAptId = GetCurrentApartmentId();
                    _dwTid       = GetCurrentThreadId();
                    _dwType     |= HDLLF_COMAPARTMENT;
                    hr = GetCurrentApartmentToken(_hActivator, TRUE);

                    // That's it.  Now that we've initialized the NTA channel
                    // and registered the NTA in the activator table, we pop
                    // back to the previous apartment.
                    LeaveNTAIfNecessary(tls, fSwitched, pCurrentCtx);

                    break;
                }

            case HDLLF_MULTITHREADED:
                // it is possible that we're comming through here twice if
                // the first time through we got an error in the marshal or
                // unmarshal, so dont create the event twice.
                if (_hEventWakeUp == NULL)
                    _hEventWakeUp = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (_hEventWakeUp == NULL)
                {
                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
                    break;
                }

                // fallthru to common code for these two cases.

            case HDLLF_APARTMENTTHREADED:
                // create a thread to act as the apartment for the dll host. It
                // will marshal the host interface and set an event when done.

                // it is possible that we're comming through here twice if
                // the first time through we got an error in the marshal or
                // unmarshal, so dont create the event twice.
                if (_hEvent == NULL)
                    _hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (_hEvent)
                {
                    _dwType |= HDLLF_COMAPARTMENT;
                    hr = CacheCreateThread( DLLHostThreadEntry, this );
                    if (SUCCEEDED(hr))
                    {
                        WaitForSingleObject(_hEvent, 0xffffffff);
                        hr = _hr;
                    }
                    else
                    {
                        _dwType &= ~HDLLF_COMAPARTMENT;
                    }
                }
                else
                {
                    hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
                }

                // dont try to cleanup if there are errors from the other
                // thread, we'll just try again later.
                break;
            }

        }

        // the other thread registered its activator in the GIT and
        // placed the GIT cookie into _hActivator. If there was an error
        // it will be NULL, and that's fine.

        hActivator = _hActivator;
    }


    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetSingleThreadedHost
//
//  Synopsis:   Get the host interface for single threaded inproc class
//              object creation.
//
//  Arguments:  [param] - pointer to the CDllHost for the single-threaded
//                        host apartment.
//
//  History:    06-Mar-96   Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT GetSingleThreadedHost(LPARAM param)
{
    ComDebOut((DEB_DLL,
               "GetSingleThreadedHost pDllHost:%x tid:%x\n",
               param,
               GetCurrentThreadId()));    

    // param is the ptr to the CDllHost object. Just tell it to marshal
    // it's IDLLHost interface into it's _objref. The _objref will be
    // unmarshaled by the calling apartment and the proxy placed in
    // _pIDllProxy.   Dont need to call Lock because we are already
    // guarenteed to be the only thread accessing the state at this time.
    IMessageParam *pMsgParam = (IMessageParam *)(param);
    CComApartment *pCurrApt  = NULL;
    
    HRESULT hr = GetCurrentComApartment(&pCurrApt);
    if (SUCCEEDED(hr))
    {        
        hr = pCurrApt->RemoveMessage(WM_OLE_GETCLASS, pMsgParam);
        if (SUCCEEDED(hr))
        {
            CDllHost *pDllHost = (CDllHost *)(pMsgParam);

            hr = pDllHost->GetSingleThreadHost();
            pDllHost->Release();
        }
        else
        {
            ComDebOut((DEB_ERROR, "Invalid parameter passed to GetSingleThreadedHost! 0x%p\n", param));
        }

        pCurrApt->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::GetSingleThreadedHost
//
//  Synopsis:   Get the host interface for single threaded inproc class
//              object creation.
//
//  History:    06-Apr-96   Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT CDllHost::GetSingleThreadHost()
{
    // set up the TID and apartment id, then marshal the interface
    _dwHostAptId = GetCurrentApartmentId();
    _dwTid       = GetCurrentThreadId();

    // Get or Create an apartment activator cookie
    HRESULT hr = GetCurrentApartmentToken(_hActivator, TRUE);


    if (SUCCEEDED(hr))
    {
        // Marshal here, because you must marshal when you initialize your
        // Activator token.
        hr = Marshal(); 
    }

    //
    // Send the HRESULT back in the object
    //

    _hr = hr;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DLLHostThreadEntry
//
//  Synopsis:   Worker thread entry point for AT & MT DLL loading
//
//  History     06-Apr-96   Rickhi      Created
//
//+-------------------------------------------------------------------------
DWORD _stdcall DLLHostThreadEntry(void *param)
{
    ComDebOut((DEB_DLL, "DLLHostThreadEntry Tid:%x\n", GetCurrentThreadId()));

    CDllHost *pDllHost = (CDllHost *)param;
    ComDebOut((DEB_DLL, "--> WorkerThread CDllHost:0x%x, HostInits:%d, ProcessInits:%d\n",
               pDllHost, gcHostProcessInits, g_cProcessInits));
    HRESULT hr = pDllHost->WorkerThread();
    ComDebOut((DEB_DLL, "<-- WorkerThread CDllHost:0x%x, HostInits:%d, ProcessInits:%d\n",
               pDllHost, gcHostProcessInits, g_cProcessInits));

    ComDebOut((DEB_DLL, "DLLHostThreadEntry hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     WorkerThread
//
//  Synopsis:   Worker thread for STA and MTA DLL loading. Single threaded
//              Dlls are loaded on the main thread (gdwOleMainThread).
//
//  History     06-Apr-96   Rickhi      Created
//
//+-------------------------------------------------------------------------
HRESULT CDllHost::WorkerThread()
{
    ComDebOut((DEB_DLL, "WorkerThread pDllHost:%x\n", this));

    // We can't look at _hEvent after we let the caller go because the caller
    // can NULL it. Thus we save it in a local stack var.
    Win4Assert(_hEvent);
    HANDLE hEventDone = _hEvent;

    HRESULT hr;
    COleTls Tls(hr);
    if(SUCCEEDED(hr))
    {
        // Mark the thread as a host
        Tls->dwFlags &= ~OLETLS_DISPATCHTHREAD;
        Tls->dwFlags  |= OLETLS_HOSTTHREAD;

        // Init the thread appropriatly
        BOOL fMTA = ((_dwType & HDLLF_HOSTTYPEMASK) == HDLLF_MULTITHREADED) ? TRUE : FALSE;
        hr = CoInitializeEx(NULL, fMTA ? COINIT_MULTITHREADED : COINIT_APARTMENTTHREADED);
        if(SUCCEEDED(hr))
        {
            // Count 1 more host process.
            InterlockedIncrement( (LONG *)&gcHostProcessInits );

            // Marshal the DllHost interface to pass back to the caller.
            _dwHostAptId = GetCurrentApartmentId();
            _dwTid       = GetCurrentThreadId();

            // Marshal IDllInterface
            hr = Marshal();

            // Create an apartment activator cookie
            if(SUCCEEDED(hr))
            {
                Win4Assert(fMTA || FAILED(GetCurrentApartmentToken(_hActivator, FALSE)));
                hr = GetCurrentApartmentToken(_hActivator, TRUE);
            }

            if(SUCCEEDED(hr))
            {
                // Wake up the thread that started us. Note we can't look
                // at the _hEventWakeup after that time because the other
                // thread could NULL it. Thus we stick it in a stack var.
                HANDLE hEventWakeUp = _hEventWakeUp;
                _hr = hr;
                SetEvent(hEventDone);

                // Enter a wait loop for work. stay there until told to exit.
                if (hEventWakeUp)
                {
                    MTAWorkerLoop(hEventWakeUp);
                }
                else
                {
                    STAWorkerLoop();
                }
            }

            // Special uninitialize for the host threads that does not take
            // the single thread mutex and does not check for process uninits.
            //
            // First, check to make sure that there is something to uninitialize-- it's
            // possible for user bugs to cause this thread to become uninitialized. 
            if (Tls->cComInits > 0)
            {
                wCoUninitialize(Tls, TRUE);
            }

            Win4Assert(_dwType & HDLLF_COMAPARTMENT);
            _dwType &= ~HDLLF_COMAPARTMENT;

            // Count 1 less host process *after* doing the Uninit.
            InterlockedDecrement((LONG *)&gcHostProcessInits);
        }

        // Revert the thread type
        Tls->dwFlags &= ~OLETLS_HOSTTHREAD;
    }

    // send back the status code inside the object
    _hr = hr;

    // Either CoInit/Marshal failed or we are exiting due to the last
    // CoUninitialize by some other thread. Wake up the calling thread.
    SetEvent(hEventDone);

    ComDebOut((DEB_DLL, "WorkerThread pDllHost:%x hr:%x\n", this, hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     MTAWorkerLoop
//
//  Synopsis:   Worker thread loop for MTA Host.
//
//  History     24-Oct-96   Rickhi      Created
//
//+-------------------------------------------------------------------------
void CDllHost::MTAWorkerLoop(HANDLE hEventWakeUp)
{
    while (1)
    {
        DWORD dwWakeReason = WaitForSingleObject(hEventWakeUp, 300000);
        if (dwWakeReason == WAIT_TIMEOUT)
        {
            //
            // We woke up because of a timeout. Go poll CoFreeUnusedLibraries.
            //

            CoFreeUnusedLibraries();
        }
        else
        {
            //
            // Woke up because the exit event was signalled. Just exit.
            //

            CloseHandle(hEventWakeUp);
            break;
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   STAHostTimerProc
//
//  Synopsis:   Timer proc for STA Host. When called, it calls CoFreeUnused
//              Libraries.
//
//  History     24-Oct-96   Rickhi      Created
//
//
//+-------------------------------------------------------------------------
void CALLBACK STAHostTimerProc(HWND hWnd, UINT uMsg, UINT_PTR uTimerId, DWORD dwTime)
{
    // go check if there are libraries to free
    CoFreeUnusedLibraries();
}

//+-------------------------------------------------------------------------
//
//  Member:     STAWorkerLoop
//
//  Synopsis:   Worker thread loop for STA Host.
//
//  History     24-Oct-96   Rickhi      Created
//
//+-------------------------------------------------------------------------
void CDllHost::STAWorkerLoop()
{
    HWND hWnd = TLSGethwndSTA();
    gTimerId = SetTimer(hWnd, 0, 300000, STAHostTimerProc);

    // enter a message loop to process requests.
    MSG msg;
    while (SSGetMessage(&msg, NULL, 0, 0))
    {
        if (CSurrogatedObjectList::TranslateAccelerator(&msg))
            continue;

        TranslateMessage(&msg);
        SSDispatchMessage(&msg);

        // Leverage appverifier.   Check for orphaned critsecs (should
        // never own any locks at this point).
        RtlCheckForOrphanedCriticalSections(GetCurrentThread());
    }

    KillTimer(hWnd, gTimerId);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::Marshal
//
//  Synopsis:   marshals IDLLHost interface on this object
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------------
HRESULT CDllHost::Marshal()
{
    ComDebOut((DEB_DLL, "CDllHost::Marshal this:%x tid:%x\n",
        this, GetCurrentThreadId()));

    // Only valid to call this from inside the host apartment.
    Win4Assert(IsThreadInNTA() || _dwHostAptId == GetCurrentApartmentId());

    // Marshal this objref so another apartment can unmarshal it.
    _hrMarshal = MarshalInternalObjRef(_objref,
                                       IID_IDLLHost,
                                       (IDLLHost*) this,
                                       MSHLFLAGS_NOPING,
                                       (void **)&_pStdId);

    if (SUCCEEDED(_hrMarshal))
    {
        // Make the unmarshaled proxy callable from any apartment.
        MakeCallableFromAnyApt(_objref);
    }

    ComDebOut((DEB_DLL, "CDllHost::Marshal this:%x hr:%x\n", this, _hrMarshal));
    return _hrMarshal;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::UnMarshal
//
//  Synopsis:   unmarshals the IDLLHost interface to create a proxy
//
//  History:    04-Mar-96   Rickhi      Created
//              12-Feb-98   Johnstra    Added NTA support
//
//  Notes:      Unmarshal never enters the NTA.  If it did, then it
//              just find the StdId for the NTA instead of the caller's.
//
//--------------------------------------------------------------------------
HRESULT CDllHost::Unmarshal()
{
    ComDebOut((DEB_DLL, "CDllHost::Unmarshal this:%x tid:%x\n",
              this,
              GetCurrentThreadId()));

    // Unless this is the NTA host, unmarshaling is only valid to call this from
    // outside the host apartment.

    Win4Assert((HDLLF_NEUTRALTHREADED & (_dwType & HDLLF_HOSTTYPEMASK)) ||
                _dwHostAptId != GetCurrentApartmentId());

    HRESULT hr = _hrMarshal;
    if (SUCCEEDED(hr))
    {
        // Unmarshal this objref so it can be used in this apartment.
        hr = UnmarshalInternalObjRef(_objref, (void **)&_pIDllProxy);

        // free the resouces held by the OBJREF.
        FreeObjRef(_objref);

        // indicate that we have free'd the OBJREF
        _hrMarshal = RPC_E_INVALID_OBJREF;
    }

    ComDebOut((DEB_DLL, "CDllHost::Unmarshal this:%x hr:%x\n", this, hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::Initialize
//
//  Synopsis:   initializer for Dll host object.
//
//  History:    04-Mar-96   Rickhi      Created
//
//--------------------------------------------------------------------------
HRESULT CDllHost::Initialize(DWORD dwType)
{
    ComDebOut((DEB_DLL,"CDllHost::Initialize this:%x type:%x\n", this,dwType));

    _dwType           = dwType;
    _dwHostAptId      = 0;
    _hActivator       = 0;
    _dwTid            = 0;
    _hrMarshal        = E_UNSPEC; // never been marshaled yet, dont cleanup
    _pStdId           = NULL;
    _pIDllProxy       = NULL;
    _hEvent           = NULL;
    _hEventWakeUp     = NULL;	

    return _mxs.Init();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::ClientCleanupStart
//
//  Synopsis:   starts client-side cleanup for Dll host object.
//
//  History:    04-Apr-96   Rickhi      Created
//              18-Jun-98   GopalK      Fixed races during shutdown
//
//--------------------------------------------------------------------------
HANDLE CDllHost::ClientCleanupStart()
{
    ComDebOut((DEB_DLL, "CDllHost::ClientCleanupStart this:%x AptId:%x\n",
        this, GetCurrentApartmentId()));
    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    HANDLE hWait = NULL;

    COleTls tls;
    CObjectContext* pCurrentCtx;
    BOOL fSwitched = EnterNTAIfNecessary(tls, &pCurrentCtx);

    // flag the host as shutting down. Prevents GetHostProxy from
    // creating another proxy
    Win4Assert(!(_dwType & HDLLF_SHUTTINGDOWN));
    _dwType |= HDLLF_SHUTTINGDOWN;

    if (_dwType & HDLLF_COMAPARTMENT)
    {
        if (_dwType & HDLLF_NEUTRALTHREADED)
        {
            // Unlike the MTA and STA hosts, the NTA host doesn't need to
            // call wCoUnintialize.  It can do all of its cleanup right
            // here.
            if (SUCCEEDED(_hrMarshal))
            {
                // still have the OBJREF around that we have
                // not yet Unmarshaled, so clean it up now.
                ReleaseMarshalObjRef(_objref);
                FreeObjRef(_objref);
                _hrMarshal = E_UNSPEC;
            }
            _dwType &= ~HDLLF_COMAPARTMENT;
            InterlockedDecrement( (LONG *) &gcHostProcessInits );
            InterlockedDecrement( (LONG *) &gcNAHosts );
        }
        else
        {
            // wakeup host thread to tell it to exit, then wait for it
            // to complete it's Uninitialization before continuing.
            Win4Assert(_hEvent);
            hWait = _hEvent;
            _hEvent = NULL;

            if (_dwType & HDLLF_MULTITHREADED)
            {
                Win4Assert(_hEventWakeUp);
                SetEvent(_hEventWakeUp);
                _hEventWakeUp = NULL;
            }
            else
            {
                PostThreadMessage(_dwTid, WM_QUIT, 0, 0);
            }
        }
    }

    // Since we own all the code that will run during cleanup, we know it
    // is safe to hold the lock for the duration.
    if (_pIDllProxy)
    {
        // proxy exists, release it.
        _pIDllProxy->Release();
        _pIDllProxy = NULL;
    }

    // Close the event handles.
    if (_hEvent)
    {
        CloseHandle(_hEvent);
        _hEvent = NULL;
    }

    if (_hEventWakeUp)
    {
        CloseHandle(_hEventWakeUp);
        _hEventWakeUp = NULL;
    }

    LeaveNTAIfNecessary(tls, fSwitched, pCurrentCtx);

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);

    ComDebOut((DEB_DLL, "CDllHost::ClientCleanupStart this:%x hWait:%x\n",
        this, hWait));
    return hWait;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::ClientCleanupFinish
//
//  Synopsis:   Finishes client-side cleanup for Dll host object.
//
//  History:    04-Apr-96   Rickhi      Created
//
//--------------------------------------------------------------------------
void CDllHost::ClientCleanupFinish(HANDLE hEvent)
{
    COleTls tls;
    CObjectContext* pCurrentCtx;
    BOOL fSwitched = EnterNTAIfNecessary(tls, &pCurrentCtx);

    ComDebOut((DEB_DLL, "CDllHost::ClientCleanupFinish this:%x AptId:%x hEvent:%x\n",
        this, GetCurrentApartmentId(), hEvent));
    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
    ASSERT_LOCK_NOT_HELD(_mxs);

    // wait for the server apartments to uninitialize before continuing.
    // Don't hold the lock across this call since some host apartment
    // may currently be processing a call which wants to use this
    // host.
    if (hEvent)
    {
        WaitForSingleObject(hEvent, 0xffffffff);
        CloseHandle(hEvent);
    }

    // allow activation again
    Win4Assert(!(_dwType & HDLLF_COMAPARTMENT));
    _dwType = (_dwType & HDLLF_HOSTTYPEMASK);

    LeaveNTAIfNecessary(tls, fSwitched, pCurrentCtx);
    ComDebOut((DEB_DLL, "CDllHost::ClientCleanupFinish this:%x\n", this));
}


//+-------------------------------------------------------------------------
//
//  Member:     CDllHost::ServerCleanup
//
//  Synopsis:   server-side cleanup for Dll host object.
//
//  History:    04-Apr-96   Rickhi      Created
//              14-Feb-98   Johnstra    make NTA aware
//
//  Notes:      Don't attempt to enter the NTA from within this method.
//              Per-apartment cleanup code will switch to the NTA
//              before calling us.
//
//--------------------------------------------------------------------------
void CDllHost::ServerCleanup(DWORD dwAptId)
{
    // only do cleanup if the apartment id's match
    if (_dwHostAptId != dwAptId)
        return;

    ComDebOut((DEB_DLL, "CDllHost::ServerCleanup this:%x AptId:%x Type:%x\n",
        this, GetCurrentApartmentId(), _dwType));

    // the _mxs mutex is already held in order to
    // prevent simultaneous use/creation of the proxy while this thread
    // is doing the cleanup. Since we own all the code that will run during
    // cleanup, we know it is safe to hold the lock for the duration.

    // revoke the apartment activator cookie (best faith effort)
    RevokeApartmentActivator();
    _hActivator = 0;

    if (SUCCEEDED(_hrMarshal))
    {
        // server side, marshal was successful and has not been
        // unmarshaled so release it now via RMD
        ReleaseMarshalObjRef(_objref);
        FreeObjRef(_objref);
        _hrMarshal = E_UNSPEC;
    }

    if (_pStdId)
    {
        // cleanup the server-side marshaling infrastructure.
        ((CStdMarshal *)_pStdId)->Disconnect(DISCTYPE_SYSTEM);
        _pStdId->Release();
        _pStdId = NULL;
    }

    ComDebOut((DEB_DLL,
        "CDllHost::Cleanup this:%x tid:%x\n", this, GetCurrentThreadId()));
}

//+-------------------------------------------------------------------------
//
//  Function:   IsMTAHostInitialized
//
//  Synopsis:   Returns TRUE if MTA Host is active
//
//  History     02-Jul-98   GopalK      Created
//
//+-------------------------------------------------------------------------
BOOL IsMTAHostInitialized()
{
    return(gMTHost.IsComApartment());
}

//+-------------------------------------------------------------------------
//
//  Function:   DllHostProcessInitialize
//
//  Synopsis:   initializes the state for DllHost objects.
//
//  History     06-Mar-96   Rickhi      Created
//              06-Feb-98   JohnStra    Add NTA support.
//
//+-------------------------------------------------------------------------
HRESULT DllHostProcessInitialize()
{
    HRESULT hr = gSTHost.Initialize(HDLLF_SINGLETHREADED);

    if (SUCCEEDED(hr)) 
        hr = gSTMTHost.Initialize(HDLLF_SINGLETHREADED);

    if (SUCCEEDED(hr)) 
        hr = gATHost.Initialize(HDLLF_APARTMENTTHREADED);

    if (SUCCEEDED(hr)) 
        hr = gMTHost.Initialize(HDLLF_MULTITHREADED);

    if (SUCCEEDED(hr)) 
        hr = gNTHost.Initialize(HDLLF_NEUTRALTHREADED);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllHostProcessUninitialize
//
//  Synopsis:   Cleans up the state for DllHost objects. This is called when
//              the process is going to uninitialize. It cleans up the
//              client half of the objects, and wakes the worker threads to
//              cleanup the server half of the objects.
//
//  History     06-Mar-96   Rickhi      Created
//              06-Feb-98   JohnStra    Add NTA support
//
//+-------------------------------------------------------------------------
void DllHostProcessUninitialize()
{
    ASSERT_LOCK_HELD(g_mxsSingleThreadOle);
    UNLOCK(g_mxsSingleThreadOle);
    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);

    // initiate the cleanup of the STA and MTA host objects
    // Dont hold the mxsSingleThreadOle because it has a lower
    // rank in the mutex hierarchy (ie another thread could call
    // GetHostProxy which takes mxs then creates a thread that takes
    // mxsSinglThreadOle which would be the opposite order of the
    // calls here).
    HANDLE h1 = gSTHost.ClientCleanupStart();
    HANDLE h2 = gSTMTHost.ClientCleanupStart();
    HANDLE h3 = gATHost.ClientCleanupStart();
    HANDLE h4 = gMTHost.ClientCleanupStart();
    HANDLE h5 = gNTHost.ClientCleanupStart();

    // Complete the cleanup of the STA and MTA host objects
    gSTHost.ClientCleanupFinish(h1);
    gSTMTHost.ClientCleanupFinish(h2);
    gATHost.ClientCleanupFinish(h3);
    gMTHost.ClientCleanupFinish(h4);
    gNTHost.ClientCleanupFinish(h5);

    // Sanity check
    Win4Assert(gcHostProcessInits - gcNAHosts == 0 );

    ASSERT_LOCK_NOT_HELD(g_mxsSingleThreadOle);
    LOCK(g_mxsSingleThreadOle);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllHostThreadUninitialize
//
//  Synopsis:   Cleans up the server-side state for any DllHost objects
//              that happen to live on this thread.
//
//  History     06-Mar-96   Rickhi      Created
//              08-Feb-98   JohnStra    Added NTA support
//
//+-------------------------------------------------------------------------
void DllHostThreadUninitialize()
{
    DWORD dwAptId = GetCurrentApartmentId();

    gSTHost.ServerCleanup(dwAptId);
    gSTMTHost.ServerCleanup(dwAptId);
    gATHost.ServerCleanup(dwAptId);
    gMTHost.ServerCleanup(dwAptId);
    gNTHost.ServerCleanup(dwAptId);
}



//+---------------------------------------------------------------------------
//
//  Function:   CoIsSurrogateProcess
//
//  Synopsis:   Returns TRUE if this is a surrogate process
//
//  History:    20-Oct-97   MikeW   Created
//
//----------------------------------------------------------------------------
BOOL CoIsSurrogateProcess()
{
    return (NULL != CCOMSurrogate::_pSurrogate);
}



//+-------------------------------------------------------------------------
//
//  Method:     CSurrogatedObjectList::TranslateAccelerator, static
//
//  Synopsis:   Try to translate an accelerator key in this message
//
//  Parameters: [pMsg]          -- The message
//
//  Returns:    TRUE if the message was translated, else FALSE
//
//  History:    17-Oct-97   MikeW   Created
//
//-------------------------------------------------------------------------

BOOL CSurrogatedObjectList::TranslateAccelerator(MSG *pMsg)
{
    if (pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST)
        return FALSE;

    COleTls                 tls;
    CSurrogatedObjectList  *pObject = tls->pSurrogateList;

    //
    // Try to find the object that owns this window
    //

    for ( ; NULL != pObject; pObject = pObject->_pNext)
    {
        //
        // Get the top level window for this object if we don't already have it
        //

        if (NULL == pObject->_hWnd)
        {
            if (S_OK != pObject->_pInplaceObject->GetWindow(&pObject->_hWnd))
            {
                pObject->_hWnd = NULL;      // just to be sure
                continue;
            }
        }

        //
        // If the destination window of the accelerator message is this object's
        // window or a child of it, then let it do the translation
        //

        if (pMsg->hwnd == pObject->_hWnd || IsChild(pObject->_hWnd, pMsg->hwnd))
        {
            HRESULT hr = pObject->_pInplaceObject->TranslateAccelerator(pMsg);

            return (S_OK == hr);
        }
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Function:   CoRegisterSurrogatedObject
//
//  Synopsis:   Register an object in the surrogate list
//
//  Parameters: [pObject]           -- The object
//
//  Returns:    S_OK if all is well
//
//  History:    17-Oct-97   MikeW   Created
//
//  CODEWORK:   Currently there is no way to remove the object from the
//              list.  This should be ok for restricted sites because
//              rpcss should forcibaly kill the process when all the
//              external refs are gone.
//
//-------------------------------------------------------------------------

HRESULT CoRegisterSurrogatedObject(IUnknown *pObject)
{
    IOleInPlaceActiveObject *pInplaceObject;
    HRESULT                  hr;
    CSurrogatedObjectList   *pEntry;
    HWND                     hWnd;

    hr = pObject->QueryInterface(
                        IID_IOleInPlaceActiveObject,
                        (void **) &pInplaceObject);

    if (S_OK == hr)
    {
        pEntry = new CSurrogatedObjectList(pInplaceObject);

        if (NULL == pEntry)
        {
            hr = E_OUTOFMEMORY;
            pInplaceObject->Release();
        }
        else
        {
            COleTls tls;

            //
            // NOTE: Not thread safe! This routine must be called on the
            // same thread that created the object
            //

            pEntry->_pNext = tls->pSurrogateList;
            tls->pSurrogateList = pEntry;
        }
    }
    else if (E_NOINTERFACE == hr)
    {
        //
        // We only need to do something if the object supports
        // IOleInPlaceActiveObject so don't complain if it doesn't
        //

        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\dsapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       dsapi.cxx
//
//  Contents:   Routines for lookup/queries of application state in the DS.
//
//  Functions:
//
//  History:    Feb-97  DKays   Created
//
//--------------------------------------------------------------------------

#include <ole2int.h>
#include <appmgmt.h>

#include "cfactory.hxx"
#include "resolver.hxx"
#include "objact.hxx"

LPCWSTR FindExt(LPCWSTR szPath);

#ifdef DIRECTORY_SERVICE

DWORD CheckDownloadRegistrySettings (void)
{
    static DWORD dwCSEnabled=0;
    static BOOL fInitialized=FALSE;

    if (!fInitialized)
    {
        DWORD dwType=0;
        DWORD dwSize=0;
        HKEY hKeyAppMgmt=NULL;

        // First check for a user specific policy
        if (ERROR_SUCCESS==RegOpenKeyEx(HKEY_CURRENT_USER,
                                        L"Software\\Policies\\Microsoft\\Windows\\App Management",
                                        0,
                                        KEY_QUERY_VALUE,
                                        &hKeyAppMgmt))
        {
            dwSize=sizeof(dwCSEnabled);
            if (ERROR_SUCCESS!=RegQueryValueEx(hKeyAppMgmt,
                                               L"COMClassStore",
                                               NULL,
                                               &dwType,
                                               (LPBYTE) &dwCSEnabled,
                                               &dwSize))
            {
                dwCSEnabled=0;
            }
            else if (dwType != REG_DWORD || 0 == dwSize)
            {
                dwCSEnabled=0;
            }
            RegCloseKey(hKeyAppMgmt);
        }

        // If no per-user policy was found or per-user policy didn't request
        // class store, check for per-machine policy
        if (!dwCSEnabled)
        {
            DWORD dwCSEnabledForMachine=0;
            if (ERROR_SUCCESS==RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                            L"Software\\Policies\\Microsoft\\Windows\\App Management",
                                            0,
                                            KEY_QUERY_VALUE,
                                            &hKeyAppMgmt))
            {
                dwSize=sizeof(dwCSEnabledForMachine);
                if (ERROR_SUCCESS!=RegQueryValueEx(hKeyAppMgmt,
                                                   L"COMClassStore",
                                                   NULL,
                                                   &dwType,
                                                   (LPBYTE) &dwCSEnabledForMachine,
                                                   &dwSize))
                {
                    // no value there
                    dwCSEnabledForMachine=0;
                }
                else if (dwType!=REG_DWORD || 0==dwSize)
                {
                    // the value is of wrong type
                    dwCSEnabledForMachine=0;
                }
                RegCloseKey(hKeyAppMgmt);
                if (dwCSEnabledForMachine)
                {
                    dwCSEnabled=dwCSEnabledForMachine;
                }
            }
        }
        fInitialized = TRUE;
    }

    return dwCSEnabled;
}


/*---------------------------------------------------------------
    Function(s) : DownloadClass

    Synopsis    : Downloads class from the Directory if it exists

    Remarks     : This is an overloaded function. It takes either a filename
                  or a class id as an argument. In either case, it downloads
                  the corresponding class from the Directory

    Arguments   :
        For the ClassID version :
                [clsid] : ClassID of the class that is to be downloaded
        For the filename version :
                [lpwszFileName] : Name of the file that needs to be handled. The file extension is
                                                 used to figure out the class that can handle this file
        Common parameters :
                [dwClsCtx] : Context for object creation
                [dwFlags]   : creation flags

    Return values : S_OK, MK_E_INVALIDEXTENSION, REGDB_E_CLASSNOTREG

    Created by    : RahulTh (11/21/97)
----------------------------------------------------------------*/
HRESULT DownloadClass( LPWSTR lpwszFileName, DWORD dwClsCtx )
{
    DWORD dwCSEnabled = (dwClsCtx & CLSCTX_ENABLE_CODE_DOWNLOAD) ? 1 : CheckDownloadRegistrySettings();

    if (dwCSEnabled)
    {
        INSTALLDATA InstallData;

        InstallData.Type = FILEEXT;
        InstallData.Spec.FileExt = (PWCHAR) FindExt(lpwszFileName);

        if ( ! InstallData.Spec.FileExt )
        {
            return HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        }

        DWORD code = InstallApplication( &InstallData );
        if (code != 0)
        {
            return HRESULT_FROM_WIN32(code);
        }
        else
        {
            return S_OK;
        }
    }

    return CS_E_PACKAGE_NOTFOUND; // this will get mapped to REGDB_E_CLASSNOTREG further up
}

HRESULT DownloadClass( CLSID clsid, DWORD dwClsCtx )
{
    // Determine if class store downloads are enabled
    // If either per-user or per-machine policy requests class store downloads we perform the lookup:
    // If we didn't, we would break per-user or per-machine applications that rely on class store download.

    DWORD dwCSEnabled = (dwClsCtx & CLSCTX_ENABLE_CODE_DOWNLOAD) ? 1 : CheckDownloadRegistrySettings();

    if (dwCSEnabled)
    {
        INSTALLDATA InstallData;

        InstallData.Type = COMCLASS;
        InstallData.Spec.COMClass.Clsid = clsid;
        InstallData.Spec.COMClass.ClsCtx = dwClsCtx;

        DWORD code = InstallApplication( &InstallData );
        if (code != 0)
        {
            return HRESULT_FROM_WIN32(code);
        }
        else
        {
            return S_OK;
        }
    }

    return CS_E_PACKAGE_NOTFOUND; // this will get mapped to REGDB_E_CLASSNOTREG further up
}

//+-------------------------------------------------------------------
//
//  Function:   CoInstall
//
//  Synopsis:   Downloads the specified class.
//
//  Returns:    S_OK, REGDB_E_CLASSNOTREG.
//
//  This routine is called from IE to do app/component downloads from
//  the NT5 Directory.
//
//--------------------------------------------------------------------
STDAPI CoInstall(
    IBindCtx     *pbc,
    DWORD         dwFlags,
    uCLSSPEC     *pClassSpec,
    QUERYCONTEXT *pQuery,
    LPWSTR        pszCodeBase)
{
    INSTALLDATA     InstallData;
    DWORD           Status;

    if ( ! pClassSpec )
        return E_INVALIDARG;

    if ( pClassSpec->tyspec !=  TYSPEC_CLSID )
        return CS_E_PACKAGE_NOTFOUND;

    InstallData.Type = COMCLASS;
    InstallData.Spec.COMClass.Clsid = pClassSpec->tagged_union.clsid;
    InstallData.Spec.COMClass.ClsCtx = pQuery->dwContext;

    Status = InstallApplication( &InstallData );

    if ( Status != ERROR_SUCCESS )
        return HRESULT_FROM_WIN32( Status );
    else
        return S_OK;

    //
    // TDB : How COM+ wants to interact with IE code download.
    //
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\defcxact.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       defcxact.cxx
//
//  Contents:   Activation Functions used by object servers.
//
//  Classes:    CObjServer
//
//  History:    24-Feb-98 vinaykr   Created/Separated from sobjact
//              15-Jun-98 GopalK    Simplified creation/destruction
//              22-Jun-98 CBiks     See RAID# 169589.  Added the activator
//                                  flags to the ACTIVATION_PROPERTIES
//                                  constructors.
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <iface.h>
#include    <olerem.h>

#include    <cfactory.hxx>
#include    <classmon.hxx>
#include    "resolver.hxx"
#include    "smstg.hxx"
#include    "objact.hxx"
#include    "service.hxx"
#include    <sobjact.hxx>
#include    <comsrgt.hxx>
#include    <security.hxx>

//CObjServer *gpMTAObjServer = NULL;
//static COleStaticMutexSem g_mxsSingleThreadObjReg;

void *GetDestCtxPtr(COMVERSION *pComVersion)
{
    return new CDestObject(*pComVersion, MSHCTX_DIFFERENTMACHINE);
}

extern "C" const GUID GUID_DefaultAppPartition;
const GUID *GetPartitionIDForClassInfo(IComClassInfo *pCI);

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::CObjServer, public
//
//  Synopsis:   construction
//
//  History:    10 Apr 95    AlexMit     Created
//              15 Jun 98    GopalK      Simplified creation
//
//--------------------------------------------------------------------
CObjServer::CObjServer(HRESULT &hr)
{
    OBJREF objref;
    hr = MarshalInternalObjRef(objref, IID_ILocalSystemActivator,
                               (ILocalSystemActivator*) this,
                               MSHLFLAGS_NOPING, (void **) &_pStdID);
    if(SUCCEEDED(hr))
    {
        _ipid = objref.u_objref.u_standard.std.ipid;
        _oxid = objref.u_objref.u_standard.std.oxid;
        SetObjServer(this);
        FreeObjRef(objref);
    }
    else
    {
        _pStdID = NULL;
        _ipid = GUID_NULL;
        _oxid = 0;
    }

    ComDebOut((DEB_ACTIVATE, "CObjServer::CObjServer hr:%x\n", hr));
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::~CObjServer, public
//
//  Synopsis:   dtor for activation object
//
//  History:    19 Jun 95   Rickhi      Created
//              15 Jun 98    GopalK     Simplified destruction
//
//--------------------------------------------------------------------
CObjServer::~CObjServer()
{
    if(_pStdID)
    {
        SetObjServer(NULL);
        ((CStdMarshal *) _pStdID)->Disconnect(DISCTYPE_SYSTEM);
        _pStdID->Release();
    }

    ComDebOut((DEB_ACTIVATE, "CObjServer::~CObjServer\n"));
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::AddRef, public
//
//  Synopsis:   we dont refcnt this object so this is a noop
//
//  History:    10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
ULONG CObjServer::AddRef(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::Release, public
//
//  Synopsis:   we dont refcnt this object so this is a noop
//
//  History:    10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
ULONG CObjServer::Release(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CObjServer::QueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:    10 Apr 95   AlexMit     Created
//
//--------------------------------------------------------------------
STDMETHODIMP CObjServer::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_ILocalSystemActivator) ||  //   more common than IUnknown
        IsEqualIID(riid, IID_ISystemActivator) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (ILocalSystemActivator *) this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjServer::LocalGetClassObject
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjServer::GetClassObject(
    IActivationPropertiesIn *pActIn,
    IActivationPropertiesOut **ppActOut)
{
    HRESULT hr;
    CLSID *pClsid = NULL;

    if (!pActIn)
        return E_INVALIDARG;

    *ppActOut = NULL;
    
    IActivationContextInfo *pCtxInfo=NULL;
    hr = pActIn->QueryInterface(IID_IActivationContextInfo, (void**)&pCtxInfo);

    if (FAILED(hr))
        return hr;
    
    Win4Assert(pCtxInfo);
    
    pCtxInfo->Release(); 

    IComClassInfo *pComClassInfo = NULL;
    hr = pActIn->GetClassInfo(IID_IComClassInfo,(LPVOID*)&pComClassInfo);
    Win4Assert(hr == S_OK);

    hr = pComClassInfo->GetConfiguredClsid(&pClsid);
    Win4Assert(hr == S_OK);
    Win4Assert(pClsid && "Configured class id missing in class info");

    const GUID *pguidPartition = GetPartitionIDForClassInfo(pComClassInfo);

    ComDebOut((DEB_ACTIVATE,
               "CObjServer::LocalGetClassObject clsid:%I\n", pClsid));

    InstantiationInfo *pinst;
    hr = pActIn->QueryInterface(IID_IInstantiationInfo, (LPVOID*)&pinst);
    Win4Assert(hr == S_OK);

    BOOL fSurrogate;
    pinst->GetIsSurrogate(&fSurrogate);
    pinst->Release();

    DWORD dwcount;
    IID *pIID;
    pActIn->GetRequestedIIDs(&dwcount, &pIID);

    if (dwcount != 1)
    {
        pComClassInfo->Release();
        return E_INVALIDARG;
    }

    // Check access.
    if (!CheckObjactAccess())
    {
        pComClassInfo->Release();
        return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }
    
    IUnknown *pcf = NULL;

    // Get the class object
    DWORD actvflags;
    hr = pActIn->GetActivationFlags( &actvflags );
    if (FAILED(hr))
    {
        pComClassInfo->Release();
        return hr;
    }

    ACTIVATION_PROPERTIES ap(*pClsid, 
                             *pguidPartition,
                             (fSurrogate ? IID_IClassFactory : *pIID) ,
                             (ACTIVATION_PROPERTIES::fFOR_SCM |
                              (fSurrogate ? ACTIVATION_PROPERTIES::fSURROGATE : 0) |
                              ACTIVATION_PROPERTIES::fDO_NOT_LOAD),
                             CLSCTX_LOCAL_SERVER,
                             actvflags,
                             0,
                             NULL,
                             &pcf,
                             pComClassInfo);

    hr = CCGetOrLoadClass(ap);

    if (hr == S_OK)
    {
        hr = CCLockServerForActivation();
        if (SUCCEEDED(hr)) 
        {
            IActivationProperties *pActProps;
            hr = pActIn->QueryInterface(IID_IActivationProperties,
                                        (void**) &pActProps);
            
            pActProps->SetMarshalFlags(MSHLFLAGS_NOTIFYACTIVATION|MSHLFLAGS_NORMAL);
            Win4Assert(hr==S_OK);
            pActProps->Release();
            
            hr = pActIn->GetReturnActivationProperties(pcf, ppActOut);
            
            CCUnlockServerForActivation();
            
            // marshal should have bumped up the global count by now.
            // make sure the shutdown bit has not been strobed
            
            //        LOCK(CClassCache::_mxs);
            //  if (CClassCache::_dwFlags & CClassCache::fSHUTTINGDOWN) 
            //  {
            //      hr = CO_E_SERVER_STOPPING;
            //      }
            //      UNLOCK(CClassCache::_mxs);
        }

        // Release our Reference
        pcf->Release();
    }
    else
    {
        //It is possible that the error is on a classfactory
        //where the interface is not supported. In this case
        //the server could linger around because the LockServer
        //API is never toggled. We effect this toggling on an
        //error path.
        IClassFactory *pCF;
        if ((*pIID != IID_IClassFactory) && (!fSurrogate))
        {
            HRESULT hr2;
            ACTIVATION_PROPERTIES ap(*pClsid, 
                                     *pguidPartition,
                                     IID_IClassFactory ,
                                     (ACTIVATION_PROPERTIES::fFOR_SCM |
                                      ACTIVATION_PROPERTIES::fDO_NOT_LOAD),
                                     CLSCTX_LOCAL_SERVER,
                                     actvflags,
                                     0,
                                     NULL,
                                     (IUnknown**)&pCF,
                                     pComClassInfo);

            hr2 = CCGetOrLoadClass(ap);
            
            if (SUCCEEDED(hr2))
            {
                pCF->LockServer(TRUE);
                pCF->LockServer(FALSE);
                pCF->Release();
            }
        }
    }

    pComClassInfo->Release();
    
    ComDebOut((DEB_ACTIVATE,
        "CObjServer::LocalGetClassObject hr:%x\n", hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjServer::CreateInstance
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjServer::CreateInstance(
                   /* [in] */  IUnknown *pUnkOuter,
                   /* [in] */  IActivationPropertiesIn *pActIn,
                   /* [out] */ IActivationPropertiesOut **ppActOut)
{
    HRESULT hr;
    CLSID *pClsid = NULL;
    IID *newIIDs;
    DWORD i;
    IPrivActivationPropertiesIn *privActIn = NULL;
    COMVERSION version;
    CDestObject destObj;

    if (!pActIn)
        return E_INVALIDARG;

   *ppActOut = NULL;

    IActivationContextInfo *pCtxInfo=NULL;
    hr = pActIn->QueryInterface(IID_IActivationContextInfo, (void**)&pCtxInfo);

    if (FAILED(hr))
        return hr;

    Win4Assert(pCtxInfo);

    pCtxInfo->Release();

    IComClassInfo * pComClassInfo = NULL;
    hr = pActIn->GetClassInfo(IID_IComClassInfo,(LPVOID*)&pComClassInfo);
    if (FAILED(hr))
    {
        pComClassInfo = NULL;		// in case GetClassInfo messed with it
        goto exit_CI;
    }

    hr = pComClassInfo->GetConfiguredClsid(&pClsid);
    if (FAILED(hr))
        goto exit_CI;
    Win4Assert(pClsid && "Configured class id missing in class info");
    Win4Assert ((*pClsid) != GUID_NULL);

    const GUID *pguidPartition = GetPartitionIDForClassInfo(pComClassInfo);

    ComDebOut((DEB_ACTIVATE,
       "CObjServer::CreateInstance clsid:%I\n", pClsid));

    // Check access.
    if (!CheckObjactAccess())
    {
        hr = HRESULT_FROM_WIN32 (ERROR_ACCESS_DENIED);
        goto exit_CI;
    }

    hr = pActIn->QueryInterface(IID_IPrivActivationPropertiesIn,
                                (void**) &privActIn);
    if (FAILED(hr))
    {
        privActIn = NULL;		// in case QueryInterface messed with it
        goto exit_CI;
    }

    hr = privActIn->GetCOMVersion(&version);		
    if (FAILED(hr))
        goto exit_CI;

    destObj.SetComVersion(version);
    destObj.SetDestCtx(MSHCTX_DIFFERENTMACHINE);

    Win4Assert(hr==S_OK);

    IUnknown *pcf = NULL;
    DWORD dwInterfaces=0;
    IID *pIIDs=0;
    MInterfacePointer **ppIFDs=0;
    HRESULT *pResults=0;

    // First check if GetInstanceFrom..Storage/File
    IInstanceInfo *pInstanceInfo = NULL;
    if (pActIn->QueryInterface(IID_IInstanceInfo,
                                   (LPVOID*)&pInstanceInfo) == S_OK)
    {
        DWORD mode;
        WCHAR *path;
        MInterfacePointer *pStg;
        MInterfacePointer *pIFDROT;
        pInstanceInfo->GetFile(&path, &mode);
        pInstanceInfo->GetStorageIFD(&pStg);
        pInstanceInfo->GetIfdROT(&pIFDROT);
        pInstanceInfo->Release();
        hr = pActIn->GetRequestedIIDs(&dwInterfaces, &pIIDs);
        if (FAILED(hr))
           goto exit_CI;

        ppIFDs = (MInterfacePointer**)
                    _alloca(sizeof(MInterfacePointer*)*dwInterfaces);
        pResults = (HRESULT*)
                    _alloca(sizeof(HRESULT)*dwInterfaces);
        hr = GetPersistentInstance(pClsid,
                                   mode,
                                   path,
                                   pStg,
                                   dwInterfaces,
                                   pIIDs,
                                   pIFDROT,
                                   ppIFDs,
                                   pResults,
                                   &destObj);
         if (hr != S_OK)
            goto exit_CI;
    }
    else // Normal Create Instance
    {

        // Get the class object
        DWORD actvflags;
        hr = pActIn->GetActivationFlags( &actvflags );
        if (FAILED(hr))
            goto exit_CI;

        ACTIVATION_PROPERTIES ap(*pClsid, 
                                 *pguidPartition,
                                 IID_IClassFactory,
                                 ACTIVATION_PROPERTIES::fFOR_SCM |
                                 ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                                 CLSCTX_LOCAL_SERVER,
                                 actvflags,
                                 0,
                                 NULL,
                                 &pcf,
                                 pComClassInfo);
        hr = CCGetOrLoadClass(ap);

        if (SUCCEEDED(hr))
        {
            hr = pActIn->GetRequestedIIDs(&dwInterfaces, &pIIDs);
            Win4Assert(hr == S_OK);

            ppIFDs = (MInterfacePointer**)
                        _alloca(sizeof(MInterfacePointer*)*dwInterfaces);
            pResults = (HRESULT*)
                        _alloca(sizeof(HRESULT)*dwInterfaces);

            // first, check if the server is willing to accept the incoming call
            // on IClassFactory. The reason we need this is that EXCEL's message
            // filter rejects calls on IID_IClassFactory if it is busy. They dont
            // know about IID_ILocalSystemActivator.
            hr = HandleIncomingCall(IID_IClassFactory, 3,
                                    CALLCAT_SYNCHRONOUS,
                                    (void *)pcf);
            if (SUCCEEDED(hr))
            {
                // Load the object
                DWORD flags;

                InstantiationInfo *pinst;
                hr = pActIn->QueryInterface(IID_IInstantiationInfo, (LPVOID*)&pinst);
                Win4Assert(hr == S_OK);

                pinst->GetInstFlag(&flags);
                pinst->Release();

#ifdef SERVER_HANDLER
                if (flags & CREATE_EMBEDDING_SERVER_HANDLER)
                {
                    hr = GetEmbeddingServerHandlerInterfaces((IClassFactory *)pcf,
                                                        flags,
                                                        dwInterfaces,
                                                        pIIDs,
                                                        ppIFDs,
                                                        pResults,
                                                        NULL,
                                                        &destObj);
                }
                else
#endif // SERVER_HANDLER
                {
                    hr = GetInstanceHelperMulti((IClassFactory *)pcf,
                                                    dwInterfaces,
                                                    pIIDs,
                                                    ppIFDs,
                                                    pResults,
                                                    NULL,
                                                    &destObj);
                }
            }
            pcf->Release();

            if (FAILED(hr))
                goto exit_CI;
        }
        else
            goto exit_CI;
    }

    IPrivActivationPropertiesOut *privActOut = NULL;
    hr = privActIn->PrivGetReturnActivationProperties(&privActOut);
    if (hr != S_OK)
        goto exit_CI;

    hr = privActOut->SetMarshalledResults(dwInterfaces,
                                          pIIDs,
                                          pResults,
                                          ppIFDs);

    // pIIDs belongs to pActIn, so don't free
    for(i=0;i<dwInterfaces;i++)
        MIDL_user_free(ppIFDs[i]);

    *ppActOut = (IActivationPropertiesOut*) privActOut;

    ComDebOut((DEB_ACTIVATE,
       "CObjServer::CreateInstance hr:%x\n", hr));

exit_CI:
    if (pComClassInfo)
        pComClassInfo->Release();
    if (privActIn)
        privActIn->Release();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjServer::GetInstance
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjServer::GetPersistentInstance(
                                                GUID *rclsid,
                                                DWORD grfMode,
                                                WCHAR *pwszPath,
                                                MInterfacePointer *pIFDstg,
                                                DWORD Interfaces,
                                                IID *pIIDs,
                                                MInterfacePointer *pIFDFromROT,
                                                MInterfacePointer **ppIFDs,
                                                HRESULT *pResults,
                                                CDestObject *pDestObj)
{
    ComDebOut((DEB_ACTIVATE, "GetInstance clsid:%I\n", rclsid));
    HRESULT hr = S_OK;

    // Check access.
    if (!CheckObjactAccess())
    {
        return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
    }

    if (pIFDFromROT != NULL)
    {
        // If the SCM has passed us an object from the ROT, we
        // try to use that first by unmarshalling it and then
        // marshaling it normal.
        CXmitRpcStream xrpcForUnmarshal((InterfaceData*)pIFDFromROT);
        IUnknown *punk;

        hr = CoUnmarshalInterface(&xrpcForUnmarshal, IID_IUnknown,
            (void **) &punk);

        if (SUCCEEDED(hr))
        {
            hr = E_NOINTERFACE;

            for ( DWORD i = 0; i < Interfaces; i++ )
            {
                // Stream to put marshaled interface in
                CXmitRpcStream xrpc;
                HRESULT hr2;

                // use DIFFERENTMACHINE so we get the long form OBJREF
                hr2 = CoMarshalInterface(&xrpc, pIIDs[i], punk,
                    SetMarshalContextDifferentMachine(), pDestObj, MSHLFLAGS_NORMAL);

                if (SUCCEEDED(hr2))
                {
                    // Report OK if any interface is found.
                    hr = hr2;
                    xrpc.AssignSerializedInterface((InterfaceData **) &ppIFDs[i]);
                }
                pResults[i] = hr2;
            }
            // Don't need the unknown ptr any more
            punk->Release();

            ComDebOut((DEB_ACTIVATE, "GetInstance hr:%x\n", hr));
            return hr;
        }

        // Assume any errors are the result of a stale entry in the ROT
        // so we just fall into the regular code path from here.
        hr = S_OK;
    }

    // Get the class object
    DWORD actvflags = ACTVFLAGS_NONE;

    if ( gCapabilities & EOAC_DISABLE_AAA )
    {
        actvflags |= ACTVFLAGS_DISABLE_AAA;
    }
    
    // REVIEW: I'm not so sure about this DefaultAppPartition here...
    IUnknown *pcf = NULL;
    ACTIVATION_PROPERTIES ap(*rclsid, 
                             GUID_DefaultAppPartition, 
                             IID_IClassFactory,
                             ACTIVATION_PROPERTIES::fFOR_SCM |
                             ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                             CLSCTX_LOCAL_SERVER,
                             actvflags,
                             0,
                             NULL,
                             &pcf);
    hr = CCGetOrLoadClass(ap);

    if (SUCCEEDED(hr))
    {
      // Unmarshal the storage which we're going to use to initialize the object
      CSafeMarshaledStg smstg( (InterfaceData*) pIFDstg, hr);
      if (SUCCEEDED(hr))
      {
        // first, check if the server is willing to accept the incoming call
        // on IClassFactory. The reason we need this is that EXCEL's message
        // filter rejects calls on IID_IClassFactory if it is busy. They dont
        // know about IID_ILocalSystemActivator.
        hr = HandleIncomingCall(IID_IClassFactory, 3,
          CALLCAT_SYNCHRONOUS,
          (void *)pcf);
        if (SUCCEEDED(hr))
        {
          // Load the object
          hr = GetObjectHelperMulti((IClassFactory *)pcf, grfMode, NULL,
            pwszPath, smstg, Interfaces, pIIDs, ppIFDs, pResults, NULL,
            pDestObj);
        }
      }
      pcf->Release();
    }
    else
    {
      // Need to cleanup the marshaled stg buffer so we don't leak a reference; do 
      // this only if we're not returning CO_E_SERVERSTOPPING, in which case the SCM
      // will be re-trying the activation in a different server and will still want
      // the stg objref to be valid.
      if (hr != CO_E_SERVER_STOPPING)
      {
        // Turn raw marshalled data into a stream
        CXmitRpcStream xrpc((InterfaceData*)pIFDstg);
        
        // Release the data (don't care about the return value here, the original 
        // error code takes precedence)
        CoReleaseMarshalData(&xrpc);
      }
    }

    ComDebOut((DEB_ACTIVATE, "GetInstance hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjServer::ObjectServerLoadDll
//
//  Synopsis:   Loads the requested dll into a surrogate process which
//              implements the ISurrogate interface
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjServer::ObjectServerLoadDll(
            /* [in] */ GUID *rclsid,
            /* [out] */ DWORD* pStatus)
{
    ComDebOut((DEB_ACTIVATE, "ObjectServerLoadDll clsid:%I\n", rclsid));

    if (!rclsid || !pStatus)
        return E_ACCESSDENIED;

    *pStatus = RPC_S_OK;

    HRESULT hr = CCOMSurrogate::LoadDllServer(*rclsid);

    ComDebOut((DEB_ACTIVATE, "ObjectServerLoadDll hr:%x\n", hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\dllcache.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       dllcache.cxx
//
//  Contents:   Implementation of CClassCache as declared in dllcache.hxx
//
//  Functions:
//              CClassCache::CClassEntry::~CClassEntry
//              CClassCache::CClassEntry::CycleToClassEntry
//              CClassCache::CClassEntry::NoLongerNeeded
//              CClassCache::CClassEntry::SearchBaseClassEntry
//              CClassCache::CClassEntry::SearchBaseClassEntryHelp
//              CClassCache::CDllClassEntry::GetClassInterface
//              CClassCache::CLSvrClassEntry::GetClassInterface
//              CClassCache::GetApartmentChain
//              CClassCache::CLSvrClassEntry::AddToApartmentChain
//              CClassCache::CLSvrClassEntry::RemoveFromApartmentChain
//              CClassCache::CLSvrClassEntry::Release
//              CClassCache::CLSvrClassEntry::GetDDEInfo
//              CClassCache::CLSvrClassEntry::CFinishObject::Finish
//              CClassCache::CDllPathEntry::IsValidInApartment
//              CClassCache::CDllPathEntry::Release
//              CClassCache::CDllPathEntry::CanUnload_rl
//              CClassCache::CDllPathEntry::CFinishObject::Finish
//              CClassCache::CDllAptEntry::Release
//              CClassCache::CFinishComposite::~CFinishComposite
//              CClassCache::CFinishComposite::Finish
//              CClassCache::CFinishComposite::Add
//              CClassCache::Init
//              CClassCache::GetOrLoadClass
//              CClassCache::SearchDPEHash
//              CClassCache::Revoke
//              CClassCache::FreeUnused
//              CClassCache::CleanUpDllsForApartment
//              CClassCache::CleanUpLocalServersForApartment
//              CClassCache::CleanUpDllsForProcess
//              CClassCache::AddRefServerProcess
//              CClassCache::ReleaseServerProcess
//              CClassCache::SuspendProcessClassObjects
//              CClassCache::ResumeProcessClassObjects
//              CClassCache::GetClassInformationForDde
//              CClassCache::GetClassInformationFromKey
//              CClassCache::SetDdeServerWindow
//              CClassCache::CDllFnPtrMoniker::CDllFnPtrMoniker
//              CClassCache::CDllFnPtrMoniker::~CDllFnPtrMoniker
//              CClassCache::CDllFnPtrMoniker::BindToObject
//              CClassCache::CpUnkMoniker::CpUnkMoniker
//              CClassCache::CpUnkMoniker::~CpUnkMoniker
//              CClassCache::CpUnkMoniker::BindToObject
//              CCGetOrLoadClass
//              CCGetClass
//              CCIsClsidRegisteredInApartment
//              CCRegisterServer
//              CCRevoke
//              CCAddRefServerProcess
//              CCReleaseServerProcess
//              CCSuspendProcessClassObjects
//              CCResumeProcessClassObjects
//              CCCleanUpDllsForApartment
//              CCCleanUpDllsForProcess
//              CCCleanUpLocalServersForApartment
//              CCFreeUnused
//              CCGetClassInformationForDde
//              CCGetClassInformationFromKey
//              CCSetDdeServerWindow
//              CCGetDummyNodeForApartmentChain
//              CCReleaseDummyNodeForApartmentChain
//              CCInitMTAApartmentChain
//              CCReleaseMTAApartmentChain
//
//  Classes:    CClassCache
//              CClassCache::ClassEntry
//              CClassCache::CBaseClassEntry
//              CClassCache::CDllClassEntry
//              CClassCache::CLSvrClassEntry
//              CClassCache::CDllPathEntry
//              CClassCache::CDllAptEntry
//
//  History:    18-Nov-96   MattSmit    Created
//              26-Feb-98   CBiks       Modified the DLL cache to include
//                                       the context information as part of
//                                       the DLLs identity.
//              23-Jun-98   CBiks       See comments in the code.
//              14-Sep-98   CBiks       Fixed RAID# 214719.
//              09-Oct-98   CBiks       Cleaned up debugging code.
//              20-Oct-98    TarunA     Fixed RAID# 148288
//
//--------------------------------------------------------------------------

#include    <ole2int.h>
#include    <ole2com.h>

#include    "objact.hxx"
#include    <dllhost.hxx>
#include    <sobjact.hxx>
#include    "dllcache.hxx"

HRESULT GetClassInfoFromClsid(REFCLSID rclsid, IComClassInfo **ppClassInfo);
HRESULT HelperGetImplementedClsid(IComClassInfo* pCI, /*[in]*/ CLSID* pConfigCLSID, /*[out]*/ CLSID* pImplCLSID);
void    UnregisterUnusedInterfaces(); // Implemented by the RIF table.

const IID IID_IMiniMoniker =
{0x00000153,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

#ifdef _UNICODE
#define TSZFMT     "%ws"
#else
#define TSZFMT      "%s"
#endif


// Macros to help iterating linked lists
#define FOREACH_SAFE(ptr, lst, nxt, fldnext) \
for ( ptr = (lst), nxt = ptr->fldnext; \
      ptr->fldnext != (lst); \
      ptr = nxt, nxt = ptr->fldnext)

#define FOREACH(ptr, lst, fldnext) \
for ( ptr = (lst); \
      ptr->fldnext != (lst); \
      ptr = ptr->fldnext)

// convert an HRESULT to a string
#define HR2STRING(hr) (SUCCEEDED(hr) ? "SUCCEEDED" : "FAILED")
#define HRDBG(hr) (SUCCEEDED(hr) ? DEB_ACTIVATE : DEB_ERROR)


//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// static data initialization /////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

// collection
DWORD CClassCache::CCollectable::_dwCollectionGracePeriod = 500 ;
DWORD CClassCache::CCollectable::_dwCollectionFrequency = 5;
CClassCache::CCollectable * CClassCache::_ObjectsForCollection = NULL;
CClassCache::CCollectable  *CClassCache::CCollectable::NOT_COLLECTED =
(CClassCache::CCollectable *)LongToPtr(0xffffffff);


// hash tables -- entry points
CClassCache::CCEHashTable   CClassCache::_ClassEntries;
CClassCache::CDPEHashTable  CClassCache::_DllPathEntries;

// mutex
CStaticRWLock   CClassCache::_mxs;

// flags
DWORD                CClassCache::_dwFlags = 0;

// data
ULONG                CClassCache::_cRefsServerProcess = 0;
CClassCache::CLSvrClassEntry *CClassCache::_MTALSvrsFront = 0;
CClassCache::CLSvrClassEntry *CClassCache::_NTALSvrsFront = 0;

//
// NOTE:   These parameters are purposely small in order to
//         ensure that stress and regression tests will attempt
//         to collect objects on a faily regualar basis.  After
//         these changes have had a chance to be well tested,
//         I will change these parameters to more appropriate
//         values.
//
//         (MattSmit)
//

const ULONG          CClassCache::_CollectAtObjectCount = 2;
const ULONG          CClassCache::_CollectAtInterval    = 5000;
ULONG                CClassCache::_LastCollectionTickCount = 0;
ULONG                CClassCache::_LastObjectCount      = 0;

// backing store for hash tables
const ULONG CClassCache::_cCEBuckets = 23;
SHashChain CClassCache::_CEBuckets[CClassCache::_cCEBuckets] =
{
    {&_CEBuckets[0],  &_CEBuckets[0]},
    {&_CEBuckets[1],  &_CEBuckets[1]},
    {&_CEBuckets[2],  &_CEBuckets[2]},
    {&_CEBuckets[3],  &_CEBuckets[3]},
    {&_CEBuckets[4],  &_CEBuckets[4]},
    {&_CEBuckets[5],  &_CEBuckets[5]},
    {&_CEBuckets[6],  &_CEBuckets[6]},
    {&_CEBuckets[7],  &_CEBuckets[7]},
    {&_CEBuckets[8],  &_CEBuckets[8]},
    {&_CEBuckets[9],  &_CEBuckets[9]},
    {&_CEBuckets[10], &_CEBuckets[10]},
    {&_CEBuckets[11], &_CEBuckets[11]},
    {&_CEBuckets[12], &_CEBuckets[12]},
    {&_CEBuckets[13], &_CEBuckets[13]},
    {&_CEBuckets[14], &_CEBuckets[14]},
    {&_CEBuckets[15], &_CEBuckets[15]},
    {&_CEBuckets[16], &_CEBuckets[16]},
    {&_CEBuckets[17], &_CEBuckets[17]},
    {&_CEBuckets[18], &_CEBuckets[18]},
    {&_CEBuckets[19], &_CEBuckets[19]},
    {&_CEBuckets[20], &_CEBuckets[20]},
    {&_CEBuckets[21], &_CEBuckets[21]},
    {&_CEBuckets[22], &_CEBuckets[22]}
};

const ULONG CClassCache::_cDPEBuckets = 23;
SHashChain CClassCache::_DPEBuckets[CClassCache::_cDPEBuckets] =
{
    {&_DPEBuckets[0],  &_DPEBuckets[0]},
    {&_DPEBuckets[1],  &_DPEBuckets[1]},
    {&_DPEBuckets[2],  &_DPEBuckets[2]},
    {&_DPEBuckets[3],  &_DPEBuckets[3]},
    {&_DPEBuckets[4],  &_DPEBuckets[4]},
    {&_DPEBuckets[5],  &_DPEBuckets[5]},
    {&_DPEBuckets[6],  &_DPEBuckets[6]},
    {&_DPEBuckets[7],  &_DPEBuckets[7]},
    {&_DPEBuckets[8],  &_DPEBuckets[8]},
    {&_DPEBuckets[9],  &_DPEBuckets[9]},
    {&_DPEBuckets[10], &_DPEBuckets[10]},
    {&_DPEBuckets[11], &_DPEBuckets[11]},
    {&_DPEBuckets[12], &_DPEBuckets[12]},
    {&_DPEBuckets[13], &_DPEBuckets[13]},
    {&_DPEBuckets[14], &_DPEBuckets[14]},
    {&_DPEBuckets[15], &_DPEBuckets[15]},
    {&_DPEBuckets[16], &_DPEBuckets[16]},
    {&_DPEBuckets[17], &_DPEBuckets[17]},
    {&_DPEBuckets[18], &_DPEBuckets[18]},
    {&_DPEBuckets[19], &_DPEBuckets[19]},
    {&_DPEBuckets[20], &_DPEBuckets[20]},
    {&_DPEBuckets[21], &_DPEBuckets[21]},
    {&_DPEBuckets[22], &_DPEBuckets[22]}
};

// page tables
CPageAllocator      CClassCache::CDllPathEntry::_palloc;
CPageAllocator      CClassCache::CClassEntry::_palloc;
CPageAllocator      CClassCache::CDllClassEntry::_palloc;
CPageAllocator      CClassCache::CLSvrClassEntry::_palloc;
CPageAllocator      CClassCache::CDllAptEntry::_palloc;

const unsigned long CClassCache::CDllPathEntry::_cNumPerPage = 15;
const unsigned long CClassCache::CClassEntry::_cNumPerPage = 50;
const unsigned long CClassCache::CDllClassEntry::_cNumPerPage = 50;
// Do not grow this number past 16 w/o changing cookie code


const unsigned long CClassCache::CLSvrClassEntry::_cNumPerPage = 16 ;
const unsigned long CClassCache::CDllAptEntry::_cNumPerPage = 50;

// signatures
const DWORD CClassCache::CClassEntry::TREAT_AS_SIG = *((DWORD *)"TA ");
const DWORD CClassCache::CClassEntry::INCOMPLETE_ENTRY_SIG = *((DWORD *)"INC");
const DWORD CClassCache::CClassEntry::CLASS_ENTRY_SIG = *((DWORD *)"CE ");
const DWORD CClassCache::CDllClassEntry::SIG =  *((DWORD *) "DLL");
const DWORD CClassCache::CLSvrClassEntry::SIG = *((DWORD *) "LSV");
const DWORD CClassCache::CLSvrClassEntry::DUMMY_SIG = *((DWORD *) "DUM");
const DWORD CClassCache::CDllPathEntry::SIG =  *((DWORD *) "DPE");
const DWORD CClassCache::CDllAptEntry::SIG =  *((DWORD *) "APT");

//other
const ULONG CClassCache::CDllPathEntry::DLL_DELAY_UNLOAD_TIME = 600000; // 600,000 ticks == 10 minutes
const char CClassCache::CDllPathEntry::DLL_GET_CLASS_OBJECT_EP[] = "DllGetClassObject";
const char CClassCache::CDllPathEntry::DLL_CAN_UNLOAD_EP[] =       "DllCanUnloadNow";

const DWORD CClassCache::CLSvrClassEntry::NO_SCM_REG = 0xffffffff;
DWORD CClassCache::CLSvrClassEntry::_dwNextCookieCount = 0;
DWORD CClassCache::CLSvrClassEntry::_cOutstandingObjects = 0;


//+-------------------------------------------------------------------------
//
//  Function:   GetPartitionIDForClassInfo
//
//  Synopsis:   Figure out what partition this classinfo lives in.
//
//  Arguments:  pCI      - [in] The classinfo in question
//
//  Algorithm:  QI the classinfo for IComClasSInfo2, and use that interface
//              to get back the partition ID.  If anything fails, return
//              GUID_DefaultAppPartition.
//
//  History:    12-Mar-01 JohnDoty Created
//
//+-------------------------------------------------------------------------
const GUID *GetPartitionIDForClassInfo(
    IN IComClassInfo *pCI
)
{
    IComClassInfo2 *pCI2;
    const GUID *pguidPartition = &GUID_DefaultAppPartition;

    HRESULT hr = pCI->QueryInterface(IID_IComClassInfo2, (void **)&pCI2);
    if (SUCCEEDED(hr))
    {
        hr = pCI2->GetApplicationPartitionId((GUID**)&pguidPartition);
        Win4Assert(SUCCEEDED(hr));
        
        pCI2->Release();
    }
    
    return pguidPartition;
}



//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////// Method Implementation /////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////
// ClassCache::CClassEntry ///////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::~CClassEntry()
//
//  Synopsis:   Destructor
//
//  Arguments:  none
//
//  Returns:    n/a
//
//  Algorithm:  Assert that this object is ok to delete, flag it deleted by
//              zeroing the sig and flags, delete the treat as objects in
//              chain, and remove this object from the hash
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
CClassCache::CClassEntry::~CClassEntry()
{
    ClsCacheDebugOut((DEB_ACTIVATE,"Destroying CClassEntry: 0x%x\n", this));

    Win4Assert(NoLongerNeeded());

    // NOTE:: before adding logic to this destructor,
    // please examine the code and accompanying note in
    // CClassCache::CleanupDllsForProcess, in which some CClassEntry
    // objects are freed w/o the destructor running.


    ASSERT_LOCK_HELD(_mxs);

    // Zap the sig
    _dwSig = 0;

    // Zap the flags
    _dwFlags = 0;

    // remove treat as entries

    if (_pTreatAsList && _pTreatAsList->_dwSig != 0)
    {
        delete _pTreatAsList;
    }

    // remove from hash
    _hashNode.chain.pPrev->pNext = (SHashChain *) _hashNode.chain.pNext;
    _hashNode.chain.pNext->pPrev = (SHashChain *) _hashNode.chain.pPrev;

    // release class info if there
    if (_pCI)
    {
        _pCI->Release();
    }

    AssertNoRefsToThisObject();
}

#if DBG == 1
void CClassCache::CClassEntry::AssertNoRefsToThisObject()
{
    ASSERT_LOCK_HELD(_mxs);

    for (int k = 0; k < _cCEBuckets; k++)
    {
        SHashChain *pHN;
        FOREACH(pHN, _CEBuckets[k].pNext, pNext)
        {
            CClassEntry *pCE = CClassEntry::SafeCastFromHashNode((SMultiGUIDHashNode *) pHN);
            Win4Assert(pCE != this && "AssertNoRefsToThisObject");
        }
    }
}

#endif
//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::CreateIncomplete()
//
//  Synopsis:   Creates an CClassEntry object w/o consulting the registry
//
//  Arguments:  rclsid         - CLSID of the object to create
//              dwClsHash      - computed 32-bit hash code
//              pCE            - out parameter
//              dwFlags        - fDO_NOT_HASH - don't put in hash table
//
//  Returns:    S_OK/error code
//
//  Algorithm:  Create a class entry. No need to check the registry for
//              TreatAs types
//
//  History:    11-Mar-97 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::CreateIncomplete(REFCLSID rclsid,
                                                   DWORD dwClsHash,
                                                   IComClassInfo *pCI,
                                                   CClassEntry *&pCE,
                                                   DWORD dwFlags)
{
    ASSERT_LOCK_HELD(_mxs);
    ClsCacheDebugOut((DEB_ACTIVATE, "Creating incomplete CClassEntry: clsid: %I\n", &rclsid));

    //
    // We no longer call GetClassInfoFromClsid because it can lead to 
    // deadlocks with MSI because they switch threads when servicing calls.
    // Consequently, all callers to this function must provide their own pCI,
    // obtained outside the class cache lock
    //
    if (!pCI)
    {
        Win4Assert (!"pCI should never be NULL - see Windows Bug #108538");
        return E_POINTER;
    }

    CStdMarshal *psm;

    // Call garbage collection algorithm before allocating
    // memory.
    Collect(1);
    
    HRESULT hr = E_OUTOFMEMORY;
    pCE = new CClassEntry();
    if (pCE)
    {
        
        pCE->_dwSig = CClassEntry::INCOMPLETE_ENTRY_SIG;
        pCE->_dwFlags = fINCOMPLETE;
        
        // fill out catalog & complus info
        
        DWORD cCustomActivatorCount = 0;
        DWORD stage;
        
        for (stage = CLIENT_CONTEXT_STAGE; stage <= SERVER_CONTEXT_STAGE; stage++)
        {
            DWORD cCustomActForStage = 0;
            hr = pCI->GetCustomActivatorCount((ACTIVATION_STAGE)stage,&cCustomActForStage);
            if (SUCCEEDED(hr))
            {
                cCustomActivatorCount += cCustomActForStage;
            }
        }
        
        if (cCustomActivatorCount > 0)
        {
            pCE->_dwFlags |= fCOMPLUS;
        }
        else
        {
            pCE->_pCI = pCI;
            pCE->_pCI->AddRef();
        }
        
        // fill out the CClassEntry
        pCE->_guids[iCLSID]     = rclsid;

        const GUID *pguidPartition = GetPartitionIDForClassInfo(pCI);
        pCE->_guids[iPartition] = *pguidPartition;

        // put in the hash
        if (!(dwFlags & fDO_NOT_HASH))
        {
            SMultiGUIDKey key;
            
            key.cGUID = iTotal;
            key.aGUID = pCE->_guids;
            
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassEntry: Adding clsid: %I to the hash, pCE = 0x%x\n", &rclsid, pCE));
            _ClassEntries.AddCE(dwClsHash, key, pCE);
        }
        hr = S_OK;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::Complete
//
//  Synopsis:   Check's the registry for TreatAs entries for this object.
//
//  Arguments:  none
//
//  Returns:    S_OK/error code
//
//  Algorithm:  if this entry is already complete, do nothing.  Otherwise,
//              check the registry.  If there is a TreatAs element for this
//              CLSID, create that and hook it up.  Repeat recursively.
//
//              NOTE: Only Create and SearchBaseClassEntry should
//                    call this function!!
//
//  History:    11-Mar-97 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::Complete(BOOL *pfLockReleased)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "Completing CClassEntry object: this = 0x%x, clsid: %I\n", this, &(_guids[iCLSID])));
    ASSERT_WRITE_LOCK_HELD(_mxs);

    *pfLockReleased = FALSE;

    if (IsComplete())
    {
        return S_OK;
    }

    HRESULT hr;

    CLSID TreatAs_clsid;
    IComClassInfo* pCI = NULL;

    hr = CoGetTreatAsClass(_guids[iCLSID], &TreatAs_clsid);

    if ((hr == S_OK) && (_guids[iCLSID] != TreatAs_clsid))
    {
        // TreatAs class listed in the registry
        // check the hash

        ClsCacheDebugOut((DEB_ACTIVATE, "Treating CLSID %I as %I\n", &_guids[iCLSID], &TreatAs_clsid));

        // TreatAs stuff is only in the base partition...
        DWORD dwTAHash = _ClassEntries.Hash(TreatAs_clsid, GUID_DefaultAppPartition);
        CClassEntry *pTACE = _ClassEntries.LookupCE(dwTAHash, TreatAs_clsid, GUID_DefaultAppPartition);

        if (!pTACE)
        {            
            // Windows Bug #107960
            // Look up class info without write lock
            // before call to CClassEntry::Create

            UNLOCK_WRITE(_mxs);

            *pfLockReleased = TRUE;

            hr = GetClassInfoFromClsid(TreatAs_clsid, &pCI);

            // Restore the read lock for the caller
            LOCK_WRITE(_mxs);

            if (FAILED (hr))
            {
                goto epilog;
            }

            pTACE = _ClassEntries.LookupCE(dwTAHash, TreatAs_clsid, GUID_DefaultAppPartition);
        }

        if (!pTACE)
        {
            hr = CClassEntry::Create(TreatAs_clsid, dwTAHash, pCI, pTACE);

            if (FAILED(hr))
            {
                goto epilog;
            }
            // check to see if this object was completed while
            // the lock was released
            if (IsComplete())
            {
                hr = S_OK;
                goto epilog;
            }

        }
        else if (!pTACE->IsComplete())
        {
            hr = pTACE->Complete(pfLockReleased);
            Win4Assert(!*pfLockReleased);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        CompleteTreatAs(pTACE);
    }
    else
    {
        CompleteNoTreatAs();
    }


    MarkCompleted();
    Win4Assert(IsComplete());
    epilog:

    if (pCI)
    {
        pCI->Release();
    }
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::Create()
//
//  Synopsis:   Creates a CClassCache::CClassEntry object
//
//  Arguments:  rclsid      - [in] The class id of the new CClassEntry
//              dwClsHash   - [in] The hash value for the clsid
//              fGetTreatAs - [in] TRUE - then lookup the treatas, else dont
//              pCE         - [out] The new CClassEntry.
//
//  Returns:    S_OK    - operation succeeded
//              E_OUTOFMEMORY - operation failed due to lack of memory
//
//  Algorithm:  if there is a treat as class
//                 create it recursively and link the new
//                 CClassEntry to it
//              else
//                 create a new CClassEntry
//              add the new CClassEntry to the hash table.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::Create(REFCLSID rclsid,
                                         DWORD dwClsHash,
                                         IComClassInfo *pCI,
                                         CClassEntry *&pCE)
{
    ASSERT_WRITE_LOCK_HELD(_mxs);
    ClsCacheDebugOut((DEB_ACTIVATE, "Creating CClassEntry: clsid: %I\n", &rclsid));

    if (!pCI)
    {
        Win4Assert (!"pCI should never be NULL - see Windows Bug #108538");
        return E_POINTER;
    }

    HRESULT hr = CreateIncomplete(rclsid, dwClsHash, pCI, pCE, fDO_NOT_HASH);
    if (SUCCEEDED(hr))
    {
        BOOL fLockReleased = FALSE;
        hr = pCE->Complete(&fLockReleased);

        ASSERT_WRITE_LOCK_HELD(_mxs);
        
        if (SUCCEEDED(hr))
        {
            // If we released the lock, make sure we still need to add
            // the class entry to the table
            CClassEntry* pNewCE = NULL;

            if (fLockReleased)
            {
                const GUID *pguidPartition = GetPartitionIDForClassInfo(pCI);

                pNewCE = _ClassEntries.LookupCE (dwClsHash, rclsid, *pguidPartition);
            }
        
            if (pNewCE)
            {
                // Discard the current class entry
                delete pCE;
            }
            else
            {
                // put in the hash
                SMultiGUIDKey key;

                key.cGUID = iTotal;
                key.aGUID = pCE->_guids;

                ClsCacheDebugOut((DEB_ACTIVATE, "CClassEntry: Adding clsid: %I to the hash, pCE = 0x%x\n", &rclsid, pCE));
                _ClassEntries.AddCE(dwClsHash, key, pCE);
            }
        }
        else
        {
            delete pCE;
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::CycleToClassEntry()
//
//  Synopsis:   Return a pointer to the ClassEntry for this TreatAs chain
//
//  Arguments:  none
//
//  Returns:    The ClassEntry for this TreatAs chain
//
//  Algorithm:  loop through the _pTreatAsList pointers until the signature
//              is not a TreaAs signature.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
CClassCache::CClassEntry * CClassCache::CClassEntry::CycleToClassEntry()
{
    ASSERT_RORW_LOCK_HELD(_mxs);

    ClsCacheDebugOut((DEB_ACTIVATE, "CycleToClassEntry: this = 0x%x\n", this));
    Win4Assert(IsComplete()  && "Entry must be complete to call CycleToClassEntry");
    Win4Assert(_pTreatAsList);

    CClassEntry *ret = this;

    while (ret->_dwFlags &  fTREAT_AS)
    {
        ret = ret->_pTreatAsList;
        // check for infinite cycles
        Win4Assert(ret != this && "No Class Entry in this chain!");
    }

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::CreateDllClassEntry_rl()
//
//  Synopsis:   Creates a new CDllClassEntry - releases the lock
//
//  Arguments:  dwContext    - [in]  Context of the CDllClassEntry
//              ap           - [in]  Activation properties passed in from
//                                   caller
//              pDCE         - [out] Pointer to the new CDllClassEntry
//
//  Returns:    S_OK    -  operation succeeded
//              PROPOGATE:NegotiateDllInstantiationProperties
//              PROPOGATE:CDllPathEntry::Create
//
//  Algorithm:  Get the dll instantiation properties.
//              if CDllPathEntry is not in the hash
//                   create one
//                   if another thread created the CDllClassEntry return it
//              Create a new CDllClassEntry
//              Initilize it
//              Link it to the CDllPathEntry, and this CClassEntry
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::CreateDllClassEntry_rl(
                                                        DWORD                        dwContext,
                                                        ACTIVATION_PROPERTIES_PARAM  ap,
                                                        CDllClassEntry*&             pDCE)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CreateDllClassEntry: dwContext = 0x%x\n", dwContext));
    Win4Assert(!(_dwFlags & fTREAT_AS) && "Can only create DllClassEntry's on non-TreatAs ClassEntries");
    Win4Assert((_dwSig == CLASS_ENTRY_SIG) && "Must be a full CClassEntry");
    Win4Assert(!(dwContext & CLSCTX_LOCAL_SERVER));
    Win4Assert(!((dwContext & CLSCTX_INPROC_SERVERS) && (dwContext & CLSCTX_INPROC_HANDLERS)));
    Win4Assert(((dwContext & CLSCTX_INPROC_SERVERS) || (dwContext & CLSCTX_INPROC_HANDLERS)));

    HRESULT hr;
    CDllPathEntry *pDPE;
    DLL_INSTANTIATION_PROPERTIES dip;

    ASSERT_LOCK_NOT_HELD(_mxs);

    //
    // I don't know what the fRELOAD_DARWIN flag means, but if it is not set,
    // we negotiate dll information using registry information.
    //
    if (ap._dwFlags & ACTIVATION_PROPERTIES::fRELOAD_DARWIN)
    {

        if (wCompareDllName(ap._pwszDllServer, OLE32_DLL, OLE32_CHAR_LEN))
        {
            hr = dip.Init( OLE32_DLL, ap._dwDllServerType, 0, ap._rclsid);
        }
        else
        {
            hr = dip.Init( ap._pwszDllServer, ap._dwDllServerType, 0, ap._rclsid );
        }

    }
    else
    {
        hr = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties(
                                                                            dwContext,
                                                                            ap._dwActvFlags,
                                                                            _guids[iCLSID],
                                                                            dip,
                                                                            ap._pCI);
    }


    if (FAILED(hr))
        return hr;

    LOCK(_mxs);

    //
    // Make sure no one else came and added a similar class entry
    // while the lock was released.
    //
    if (pDCE = SearchForDCE(dip._pzDllPath , dip._dwFlags)) 
    {                                                       
        hr = S_OK;                                          
        goto epilog;                                        
    }


    //
    // Look up the dll path in the registry.
    //
    hr = SearchDPEHash(dip._pzDllPath, pDPE, dip._dwHash, dip._dwFlags);
    if (FAILED(hr))
    {
        //
        // No entry for this DLL.  Make one...
        //
        ClsCacheDebugOut((DEB_ACTIVATE, "No Dll found in cache, loading one\n"));
        if (FAILED(hr = CClassCache::CDllPathEntry::Create_rl(dip, ap, pDPE)))
        {
            ClsCacheDebugOut((DEB_ERROR, "CClassEntry::CreateDllClassEntry: CDllPathEntry::Create_rl FAILED! hr = 0x%x\n", hr));
            goto epilog;
        }

        //
        // Make sure no one else came and added a similar class entry
        // while the lock was released.
        //
        if (pDCE = SearchForDCE(dip._pzDllPath, dip._dwFlags))
        {
            hr = S_OK;
            goto epilog;
        }
    }


    //
    // Create a new DLL class entry.
    //

    pDCE = new CClassCache::CDllClassEntry();
    if (!pDCE)
    {
        hr = E_OUTOFMEMORY;
        goto epilog;
    }

    //
    // Fill in Dll Class Entry and add it to the cache.
    //
    pDCE->_dwContext = dwContext & (CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER);
    pDCE->_dwContext = dwContext & CLSCTX_INPROC_MASK1632;

    pDCE->_dwSig = CDllClassEntry::SIG;
    pDCE->_dwDllThreadModel = dip._dwThreadingModel;
    hr = HelperGetImplementedClsid(_pCI ? _pCI : ap._pCI, &_guids[iCLSID], &pDCE->_impclsid);
    Win4Assert(SUCCEEDED(hr) && "HelperGetImplementedClsid failed in CClassCache::CClassCache::CreateDllClassEntry_rl");

    pDPE->AddDllClassEntry(pDCE);
    AddBaseClassEntry(pDCE);

    epilog:

    Win4Assert(!!SUCCEEDED(hr) == !!pDCE);

    if (pDCE)
    {
        pDCE->Lock();
    }

    UNLOCK(_mxs);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::SearchForDCE()
//
//  Synopsis:   Scans the CBaseClassEntry list for a DCE with this path
//
//  Arguments:  pzDllPath   - path to look for
//
//  Returns:    pointer to object if found, NULL otherwise
//
//  Algorithm:  linear search of _pBCEList*
//
//  History:    21-Feb-97    MattSmit    Created
//
//+-------------------------------------------------------------------------
CClassCache::CDllClassEntry * CClassCache::CClassEntry::SearchForDCE(WCHAR *pzDllPath, DWORD dwDIPFlags)
{
    CDllClassEntry *pOtherDCE = (CDllClassEntry *) _pBCEListFront->_pPrev;

    while (pOtherDCE != _pBCEListBack)
    {
        pOtherDCE = (CDllClassEntry *) pOtherDCE->_pNext;

        if ((pOtherDCE->_dwSig == CDllClassEntry::SIG) &&
            (lstrcmpW(pOtherDCE->_pDllPathEntry->_psPath, pzDllPath) == 0) &&
            pOtherDCE->_pDllPathEntry->Matches(dwDIPFlags))
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "DllClassEntry created by another thread, leaving\n"));
            return pOtherDCE;
        }
    }

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::CreateLSvrClassEntry_rl()
//
//  Synopsis:   Creates a new CLSvrClassEntry - releases the lock
//
//  Arguments:  punk           - [in] New server's IUnknown Interface
//              dwContext      - [in] Context to register the server as
//              dwRegFlags     - [in] Registration flags
//              lpdwRegister   - [out] Cookie so calling program can
//                               revoke the server
//
//  Returns:    S_OK    -  operation succeeded
//              PROPOGATE:gResolver.NotifyStarted()
//
//  Algorithm:  Create a new CLSverClassEntry
//              Fill out members
//              If local server, notify SCM class is started
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::CreateLSvrClassEntry_rl(IUnknown *punk, DWORD dwContext, DWORD dwRegFlags,
                                                          LPDWORD lpdwRegister)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CreateLSvrClassEntry_rl: punk = 0x%x, dwContext = 0x%x, dwRegFlags = 0x%x\n",
                      punk, dwContext, dwRegFlags));

    ASSERT_LOCK_HELD(_mxs);
    HRESULT hr = S_OK;

    CObjServer *pObjServer = NULL;
    if (dwContext & CLSCTX_LOCAL_SERVER)
    {
        pObjServer = GetObjServer();
        if (!pObjServer)
        {
            ClsCacheDebugOut((DEB_ERROR, "CreateLSvrClassEntry_rl: error creating the object server\n"));
            return E_FAIL;
        }
    }

    if (IsWOWThread())
    {
        if (dwContext & CLSCTX_INPROC_SERVER)
        {
            dwContext |= CLSCTX_INPROC_SERVER16;
        }
        if (dwContext & CLSCTX_INPROC_HANDLER)
        {
            dwContext |= CLSCTX_INPROC_HANDLER16;
        }
    }


    CLSvrClassEntry *pLSCE = new CLSvrClassEntry(CLSvrClassEntry::SIG,
                                                 punk,
                                                 dwContext,
                                                 dwRegFlags,
                                                 GetCurrentApartmentId());
    if (!pLSCE)
    {
        return E_OUTOFMEMORY;
    }


    if (FAILED(hr = pLSCE->AddToApartmentChain()))
    {
        return hr;
    }

    AddBaseClassEntry(pLSCE);



    if (dwContext & CLSCTX_LOCAL_SERVER)
    {
        // Win95 does lazy create of ObjServer for STA...OleNotificationProc() in com\dcomrem\notify.cxx
        // but only if the clsid is not being registered suspended.  This is coz the bulk update can
        // happen on any thread and therefore the hwnd of the thread corresponding to the clsid will not be
        // known for notification.

        // store off a pointer to the activation server object.
        // Note that on Win95 GetObjServer() will return NULL as the IObjServer will be created lazily.
        pLSCE->_pObjServer = pObjServer;
        if (!(dwRegFlags & REGCLS_SUSPENDED))
        {
            ClsCacheDebugOut((DEB_ACTIVATE,"Notifying SCM that class is started\n"));


            // Notify SCM that the class is started.
            RegOutput     *pRegOut = NULL;

            RegInput RegIn;
            RegIn.dwSize = 1;
            RegIn.rginent[0].clsid = _guids[iCLSID];
            RegIn.rginent[0].dwFlags = dwRegFlags;

            // Win95 does lazy create of ObjServer for STA...OleNotificationProc() in com\dcomrem\notify.cxx
            if (pLSCE->_pObjServer)
            {
                RegIn.rginent[0].ipid = pLSCE->_pObjServer->GetIPID();
                RegIn.rginent[0].oxid = pLSCE->_pObjServer->GetOXID();
            }
            else
            {
                RegIn.rginent[0].ipid = GUID_NULL;
                RegIn.rginent[0].oxid = NULL;
            }

            // Release the lock across outgoing calls to the SCM.
            UNLOCK(_mxs);
            hr = gResolver.NotifyStarted(&RegIn, &pRegOut);
            LOCK(_mxs);


            if (SUCCEEDED(hr))
            {
                pLSCE->_dwScmReg   = pRegOut->RegKeys[0];
                MIDL_user_free(pRegOut);
            }
            else
            {
                ClsCacheDebugOut((DEB_ERROR,"gResolver.NotifyStarted FAILED!!\n"));
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *lpdwRegister = (DWORD) CLSvrClassEntry::_palloc.GetEntryIndex((PageEntry *)pLSCE);

        Win4Assert(*lpdwRegister != -1);

        CLSvrClassEntry::_dwNextCookieCount++;
        *lpdwRegister |= (CLSvrClassEntry::_dwNextCookieCount << COOKIE_COUNT_SHIFT) & COOKIE_COUNT_MASK ;

        pLSCE->_dwCookie = *lpdwRegister;
    }
    else
    {
        *lpdwRegister = 0;
        pLSCE->RemoveFromApartmentChain();
        RemoveBaseClassEntry(pLSCE);
        delete pLSCE;
        pLSCE = 0;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::NoLongerNeeded()
//
//  Synopsis:   Return whether this object can be deleted
//
//  Arguments:  none
//
//  Returns:    TRUE  - Object can be deleted
//              FALSE - Do not delete object
//
//  Algorithm:  Object can be deleted iff for all object in the treat as chain,
//              the lock count is zero and ther are no attached CBaseClassEntry
//              objects.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
BOOL CClassCache::CClassEntry::NoLongerNeeded()
{
    ClsCacheDebugOut((DEB_ACTIVATE,"NoLongerNeeded: this = 0x%x\n", this));
    ASSERT_WRITE_LOCK_HELD(_mxs);

    if (_cLocks)
    {
        return FALSE;
    }

    return HasBCEs();
}

BOOL CClassCache::CClassEntry::HasBCEs()
{
    ClsCacheDebugOut((DEB_ACTIVATE,"Has BCEs: this = 0x%x\n", this));
    ASSERT_RORW_LOCK_HELD(_mxs);

    if (!IsComplete())
    {
        return((_pBCEListFront  ==
                ((CBaseClassEntry *) (((DWORD_PTR *)&_pBCEListFront) - 1)))  &&
               (_cLocks == 0));
    }

    CClassEntry *p = this;
    do
    {
        if ((p->_pBCEListFront  !=
             ((CBaseClassEntry *) (((DWORD_PTR *)&p->_pBCEListFront) - 1)))
            || (p->_cLocks != 0))
        {
            return FALSE;
        }
        p = p->_pTreatAsList;

    }
    while (p != this);

    ClsCacheDebugOut((DEB_ACTIVATE,"CClassEntry object 0x%x no longer needed\n", this));

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::SearchBaseClassEntry()
//
//  Synopsis:   Search for a CBaseClassEntry object with give criteria
//
//  Arguments:  dwContext         - [in]  mask of acceptable contexts
//              pBCE              - [out] pointer to found object
//              fForSCM           - [in]  operation originated from the SCM
//
//  Returns:    S_OK   - an object was found
//              E_FAIL - no object was found
//
//  Algorithm:  Search this object first
//              If the search failed && this object is a TreatAs
//                  cycle to the class entry and search it
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::SearchBaseClassEntry(DWORD dwContext,
                                                       CBaseClassEntry *&pBCE,
                                                       DWORD dwActFlags,
                                                       BOOL *pfLockReleased)
{
    ClsCacheDebugOut((DEB_ACTIVATE,"SearchBaseClassEntry: this = 0x%x,"
                      " dwContext = 0x%x, dwActFlags = 0x%x\n",
                      this, dwContext, dwActFlags));
    ASSERT_RORW_LOCK_HELD(_mxs);

    HRESULT hr, tmphr;
    *pfLockReleased = FALSE;

    if (FAILED(hr = SearchBaseClassEntryHelp(dwContext, pBCE, dwActFlags)) &&
        (dwContext & (CLSCTX_INPROC_SERVERS | CLSCTX_INPROC_HANDLERS)))
    {
        // If we're only holding a read lock, upgrade to a write lock
        LockCookie cookie;
        BOOL bExclusive = _mxs.HeldExclusive();

        if (!bExclusive)
        {
            LOCK_UPGRADE(_mxs, &cookie, pfLockReleased);
        }
        
        if (SUCCEEDED(tmphr = Complete(pfLockReleased)))
        {

            if ((_dwFlags & fTREAT_AS) &&
                // if the lock was released we search again.
                (!*pfLockReleased || FAILED(hr = SearchBaseClassEntryHelp(dwContext, pBCE, dwActFlags))))
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "Search Failed, trying TreatAs\n"));
                CClassEntry *pCE = CycleToClassEntry();
                hr = pCE->SearchBaseClassEntryHelp(dwContext, pBCE, dwActFlags);
            }
        }
        else
        {
            hr = tmphr;
        }

        if (!bExclusive)
        {
            LOCK_DOWNGRADE(_mxs, &cookie);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CClassEntry::SearchBaseClassEntryHelp()
//
//  Synopsis:   Helper function for SearchBaseClassEntry, does the actual
//              searching.
//
//  Arguments:  dwContext         - [in]  mask of acceptable contexts
//              pBCE              - [out] pointer to found object
//              fForSCM           - [in]  operation originated from the SCM
//
//  Returns:    S_OK   - an object was found
//              E_FAIL - no object was found
//
//  Algorithm:  For each object in the list
//              if its context matches the context specified
//                  and if it is a local server check apartment and MULTI_SEPARATE semantics
//                  return the object.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CClassEntry::SearchBaseClassEntryHelp(DWORD dwContext,
                                                           CBaseClassEntry *&pBCE,
                                                           DWORD dwActFlags)
{
    ClsCacheDebugOut((DEB_ACTIVATE,"SearchBaseClassEntryHelp: this = 0x%x,"
                      " dwContext = 0x%x, dwActFlags= 0x%x\n",
                      this, dwContext, dwActFlags));
    ASSERT_RORW_LOCK_HELD(_mxs);


    pBCE = _pBCEListFront->_pPrev;

    while (pBCE != _pBCEListBack)
    {
        pBCE = pBCE->_pNext;

        ClsCacheDebugOut((DEB_ACTIVATE,"SearchBaseClassEntryHelp: this = 0x%x, pBCE->_dwContext = 0x%x\n",
                          pBCE, pBCE->_dwContext));
        if ((pBCE->_dwContext & dwContext))
        {


            if (pBCE->_dwSig == CLSvrClassEntry::SIG)
            {
                // if this is a CLsvrclassEntry object, check that
                // the apartment matches and we are not grabbing
                // a MULTI_SEPARTE w/o being the SCM
                if ((((CLSvrClassEntry *) pBCE)->_hApt != GetCurrentApartmentId()) ||
                    (!(pBCE->_dwContext & CLSCTX_INPROC_SERVERS) &&
                     !(dwActFlags & ACTIVATION_PROPERTIES::fFOR_SCM) &&
                     (((CLSvrClassEntry *) pBCE)->_dwRegFlags & REGCLS_MULTI_SEPARATE)))
                {
                    continue;
                }
            }
            else if (dwActFlags & ACTIVATION_PROPERTIES::fLSVR_ONLY)
            {
                //
                // we only want registered servers, so skip this one
                //

                continue;
            }

            ClsCacheDebugOut((DEB_ACTIVATE,"SearchBaseClassEntryHelp - object found - 0x%x\n", pBCE));

            return S_OK;
        }
    }

    pBCE = 0;
    return E_FAIL;
}




//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDllClassEntry ///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllClassEntry::GetClassInterface
//
//  Synopsis:   Gives out moniker to create the factory from the dll
//
//  Arguments:  ppIM            - [out] pointer to the moniker
//
//  Returns:    S_OK      - operation succeeded
//              PROPOGATE:  CDllPathEntry::MakeVal  idInPartment_rl16
//              PROPOGATE:  CDllFnPtrMoniker::CDllFnPtrMoniker
//
//  Algorithm:  Make the dll valid in this apartment
//              reset the expire time and flag we were here for unload
//                 algorithms
//              create new CDllFnPtrMoniker
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllClassEntry::GetClassInterface(IMiniMoniker ** ppIM)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllClassEntry::GetClassInterface\n"));
    ASSERT_RORW_LOCK_HELD(_mxs);

    // this resets the delay time for delayed unload DLLs
    _pDllPathEntry->_dwExpireTime = 0;
    _pDllPathEntry->_fGCO_WAS_HERE = TRUE;

    HRESULT hr = E_OUTOFMEMORY;
    IUnknown *pUnk = new ((PBYTE) *ppIM) CDllFnPtrMoniker(this, hr);

    if (SUCCEEDED(hr))
    {
        hr = pUnk->QueryInterface(IID_IMiniMoniker, (void **) ppIM);
        if (SUCCEEDED((*ppIM)->CheckApt()) &&
            SUCCEEDED((*ppIM)->CheckNotComPlus()))
        {
            // make valid now so we don't have to take the lock later

            hr = _pDllPathEntry->MakeValidInApartment_rl16 (_impclsid);
        }
    }

    if (pUnk)
    {
        pUnk->Release();
    }

    ClsCacheDebugOut((DEB_ACTIVATE, "CDllClassEntry::GetClassInterface new CDllFnPtrMoniker hr = 0x%x\n", hr));

    return hr;

}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::GetClassInterface
//
//  Synopsis:   Gives out moniker to hand out the factory.
//
//  Arguments:  ppIM            - [out] pointer to the moniker
//
//  Returns:    S_OK                 - operation succeeded
//              CO_E_SERVER_STOPPING - server is suspended
//              PROPOGATE:  CpUnkMoniker::CpUnkMoniker
//
//  Algorithm:  if class is not suspended
//                 if REGCLS_SINGLEUSE remove from the list, so it won't get
//                  found again.
//                 create the moniker
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CLSvrClassEntry::GetClassInterface(IMiniMoniker **ppIM)
{

    ClsCacheDebugOut((DEB_ACTIVATE, "CLSvrClassEntry::GetClassInterface: this = 0x%x\n", this));
    ASSERT_RORW_LOCK_HELD(_mxs);


    if (!(_dwRegFlags & REGCLS_SUSPENDED))
    {
        HRESULT hr = S_OK;

        if (_dwRegFlags == REGCLS_SINGLEUSE)
        {
            LockCookie cookie;
            BOOL       fLockReleased;
            BOOL       fExclusive = _mxs.HeldExclusive();

            if (!fExclusive)
            {
                LOCK_UPGRADE(_mxs, &cookie, &fLockReleased);
            }

            if (_dwFlags & fBEEN_USED)
            {
                hr = CO_E_SERVER_STOPPING;
            }
            else
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CLSvrClassEntry::GetClassInterface - class is single-use, removing\n"));
                _dwContext = 0;  // zero context so it is not found by search
                _dwFlags |= fBEEN_USED;
            }

            if (!fExclusive)
            {
                LOCK_DOWNGRADE(_mxs, &cookie);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = E_OUTOFMEMORY;
            IUnknown *pUnk = new ((PBYTE) *ppIM) CpUnkMoniker(this, hr);
            if (SUCCEEDED(hr))
            {
                hr = pUnk->QueryInterface(IID_IMiniMoniker, (void **) ppIM);
            }
            if (pUnk)
            {
                pUnk->Release();
            }

            ClsCacheDebugOut((DEB_ACTIVATE, "CLSvrClassEntry::GetClassInterface: %s, hr = 0x%x, this = 0x%x\n",
                              HR2STRING(hr), hr, this));
        }
        
        return hr;
    }
    else
    {
        ClsCacheDebugOut((DEB_ERROR, "CLSvrClassEntry::GetClassInterface: FAILED, class suspended. this = 0x%x\n", this));
        return CO_E_SERVER_STOPPING;
    }

}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::AddToApartmentChain
//
//  Synopsis:   Add this object to the apartment's chain of lsvr's
//
//  Arguments:  none
//
//  Returns:    none
//
//  Algorithm:  Get the correct chain, add it to the front
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CLSvrClassEntry::AddToApartmentChain()
{

    ClsCacheDebugOut((DEB_ACTIVATE, "AddToApartmentChain: this = 0x%x\n", this));
    ASSERT_LOCK_HELD(_mxs);

    Win4Assert((_pNextLSvr == this) && (_pPrevLSvr == this) && "Object is already a member of the apartment chain");

    CLSvrClassEntry *pFront = GetApartmentChain(TRUE);
    if (pFront == 0)
    {
        return E_OUTOFMEMORY;
    }

    _pNextLSvr = pFront->_pNextLSvr;
    _pPrevLSvr = pFront;
    pFront->_pNextLSvr->_pPrevLSvr = this;
    pFront->_pNextLSvr = this;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::RemoveFromApartmentChain
//
//  Synopsis:   Remove this object from the apartment's chain of lsvr's
//
//  Arguments:  none
//
//  Returns:    none
//
//  Algorithm:  Remove the object
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
void CClassCache::CLSvrClassEntry::RemoveFromApartmentChain()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "RemoveFromApartmentChain: this = 0x%x\n", this));
    ASSERT_LOCK_HELD(_mxs);

    Win4Assert(_pNextLSvr != this && "Object is not a member of the apartment chain");

    _pNextLSvr->_pPrevLSvr = _pPrevLSvr;
    _pPrevLSvr->_pNextLSvr = _pNextLSvr;
    _pPrevLSvr = this;
    _pNextLSvr = this;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::Release
//
//  Synopsis:   Controlled destruction of a CLSvrClassEntry object
//
//  Arguments:  pFC      - [in] a pointer to a CFinsishComposite object
//                         for attaching IFinish interfaces.
//
//  Returns:    S_OK     - operation succeeded
//
//  Algorithm:  if already releasing, cancel
//              zero context and flags
//              remove from CClassEntry object (if needed) and Apt chain
//              create a CFinishObject to release the server and
//                  notify the SCM.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CLSvrClassEntry::Release(CFinishObject *pFO)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CLSvrClassEntry::Release: this = 0x%x, pFO = 0x%x\n", this, pFO));
    ASSERT_LOCK_HELD(_mxs);

    HRESULT hr = S_OK;

    pFO->Init(this);
    RemoveFromApartmentChain();
    _pClassEntry->RemoveBaseClassEntry(this);

    delete this;

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::GetDDEInfo
//
//  Synopsis:   Fills a DDECLASSINFO object with the state from this object
//
//  Arguments:  lpDdeClassInfo  - [in/out] the object to fill out
//              ppIM            - [out] Moniker to make a server if asked for
//
//  Returns:    S_OK     - operation succeeded
//              E_FAIL   - operation failed
//              PROPOGATE:CLSverClassEntry::GetClassInterface
//
//  Algorithm:  if the context mask and the current apartment match
//                  fill out the DDEInfo structure
//                  if asked for get the moniker
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CLSvrClassEntry::GetDDEInfo(LPDDECLASSINFO lpDdeClassInfo,
                                                 IMiniMoniker **ppIM)
{
    ClsCacheDebugOut((DEB_ACTIVATE,"CClassCache::CLSvrClassEntry::GetDDEInfo: "
                      "lpDdeClassInfo = 0x%x, ppIM = 0x%x", lpDdeClassInfo, ppIM));
    ASSERT_LOCK_HELD(_mxs);
    Win4Assert(IsValidPtrOut(lpDdeClassInfo, sizeof(LPDDECLASSINFO))  &&
               "CLSvrClassEntry::GetDDEInfo invalid out parameter");

    if (lpDdeClassInfo->dwContextMask & _dwContext)
    {
        HAPT hApt = GetCurrentApartmentId();

        if (hApt == _hApt)
        {
            // Found a matching record, set its info
            lpDdeClassInfo->dwContext         = _dwContext;
            lpDdeClassInfo->dwFlags           = _dwFlags;
            lpDdeClassInfo->dwThreadId        = _hApt;
            Win4Assert(_dwCookie);
            lpDdeClassInfo->dwRegistrationKey = _dwCookie;

            if (lpDdeClassInfo->fClaimFactory == TRUE)
            {
                HRESULT hr = GetClassInterface(ppIM);
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            else
            {
                lpDdeClassInfo->punk = NULL;
                *ppIM = 0;
            }

            return S_OK;
        }
    }

    return E_FAIL;
}



//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CLSvrClassEntry::CFinishObject ///////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CLSvrClassEntry::CFinishObject::Finish
//
//  Synopsis:   Finishes up revoking a server
//
//  Arguments:  none
//
//  Returns:    S_OK     - operation succeeded
//              CO_E_RELEASED   - object already released
//
//  Algorithm:  Tell the SCM this class has stopped
//              Notify the DDE Server
//              Release the server
//              delete the CLSvrClassEntry object
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CLSvrClassEntry::CFinishObject::Finish()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    ClsCacheDebugOut((DEB_ACTIVATE,"CLSvrClassEntry::CFinishObject::Finish: this = 0x%x\n", this));
    HRESULT hr;

    // Tell SCM about multiple use classes stopping.
    if (_dwScmReg != NO_SCM_REG)
    {
        gResolver.NotifyStopped(_clsid, _dwScmReg);
    }

    // If a DDE Server window exists for this class, then we need to
    // release it now.
    if (_hWndDdeServer != NULL)
    {
        // It's possible that SendMessage could fail. However, there
        // really isn't anything we can do about it. So, the error
        // code is not checked.
        SSSendMessage(_hWndDdeServer, WM_USER, 0, 0);
        _hWndDdeServer = NULL;

    }

    // Now really release it
    if (IsValidInterface(_pUnk))
    {
        CoDisconnectObject(_pUnk, NULL);
        _pUnk->Release();

        hr = S_OK;
    }
    else
    {
        ClsCacheDebugOut((DEB_ERROR,"CLSVRClassEntry::CFinishObject::Finish: Registered server destroyed before revoke!!!\n"));
        hr = CO_E_RELEASED;
    }

    return hr;
}




//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDllPathEntry ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::Create_rl
//
//  Synopsis:   Create a CDllPathEntry object
//
//  Arguments:  dip     - [in] DLL instantiation parameters
//              ap      - [in] Activation properties
//              pDPE    - [out] created CDllPathEntry
//
//  Returns:    S_OK    - operation succeeded
//              PROPOGATE:CDllPathEntry::LoadDll
//              PROPOGATE:CDllPathEntry::MakeValidInApartment
//
//  Algorithm:  Release lock, Load Dll, Take lock
//              If the CDllPathObject wasn't created while unlocked
//                 create CDllPathObject, and fill it out
//              make the object valid in this apartment
//
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::Create_rl(DLL_INSTANTIATION_PROPERTIES &dip,
                                              ACTIVATION_PROPERTIES_PARAM ap, CDllPathEntry *&pDPE)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::Create_rl  dip.pzDllPath = \""
                      TSZFMT "\" dip._dwFlags = 0x%x\n",  dip._pzDllPath, dip._dwFlags));
    ASSERT_LOCK_HELD(_mxs);

    HMODULE hDll = 0;
    HRESULT hr = S_OK;

    // load the dll
    LPFNGETCLASSOBJECT  pfnGetClassObject = 0;    // Create object entry point
    DLLUNLOADFNP        pfnDllCanUnload   = 0;    // DllCanUnloadNow entry point

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    hr  = LoadDll(dip,
                  pfnGetClassObject,
                  pfnDllCanUnload,
                  hDll);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);

    if (FAILED(hr))
    {

        ClsCacheDebugOut((DEB_ERROR, "CDllPathEntry LoadDll Failed this\n"));
        return hr;
    }


    // check to see no one loaded this library while
    // the lock was released.

    hr = CClassCache::SearchDPEHash(dip._pzDllPath, pDPE, dip._dwHash, dip._dwFlags);


    if (FAILED(hr))
    {
        // create a new CDllPathEntry

        hr = E_OUTOFMEMORY;
        pDPE = new CDllPathEntry(dip, hDll, pfnGetClassObject, pfnDllCanUnload);

        if (pDPE)
        {

            pDPE->_psPath = new WCHAR[lstrlenW(dip._pzDllPath)+1];
            if (pDPE->_psPath)
            {

                lstrcpyW(pDPE->_psPath, dip._pzDllPath);

                // add to hash table
                _DllPathEntries.Add(dip._dwHash,  pDPE);
		hr = S_OK;
            }
            else
            {
                delete pDPE;
            }
        }
	if (FAILED(hr))
	{
	   FreeLibrary(hDll);
	}
    }
    //Threads racing, free the extra load
    else
       FreeLibrary(hDll);
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::LoadDll
//
//  Synopsis:   Load the DLL
//
//  Arguments:  dip     - [in] DLL instantiation parameters
//              ap      - [in] Activation properties
//              pDPE    - [out] created CDllPathEntry
//
//  Returns:    S_OK    - operation succeeded
//              PROPoGATE:CDllPathEntry::LoadDll
//              PROPOGATE:CDllPathEntry::MakeValidInApartment
//
//  Algorithm:  Load the dll using correct method
//
//
//  History:    18-Nov-96 MattSmit  Created
//              26-Feb-98 CBiks     Removed bogus code that manipulated the
//                                  hard error flag.  It turns out the code
//                                  was originally added because of a Wx86
//                                  Loader bug, but nobody researched it
//                                  enough to figure that out.
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::LoadDll(DLL_INSTANTIATION_PROPERTIES &dip,
                                            LPFNGETCLASSOBJECT &pfnGetClassObject,
                                            DLLUNLOADFNP &pfnDllCanUnload,
                                            HMODULE &hDll)
{

    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::LoadDll dip.pzDllPath = \""
                      TSZFMT "\" dip._dwFlags = 0x%x\n",  dip._pzDllPath, dip._dwFlags));
    ASSERT_LOCK_NOT_HELD(_mxs);

    HRESULT hr = S_OK;

    if (dip._dwFlags & DLL_INSTANTIATION_PROPERTIES::fIS_OLE32)
    {
        pfnGetClassObject = ::DllGetClassObject;
        pfnDllCanUnload = 0;
        hDll = 0;
        return S_OK;
    }

    if (dip._dwFlags & DLL_INSTANTIATION_PROPERTIES::fIS_COMSVCS_CLSID)
    {
        if (!wCompareDllName (dip._pzDllPath, COMSVCS_DLL, COMSVCS_CHAR_LEN) &&
            !wCompareDllName (dip._pzDllPath, ES_DLL, ES_CHAR_LEN))
        {
            return E_UNEXPECTED;
        }
    }

    if (dip._dwFlags & DLL_INSTANTIATION_PROPERTIES::fSIXTEEN_BIT)
    {
        ClsCacheDebugOut((DEB_ACTIVATE,
                          "Attempting to load 16 bit DLL " TSZFMT "\n\n", dip._pzDllPath));

        // In this section, we need to call 16-bit DllGetClassObject. The
        // g_OleThunkWow pointer is the VTABLE to use for getting back to
        // the 16-bit implementation.
        hr = g_pOleThunkWOW->LoadProcDll(dip._pzDllPath,
                                         (DWORD *)&pfnGetClassObject,
                                         (DWORD *)&pfnDllCanUnload,
                                         (DWORD *)&hDll);

        // A failure condition would mean that the DLL could not be found,
        // or otherwise could not be loaded
        if (FAILED(hr))
        {
            ClsCacheDebugOut((DEB_ERROR,
                              "Load 16 bit DLL " TSZFMT " failed(%x)\n\n",dip._pzDllPath,hr));
            return CO_E_DLLNOTFOUND;
        }

        // The other possible error is the DLL didn't have the required
        // interface
        if (pfnGetClassObject == NULL)
        {
            ClsCacheDebugOut((DEB_ERROR,
                              "Get pfnGetClassObject %ws failed\n\n",
                              dip._pzDllPath));

            return(CO_E_ERRORINDLL);
        }

    }
    else
    {
        ClsCacheDebugOut((DEB_ACTIVATE,
                          "Attempting to load 32 bit DLL " TSZFMT "\n\n", dip._pzDllPath));

        hDll = LoadLibraryExW(dip._pzDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

        if (hDll == NULL)
        {
            //  Dll could not be loaded
            ClsCacheDebugOut((DEB_ERROR,
                              "Load of " TSZFMT " failed\n\n",
                              dip._pzDllPath));
            return HRESULT_FROM_WIN32(GetLastError());
        }

        // Get the entry points if desired
        if ((pfnGetClassObject = (LPFNGETCLASSOBJECT) GetProcAddress(hDll, DLL_GET_CLASS_OBJECT_EP)) == NULL)
        {
            // Doesn't have a valid entry point for creation of class objects
            return CO_E_ERRORINDLL;
        }


        // Not having an unload entry point is valid behavior
        pfnDllCanUnload = (DLLUNLOADFNP) GetProcAddress(hDll, DLL_CAN_UNLOAD_EP);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::MakeValidInApartment_rl16
//
//  Synopsis:   Makes the dll valid for instantiations in this apartment
//
//  Arguments:  hDll    - [in] handle if dll load already done (16 bit)
//              pfnGetClassObject - [in] entry point if dll already loaded (16 bit)
//              pfnDllCanUnload   - [in] entry point if dll already loaded (16 bit)
//
//  Returns:    S_OK    - operation succeeded
//              E_OUTOFMEMORY - Operation failed due to lack of memory
//              PROPGATE:CDllPathEntry::LoadDll
//
//  Algorithm:  if already valid in apartment return
//              create apartment entry and add it to the list
//              if 16 bit load up the dll on this thread
//
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::MakeValidInApartment_rl16(REFCLSID clsid, HMODULE hDll,
                                                              LPFNGETCLASSOBJECT pfnGetClassObject,
                                                              DLLUNLOADFNP pfnDllCanUnload)

{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::MakeValidInApartment_rl16: this = 0x%x\n"
                      "hDll = 0x%x, pfnGetClassObject = 0x%x, pfnDllCanUnload 0x%x\n",
                      this, hDll, pfnGetClassObject, pfnDllCanUnload));

    ASSERT_RORW_LOCK_HELD(_mxs);
    LockCookie cookie;

    HRESULT hr = S_OK;

    //  Walk the list of apartment entries looking for a match
    //  with the current apartment id. If one exists, we are valid,
    //  Otherwise, we will try to create an entry for the current
    //  apartment.
    HAPT hApt = GetCurrentApartmentId();
    if (IsValidInApartment(hApt))
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "Dll " TSZFMT " already valid in apt %d\n",
                          _psPath, hApt));
        return S_OK;
    }
    else
    {
        BOOL fLockReleased;
        LOCK_UPGRADE(_mxs, &cookie, &fLockReleased);
        if (fLockReleased)
        {
            if (IsValidInApartment(hApt))
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "Dll " TSZFMT " already valid in apt %d\n",
                                  _psPath, hApt));
                LOCK_DOWNGRADE(_mxs, &cookie);
                return S_OK;
            }
        }

    }

    ASSERT_WRITE_LOCK_HELD(_mxs);

    // No match found, create a new entry and link up to this DPE
    CDllAptEntry *pAptent = new CDllAptEntry(hApt);
    if (pAptent == 0)
    {
        hr = E_OUTOFMEMORY;
        goto epilog;
    }


    // Dll is always valid for non-WOW case
    if (!(_dwFlags & CDllPathEntry::fSIXTEEN_BIT) || (_dwFlags & CDllPathEntry::fIS_OLE32))
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "Making dll " TSZFMT " valid in apt %d, 32 bit or OLE32\n",
                          _psPath, hApt));
        AddDllAptEntry(pAptent);
        hr = S_OK;
        goto epilog;
    }

    // We need to release the lock across the LoadLibrary since there is
    // a chance that an exiting thread waits on our mutext to
    // CleanUpFoApartment while we wait on the kernel mutex which the
    // exiting thread owns
    // Reset the entry point values on every apartment initialization
    // to handle DLLs being unloaded and then reloaded at a different
    // address.
    if (!hDll)
    {
        DLL_INSTANTIATION_PROPERTIES dip;

        hr = dip.Init(_psPath, 0,
                      ((_dwFlags & fSIXTEEN_BIT) ? DLL_INSTANTIATION_PROPERTIES::fSIXTEEN_BIT : 0) |
                      (wCompareDllName(_psPath, OLE32_DLL, OLE32_CHAR_LEN) ? DLL_INSTANTIATION_PROPERTIES::fIS_OLE32 : 0), clsid
                      );
        if (FAILED(hr))
        {
            goto epilog;
        }
        LockCookie cookie2;

        LOCK_RELEASE(_mxs, &cookie2);

        hr = LoadDll(dip,
                     pfnGetClassObject,
                     pfnDllCanUnload,
                     hDll);
        LOCK_RESTORE(_mxs, &cookie2);
        ASSERT_WRITE_LOCK_HELD(_mxs);
    }
    _pfnGetClassObject = pfnGetClassObject;
    _pfnDllCanUnload = pfnDllCanUnload;

    pAptent->_hDll = hDll;

    if (FAILED(hr))
    {
        delete pAptent;
    }
    else
    {
        AddDllAptEntry(pAptent);

        ClsCacheDebugOut((DEB_ACTIVATE, "Making dll " TSZFMT " valid in apt %d\n",
                          _psPath, hApt));
    }
    epilog:
    ASSERT_WRITE_LOCK_HELD(_mxs);
    LOCK_DOWNGRADE(_mxs, &cookie);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::IsValidInApartment
//
//  Synopsis:   Return whether the current dll is valid in the apartment
//              specified
//
//  Arguments:  hApt     - [in] Apartment to check
//
//  Returns:    TRUE     - Is valid in apartment
//              FALSE    - Is not valid in apartment
//
//  Algorithm:  Sequential search of apartments for one that matches hApt.
//
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
BOOL CClassCache::CDllPathEntry::IsValidInApartment(HAPT hApt)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::IsValidInApartment: this = 0x%x, hApt = 0x%x\n\n", this, hApt));
    ASSERT_RORW_LOCK_HELD(_mxs);

    CDllAptEntry *pDAE = _pAptEntryFront;

    if (_dwFlags & fIS_OLE32)
    {
        return TRUE;
    }

    while (pDAE != (CDllAptEntry *) &_pAptEntryFront)
    {
        if (pDAE->_hApt == hApt)
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::IsValidInApartment:  Valid in current apt\n"));
            return TRUE;
        }
        pDAE = pDAE->_pNext;
    }

    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::IsValidInApartment:  NOT Valid in current apt\n"));
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::Release
//
//  Synopsis:   Controlled destruction of a CDllPathEntry object
//
//  Arguments:  pFC      - [in/out] pointer to finish composite object to
//                         attach IFinish interfaces
//
//  Returns:    S_OK     - operation succeeded
//
//  Algorithm:  Release the CDllClassEntry objects
//              Remove from DllHash
//
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::Release(CDllPathEntry::CFinishObject *pFO)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::Release: this = 0x%x, _cUsing = %d\n", this, _cUsing));
    ASSERT_LOCK_HELD(_mxs);


    Win4Assert(NoLongerNeeded());

    CDllClassEntry * pDCE, *pDCENext;

    for (pDCE = _p1stClass; pDCE; pDCE = pDCENext)
    {

        pDCENext = pDCE->_pDllClsNext;

        Win4Assert(pDCE->_pClassEntry);

        pDCE->_pClassEntry->RemoveBaseClassEntry(pDCE);


        delete pDCE;

    }

    // remove from dll hash;
    _pPrev->_pNext = _pNext;
    _pNext->_pPrev = _pPrev;

    // free the string
    delete [] _psPath;

    pFO->Init(_hDll32, _dwFlags);

    delete this;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties
//
//  Synopsis:   Registry work to read class and DLL properties
//
//  Arguments:  dwContext   - [in] Context mask
//              rclsid      - [in] CLSID to instantiate
//              dip         - [out] dll instantiaion properties
//
//  Returns:    S_OK     - operation succeeded
//              E_FAIL   - operation failed
//
//  Algorithm:  see comments below
//
//  History:    18-Nov-96 MattSmit  Created
//              26-Feb-98 CBiks     See RAID# 169589.  Factored
//                                  NegotiateDllInstantiationProperties() into
//                                  two functions so the code the the new
//                                  Negotiate...() wouldn't have to be duplicated
//                                  everyplace it was called.
//
//+-------------------------------------------------------------------------


#define PREFIX_STRING_OFFSET (CLSIDBACK_CHAR_LEN + GUIDSTR_MAX)

HRESULT  CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties(
                                                                        DWORD                        dwContext,
                                                                        DWORD                        actvflags,
                                                                        REFCLSID                     rclsid,
                                                                        DLL_INSTANTIATION_PROPERTIES &dip,
                                                                        IComClassInfo *pClassInfo,
                                                                        BOOL fTMOnly)
{
    HRESULT hr = E_FAIL;

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties2:"
                      "dwContext = 0x%x\n", dwContext));

    hr = CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties2(dwContext,
                                                                          rclsid,
                                                                          dip,
                                                                          pClassInfo);

    return hr;
}

inline HRESULT GetUnquotedPath(IClassClassicInfo* pClassicInfo,
                               CLSCTX             dwContext,
                               WCHAR**            ppwszDllPath,
                               WCHAR*             pTempDllPath,
                               size_t             cchTempDllPath)
{
  HRESULT hr = pClassicInfo->GetModulePath(dwContext, ppwszDllPath);
  if (SUCCEEDED(hr))
  {
    // The catalog has prestripped leading and trailing blanks from the path
    // Just strip the quotes

    if ((*ppwszDllPath)[0] == L'\"') {

      if(wcslen(*ppwszDllPath) > cchTempDllPath)
      {
        *ppwszDllPath = NULL;
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
      }

      // String is Quoted so copy to temp removing leading quote
      wcscpy(pTempDllPath,(*ppwszDllPath)+1);
      *ppwszDllPath = pTempDllPath;

      // Remove trailing " if present
      size_t iLen = wcslen(pTempDllPath);
      if ((iLen > 0) &&
          (pTempDllPath[iLen-1] == L'\"'))
      {
          pTempDllPath[iLen-1] = L'\0';
      }
    }
  }
  return hr;
}


HRESULT  CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties2(
                                                                         DWORD                        dwContext,
                                                                         REFCLSID                     rclsid,
                                                                         DLL_INSTANTIATION_PROPERTIES &dip,
                                                                         IComClassInfo *pClassInfo,
                                                                         BOOL fTMOnly)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties2:"
                      "dwContext = 0x%x\n", dwContext));

    ASSERT_LOCK_NOT_HELD(_mxs);
    HRESULT     hr=S_OK;


    IComClassInfo* pClassInfoToRel=NULL;
    IClassClassicInfo* pClassicInfo=NULL;
    LPWSTR pszDllPath=NULL;
    WCHAR szTempDllPath[MAX_PATH+1];

    if (pClassInfo==NULL)
    {
        hr = GetClassInfoFromClsid(rclsid, &pClassInfo);
        if (FAILED(hr)) goto exit;
        pClassInfoToRel = pClassInfo;
    }
    Win4Assert(NULL != pClassInfo);

    hr=pClassInfo->QueryInterface(IID_IClassClassicInfo, (void**) &pClassicInfo);
    if (FAILED(hr))
    {
        goto exit;
    }
    Win4Assert(NULL != pClassicInfo);

    ULONG       ulDllType;

    //
    // If 16-bit has been requested and we find it, we'll return that.
    //
    if (dwContext & CLSCTX_INPROC_SERVER16)
    {
        hr=GetUnquotedPath(pClassicInfo, 
                           CLSCTX_INPROC_SERVER16, 
                           &pszDllPath, szTempDllPath, 
                           sizeof(szTempDllPath)/sizeof(*szTempDllPath));
        if (SUCCEEDED(hr))
        {
            if (wCompareDllName(pszDllPath, OLE2_DLL, OLE2_CHAR_LEN))
            {
                hr = dip.Init(OLE32_DLL, BOTH_THREADED, 0, rclsid, fTMOnly);
                goto exit;
            }
            else
            {
                //
                // Otherwise, load the 16-bit fellow but only if in WOW thread.
                //

                if (IsWOWThread())
                {

                    hr = dip.Init(pszDllPath,
                                  APT_THREADED,
                                  DLL_INSTANTIATION_PROPERTIES::fSIXTEEN_BIT,
                                  rclsid,
                                  fTMOnly);

                    goto exit;
                }
            }
        }
    }

    //
    // Could be that we are trying to load an INPROC_SERVER
    //
    if (dwContext & CLSCTX_INPROC_SERVER)
    {


        hr=GetUnquotedPath(pClassicInfo, 
                           CLSCTX_INPROC_SERVER, 
                           &pszDllPath, 
                           szTempDllPath, 
                           sizeof(szTempDllPath)/sizeof(*szTempDllPath));
        if (SUCCEEDED(hr))
        {
            if (wCompareDllName(pszDllPath, OLE32_DLL, OLE32_CHAR_LEN))
            {
                pszDllPath=(LPWSTR) OLE32_DLL;
                ulDllType = BOTH_THREADED;
            }
            else
            {
                hr=pClassicInfo->GetThreadingModel((ThreadingModel*) &ulDllType);
                if (FAILED(hr))
                {
                    hr = REGDB_E_BADTHREADINGMODEL;
                    goto exit;
                }
            }

            //
            // If we are after a proxy/stub dll, then load it as both
            // no matter what the DLL says.
            //

            if (dwContext & CLSCTX_PS_DLL)
                ulDllType = BOTH_THREADED;

            //
            // load it.
            //


            hr = dip.Init(pszDllPath, ulDllType, 0, rclsid, fTMOnly);

            goto exit;
        }
    }


    //
    // If INPROC_HANDLER16 set, then we look to load a 16-bit handler.
    // If the handler is ole2.dll, then we will load ole32 instead.
    // Otherwise we load the found 16bit dll but only if in a WOW thread.
    //

    if (dwContext & CLSCTX_INPROC_HANDLER16 )
    {
        hr=GetUnquotedPath(pClassicInfo, 
                           CLSCTX_INPROC_HANDLER16, 
                           &pszDllPath, 
                           szTempDllPath, 
                           sizeof(szTempDllPath)/sizeof(*szTempDllPath));
        if (SUCCEEDED(hr))
        {
            //
            // If the inproc handler is ole2.dll, then subst
            // ole32.dll instead
            //
            if (wCompareDllName(pszDllPath,OLE2_DLL,OLE2_CHAR_LEN))
            {
                hr = dip.Init(OLE32_DLL, BOTH_THREADED, 0, rclsid, fTMOnly);
                goto exit;
            }
            else
            {
                // Otherwise, load the 16-bit fellow but only if in WOW thread
                if (IsWOWThread())
                {
                    hr = dip.Init(pszDllPath, APT_THREADED,
                                  DLL_INSTANTIATION_PROPERTIES::fSIXTEEN_BIT,
                                  rclsid,
                                  fTMOnly);
                    goto exit;
                }
            }
        }
    }

    //
    // See about 32-bit handlers. A was a change made after the
    // Win95 (August release) and Windows/NT 3.51 release. Previously
    // the code would give preference to loading 32-bit handlers. This
    // means that even if an ISV provided both 16 and 32-bit handlers,
    // the code would only attempt to provide the 32-bit handler. This
    // was bad because servers with handlers could not be inserted into
    // containers in the wrong model. We have fixed it here.
    //
    // Another thing to watch out for are applications that use our
    // default handler. 16-bit applications can and should be able to
    // use OLE32 has a handler. This will happen if the server app is
    // actually a 32-bit.
    //
    //
    if (dwContext & CLSCTX_INPROC_HANDLERS)
    {


        if (SUCCEEDED(hr=GetUnquotedPath(pClassicInfo, 
                                         CLSCTX_INPROC_HANDLER, 
                                         &pszDllPath, 
                                         szTempDllPath, 
                                         sizeof(szTempDllPath)/sizeof(*szTempDllPath))))
        {
            // Handlers are both threaded.
            ulDllType=BOTH_THREADED; 
            if (wCompareDllName(pszDllPath, OLE32_DLL, OLE32_CHAR_LEN))
            {
                pszDllPath=(LPWSTR) OLE32_DLL;
            }

            //
            // If it turns out this path is for OLE32.DLL, then add the DLL without the
            // path.
            //
            LPCWSTR pDllName = wCompareDllName(pszDllPath,OLE32_DLL,OLE32_CHAR_LEN)?
                               OLE32_DLL:pszDllPath;

            //
            // If we are looking for a INPROC_HANDER16 and this is OLE32.DLL, or if we
            // are looking for an INPROC_HANDLER, then load this path. Note that pDllName
            // was set above.
            //
            // If we're in a Wow thread the only 32 bit DLL we're allowed to load is
            // OLE32.DLL
            if ((IsWOWThread() && (pDllName == OLE32_DLL)) ||
                (!IsWOWThread() ))
            {
                // Add a 32-bit handler to the pile.
                hr = dip.Init(pDllName, ulDllType, 0, rclsid, fTMOnly);
                goto exit;

            }
        }

        else
        {
            // We're here if we couldn't find a 32-bit handler.  If non-Wow caller didn't
            // explicitly request 16-bit handler we'll look for one here.  But the only one
            // allowed is OLE2.DLL => OLE32.DLL
            if (!IsWOWThread() && !(dwContext & CLSCTX_INPROC_HANDLER16))
            {
                hr=GetUnquotedPath(pClassicInfo,
                                   CLSCTX_INPROC_HANDLER16,
                                   &pszDllPath,
                                   szTempDllPath,sizeof(szTempDllPath)/sizeof(*szTempDllPath));
                if (SUCCEEDED(hr))
                {
                    //
                    // If the inproc handler is ole2.dll, then subst
                    // ole32.dll instead
                    //
                    if (wCompareDllName(pszDllPath,OLE2_DLL,OLE2_CHAR_LEN))
                    {
                        // Add and load OLE32.DLL
                        hr = dip.Init(OLE32_DLL, BOTH_THREADED, 0, rclsid, fTMOnly);
                        //return S_OK;
                        goto exit;
                    }
                }
            }
        }
    }


    hr=REGDB_E_CLASSNOTREG;

    exit:

    if (pClassInfoToRel)
    {
        pClassInfoToRel->Release();
        pClassInfoToRel=NULL;
    }
    if (pClassicInfo)
    {
        pClassicInfo->Release();
        pClassicInfo=NULL;
    }
    if (FAILED(hr))
    {
        ClsCacheDebugOut((DEB_TRACE, "CClassCache::CDllPathEntry::NegotiateDllInstantiationProperties:"
                          "returns %x for CLSID %I dwContext = 0x%x\n", hr, &rclsid, dwContext));
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::CanUnload_rl
//
//  Synopsis:   Determine if it is safe to unload a dll
//
//  Arguments:  dwUnloadDelay - [in] amount to age DLL that could be unloaded
//
//  Returns:    S_OK     - operation succeeded can unload
//              S_FALSE  - operation succeeded cannot unload
//
//
//  Algorithm:  see comments below
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::CanUnload_rl(DWORD dwUnloadDelay)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl on " TSZFMT "\n",
                      _psPath));

    // Single thread access to the table
    ASSERT_LOCK_HELD(_mxs);

    // Unless the code is changed, we should not be here in the Wow case
    ClsCacheAssert(!IsWOWProcess() && "Freeing unused libraries in WOW");


    if (_cUsing != 0)
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: Dll in use. Cancel unload. _cUsing = %d", _cUsing));
        // At least one thread is using the object unlocked so we better
        // not release the DLL object.
        return S_FALSE;
    }

    // Does DLL support unloading itself?
    if (_pfnDllCanUnload)
    {
        // Release the lock across outgoing call
        BOOL  fSixteenBit     = _dwFlags & CDllPathEntry::fSIXTEEN_BIT;
        HRESULT       hr;

        _cUsing++;

        _fGCO_WAS_HERE = FALSE;




        // Need to check to see if the class is 16-bit.
        // If it is 16-bit, then this call needs to be routed through a thunk
        if (!fSixteenBit)
        {

            // Call through to the DLL -- does it think it can unload?
            UNLOCK(_mxs);
            ASSERT_LOCK_NOT_HELD(_mxs);
            hr = (*_pfnDllCanUnload)();
            LOCK(_mxs);
            ASSERT_LOCK_HELD(_mxs);

            ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: Dll says %s\n", (hr == S_OK) ? "S_OK" : "S_FALSE"));

            if (hr == S_OK && _fGCO_WAS_HERE)
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: Dll says %s,"
                                  "but GetClassObject touched this dll.\n",
                                  (hr == S_OK) ? "S_OK" : "S_FALSE"));
                // the Dll thinks it's OK to unload, but this DllPathEntry object
                // was touched by GetclassObject while the lock was released
                hr = S_FALSE;
            }
            if (hr == S_OK && _dwFlags & CDllPathEntry::fDELAYED_UNLOAD)
            {
                // the DLL thinks it's OK to unload, but we are employing
                // delayed unloading, so go check if we've reached the
                // expire time yet.

                DWORD dwCurrentTime = GetTickCount();

                // Handle special dwUnloadDelay values
                if (dwUnloadDelay == 0)
                {
                    // A new delay time of 0 overrides any existing delays
                    // Immediate unload requested
                    _dwExpireTime = dwCurrentTime;
                }
                else if (dwUnloadDelay == INFINITE)
                {
                    // Default delay requested
                    dwUnloadDelay = DLL_DELAY_UNLOAD_TIME;
                }


                if (_dwExpireTime == 0)
                {
                    // first time we've reached this state, record the
                    // expire timer. When current time exceeds this time
                    // we can unload.

                    _dwExpireTime = dwCurrentTime + dwUnloadDelay;
                    if (_dwExpireTime < dwUnloadDelay)
                    {
                        // handle counter wrapping, we'll just wait a little
                        // longer once every 49.7 days.
                        _dwExpireTime = dwUnloadDelay;
                    }
                    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: "
                                      "Delaying Unload _dwExpireTime = %d, dwCurrentTime = %d\n",
                                      _dwExpireTime, dwCurrentTime));
                    hr = S_FALSE;
                }
                else
                {
                    if ((_dwExpireTime > dwCurrentTime) ||
                        (dwCurrentTime + dwUnloadDelay < _dwExpireTime))
                    {
                        ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: "
                                          "Still Delaying unload _dwExpireTime = %d, dwCurrentTime = %d\n",
                                          _dwExpireTime, dwCurrentTime));
                        hr = S_FALSE;
                    }
                }
            }
        }
        else  // sixteen-bit
        {
#if defined(_WIN64)

            ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: "
                              "Sundown - This class should not be 16bit,  returning S_FALSE\n"));
            hr = S_FALSE;

#else  // !_WIN64

            if (!IsWOWThread() || !IsWOWThreadCallable())
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: "
                                  "Not On WOW Thread,  returning S_FALSE\n"));
                hr = S_FALSE;
            }
            else
            {
                UNLOCK(_mxs);
                hr = g_pOleThunkWOW->CallCanUnloadNow((DWORD) _pfnDllCanUnload);
                ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: Sixteen bit Dll says %s\n",
                                  (hr == S_OK) ? "S_OK" : "S_FALSE"));

                LOCK(_mxs);
            }

#endif // !_WIN64

        }

        _cUsing--;

        // Check _cUsing in case someone started using this object while
        // the lock was released
        if (_cUsing != 0)
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::CanUnload_rl: SomeOne is using the object now. _cUsing = %d\n",
                              _cUsing));

            hr = S_FALSE;
        }



        return hr;

    }

    return S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::DllGetclassObject
//
//  Synopsis:   Callback method from CDllHost to create the object on
//              the correct thread.
//
//  Arguments:  rclsid   - class id to get
//              riid     - interface it to query
//              ppUnk    - location for object
//
//  Returns:    S_OK     - operation succeeded can unload
//              other    - failed
//
//  Algorithm:  see comments below
//
//  History:    02-Mar-97  MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::DllGetClassObject(REFCLSID rclsid, REFIID riid, LPUNKNOWN * ppUnk, BOOL fMakeValid)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::DllGetClassObject clsid = %I,  riid = %I, ppunk = 0x%x",
                      &rclsid, &riid, ppUnk));
    HRESULT hr = E_FAIL;

    // The Class Cache lock is not currently held.  This is ok because there should
    // be a positive count in _cUsing for this object.
    ASSERT_LOCK_NOT_HELD(_mxs);
    Win4Assert((LONG) _cUsing >= 0);

    // Create the object
    if (_dwFlags & CDllPathEntry::fSIXTEEN_BIT) // 16 bit server
    {

#if defined(_WIN64)

        ClsCacheDebugOut((DEB_ACTIVATE, "CDllPathEntry::DllGetClassObject - Sundown: Server should not be 16bits"));
        hr = S_FALSE;

#else  // !_WIN64

        hr = g_pOleThunkWOW->CallGetClassObject((DWORD)_pfnGetClassObject,
                                                rclsid,
                                                riid,
                                                (void **)ppUnk);
#endif // !_WIN64

    }
    else
    {
        // Phew!  32 bit server
        hr = _pfnGetClassObject(rclsid, riid, (void **) ppUnk);

        if (SUCCEEDED(hr) && fMakeValid)
        {
            LOCK_READ(_mxs);
            hr = MakeValidInApartment_rl16 (rclsid);
            UNLOCK_READ(_mxs);
        }

    }

    if (SUCCEEDED(hr) && (*ppUnk == NULL))
        CoVrfNotifyGCOSuccessWithNULL(_psPath, rclsid, riid, hr);

    return hr;
}



//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDllPathEntry::CFinishObject /////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllPathEntry::CFinishObject::Finish
//
//  Synopsis:   Finish releasing a CDllPathEntry object
//
//  Arguments:  none
//
//  Returns:    S_OK     - operation succeeded can unload
//
//
//  Algorithm:  free the library, and delete the object
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllPathEntry::CFinishObject::Finish()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CDllPathEntry::CFinishObject::Finish: 0x%x\n", this));
    ASSERT_LOCK_NOT_HELD(_mxs);

    if (_hDll)
    {
        if (_dwFlags & CDllPathEntry::fSIXTEEN_BIT)
        {
#if defined(_WIN64)
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CDllPathEntry::CFinishObject::Finish: Sundown - DllPathEntry should not be 16bit\n"));
            return( S_FALSE );
#else   // !_WIN64
            g_pOleThunkWOW->UnloadProcDll(_hDll);
#endif  // !_WIN64
        }
        else if (!(_dwFlags & CDllPathEntry::fIS_OLE32))
        {
            FreeLibrary(_hDll);
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDllAptEntry /////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CDllAptEntry::Release
//
//  Synopsis:   Release an apartment entry
//
//  Arguments:  pFC  - [in/out] CFinishComposite object for adding IFinish
//              interfaces.
//
//  Returns:    S_OK     - operation succeeded can unload
//
//
//  Algorithm:  if there is a dll handle create a finish object to free it.
//              remove from the apartment list, delete this apartment.
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CDllAptEntry::Release(CDllPathEntry::CFinishObject *pFO, BOOL &fUsedFO)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CDllAptEntry::Release: this = 0x%p\n", this));
    ASSERT_LOCK_HELD(_mxs);

    if (_hDll)
    {
        pFO->Init(_hDll, CDllPathEntry::fSIXTEEN_BIT);
        fUsedFO = TRUE;
    }

    _pNext->_pPrev = _pPrev;
    _pPrev->_pNext = _pNext;

    delete this;
    return S_OK;
}





//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CFinishComposite /////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CFinishComposite:~CFinishComposite
//
//  Synopsis:   Destructor
//
//  Arguments:  none
//
//  Returns:    n/a
//
//  Algorithm:  Release all aquired interfaces
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
CClassCache::CFinishComposite::~CFinishComposite()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CFinishComposite: Destructing this = 0x%x\n", this));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    node *p, *pNextNode;
    FOREACH_SAFE(p, _pFinishNodesFront, pNextNode, _pNext)
    {
        if (p->_pIF)
        {
            delete p->_pIF;
        }
        delete p;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::CFinishComposite:Finish
//
//  Synopsis:   Executes the finish operation
//
//  Arguments:  none
//
//  Returns:    n/a
//
//  Algorithm:  for all interfaces, call Finish and release the interface
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::CFinishComposite::Finish()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CFinishComposite::Finish this = 0x%x\n", this));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    HRESULT hr;
    node *p, *pNextNode;
    FOREACH_SAFE(p, _pFinishNodesFront, pNextNode, _pNext)
    {
        if (p->_pIF)
        {
            hr = p->_pIF->Finish();
            delete p->_pIF;
        }
        delete p;
    }
    _pFinishNodesFront = (node *) &_pFinishNodesFront;
    _pFinishNodesBack  = (node *) &_pFinishNodesFront;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDllFnPtrMoniker ///////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CClassCache::CDllFnPtrMoniker::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }


    *ppv = NULL;
    if (riid == IID_IUnknown)
    {
        *ppv = this;
    }
    else if (riid == IID_IMiniMoniker)
    {
        *ppv = (IMiniMoniker*) this;
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        return S_OK;
    }
    else
    {

        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CClassCache::CDllFnPtrMoniker::AddRef()
{
    return InterlockedIncrement((PLONG) &_cRefs);
}

STDMETHODIMP_(ULONG) CClassCache::CDllFnPtrMoniker::Release()
{
    ULONG ret = (ULONG)  InterlockedDecrement((PLONG) &_cRefs);

    if (ret == 0)
    {
        delete this;
    }
    return 0;
}



//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::GetActivatorFromDllHost
//
//  Synopsis:      figure out where this dll should be activated and get an
//                 apartment token
//
//  History:       25-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::GetActivatorFromDllHost(BOOL fSixteenBit,
                                             DWORD dwDllThreadModel,
                                             HActivator *phActivator)
{

    ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetActivatorFromDllHost IN fSixteenBit:%s, "
                      "dwDllThreadModel:0x%x, phActivator:0x%x\n",
                      fSixteenBit ? "TRUE" : "FALSE", dwDllThreadModel, phActivator));

    ASSERT_LOCK_NOT_HELD(_mxs);
    HRESULT hr = S_OK;

    // attach reference to the out parameter
    HActivator &hActivator = *phActivator;


    // Need to check to see if the class is 16-bit or not.
    // If it is 16-bit, then this call needs to be routed through
    // a thunk
    if (!fSixteenBit)
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - 32 bit factory\n"));
        // Find 32 bit interface
        //
        // We load single threaded DLLs specially if we are not in WOW.
        // The reason for this is that the initial release of Daytona
        // did not know about multiple threads and therefore, we want
        // to make sure that they don't get inadvertently multithreaded.
        // The reason we don't have to do this if we are in WOW is that
        // only one thread is allowed to execute at a time even though
        // there are multiple physical threads and therefore the DLL
        // will never be executed in a multithreaded manner.

        BOOL fThisThread = TRUE;
        switch (dwDllThreadModel)
        {
        case SINGLE_THREADED:
            if ((!IsWOWProcess() || !IsWOWThread() || !IsWOWThreadCallable())
                && (!OnMainThread() || IsThreadInNTA()))
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - passing call to main thread\n"));
                // Pass the call to the main thread
                fThisThread = FALSE;
                if (IsMTAThread())
                {
                    hr = DoSTMTApartmentCreate(hActivator);
                }
                else
                {
                    hr = DoSTApartmentCreate(hActivator);
                }
            }
            break;

        case APT_THREADED:
            if (IsMTAThread() || IsThreadInNTA())
            {
                // pass call to apartment thread worker
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - passing call to apartment thread worker\n"));
                fThisThread = FALSE;
                hr = DoATApartmentCreate(hActivator);
            }
            break;

        case FREE_THREADED:
            if (IsSTAThread() || IsThreadInNTA())
            {
                // pass call to MTA
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - passing call to MTA\n"));

                fThisThread = FALSE;
                hr = DoMTApartmentCreate(hActivator);
            }
            break;

        case BOTH_THREADED:
            break;

        case NEUTRAL_THREADED:
            if (!IsThreadInNTA())
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - passing call to NTA\n"));

                fThisThread = FALSE;
                hr = DoNTApartmentCreate(hActivator);
            }
            break;
        }

        if (fThisThread)
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetActivatorFromDllHost - creating on this thread\n"));
            hr = S_OK;

            // return the special (phoney) cookie to signify same apartment
            hActivator = CURRENT_APARTMENT_TOKEN;
        }

        if (FAILED(hr))
        {
            ClsCacheDebugOut((DEB_ERROR,"CClassCache::GetActivatorFromDllHost failed (0x%x)\n\n",hr));
        }

    }
    else
    {
        ClsCacheDebugOut((DEB_ACTIVATE,
                          "CClassCache::GetActivatorFromDllHost setting apartment for 16 bit factory\n"));

        //
        // Check to be sure this is a sensible situation for a 16bit server.
        //

        if (!IsWOWProcess())
        {
            ClsCacheDebugOut((DEB_ACTIVATE,
                              "CClassCache::GetActivatorFromDllHost: on 16bit; not in VDM\n\n"));
            return E_FAIL;
        }

        if (!IsWOWThread())
        {
            ClsCacheDebugOut((DEB_ACTIVATE,
                              "CClassCache::GetActivatorFromDllHost on 16bit; not in 16-bit thread\n\n"));
            return E_FAIL;
        }

        // 16 bit inproc servers are always used in the current apartment
        if (SUCCEEDED(hr))
        {
            hActivator = CURRENT_APARTMENT_TOKEN;
        }
    }

    ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetActivatorFromDllHost OUT"
                      "*phActivator:0x%x, hr:0x%x\n", *phActivator, hr));
    return hr;

}


HRESULT HelperGetImplementedClsid(IComClassInfo* pCI, /*[in]*/ CLSID* pConfigCLSID, /*[out]*/ CLSID* pImplCLSID)
{
    HRESULT hr=E_FAIL;
    IClassClassicInfo* pClassicInfo=NULL;
    Win4Assert(pImplCLSID);
    Win4Assert(pConfigCLSID);

    if (!pCI)
    {
        IComClassInfo* pTemp=NULL;
        hr = GetClassInfoFromClsid(*pConfigCLSID, &pTemp);
        if (FAILED(hr))
            return hr;

        hr=pTemp->QueryInterface(IID_IClassClassicInfo, (void**) &pClassicInfo);
        pTemp->Release();
    }
    else
    {
        hr=pCI->QueryInterface(IID_IClassClassicInfo, (void**) &pClassicInfo);
    }

    // Now check the result of the QI
    if (SUCCEEDED(hr))
    {
        // Use temporary pointer because pTemp's life time is bound by the class info object's life time
        CLSID* pTemp=NULL;
        hr=pClassicInfo->GetImplementedClsid(&pTemp);
        if (FAILED(hr))
        {
            Win4Assert(FALSE && "IClassClassicInfo::GetImplementedCLSID failed in HelperGetImplementedClsid");
            // Fall back: use configured class id
            *pImplCLSID=*pConfigCLSID;
        }
        else
        {
            // Copy the buffer
            Win4Assert(pTemp);
            *pImplCLSID=*pTemp;
        }
        pClassicInfo->Release();
        pClassicInfo=NULL;
    }
    else
    {
        Win4Assert(FALSE && "QI for IClassClassicInfo failed in HelperGetImplementedClsid");
        // Fall back: use configured class id
        *pImplCLSID=*pConfigCLSID;
    }
    return hr;
}

// IMiniMoniker


HRESULT CClassCache::CDllFnPtrMoniker::CheckApt()
{

    BOOL fThisApartment = TRUE;
    switch (_pDCE->_dwDllThreadModel)
    {
    case SINGLE_THREADED:
        if ((!IsWOWProcess() || !IsWOWThread() || !IsWOWThreadCallable())
            && !OnMainThread())
        {
            fThisApartment = FALSE;
        }
        break;

    case APT_THREADED:
        if (IsThreadInNTA() || IsMTAThread())
        {
            fThisApartment = FALSE;
        }
        break;
    case FREE_THREADED:
        if (IsThreadInNTA() || IsSTAThread())
        {
            fThisApartment = FALSE;
        }
        break;
    case BOTH_THREADED:
        break;
    case NEUTRAL_THREADED:
        fThisApartment = FALSE;
        break;
    }

    return fThisApartment ? S_OK : CLASS_E_CLASSNOTAVAILABLE;
}

HRESULT CClassCache::CDllFnPtrMoniker::CheckNotComPlus()
{

    return(_pDCE->_pClassEntry->_dwFlags & CClassEntry::fCOMPLUS) ?
    E_FAIL :
    S_OK;
}
//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::CDllFnPtrMoniker::BindToObjectNoSwitch
//
//  Synopsis:      BindToObject which does not switch threads.
//
//  History:       28-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::CDllFnPtrMoniker::BindToObjectNoSwitch(
                                                           REFIID  riid,
                                                           void**  ppvResult)
{
    return _pDCE->_pDllPathEntry->DllGetClassObject(_pDCE->_impclsid, riid, (IUnknown **) ppvResult, TRUE);
}

HRESULT CClassCache::CDllFnPtrMoniker::GetDCE(CClassCache::CDllClassEntry **ppDCE)
{

    LOCK(_mxs);
    _pDCE->Lock();
    UNLOCK(_mxs);
    *ppDCE = _pDCE;
    return S_OK;
}
//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::CDllFnPtrMoniker::BindToObject
//
//  Synopsis:      Switchs to the correct thread and calls into the DLL to
//                 get the class object
//
//  History:       28-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::CDllFnPtrMoniker::BindToObject(
                                                   REFIID  riid,
                                                   void**  ppvResult)

{
    char* msghdr = "CDllFnPtrMoniker::BindToObject - ";

    ClsCacheDebugOut((DEB_ACTIVATE, "CDllFnPtrMoniker::BindToObject\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    HRESULT hr = S_OK;

    //
    // Need to check to see if the class is 16-bit or not.  If it is 16-bit,
    // then this call needs to be routed through a thunk.
    //

    if (!(_pDCE->_pDllPathEntry->_dwFlags & CDllPathEntry::fSIXTEEN_BIT))
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "%screating 32-bit factory\n", msghdr));

        //
        // Find 32 bit interface
        //
        // We load single threaded DLLs specially if we are not in WOW.
        // The reason for this is that the initial release of Daytona
        // did not know about multiple threads and therefore, we want
        // to make sure that they don't get inadvertently multithreaded.
        // The reason we don't have to do this if we are in WOW is that
        // only one thread is allowed to execute at a time even though
        // there are multiple physical threads and therefore the DLL
        // will never be executed in a multithreaded manner.
        //

        BOOL fThisApartment = TRUE;
        switch (_pDCE->_dwDllThreadModel)
        {
        case SINGLE_THREADED:

            if ((!IsWOWProcess() || !IsWOWThread() || !IsWOWThreadCallable())
                && (!OnMainThread() || IsThreadInNTA()))
            {
                //
                // Single threaded object, not on a WOW thread and not already
                // in the main thread.  Switch to the main thread to create
                // the object.
                //

                ClsCacheDebugOut((DEB_ACTIVATE, "%sswitching to main thread\n", msghdr));
                fThisApartment = FALSE;
                if (IsMTAThread())
                {
                    hr = DoSTMTClassCreate(_pDCE->_pDllPathEntry,
                                           _pDCE->_pClassEntry->GetCLSID(),
                                           riid,
                                           (IUnknown **) ppvResult);
                }
                else
                {
                    hr = DoSTClassCreate(_pDCE->_pDllPathEntry,
                                         _pDCE->_pClassEntry->GetCLSID(),
                                         riid,
                                         (IUnknown **) ppvResult);
                }
            }
            break;

        case APT_THREADED:

            if (IsThreadInNTA() || IsMTAThread())
            {
                // An apartment model object is being created by code running
                // in the NTA or on an MTA thread.  Switch to an STA thread to
                // create the object.

                ClsCacheDebugOut((DEB_ACTIVATE, "%sswitching to STA worker\n", msghdr));
                fThisApartment = FALSE;
                hr = DoATClassCreate(_pDCE->_pDllPathEntry,
                                     _pDCE->_pClassEntry->GetCLSID(),
                                     riid, (IUnknown **) ppvResult);
            }
            break;

        case FREE_THREADED:

            if (IsThreadInNTA() || IsSTAThread())
            {
                // A freethreaded model object is being created by code
                // running in the NTA or on an STA thread.  Switch to the MTA
                // to create the object.

                ClsCacheDebugOut((DEB_ACTIVATE, "%sswitching to MTA worker\n", msghdr));
                fThisApartment = FALSE;
                hr = DoMTClassCreate(_pDCE->_pDllPathEntry, _pDCE->_pClassEntry->GetCLSID(),
                                     riid, (IUnknown **) ppvResult);
            }
            break;

        case BOTH_THREADED:

            //
            // In all cases, an object marked BOTH is created in the same
            // apartment and on the same thread as the cleint code.
            //

            break;

        case NEUTRAL_THREADED:

            //
            // Create NEUTRAL model objects in the NEUTRAL apartment.
            //

            fThisApartment = FALSE;
            hr = DoNTClassCreate(_pDCE->_pDllPathEntry, _pDCE->_pClassEntry->GetCLSID(),
                                 riid, (IUnknown**) ppvResult);
            break;
        }

        if (fThisApartment)
        {
            //
            // The object can be created in same apartment as the client.
            // Return a direct pointer to its class factory.
            //

            ClsCacheDebugOut((DEB_ACTIVATE, "%screating in current apt\n", msghdr));
            hr = _pDCE->_pDllPathEntry->DllGetClassObject(_pDCE->_impclsid, riid, (IUnknown **) ppvResult, FALSE);
        }

        if (FAILED(hr))
        {
            ClsCacheDebugOut((DEB_ACTIVATE,"%sfailed (0x%x)\n\n", msghdr, hr));
        }

    }
    else
    {
#if defined(_WIN64)

        ClsCacheDebugOut((DEB_ACTIVATE, "%sfailed - Sundown: We should not create 16 bit factory\n", msghdr));
        hr = E_FAIL;

#else   // !_WIN64

        ClsCacheDebugOut((DEB_ACTIVATE, "%screating 16 bit factory\n", msghdr));

        //
        // Find 16-bit interface.
        //

        if (!IsWOWProcess())
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "%son 16bit; not in VDM\n\n", msghdr));
            return E_FAIL;
        }

        if (!IsWOWThread())
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "%son 16bit; not in 16-bit thread\n\n", msghdr));
            return E_FAIL;
        }

        LOCK(_mxs);
        hr = _pDCE->_pDllPathEntry->MakeValidInApartment_rl16 (_pDCE->_pClassEntry->GetCLSID());
        UNLOCK(_mxs);
        if (SUCCEEDED(hr))
        {
            hr = g_pOleThunkWOW->CallGetClassObject((DWORD)_pDCE->_pDllPathEntry->_pfnGetClassObject,
                                                    _pDCE->_pClassEntry->GetCLSID(),
                                                    riid,
                                                    (void **)ppvResult);
            if (FAILED(hr))
            {
                ClsCacheDebugOut((DEB_ACTIVATE,
                                  "CDllFnPtrMoniker::BindToObject 16-bit failed (0x%x)\n\n",hr));
            }
        }

#endif // !_WIN64

    }

    return hr;
}




/////////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CpUnkMoniker ////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClassCache::CpUnkMoniker::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    *ppv = NULL;
    if (riid == IID_IUnknown)
    {
        *ppv = (IUnknown *)this;
    }
    else if (riid == IID_IMiniMoniker)
    {
        *ppv = (IMiniMoniker*) this;
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        return S_OK;
    }
    else
    {

        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CClassCache::CpUnkMoniker::AddRef()
{
    return InterlockedIncrement((PLONG) &_cRefs);
}

STDMETHODIMP_(ULONG) CClassCache::CpUnkMoniker::Release()
{
    ULONG ret = (ULONG)  InterlockedDecrement((PLONG) &_cRefs);

    if (ret == 0)
    {
        delete this;
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::CpUnkMoniker::BindToObjectNoSwitch
//
//  Synopsis:      delegate to BindToObject see CDllFnPtrMoniker::BindToObjectNoSwitch
//                 for info on why this must be implemented.
//
//  History:       28-Apr-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::CpUnkMoniker::BindToObjectNoSwitch(REFIID riidResult, void **ppvResult)
{
    return BindToObject(riidResult, ppvResult);
}



//+-------------------------------------------------------------------------
//
//  Function:   CClassCache::CCpUnkMoniker::BindToObject
//
//  Synopsis:   Creates an object based on the internal state
//
//  Arguments:  riid   - [in] IID to return
//              ppvResult - [out] where to put the new object
//
//  Returns:    S_OK   -  operation succeeded
//              PROPOGATE:QueryInterface
//
//
//  Algorithm:  see comments below
//
//  History:    09-Sep-96  MattSmit   Created
//
//+-------------------------------------------------------------------------

HRESULT CClassCache::CpUnkMoniker::BindToObject(REFIID riidResult, void **ppvResult)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CpUnkMoniker::BindToObject\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    return  _pUnk->QueryInterface(riidResult, ppvResult);
}

HRESULT CClassCache::CpUnkMoniker::GetDCE(CClassCache::CDllClassEntry **ppDCE)
{
    return E_NOTIMPL;
}

HRESULT CClassCache::CpUnkMoniker::CheckApt()
{
    return S_OK;
}
HRESULT CClassCache::CpUnkMoniker::CheckNotComPlus()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////
// CClassCache ///////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Function:   Init
//
//  Synopsis:   Initialize the ClassCache.
//
//  Arguments:  none
//
//  Returns:    TRUE/FALSE - Init success
//
//  Algorithm:  If the ClassCache has not been initialized, initialize it.
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
BOOL CClassCache::Init()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Init\n"));
    ASSERT_LOCK_NOT_HELD(_mxs);
    STATIC_WRITE_LOCK(lck, _mxs);

    if (!(_dwFlags & fINITIALIZED))
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Init -- Initializing\n"));
        // initilize some hash tables
        _ClassEntries.Initialize(_CEBuckets, &_mxs);
        _DllPathEntries.Initialize(_DPEBuckets, &_mxs);



        // initialize some page tables
        CDllPathEntry::_palloc.Initialize(sizeof(CDllPathEntry), CDllPathEntry::_cNumPerPage,
                                          NULL);
        CClassEntry::_palloc.Initialize(sizeof(CClassEntry), CClassEntry::_cNumPerPage,
                                        NULL);
        CDllClassEntry::_palloc.Initialize(sizeof(CDllClassEntry), CDllClassEntry::_cNumPerPage,
                                           NULL);
        CLSvrClassEntry::_palloc.Initialize(sizeof(CLSvrClassEntry), CLSvrClassEntry::_cNumPerPage,
                                            NULL, CPageAllocator::fCOUNT_ENTRIES);
        CLSvrClassEntry::_cOutstandingObjects = 0;
        CDllAptEntry::_palloc.Initialize(sizeof(CDllAptEntry), CDllAptEntry::_cNumPerPage,
                                         NULL);

        // this must be the last thing we do since the API entry
        // points check it without taking the lock.
        _dwFlags |= fINITIALIZED;
    }
    else
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Init -- Already initialized\n"));
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   Collect
//
//  Synopsis:   Clean up unneeded objects
//
//  Arguments:  cNewObjects - Number of new objects to be created
//                            after this collection.
//
//  Returns:    S_OK or error code
//
//  Algorithm:  for each object in the _objectsForCollection list
//                  check that it still valid for collection
//                  check collection policies
//                  delete if above is ok
//
//  History:    11-Mar-97  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::Collect(ULONG cNewObjects)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Collect\n"));
    ASSERT_LOCK_HELD(_mxs);

    _LastObjectCount += cNewObjects;

    DWORD currTickCount = GetTickCount();

    // handle counter wrap
    if (currTickCount < _LastCollectionTickCount)
    {
        _LastCollectionTickCount = 0;
    }

    if ((_LastObjectCount >= _CollectAtObjectCount) ||
        (currTickCount > (_LastCollectionTickCount + _CollectAtInterval)))
    {
        CCollectable *back = 0;
        CCollectable *curr = _ObjectsForCollection;

        while (curr)
        {
            //  if something attached to this, or locked it,
            //  take it out of the collection list

            if (!curr->NoLongerNeeded())
            {
                curr->RemoveCollectee(back);
                CCollectable *tmp = curr;
                curr = curr->_pNextCollectee;
                // back stays the same
                tmp->_pNextCollectee = CCollectable::NOT_COLLECTED;

            }
            else
            {
                // collect this object if it is ready

                if (curr->CanBeCollected())
                {
                    curr->RemoveCollectee(back);
                    CCollectable *tmp = curr;
                    curr = curr->_pNextCollectee;
                    tmp->Release();
                    // back stays the same
                }
                else
                {
                    back = curr;
                    curr = curr->_pNextCollectee;
                }
            }
        }
        _LastCollectionTickCount = GetTickCount();
        _LastObjectCount = 0;
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetOrLoadClass
//
//  Synopsis:   This is an entry point into the ClassCache.  The code for
//              CoGetClassObject uses this as well as the SCM activation code.
//
//  Arguments:  ap  - activation properties
//
//  Returns:    S_OK or error code
//
//  Algorithm:  Attempt different contexts in order (see below)
//              upon success, release the lock and instantiate the moniker
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::GetOrLoadClass(ACTIVATION_PROPERTIES_PARAM ap)

{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClass ap._dwContext = 0x%x, ap._dwFlags = 0x%x"
                      "ap._rclsid == %I\n",
                      ap._dwContext, ap._dwFlags, &(ap._rclsid)));

    IMiniMoniker *pIM = (IMiniMoniker *)_alloca(max(sizeof(CDllFnPtrMoniker),
                                                    sizeof(CpUnkMoniker)));
    HRESULT hr = E_FAIL;

    ASSERT_LOCK_NOT_HELD(_mxs);
    DWORD dwCEHash = _ClassEntries.Hash(ap._rclsid, ap._partition);

    IComClassInfo* pCI = ap._pCI;

    if (pCI)
    {
        pCI->AddRef();
    }
    else
    {
        // Windows Bug #107960
        // Look up class info without write lock
        // before call to CClassEntry::Create, which is
        // called by GetOrLoadClassByContext_rl below

        hr = GetClassInfoFromClsid(ap._rclsid, &pCI);
        if (FAILED (hr))
        {
            goto Cleanup;
        }  
    }

    {
        STATIC_WRITE_LOCK(lck, _mxs);

        // check the hash
        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClass: dwCEHash = 0x%x\n", dwCEHash));
        CClassEntry *pCE = _ClassEntries.LookupCE(dwCEHash, ap._rclsid, ap._partition);
        ClsCacheDebugOut((DEB_ACTIVATE,
                          "CClassCache::GetOrLoadClass Lookup for clsid %I %s!\n",
                          &(ap._rclsid), pCE ? "SUCCEEDED" : "FAILED"));
        if (pCE)
        {
            pCE->SetLockedInMemory();
        }



        if (ap._dwFlags & ACTIVATION_PROPERTIES::fFOR_SCM)
        {
            hr = GetOrLoadClassByContext_rl(ap._dwContext & CLSCTX_LOCAL_SERVER, ap, pCI, pCE, dwCEHash, pIM);
        }
        else if (ap._dwFlags & ACTIVATION_PROPERTIES::fRELOAD_DARWIN)
        {
            hr = GetOrLoadClassByContext_rl(ap._dwContext & CLSCTX_INPROC_SERVERS, ap, pCI, pCE, dwCEHash, pIM);
        }
        else
        {
            // try an INPROC_SERVER first
            if (ap._dwContext & CLSCTX_INPROC_SERVERS)
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClass -- trying INPROC_SERVERS\n"));
                hr = GetOrLoadClassByContext_rl(ap._dwContext & CLSCTX_INPROC_SERVERS, ap, pCI, pCE, dwCEHash, pIM);
            }

            // that didn't work, so try an INPROC_HANDLER
            if (FAILED(hr) && (ap._dwContext & CLSCTX_INPROC_HANDLERS))
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClass -- trying INPROC_HANDLERS\n"));
                hr = GetOrLoadClassByContext_rl(ap._dwContext & CLSCTX_INPROC_HANDLERS, ap, pCI, pCE, dwCEHash, pIM);
            }

            // that didn't work, so try a LOCAL_SERVER
            if (FAILED(hr) && (ap._dwContext & CLSCTX_LOCAL_SERVER))
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClass -- trying INPROC_LOCAL_SERVER\n"));
                hr = GetOrLoadClassByContext_rl(ap._dwContext & CLSCTX_LOCAL_SERVER, ap, pCI, pCE, dwCEHash, pIM);
            }

            if (pCE)
            {
                ASSERT_LOCK_HELD(_mxs);
                BOOL fLockReleased;
                pCE->ReleaseMemoryLock(&fLockReleased);
                Win4Assert(!fLockReleased);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pIM->BindToObject(ap._riid, (void **) ap._ppUnk);
        pIM->Release();
    }

Cleanup:

    if (pCI)
    {
        pCI->Release();
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::SearchForLoadedClass
//
//  Synopsis:      Searches for classes that require little or no work to
//                 activate.  These being classes that are one of
//                 the following, and not a COM+ class.
//                     * registered using CoRegisterClassObject
//                     * dll already loaded, no switching necessary.
//
//  History:       6-May-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::SearchForLoadedClass(ACTIVATION_PROPERTIES_PARAM ap,
                                          CDllClassEntry **ppDCE)
{
    ClsCacheDebugOut((DEB_TRACE, "CClassCache::SearchForLoadedClass"
                      " IN ap:0x%x, ppDCE:0x%x\n", &ap, ppDCE));

    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }

    HRESULT hr = S_OK;
    *ppDCE = NULL;
    *(ap._ppUnk) = NULL;

    if (ap._dwContext & CLSCTX_INPROC_SERVERS)
    {
        IMiniMoniker *pMM =  (IMiniMoniker *) _alloca(max(sizeof(CDllFnPtrMoniker),
                                                          sizeof(CpUnkMoniker)));

        hr = GetClassObjectActivator(ap._dwContext & CLSCTX_INPROC_SERVERS,
                                     ap, &pMM);
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(pMM->CheckApt()) &&
                SUCCEEDED(pMM->CheckNotComPlus()))
            {
                hr = pMM->BindToObject(ap._riid, (void **) ap._ppUnk);
            }
            else
            {
                hr = pMM->GetDCE(ppDCE);
                Win4Assert(SUCCEEDED(hr));
            }
            pMM->Release();
        }
        else
        {
            // we still return success, so the COM+
            // activation will happen.
            hr = S_OK;
        }
    }


    return hr;

}
//+-------------------------------------------------------------------------
//
//  Function:   GetClassObject
//
//  Synopsis:   This is an entry point into the ClassCache.  The code for
//              the server context activator uses this.
//
//  Arguments:  ap  - activation properties
//
//  Returns:    S_OK or error code
//
//  Algorithm:  Search for a DCE for the class.  It must be present by this time.
//              Just call DllGetClassObject on the DPE in the DCE.
//
//  History:    26-Feb-98   SatishT   Created
//              04-Apr-98   CBiks     Added updated support for Wx86 that was removed
//                                    during the Com+ merge.
//
//--------------------------------------------------------------------------

HRESULT CClassCache::GetClassObject(ACTIVATION_PROPERTIES_PARAM ap)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObject\n"));
    HRESULT hr = E_FAIL;
    ASSERT_LOCK_NOT_HELD(_mxs);
    ASSERT_ONE_CLSCTX(ap._dwContext);
    IMiniMoniker *pIM = (IMiniMoniker *) _alloca(max(sizeof(CDllFnPtrMoniker),
                                                     sizeof(CpUnkMoniker)));

    hr = GetClassObjectActivator(ap._dwContext, ap, &pIM);

    //
    // finally activate the object now that the lock is released
    //

    if (SUCCEEDED(hr))
    {
        hr = pIM->BindToObjectNoSwitch(ap._riid, (void **)ap._ppUnk);
        pIM->Release();
    }


    return hr;

}

//+----------------------------------------------------------------------------
//
//  Member:        CClassCache::GetClassObjectActivator
//
//  Synopsis:      Gets the a cache line for a clsid-context pair, no thread
//                 switching.
//
//  History:       6-May-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT CClassCache::GetClassObjectActivator(DWORD dwContext,
                                             ACTIVATION_PROPERTIES_PARAM ap,
                                             IMiniMoniker **ppIM)

{
    ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetClassObjectActivator IN\n"));


    HRESULT hr = E_FAIL;



    BOOL fLockUpgraded = FALSE;
    LockCookie cookie;
    BOOL fLockReleased;
    ASSERT_LOCK_NOT_HELD(_mxs);
    ASSERT_ONE_CLSCTX(dwContext);

    DWORD dwCEHash = _ClassEntries.Hash(ap._rclsid,
                                        ap._partition);
    CBaseClassEntry *pBCE = NULL;
    
    IComClassInfo* pCI = ap._pCI;
    if (pCI)
    {
        pCI->AddRef();
    }

    
    LOCK_READ(_mxs);

    //
    // Lookup the ClassEntry
    //
    CClassEntry *pCE = _ClassEntries.LookupCE(dwCEHash, 
                                              ap._rclsid,
                                              ap._partition);

    if (!pCE && !pCI)
    {
        // Windows Bug #107960
        // Look up class info without write lock
        // before call to CClassEntry::Create
        
        UNLOCK_READ(_mxs);

        hr = GetClassInfoFromClsid(ap._rclsid, &pCI);
        if (FAILED (hr))
        {
            ClsCacheDebugOut((DEB_ERROR, "CClassCache::GetClassObjectActivator:"
                              " GetClassInfoFromClsid failed hr = 0x%x\n", hr));
            goto Cleanup;
        }

        LOCK_READ(_mxs);

        pCE = _ClassEntries.LookupCE(dwCEHash, 
                                     ap._rclsid,
                                     ap._partition);
    }

    if (!pCE)
    {
        //
        // Load the class
        //

        if (ap._dwFlags & ACTIVATION_PROPERTIES::fDO_NOT_LOAD)
        {
            ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetClassObjectActivator_rl:"
                              " No class in cache, not loading\n"));
            hr = CO_E_SERVER_STOPPING;
            goto epilog;
        }

        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObjectActivator_rl:"
                          " No class in cache, "
                          "will attempt to create CE\n"));

        //
        // Create the new CClassEntry
        //
        LOCK_UPGRADE(_mxs, &cookie, &fLockReleased);
        fLockUpgraded = TRUE;
        
        if (fLockReleased)
        {
            pCE = _ClassEntries.LookupCE(dwCEHash, 
                                         ap._rclsid,
                                         ap._partition);
        }

        if (!pCE && FAILED(hr = CClassEntry::Create(ap._rclsid, dwCEHash, pCI, pCE)))
        {
            ClsCacheDebugOut((DEB_ERROR, "CClassCache::GetClassObjectActivator_rl:"
                              " Create failed hr = 0x%x\n", hr));
            goto epilog;
        }
    }

    Win4Assert(pCE->_dwSig);

    //
    // now we have a valid Class Entry (pCE), check to see if we have
    // tried to activate this clsid previously with this context.  If
    // it has failed before, fail it right away unless it is a Darwin
    // reload.
    //
    //
    //    if ( !(ap._dwFlags & ACTIVATION_PROPERTIES::fRELOAD_DARWIN) &&
    //         !(dwContext  & ~pCE->_dwFailedContexts) )
    //    {
    //        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObjectActivator_rl:"
    //                          " We have already failed this context, exiting,\n"
    //                          "pCE->_dwFailedContexts = 0x%x", pCE->_dwFailedContexts));
    //        hr = E_FAIL;
    //        goto epilog;
    //    }
    //

    //
    // search the class entry for a BCE that meets our criteria,
    // this could come back with either an LSCE or a DCE.
    //
    pCE->SetLockedInMemory();
    fLockReleased = FALSE;
    hr = pCE->SearchBaseClassEntry(dwContext, pBCE,
                                   (ap._dwFlags & ACTIVATION_PROPERTIES::fFOR_SCM),
                                   &fLockReleased);
    if (FAILED(hr))
    {
        if (ap._dwFlags & ACTIVATION_PROPERTIES::fDO_NOT_LOAD)
        {
            ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetClassObjectActivator_rl:"
                              " No class in cache, not loading\n"));
            hr = CO_E_SERVER_STOPPING;
        }
        else if (pCE->IsComplete() &&
                 (dwContext & (CLSCTX_INPROC_SERVERS | CLSCTX_INPROC_HANDLERS)))
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObjectActivator_rl:"
                              " No class in cache, creating DCE\n"));
            //
            // if there is not an existing BCE the only choice is to
            // try and make a DCE.
            //

            CClassCache::CDllClassEntry *pDCE = 0;

            pCE = pCE->CycleToClassEntry();

            if (fLockUpgraded)
            {
                LOCK_DOWNGRADE(_mxs, &cookie);
            }
            UNLOCK_READ(_mxs);

            hr = pCE->CreateDllClassEntry_rl(dwContext, ap, pDCE);

            LOCK_READ(_mxs);
            fLockUpgraded = FALSE;

            // NOTE: At one time, there was an effort to remember the contexts
            //       a creation had failed in.  This was abandoned because we
            //       didn't have a way to flush the "failed" entries.
            if (SUCCEEDED(hr))
            {
                pBCE = pDCE;
                pDCE->Unlock();
            }            
        }
    }

    // if there is a valid base class entry, then we can use it
    // to get the class factory

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassObjectActivator_rl:"
                      " Class %s found or loaded, hr = 0x%x\n",
                      FAILED(hr) ? "NOT " : "", hr));

    if (SUCCEEDED(hr))
    {

        hr = pBCE->GetClassInterface(ppIM);

        ClsCacheDebugOut((HRDBG(hr), "CClassCache::GetClassObjectActivator_rl:"
                          " GetClassInterface %s, "
                          "hr = 0x%x\n", HR2STRING(hr), hr));
    }

    pCE->ReleaseMemoryLock(&fLockReleased); // ok if cache lock releases


    epilog:
    if (fLockUpgraded)
    {
        LOCK_DOWNGRADE(_mxs, &cookie);
    }

    UNLOCK_READ(_mxs);

Cleanup:
    
    if (pCI)
    {
        pCI->Release();
    }

    ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetClassObjectActivator OUT hr:0x%x\n", hr));
    ASSERT_LOCK_NOT_HELD(_mxs);
    return hr;

}

//+-------------------------------------------------------------------------
//
//  Function:   GetOrCreateApartment
//
//  Synopsis:   This is an entry point into the ClassCache.  The code for
//              the process activator uses this.
//
//  Arguments:  ap  - activation properties
//
//  Returns:    S_OK or error code
//
//  Algorithm:  Attempt different contexts in order (see below)
//              upon success, release the lock and return the apartment cookie
//
//  History:    25-Feb-98   SatishT   Created
//              04-Apr-98   CBiks     Fixed bug introduced by the Com+ merge.
//                                    Someone removed the () in the Wx86
//                                    tests.
//
//--------------------------------------------------------------------------

HRESULT CClassCache::GetOrCreateApartment(ACTIVATION_PROPERTIES_PARAM ap,
                                          DLL_INSTANTIATION_PROPERTIES *pdip,
                                          HActivator *phActivator)


{
    ASSERT_ONE_CLSCTX(ap._dwContext);
    Win4Assert(pdip);

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrCreateApartment "
                      "ap._dwContext = 0x%x, ap._dwFlags = 0x%x"
                      "ap._rclsid == %I\n",
                      ap._dwContext, ap._dwFlags, &(ap._rclsid)));
    HRESULT hr;

    hr = GetActivatorFromDllHost(pdip->_dwFlags & DLL_INSTANTIATION_PROPERTIES::fSIXTEEN_BIT,
                                 pdip->_dwThreadingModel,
                                 phActivator);

    return hr;

}



//+-------------------------------------------------------------------------
//
//  Function:   GetOrLoadClassByContext_rl
//
//  Synopsis:   Helper function to GetOrLoadClass.
//
//  Arguments:  dwContext      - [in] context mask
//              ap             - [in] activation properties
//              pCE            - [in] class entry already looked up
//              dwCEHash       - [in] hash code for pCE
//              pIM            - [out] IMiniMoniker Interface out
//
//  Returns:    S_OK or error code
//
//  Algorithm:  create a class entry if needed
//              search the class entry for a matching context
//              if not found and an INPROC is asked for, attempt to load a DLL
//
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::GetOrLoadClassByContext_rl(
                                               DWORD                        dwContext,
                                               ACTIVATION_PROPERTIES_PARAM  ap,
                                               IComClassInfo*               pCI,
                                               CClassEntry*                 pCE,
                                               DWORD                        dwCEHash,
                                               IMiniMoniker               *&pIM
                                               )
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClassByContext_rl:"
                      " dwContext = 0x%x, pCE = 0x%x\n", dwContext, pCE));
    ASSERT_LOCK_HELD(_mxs);

    HRESULT hr = S_OK;
    CBaseClassEntry *pBCE = 0;

    if (!pCE)
    {
        // Load the class

        if (ap._dwFlags & ACTIVATION_PROPERTIES::fDO_NOT_LOAD)
        {
            ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetOrLoadClassByContext_rl:"
                              " No class in cache, not loading\n"));
            return CO_E_SERVER_STOPPING;
        }

        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClassByContext_rl:"
                          " No class in cache, will attempt to create CE\n"));

        // Create the new CClassEntry
        if (FAILED(hr = CClassEntry::Create(ap._rclsid, dwCEHash, pCI, pCE)))
        {
            ClsCacheDebugOut((DEB_ERROR, "CClassCache::GetOrLoadClassByContext_rl:"
                              " Create failed hr = 0x%x\n", hr));
            return hr;
        }
    }

    Win4Assert(pCE->_dwSig);
    if ( !(ap._dwFlags & ACTIVATION_PROPERTIES::fRELOAD_DARWIN) &&
         !(dwContext  & ~pCE->_dwFailedContexts) )
    {
        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClassByContext_rl:"
                          " We have already failed this context, exiting,\n"
                          "pCE->_dwFailedContexts = 0x%x", pCE->_dwFailedContexts));
        return E_FAIL;
    }

    pCE->SetLockedInMemory();


    //
    // Search the class entry for a BCE that meets our criteria, this could
    // come back with either an LSCE or a DCE.
    //
    ASSERT_WRITE_LOCK_HELD(_mxs);
    BOOL fLockReleased = FALSE;
    hr = pCE->SearchBaseClassEntry(
                                  dwContext,
                                  pBCE,
                                  ap._dwFlags,
                                  &fLockReleased);
    Win4Assert(!fLockReleased);
    if (FAILED(hr))
    {
        if (ap._dwFlags & ACTIVATION_PROPERTIES::fDO_NOT_LOAD)
        {
            ClsCacheDebugOut((DEB_TRACE, "CClassCache::GetOrLoadClassByContext_rl:"
                              " No class in cache, not loading\n"));
            hr = CO_E_SERVER_STOPPING;
        }
        else if (pCE->IsComplete()
                 && (dwContext
                     & (CLSCTX_INPROC_SERVERS | CLSCTX_INPROC_HANDLERS)))
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClassByContext_rl:"
                              " No class in cache, creating DCE\n"));

            //
            // If there is not an existing BCE the only choice is to
            // try and make a DCE.
            //

            CClassCache::CDllClassEntry *pDCE = 0;

            pCE = pCE->CycleToClassEntry();

            UNLOCK(_mxs);
            hr = pCE->CreateDllClassEntry_rl(dwContext, ap, pDCE);
            LOCK(_mxs);

            if (FAILED(hr))
            {
                pCE->_dwFailedContexts |= dwContext;
            }

            pBCE = pDCE;
        }
    }

    //
    // if there is a valid base class entry, then we can use it
    // to get the class interface.
    //

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetOrLoadClassByContext_rl:"
                      " Class %s found or loaded, hr = 0x%x\n",
                      FAILED(hr) ? "NOT " : "", hr));

    if (SUCCEEDED(hr))
    {
        hr = pBCE->GetClassInterface(&pIM);
        ClsCacheDebugOut((HRDBG(hr), "CClassCache::GetOrLoadClassByContext_rl:"
                          " GetClassInterface %s, hr = 0x%x, pIM = 0x%x\n",
                          HR2STRING(hr), hr, pIM));
    }

    pCE->ReleaseMemoryLock(&fLockReleased);
    Win4Assert(!fLockReleased);

    return hr;
}







//+-------------------------------------------------------------------------
//
//  Function:   SearchDPEHash
//
//  Synopsis:   Lookup an entry in _DllPathEntries.
//
//  Arguments:  pszDllPath     - [in] the path to look up
//              pDPE           - [out] the entry if found
//              dwHashValue    - [in/optional] Hash value, -1 if not present
//
//  Returns:    S_OK   -  found
//              E_FAIL -  not found
//
//  Algorithm:  convert using the DSA Wrapper
//              lookup in the hash
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::SearchDPEHash(LPWSTR pszDllPath, CDllPathEntry *& pDPE, DWORD dwHashValue, DWORD dwDIPFlags)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SearchDPEHash: pszDllPath = \"" TSZFMT"\", dwHashValue 0x%x, dwDIPFlags 0x%x\n",
                      pszDllPath, dwHashValue, dwDIPFlags));
    ASSERT_LOCK_HELD(CClassCache::_mxs);
    HRESULT hr;



    SDPEHashKey lookupKey;
    lookupKey._pstr = pszDllPath;
    lookupKey._dwDIPFlags = dwDIPFlags;

    // search for a DPE in the DllPathEntries hash
    pDPE = (CDllPathEntry *)_DllPathEntries.Lookup(dwHashValue, &lookupKey);

    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SearchDPEHash: pszDllPath(\"" TSZFMT "\") %s!! 0x%x\n",
                      pszDllPath, pDPE ? "FOUND" : "NOT FOUND\n", pDPE));

    return(pDPE ? S_OK : E_FAIL);
}

//+-------------------------------------------------------------------------
//
//  Function:   RegisterServer
//
//  Synopsis:   Inserts a server into the cache for later use
//
//  Arguments:  rclsid    -   [in] the clsid of the server
//              punk      -   [in] the server
//              dwContext -   [in] context
//              dwRegFlags- [in] registration flags
//              lpdwRegister  - [out] cookie for identifying this server later
//
//  Returns:    S_OK   -  operation succeeded
//              PROPOGATE:CClassEntry::Create
//              PROPOGATE:CClassEntry::CreateLSvrClassEntry_rl
//
//  Algorithm:  Get or create the class entry
//              Create a CLSvrClassEntry
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::RegisterServer(REFCLSID rclsid, IUnknown *punk,
                                    DWORD dwContext, DWORD dwRegFlags,
                                    LPDWORD lpdwRegister)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::RegisterServer:punk = 0x%x, dwContext = 0x%x, dwRegFlags = 0x%x\n",
                      punk, dwContext, dwRegFlags));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);


    HRESULT hr = S_OK;
    IComClassInfo* pCI = NULL;
 
    punk->AddRef();

    // LocalServers only exist in the base partition... (if not, we'll have to fetch the partition
    // from the context.)
    DWORD dwCEHash = _ClassEntries.Hash(rclsid, GUID_DefaultAppPartition);

    {
        LOCK_WRITE(_mxs);


        // lookup class

        // check the hash
        CClassEntry *pCE = _ClassEntries.LookupCE(dwCEHash, rclsid, GUID_DefaultAppPartition);

        if (!pCE)
        {
            // Windows Bug #107960
            // Look up class info without write lock
            // before call to CClassEntry::Create

            UNLOCK_WRITE(_mxs);
            
            hr = GetClassInfoFromClsid (rclsid, &pCI);
            if (FAILED (hr))
            {
                goto Cleanup;
            }

            LOCK_WRITE(_mxs);

            const GUID *pguidPartition = GetPartitionIDForClassInfo(pCI);            
            pCE = _ClassEntries.LookupCE(dwCEHash, rclsid, *pguidPartition);
        }
    
        // create if not found
        if (!pCE)
        {
            // Create a new CClassEntry. Don't get the TreatAs yet.
            hr = CClassEntry::CreateIncomplete(rclsid, dwCEHash, pCI, pCE, 0);
        }

        if (SUCCEEDED(hr))
        {
            // create LSvrClassEntry
            pCE->SetLockedInMemory();
            hr = pCE->CreateLSvrClassEntry_rl(punk, dwContext, dwRegFlags, lpdwRegister);
            BOOL fLockReleased;
            pCE->ReleaseMemoryLock(&fLockReleased);
            Win4Assert(!fLockReleased);
        }

        UNLOCK_WRITE(_mxs);
    }

Cleanup:
    
    if (FAILED(hr))
    {
        punk->Release();
    }

    if (pCI)
    {
        pCI->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   Revoke
//
//  Synopsis:   Removes a previouly registered server from the cache
//
//  Arguments:  dwRegister  - [in] Cookie representing the server to revoke
//
//  Returns:    S_OK   -  operation succeeded
//              PROPOGATE:CLSvrClassEntry::SafeCastFromDWORD
//
//  Algorithm:  get the CLSvrClassEntry object by safe-casting the DWORD
//              check for correct apartment, and recursive revokes
//              release the object
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::Revoke(DWORD dwRegister)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Revoke: dwRegister = 0x%x\n", dwRegister));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    HRESULT hr;

    CLSvrClassEntry::CFinishObject fo;
    {
        // Single thread access to the table
        STATIC_WRITE_LOCK (lck, _mxs);
        CLSvrClassEntry *pLSCE = 0;

        if (FAILED(hr = CLSvrClassEntry::SafeCastFromDWORD(dwRegister, pLSCE)))
        {
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Revoke: SafeCastFromDWORD FAILED dwRegister = 0x%x, hr = 0x%x\n",
                              dwRegister, hr));
            return hr;
        }

        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Revoke: SafeCastFromDWORD SUCCESS! pLSCE->_dwFlags = 0x%x\n",
                          pLSCE->_dwFlags));




        // Make sure apartment id's match

        if (GetCurrentApartmentId() != pLSCE->_hApt)
        {
            ClsCacheDebugOut((DEB_ERROR,
                              "CClassCache::Revoke %x:  Wrong thread attempting to revoke\n\n", dwRegister));
            return RPC_E_WRONG_THREAD;
        }


        // Make sure some other thread is not already using this object
        if (pLSCE->_cUsing > 0)
        {
            // mark the object as pending for revoke, the thread
            // which is using this object will have to revoke it.
            // we zero the context, so it cannot be found.
            pLSCE->_dwContext = 0;
            pLSCE->_dwFlags |= CLSvrClassEntry::fREVOKE_PENDING;
            return S_OK;
        }
        else
        {            
            ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::Revoke: Releasing cache line for dwRegister = 0x%x, pLSCE = 0x%x\n",
                              dwRegister, pLSCE));
            
            pLSCE->Release(&fo);
        }
    }
    fo.Finish();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassCache::GetApartmentChain
//
//  Synopsis:   Select the correct apartment chain based on the current
//              apartment
//
//  Arguments:  none
//
//  Returns:    apartment chain
//
//  Algorithm:  if in the MTA get from global, else use TLS
//
//  History:    18-Nov-96 MattSmit Created
//
//+-------------------------------------------------------------------------
CClassCache::CLSvrClassEntry *CClassCache::GetApartmentChain(BOOL fCreate)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "GetApartmentChain\n"));
    ASSERT_LOCK_HELD(CClassCache::_mxs);

    APTKIND AptKind = GetCurrentApartmentKind();
    if (AptKind == APTKIND_MULTITHREADED)
    {
        if (!CClassCache::_MTALSvrsFront && fCreate)
        {
            CClassCache::_MTALSvrsFront =
            new CClassCache::CLSvrClassEntry(CClassCache::CLSvrClassEntry::DUMMY_SIG, 0, 0, 0, 0);
        }
        return CClassCache::_MTALSvrsFront;
    }
    else if (AptKind == APTKIND_NEUTRALTHREADED)
    {
        if (!CClassCache::_NTALSvrsFront && fCreate)
        {
            CClassCache::_NTALSvrsFront =
            new CClassCache::CLSvrClassEntry(
                                            CClassCache::CLSvrClassEntry::DUMMY_SIG, 0, 0, 0, 0);
        }
        return CClassCache::_NTALSvrsFront;
    }
    else
    {
        COleTls tls;
        if (!tls->pSTALSvrsFront && fCreate)
        {
            tls->pSTALSvrsFront =
            new CClassCache::CLSvrClassEntry(CClassCache::CLSvrClassEntry::DUMMY_SIG, 0, 0, 0, 0);
        }

        return(CLSvrClassEntry *)tls->pSTALSvrsFront;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   FreeUnused
//
//  Synopsis:   Free all Dlls which are no longer in use
//
//  Arguments:  dwUnloadDelay - [in] number of milliseconds to age a unused DLL
//
//  Returns:    S_OK   -  operation succeeded
//
//  Algorithm:  For each Dll
//                if the dll says it can unload
//                   release this apartment
//                   if the dll is no longer needed release it
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::FreeUnused(DWORD dwUnloadDelay)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::FreeUnused\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    CFinishComposite fc;
    CFinishComposite::node *p;
    BOOL fGotOne = FALSE;

    {
        STATIC_WRITE_LOCK(lck, _mxs);

        HAPT hCurrApt = GetCurrentApartmentId();
        HAPT hNeutralApt = NTATID;

        for (int i = 0; i < _cDPEBuckets; i++)
        {

            BOOL fUsedFO = 0;
            CDllPathEntry::CFinishObject *pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();


            CDllPathEntry * pDPE, * pDPENext;
            FOREACH_SAFE(pDPE, ((CDllPathEntry *) _DPEBuckets[i].pNext), pDPENext, _pNext)
            {
                HRESULT hr = pDPE->CanUnload_rl(dwUnloadDelay);

                // CanUnload_rl guarantees pDPE won't go away, but the
                // next one might, so reset it
                pDPENext = pDPE->_pNext;

                if (hr == S_OK)
                {
                    // The dll says its ok to unload.  This is good
                    // for this apartment and the NA, so we will take either
                    // entry off this DPE

                    CDllAptEntry *pDAE, *pDAENext;
                    FOREACH_SAFE(pDAE, pDPE->_pAptEntryFront, pDAENext, _pNext)
                    {
                        if ( (pDAE->_hApt == hCurrApt) ||
                             (pDAE->_hApt == hNeutralApt) )
                        {
                            // release the apartment
                            hr = pDAE->Release(pFO, fUsedFO);
                            Win4Assert(SUCCEEDED(hr));
                            // if the release used the finish object,
                            // allocate another
                            if (fUsedFO)
                            {
                                STACK_FC_ADD(fc, p, pFO);
                                fUsedFO = 0;
                                pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();

                                fGotOne = TRUE;
                            }
                        }
                    }
                    if (pDPE->NoLongerNeeded())
                    {
                        // the Dll is no longer needed, so we free it
                        hr = pDPE->Release(pFO);
                        Win4Assert(SUCCEEDED(hr));
                        STACK_FC_ADD(fc, p, pFO);
                        pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();

                        fGotOne = TRUE;
                    }
                }

            }
            // we "leak" one finish object, but it is on the stack,
            // and there is no dtor.
        }
    }
    if (fGotOne)
    {
        // Unregister any RPC interfaces that might be using proxy/stub code in 
        // the DLLs we are about to unload.
        UnregisterUnusedInterfaces();
    }
    fc.Finish();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   CleanUpDllsForApartment
//
//  Synopsis:   Cleans up all references this apartment hold on a dll
//
//  Arguments:  none
//
//  Returns:    S_OK   -  operation succeeded
//
//  Algorithm:  For each Dll
//                 find the apartment entry for this apt and release it
//                 if the dll says its ok, and it is no longer needed release the dll
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::CleanUpDllsForApartment(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpDllsForApartment Apt = 0x%x\n", GetCurrentApartmentId()));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    
    HRESULT hr;
    CFinishComposite fc;
    CFinishComposite::node *p;
    BOOL fGotOne = FALSE;
    
    {
        STATIC_WRITE_LOCK(lck, _mxs);
        
        HAPT hCurrApt = GetCurrentApartmentId();
        
        for (int i = 0; i < _cDPEBuckets; i++)
        {
            CDllPathEntry * pDPE, * pDPENext;
            FOREACH_SAFE(pDPE, ((CDllPathEntry *) _DPEBuckets[i].pNext), pDPENext, _pNext)
            {
                ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpDllsForApartment - "
                                  "Cleaning up apt entries for pDPE = 0x%x\n", pDPE));
                
                CDllAptEntry *pDAE, *pDAENext;
                
                BOOL fUsedFO = 0;
                BOOL fInThisApartment = FALSE;
                
                CDllPathEntry::CFinishObject *pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();
                
                FOREACH_SAFE(pDAE, pDPE->_pAptEntryFront, pDAENext, _pNext)
                {                    
                    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpDllsForApartment - "
                                      "Cleaning up apt entries pDAE = 0x%x ... testing\n", pDAE));
                    if (pDAE->_hApt == hCurrApt)
                    {
                        ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpDllsForApartment - "
                                          "Releaseing apt entry - pDAE = pDAE = 0x%x\n", pDAE));
                        hr = pDAE->Release(pFO, fUsedFO);
                        Win4Assert(SUCCEEDED(hr));
                        if (fUsedFO)
                        {
                            STACK_FC_ADD(fc, p, pFO);
                            fUsedFO = 0;
                            pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();

                            fGotOne = TRUE;
                        }
                        
                        fInThisApartment = TRUE;
                    }
                }
                
                if (pDPE->NoLongerNeeded() && (fInThisApartment))
                {
                    hr = S_OK;
                    if (!IsWOWProcess()) 
                    {
                        hr = pDPE->CanUnload_rl(INFINITE);
                    }
                    
                    // CanUnload_rl guarantees pDPE won't go away, but the
                    // next one might, so reset it
                    pDPENext = pDPE->_pNext;
                    
                    if (hr == S_OK) 
                    {
                        // the Dll is no longer needed, so we free it
                        hr = pDPE->Release(pFO);
                        Win4Assert(SUCCEEDED(hr));
                        STACK_FC_ADD(fc, p, pFO);
                        pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();
                        
                        fGotOne = TRUE;
                    }
                }
                
                // we "leak" one finish object, but it is on the stack,
                // and there is no dtor.
            }
        }
    }
    if (fGotOne)
    {
        // Unregister any RPC interfaces that might be using proxy/stub code in 
        // the DLLs we are about to unload.
        UnregisterUnusedInterfaces();
    }
    fc.Finish();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   CleanUpLocalServersForApartment
//
//  Synopsis:   Cleans up all lsvrs held in this apartment
//
//  Arguments:  none
//
//  Returns:    S_OK   -  operation succeeded
//
//  Algorithm:  For each lsvr in this apt
//                  release it
//              clean up apt chain in tls
//
//  History:    09-Sep-96  MattSmit   Created
//              13-Feb-98  Johnstra   Made NTA aware
//
//--------------------------------------------------------------------------
HRESULT CClassCache::CleanUpLocalServersForApartment(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpLocalServersForApartment\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    CFinishComposite fc;
    CFinishComposite::node *p;

    {
        STATIC_WRITE_LOCK(lck, _mxs);

        CLSvrClassEntry *pLSCEChain, *pLSCE, *pLSCENext;


        pLSCEChain = GetApartmentChain(FALSE);
        if (pLSCEChain == 0)
        {
            return S_OK;
        }

        FOREACH_SAFE(pLSCE, pLSCEChain->_pNextLSvr, pLSCENext, _pNextLSvr)
        {
            CLSvrClassEntry::CFinishObject *pFO = STACK_ALLOCATE_LSVRCLASSENTRY_FINISHOBJECT();
            pLSCE->Release(pFO);
            STACK_FC_ADD(fc, p, pFO);
        }


        COleTls tls;
        APTKIND AptKind = GetCurrentApartmentKind(tls);
        if (AptKind == APTKIND_NEUTRALTHREADED && _NTALSvrsFront)
        {
            delete (CLSvrClassEntry *) _NTALSvrsFront;
            _NTALSvrsFront = 0;
        }
        else if ((AptKind == APTKIND_APARTMENTTHREADED) && tls->pSTALSvrsFront)
        {
            delete (CLSvrClassEntry *) tls->pSTALSvrsFront;
            tls->pSTALSvrsFront = 0;
        }
        else if (_MTALSvrsFront)
        {
            delete (CLSvrClassEntry *) _MTALSvrsFront;
            _MTALSvrsFront = 0;
        }
    }

    return fc.Finish();
}

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseCatalogObjects
//
//  Synopsis:   Release all ClassInfo objects held by the dll cache
//
//  Arguments:  none
//
//  Returns:    S_OK   -  operation succeeded
//
//  History:    11-Jan-99  MattSmit   Created
//
//--------------------------------------------------------------------------
void CClassCache::ReleaseCatalogObjects(void)
{
#if DBG == 1
    const ULONG cMaxCI = 2;
#else
    const ULONG cMaxCI = 10;
#endif
    struct STmpCI
    {
        IComClassInfo  *arCI[cMaxCI];
        STmpCI         *pNext;
    };
    STmpCI   *pCI2Rel     = NULL;
    STmpCI   *pCI2RelHead = NULL;
    ULONG cCI = 0;
    LOCK(_mxs);
    for (ULONG k = 0; k < _cCEBuckets; k++)
    {
        SHashChain *pHN;
        FOREACH(pHN, _CEBuckets[k].pNext, pNext)
        {
            CClassEntry *pCE = CClassEntry::SafeCastFromHashNode((SMultiGUIDHashNode *) pHN);
            if (pCE->_pCI)
            {
                ULONG ndx = cCI % cMaxCI;
                if (ndx == 0)
                {
                    // allocate more memory
                    STmpCI *tmp = (STmpCI *) _alloca(sizeof(STmpCI));
                    tmp->pNext = NULL;
                    if (pCI2Rel)
                    {
                        pCI2Rel->pNext = tmp;
                        Win4Assert(pCI2RelHead);
                    }
                    else
                    {
                        Win4Assert(!pCI2RelHead);
                        pCI2RelHead = tmp;
                    }
                    pCI2Rel = tmp;
                }
                pCI2Rel->arCI[ndx] = pCE->_pCI;
                pCE->_pCI = NULL;
                cCI++;
            }
        }
    }
    UNLOCK(_mxs);

    pCI2Rel = pCI2RelHead;
    for (k = 0; k < cCI; k++)
    {
        ULONG ndx = k % cMaxCI;
        pCI2Rel->arCI[ndx]->Release();

        if (ndx == (cMaxCI-1))
        {
            pCI2Rel = pCI2Rel->pNext;
        }
        Win4Assert(k+1 >= cCI || pCI2Rel);
    }
}
//+-------------------------------------------------------------------------
//
//  Function:   CleanUpDllsForProcess
//
//  Synopsis:   Cleans up all lsvrs held in this apartment
//
//  Arguments:  none
//
//  Returns:    S_OK   -  operation succeeded
//
//  Algorithm:  For each Dll
//                release all the apt entries
//                release the dll
//              Cleanup the page tables
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::CleanUpDllsForProcess(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::CleanUpDllsForProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    CFinishComposite fc;
    CFinishComposite::node *p;

    {
        STATIC_WRITE_LOCK(lck, _mxs); // do we need this?
        HAPT hCurrApt = GetCurrentApartmentId();

        for (int i = 0; i < _cDPEBuckets; i++)
        {
            CDllPathEntry * pDPE, * pDPENext;


            FOREACH_SAFE(pDPE, ((CDllPathEntry *) _DPEBuckets[i].pNext), pDPENext, _pNext)
            {
                CDllAptEntry *pDAE, *pDAENext;

                BOOL fUsedFO = FALSE;
                CDllPathEntry::CFinishObject *pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();

                FOREACH_SAFE(pDAE, pDPE->_pAptEntryFront, pDAENext, _pNext)
                {

                    HRESULT hr;
                    hr = pDAE->Release(pFO, fUsedFO);
                    Win4Assert(SUCCEEDED(hr));
                    if (fUsedFO)
                    {
                        STACK_FC_ADD(fc, p, pFO);
                        fUsedFO = 0;
                        pFO = STACK_ALLOCATE_DLLPATHENTRY_FINISHOBJECT();
                    }

                }

                HRESULT hr;

                hr = pDPE->Release(pFO);
                Win4Assert(SUCCEEDED(hr));
                STACK_FC_ADD(fc, p, pFO);
            }
        }

        // reset the CEBuckets because there may be some
        // CClassEntry objects hanging around from calls
        // to CCGetTreatAs
        for (int iBucket = 0; iBucket < _cCEBuckets; iBucket++)
        {
            // NOTE:: the destructor does not run.  this is ok for now, because
            // we are going to blow away the memory anyway.

            _CEBuckets[iBucket].pNext =  &(_CEBuckets[iBucket]);
            _CEBuckets[iBucket].pPrev =  &(_CEBuckets[iBucket]) ;

        }

        // reset collection information

        _LastObjectCount = 0;
        _LastCollectionTickCount = 0;
        _ObjectsForCollection = 0;



        CDllPathEntry::_palloc.Cleanup();
        CClassEntry::_palloc.Cleanup();
        CDllClassEntry::_palloc.Cleanup();
        CLSvrClassEntry::_palloc.Cleanup();
        CLSvrClassEntry::_cOutstandingObjects = 0;
        CDllAptEntry::_palloc.Cleanup();
    }

    fc.Finish();

    _dwFlags &= ~fINITIALIZED;

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   AddRefServerProcess
//
//  Synopsis:   Addrefs the process one
//
//  Arguments:  none
//
//  Returns:    number of references
//
//  Algorithm:  Increment _cRefsServerProcess
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
ULONG CClassCache::AddRefServerProcess(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::AddRefServerProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    STATIC_WRITE_LOCK(lck,_mxs);
    return ++_cRefsServerProcess;

}

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseServerProcess
//
//  Synopsis:   Removes a reference from the process
//
//  Arguments:  none
//
//  Returns:    number of references
//
//  Algorithm:  Decrement _cRefsServerProcess
//              if 0 suspend all process objects
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
ULONG CClassCache::ReleaseServerProcess(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::ReleaseServerProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    STATIC_WRITE_LOCK(lck,_mxs);

    ULONG cRefs = --_cRefsServerProcess;
    if (cRefs == 0)
    {
        CClassCache::_dwFlags |= fSHUTTINGDOWN;
        HRESULT hr = SuspendProcessClassObjectsHelp();
        Win4Assert(hr == S_OK);
    }
    return cRefs;
}
//+-------------------------------------------------------------------------
//
//  Function:   LockServerForActivation
//
//  Arguments:  none
//
//  Algorithm:  Increments _cRefsServerProcess
//
//  History:    06-Oct-98  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::LockServerForActivation(void)
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    STATIC_WRITE_LOCK(lck, _mxs);

    if (CClassCache::_dwFlags & fSHUTTINGDOWN)
    {
        return CO_E_SERVER_STOPPING;
    }
    else
    {
        ++_cRefsServerProcess;
        return S_OK;
    }
}
//+-------------------------------------------------------------------------
//
//  Function:   UnlockServerForActivation
//
//  Arguments:  none
//
//  Algorithm:  Decrements _cRefsServerProcess
//
//  History:    06-Oct-98  MattSmit   Created
//
//--------------------------------------------------------------------------
void CClassCache::UnlockServerForActivation(void)
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    STATIC_WRITE_LOCK(lck, _mxs);

    --_cRefsServerProcess;
}



//+-------------------------------------------------------------------------
//
//  Function:   SuspendProcessClassObjects
//
//  Synopsis:   Mark all registered objecst suspended
//
//  Arguments:  none
//
//  Returns:    S_OK    - operation succeeded
//
//  Algorithm:  take lock and call helper fn
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::SuspendProcessClassObjects(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SuspendProcessClassObjects\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    STATIC_WRITE_LOCK(lck, _mxs);

    return SuspendProcessClassObjectsHelp();
}

//+-------------------------------------------------------------------------
//
//  Function:   SuspendProcessClassObjectsHelp
//
//  Synopsis:   Mark all registered objecst suspended
//
//  Arguments:  none
//
//  Returns:    S_OK    - operation succeeded
//
//  Algorithm:  foreach CLSvrClassEntry
//                  mark it suspended
//
//  History:    09-Sep-96  MattSmit   Created
//
//--------------------------------------------------------------------------
HRESULT CClassCache::SuspendProcessClassObjectsHelp(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SuspendProcessClassObjectsHelp\n"));
    ASSERT_LOCK_HELD(_mxs);

    // walk the list of class entries, and for any that are registered as
    // local servers, mark them as suspended.

    for (int k = 0; k < _cCEBuckets; k++)
    {
        SHashChain *pHN;
        FOREACH(pHN, _CEBuckets[k].pNext, pNext)
        {
            CClassEntry *pCE = CClassEntry::SafeCastFromHashNode((SMultiGUIDHashNode *) pHN);

            CBaseClassEntry * pBCE;
            FOREACH(pBCE, pCE->_pBCEListFront, _pNext)
            {
                if (pBCE->_dwContext & CLSCTX_LOCAL_SERVER)
                {
                    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SuspendProcessClassObjectsHelp - suspending"
                                      " pBCE = 0x%x, pBCE->_dwContext = 0x%x, pBCE->_dwSig = %s\n",
                                      pBCE, pBCE->_dwContext, &(pBCE->_dwSig)));

                    Win4Assert(pBCE->_dwSig == CLSvrClassEntry::SIG);
                    ((CLSvrClassEntry *) pBCE)->_dwRegFlags |= REGCLS_SUSPENDED;
                }
            }

        }
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   ResumeProcessClassObjects
//
//  Synopsis:   Resume all registered objects
//
//  Arguments:  none
//
//  Returns:    S_OK    - operation succeeded
//              PROPOGATE - gResolver.NotifyStarted
//
//  Algorithm:  foreach suspended CLSvrClassEntry
//                 remove suspended flag
//                 put in structure to notify SCM
//              notify SCM
//              fill in AT_STORAGE and SCM registration
//
//  History:    09-Sep-96  MattSmit   Created
//
//+-------------------------------------------------------------------------
HRESULT CClassCache::ResumeProcessClassObjects(void)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::ResumeProcessClassObjects\n\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    CFinishComposite fc;
    CFinishComposite::node *p;

    HRESULT hr = S_OK;
    {
        STATIC_WRITE_LOCK(lck,_mxs);

        const ULONG    cLSCEInUse = CLSvrClassEntry::_cOutstandingObjects;

        if (cLSCEInUse == 0)
        {
            return S_OK;
        }

        // allocate a block of memory on the stack, large enough to hold the
        // maximum number of entries we may have to register with the SCM.

        ULONG          cbAlloc = sizeof(RegInput) +
                                 ((sizeof(RegInputEntry) + sizeof(CLSvrClassEntry *))*
                                  cLSCEInUse);

        RegInput         *pRegIn  = (RegInput*) _alloca(cbAlloc);
        RegInputEntry    *pRegEnt = &pRegIn->rginent[0];
        CLSvrClassEntry **pRegIndex = (CLSvrClassEntry **)(&pRegIn->rginent[cLSCEInUse]);
        ULONG             cToReg  = 0;


        // walk the list of class entries, and for any that are registered as
        // local servers and marked suspended, mark them as available and
        // notify the SCM about them.
        for (int k = 0; k < _cCEBuckets; k++)
        {
            SHashChain *pHN;
            FOREACH(pHN, _CEBuckets[k].pNext, pNext)
            {
                CClassEntry *pCE = CClassEntry::SafeCastFromHashNode((SMultiGUIDHashNode *) pHN);

                CBaseClassEntry * pBCE;
                FOREACH(pBCE, pCE->_pBCEListFront, _pNext)
                {
                    if (pBCE->_dwContext & CLSCTX_LOCAL_SERVER)
                    {
                        Win4Assert(pBCE->_dwSig == CLSvrClassEntry::SIG);
                        CLSvrClassEntry *pLSCE = (CLSvrClassEntry *)pBCE;
                        if (pLSCE->_dwRegFlags & REGCLS_SUSPENDED)
                        {
                            // turn off the suspended flag for this clsid.
                            pLSCE->_dwRegFlags &= ~REGCLS_SUSPENDED;

                            if (pLSCE->_dwScmReg == CLSvrClassEntry::NO_SCM_REG)
                            {
                                Win4Assert(pLSCE->_pObjServer != NULL);

                                // add to the list to tell the SCM about
                                pRegEnt->clsid    = pLSCE->_pClassEntry->GetCLSID();
                                pRegEnt->dwFlags  = pLSCE->_dwRegFlags;
                                pRegEnt->oxid     = pLSCE->_pObjServer->GetOXID();
                                pRegEnt->ipid     = pLSCE->_pObjServer->GetIPID();
                                pRegEnt++;

                                *pRegIndex = pLSCE;     // remember the pointer to this entry
                                pRegIndex++;            // so we can update it below.

                                pLSCE->_cUsing++;

                                cToReg++;
                            }
                        }
                    }
                }
            }
        }

        // reset the pointers we mucked with in the loop above, and set the
        // total number of entries we are passing to the SCM.

        pRegIn->dwSize = cToReg;
        pRegEnt        = &pRegIn->rginent[0];
        pRegIndex      = (CLSvrClassEntry **)(&pRegIn->rginent[cLSCEInUse]);


        // call the SCM to register all the classes and get back all the
        // registration keys.

        RegOutput *pRegOut = NULL;

        UNLOCK(_mxs);
        hr = gResolver.NotifyStarted(pRegIn, &pRegOut);
        LOCK(_mxs);

        if (SUCCEEDED(hr))
        {
            Win4Assert((pRegOut->dwSize == pRegIn->dwSize) &&
                       "CRpcResolver::NotifyStarted Invalid regout");

            // update the entries with the registration keys from the SCM.
            for (ULONG i = 0; i < cToReg; i++)
            {
                CLSvrClassEntry *pLSCE = *pRegIndex;
                pRegIndex++;

                pLSCE->_dwScmReg   = pRegOut->RegKeys[i];

                if ((--pLSCE->_cUsing  == 0 ) && (pLSCE->_dwFlags & CLSvrClassEntry::fREVOKE_PENDING))
                {
                    CLSvrClassEntry::CFinishObject *pFO = STACK_ALLOCATE_LSVRCLASSENTRY_FINISHOBJECT();
                    pLSCE->Release(pFO);
                    STACK_FC_ADD(fc, p, pFO);
                }
            }

            // Free memory from RPC
            MIDL_user_free(pRegOut);
        }
    }

    fc.Finish();

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetClassInformationForDde
//
//  Synopsis:   Get info for dde routines
//
//  Arguments:  clsid   - [in] class id queried
//              lpDdeInfo - [out] DDECLASSINFO object to fill out
//
//  Returns:    TRUE   -  operation succeeded
//              FALSE  -  operation failed
//
//  Algorithm:  find an lsvr with this clsid in the cache
//              use GetDDEInfo to fill out the information
//
//  History:    09-Sep-96  MattSmit   Created
//
//+-------------------------------------------------------------------------
BOOL CClassCache::GetClassInformationForDde(REFCLSID clsid, LPDDECLASSINFO lpDdeInfo)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassInformationForDde: lpDdeInfo = 0x%x\n",
                      lpDdeInfo));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    IMiniMoniker *pIM = (IMiniMoniker *) _alloca(max(sizeof(CDllFnPtrMoniker),
                                                     sizeof(CpUnkMoniker)));

    // REVIEW: Should we be getting the partition ID out of the context?  I don't think so.
    HRESULT hr;
    DWORD dwCEHash = _ClassEntries.Hash(clsid, GUID_DefaultAppPartition);

    {
        STATIC_WRITE_LOCK(lck, _mxs);

        // check the hash
        CClassEntry *pCE = _ClassEntries.LookupCE(dwCEHash, clsid, GUID_DefaultAppPartition);

        if (!pCE)
        {
            return FALSE;
        }

        CBaseClassEntry *pBCE;
        ASSERT_WRITE_LOCK_HELD(_mxs);
        BOOL fLockReleased = FALSE;
        hr = pCE->SearchBaseClassEntry(CLSCTX_LOCAL_SERVER, pBCE, ACTIVATION_PROPERTIES::fFOR_SCM, &fLockReleased);
        Win4Assert(!fLockReleased);

        if (FAILED(hr))
        {
            return FALSE;
        }

        Win4Assert(pBCE->_dwSig == CLSvrClassEntry::SIG);
        CLSvrClassEntry *pLSCE = (CLSvrClassEntry *) pBCE;

        hr = pLSCE->GetDDEInfo(lpDdeInfo, &pIM);


    }

    if (SUCCEEDED(hr) && pIM)
    {
        hr = pIM->BindToObjectNoSwitch(IID_IClassFactory, (void **) &lpDdeInfo->punk);
        pIM->Release();
    }
    else
    {
        lpDdeInfo->punk = 0;
    }

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetClassInformationFromKey
//
//  Synopsis:   Get info for dde routines
//
//  Arguments:  lpDdeInfo - [in/out] DDECLASSINFO object to fill out,
//                            also contains cookie for the server
//
//  Returns:    TRUE   -  operation succeeded
//              FALSE  -  operation failed
//
//  Algorithm:  find an lsvr by safe casting the cookie
//              use GetDDEInfo to fill out the information
//
//  History:    09-Sep-96  MattSmit   Created
//
//+-------------------------------------------------------------------------
BOOL CClassCache::GetClassInformationFromKey(LPDDECLASSINFO lpDdeInfo)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::GetClassInformationFromKey: lpDdeInfo = 0x%x\n",
                      lpDdeInfo));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);


    IMiniMoniker *pIM = (IMiniMoniker *) _alloca(max(sizeof(CDllFnPtrMoniker),
                                                     sizeof(CpUnkMoniker)));
    HRESULT hr;

    {
        STATIC_WRITE_LOCK(lck, _mxs);

        CLSvrClassEntry *pLSCE;


        if (FAILED(hr = CLSvrClassEntry::SafeCastFromDWORD(lpDdeInfo->dwRegistrationKey, pLSCE)))
        {
            return FALSE;
        }

        hr = pLSCE->GetDDEInfo(lpDdeInfo, &pIM);


    }

    if (SUCCEEDED(hr) && pIM)
    {
        hr = pIM->BindToObjectNoSwitch(IID_IClassFactory, (void **) &lpDdeInfo->punk);
        pIM->Release();
    }
    else
    {
        lpDdeInfo->punk = 0;
    }

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetDdeServerWindow
//
//  Synopsis:   set dde server window
//
//  Arguments:  dwKey   - [in] Cookie designating the server
//              hWndDdeServer - [in] window to set
//
//  Returns:    TRUE   -  operation succeeded
//              FALSE  -  operation failed
//
//  Algorithm:  find an lsvr by safe casting the cookie
//              set its window to hWndDdeServer
//
//  History:    09-Sep-96  MattSmit   Created
//
//+-------------------------------------------------------------------------
BOOL CClassCache::SetDdeServerWindow(DWORD dwKey, HWND hWndDdeServer)
{
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    ClsCacheDebugOut((DEB_ACTIVATE, "CClassCache::SetDdeServerWindow: dwKey = 0x%x, hWndDdeServer = 0x%x\n",
                      dwKey, hWndDdeServer));
    {
        STATIC_WRITE_LOCK(lck, _mxs);

        CLSvrClassEntry *pLSCE;
        HRESULT hr;

        if (FAILED(hr = CLSvrClassEntry::SafeCastFromDWORD(dwKey, pLSCE)))
        {
            return FALSE;
        }

        pLSCE->_hWndDdeServer = hWndDdeServer;

    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// API Implementation //////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetOrLoadClass
//
//  Delegates to:     CClassCache::GetOrLoadClass
//
//  Special Behavior: none
//
//  History:    23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCGetOrLoadClass(ACTIVATION_PROPERTIES_PARAM ap)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetorLoadClass\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }
    *(ap._ppUnk) = 0;
    return CClassCache::GetOrLoadClass(ap);
}




//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetOrCreateApartment
//
//  Delegates to:     CClassCache::GetOrCreateApartment
//
//  Special Behavior: none
//
//  History:    25-Feb-98   SatishT    Created
//
//--------------------------------------------------------------------------


HRESULT CCGetOrCreateApartment(ACTIVATION_PROPERTIES_PARAM ap,
                               DLL_INSTANTIATION_PROPERTIES *pdip,
                               HActivator *phActivator)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetOrCreateApartment\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }
    return CClassCache::GetOrCreateApartment(ap, pdip, phActivator);
}


//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetClassObject
//
//  Delegates to:     CClassCache::GetClassObject
//
//  Special Behavior: none
//
//  History:    26-Feb-98   SatishT    Created
//
//--------------------------------------------------------------------------


HRESULT CCGetClassObject(ACTIVATION_PROPERTIES_PARAM ap)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetClassObject\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }
    return CClassCache::GetClassObject(ap);
}


//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCIsClsidRegisteredInApartment
//
//  Delegates to:     CClassCache::IsClsIdRegisteredInApartment
//
//  Special Behavior: none
//
//  History:    23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
BOOL CCIsClsidRegisteredInApartment(REFCLSID rclsid, REFGUID guidPartition, DWORD dwContext)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCIsClsidRegisteredIniApartment\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return FALSE;
    }

    return CClassCache::IsClsidRegisteredInApartment(rclsid, guidPartition, dwContext);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCRegisterServer
//
//  Delegates to:     CClassCache::RegisterServer
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCRegisterServer(REFCLSID rclsid, IUnknown *punk, DWORD dwFlags, DWORD dwType, LPDWORD lpdwCookie)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCRegisterServer: punk = 0x%x, dwFlags = 0x%x, dwType = 0x%x\n", punk, dwFlags, dwType));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }

    return CClassCache::RegisterServer(rclsid, punk, dwFlags, dwType, lpdwCookie);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCRevoke
//
//  Delegates to:     CClassCache::Revoke
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCRevoke(DWORD dwCookie)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCRevoke: dwCookie = 0x%x\n", dwCookie));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return CO_E_OBJNOTREG;
    }

    return CClassCache::Revoke(dwCookie);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCAddRefServerProcess
//
//  Delegates to:     CClassCache::AddRefServerProcess
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
ULONG CCAddRefServerProcess()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCAddRefServerProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }

    return CClassCache::AddRefServerProcess();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCReleaseServerProcess
//
//  Delegates to:     CClassCache::ReleaseServerProcess
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
ULONG CCReleaseServerProcess()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCReleaseServerProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return 0;
    }

    return CClassCache::ReleaseServerProcess();
}
//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCLockServerForActivation
//
//  Delegates to:     CClassCache::LockServerForActivation
//
//  Special Behavior: none
//
//  History:          06-Oct-98 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCLockServerForActivation()
{
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return E_FAIL;
    }

    return CClassCache::LockServerForActivation();


}
//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCUnlockServerForActivation
//
//  Delegates to:     CClassCache::UnlockServerForActivation
//
//  Special Behavior: none
//
//  History:          06-Oct-98 MattSmit    Created
//
//--------------------------------------------------------------------------
void CCUnlockServerForActivation()
{
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if ((CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::UnlockServerForActivation();
    }
}
//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCSuspendProcessClassObjects
//
//  Delegates to:     CClassCache::SuspendProcessClassObjects
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCSuspendProcessClassObjects()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCSuspendProcessClassObjects\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::SuspendProcessClassObjects();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCResumeProcessClassObjects
//
//  Delegates to:     CClassCache::ResumeProcessClassObjects
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCResumeProcessClassObjects()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCResumeProcessClassObjects\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::ResumeProcessClassObjects();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCCleanUpDllsForApartment
//
//  Delegates to:     CClassCache::CleanupDllsForApartment
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCCleanUpDllsForApartment()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCCleanUpDllsForApartment\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::CleanUpDllsForApartment();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCCleanupDllsForProcess
//
//  Delegates to:     CClassCache::CleanupDllsforProcess
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCCleanUpDllsForProcess()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCCleanUpDllsForProcess\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::CleanUpDllsForProcess();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCReleaseCatalogObjects
//
//  Delegates to:     CClassCache::ReleaseCatalogObjects
//
//  Special Behavior: none
//
//  History:          11-Jan-99 MattSmit    Created
//
//--------------------------------------------------------------------------
void CCReleaseCatalogObjects()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCReleaseCatalogObjects\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return;
    }

    CClassCache::ReleaseCatalogObjects();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCCleanUpLocalServersForApartment
//
//  Delegates to:     CClassCache::CleanUpLocalServersForApartment
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCCleanUpLocalServersForApartment()
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCCleanUpLocalServersForApartment\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::CleanUpLocalServersForApartment();
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCFreeUnused
//
//  Delegates to:     CClassCache::FreeUnused
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCFreeUnused(DWORD dwUnloadDelay)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetFreeUnused\n"));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return S_OK;
    }

    return CClassCache::FreeUnused(dwUnloadDelay);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetClassInformationForDde
//
//  Delegates to:     CClassCache:GetClassInformationForDde
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
BOOL CCGetClassInformationForDde(REFCLSID clsid, LPDDECLASSINFO lpDdeInfo)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetClassInformationForDde: lpDdeInfo = 0x%x\n", lpDdeInfo));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return FALSE;
    }

    return CClassCache::GetClassInformationForDde(clsid, lpDdeInfo);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetClassInformationFromKey
//
//  Delegates to:     CClassCache:GetClassInformationFromKey
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
BOOL CCGetClassInformationFromKey(LPDDECLASSINFO lpDdeInfo)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetClassInformationFromKey: lpDdeInfo = 0x%x\n", lpDdeInfo));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return FALSE;
    }

    return CClassCache::GetClassInformationFromKey(lpDdeInfo);
}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCSetDdeServerWindow
//
//  Delegates to:     CClassCache:SetDdeServerWindow
//
//  Special Behavior: none
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
BOOL CCSetDdeServerWindow(DWORD dwKey,HWND hwndDdeServer)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCSetDdeServerWindow: dwKey = 0x%x, hwndDdeServer = 0x%x\n", dwKey, hwndDdeServer));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);
    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        return FALSE;
    }

    return CClassCache::SetDdeServerWindow(dwKey, hwndDdeServer);
}

//+-------------------------------------------------------------------------
//
//  Function:    CCGetDummyNodeForApartmentChain
//
//  Synopsis:    Allocates a "dummy" node for an apartment chain
//
//  Parameters:  ppv - [out] where to put a pointer to the dummy node
//
//  Algorithm:   allocate the node
//               put a dummy node signature on it
//
//  History:     23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCGetDummyNodeForApartmentChain(void **ppv)
{
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetDummyNodeForApartmentChain: ppv = 0x%x\n", ppv));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }

    {
        STATIC_WRITE_LOCK(lck, CClassCache::_mxs);

        if (!*ppv)
        {

            *ppv = new CClassCache::CLSvrClassEntry(CClassCache::CLSvrClassEntry::DUMMY_SIG, 0, 0, 0, 0);
            if (*ppv)
            {
                return S_OK;
            }
            return E_FAIL;
        }

        return S_OK;
    }

}

//+-------------------------------------------------------------------------
//
//  API Entrypoint:   CCGetTreatAs
//
//  Delegates to:     CClassCache
//
//  History:          23-Sep-96 MattSmit    Created
//
//--------------------------------------------------------------------------
HRESULT CCGetTreatAs(REFCLSID rclsid, CLSID &clsid)
{
    HRESULT hr = S_OK;

    IComClassInfo* pCI = NULL;
    
    ClsCacheDebugOut((DEB_ACTIVATE, "CCGetTreatAs rclsid = %I\n", &rclsid));
    ASSERT_LOCK_NOT_HELD(CClassCache::_mxs);

    if (!(CClassCache::_dwFlags & CClassCache::fINITIALIZED))
    {
        CClassCache::Init();
    }

    {
        LOCK_WRITE(CClassCache::_mxs);

        // check the hash
        DWORD dwCEHash = CClassCache::_ClassEntries.Hash(rclsid, GUID_DefaultAppPartition);
        ClsCacheDebugOut((DEB_ACTIVATE, "CCGetTreatAs: dwCEHash = 0x%x\n", dwCEHash));
        CClassCache::CClassEntry *pCE = CClassCache::_ClassEntries.LookupCE(dwCEHash, 
                                                                            rclsid, 
                                                                            GUID_DefaultAppPartition);
        ClsCacheDebugOut(( DEB_ACTIVATE,
                           "CCGetTreatAs: Lookup for clsid %I %s!\n",
                           &(rclsid), pCE ? "SUCCEEDED" : "FAILED"));

        if (!pCE)
        {
            // Windows Bug #107960
            // Look up class info without write lock
            // before call to CClassEntry::Create

            UNLOCK_WRITE(CClassCache::_mxs);
            
            hr = GetClassInfoFromClsid(rclsid, &pCI);
            if (FAILED (hr))
            {
                goto Cleanup;
            }

            LOCK_WRITE(CClassCache::_mxs);

            const GUID *pguidPartition = GetPartitionIDForClassInfo(pCI);

            pCE = CClassCache::_ClassEntries.LookupCE(dwCEHash, rclsid, *pguidPartition);
        }

        if (!pCE)
        {
            hr = CClassCache::CClassEntry::Create(rclsid, dwCEHash, pCI, pCE);
            if (FAILED(hr))
            {
                ClsCacheDebugOut((DEB_ERROR, "CCGetTreatAs: Create failed hr = 0x%x\n", hr));
                clsid = rclsid;
                goto CleanupUnlock;
            }
        }
        else
        {
            ASSERT_WRITE_LOCK_HELD(CClassCache::_mxs);
            BOOL fLockReleased = FALSE;
            hr = pCE->Complete(&fLockReleased);
            Win4Assert(!fLockReleased);
            if (FAILED(hr))
            {
                goto CleanupUnlock;
            }
        }

        Win4Assert(pCE->IsComplete());
        pCE = pCE->CycleToClassEntry();

        // This will stay in the cache until it gets cleaned
        // up by the last couninit.

        pCE->SetLockedInMemory();
        clsid = pCE->GetCLSID();
    }

CleanupUnlock:

    UNLOCK_WRITE(CClassCache::_mxs);

Cleanup:

    if (pCI)
    {
        pCI->Release();
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CClassCache::CDPEHashTable ///////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
DWORD CClassCache::CDPEHashTable::HashNode(SHashChain *pNode)
{
    return Hash( ((CDllPathEntry *) pNode)->_psPath );
}

DWORD CClassCache::CDPEHashTable::Hash(LPCWSTR psz)
{
    DWORD  dwHash  = 0;
    WORD   *pw     = (WORD *) psz;
    DWORD  dwLen   = lstrlenW( psz );
    ULONG  i;

    // Hash the name.
    for (i=0; i < dwLen; i++)
    {
        dwHash = (dwHash << 8) ^ *pw++;
    }

    return dwHash;
}

void  CClassCache::CDPEHashTable::Add(DWORD dwHash, CDllPathEntry *pDPE)
{
    CHashTable::Add(dwHash, (SHashChain *) pDPE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\mainthrd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//
//  File:       mainthrd.cxx
//
//  Contents:   Main Thread Procedure and support functions
//
//  History:    03-Dec-96   MattSmit   Created
//
//----------------------------------------------------------------------------


#include    <ole2int.h>
#include    <channelb.hxx>

#include    "objact.hxx"
#include    <dllhost.hxx>
#include    <sobjact.hxx>

// Name of window class and message class for dispatching messages.
LPTSTR  gOleWindowClass = NULL;         // class used to create windows

// Various things used for special single threaded DLL processing
DWORD gdwMainThreadId = 0;
HWND  ghwndOleMainThread = NULL;

// this flag is to indicate whether it is UninitMainThread that is
// destroying the window, or system shut down destroying the window.
BOOL gfDestroyingMainWindow = FALSE;

const TCHAR *ptszOleMainThreadWndName = TEXT("OleMainThreadWndName");

const WCHAR *ptszOleMainThreadWndClass = L"OleMainThreadWndClass";

//+---------------------------------------------------------------------------
//
//  Function:   OleMainThreadWndProc
//
//  Synopsis:   Window proc for handling messages to the main thread
//
//  Arguments:  [hWnd] - window the message is on
//              [message] - message the window receives
//              [wParam] - first message parameter
//              [lParam] - second message parameter.
//
//  Returns:    Depends on the message
//
//  Algorithm:  If the message is one a user message that we have defined,
//              dispatch it. Otherwise, send any other message to the
//              default window proc.
//
//  History:    22-Nov-94   Ricksa  Created
//
//----------------------------------------------------------------------------
LRESULT OleMainThreadWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch(message)
    {
    case WM_OLE_GETCLASS:
        // get the host interface for single-threaded dlls
        return GetSingleThreadedHost(lParam);

    // Check whether it is UninitMainThreadWnd or system shutdown that
    // is destroying the window. Only actually do the destroy if it is us.
    case WM_DESTROY:
    case WM_CLOSE:
        if (gfDestroyingMainWindow == FALSE)
        {
            // Not in UninitMainThreadWnd so just ignore this message. Do not
            // dispatch it.
            ComDebOut((DEB_WARN, "Attempted to destroy Window outside of UninitMainThreadWnd"));
            return 0;
        }
        // else fallthru
    }

    // We don't process the message so pass it on to the default
    // window proc.
    return SSDefWindowProc(hWnd, message, wParam, lParam);
}



//+---------------------------------------------------------------------------
//
//  Function:   InitMainThreadWnd
//
//  Synopsis:   Do initialization necessary for main window processing.
//
//  Returns:    S_OK - we got initialized
//              S_FALSE - initialization skipped due to WOW thread.
//              other - failure creating window
//
//  Algorithm:  Create our main thread window and save the threadid.
//
//  History:    22-Nov-94   Ricksa  Created
//              24-Mar-95   JohannP Added notify mechanismen
//
//----------------------------------------------------------------------------
HRESULT InitMainThreadWnd(void)
{
    HRESULT hr = S_FALSE;

    ComDebOut((DEB_ENDPNT, "InitMainThreadWnd on %x\n", GetCurrentThreadId()));
    Win4Assert(IsSTAThread());

    // Use IsWOWThread and NOT IsWOWProcess because there may be 32 bit threads
    // in WOW that call CoInitializeEx for their own purpose. IsWowThread gets
    // set in the TLS only when CoInitializeWow is called (when a 16-bit app
    // calls CoInitialize).

    if (!IsWOWThread())
    {
        // We could get here in NTVDM (Wow) only if a 32-bit thread
        // calls CoInit before WOW calls it on behalf of any 16-bit app
        // Otherwise there is no "main" thread in WOW. A thread in WOW
        // gets marked as a WOW thread when WOW calls CoInit (coming from
        // the 16-bit world) on that thread.

        // this window is only needed for the non WOW case since
        // WOW is not a real apartment case
        // Create a main window for this application instance.

        // NT has defined a new window type that won't receive broadcast
        // messages. We use this whenever possible.
        HWND hwndParent = HWND_MESSAGE;
		
        Win4Assert(gOleWindowClass != NULL);

        // gdwMainThreadId and ghwndOleMainThread should be
        // set or cleared together as a matched pair
        Win4Assert(gdwMainThreadId == 0);
        Win4Assert(ghwndOleMainThread == NULL);

        ghwndOleMainThread = CreateWindowEx(
                0,
                gOleWindowClass,
                ptszOleMainThreadWndName,
                // must use WS_POPUP so the window does not get assigned
                // a hot key by user.
                (WS_DISABLED | WS_POPUP),
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                hwndParent,
                NULL,
                g_hinst,
                NULL);       
        if (!ghwndOleMainThread)
        {
            ComDebOut((DEB_WARN, "Register Window on OleWindowClass failed \n"));

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            // Success.  Remember this thread
            gdwMainThreadId = GetCurrentThreadId();
            hr = S_OK;
        }
    }

    ComDebOut((DEB_ENDPNT, "InitMainThreadWnd done on %x\n", gdwMainThreadId));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterOleWndClass
//
//  Synopsis:   Registers the Ole window class
//
//  History:    04-Apr-01   JSimmons  Moved here from InitMainThreadWnd
//
//----------------------------------------------------------------------------
HRESULT RegisterOleWndClass(void)
{
    HRESULT hr = S_OK;

    ComDebOut((DEB_ENDPNT, "RegisterOleWndClass on %x\n", GetCurrentThreadId()));
    Win4Assert(IsSTAThread());
    Win4Assert(gOleWindowClass == NULL);

    // Register windows class.
    WNDCLASST        xClass;
    xClass.style         = 0;
    xClass.lpfnWndProc   = OleMainThreadWndProc;
    xClass.cbClsExtra    = 0;

    // DDE needs some extra space in the window
    xClass.cbWndExtra    = sizeof(LPVOID) + sizeof(ULONG) + sizeof(HANDLE);
    xClass.hInstance     = g_hinst;
    xClass.hIcon         = NULL;
    xClass.hCursor       = NULL;
    xClass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    xClass.lpszMenuName  = NULL;
    xClass.lpszClassName = ptszOleMainThreadWndClass;	

    gOleWindowClass = (LPTSTR)RegisterClass(&xClass);
    if (gOleWindowClass == 0)
    {
        // it is possible the dll got unloaded without us having called
        // unregister so we call it here and try again.

        // jsimmons 04/04/01
        // I don't know if the above comment still holds true or
        // not -- it's probably some antique holdover from the 9x
        // days.  However, retrying the registration should be benign
        // in any case.
        (void)UnregisterClass(ptszOleMainThreadWndClass, g_hinst);

        gOleWindowClass = (LPTSTR) RegisterClass(&xClass);
        if (gOleWindowClass == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            ComDebOut((DEB_ERROR, "RegisterOleWndClass failed; GLE=0x%x\n", GetLastError()));
        }
    }

    ComDebOut((DEB_ENDPNT,"RegisterOleWndClass done on %x\n", GetCurrentThreadId()));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   UnRegisterOleWndClass
//
//  Synopsis:   Unregister Ole window class
//
//  Algorithm:  Unregister the window class.
//
//  History:    13-Dec-96   MurthyS  Created
//
//----------------------------------------------------------------------------
void UnRegisterOleWndClass(void)
{
    ComDebOut((DEB_ENDPNT, "UnRegisterOleWndClass on %x\n", GetCurrentThreadId()));
    Win4Assert(IsSTAThread());

    Win4Assert(gOleWindowClass != NULL);

    // Unregister the window class.  We use the string name of the class, but we could
    // also use the atom (gOleWindowClass).  In any event, once we unregister the class,
    // the class atom is invalid so we null it out for easier debugging if someone
    // tries to use afterwards.
    if (UnregisterClassT(ptszOleMainThreadWndClass, g_hinst) == FALSE)
    {
        ComDebOut((DEB_ERROR,"Unregister Class failed on OleMainThreadWndClass %ws because %d\n", ptszOleMainThreadWndClass, GetLastError()));
    }
    
    gOleWindowClass = NULL;

    ComDebOut((DEB_ENDPNT,"UnRegisterOleWndClass done on %x\n", GetCurrentThreadId()));
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   UninitMainThreadWnd
//
//  Synopsis:   Free resources used by main window processing.
//
//  Algorithm:  Destroy the main thread window if this is indeed the main thread.
//
//  History:    22-Nov-94   Ricksa  Created
//              24-Mar-95   JohannP Added notify mechanismen
//
//----------------------------------------------------------------------------
void UninitMainThreadWnd(void)
{
    ComDebOut((DEB_ENDPNT, "UninitMainThreadWnd on %x\n", GetCurrentThreadId()));
    Win4Assert(IsSTAThread());

    if (gdwMainThreadId == GetCurrentThreadId())
    {
        BOOL fRet = FALSE;

        // we can get here through a 32-bit thread in Wow (Shell32 has
        // started calling CoInit as of 7/98 and we do end up having
        // gdwMainThreadId in ntvdm.exe.

        // Destroy the window
        if (IsWindow(ghwndOleMainThread))
        {
            // flag here is to indicate that we are destroying the window.
            // as opposed to the system shutdown closing the window. the
            // flag is looked at in dcomrem\chancont\ThreadWndProc.
            gfDestroyingMainWindow = TRUE;
            SSDestroyWindow(ghwndOleMainThread);
            gfDestroyingMainWindow = FALSE;
            ghwndOleMainThread = NULL;
        }

        gdwMainThreadId = 0;
    }

    ComDebOut((DEB_ENDPNT,"UninitMainThreadWnd done on %x\n", GetCurrentThreadId()));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\objact.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       objact.cxx
//
//  Contents:   Helper Functions for object activation
//
//  Functions:
//
//  History:    12-May-93 Ricksa    Created
//              31-Dec-93 ErikGav   Chicago port
//              23-Jun-98 CBiks     See RAID# 159589.  Added activation
//                                  flags where appropriate.
//              24-Jul-98 CBiks     Fixed Raid# 19960.
//              21-Oct-98 SteveSw   104665; 197253;
//                                  fix COM+ persistent activation
//
//--------------------------------------------------------------------------

#include <ole2int.h>
#include <iface.h>
#include <objact.hxx>
#include <clsctx.hxx>
#include "resolver.hxx"
#include "smstg.hxx"
#include "events.hxx"
#include <objsrv.h>
#include <utils.h>
#include "dllcache.hxx"
#include <security.hxx>
#include <immact.hxx>
#include <reghelp.hxx>

// only for CHECKREFCOUNT which should be moved to a common header
#include <actvator.hxx>

#include "partitions.h"

#if DBG == 1
extern BOOL gAssertOnCreate;
#endif

HRESULT ATHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj);
HRESULT MTHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj);
HRESULT NTHostActivatorGetClassObject(REFIID riid, LPVOID *ppvClassObj);
HINSTANCE g_hComSvcs = NULL;     // module handle of com svcs.

// Add type definition for the get class function of the comsvcs dll.
typedef HRESULT (*InternalGetClass) (REFCLSID, REFIID, LPVOID *);

InternalGetClass ComSvcGetClass;

extern "C" CLSID CLSID_ThumbnailUpdater;

const CLSID guidPartitionProperty = {0xecabaeba, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};


extern "C" HRESULT GetActivationPropertiesIn(
                                            ActivationPropertiesIn *pInActivationProperties,
                                            REFCLSID rclsid,
                                            DWORD dwContext,
                                            COSERVERINFO * pServerInfo,
                                            DWORD cIIDs,
                                            IID *iidArray,
                                            DWORD dwActvFlags,
                                            DLL_INSTANTIATION_PROPERTIES *pdip,
                                            IComClassInfo *pClassInfo);


#define INTERNAL_CLSCTX(clsctx) (clsctx & CLSCTX_PS_DLL)

//+-------------------------------------------------------------------------
//
//  Function:   GetClassInfoFlags
//
//  Synopsis:   Get some useful flags from the class info
//
//  Arguments:  pActIn (in/out) activationproperties object
//
//  Returns:    Flags indicating whether the component is enabled, private or VB debug is in progress
//
//--------------------------------------------------------------------------

void GetClassInfoFlags
(
    ActivationPropertiesIn * i_pActIn, 
    BOOL * o_pfEnabled, 
    BOOL * o_pfPrivate, 
    BOOL * o_pfDebugInProgress
)
{
    HRESULT hr = S_OK;
    IComClassInfo * pIComClassInfo = NULL;
    IComClassInfo2 * pIComClassInfo2 = NULL;

    Win4Assert(i_pActIn);

    // default values
    
    if (o_pfEnabled)
        *o_pfEnabled = TRUE;        // NOTE: important!

    if (o_pfPrivate)
        *o_pfPrivate = FALSE;

    if (o_pfDebugInProgress)
        *o_pfDebugInProgress = FALSE;

    pIComClassInfo = i_pActIn->GetComClassInfo();
    Win4Assert(pIComClassInfo);
    pIComClassInfo->AddRef(); 

    hr = pIComClassInfo->QueryInterface(IID_IComClassInfo2, (void **)&pIComClassInfo2); 

    if (S_OK == hr)
    {
        Win4Assert(pIComClassInfo2);

        if (o_pfEnabled)
            pIComClassInfo2->IsEnabled(o_pfEnabled);
        if (o_pfPrivate)
            pIComClassInfo2->IsPrivateComponent(o_pfPrivate);
        if (o_pfDebugInProgress)
            pIComClassInfo2->VBDebugInProgress(o_pfDebugInProgress);
    }

    pIComClassInfo2->Release();
    pIComClassInfo->Release();

} // GetClassInfoFlags


//+-------------------------------------------------------------------------
//
//  Function:   AddPartitionID
//
//  Synopsis:   Add the partition id from the context property (if available) to the actprops object.
//
//  Arguments:  pActIn (in/out) activationproperties object
//
//  Returns:    none
//
//--------------------------------------------------------------------------

void AddPartitionID(ActivationPropertiesIn *pActIn)
{
	HRESULT hr = S_OK;

	SpecialProperties * pSSP = NULL;

	Win4Assert(pActIn);

	pSSP = pActIn->GetSpecialProperties();
	
	// Don't clean up pSSP, it is not reference counted

	if (NULL == pSSP)	// unexpected, should be there
	{
		Win4Assert(!"GetSpecialProperties");

		return;
	}

	GUID guidPartitionId = GUID_NULL;

	hr = pSSP->GetPartitionId(&guidPartitionId);

	if (S_OK == hr)		// valid case, partition id is already set
		return;								

	// There is no existing partition id on the ActPropsIn, try to get one from context

	CObjectContext * pClientContext = GetCurrentContext();

	// Don't need to release this pClientContext

	if (NULL == pClientContext)		// unexpected, should be there
	{
		Win4Assert(!"GetCurrentContext");

		return;
	}

	IUnknown * punk = NULL;

	CPFLAGS flags;	// not used

	hr  = pClientContext->GetProperty(guidPartitionProperty, &flags, &punk);

	if (NULL == punk)		// valid case, normal case, partition property not on context
		return;

	Win4Assert(S_OK == hr);

	// Found the partition property on the client context

	IPartitionProperty * pPartitionProp = NULL;

	hr = punk->QueryInterface(__uuidof(IPartitionProperty), (void**)&pPartitionProp);

	punk->Release();

	if ((hr != S_OK) || (NULL == pPartitionProp))		// unexpected, must support this interface
	{
		Win4Assert(!"QI for IPartitionProperty");

		return;
	}

	Win4Assert(GUID_NULL == guidPartitionId);

	hr = pPartitionProp->GetPartitionID(&guidPartitionId);

	pPartitionProp->Release();

	Win4Assert(S_OK == hr);

	// Set the partition id on the ActPropsIn

	pSSP->SetPartitionId(guidPartitionId);

} // AddPartitionID

//+-------------------------------------------------------------------------
//
//  Function:   AddHydraSessionID
//
//  Synopsis:   Add the current hydra session to the actprops object if 
//              running in a session; otherwise set it to zero.   Meant to
//              be used early in the activation process to store the client
//              app's session id.
//
//  Arguments:  pActIn (in/out) activationproperties object
//
//  Returns:    none
//
//--------------------------------------------------------------------------

void AddHydraSessionID(ActivationPropertiesIn *pActIn)
{
    SpecialProperties* pSSP = NULL;
    ULONG ulSessionId;
    
    pSSP = pActIn->GetSpecialProperties();
    if (pSSP != NULL)
    {
        HRESULT hr;
        BOOL bUseConsole;
        BOOL bRemoteSessionId = FALSE;

        // If a session moniker has already set this upstream from us, don't
        // overwrite anything.   The session moniker always sets the "remote this
        // session id" flag to TRUE, so we can use that flag to detect this case.
        hr = pSSP->GetSessionId2(&ulSessionId, &bUseConsole, &bRemoteSessionId);
        if (SUCCEEDED(hr) && bRemoteSessionId)
        {
            // return immediately
            return;
        }

        // Ask Hydra what our current session ID is:
        if ( !ProcessIdToSessionId( GetCurrentProcessId(), (DWORD *) &ulSessionId ) )
        {
            // if that failed for any reason, fall back on zero
            ulSessionId = 0;
        }
        
        // Pass in FALSE here since this session id should NOT go off 
        // machine.  Pass in FALSE for bUseConsole since this is an implicit
        // session setting, not explicit.
        pSSP->SetSessionId (ulSessionId, FALSE, FALSE);
        // Don't clean up pSSP, it's not reference counted
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   AddOrigClsCtx
//
//  Synopsis:   Add the the CLSCTX as supplied by the client.
//
//  Arguments:  pActIn (in/out) activationproperties object
//             dwClsCtx (in) CLSCTX as supplied by the client  
//
//  Returns:    none
//
//--------------------------------------------------------------------------

void AddOrigClsCtx(ActivationPropertiesIn *pActIn, DWORD dwClsCtx)
{
    SpecialProperties* pSSP = NULL;
    DWORD dwCurClsCtx = 0;

    pSSP = pActIn->GetSpecialProperties();
    
    if (pSSP != NULL)
    {
        pSSP->GetOrigClsctx(&dwCurClsCtx);

        if(!dwCurClsCtx){
            pSSP->SetOrigClsctx(dwClsCtx);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   GetClassInfoFromClsid
//
//  Synopsis:   Initialize the catalog interface if necessary and query it
//              for a CLSID
//
//
//  Arguments:
//
//  Returns:    S_OK - no errors or inconsistencies found
//
//
//--------------------------------------------------------------------------

HRESULT GetClassInfoFromClsid(REFCLSID rclsid, IComClassInfo **ppClassInfo)
{
    HRESULT hr = InitializeCatalogIfNecessary();
    if ( FAILED(hr) )
    {
        return hr;
    }
    else
    {
        return gpCatalog->GetClassInfo(rclsid,IID_IUnknown,(LPVOID*)ppClassInfo);
    }
}


STDAPI CoGetDefaultContext(APTTYPE aptType, REFIID riid, void** ppv);

//+-------------------------------------------------------------------------
//
//  Function:   GetActivationPropertiesIn
//
//  Synopsis:   Create and initialize an ActivationPropertiesIn
//              object based on the activation parameters
//
//
// Arguments:   [rclsid] - requested CLSID
//              [pServerInfo] - server information block
//              [dwContext] - kind of server required
//              [cIIDs] - count of interface ids
//              [iidArray] - array of interface ids
//              [ppActIn] - ActivationPropertiesIn object returned
//
//  Returns:    S_OK - no errors or inconsistencies found
//
//
//--------------------------------------------------------------------------
extern "C" HRESULT GetActivationPropertiesIn(
                                            ActivationPropertiesIn *pInActivationProperties,
                                            REFCLSID rclsid,
                                            DWORD dwContext,
                                            COSERVERINFO * pServerInfo,
                                            DWORD cIIDs,
                                            IID *iidArray,
                                            DWORD dwActvFlags,
                                            DLL_INSTANTIATION_PROPERTIES *pdip,
                                            IComClassInfo *pClassInfo)
{
    // We may be doing out of proc activation for a class that is not
    // registered so allow it to go through
    HRESULT hr;
    if ( pClassInfo )
    {
        pClassInfo->AddRef();
    }
    else
    {
        hr = GetClassInfoFromClsid(rclsid, &pClassInfo);
        if ( FAILED(hr) && (hr != REGDB_E_CLASSNOTREG) )
            return hr;
    }

    hr = pInActivationProperties->SetClassInfo(pClassInfo);
    if ( FAILED(hr) && (hr != REGDB_E_CLASSNOTREG) )
        return hr;

    pClassInfo->Release();      // pInActivationProperties owns it

    hr = pInActivationProperties->SetClsctx(dwContext);
    if ( FAILED(hr) )
        return hr;

    hr = pInActivationProperties->SetActivationFlags(dwActvFlags);
    if ( FAILED(hr) )
        return hr;

    hr = pInActivationProperties->AddRequestedIIDs(cIIDs,iidArray);
    if ( FAILED(hr) )
        return hr;

    // Figure out what the client context should be.
    BOOL fReleaseClientContext;
    CObjectContext *pClientContext;
    if (dwContext & CLSCTX_FROM_DEFAULT_CONTEXT)
    {        
        hr = CoGetDefaultContext(APTTYPE_CURRENT, IID_IStdObjectContext, (void **)&pClientContext);
        fReleaseClientContext = TRUE;
    }
    else
    {
        fReleaseClientContext = FALSE;
        pClientContext = GetCurrentContext();
        if (NULL == pClientContext)
            hr = CO_E_NOTINITIALIZED;
    }

    if (FAILED(hr))
        return hr;


    // Create prototype context only if there are properties marked
    // PROPAGATE in the client context -- and add them to the prototype
    // context
    CObjectContext *pPrototypeContext = NULL;
    hr = CObjectContext::CreatePrototypeContext(pClientContext,
                                                &pPrototypeContext);
    if ( SUCCEEDED(hr) )
    {
        // Set the client and prototype contexts in the activation properties
        // The prototype context is set to NULL when not needed and is created on demand
        hr = pInActivationProperties->SetContextInfo((IContext*)pClientContext,
                                                     (IContext*)pPrototypeContext);
    }

    if (fReleaseClientContext)
        pClientContext->Release();

    if (pPrototypeContext)
        pPrototypeContext->Release();

    if ( FAILED(hr) )
        return hr;

    if ( pServerInfo )
    {
        SecurityInfo                  * pLegacyInfo = NULL;
        // This special private interface saves us some labor in
        // setting security properties
        pLegacyInfo = pInActivationProperties->GetSecurityInfo();
        Win4Assert(pLegacyInfo != NULL);

        hr = pLegacyInfo->SetCOSERVERINFO(pServerInfo);
        if ( FAILED(hr) )
            return hr;
    }


    //if (pdip)    {

    ActivationPropertiesIn *pActIn;
    hr = pInActivationProperties->QueryInterface(CLSID_ActivationPropertiesIn,
                                                 (void **) &pActIn);

    Win4Assert(!FAILED(hr));

#if DBG == 1
    DLL_INSTANTIATION_PROPERTIES *check_pdip;
    check_pdip = (DLL_INSTANTIATION_PROPERTIES *)pActIn->GetDip();
    Win4Assert(!check_pdip);
#endif
    pActIn->SetDip(pdip);
    //    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ValidateAndRemapParams
//
//  Synopsis:   Common parameter checking for internal activation APIs
//
//
// Arguments:   [Clsid] - requested CLSID
//              [pServerInfo] - server information block
//              [dwCount] - count of interfaces
//              [pResults] - MULTI_QI struct of interfaces
//
//  Returns:    S_OK - no errors or inconsistencies found
//
//
//--------------------------------------------------------------------------

INTERNAL ValidateAndRemapParams(
                               REFCLSID                    Clsid,
                               DWORD                     & dwClsCtx,
                               COSERVERINFO              * pServerInfo,
                               DWORD                       dwCount,
                               MULTI_QI                  * pResults )
{
    if ( !IsApartmentInitialized() )
        return  CO_E_NOTINITIALIZED;

    HRESULT hr = ValidateCoServerInfo(pServerInfo);
    if ( FAILED(hr) )
    {
        return hr;
    }

    DWORD dwValidMask = CLSCTX_VALID_MASK | CLSCTX_PS_DLL;

    // Make sure input request is at least slightly logical
    if (
       ((dwClsCtx & ~dwValidMask) != 0)
       || ( dwCount < 1 )
       || ( pResults == NULL )
       )
    {
        return E_INVALIDARG;
    }
    // can't ask for both
    if ( (dwClsCtx & CLSCTX_DISABLE_AAA) && (dwClsCtx & CLSCTX_ENABLE_AAA) ) 
    {
       return E_INVALIDARG;
    }
    // check the MULTI_QI for validity (and clear out the hresults)
    for ( UINT i=0; i<dwCount; i++ )
    {
        if ( pResults[i].pItf || !pResults[i].pIID )
        {
            return E_INVALIDARG;
        }
        pResults[i].hr = E_NOINTERFACE;
        Win4Assert (pResults[i].pItf == NULL);
    }

    // Make sure we are asking for the correct inproc server
    dwClsCtx = RemapClassCtxForInProcServer(dwClsCtx);

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsComsvcsCLSID
//
//  Synopsis:   checks if the given clsid is implemented in COMSVCS.DLL.
//
//  Arguments:  [rclsid] - clsid to look for
//
//  History:    11-18-98    JohnStra      Created
//
//+-------------------------------------------------------------------------
BOOL IsComsvcsCLSID(
    REFCLSID rclsid
    )
{
    // The range of CLSIDs implemented by COMSVCS.DLL is:
    // from: ecabaeb0-7f19-11d2-978e-0000f8757e2a
    // to:   ecabb297-7f19-11d2-978e-0000f8757e2a

    // Special case for the CLSID of System.EnterpriseServices.ClrObjectFactory, which
    // is activated by mscoree.dll and implemented in System.EnterpriseServices.dll
    static const CLSID clsidClrObjFactory = { 0xecabafd1 ,0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a} };

    DWORD *ptr = (DWORD *) &rclsid;
    if (*(ptr+1) == 0x11d27f19 &&
        *(ptr+2) == 0x00008e97 &&
        *(ptr+3) == 0x2a7e75f8)
    {
        if (*ptr >= 0xecabaeb0 && *ptr <= 0xecabb297)
        {
            return rclsid == clsidClrObjFactory ? FALSE : TRUE;
        }
    }
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   IsMarshalerCLSID
//
//  Synopsis:   checks if the given clsid implements the marshaler category.
//
//  Arguments:  [rclsid] - clsid to look for
//
//  History:    05-04-00    Sajia         Created
//
//+-------------------------------------------------------------------------
BOOL IsMarshalerCLSID(
    REFCLSID rclsid
    )
{
    const WCHAR *WSZ_IMPLMARSHALERCATID = L"\\Implemented Categories\\{00000003-0000-0000-C000-000000000046}";
    WCHAR szKey[200];
    lstrcpyW(szKey, L"Clsid\\");
    wStringFromGUID2(rclsid,szKey+6,GUIDSTR_MAX);
    lstrcat(szKey, WSZ_IMPLMARSHALERCATID);
    HKEY hKey;
    if (OpenClassesRootKeyEx(szKey, KEY_READ, &hKey) == ERROR_SUCCESS) 
    {
       RegCloseKey(hKey);
       return TRUE;
    }
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   ICoGetClassObject
//
//  Synopsis:   Internal entry point that returns an instantiated class object
//
//  Arguments:  [rclsid] - class id for class object
//              [dwContext] - kind of server we wish
//              [pvReserved] - Reserved
//              [riid] - interface to bind class object
//              [ppvClassObj] - where to put interface pointer
//
//  Returns:    S_OK - successfully bound class object
//
//  Algorithm:  First, the context is validated. Then we try to use
//              any cached information by looking up either cached in
//              process servers or handlers based on the context.
//              If no cached information suffices, we call the SCM
//              to find out what to use. If the SCM returns a handler
//              or an inprocess server, we cache that information.
//              If the class is implemented by a local server, then
//              the class object is unmarshaled. Otherwise, the object
//              is instantiated locally using the returned DLL.
//
//
//  History:    15-Nov-94 Ricksa    Split into external and internal calls
//
//
//--------------------------------------------------------------------------
INTERNAL ICoGetClassObject(
                          REFCLSID rclsid,
                          DWORD dwContext,
                          COSERVERINFO * pServerInfo,
                          REFIID riid,
                          DWORD dwActvFlags,
                          void FAR* FAR* ppvClassObj,
                          ActivationPropertiesIn *pActIn)
{
    Win4Assert(gAssertOnCreate && "Assertion Testing");
    CLSID ConfClsid;
    
    MULTI_QI multi_qi = { &riid, NULL, E_NOINTERFACE};
    HRESULT hr = ValidateAndRemapParams(rclsid,dwContext,pServerInfo,1,&multi_qi);
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    
    IUnknown *punk = NULL;
    MInterfacePointer *pIFD = NULL;
    CLSID realclsid = rclsid;
    DWORD dwDllServerModel = 0;
    WCHAR * pwszDllServer = 0;
    int nRetries = 0;
    
    // IsInternalCLSID will also check to determine if the CLSID is
    // an OLE 1.0 CLSID, in which case we get back our internal
    // class factory.
    
    if ( IsInternalCLSID(rclsid, dwContext, riid, hr, ppvClassObj) )
    {
        //  this is an internally implemented clsid, or an OLE 1.0 class
        //  so we already got the class factory (if available) and set
        //  the return code appropriately.
        
    }
    else
    {
        if ((dwContext & CLSCTX_NO_CUSTOM_MARSHAL) && !IsComsvcsCLSID(rclsid)
            && !IsMarshalerCLSID(rclsid))
        {
            // don't allow custom marshalers that do not belong to
            // com services.
            return E_ACCESSDENIED;
        }

        // Remap from a reference clsid to a configured clsid through the catalogs
        hr = LookForConfiguredClsid(rclsid, ConfClsid);
        if (FAILED(hr) && (hr != REGDB_E_CLASSNOTREG))
            goto exit_point;

        // It's OK to pass in GUID_DefaultAppPartition, since 
        // SearchForLoadedClass ignores COM+ classes anyway.
        CClassCache::CDllClassEntry *pDCE = NULL;        
        ACTIVATION_PROPERTIES ap(ConfClsid, 
                                 GUID_DefaultAppPartition, 
                                 riid,
                                 ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                                 dwContext, 
                                 dwActvFlags, 
                                 0, 
                                 NULL,
                                 (IUnknown **) ppvClassObj);
        
        hr = CClassCache::SearchForLoadedClass(ap, &pDCE);
        if ( SUCCEEDED(hr) )
        {
            if ( *ppvClassObj )
            {
                //
                // an object was found, nothing left to do
                //
                Win4Assert(!pDCE);
            }
            else
                // Check if it's one we need to activate right here
                if (INTERNAL_CLSCTX(dwContext))
                {
                    // This goes to the class cache to actually lookup the DPE and
                    // get the factory                    
                    //
                    // Internal CLSCTX-- Proxy/Stubs are always in the base partition.
                    ACTIVATION_PROPERTIES ap(ConfClsid, 
                                             GUID_DefaultAppPartition,
                                             riid,
                                             0,
                                             dwContext, 
                                             dwActvFlags, 
                                             0, 
                                             NULL,
                                             (IUnknown **) ppvClassObj);
                    hr = CCGetClassObject(ap);
                }
                else
                {
                    //
                    // do COM+ activation
                    //
                    // Allocate In object on stack
                    IActivationPropertiesOut  * pOutActivationProperties = NULL;     // output
                    
                    if (!pActIn)
                    {
                        pActIn=(ActivationPropertiesIn*)
                          _alloca(sizeof(ActivationPropertiesIn));
                        pActIn->ActivationPropertiesIn::ActivationPropertiesIn();
                        pActIn->SetNotDelete(TRUE);
                    }
                    
                    AddHydraSessionID(pActIn);
                    AddPartitionID(pActIn);
                    AddOrigClsCtx(pActIn, dwContext);
                    
                    IID iid = riid;
                    
                    BOOL fRetry = FALSE, fDownloadDone = FALSE, bClassEnabled = TRUE;
                    DWORD relCount = 0;
                    
                    do
                    {                        
                        if ( fRetry )
                        {
                            relCount = pActIn->Release();
                            Win4Assert(relCount==0);
                            
                            pActIn = new ActivationPropertiesIn();
                            
                            if ( pActIn == NULL )
                                return E_OUTOFMEMORY;

                            AddOrigClsCtx(pActIn, dwContext);
                            fRetry = FALSE; // start with the assumption of termination
                        }
                        
                        Win4Assert(pActIn != NULL);

                        IComClassInfo *pCI = NULL;                        
                        DLL_INSTANTIATION_PROPERTIES *pdip;
                        
                        if ( pDCE )
                        {
                            pdip = (DLL_INSTANTIATION_PROPERTIES *)_alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
                            memset(pdip, 0, sizeof(DLL_INSTANTIATION_PROPERTIES));
                            pdip->_pDCE = pDCE;
                            pCI = pdip->_pDCE->_pClassEntry->_pCI;
                            if ( pCI )
                            {
                                pCI->AddRef();
                            }
                        }
                        else
                        {
                            pdip = NULL;
                        }
                        
                        // croft up an input activation properties object
                        hr = GetActivationPropertiesIn(
                            pActIn,
                            ConfClsid,
                            dwContext,
                            pServerInfo,
                            1,
                            &iid,
                            dwActvFlags,
                            pdip,
                            pCI);
                        
                        
                        if(SUCCEEDED(hr))
                        {
                            HRESULT TempHR; //This is here because it is OK to fail and we use hr later
                            IComClassInfo2 *pCI2 = NULL;
                            
                            if(!pCI)
                            {
                                pCI = pActIn->GetComClassInfo();
                                Win4Assert(pCI != NULL);
                                pCI->AddRef(); 
                            }
                            
                            TempHR = pCI->QueryInterface(IID_IComClassInfo2, (void **)&pCI2); 
                            if(SUCCEEDED(TempHR))
                            {
                                pCI2->IsEnabled(&bClassEnabled);
                                pCI2->Release();
                            }
                        }
                        
                        if ( pCI )
                        {
                            pCI->Release();
                            pCI = NULL;
                        }
                        
                        
                        if ( FAILED(hr) )
                        {
                            
                            pActIn->Release();      
                            goto exit_point;
                        }
                        
                        if(bClassEnabled == FALSE)
                        {
                            pActIn->Release(); 
                            hr = CO_E_CLASS_DISABLED; 
                            goto exit_point; 
                        }
RETRY_ACTIVATION:                   
                        IActivationStageInfo *pStageInfo = (IActivationStageInfo*) pActIn;
                        
                        // Start off activation at the beginning of client context stage
                        hr = pStageInfo->SetStageAndIndex(CLIENT_CONTEXT_STAGE,0);
                        CHECK_HRESULT(hr);
                        
                        // This is the whole activation process
                        hr = pActIn->DelegateGetClassObject(&pOutActivationProperties);
                        // If the delegated activation returns ERROR_RETRY,
                        // we walk the chain again, but AT MOST ONCE.
                        // This is to support the private activations.
                        if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr) 
                        {
                            Win4Assert(!nRetries);
                            if (!nRetries)
                            {
                                BOOL fEnabled = TRUE;

                                GetClassInfoFlags(pActIn, &fEnabled, NULL, NULL);
                                             
                                if (!fEnabled)
                                {   
                                    hr = CO_E_CLASS_DISABLED;
                                    pActIn->Release();      
                                    goto exit_point;
                                }

                                nRetries++;
                                goto RETRY_ACTIVATION;
                            }
                        }
                        
#ifdef DIRECTORY_SERVICE
                        
                        if ( FAILED(hr) && !(dwContext & CLSCTX_NO_CODE_DOWNLOAD) )
                        {
                            //download class if not registered locally -- but only once!
                            if ( (REGDB_E_CLASSNOTREG == hr) && !fDownloadDone )
                            {
                                //if successful, this will add a darwin id to the registry
                                hr = DownloadClass(realclsid,dwContext);
                                fDownloadDone = fRetry = SUCCEEDED(hr);
                            }
                            
                            if ( hr == CS_E_PACKAGE_NOTFOUND )
                            {
                                hr = REGDB_E_CLASSNOTREG;
                            }                            
                        }
#endif //DIRECTORY_SERVICE
                        
                        
                } while ( fRetry );
                
                
                if ( hr == S_OK )
                {
                    Win4Assert(pOutActivationProperties != NULL);
                    if (pOutActivationProperties == NULL)
                    {
                        hr = E_UNEXPECTED;
                    }
                    else
                    {
                        MULTI_QI mqi;
                        mqi.hr = S_OK;
                        mqi.pIID = &riid;
                        mqi.pItf = NULL;
                        hr = pOutActivationProperties->GetObjectInterfaces(1, dwActvFlags, &mqi);
                        if ( SUCCEEDED(hr) )
                        {
                            *ppvClassObj = mqi.pItf;
                            hr = mqi.hr;
                        }
                    }
                }
                
                if ( pOutActivationProperties )
                {
                    relCount = pOutActivationProperties->Release();
                    Win4Assert(relCount==0);
                }
                
                // Since doing an alloca, must release in after out
                // since actout may be contained by actin for
                // performance optimization
                relCount = pActIn->Release();
                Win4Assert(relCount==0);
                
                if ( pDCE )
                {
                    LOCK(CClassCache::_mxs);
                    pDCE->Unlock();
                    UNLOCK(CClassCache::_mxs);
                }
            }
        }
    }
exit_point:
    
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   LookForConfiguredClsid
//
//  Synopsis:   Internal mapper to find a ConfClsid given a RefClsid
//
//  Arguments:  [RefClsid] - Reference classid to map
//              [rFoundConfClsid] - Configured clsid found in catalogs
//
//  Returns:    S_OK - Successfully mapped clsid to configured clsid
//
//              S_FALSE - Didn't find catalog entry for clsid, confclsid is
//                        the same as the refclsid
//
//  Algorithm:  Simply look in the catalogs for the given clsid. The catalogs
//              will do all the heavy-lifting to find this clsid in their lists
//              When a victim^Wmatch is found, we ask for its configured clsid
//              that will be used to look this clsid up in all other instances.
//
//  History:    02-Jun-02 Jonwis      Created
//
//--------------------------------------------------------------------------
HRESULT
LookForConfiguredClsid(
    REFCLSID    RefClsid,
    CLSID      &rFoundConfClsid
    )
{
    IComClassInfo *pFoundClassInfo = NULL;
    HRESULT hr;
    
    hr = GetClassInfoFromClsid(RefClsid, &pFoundClassInfo);
    
    if (FAILED(hr))
    {
        rFoundConfClsid = RefClsid;
        hr = S_FALSE;
    }
    else
    {
        GUID *pConfiguredGuid = NULL;
        if (SUCCEEDED(hr = pFoundClassInfo->GetConfiguredClsid(&pConfiguredGuid)))
        {
            if (pConfiguredGuid != NULL)
            {
                rFoundConfClsid = *pConfiguredGuid;
                hr = S_OK;
            }
            else
            {
                rFoundConfClsid = RefClsid;
                hr = S_FALSE;
            }
        }
        pFoundClassInfo->Release();
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ICoCreateInstanceEx
//
//  Synopsis:   Internal version of CoCreateInstance
//
//
// Arguments:   [Clsid] - requested CLSID
//              [pServerInfo] - server information block
//              [punkOuter] - controlling unknown for aggregating
//              [dwCtrl] - kind of server required
//              [dwCount] - count of interfaces
//              [dwActvFlags] - activation flags
//              [pResults] - MULTI_QI struct of interfaces
//
//  Returns:    S_OK - object bound successfully
//
//
//--------------------------------------------------------------------------
INTERNAL ICoCreateInstanceEx(
                            REFCLSID                    Clsid,
                            IUnknown    *               punkOuter, // only relevant locally
                            DWORD                       dwClsCtx,
                            COSERVERINFO *              pServerInfo,
                            DWORD                       dwCount,
                            DWORD                       dwActvFlags,
                            MULTI_QI        *           pResults,
                          ActivationPropertiesIn *pActIn )
{
    int nRetries = 0;
    Win4Assert(gAssertOnCreate && "Assertion Testing");
    CLSID ConfClsid;
    
    HRESULT hrSave = E_FAIL;
    HRESULT hr = ValidateAndRemapParams(Clsid,dwClsCtx,pServerInfo,dwCount,pResults);
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    // an OLE 1.0 CLSID, in which case we get back our internal
    // class factory.
    
    IClassFactory *pcf = NULL;
    
    if (IsInternalCLSID(Clsid, dwClsCtx, IID_IClassFactory, hr, (void **)&pcf))
    {
        // this is an internally implemented clsid, or an OLE 1.0 class
        // so we already got the class factory (if available) and set
        // the return code appropriately.
        
        // get the interfaces
        if ( SUCCEEDED(hr) && pcf )
        {
            hr = hrSave = CreateInprocInstanceHelper(pcf,
                dwActvFlags,
                punkOuter,
                dwCount,
                pResults);
        }
    }
    else
    {
        // The class is not internal. If the CLSCTX_NO_CUSTOM_MARSHAL flag is set
        // return E_ACCESSDENIED.
        
        if ((dwClsCtx & CLSCTX_NO_CUSTOM_MARSHAL) && !IsComsvcsCLSID(Clsid)
            && !IsMarshalerCLSID(Clsid))
        {
            // don't allow custom marshalers that do not belong to
            // com services.
            return E_ACCESSDENIED;
        }

        // Look in our catalogs for a mapping for this clsid to a configured clsid,
        // since we store configured clsids in our class caching table. Don't fail if
        // we couldn't do the mapping.
        hr = LookForConfiguredClsid(Clsid, ConfClsid);
        if (FAILED(hr) && (hr != REGDB_E_CLASSNOTREG))
            goto exit_point;
        
        // It's OK to pass in GUID_DefaultAppPartition, since 
        // SearchForLoadedClass ignores COM+ classes anyway.
        CClassCache::CDllClassEntry *pDCE = NULL;
        ACTIVATION_PROPERTIES ap(ConfClsid, 
                                 GUID_DefaultAppPartition,
                                 IID_IClassFactory,
                                 ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                                 dwClsCtx, 
                                 dwActvFlags, 
                                 0, 
                                 NULL,
                                 (IUnknown **) &pcf);        
        
        hr = CClassCache::SearchForLoadedClass(ap, &pDCE);
        if ( SUCCEEDED(hr) )
        {
            // Check if it's one we need to activate right here
            if ((!pcf) && INTERNAL_CLSCTX(dwClsCtx))
            {
                // This goes to the class cache to actually lookup the DPE and
                // get the factory
                //
                // Proxy/Stubs are never partitioned.
                ACTIVATION_PROPERTIES ap(ConfClsid, 
                                         GUID_DefaultAppPartition,
                                         IID_IClassFactory,
                                         0,
                                         dwClsCtx, 
                                         dwActvFlags, 
                                         0, 
                                         NULL,
                                         (IUnknown **) &pcf);
                hr = hrSave = CCGetClassObject(ap);
                if (FAILED(hr))
                    goto exit_point;
            }
            
            if (pcf)
            {
                //
                // an object was found get the interfaces
                //
                Win4Assert(!pDCE);
                hr = hrSave = CreateInprocInstanceHelper(pcf,
                                                         dwActvFlags,
                                                         punkOuter,
                                                         dwCount,
                                                         pResults);
            }
            else
            {
                
                //
                // do COM+ activation
                //
                
                // Initialize activation properties
                // Allocate In on stack
                IActivationPropertiesOut  * pOutActivationProperties = NULL;     // output
                if (!pActIn)
                {
                    pActIn=(ActivationPropertiesIn*)
                        _alloca(sizeof(ActivationPropertiesIn));
                    pActIn->ActivationPropertiesIn::ActivationPropertiesIn();
                    pActIn->SetNotDelete(TRUE);
                }
                
                AddHydraSessionID(pActIn);                
                AddPartitionID(pActIn);
                AddOrigClsCtx(pActIn, dwClsCtx);
                
                // split the array of structs into individual arrays
                CSplit_QI    SplitQI( hr, dwCount, pResults );
                
                if ( FAILED(hr) )
                    goto exit_point;
                
                DLL_INSTANTIATION_PROPERTIES *pdip;
                IComClassInfo *pCI = NULL;
                
                if ( pDCE )
                {
                    pdip = (DLL_INSTANTIATION_PROPERTIES *)
                        _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
                    pdip->_pDCE = pDCE;
                    pCI = pdip->_pDCE->_pClassEntry->_pCI;
                    if ( pCI )
                    {
                        pCI->AddRef();
                    }
                }
                else
                {
                    pdip = NULL;
                }
                
                BOOL fRetry=FALSE, fDownloadDone = FALSE, bClassEnabled = TRUE;
                DWORD relCount = 0;
                
                do
                {
                    if ( fRetry )
                    {
                        DWORD relCount = pActIn->Release();
                        Win4Assert(relCount==0);
                        
                        pActIn = new ActivationPropertiesIn;
                        
                        if ( pActIn == NULL )
                            return E_OUTOFMEMORY;

                        AddOrigClsCtx(pActIn, dwClsCtx);
                            
                        fRetry = FALSE; // start with the assumption of termination
                    }
                    
                    Win4Assert(pActIn != NULL);
                    
                    hr = GetActivationPropertiesIn(
                        pActIn,
                        ConfClsid,
                        dwClsCtx,
                        pServerInfo,
                        dwCount,
                        SplitQI._pIIDArray,
                        dwActvFlags,
                        pdip,
                        pCI);
                    
                    if(SUCCEEDED(hr))
                    {
                        HRESULT TempHR; //This is here because it is OK to fail and we use hr later
                        IComClassInfo2 *pCI2 = NULL;
                        
                        if(!pCI)
                        {
                            pCI = pActIn->GetComClassInfo();
                            Win4Assert(pCI != NULL);
                            pCI->AddRef(); 
                        }
                        
                        TempHR = pCI->QueryInterface(IID_IComClassInfo2, (void **)&pCI2); 
                        if(SUCCEEDED(TempHR))
                        {
                            pCI2->IsEnabled(&bClassEnabled);
                            pCI2->Release();
                        }
                    }
                    
                    if ( pCI )
                    {
                        pCI->Release();
                        pCI = NULL;
                    }
                    
                    
                    
                    if ( FAILED(hr) )
                    {
                        
                        pActIn->Release();      
                        goto exit_point;
                    }
                    
                    if(bClassEnabled == FALSE)
                    {
                        pActIn->Release(); 
                        hr = CO_E_CLASS_DISABLED; 
                        goto exit_point; 
                    }
RETRY_ACTIVATION:                   
                    IActivationStageInfo *pStageInfo = (IActivationStageInfo*) pActIn;
                    
                    // Start off activation at the beginning of client context stage
                    hr = pStageInfo->SetStageAndIndex(CLIENT_CONTEXT_STAGE,0);
                    if (FAILED (hr))
                    {
                        pActIn->Release();      
                        goto exit_point;
                    }
                    
                    // This is the whole activation process
                    hr = hrSave = pActIn->DelegateCreateInstance(
                        punkOuter,
                        &pOutActivationProperties);
                    
                    // If the delegated activation returns ERROR_RETRY,
                    // we walk the chain again, but AT MOST ONCE.
                    // This is to support the private activations.
                    if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr) 
                    {
                        Win4Assert(!nRetries);
                        if (!nRetries)
                        {
                            BOOL fEnabled = TRUE;

                            GetClassInfoFlags(pActIn, &fEnabled, NULL, NULL);
                                         
                            if (!fEnabled)
                            {   
                                hr = CO_E_CLASS_DISABLED;
                                pActIn->Release();      
                                goto exit_point;
                            }
                    
                            nRetries++;
                            goto RETRY_ACTIVATION;
                        }
                    }
                    
#ifdef DIRECTORY_SERVICE
                    
                    if ( FAILED(hr) && !(dwClsCtx & CLSCTX_NO_CODE_DOWNLOAD) )
                    {
                        //download class if not registered locally -- but only once!
                        if ( (REGDB_E_CLASSNOTREG == hr) && !fDownloadDone )
                        {
                            //if successful, this will add a darwin id to the registry
                            hr = DownloadClass(Clsid,dwClsCtx);
                            fDownloadDone = fRetry = SUCCEEDED(hr);
                        }
                        
                        if ( hr == CS_E_PACKAGE_NOTFOUND )
                        {
                            hr = REGDB_E_CLASSNOTREG;
                        }                        
                    }
#endif //DIRECTORY_SERVICE
                    
                    
                } while ( fRetry );
                
                
                if ( SUCCEEDED(hr) )
                {
                    Win4Assert(pOutActivationProperties != NULL);
                    if (pOutActivationProperties == NULL)
                    {
                        hr = E_UNEXPECTED;
                    }
                    else
                    {
                        hr = pOutActivationProperties->GetObjectInterfaces(dwCount,
                                                                           dwActvFlags,
                                                                           pResults);
                    }
                }
                
                if ( pOutActivationProperties )
                {
                    relCount = pOutActivationProperties->Release();
                    Win4Assert(relCount==0);
                }
                
                
                // Since doing an alloca, must release in after out
                // since actout may be contained by actin for
                // performance optimization
                relCount = pActIn->Release();
                Win4Assert(relCount==0);
                
                if ( pDCE )
                {
                    LOCK(CClassCache::_mxs);
                    pDCE->Unlock();
                    UNLOCK(CClassCache::_mxs);
                }
            }
        }
    }
    
exit_point:
    
    if ( pcf != NULL )
    {
        pcf->Release();
    }

    //
    // hrSave is the result of the entire activation chain, hr is the
    // result of any work done after the activation (unmarshalling the
    // interfaces, etc).  If hr succeeded, then we want to update the
    // MULTI_QI array with the result of the actual activation, not the
    // rest.  If hr failed, then we want to use it regardless of the value
    // of hrSave.
    //
    if (SUCCEEDED(hr))
        hr = hrSave;

    hr = UpdateResultsArray( hr, dwCount, pResults );
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateInprocInstanceHelper
//
//  Synopsis:   Uses the supplied class factory to create instances
//              of multiple interfaces on an inproc server
//
//
// Arguments:   [pcf] - class factory object. this ALWAYS gets released
//                      if you call this function
//              [dwActvFlags] - flags controlling activation
//              [punkOuter] - controlling unknown for aggregating
//              [pResults] - MULTI_QI struct of interfaces
//
//  Returns:    S_OK - if results array was successfully updated
//
//
//--------------------------------------------------------------------------
HRESULT CreateInprocInstanceHelper(
                                  IClassFactory* pcf,
                                  DWORD          dwActvFlags,
                                  IUnknown*      pUnkOuter,
                                  DWORD          dwCount,
                                  MULTI_QI*      pResults)
{
    IUnknown * pUnk;
    HRESULT hr;

    // ask for the first interface (we'll use it as our IUnknown)
    hr = pcf->CreateInstance(pUnkOuter, *(pResults[0].pIID), (void**)&pUnk);

    if ( FAILED(hr) )
    {
        return hr;
    }

    // assign the first interface, then get the rest
    pResults[0].pItf = pUnk;
    pResults[0].hr   = S_OK;

    for ( DWORD i=1; i<dwCount; i++ )
    {
        pResults[i].hr = pUnk->QueryInterface( *(pResults[i].pIID),
                                               (void**)&pResults[i].pItf );
    }

    // rely on the UpdateResultsArray to count up failed QI's

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetObjectHelperMulti
//
//  Synopsis:   Creates an object in a persistent state
//
//  Arguments:  [pcf] - class factory
//              [grfMode] - mode to use when loading file
//              [pwszName] - file path to persistent storage
//              [pstg] - storage for persistent storage
//              [ppvUnk] - pointer to IUnknown
//
//  Returns:    S_OK - object successfully instantiated
//
//  Algorithm:  Create an empty instance of the object and then use
//              either the provided storage or file to load the object.
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      This helper is called by by servers and clients
//
//--------------------------------------------------------------------------
HRESULT GetObjectHelperMulti(
                            IClassFactory *pcf,
                            DWORD grfMode,
                            IUnknown * punkOuter,
                            WCHAR *pwszName,
                            IStorage *pstg,
                            DWORD dwInterfaces,
                            IID * pIIDs,
                            MInterfacePointer **ppIFDArray,
                            HRESULT * pResultsArray,
                            MULTI_QI *pResults ,
                            CDestObject *pDestObj)
{
    XIUnknown xunk;

    // Get the controlling unknown for the instance.
    HRESULT hr = pcf->CreateInstance(punkOuter, IID_IUnknown, (void **) &xunk);

    // This shouldn't fail but it is untrusted code ...
    if ( FAILED(hr) )
    {
        return hr;
    }

    // We put all these safe interface classes in the outer block because
    // we might be in the VDM where some classes will release
    // themselves at ref counts greater than one. Therefore, we avoid
    // releases at all costs.
    XIPersistStorage xipstg;
    XIPersistFile xipfile;

    // This is the case that the class requested is a DLL
    if ( pstg )
    {
        // Load the storage requested as an template
        hr = xunk->QueryInterface(IID_IPersistStorage, (void **) &xipstg);

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = xipstg->Load(pstg);

        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        hr = xunk->QueryInterface(IID_IPersistFile, (void **) &xipfile);

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = xipfile->Load(pwszName, grfMode);

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    // If an interface buffer was passed in, then this is a remote call
    // and we need to marshal the interface.
    if ( ppIFDArray )
    {
        // AddRef the pointer because MarshalHelper expects to release
        // pointer. Because MarshalHelper is called from two other places,
        // we do an AddRef here instead of moving the AddRef out of
        // MarshalHelper.
        xunk->AddRef();
        hr = MarshalHelperMulti(xunk, dwInterfaces, pIIDs, ppIFDArray, pResultsArray,
                                pDestObj);
    }
    else
    {
        // This is an inprocess server so we need to return the output
        // punk
        HRESULT hr2;

        for ( DWORD i=0; i<dwInterfaces; i++ )
        {
            hr2 = xunk->QueryInterface( *(pResults[i].pIID),
                                        (void**)&pResults[i].pItf );

            pResults[i].hr = hr2;

        }
        // rely on the caller to count up the failed QI's
        return S_OK;

    }

    return hr;
}


HRESULT GetInstanceHelper(
                         COSERVERINFO *              pServerInfo,
                         CLSID       *               pclsidOverride,
                         IUnknown    *               punkOuter, // only relevant locally
                         DWORD                       dwClsCtx,
                         DWORD                       grfMode,
                         OLECHAR *                   pwszName,
                         struct IStorage *           pstg,
                         DWORD                       dwCount,
                         MULTI_QI        *           pResults,
                         ActivationPropertiesIn      *pActIn )
{
    IUnknown*       punk            = NULL;
    IClassFactory*  pcf             = NULL;
    HRESULT         hr              = E_FAIL;
    BOOL            fExitBlock;
    DWORD           i;              // handy iterator
    DWORD           dwDllServerModel = 0;
    CLSID           clsid;
    HRESULT         hrSave          = E_FAIL;
    WCHAR*          pwszDllServer   = 0;
    
    int nRetries = 0;
#ifdef DFSACTIVATION
    BOOL        bFileWasOpened = FALSE;
#endif
    
    if ( (pwszName == NULL) && (pstg == NULL) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = ValidateAndRemapParams(clsid,dwClsCtx,pServerInfo,dwCount,pResults);
    }
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    DWORD actvflags = CComActivator::GetActvFlags(dwClsCtx);
    
    if ( pwszName )
    {
        // Limit on loops for retrying to get class of object
        DWORD cGetClassRetries = 0;
        
        // We loop here looking for either the running object or
        // for the class of the file. We do this because there
        // are race conditions where the can be starting or stopping
        // and the class of the object might not be available because
        // of the opening mode of the object's server.
        do
        {
            // Look in the ROT first to see if we need to bother
            // looking up the class of the file.
            
            hr = GetObjectFromRotByPath(pwszName,(IUnknown **) &punk);
            if ( S_OK == hr )
            {
                // Got object from ROT so we are done.
                goto qiexit_point;
            }
            
            // Try to get the class of the file
            if ( pclsidOverride != NULL )
            {
                clsid = *pclsidOverride;
                hr = S_OK;
            }
            else
            {
                hr = GetClassFile(pwszName, &clsid);
#ifdef DIRECTORY_SERVICE
                /*
                If class is not found locally and code download is permitted, download the class from the directory and
                try GetClassFile again.
                
                  - added by RahulTh (11/21/97)
                */
                if ( !(dwClsCtx & CLSCTX_NO_CODE_DOWNLOAD) &&
                    ResultFromScode (MK_E_INVALIDEXTENSION) == hr )
                {
                    dwClsCtx &= ~CLSCTX_NO_CODE_DOWNLOAD;
                    hr = DownloadClass(pwszName,dwClsCtx);
                    if ( hr == CS_E_PACKAGE_NOTFOUND )
                    {
                        hr = REGDB_E_CLASSNOTREG;
                    }
                    if ( SUCCEEDED(hr) )
                    {
                        hr = GetClassFile(pwszName, &clsid);
                    }
                }
#endif //DIRECTORY_SERVICE
#ifdef DFSACTIVATION
                bFileWasOpened = TRUE;
#endif
            }
            
            if ( hr == STG_E_ACCESSDENIED )
            {
                // The point here of the sleep is to try to let the
                // operation that is holding the class id unavailable
                // complete.
                Sleep(GET_CLASS_RETRY_SLEEP_MS);
                continue;
            }
            
            // Either we succeeded or something other than error
            // access denied occurred here. For all these cases
            // we break the loop.
            break;
            
        } while ( cGetClassRetries++ < GET_CLASS_RETRY_MAX );
        
        if ( FAILED(hr) )
        {
            // If we were unable to determine the classid, and the
            // caller provided one as a Ole1 clsid, try loading it
            // If it succeeds, then return
            
            if ( pclsidOverride != NULL )
            {
                goto dde_exit;
            }
            
            goto final_exit;
        }
    }
    
    CLSID       tmpClsid;
    
    hr = OleGetAutoConvert(clsid, &tmpClsid);
    if ( ( hr == REGDB_E_KEYMISSING ) || ( hr == REGDB_E_CLASSNOTREG ) )
    {
        // do nothing
        
    }
    else if ( FAILED(hr) )
    {
        goto exit_point;
    }
    else
    {
        clsid = tmpClsid;
    }
    
    hr = CCGetTreatAs(clsid, clsid);
    if ( FAILED(hr) )
    {
        goto exit_point;
    }
    
    //
    // If this is a OLE 1.0 class, then do a DdeBindToObject on it,
    // and return.
    //
    if ( CoIsOle1Class(clsid) )
    {
        if ( pwszName != NULL )
        {
            goto dde_exit;
        }
        else
        {
            //
            // Something is fishy here. We don't have a pwszName,
            // yet CoIsOle1Class returned the class as an ole1 class.
            // To get to this point without a pwszName, there must have
            // been a pstg passed into the API.
            //
            // This isn't supposed to happen. To recover, just fall
            // through and load the class as an OLE 2.0 class
            //
            CairoleDebugOut((DEB_ERROR,
                "CoIsOle1Class is TRUE on a storage!\n"));
        }
    }
    
    // At this point, we know the clsid we want to activate
    
    {
        // SearchForLoadedClass ignores COM+....
        CClassCache::CDllClassEntry *pDCE = NULL;
        ACTIVATION_PROPERTIES ap(clsid, 
                                 GUID_DefaultAppPartition,
                                 IID_IClassFactory,
                                 ACTIVATION_PROPERTIES::fDO_NOT_LOAD,
                                 dwClsCtx, 
                                 actvflags, 
                                 0, 
                                 NULL,
                                 (IUnknown **) &pcf);
        
        hr = CClassCache::SearchForLoadedClass(ap, &pDCE);
        if ( !SUCCEEDED(hr) )
        {
            goto final_exit;
        }
        else if ( pcf )
        {
            // Create the instance and do the qi's
            Win4Assert(!pDCE);
            hr = GetObjectHelperMulti( pcf,
                grfMode,
                punkOuter,
                pwszName,
                pstg,
                dwCount,
                NULL,
                NULL,
                NULL,
                pResults ,
                NULL);
            
        }
        else
        {
            //
            // do COM+ activation
            //
            
            // Initialize activation properties
            // Allocate In on stack
            
            // split the array of structs into individual arrays
            CSplit_QI    SplitQI( hr, dwCount, pResults );
            
            IActivationPropertiesOut* pOutActivationProperties=0;   // output
            if (!pActIn)
            {
                pActIn=(ActivationPropertiesIn*)
                    _alloca(sizeof(ActivationPropertiesIn));
                pActIn->ActivationPropertiesIn::ActivationPropertiesIn();
                pActIn->SetNotDelete(TRUE);
            }
            
            AddHydraSessionID(pActIn);
            
            AddPartitionID(pActIn);
            
            if ( FAILED(hr) )
                goto exit_point;
            
            DLL_INSTANTIATION_PROPERTIES *pdip;
            IComClassInfo *pCI = NULL;
            
            if ( pDCE )
            {
                pdip = (DLL_INSTANTIATION_PROPERTIES *)
                    _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES));
                pdip->_pDCE = pDCE;
                pCI = pdip->_pDCE->_pClassEntry->_pCI;
                if ( pCI )
                {
                    pCI->AddRef();
                }
            }
            else
            {
                pdip = NULL;
            }
            
            BOOL fRetry=FALSE, fDownloadDone = FALSE, bClassEnabled = TRUE;
            DWORD relCount = 0;
            
            do
            {
                if ( fRetry )
                {
                    relCount = pActIn->Release();
                    Win4Assert(relCount==0);
                    
                    pActIn = new ActivationPropertiesIn;
                    if ( pActIn == NULL )
                        return E_OUTOFMEMORY;
                    fRetry = FALSE; // start with the assumption of termination
                }
                
                Win4Assert(pActIn != NULL);
                
                hr = GetActivationPropertiesIn(
                    pActIn,
                    clsid,
                    dwClsCtx,
                    pServerInfo,
                    dwCount,
                    SplitQI._pIIDArray,
                    actvflags,
                    pdip,
                    pCI);
                
                
                if(SUCCEEDED(hr))
                {
                    HRESULT TempHR; //This is here because it is OK to fail and we use hr later
                    IComClassInfo2 *pCI2 = NULL;
                    
                    if(!pCI)
                    {
                        pCI = pActIn->GetComClassInfo();
                        Win4Assert(pCI != NULL);
                        pCI->AddRef(); 
                    }
                    
                    TempHR = pCI->QueryInterface(IID_IComClassInfo2, (void **)&pCI2); 
                    if(SUCCEEDED(TempHR))
                    {
                        pCI2->IsEnabled(&bClassEnabled);
                        pCI2->Release();
                    }
                }
                
                if ( pCI )
                {
                    pCI->Release();
                    pCI = NULL;
                }
                
                
                
                if ( FAILED(hr) )
                {
                    pActIn->Release();      
                    goto exit_point;
                }
                
                if(bClassEnabled == FALSE)
                {
                    pActIn->Release(); 
                    hr = CO_E_CLASS_DISABLED;
                    goto exit_point;
                }
                
                
                // Tell about the remote activation
                InstanceInfo *pInstanceInfo = pActIn->GetPersistInfo();
                pInstanceInfo->SetStorage(pstg);
                pInstanceInfo->SetFile(pwszName, grfMode);
                
RETRY_ACTIVATION:                   
                // Start off activation at the beginning of client context stage
                IActivationStageInfo *pStageInfo = (IActivationStageInfo*) pActIn;
                hr = pStageInfo->SetStageAndIndex(CLIENT_CONTEXT_STAGE,0);
                if (FAILED (hr))
                {
                    pActIn->Release();      
                    goto exit_point;
                }
                    
                
                // This is the whole activation process
                hr = hrSave = pActIn->DelegateCreateInstance(punkOuter,
                    &pOutActivationProperties);
                
                // If the delegated activation returns ERROR_RETRY,
                // we walk the chain again, but AT MOST ONCE.
                // This is to support the private activations.
                if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr) 
                {
                    Win4Assert(!nRetries);
                    if (!nRetries)
                    {
                        BOOL fEnabled = TRUE;

                        GetClassInfoFlags(pActIn, &fEnabled, NULL, NULL);
                                     
                        if (!fEnabled)
                        {   
                            hr = CO_E_CLASS_DISABLED;
                            pActIn->Release();      
                            goto exit_point;
                        }
                
                        nRetries++;
                        goto RETRY_ACTIVATION;
                    }
                }
                
#ifdef DIRECTORY_SERVICE
                
                if ( FAILED(hr) && !(dwClsCtx & CLSCTX_NO_CODE_DOWNLOAD) )
                {
                    //download class if not registered locally -- but only once!
                    if ( (REGDB_E_CLASSNOTREG == hr) && !fDownloadDone )
                    {
                        //if successful, this will add a darwin id to the registry
                        hr = DownloadClass(clsid,dwClsCtx);
                        fDownloadDone = fRetry = SUCCEEDED(hr);
                    }
                    
                    if ( hr == CS_E_PACKAGE_NOTFOUND )
                    {
                        hr = REGDB_E_CLASSNOTREG;
                    }                    
                }
#endif //DIRECTORY_SERVICE
                
                
            } while ( fRetry );
            
            
            
            if ( SUCCEEDED(hr) )
            {
                Win4Assert(pOutActivationProperties != NULL);
                if (pOutActivationProperties == NULL)
                {
                    hr = E_UNEXPECTED;
                }
                else
                {
                    hr = pOutActivationProperties->GetObjectInterfaces(dwCount,
                        actvflags,
                        pResults);
                }
            }
            
            if ( pOutActivationProperties )
            {
                relCount = pOutActivationProperties->Release();
                Win4Assert(relCount==0);
            }
            
            
            // Since doing an alloca, must release in after out
            // since actout may be contained by actin for
            // performance optimization
            relCount = pActIn->Release();
            Win4Assert(relCount==0);
            
            if ( pDCE )
            {
                LOCK(CClassCache::_mxs);
                pDCE->Unlock();
                UNLOCK(CClassCache::_mxs);
            }
        }
    }
    
exit_point:
    
    hr = UpdateResultsArray( hr, dwCount, pResults );
    
final_exit:
    
    if ( pcf != NULL)
    {
        pcf->Release();
    }
    
    return hr;
    
dde_exit:
    
    if ( hr != MK_E_CANTOPENFILE )
    {
        COleTls Tls;
        if ( Tls->dwFlags & OLETLS_DISABLE_OLE1DDE )
        {
            // If this app doesn't want or can tolerate having a DDE
            // window then currently it can't use OLE1 classes because
            // they are implemented using DDE windows.
            //
            hr = CO_E_OLE1DDE_DISABLED;
            goto final_exit;
        }
        
        hr = DdeBindToObject(pwszName,
            clsid,
            FALSE,
            IID_IUnknown,
            (void **)&punk);
        
        if ( FAILED(hr) )
            goto final_exit;
    }
    // FALLTHRU to qi exit point
    
qiexit_point:
    
    // Get the requested interfaces
    for ( i = 0; i<dwCount; i++ )
    {
        pResults[i].hr = punk->QueryInterface(*(pResults[i].pIID),
            (void**)&pResults[i].pItf );
    }
    punk->Release();
    
    // Got object from ROT so we are done.
    goto exit_point;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetInstanceHelperMulti
//
//  Synopsis:   Creates an instance
//
//  Arguments:  [pcf] - class factory
//              [grfMode] - mode to use when loading file
//              [pwszName] - file path to persistent storage
//              [pstg] - storage for persistent storage
//              [ppvUnk] - pointer to IUnknown
//
//  Returns:    S_OK - object successfully instantiated
//
//  Algorithm:  Create an empty instance of the object and then use
//              either the provided storage or file to load the object.
//
//  History:    12-May-93 Ricksa    Created
//
//  Notes:      This helper is called by by servers and clients
//
//--------------------------------------------------------------------------
HRESULT GetInstanceHelperMulti(
                              IClassFactory *pcf,
                              DWORD dwInterfaces,
                              IID * pIIDs,
                              MInterfacePointer **ppIFDArray,
                              HRESULT * pResultsArray,
                              IUnknown **ppunk,
                              CDestObject *pDestObj)
{
    XIUnknown xunk;

    // Get the controlling unknown for the instance.
    HRESULT hr = pcf->CreateInstance(NULL, IID_IUnknown, (void **) &xunk);

    // This shouldn't fail but it is untrusted code ...
    if ( FAILED(hr) || !xunk)
    {
        if (SUCCEEDED (hr))
            hr = E_OUTOFMEMORY;

        if ( ppIFDArray )
            for ( DWORD i=0; i< dwInterfaces; i++ )
            {
                ppIFDArray[i] = NULL;
                pResultsArray[i] = E_FAIL;
            }

        return hr;
    }

    // If an interface buffer was passed in, then this is a remote call
    // and we need to marshal the interface.
    if ( ppIFDArray )
    {
        // AddRef the pointer because MarshalHelper expects to release
        // pointer. Because MarshalHelper is called from two other places,
        // we do an AddRef here instead of moving the AddRef out of
        // MarshalHelper.
        xunk->AddRef();
        hr = MarshalHelperMulti(xunk, dwInterfaces, pIIDs, ppIFDArray, pResultsArray,
                                pDestObj);

        if ( ppunk )
        {
            xunk.Transfer(ppunk);
        }

        return hr;
    }
    else
    {
        // This is an inprocess server so we need to return the output
        // punk
        xunk.Transfer(ppunk);
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   MarshalHelper
//
//  Synopsis:   Marshals an Interface
//
//  Arguments:  [punk] - interface to marshal
//              [riid] - iid to marshal
//              [ppIRD] - where to put pointer to marshaled data
//
//  Returns:    S_OK - object successfully marshaled.
//
//  Algorithm:  Marshal the object and then get the pointer to
//              the marshaled data so we can give it to RPC
//
//  History:    12-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT MarshalHelper(
                     IUnknown *punk,
                     REFIID    riid,
                     DWORD     mshlflags,
                     InterfaceData **ppIRD)
{
    // Stream to put marshaled interface in
    CXmitRpcStream xrpc;

    // use MSHCTX_DIFFERENTMACHINE so we get the long form OBJREF
    HRESULT hr = CoMarshalInterface(&xrpc, riid, punk,
                                    SetMarshalContextDifferentMachine(),
                                    NULL, mshlflags);

    if ( SUCCEEDED(hr) )
    {
        xrpc.AssignSerializedInterface(ppIRD);
    }

    // We release our reference to this object here. Either we
    // are going to hand it out to the client, in which case, we
    // want to release it when the client is done or the marshal
    // failed in which case we want it to go away since we can't
    // pass it back to the client.
    punk->Release();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   MarshalHelperMulti
//
//  Synopsis:   Marshals a bunch of Interfaces
//
//  Arguments:  [punk] - interface to marshal
//              [riid] - iid to marshal
//              [ppIRD] - where to put pointer to marshaled data
//
//  Returns:    S_OK - object successfully marshaled.
//
//  Algorithm:  Marshal the object and then get the pointer to
//              the marshaled data so we can give it to RPC
//
//  History:    12-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT MarshalHelperMulti(
                          IUnknown *punk,
                          DWORD dwInterfaces,
                          IID * pIIDs,
                          MInterfacePointer **ppIFDArray,
                          HRESULT * pResultsArray,
                          CDestObject *pDestObj)
{
    HRESULT hr = E_NOINTERFACE;

    for ( DWORD i = 0; i<dwInterfaces; i++ )
    {
        // Stream to put marshaled interface in
        CXmitRpcStream xrpc;

        // use DIFFERENTMACHINE so we get the long form OBJREF
        HRESULT hr2 = CoMarshalInterface(&xrpc, pIIDs[i], punk,
                                         SetMarshalContextDifferentMachine(),
                                         pDestObj, MSHLFLAGS_NORMAL);

        pResultsArray[i] = hr2;
        if ( SUCCEEDED(hr2) )
        {
            xrpc.AssignSerializedInterface((InterfaceData**)&ppIFDArray[i]);
            hr = hr2;       // report OK if ANY interface was found
        }
        else
            ppIFDArray[i] = NULL;

    }

    // We release our reference to this object here. Either we
    // are going to hand it out to the client, in which case, we
    // want to release it when the client is done or the marshal
    // failed in which case we want it to go away since we can't
    // pass it back to the client.
    punk->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnMarshalHelper
//
//  Synopsis:
//
//  Arguments:  [pIFP] --
//              [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    10-10-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT UnMarshalHelper(MInterfacePointer *pIFP, REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;

    if ( pIFP && ppv )
    {
        CXmitRpcStream Stm((InterfaceData *) pIFP);

        *ppv = NULL;

        hr = CoUnmarshalInterface(&Stm, riid, ppv);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DoBetterUnmarshal
//
//  Synopsis:   Helper for unmarshaling an interface from remote
//
//  Arguments:  [pIFD] - serialized interface reference returned by SCM
//      [riid] - interface ID requested by application
//      [ppvUnk] - where to put pointer to returned interface
//
//  Returns:    S_OK - Interface unmarshaled
//
//  Algorithm:  Convert marshaled data to a stream and then unmarshal
//      to the right interface
//
//
//  History:    11-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT DoBetterUnmarshal(MInterfacePointer *&pIFD, REFIID riid, IUnknown **ppvUnk)
{
    // Convert returned interface to  a stream
    CXmitRpcStream xrpc( (InterfaceData*)pIFD );

    HRESULT hr = CoUnmarshalInterface(&xrpc, riid, (void **) ppvUnk);

    //CODEWORK: Stress revealed CoGetClassObject returning a null class factory
    // and S_OK
    Win4Assert(((hr == S_OK  &&  *ppvUnk != NULL)  ||
                (hr != S_OK  &&  *ppvUnk == NULL))
               &&  "DoBetterUnmarshal QueryInterface failure");

    MIDL_user_free(pIFD);
    pIFD = NULL;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   UnmarshalMultipleSCMResults
//
//  Synopsis:   Common routine for dealing with results from SCM
//
//  Arguments:  [sc] - SCODE returned by SCM
//      [pIFD] - serialized interface reference returned by SCM
//      [riid] - interface ID requested by application
//      [ppunk] - where to put pointer to returned interface
//      [pwszDllPath] - path to DLL if there is one.
//      [ppunk] - pointer to returned interface.
//      [usMethodOrdinal] - method for error reporting
//
//  Returns:    TRUE - processing is complete for the call
//      FALSE - this is a DLL and client needs to instantiate.
//
//  Algorithm:  If the SCODE indicates a failure, then this sets an
//      SCODE indicating that the service controller returned
//      an error and propagates the result from the SCM. Otherwise,
//      if the SCM has returned a result indicating that a
//      handler has been returned, the handler DLL is cached.
//      If a marshaled interface has been returned, then that is
//      unmarshaled. If an inprocess server has been returned,
//      the DLL is cached and the class object is created.
//
//  History:    11-May-93 Ricksa    Created
//
//  Notes:      This routine is simply a helper for CoGetPersistentInstance.
//
//--------------------------------------------------------------------------
void UnmarshalMultipleSCMResults(
                                HRESULT & hr,
                                PMInterfacePointer *pItfArray,
                                DWORD dwContext,
                                REFCLSID rclsid,
                                IUnknown * punkOuter,
                                DWORD dwCount,
                                IID * pIIDs,
                                HRESULT * pHrArray,
                                MULTI_QI * pResults)
{
    DWORD       i;
    HRESULT     hr2;
    IUnknown    * pUnk;

    if ( hr != S_OK )
        return;

    if ( punkOuter )
    {
        hr = CLASS_E_NOAGGREGATION;
        return;
    }

    for ( i=0; i<dwCount; i++, pResults++ )
    {
        pResults->hr = pHrArray[i];

        if ( SUCCEEDED( pHrArray[i] ) )
        {
            hr2 = DoBetterUnmarshal( pItfArray[i],
                                     *(pResults->pIID),
                                     &pResults->pItf);

            // Try to set the overall HR correctly
            pResults->hr = hr2;

            if ( FAILED( hr2 ) )
                hr = CO_S_NOTALLINTERFACES;
        }
        else
        {
            hr = CO_S_NOTALLINTERFACES;
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   RemapClassCtxForInProcServer
//
//  Synopsis:   Remap CLSCTX so that the correct type of inproc server will
//              be requested.
//
//  Arguments:  [dwCtrl] - requested server context
//
//  Returns:    Updated dwCtrl appropriate for the process' context
//
//  Notes:      If an inproc server is requested make sure it is the right
//              type for the process. In other words, we only load 16 bit
//              inproc servers into 16 bit processes and 32 bit servers
//              into 32 bit processes. The special logic here is only for
//              16 bit servers since the attempt to load a 16-bit DLL into
//              a 32 bit process will fail anyway.
//
//  History:    01-11-95    Ricksa      Created
//
//+-------------------------------------------------------------------------
DWORD RemapClassCtxForInProcServer(DWORD dwCtrl)
{
    if ( IsWOWThread() )
    {
        // 16 bit process - remap CLSCTX_INPROC_SERVER if necessary
        if ( (dwCtrl & CLSCTX_INPROC_SERVER) != 0 )
        {
            // Turn on the 16 bit inproc server request and turn off the
            // 32 bit server request flag.
            dwCtrl = (dwCtrl & ~CLSCTX_INPROC_SERVER) | CLSCTX_INPROC_SERVER16;
        }
        // if handlers are requested make sure 16-bit is looked for first
        // We mask out 32bit handler flag for Wow threads because we will
        // always look for a 32 bit handler if we don't find a 16 bit one
        if ( (dwCtrl & CLSCTX_INPROC_HANDLER) != 0 )
        {
            // Turn on the 16 bit inproc handler request and turn off the
            // 32 bit handler request flag.
            dwCtrl = (dwCtrl & ~CLSCTX_INPROC_HANDLER) | CLSCTX_INPROC_HANDLER16;
        }
    }
    else
    {
        if ( (dwCtrl & CLSCTX_INPROC_SERVER) != 0 )
        {
            // Turn off the 16 bit inproc server request
            dwCtrl &= ~CLSCTX_INPROC_SERVER16;
        }
    }

    return dwCtrl;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsInternalCLSID
//
//  Synopsis:   checks if the given clsid is an internal class, and
//              bypasses the TreatAs and SCM lookup if so. Also checks for
//              OLE 1.0 classes, which are actually considered to be
//              internal, since their OLE 2.0 implementation wrapper is
//              ours.
//
//  Arguments:  [rclsid] - clsid to look for
//              [riid]   - the iid requested
//              [hr]     - returns the hresult from DllGetClassObject
//              [ppvClassObj] - where to return the class factory
//
//  Returns:    TRUE - its an internal class, hr is the return code from
//                     DllGetClassObject and if hr==S_OK ppvClassObj
//                     is the class factory.
//              FALSE - not an internal class
//
//  Notes:      internal classes can not be overridden because there are
//              other mechanisms for creating them eg CreateFileMoniker that
//              bypass implementation lookup.
//
//  History:    5-04-94     Rickhi      Created
//              5-04-94     KevinRo     Added OLE 1.0 support
//
//+-------------------------------------------------------------------------
BOOL IsInternalCLSID(
                    REFCLSID rclsid,
                    DWORD    dwContext,
                    REFIID   riid,
                    HRESULT  &hr,
                    void **  ppvClassObj)
{
    DWORD *ptr = (DWORD *) &rclsid;
    *ppvClassObj = NULL;

    if ( *(ptr+1) == 0x00000000 &&   //  all internal clsid's have these
         *(ptr+2) == 0x000000C0 &&   //   common values
         *(ptr+3) == 0x46000000 )
    {
        if ( IsEqualGUID(rclsid, CLSID_ATHostActivator) )
        {
            hr = ATHostActivatorGetClassObject(riid, ppvClassObj);
        }
        else if ( IsEqualGUID(rclsid, CLSID_MTHostActivator) )
        {
            hr = MTHostActivatorGetClassObject(riid, ppvClassObj);
        }
        else if ( IsEqualGUID(rclsid, CLSID_NTHostActivator) )
        {
            hr = NTHostActivatorGetClassObject(riid, ppvClassObj);
        }

        // Its possible that an OLE 1.0 class has been marked
        // as TREATAS as part of an upgrade. Here we are going
        // to handle the loading of OLE 1.0 servers. We
        // need to do the GetTreatAs trick first. Rather than
        // invalidate this perfectly good caching routine, the
        // GetTreatAs will only be done if the clsid is in the
        // range of the OLE 1.0 UUID's. Note that the GetTreatAs
        // done here will add the class to the cache, so if the
        // resulting class is outside of the internal range, the
        // lookup done later will be nice and fast.

        CLSID clsid  = rclsid;
        WORD  hiWord = HIWORD(clsid.Data1);

        if (hiWord == 3  ||  hiWord == 4)
        {
            // Its in the OLE 1.0 class range. See if it has
            // been marked as 'treatas'

            CCGetTreatAs(rclsid, clsid);
            ptr = (DWORD *) &clsid;
            hiWord = HIWORD(clsid.Data1);
        }

        if ((*ptr >= MIN_INTERNAL_CLSID && *ptr <= MAX_INTERNAL_CLSID       &&
            (dwContext & (CLSCTX_INPROC_SERVERS | CLSCTX_INPROC_HANDLERS))) ||
             (hiWord == 3  ||  hiWord == 4) || (*ptr == 0x0002e005) )
        {
            //  internal class (eg file moniker) or an OLE 1.0 class.

           hr = DllGetClassObject(clsid, riid, ppvClassObj);
           return TRUE;
        }
    }

    if ( IsEqualGUID(rclsid, CLSID_VSA_IEC) )
    {
        // this is Vista EventLog class ID
        hr = LogEventGetClassObject(riid, ppvClassObj);
        return TRUE;
    }
    else if( IsEqualGUID( rclsid, CLSID_ThumbnailUpdater ) )
    {
        hr = DllGetClassObject(rclsid, riid, ppvClassObj);
        return TRUE;
    }

    // not an internal class.
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindOrCreateApartment
//
//  Synopsis:   Searches the cache for requested classid.
//              If not found looks to see if an inproc server or handler
//              can be loaded (if requested).
//
//  Arguments:  [Clsid]         Class ID
//              [ClassContext]  Which context to load
//              [DllServerType] ???
//              [pwszDllServerPath] returned dll path
//
//  Returns:    S_OK - Class factory for object
//              otherwise - Class factory could not be found or
//                      constructed.
//
//  History:    2-5-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
FindOrCreateApartment(
                     REFCLSID     Clsid,
                     DWORD        actvflags,
                     DLL_INSTANTIATION_PROPERTIES *pdip,
                     HActivator *phActivator
                     )
{
    // CLSID and Partition are ignored here...
    ACTIVATION_PROPERTIES ap(Clsid, 
                             GUID_NULL,
                             GUID_NULL, 
                             0,
                             pdip->_dwContext, 
                             actvflags, 
                             0, 
                             NULL, 
                             NULL);
    return CCGetOrCreateApartment(ap, pdip, phActivator);
}



// Helper routine to find the apartment activator for the default apartment
// for activating the given class


//+-------------------------------------------------------------------------
//
//  Function:   UpdateResultsArray
//
//  Synopsis:   Helper for returning the correct hr from a multi-qi call
//
//  Arguments:  [hrIn]          - hr from the calling function
//              [dwCount]       - number of IIDs requested
//              [pResults]      - where to put pointer to returned interface
//
//  Returns:    S_OK - All Interface are OK
//
//  History:    30-Aug-95 GregJen    Created
////
//--------------------------------------------------------------------------
HRESULT
UpdateResultsArray( HRESULT hrIn, DWORD dwCount, MULTI_QI * pResults )
{
    HRESULT     hr = hrIn;
    DWORD       i;

    // make sure the HR is set correctly
    if ( SUCCEEDED( hrIn ) )
    {
        // assume no interfaces were found
        DWORD   dwFound = 0;
        for ( i=0; i<dwCount; i++ )
        {
            if ( FAILED( pResults[i].hr ) )
                pResults[i].pItf        = NULL;
            else
            {
                dwFound++;
                Win4Assert(pResults[i].pItf != NULL );
            }
        }

        if ( dwFound == 0 )
        {
            // if there was only 1 interface, return its hr.
            if ( dwCount == 1 )
                hr = pResults[0].hr;
            else
                hr = E_NOINTERFACE;
        }
        else if ( dwFound < dwCount )
            hr = CO_S_NOTALLINTERFACES;
    }
    else
    {
        // failed - set all the hr's to the overall failure code,
        // and clean up any interface pointers we got
        for ( i=0; i<dwCount; i++ )
        {
            if ( pResults[i].pItf )
                pResults[i].pItf->Release();
            pResults[i].pItf    = NULL;
            pResults[i].hr      = hr;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   ValidateCoServerInfo
//
//  Synopsis:   returns S_OK if the COSERVERINFO structure supplied with the
//              call to a COM API function is valid.  Since this depends
//              on other parameters supplied to the API, those parameters must
//              be passed to this validation function.
//
//  Arguments:  [pServerInfo] - server information block to be validated
//
//+----------------------------------------------------------------------------
HRESULT ValidateCoServerInfo(COSERVERINFO* pServerInfo)
{
    if ( !pServerInfo )
    {
        return S_OK;
    }

    if ( !IsValidPtrIn( pServerInfo, sizeof(COSERVERINFO)) )
    {
        return E_INVALIDARG;
    }

    if ( pServerInfo->dwReserved2 )
    {
        return E_INVALIDARG;
    }

    // check the server name
    if ( pServerInfo->pwszName && !IsValidPtrIn(pServerInfo->pwszName, sizeof(WCHAR)) )
    {
        return E_INVALIDARG;
    }

    // validate the COAUTHINFO
    if ( pServerInfo->pAuthInfo && !IsValidPtrIn(pServerInfo->pAuthInfo, sizeof(COAUTHINFO)) )
    {
        return E_INVALIDARG;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReleaseMQI
//
//  Synopsis:   Frees all the interfaces in an array of MULTI_QI's
//              Resets the members of each element to values
//              indicating activation failure
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------
void ReleaseMQI(MULTI_QI* pResults, DWORD dwCount)
{
    Win4Assert("Invalid Number of Interfaces in MQI" && ((LONG) dwCount >= 0));

    for ( DWORD i = 0; i < dwCount; i++ )
    {
        if ( pResults[i].pItf )
        {
            pResults[i].pItf->Release();
            pResults[i].pItf = NULL;
            pResults[i].hr = E_NOINTERFACE;
        }
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   CSplit_QI constructor
//
//  Synopsis:   Helper for allocating the arrays for a multi-qi call
//
//  Arguments:  [hr]            - hr to return by reference
//              [count]         - number of IIDs requested
//              [pInputArray]   - the MULTI_QI structure passed in to us
//
//  Returns:    S_OK - everything set up OK
//
//  History:    01-Dec-95 GregJen    Created
////
//--------------------------------------------------------------------------
CSplit_QI::CSplit_QI( HRESULT & hr, DWORD count, MULTI_QI * pInputArray )
{
    _pAllocBlock     = NULL;
    _pItfArray       = NULL;
    _dwCount         = count;

    // if they only asked for 1 or 2, save time by just using
    // our memory on the stack
    if ( count <= 2 )
    {
        _pItfArray       = SomePMItfPtrs;
        _pHrArray        = SomeHRs;
        _pIIDArray       = SomeIIDs;

        for ( DWORD i = 0; i < count; i++ )
        {
            _pIIDArray[i] = *(pInputArray[i].pIID);
        }

        memset( _pItfArray, 0, sizeof(SomePMItfPtrs) );

        hr = S_OK;
        return;
    }

    ULONG ulItfArrSz = count * sizeof( PMInterfacePointer );
    ULONG ulHRArrSz  = count * sizeof( HRESULT );
    ULONG ulIIDArrSz = count * sizeof( IID );

    _pAllocBlock = (char * )PrivMemAlloc( ulItfArrSz +
                                          ulHRArrSz  +
                                          ulIIDArrSz );
    if ( _pAllocBlock )
    {
        hr = S_OK;

        // carve up the allocated block
        _pItfArray = (PMInterfacePointer *) _pAllocBlock;
        _pHrArray = (HRESULT *) (_pAllocBlock +
                                 ulItfArrSz );
        _pIIDArray = (IID * ) ( _pAllocBlock +
                                ulItfArrSz +
                                ulHRArrSz );

        // copy the IIDs and zero the MInterfacePointers
        for ( DWORD i = 0; i < count; i++ )
        {
            _pIIDArray[i] = *(pInputArray[i].pIID);
        }
        memset( _pItfArray, 0, ulItfArrSz );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

}
//+-------------------------------------------------------------------------
//
//  Function:   CSplit_QI destructor
//
//  Synopsis:   Helper for freeing the arrays for a multi-qi call
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    01-Dec-95 GregJen    Created
//
//--------------------------------------------------------------------------
CSplit_QI::~CSplit_QI()
{
    // make sure to clean up any dangling interface pointers
    if ( _pItfArray )
    {
        for ( DWORD i = 0; i < _dwCount; i++ )
        {
            if ( _pItfArray[i] )
            {
                CXmitRpcStream xrpc( (InterfaceData*)_pItfArray[i] );

                CoReleaseMarshalData(&xrpc);

                MIDL_user_free(_pItfArray[i]);
                _pItfArray[i] = NULL;
            }
        }
    }

    // only do the free if we allocated something
    if ( _pAllocBlock )
    {
        PrivMemFree( _pAllocBlock );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   GetEmbeddingServerHandlerInterfaces
//
//  Synopsis:   Creates an instance of the server handler and the server object
//
//  Returns:    S_OK - object successfully instantiated
//
//  Algorithm:  Create the server object then create a server handler that points
//              to the server object.  The two are different objects.  Return only
//              the interfaces requested on the server handler object.
//              The client can get the server object by asking the server handler for it.
//
//  History:    08-oct-96 bchapman    Created
//
//  Notes:      This is called by ObjServerCreateInstance
//
//--------------------------------------------------------------------------
#ifdef SERVER_HANDLER
HRESULT GetEmbeddingServerHandlerInterfaces(
                                           IClassFactory *pcf,
                                           DWORD dwFlags,
                                           DWORD dwInterfaces,
                                           IID * pIIDs,
                                           MInterfacePointer **ppIFDArray,
                                           HRESULT * pResultsArray,
                                           IUnknown **ppunk,
                                           CDestObject *pDestObj)
{
    XIUnknown xunkServer;
    XIUnknown xunkESHandler;
    CStdIdentity *pStdid = NULL;
    HRESULT hr;

    //
    // Create the server object.
    //

    // make sure we got what was expected.
    Win4Assert(2 == dwInterfaces);
    Win4Assert(NULL != ppIFDArray);
    Win4Assert(IID_IUnknown == pIIDs[0]);
    Win4Assert(IID_IServerHandler == pIIDs[1]);
    Win4Assert(NULL == ppunk);



    ppIFDArray[0] = NULL;
    ppIFDArray[1] = NULL;
    pResultsArray[0] = E_NOINTERFACE;
    pResultsArray[1] = E_NOINTERFACE;

    // if the DISABLE_EMBEDDING_SERVER_HANDLER flags is set it means the real
    // object should be returned, else the ServerHandler.

    if ( DISABLE_EMBEDDING_SERVER_HANDLER & dwFlags )
    {
        // only allow Marshal of IID_IUnknown
        hr = GetInstanceHelperMulti(pcf,1,pIIDs,ppIFDArray,pResultsArray,ppunk,
                                    pDestObj);
        pResultsArray[1] = E_NOINTERFACE;
        ppIFDArray[1] = NULL;
        return hr;
    }


    //
    // Create the server handler w/ a pointer to the server
    //

    hr = pcf->CreateInstance(NULL, IID_IUnknown, (void **) &xunkServer);
    if ( FAILED(hr) )
        return hr;

    xunkServer->AddRef();
    hr = MarshalHelperMulti(xunkServer,1, &pIIDs[0], &ppIFDArray[0], &pResultsArray[0],
                            pDestObj);
    if ( FAILED(hr) )
        return hr;

    LookupIDFromUnk(xunkServer, GetCurrentApartmentId(), 0, &pStdid);

    if ( pStdid )
    {
        if ( !pStdid->IsClient() )
        {
            hr = CreateEmbeddingServerHandler(pStdid,&xunkESHandler);

            if ( SUCCEEDED(hr) )
            {
                xunkESHandler->AddRef();
                hr = MarshalHelperMulti(xunkESHandler,1, &pIIDs[1], &ppIFDArray[1], &pResultsArray[1], pDestObj);
            }

        }

        pStdid->Release();
    }

    return NOERROR; // return NOERROR even if ServerHandler was not created.
}
#endif // SERVER_HANDLER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\smstg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	smstg.cxx
//
//  Contents:	Implementation for class to handle marshaled data as stg.
//
//  Functions:	CSafeMarshaledStg::CSafeMarshaledStg
//		CSafeMarshaledStg::~CSafeMarshaledStg
//		CSafeStgMarshaled::CSafeStgMarshaled
//		CSafeStgMarshaled::~CSafeStgMarshaled
//
//  History:	14-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include <ole2int.h>

#include    <xmit.hxx>
#include    <smstg.hxx>


//+-------------------------------------------------------------------------
//
//  Member:	CSafeMarshaledStg::CSafeMarshaledStg
//
//  Synopsis:	Create an IStorage from a marshaled buffer
//
//  Arguments:	[pIFD] - marshaled interface pointer
//
//  Algorithm:	If pointer is not NULL, then unmarshal the interface.
//		If the interface cannot be unmarshaled throw an error.
//
//  History:	14-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CSafeMarshaledStg::CSafeMarshaledStg(InterfaceData *pIFD, HRESULT&hr)
    : _pstg(NULL)
{
    if (pIFD != NULL)
    {
	// Turn raw marshaled data into a stream
	CXmitRpcStream xrpc(pIFD);


	// Unmarshal data into an interface
	hr = CoUnmarshalInterface(&xrpc, IID_IStorage, (void **) &_pstg);
    }
    else
    {
	hr = S_OK;
    }
}




//+-------------------------------------------------------------------------
//
//  Member:	CSafeMarshaledStg::~CSafeMarshaledStg
//
//  Synopsis:	Release an IStorage that this class created
//
//  History:	14-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CSafeMarshaledStg::~CSafeMarshaledStg(void)
{
    if (_pstg)
    {
	_pstg->Release();
    }
}




//+-------------------------------------------------------------------------
//
//  Member:	CSafeStgMarshaled::CSafeStgMarshaled
//
//  Synopsis:	Create a marshaled interface from an IStorage
//
//  Arguments:	[pstg] - IStorage to marshal
//
//  History:	14-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CSafeStgMarshaled::CSafeStgMarshaled(IStorage *pstg, DWORD dwDestCtx, HRESULT& hr)
    : _pIFD(NULL)
{
    if (pstg != NULL)
    {
	// Turn raw interface into marshaled data
	CXmitRpcStream xrpc;

	if (SUCCEEDED(hr = CoMarshalInterface(&xrpc, IID_IStorage, pstg,
	    dwDestCtx, NULL, MSHLFLAGS_NORMAL)))
	{
	    // Hand of the serialized interface so we can use it
	    xrpc.AssignSerializedInterface(&_pIFD);
	}
    }
    else
    {
	hr = S_OK;
    }
}




//+-------------------------------------------------------------------------
//
//  Member:	CSafeStgMarshaled::~CSafeStgMarshaled
//
//  Synopsis:	Release marshaled data
//
//  History:	14-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CSafeStgMarshaled::~CSafeStgMarshaled(void)
{
    if (_pIFD)
    {
	delete _pIFD;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\immact.cxx ===
//+-------------------------------------------------------------------
//
//  File:       immact.cxx
//
//  Contents:   immediate activator
//
//  History:    15-Oct-98   Vinaykr     Created
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <immact.hxx>

//----------------------------------------------------------------------------
// Internal class factory for the COM Activator
//----------------------------------------------------------------------------
HRESULT CComActivatorCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    CComActivator *act =
           new CComActivator();

    if (act==NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = act->QueryInterface(riid, ppv);
    act->Release();
    return hr;
}

//----------------------------------------------------------------------------
// Methods from IUnknown
//----------------------------------------------------------------------------
STDMETHODIMP CComActivator::QueryInterface( REFIID riid, LPVOID* ppv)
{
 HRESULT hr;


    //-------------------------------------------------------------------
    //  Check for Top level interfaces
    //-------------------------------------------------------------------
    if (IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IStandardActivator))
        *ppv = (IStandardActivator*)this;
    else
    if (IsEqualIID(riid, IID_IOpaqueDataInfo))
        *ppv = (IOpaqueDataInfo*)this;
    else
    if (IsEqualIID(riid, IID_ISpecialSystemProperties))
        *ppv = (ISpecialSystemProperties*)this;
    else
    if (IsEqualIID(riid, IID_IInitActivationPropertiesIn))
        *ppv = (IInitActivationPropertiesIn*)this;
    else
        *ppv = NULL;

    if (*ppv != NULL)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG CComActivator::AddRef(void)
{
   return InterlockedIncrement(&_ulRef);
}


ULONG CComActivator::Release(void)
{
   ULONG count;

   if ((count = InterlockedDecrement(&_ulRef)) == 0)
   {
       delete this;
       return 0;
   }

   return count;
}


//----------------------------------------------------------------------------
// Methods from IStandardActivator
//----------------------------------------------------------------------------

STDMETHODIMP CComActivator::StandardGetClassObject (REFCLSID rclsid,
                                      DWORD dwContext,
                                      COSERVERINFO *pServerInfo,
                                      REFIID riid,
                                      void **ppvClassObj)
{
    // Create ActivationPropertiesIn on stack
    ActivationPropertiesIn actIn;
    actIn.SetNotDelete();

    // Initialize Actprops with set stuff
    InitializeActivation(&actIn);

    return DoGetClassObject(rclsid,
                            dwContext,
                            pServerInfo,
                            riid,
                            ppvClassObj,
                            &actIn);
}

STDMETHODIMP CComActivator::StandardCreateInstance (REFCLSID Clsid,
                                      IUnknown *punkOuter,
                                      DWORD dwClsCtx,
                                      COSERVERINFO *pServerInfo,
                                      DWORD dwCount,
                                      MULTI_QI *pResults)
{
    // Create ActivationPropertiesIn on stack
    ActivationPropertiesIn actIn;
    actIn.SetNotDelete();

    // Initialize Actprops with set stuff
    InitializeActivation(&actIn);

    return DoCreateInstance(Clsid,
                            punkOuter,
                            dwClsCtx,
                            pServerInfo,
                            dwCount,
                            pResults,
                            &actIn);

}

STDMETHODIMP CComActivator::StandardGetInstanceFromFile 
                                      (COSERVERINFO *pServerInfo,
                                       CLSID        *pclsidOverride,
                                       IUnknown     *punkOuter,
                                       DWORD        dwClsCtx,
                                       DWORD        grfMode,
                                       OLECHAR      *pwszName,
                                       DWORD        dwCount,
                                       MULTI_QI     *pResults )
{
    // Create ActivationPropertiesIn on stack
    ActivationPropertiesIn actIn;
    actIn.SetNotDelete();

    // Initialize Actprops with set stuff
    InitializeActivation(&actIn);


    return DoGetInstanceFromFile( pServerInfo,
                                  pclsidOverride,
                                  punkOuter,
                                  dwClsCtx,
                                  grfMode,
                                  pwszName,
                                  dwCount,
                                  pResults,
                                  &actIn);
}

STDMETHODIMP CComActivator::StandardGetInstanceFromIStorage 
                                      (COSERVERINFO *pServerInfo,
                                       CLSID        *pclsidOverride,
                                       IUnknown     *punkOuter,
                                       DWORD        dwClsCtx,
                                       IStorage     *pstg,
                                       DWORD        dwCount,
                                       MULTI_QI     *pResults )
{
    // Create ActivationPropertiesIn on stack
    ActivationPropertiesIn actIn;
    actIn.SetNotDelete();

    // Initialize Actprops with set stuff
    InitializeActivation(&actIn);

    return DoGetInstanceFromStorage( pServerInfo,
                                     pclsidOverride,
                                     punkOuter,
                                     dwClsCtx,
                                     pstg,
                                     dwCount,
                                     pResults,
                                     &actIn);
}

STDMETHODIMP CComActivator::Reset ()
{
    ReleaseData();
    _pOpaqueData = NULL;
    _pProps = NULL;
    _fActPropsInitNecessary = FALSE;
    return S_OK;
}

//----------------------------------------------------------------------------
// Methods from IOpaqueDataInfo
//----------------------------------------------------------------------------

STDMETHODIMP CComActivator::AddOpaqueData (OpaqueData *pData)
{
    if (!_pOpaqueData)
        _pOpaqueData = new OpaqueDataInfo();

    if (!_pOpaqueData)
        return E_OUTOFMEMORY;

    _fActPropsInitNecessary = TRUE;

    return _pOpaqueData->AddOpaqueData(pData);
}

STDMETHODIMP CComActivator::GetOpaqueData (REFGUID guid,
                               OpaqueData **pData)
{
    Win4Assert(_pOpaqueData);
    if (!_pOpaqueData)
        return E_INVALIDARG; 

    return _pOpaqueData->GetOpaqueData(guid, pData);
}

STDMETHODIMP  CComActivator::DeleteOpaqueData (REFGUID guid)
{
    Win4Assert(_pOpaqueData);
    if (!_pOpaqueData)
        return E_INVALIDARG;

    return _pOpaqueData->DeleteOpaqueData(guid);
}

STDMETHODIMP  CComActivator::GetOpaqueDataCount (ULONG *pulCount)
{
    Win4Assert(_pOpaqueData);
    if (!_pOpaqueData)
        return E_INVALIDARG;

    return _pOpaqueData->GetOpaqueDataCount(pulCount);
}

STDMETHODIMP  CComActivator::GetAllOpaqueData (OpaqueData **prgData)
{
    Win4Assert(_pOpaqueData);
    if (!_pOpaqueData)
        return E_INVALIDARG;

    return _pOpaqueData->GetAllOpaqueData(prgData);
}


//----------------------------------------------------------------------------
// Methods from ISpecialSystemProperties
//----------------------------------------------------------------------------
STDMETHODIMP CComActivator::SetSessionId (ULONG dwSessionId, BOOL bUseConsole, BOOL fRemoteThisSessionId)
{
    if (!_pProps)
    {
        _pProps = new SpecialProperties();
        if (!_pProps)
            return E_OUTOFMEMORY;

        _fActPropsInitNecessary = TRUE;
    }

    _pProps->SetSessionId(dwSessionId, bUseConsole, fRemoteThisSessionId);

    return S_OK;
}

STDMETHODIMP CComActivator::GetSessionId (ULONG *pdwSessionId, BOOL* pbUseConsole)
{
    Win4Assert(_pProps);
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetSessionId(pdwSessionId, pbUseConsole);
}

STDMETHODIMP CComActivator::GetSessionId2 (ULONG *pdwSessionId, BOOL* pbUseConsole, BOOL* pfRemoteThisSessionId)
{
    Win4Assert(_pProps);
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetSessionId2(pdwSessionId, pbUseConsole, pfRemoteThisSessionId);
}

STDMETHODIMP CComActivator::SetClientImpersonating (BOOL fClientImpersonating)
{
    Win4Assert(_pProps);
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->SetClientImpersonating(fClientImpersonating);
}

STDMETHODIMP CComActivator::GetClientImpersonating (BOOL* pfClientImpersonating)
{
    Win4Assert(_pProps);
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetClientImpersonating(pfClientImpersonating);
}

STDMETHODIMP CComActivator::SetPartitionId (REFGUID guidPartition)
{
   if (!_pProps)
   {
       _pProps = new SpecialProperties();
       if (!_pProps)
	   return E_OUTOFMEMORY;

       _fActPropsInitNecessary = TRUE;
   }

   _pProps->SetPartitionId(guidPartition);

   return S_OK;

}

STDMETHODIMP CComActivator::GetPartitionId (GUID *pguidPartition)
{
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetPartitionId(pguidPartition);
}

STDMETHODIMP CComActivator::SetProcessRequestType (DWORD dwPRT)
{
    if (!_pProps)
    {
        _pProps = new SpecialProperties();
        if (!_pProps)
            return E_OUTOFMEMORY;

        _fActPropsInitNecessary = TRUE;
    }

    return _pProps->SetProcessRequestType(dwPRT);
}


STDMETHODIMP CComActivator::GetProcessRequestType (DWORD* pdwPRT)
{
    Win4Assert(_pProps);
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetProcessRequestType(pdwPRT);
}

STDMETHODIMP CComActivator::SetOrigClsctx(DWORD dwClsctx)
{


   if (!_pProps)
   {
       _pProps = new SpecialProperties();
       if (!_pProps)
	   return E_OUTOFMEMORY;

       _fActPropsInitNecessary = TRUE;
   }

   _pProps->SetOrigClsctx(dwClsctx);

   return S_OK;

}

STDMETHODIMP CComActivator::GetOrigClsctx(DWORD *pdwClsCtx)
{
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetOrigClsctx(pdwClsCtx);
}


STDMETHODIMP CComActivator::GetDefaultAuthenticationLevel(DWORD *pdwAuthnLevel)
{
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->GetDefaultAuthenticationLevel(pdwAuthnLevel);
}

STDMETHODIMP CComActivator::SetDefaultAuthenticationLevel(DWORD dwAuthnLevel)
{
    if (!_pProps)
        return E_INVALIDARG;

    return _pProps->SetDefaultAuthenticationLevel(dwAuthnLevel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   objact
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..;..\..\inc
INCLUDES=     $(INCLUDES);..\..\dcomrem
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\cs\inc
INCLUDES=     $(INCLUDES);..\..\..\actprops
INCLUDES=     $(INCLUDES);..\..\moniker2
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

SOURCES=      \
              ..\actvator.cxx \
              ..\dllcache.cxx \
              ..\dllhost.cxx  \
              ..\actapi.cxx   \
              ..\dllapi.cxx   \
              ..\dsapi.cxx    \
              ..\objact.cxx   \
              ..\smstg.cxx    \
              ..\sobjact.cxx  \
              ..\mainthrd.cxx \
              ..\defcxact.cxx \
              ..\immact.cxx

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\objact\sobjact.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       sobjact.cxx
//
//  Contents:   Activation Functions used by object servers.
//
//  Functions:  CoRegisterClassObject
//              CoRevokeClassObject
//              CoAddRefServerProcess
//              CoReleaseServerProcess
//              CoSuspendClassObjects
//
//  Classes:    CObjServer
//
//  History:    12-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <iface.h>
#include    <olerem.h>

#include    <cfactory.hxx>
#include    <classmon.hxx>
#include    "resolver.hxx"
#include    "smstg.hxx"
#include    "objact.hxx"
#include    "service.hxx"
#include    <sobjact.hxx>
#include    <comsrgt.hxx>
#include    <excepn.hxx>    // AppInvokeExceptionFilter
#include    "defcxact.hxx"

CObjServer *gpMTAObjServer = NULL;
CObjServer *gpNTAObjServer = NULL;
static COleStaticMutexSem g_mxsSingleThreadObjReg;

extern BOOL gAutoInputSync;
extern BOOL gEnableAgileProxies;

//+-------------------------------------------------------------------------
//
//  Function:   GetOrCreateObjServer, internal
//
//  Synopsis:   Helper function to get or create the TLS or global object server.
//              Created to allow Win95 servers to do lazy init.
//
//  Arguments:  [ppObjServer] - where to return the ObjServer pointer
//
//  History:    23-Sep-96 Murthys    Created
//
//--------------------------------------------------------------------------
HRESULT GetOrCreateObjServer(CObjServer **ppObjServer)
{
    HRESULT hr = S_OK;

    // thread safe incase we are in MultiThreaded model.
    COleStaticLock lck(g_mxsSingleThreadObjReg);

    // Make sure an instance of CObjServer exists for this thread.
    // The SCM will call back on it to activate objects.

    *ppObjServer = GetObjServer();

    if (*ppObjServer == NULL)
    {
        // no activation server for this apartment yet, go make one now.

        hr = E_OUTOFMEMORY;
        *ppObjServer = new CObjServer(hr);

        if (FAILED(hr))
        {
            delete *ppObjServer;
            *ppObjServer = NULL;
        }
        else
        {
            // If we want to service OLE1 clients, we need to create the
            // common Dde window now if it has not already been done.
            CheckInitDde(TRUE /* registering server objects */);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoRegisterClassObject, public
//
//  Synopsis:   Register a class object in the requested context
//
//  Arguments:  [rclsid] - class ID
//              [pUnk] - class object
//              [dwContext] - context to register it in
//              [flags] - single/multiple use.
//              [lpdwRegister] - registration cookie
//
//  Returns:    S_OK - object is successfully registered
//
//  Algorithm:  Validate the parmeters. The get the class factory interface.
//              Then add the class object to the list and finally notify
//              the SCM that the service is started.
//
//  History:    12-May-93 Ricksa    Created
//              26-Jul-94 AndyH     #20843 - restarting OLE in the shared WOW
//
//--------------------------------------------------------------------------
STDAPI  CoRegisterClassObject(
    REFCLSID rclsid,
    IUnknown FAR* pUnk,
    DWORD dwContext,
    DWORD flags,
    LPDWORD lpdwRegister)
{
    HRESULT hr;
    CLSID ConfClsid;

    OLETRACEIN((API_CoRegisterClassObject,
        PARAMFMT("rclsid= %I, pUnk= %p, dwContext= %x, flags= %x, lpdwRegister= %p"),
        &rclsid, pUnk, dwContext, flags, lpdwRegister));

    if (!IsApartmentInitialized())
    {
        hr = CO_E_NOTINITIALIZED;
        goto errRtn;
    }

    // Validate the out parameter
    if (!IsValidPtrOut(lpdwRegister, sizeof(DWORD)))
    {
        CairoleAssert(IsValidPtrOut(lpdwRegister, sizeof(DWORD))  &&
                      "CoRegisterClassObject invalid registration ptr");
        hr = E_INVALIDARG;
        goto errRtn;
    }
    *lpdwRegister = 0;

    // Validate the pUnk
    if (!IsValidInterface(pUnk))
    {
        CairoleAssert(IsValidInterface(pUnk)  &&
                      "CoRegisterClassObject invalid pUnk");
        hr = E_INVALIDARG;
        goto errRtn;
    }

    hr = LookForConfiguredClsid(rclsid, ConfClsid);
    if (FAILED(hr) && (hr != REGDB_E_CLASSNOTREG))
        goto errRtn;


    // Hook the pUnk
    CALLHOOKOBJECT(S_OK,ConfClsid,IID_IClassFactory,&pUnk);

    // Validate context flags
    if ((dwContext & (~(CLSCTX_ALL | CLSCTX_INPROC_SERVER16) |
                      CLSCTX_INPROC_HANDLER | CLSCTX_NO_CODE_DOWNLOAD)) != 0)
    {
        hr = E_INVALIDARG;
        goto errRtn;
    }

    // Validate flag flags
    if (flags > (REGCLS_SUSPENDED | REGCLS_MULTI_SEPARATE | REGCLS_SURROGATE))
    {
        hr =  E_INVALIDARG;
        goto errRtn;
    }

    if ((flags & REGCLS_SURROGATE) && !(dwContext & CLSCTX_LOCAL_SERVER))
    {
        hr = E_INVALIDARG;
        goto errRtn;
    }


    if (flags & REGCLS_MULTIPLEUSE)
    {
        dwContext |= CLSCTX_INPROC_SERVER;
    }

    if (dwContext & CLSCTX_LOCAL_SERVER)
    {
        BOOL fCreated;
        CObjServer *pObjServer;
        hr = GetOrCreateObjServer(&pObjServer);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    // Put our object in the server table
    hr = CCRegisterServer(ConfClsid, pUnk, dwContext, flags, lpdwRegister);

errRtn:
    OLETRACEOUT((API_CoRegisterClassObject, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoRevokeClassObject, public
//
//  Synopsis:   Revoke a previously registered class object
//
//  Arguments:  [dwRegister] - registration key returned from CoRegister...
//
//  Returns:    S_OK - class successfully deregistered.
//
//  Algorithm:  Ask cache to deregister the class object.
//
//  History:    12-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDAPI  CoRevokeClassObject(DWORD dwRegister)
{
    OLETRACEIN((API_CoRevokeClassObject, PARAMFMT("dwRegister= %x"), dwRegister));

    HRESULT hr = CO_E_NOTINITIALIZED;

    if (IsApartmentInitialized())
    {
        // Try to revoke the object
        hr = CCRevoke(dwRegister);
    }

    OLETRACEOUT((API_CoRevokeClassObject, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoAddRefServerProcess, public
//
//  Synopsis:   Increments the global per-process server reference count.
//              See CDllCache::AddRefServerProcess for more detail.
//
//  History:    17-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------------
STDAPI_(ULONG)  CoAddRefServerProcess(void)
{
    return CCAddRefServerProcess();
}

//+-------------------------------------------------------------------------
//
//  Function:   CoReleaseServerProcess, public
//
//  Synopsis:   Decrements the global per-process server reference count.
//              See CDllCache::ReleaseServerProcess for more detail.
//
//  History:    17-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------------
STDAPI_(ULONG)  CoReleaseServerProcess(void)
{
    return CCReleaseServerProcess();
}

//+-------------------------------------------------------------------------
//
//  Function:   CoSuspendClassObjects, public
//
//  Synopsis:   suspends all registered LOCAL_SERVER class objects for this
//              process so that no new activation calls from the SCM will
//              be accepted.
//
//  History:    17-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------------
STDAPI CoSuspendClassObjects(void)
{
    return CCSuspendProcessClassObjects();
}

//+-------------------------------------------------------------------------
//
//  Function:   CoResumeClassObjects, public
//
//  Synopsis:   resumes all registered LOCAL_SERVER class objects for this
//              process that are currently marked as SUSPENDED, so that new
//              activation calls from the SCM will now be accepted.
//
//  History:    17-Apr-96   Rickhi  Created
//
//--------------------------------------------------------------------------
STDAPI CoResumeClassObjects(void)
{
    return CCResumeProcessClassObjects();
}

//+-------------------------------------------------------------------
//
//  Member:     ObjactThreadUninitialize
//
//  Synopsis:   Cleans up the CObjServer object.
//
//  History:    10 Apr 95   AlexMit     Created
//
//--------------------------------------------------------------------
STDAPI_(void) ObjactThreadUninitialize(void)
{
    CObjServer *pObjServer = GetObjServer();
    if (pObjServer != NULL)
    {
        delete pObjServer;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   NotifyActivation
//
//  Synopsis:   Add/Remove implicit IClassFactory::LockServer during marshal
//              and last external release of an interface pointer.
//
//  Arguments:  [fLock] - whether to Lock or Unlock
//              [pUnk]  - ptr to object interface
//
//  Returns:    TRUE  - call again during last release
//              FALSE - dont call again during last release
//
//  History:    12-May-96   RickHi  Created
//
//  Notes:  there is an inherent race condition in the IClassFactory (and
//          derived interfaces) in that between the time a client gets the
//          ICF pointer and the time they call LockServer(TRUE), a server could
//          shut down. In order to plug this hole, COM's activation code will
//          attempt to do an implicit LockServer(TRUE) on the server side of
//          CoGetClassObject during the marshaling of the class object
//          interface. Since we dont know for sure that it is IClassFactory
//          being marshaled, we QI for it here.
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) NotifyActivation(BOOL fLock, IUnknown *pUnk)
{
    ComDebOut((DEB_ACTIVATE, "NotifyActivation fLock:%x pUnk:%x\n", fLock, pUnk));

    // If the object supports IClassFactory, do an implicit LockServer(TRUE)
    // on behalf of the client when the interface is first marshaled by
    // CoGetClassObject. When the last external reference to the interface is
    // release, do an implicit LockServer(FALSE).

    IClassFactory *pICF = NULL;

    _try
    {
        if (SUCCEEDED(pUnk->QueryInterface(IID_IClassFactory, (void **)&pICF)))
        {
            pICF->LockServer(fLock);
            pICF->Release();
            return TRUE;
        }
    }
    _except (AppInvokeExceptionFilter(GetExceptionInformation(), pUnk, IID_IClassFactory, 0))
    {
        ComDebOut((DEB_ACTIVATE | DEB_WARN, "NotifyActivation on 0x%p threw an exception\n", pUnk));
    }
    
    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoRegisterSurrogate, public
//
//  Synopsis:   Register an ISurrogate interface for a surrogate process
//
//  Arguments:  [pSurrogate] - existing ISurrogate interface ponter
//
//  Returns:    S_OK - object is successfully registered
//
//  Algorithm:  Validate the parameter. Then set a global pointer to the
//              value of the pSurrogate parameter
//
//  History:    2-Jun-96 t-AdamE    Created
//
//--------------------------------------------------------------------------
STDAPI  CoRegisterSurrogate(ISurrogate* pSurrogate)
{
    HRESULT hr;

    OLETRACEIN((API_CoRegisterSurrogate,
        PARAMFMT("pSurrogate= %p"),
        pSurrogate));

    gAutoInputSync = TRUE;
    gEnableAgileProxies = TRUE;

    if (!IsApartmentInitialized())
    {
        hr = CO_E_NOTINITIALIZED;
        goto errRtn;
    }

    // Validate the pSurrogate
    if (!IsValidInterface(pSurrogate))
    {
        CairoleAssert(IsValidInterface(pSurrogate)  &&
                      "CoRegisterSurrogate invalid pSurrogate");
        hr = E_INVALIDARG;
        goto errRtn;
    }

    hr = CCOMSurrogate::InitializeISurrogate(pSurrogate);

errRtn:
    OLETRACEOUT((API_CoRegisterSurrogate, hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\rot\access.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	    access.cxx
//
//  Contents:   Methods used for building a security descriptor.
//
//  History:    02-May-94 DonnaLi    Created
//              05-Nov-97 MikeW      Variable # of sids support
//
//--------------------------------------------------------------------------
extern "C"
{
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <ntseapi.h>
#include    <windows.h>
}

#include <ole2int.h>
#include    <rpc.h>
#include    <except.hxx>

#include    <memapi.hxx>
#include    <access.hxx>

extern PSID psidMySid;


//+-------------------------------------------------------------------------
//
//  Member:     CAccessInfo::~CAccessInfo
//
//  Synopsis:   Clean up buffers allocated for building the security
//              descriptor
//
//  History:    08-Jun-94 DonnaLi    Created
//
//--------------------------------------------------------------------------
CAccessInfo::~CAccessInfo (
    void
    )
{
    if (_pAbsoluteSdBuffer != NULL)
    {
        PrivMemFree (_pAbsoluteSdBuffer);
    }

    if (_pDace != NULL && _pDace != (PACCESS_ALLOWED_ACE)&_aDace[0])
    {
        PrivMemFree (_pDace);
    }

}
    
//+-------------------------------------------------------------------------
//
//  Member:	    CAccessInfo::IdentifyAccess
//
//  Synopsis:   Build a security descriptor that identifies who has what
//              access
//
//  Arguments:  [fScmIsOwner]   - whether SCM is the owner
//              [AppAccessMask] - access mask for the OLE application
//              [ScmAccessMask] - access mask for the SCM
//
//  Returns:    NULL - an error has occurred
//              ~NULL - pointer to the resulting security descriptor
//
//  History:    08-Jun-94 DonnaLi    Created
//
//--------------------------------------------------------------------------
PSECURITY_DESCRIPTOR
CAccessInfo::IdentifyAccess (
    BOOL        fScmIsOwner,
    ACCESS_MASK AppAccessMask,
    ACCESS_MASK ScmAccessMask
    )
{
    PSID        sids[2];
    ACCESS_MASK masks[2];

    sids[0] = _pAppSid;
    sids[1] = psidMySid;

    masks[0] = AppAccessMask;
    masks[1] = ScmAccessMask;

    return IdentifyAccessWorker(fScmIsOwner, 2, sids, masks);
}

PSECURITY_DESCRIPTOR
CAccessInfo::IdentifyAccess (
    BOOL                fScmIsOwner,
    ACCESS_MASK         AppAccessMask,
    ACCESS_MASK         ScmAccessMask,
    PSID                pExtraSid,
    ACCESS_MASK         ExtraAccessMask
    )
{
    PSID        sids[3];
    ACCESS_MASK masks[3];

    sids[0] = _pAppSid;
    sids[1] = psidMySid;
    sids[2] = pExtraSid;

    masks[0] = AppAccessMask;
    masks[1] = ScmAccessMask;
    masks[2] = ExtraAccessMask;

    return IdentifyAccessWorker(fScmIsOwner, 3, sids, masks);
}



//+-------------------------------------------------------------------------
//
//  Member:	    CAccessInfo::IdentifyAccessWorker
//
//  Synopsis:   Build a security descriptor that identifies who has what
//              access
//
//  Arguments:  [fScmIsOwner]   -- whether SCM is the owner
//              [cSids]         -- The number of sids & access masks
//              [sids]          -- The sids
//              [masks]         -- The access masks
//
//  Returns:    NULL - an error has occurred
//              ~NULL - pointer to the resulting security descriptor
//
//  History:    08-Jun-94 DonnaLi    Created
//
//--------------------------------------------------------------------------
PSECURITY_DESCRIPTOR
CAccessInfo::IdentifyAccessWorker (
    BOOL            fScmIsOwner,
    UINT            cSids,
    PSID           *sids,
    ACCESS_MASK    *masks
    )
{
    NTSTATUS NtStatus;

    //
    // Pointer to memory dynamically allocated by this routine to hold
    // the absolute security descriptor, the DACL, the SACL, and all the ACEs.
    //

    //
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    DWORD               dwAbsoluteSdLength = SECURITY_DESCRIPTOR_MIN_LENGTH;
    PACL                lpDacl = NULL; // Pointer to DACL portion of sid buffer
    ULONG               dwSize;

    UINT                i;
    ULONG               cbSids[16];     // Arbitrarily large size
    ULONG               cbMaxSidLength;

    Win4Assert(cSids < (sizeof(cbSids) / sizeof(cbSids[0])));

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //
    
    dwSize = 0;
    cbMaxSidLength = 0;

    for (i = 0; i < cSids; i++)
    {
        cbSids[i] = RtlLengthSid(sids[i]);
        dwSize += cbSids[i];
        cbMaxSidLength = max(cbMaxSidLength, cbSids[i]);
    }

    dwSize += sizeof(ACL) + cSids * sizeof(ACCESS_ALLOWED_ACE);

    dwAbsoluteSdLength += dwSize;

    _pAbsoluteSdBuffer = (PSECURITY_DESCRIPTOR) PrivMemAlloc (
                dwAbsoluteSdLength
                );

    if (_pAbsoluteSdBuffer == NULL)
    {
        return NULL;
    }

    //
    // Initialize the Dacl and Sacl
    //

    lpDacl = (PACL)((PCHAR)_pAbsoluteSdBuffer + SECURITY_DESCRIPTOR_MIN_LENGTH);

    NtStatus = RtlCreateAcl (lpDacl, dwSize, ACL_REVISION);

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    //
    // Get a buffer big enough for the biggest ACE.
    //

    dwSize = cbMaxSidLength + sizeof(ACCESS_ALLOWED_ACE);

    if (dwSize <= DACE_BUFFER_LENGTH)
    {
        _pDace = (PACCESS_ALLOWED_ACE)&_aDace[0];
    }
    else
    {
        _pDace = (PACCESS_ALLOWED_ACE) PrivMemAlloc (dwSize);

        if (_pDace == NULL)
        {
            return NULL;
        }
    }

    //
    // Initialize each ACE, and append it onto the end of the DACL.
    //

    for (i = 0; i < cSids; i++)
    {
        _pDace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        _pDace->Header.AceSize = (USHORT)(cbSids[i] + sizeof(ACCESS_ALLOWED_ACE));
        _pDace->Header.AceFlags = 0;
        _pDace->Mask = masks[i];

        NtStatus = RtlCopySid (
            cbSids[i],                          //  ULONG  DestinationSidLength
            &(_pDace->SidStart),                //  PSID   DestinationSid
            sids[i]                             //  PSID   SourceSid
            );

        if (!NT_SUCCESS(NtStatus))
        {
            return NULL;
        }

        NtStatus = RtlAddAce(
            lpDacl,                                //  PACL   Acl
            ACL_REVISION,                          //  ULONG  AceRevision
            MAXULONG,                              //  ULONG  StartingAceIndex
            _pDace,                                //  PVOID  AceList
            cbSids[i] + sizeof(ACCESS_ALLOWED_ACE) //  ULONG  AceListLength
            );

        if (!NT_SUCCESS(NtStatus))
        {
            return NULL;
        }
    }

    //
    // Create the security descriptor with absolute pointers to SIDs
    // and ACLs.
    //
    // Owner = Sid of SCM
    // Group = Sid of SCM
    // Dacl  = lpDacl
    // Sacl  = nothing
    //

    NtStatus = RtlCreateSecurityDescriptor (
        _pAbsoluteSdBuffer,           // PSECURITY_DESCRIPTOR SecurityDescriptor
        SECURITY_DESCRIPTOR_REVISION  // ULONG                Revision
        );

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    if (fScmIsOwner)
    {
        NtStatus = RtlSetOwnerSecurityDescriptor (
            _pAbsoluteSdBuffer,       // PSECURITY_DESCRIPTOR SecurityDescriptor
            psidMySid,                // PSID                 Owner
            FALSE                     // BOOLEAN              OwnerDefaulted
            );

        if (!NT_SUCCESS(NtStatus))
        {
            return NULL;
        }

        NtStatus = RtlSetGroupSecurityDescriptor (
            _pAbsoluteSdBuffer,       // PSECURITY_DESCRIPTOR SecurityDescriptor
            psidMySid,                // PSID                 Group
            FALSE                     // BOOLEAN              GroupDefaulted
            );

        if (!NT_SUCCESS(NtStatus))
        {
            return NULL;
        }
    }

    NtStatus = RtlSetDaclSecurityDescriptor (
        _pAbsoluteSdBuffer,           // PSECURITY_DESCRIPTOR SecurityDescriptor
        TRUE,                         // BOOLEAN              DaclPresent
        lpDacl,                       // PACL                 Dacl
        FALSE                         // BOOLEAN              DaclDefaulted
        );

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    NtStatus = RtlSetSaclSecurityDescriptor (
        _pAbsoluteSdBuffer,           // PSECURITY_DESCRIPTOR SecurityDescriptor
        FALSE,                        // BOOLEAN              SaclPresent
        NULL,                         // PACL                 Sacl
        FALSE                         // BOOLEAN              SaclDefaulted
        );

    if (!NT_SUCCESS(NtStatus))
    {
        return NULL;
    }

    return _pAbsoluteSdBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\rot\crothint.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       crothint.cxx
//
//  Contents:   Implementation of CCliRotHintTable class
//
//  History:    27-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <ntlsa.h>
#include    <ntmsv1_0.h>
#include    <windows.h>
#include    <lmsname.h>
#include    <rpc.h>
#include    <stdio.h>
#include    <memory.h>
#include    <string.h>
#include    <winsvc.h>
}

#include    <ole2int.h>

#include <crothint.hxx>


//+-------------------------------------------------------------------------
//
//  Member:     CCliRotHintTable::GetIndicator
//
//  Synopsis:   Get whether indicator for hash entry is set
//
//  Arguments:  [dwOffset] - offset we are looking for
//
//  Returns:    TRUE - entry is set
//              FALSE - entry is not set
//
//  Algorithm:  If array has not been initialized, then bind to the SCM's
//              shared memory. Then check if the offset into the table is
//              set.
//
//  History:	20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CCliRotHintTable::GetIndicator(DWORD dwOffset)
{
    if (_pbHintArray == NULL)
    {
        // Open the shared memory
        _hSm = OpenSharedFileMapping(
                    ROTHINT_NAME,
                    SCM_HASH_SIZE,
                    (void **) &_pbHintArray);

        // It is OK for this to fail because the hint table doesn't
        // really get created by the SCM until the first registration.
    }

    if (_pbHintArray != NULL)
    {
        return _pbHintArray[dwOffset];
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\rot\crot.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rot.cxx
//
//  Contents:   methods for implementation of ROT
//
//  Functions:
//
//
//  History:    11-Nov-92 Ricksa    Created
//              25-Mar-94 brucema   #8914  CRunningObjectTable::Register
//                                   uninited variable
//              25-Mar-94           #10736  Fixed CRotMonikerEnum::Skip to
//                                   return S_OK if skipping remainder of
//                                   enumeration
//              07-Apr-94 brucema   CRunningObjectTable::Register var init
//              24-Jun-94 BruceMa   Validate ROT items when enum'ing
//              11-Jul-94 BruceMa   Marshal moniker enumeration normal
//              28-Jul-94 BruceMa   Memory sift fix
//              09-Jan-95 BruceMa   Single thread ROT creation and enum'ing
//              30-Jan-95 Ricksa    New ROT.
//              15-May-95 BruceMa   Convert DDE ROT requests to UNC-based
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#ifndef DCOM
#include    <epid.hxx>
#endif
#include    <safeif.hxx>
#include    <rothelp.hxx>
#include    <rotdata.hxx>
#include    "crot.hxx"

// Our AppId - this may be set via CoRegisterSurrogateEx or through
// CoInitializeSecurity (if EOAC_APPID is used). If available, we can
// use this in CRunningObjectTable::Register to identify ourselves with
// the SCM rather than relying on our module name, which often isn't unique.
GUID g_AppId = GUID_NULL;


// Semaphore used to protect ROT
COleStaticMutexSem g_RotSem;

// Running object table object
extern CRunningObjectTable *pROT = NULL;

// Function to help us register for/unregister for callbacks when a stub
// goes away.
HRESULT 
CoRegisterDisconnectCallback(
    IUnknown *punk, 
    DWORD dwMarshalFlags,
    IDisconnectSink *pSink,
    void *pvSinkCookie,
    void **ppvRegisterCookie);

HRESULT 
CoUnregisterDisconnectCallback(
    void *pvDiscCookie);


#define MEM_PUB  0          // memory allocated via CoTaskMemAlloc
#define MEM_PRIV 1          // memory allocated via CPrivMemAlloc



//+-------------------------------------------------------------------------
//
//  Member:     GetMonikerCompareBuffer, private
//
//  Synopsis:   Get a buffer appropriate for comparing
//
//  Arguments:  [pmk] - input moniker
//              [pmkeqbuf] - comparison buffer
//              [pfiletime] - time of last change (optional)
//              [pifdMoniker] - output marshaled moniker (optional)
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//  Algorithm:  First reduce the input moniker. Then get the last change
//              time if requested. Then we marshal the reduced moniker if
//              that was requested. Finally, we build the ROT moniker
//              comparison buffer.
//
//  History:    27-Nov-93 Ricksa    Created
//
//  Notes:      This is just a helper that is used to reduce code size.
//
//--------------------------------------------------------------------------
HRESULT GetMonikerCompareBuffer(
    IMoniker *pmk,
    CTmpMkEqBuf *ptmpmkeqbuf,
    FILETIME *pfiletime,
    InterfaceData **ppifdMoniker)
{
    CairoleDebugOut((DEB_ROT, "%p _IN GetMonikerCompareBuffer "
        "( %p , %p, %p , %p )\n", NULL, pmk, ptmpmkeqbuf, pfiletime,
            ppifdMoniker));

    HRESULT hr;

    do {

        CSafeBindCtx sbctx;

        CSafeMoniker smkReduced;

        hr = CreateBindCtx(0, &sbctx);

        if (hr != NOERROR)
        {
            CairoleDebugOut((DEB_ERROR,
                "GetMonikerCompareBuffer CreateBindCtx failed %lX\n", hr));
            break;
        }

        //  reduce the moniker
        hr = pmk->Reduce(sbctx, MKRREDUCE_ALL, NULL, &smkReduced);

        if (FAILED(hr))
        {
            CairoleDebugOut((DEB_ERROR,
                "GetMonikerCompareBuffer IMoniker::Reduce failed %lX\n", hr));
            break;
        }

        if ((IMoniker *) smkReduced == NULL)
        {
            smkReduced.Set(pmk);
        }

        if (pfiletime != NULL)
        {
            // Try to get the time of last change. We ignore the error
            // because this was the original behavior of OLE2.
            smkReduced->GetTimeOfLastChange(sbctx, NULL, pfiletime);
        }

        // Marshal the moniker if so requested
        if (ppifdMoniker != NULL)
        {
            // Stream to put marshaled interface in
            CXmitRpcStream xrpc;

            hr = CoMarshalInterface(&xrpc, IID_IMoniker, smkReduced,
                MSHCTX_NOSHAREDMEM, NULL, MSHLFLAGS_TABLESTRONG);

            if (hr != NOERROR)
            {
                CairoleDebugOut((DEB_ERROR,
                    "GetMonikerCompareBuffer CoMarshalInterface failed %lX\n",
                       hr));
                break;
            }

            xrpc.AssignSerializedInterface(ppifdMoniker);
        }

        hr = BuildRotData(
                sbctx,
                smkReduced,
                ptmpmkeqbuf->GetBuf(),
                ptmpmkeqbuf->GetSize(),
                ptmpmkeqbuf->GetSizeAddr());

    } while (FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT GetMonikerCompareBuffer "
        "( %lX ) [ %p ] \n", NULL, hr,
            (ppifdMoniker != NULL) ? *ppifdMoniker : NULL));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     ReleaseSCMInterfaceData
//
//  Synopsis:   Release interface data returned by the SCM
//
//  Arguments:  [pifd] - interface data to release
//
//  Algorithm:  Create an RPC stream and then pass that stream to
//              CoReleaseMarshalData to release any AddRefs and then
//              free the memory that the interface data lives in.
//
//  History:    27-Jan-95 Ricksa    Created
//
//  Notes:      This is designed specifically for processing interface
//              data returned by the SCM on Revoke from the ROT.
//
//--------------------------------------------------------------------------
void ReleaseInterfaceData(InterfaceData *pifd, DWORD dwMemType)
{
    CairoleDebugOut((DEB_ROT, "%p _IN ReleaseInterfaceData "
        "( %p )\n", NULL, pifd));

    if (pifd != NULL)
    {
        // Make our interface into a stream
        CXmitRpcStream xrpc(pifd);

        // Tell RPC to release it -- error is for debugging purposes only
        // since if this fails there isn't much we can do about it.
#if DBG == 1
        HRESULT hr =
#endif // DBG

            CoReleaseMarshalData(&xrpc);

#if DBG == 1
        if (hr != NOERROR)
        {
            CairoleDebugOut((DEB_ERROR,
            "ReleaseInterfaceData CoReleaseMarshalData failed: %lx\n", hr));
        }
#endif // DBG == 1

#ifdef DCOM
        if (dwMemType == MEM_PUB)
            CoTaskMemFree(pifd);
        else
            MIDL_user_free(pifd);
#else
        MIDL_user_free(pifd);
#endif // DCOM
    }

    CairoleDebugOut((DEB_ROT, "%p OUT ReleaseInterfaceData ", NULL));
}

//+-------------------------------------------------------------------------
//
//  Member:     CROTItem::RevokeStubRegistration
//
//  Synopsis:   Revoke the registration cookie for the stub disconnect.
//
//  History:    07-May-02 JohnDoty   Created
//
//--------------------------------------------------------------------------
inline void CROTItem::RevokeStubRegistration(void)
{
    LPVOID pvStubReg = TakeOverStubRegistration();
    if (pvStubReg)    
        CoUnregisterDisconnectCallback(pvStubReg);
}

//+-------------------------------------------------------------------------
//
//  Member:     CROTItem::~CROTItem
//
//  Synopsis:   Release data connected with the entry
//
//  Algorithm:  Clean up a rot entry by sending a revoke to the SCM for
//              the entry and taking the marshaled interfaces that the
//              SCM returns and releasing the data associated with them.
//
//  History:    20-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
inline CROTItem::~CROTItem(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CROTItem::~CROTItem\n", this));

    // Make sure we are in the correct apt.
    Win4Assert((_hApt == GetCurrentApartmentId())
               && "CROTItem::~CROTItem from wrong apartment");

    // This object is going away so we mark it invalid immediately
    _wItemSig = 0;

    // By the time we get here, we should not have a valid SCM 
    // registration.  Either it was cleaned up on a user Revoke,
    // or cleaned up when the stub went away (note this also 
    // applies when the apartment goes away, because ROT entries
    // get cleaned up after remaining stubs are disconnect).
    Win4Assert(_scmregkey.dwEntryLoc == SCMREG_INVALID_ENTRY_LOC);

    // On some code paths we might still have a stub disconnect
    // registration though (see error paths in CRunningObjectTable::
    // Register), so clean that up if necessary.
    if (_pvStubRegistration)
        CoUnregisterDisconnectCallback(_pvStubRegistration);

    CairoleDebugOut((DEB_ROT, "%p OUT CROTItem::~CROTItem\n", this));
}


//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::Create
//
//  Synopsis:   Create & initialize running object table object
//
//  Returns:    TRUE - ROT created successfully
//              FALSE - an error occurred.
//
//  Algorithm:  Create a new running ROT and check whether the creation
//              was successful.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CRunningObjectTable::Create(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::Create\n", NULL));

    // Need to synchronize ROT creation in a multithreaded environment
    COleStaticLock lckSem(g_RotSem);

    // The ROT may have been created by now
    if (pROT == NULL)
    {
        // Create running object table
        pROT = new CRunningObjectTable();

#if DBG == 1

        if (pROT == NULL)
        {
            CairoleDebugOut((DEB_ERROR,"Couldn't allocate ROT!\n"));
        }

#endif // DBG == 1

        // Initialize the array of registrations - FALSE means we couldn't
        // allocate the memory.
        if (pROT && !pROT->_afvRotList.SetSize(ROT_DEF_SIZE, ROT_DEF_SIZE))
        {
            CairoleDebugOut((DEB_ERROR,"Couldn't allocate ROT reg array!\n"));
            delete pROT;
            pROT = NULL;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::Create"
        "( %lX )\n", NULL, (pROT != NULL)));

    return pROT != NULL;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::~CRunningObjectTable
//
//  Synopsis:   Free ROT object
//
//  History:    11-Nov-93 Ricksa    Created
//
//  Notes:      This only occurs at process exit.
//
//--------------------------------------------------------------------------
CRunningObjectTable::~CRunningObjectTable(void)
{
    CairoleDebugOut((DEB_ROT,
        "%p _IN CRunningObjectTable::~CRunningObjectTable\n", this));

    // Get the size of the table
    int cMax = _afvRotList.GetSize();

    // Are there any entries in the table?
    if (cMax != 0)
    {
        CROTItem **pprot = (CROTItem **) _afvRotList.GetAt(0);

        // Clear out all the registrations
        for (int i = 0; i < cMax; i++)
        {
            if (pprot[i] != NULL)
            {
                delete pprot[i];
            }
        }
    }

    CairoleDebugOut((DEB_ROT,
        "%p OUT CRunningObjectTable::~CRunningObjectTable\n", this));
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::QueryInterface
//
//  Synopsis:   Implements QI for the ROT object
//
//  Arguments:  [riid] - requested id
//              [ppvObj] - where to put output object.
//
//  Returns:    S_OK - interface is suppored
//              E_NOINTERFACE - requested interface is not supported
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::QueryInterface(
    REFIID riid,
    LPVOID FAR* ppvObj)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::QueryInterface "
        "( %p , %p) \n", this, &riid, ppvObj));

    HRESULT hr = S_OK;

    *ppvObj = NULL;

    if ((IsEqualIID(riid, IID_IRunningObjectTable)) ||
        (IsEqualIID(riid, IID_IUnknown)))
    {
        *ppvObj = (IRunningObjectTable *)this;
    }
    else if (IsEqualIID(riid, IID_IDisconnectSink))
    {
        *ppvObj = (IDisconnectSink *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::QueryInterface "
        "( %lX ) [ %p ]\n", this, hr, *ppvObj));

    return hr;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::AddRef
//
//  Synopsis:   Add to reference count
//
//  Returns:    Current reference count
//
//  History:    11-Nov-93 Ricksa    Created
//
//  Notes:      Reference count is ignored with respect to object deletion
//              since this is a system object and does not go away until
//              CoUninitialize is called.
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRunningObjectTable::AddRef()
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::AddRef\n", this));
    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::AddRef\n", this));

    // Since this ignored we just return a non-zero indication
    return 1;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::Release
//
//  Synopsis:   Dec ref count
//
//  Returns:    Current reference count
//
//  History:    11-Nov-93 Ricksa    Created
//
//  Notes:      Reference count is ignored with respect to object deletion
//              since this is a system object and does not go away until
//              CoUninitialize is called.
//
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRunningObjectTable::Release()
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::Release\n", this));
    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::Release\n", this));

    // Since this ignored we just return a non-zero indication
    return 1;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::CleanupApartment
//
//  Synopsis:   Cleans up left-over entries from the ROT when an
//              apartment exits.
//
//  Arguments:  [hApt] - apartment to cleanup
//
//  Algorithm:  Walk through the list local registrations finding each entry
//              that has a matching apartment and remove those entries.  We
//              delete them (for WOW making sure we don't call back to the
//              app).
//
//  History:    24-Jun-94 Rickhi    Created
//              29-Jun-94 AlexT     Don't make yielding calls while holding
//                                  the mutex
//
//--------------------------------------------------------------------------
HRESULT CRunningObjectTable::CleanupApartment(HAPT hApt)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::CleanupApartment"
       "( %lX )\n", this, hApt));

    // Make sure all threads are locked out during lookup
    COleStaticLock lckSem(g_RotSem);

    // Find a spot in the array for the object
    CROTItem **pprotitm = (CROTItem **) _afvRotList.GetAt(0);

    for (int i = 0; i < _afvRotList.GetSize(); i++)
    {
        CROTItem *protitm = pprotitm[i];

        if ((protitm != NULL)
            && (protitm->GetAptId() == hApt))
        {
            // Clean up the entry
            pprotitm[i] = NULL;

            if (IsWOWThread())
            {
                //  16-bit OLE didn't clean up stale entries;  we remove
                //  them from the ROT but we don't call back to the
                //  application.  Who knows what the application might do
                //  if we called them - they already have a missing Revoke.
                protitm->DontCallApp();
            }

            delete protitm;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::CleanupApartment"
       "( %lX )\n", this, S_OK));

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::Register
//
//  Synopsis:   Register an item in the ROT
//
//  Arguments:  [grfFlags] - whether registration keeps object alive
//              [punkObject] - object to register
//              [pmkObjectName] - moniker for object to register
//              [pdwRegister] - id for revoke
//
//  Algorithm:  Validate parameters input. Then create the moniker to register,
//              the comparison buffer and the marshaled moniker to put in the
//              ROT. Then marshal the object to put in the ROT. Create a
//              new local ROT item and reserve a space for it in our local
//              table. Send registration to the SCM and exit.
//
//  History:    11-Nov-93 Ricksa    Created
//              26-Jul-94 AndyH     #20843 - restarting OLE in the shared WOW
//              27-Jan-94 Ricksa    New ROT
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::Register(
    DWORD grfFlags,
    LPUNKNOWN punkObject,
    LPMONIKER pmkObjectName,
    DWORD FAR* pdwRegister)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::Register"
       "( %lX , %p , %p , %p )\n", this, grfFlags, punkObject, pmkObjectName,
           pdwRegister));

    COleTls Tls;
    CROTItem *protitm = NULL;
    HRESULT hr = S_OK;

    // Place to keep marshaled moniker buffer
    InterfaceData *pifdMoniker = NULL;

    // Where to put pointer to marshaled object
    InterfaceData *pifdObject = NULL;

    // Where to put the new ROT registration - set so an invalid
    // value to tell error exit whether it needs to be cleaned up
    DWORD idwPutItem = 0xFFFFFFFF;

    do {

        // If we want to service OLE1 clients, we need to create the
        // common Dde window now if it has not already been done.
        CheckInitDde(TRUE /*registering server objects*/);

        // Validate parameters
        if ((grfFlags & ~(ROTFLAGS_REGISTRATIONKEEPSALIVE | ROTFLAGS_ALLOWANYCLIENT))
            || !IsValidInterface(punkObject)
            || !IsValidInterface(pmkObjectName)
            || !IsValidPtrOut(pdwRegister, sizeof(*pdwRegister)))
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable:Register Invalid Paramter\n"));

            hr = E_INVALIDARG;

            break;
        }

        // We don't allow registry of proxies
        // We use presence of IID_IProxyManager to detect if the object is a proxy

        IProxyManager *pProxyManager;

        // if so, return invalid argument
        if (punkObject -> QueryInterface(IID_IProxyManager, (void**) &pProxyManager) == S_OK)
        {
            pProxyManager -> Release();

            CairoleDebugOut((DEB_ERROR, "CRunningObjectTable:Register Invalid Paramter - proxy passed in expecting original object\n"));

            hr = E_INVALIDARG;

            break;
        }

        *pdwRegister = 0;

        // So we can fill in last change time at registration in the SCM
        FILETIME filetime;

        // Get the moniker comparison buffer
        CTmpMkEqBuf tmeb;

        hr = GetMonikerCompareBuffer(pmkObjectName, &tmeb, &filetime,
            &pifdMoniker);

        if (FAILED(hr))
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::Register get mk compare buf failed\n"));
            break;
        }

        //
        // Get the marshaled interface
        //

        // Stream to put marshaled interface in
        CXmitRpcStream xrpc;

        // The way we marshal this object depends on the liveness
        // characteristics specified by the caller of the operation.
        DWORD dwMarshalFlags = 0;
        if (grfFlags & ROTFLAGS_REGISTRATIONKEEPSALIVE)
        {
            dwMarshalFlags = MSHLFLAGS_TABLESTRONG;
        }
        else
        {
            dwMarshalFlags = MSHLFLAGS_TABLEWEAK;
        }

        hr = CoMarshalInterface(&xrpc, 
                                IID_IUnknown, 
                                punkObject,
                                MSHCTX_NOSHAREDMEM, 
                                NULL,
                                dwMarshalFlags);
        if (hr != NOERROR)
        {
            // Exit if there is an error
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::Register marshal object failed\n"));
            break;
        }

        xrpc.AssignSerializedInterface(&pifdObject);

        // Create an entry for the local registration table
        protitm = new CROTItem();
        if (protitm == NULL)
        {
            // Either the allocation failed, or the constructor failed
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::Register create ROT item failed\n"));
            hr = E_OUTOFMEMORY;

            break;
        }

        // Temporary holder for registration ID
        DWORD dwRotRegId;

        // ROT Table entry as opposed to the entry we are creating
        // which is called protitm.
        CROTItem **pprotitm;

        // Put it in the table and initalize signiture.
        {
            COleStaticLock lckSem(g_RotSem);

            // We lock here so we don't accidently pass out duplicate
            // signiture. It is important to note that we need to lock
            // anyway to put the item in the array.
            _wSigRotItem++;

            protitm->SetSig(_wSigRotItem);

            // Find a spot in the array for the object
            pprotitm = (CROTItem **) _afvRotList.GetAt(0);

            for (idwPutItem = 0; (int) idwPutItem < _afvRotList.GetSize();
                idwPutItem++)
            {
                if (pprotitm[idwPutItem] == NULL)
                {
                    break;
                }
            }

            // Was the table full?
            if ((int) idwPutItem < _afvRotList.GetSize())
            {
                // No -- use an empty slot.
                pprotitm[idwPutItem] = protitm;
            }
            // Grow the array to fit the next entry.
            else if (!_afvRotList.InsertAt(idwPutItem, &protitm))
            {
                // Couldn't reallocate memory
                hr = E_OUTOFMEMORY;
                break;
            }

            // Build the registration ID
            dwRotRegId = MakeRegID(_wSigRotItem, idwPutItem);
        }

        // Register the callback for disconnect with the stub manager.
        void *pvNotifyCookie;
        hr = CoRegisterDisconnectCallback(punkObject, 
                                          dwMarshalFlags,
                                          this,
                                          UlongToPtr(dwRotRegId),
                                          &pvNotifyCookie);
        if (FAILED(hr))
            break;
        protitm->SetStubRegistration(pvNotifyCookie);

        WCHAR   wszImageName[MAX_PATH];
        WCHAR * pwszExeName = 0;

        if ( grfFlags & ROTFLAGS_ALLOWANYCLIENT )
        {
            if ( g_AppId != GUID_NULL )
            {
                // If we got an AppId (from CoRegisterSurrogateEx or
                // CoInitializeSecurity, convert it to a string and pass
                // it as our Exe name to the SCM.

                if (StringFromIID2( g_AppId, wszImageName, sizeof(wszImageName)/sizeof(WCHAR)) == 0)
                {
                    hr = E_UNEXPECTED;
                    break;
                }
                pwszExeName = wszImageName;
            }
            else
            {
                // If we don't know our AppId, get our image name and
                // let the SCM try to map this to an AppId via the Registry.

                if ( ! GetModuleFileName( NULL, wszImageName, MAX_PATH ) )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    break;
                }

                pwszExeName = wszImageName + lstrlenW(wszImageName) - 1;
                while ( (pwszExeName != wszImageName) && (pwszExeName[-1] != L'\\') )
                    pwszExeName--;
            }
        }

        // Notify SCM of the registration
        //
        // Note that CoGetCurrentProcess is for supporting the DDE layer
        // which needs to find objects in the same apartment only.
        //
        hr = gResolver.IrotRegister(
            tmeb.GetMkEqBuf(),
            pifdObject,
            pifdMoniker,
            &filetime,
            CoGetCurrentProcess(),
            pwszExeName,
            protitm->GetScmRegKey());

        if (SUCCEEDED(hr))
        {
            *pdwRegister = dwRotRegId;
        }

    } while(FALSE);

    if (SUCCEEDED(hr))
    {
        // We pass the marshaled interface buffers off to the SCM so
        // it actually owns the ref counting (which is why it returns
        // copies of the buffer on Revoke. However, we still have
        // copies of the buffer memore here which we have to free or
        // leak memory.
#ifdef DCOM
        CoTaskMemFree(pifdMoniker);
        CoTaskMemFree(pifdObject);
#else
        MIDL_user_free(pifdMoniker);
        MIDL_user_free(pifdObject);
#endif
    }
    else
    {
        if (protitm != NULL)
        {
            // Releasing the interface data below might cause the
            // destruction of the newly created stub.  We don't want
            // to be revoked just yet, so clean up the stub 
            // registration if we got that far.
            protitm->RevokeStubRegistration();
        }

        // Clean up marshaled interfaces since the call has failed.
        ReleaseInterfaceData(pifdMoniker, MEM_PUB);
        ReleaseInterfaceData(pifdObject, MEM_PUB);

        // Error clean up.
        if (protitm != NULL)
        {
            if (idwPutItem != 0xFFFFFFFF)
            {
                // Registration failed on the SCM so clean up our local
                // registration.
                COleStaticLock lckSem(g_RotSem);
                
                // We have to use GetAt because the table could have grown
                CROTItem **pprotitm = (CROTItem **)
                    _afvRotList.GetAt(idwPutItem);

                pprotitm[idwPutItem] = NULL;
            }

            // Free the item for the ROT.
            delete protitm;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::Register"
       "( %lX ) [ %lX ]\n", this, hr, *pdwRegister));

    return hr;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::Revoke
//
//  Synopsis:   Remove a previously registered item from the table.
//
//  Arguments:  [dwRegister] - registration id
//
//  Returns:    S_OK - item was revoked
//              E_INVALIDARG - dwRegister is invalid
//
//  Algorithm:  Convert local registration to SCM registration. Send revoke
//              to the SCM. Release data associated with SCM ROT entries.
//
//  History:    11-Nov-93 Ricksa    Created
//              27-Nov-95 Ricksa    New ROT
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::Revoke(DWORD dwRegister)
{
    HRESULT hr;
	
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::Revoke"
       "( %lX )\n", this, dwRegister));

    hr = RevokeHelper(dwRegister, FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::Revoke"
       "( %lX )\n", this, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::IsRunning
//
//  Synopsis:   See if object is running
//
//  Arguments:  [pmkObjectName] - name of item to search for
//
//  Returns:    S_OK - item is running
//              S_FALSE - item is not running
//
//  Algorithm:  Validate input parameters. Then build a moniker comparison
//              buffer. Then ask the ROT if there is a registration for
//              the  input moniker.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::IsRunning(LPMONIKER pmkObjectName)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::IsRunning"
       "( %p )\n", this, pmkObjectName));

    HRESULT hr = E_INVALIDARG;

    // Validate input parameters
    if (IsValidInterface(pmkObjectName))
    {
        // Create a buffer for the comparison
        CTmpMkEqBuf tmpMkEqBuf;

        // Get comparison buffer
        if ((hr = GetMonikerCompareBuffer(pmkObjectName, &tmpMkEqBuf, NULL,
            NULL)) == NOERROR)
        {
            // Look into the hint table for the object
            if (IsInScm(tmpMkEqBuf.GetMkEqBuf()))
            {
                // Ask SCM for the object
                hr = gResolver.IrotIsRunning(tmpMkEqBuf.GetMkEqBuf());
            }
            else
            {
                // If it isn't in the hint table, there is no reason
                // to RPC to the ROT.
                hr = S_FALSE;
            }
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::IsRunning"
       "( %lX )\n", this, hr));

    return hr;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::GetObject
//
//  Synopsis:   Get an object from the ROT
//
//  Arguments:  [pmkObjectName] - name of object to search for
//              [ppunkObject] - where to put interface pointer.
//
//  Returns:    S_OK - found and returned object.
//              MK_E_UNAVAILABLE - not found
//
//  Algorithm:  Convert the local registration ID to the SCM registration
//              ID. Then send the request on to the SCM.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::GetObject(
    LPMONIKER pmkObjectName,
    LPUNKNOWN *ppunkObject)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::GetObject "
        "( %p , %p )\n", this, pmkObjectName, ppunkObject));

    // Validate arguments
    HRESULT hr = E_INVALIDARG;

    // Validate input parameters
    if (IsValidInterface(pmkObjectName)
        && IsValidPtrOut(ppunkObject, sizeof(*ppunkObject)))
    {
        *ppunkObject = NULL;

        // Create a buffer for the comparison
        CTmpMkEqBuf tmpMkEqBuf;

        // Get comparison buffer
        if ((hr = GetMonikerCompareBuffer(pmkObjectName, &tmpMkEqBuf, NULL,
            NULL)) == NOERROR)
        {
            // Note: Process ID is 0 because we don't care about the
            // process any registration will do.
            hr = IGetObject(tmpMkEqBuf.GetMkEqBuf(), ppunkObject, 0);
        }
        else
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::GetObject couldn't get comp buf\n"));
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::GetObject"
       "( %lX ) [ %p ]\n", this, hr, *ppunkObject));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::IGetObject
//
//  Synopsis:   Internal call to get an object from the ROT
//
//  Arguments:  [pmkObjectName] - name of object to search for
//              [ppunkObject] - where to put interface pointer.
//              [dwThreadID] - thread ID for the object
//
//  Returns:    S_OK - found and returned object.
//              MK_E_UNAVAILABLE - not found
//
//  Algorithm:  Build a moniker comparison buffer. Send request to the
//              SCM. Then unmarshal the result from the SCM. If the
//              unmarshal fails, then notify the SCM that the registration
//              is invalid.
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:      This exists because OLE 1.0 compatibility requires support
//              for determining whether an object is already in the ROT
//              for the given process.
//
//              Because this is an internal call, there is no parameter
//              validation.
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::IGetObject(
    MNKEQBUF *pmkeqbuf,
    LPUNKNOWN FAR* ppunkObject,
    DWORD dwThreadID)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::IGetObject"
       "( %p , %p , %lX )\n", this, pmkeqbuf, ppunkObject, dwThreadID));

    // Validate arguments
    HRESULT hr = E_INVALIDARG;

    do {

        // Loop because there can be multiple bad entries in the SCM
        // We loop 5 because we can theoretically loop forever so we
        // want to give up after we give a good long try that should
        // most likely work.
        //
        // Look into the hint table for the object
        if (!IsInScm(pmkeqbuf))
        {
            // If it isn't in the hint table, there is no reason
            // to RPC to the ROT.
            hr = MK_E_UNAVAILABLE;
            break;
        }
        
        // Ask SCM for the object
        SCMREGKEY scmregkey;
        InterfaceData *pifdObject = NULL;
        
        hr = gResolver.IrotGetObject(dwThreadID, pmkeqbuf,
                                     &scmregkey, &pifdObject);
        
        if (FAILED(hr))
        {
            // SCM couldn't find it so we are done.
            break;
        }
        
        if (ppunkObject == NULL)
        {
            // This is really an IsRunning from DDE so we can exit
            // now.
            hr = NOERROR;
            
            // free the buffer allocated
            MIDL_user_free(pifdObject);
            
            // Exit because we are done.
            break;
        }
        
        // Now we have to unmarshal the object to really get the
        // object.
        CXmitRpcStream xrpc(pifdObject);
        
        hr = CoUnmarshalInterface(&xrpc, 
                                  IID_IUnknown,
                                  (void **) ppunkObject);
        
        // Whether there was an error or not we need to dump the
        // memory that RPC allocated on our behalf.
        MIDL_user_free(pifdObject);

    } while(FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::IGetObject"
       "( %lX ) [ %p ]\n", this, hr,
           ((ppunkObject == NULL) ? NULL : *ppunkObject)));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::NoteChangeTime
//
//  Synopsis:   Set the time of last change in the ROT
//
//  Arguments:  [dwRegister] - registration id of object
//              [pfiletime] - file time of change.
//
//  Returns:    S_OK - new time set
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::NoteChangeTime(
    DWORD dwRegister,
    FILETIME *pfiletime)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::NoteChangeTime"
       "( %lX , %p )\n", this, dwRegister, pfiletime));

    // Default result to bad argument.
    HRESULT hr = E_INVALIDARG;

    do {

        // Validate that parameters are valid
        if (!IsValidReadPtrIn(pfiletime, sizeof(FILETIME)))
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::NoteChangeTime invalid time param\n"));
            break;
        }

        SCMREGKEY ScmRegKey;

        {
            // Lock from other threads so a revoke  will not cause something
            // strange to happen.
            COleStaticLock lckSem(g_RotSem);

            // Convert handle to pointer
            DWORD idwIndexToEntry;
            WORD wItemSig;
            GetSigAndIndex(dwRegister, &wItemSig, &idwIndexToEntry);

            CROTItem *protitm = GetRotItem(idwIndexToEntry);

            if ((protitm == NULL) || !protitm->ValidSig(wItemSig, FALSE))
            {
                // Entry is valid so clear it out from the table
                CairoleDebugOut((DEB_ERROR,
                    "CRunningObjectTable::NoteChangeTime invalid reg key\n"));
                break;
            }

            ScmRegKey = *(protitm->GetScmRegKey());
        }

        // Outside the scope of the lock, call the SCM and returns
        // it's results.
        hr = gResolver.IrotNoteChangeTime(&ScmRegKey, pfiletime);

    } while(FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::NoteChangeTime"
       "( %lX )\n", this, hr));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::GetTimeOfLastChange
//
//  Synopsis:   Get time of last change for a given object
//
//  Arguments:  [pmkObjectName] - name of object
//              [pfiletime] - where to put the time of change
//
//  Returns:    S_OK - got time of last change.
//              MK_E_UNAVAILABLE - moniker is not in the table
//
//  History:    11-Nov-93 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::GetTimeOfLastChange(
    LPMONIKER pmkObjectName,
    FILETIME *pfiletime)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::GetTimeOfLastChange"
       "( %p , %p )\n", this, pmkObjectName, pfiletime));

    HRESULT hr = E_INVALIDARG;

    do {

        // Validate input parameters
        if (!IsValidInterface(pmkObjectName)
            || !IsValidPtrOut(pfiletime, sizeof(pfiletime)))
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::GetTimeOfLastChange invalid params\n"));
            break;
        }

        // Create a buffer for the comparison
        CTmpMkEqBuf tmpMkEqBuf;

        // Get comparison buffer
        if ((hr = GetMonikerCompareBuffer(pmkObjectName, &tmpMkEqBuf, NULL,
            NULL)) != NOERROR)
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::GetTimeOfLastChange couldn't get comp buf failed\n"));

            break;
        }

        // Look into the hint table for the object
        if (!IsInScm(tmpMkEqBuf.GetMkEqBuf()))
        {
            // If it isn't in the hint table, there is no reason
            // to RPC to the ROT.
            hr = MK_E_UNAVAILABLE;
            break;
        }

        // Ask SCM for the object
        SCMREGKEY scmregkey;
        InterfaceData *pifdObject = NULL;

        hr = gResolver.IrotGetTimeOfLastChange(tmpMkEqBuf.GetMkEqBuf(), pfiletime);

    } while(FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::GetTimeOfLastChange"
       "( %lX )\n", this, hr));


    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::EnumRunning
//
//  Synopsis:   Get an enumerator for all objects in the ROT
//
//  Arguments:  [ppenumMoniker] - where to put enumerator interface
//
//  Returns:    S_OK - successfully built enumerator
//              E_OUTOFMEMORY - could not build enumerator
//
//  Algorithm:  Constructor an enumerator object. Then get the list of
//              all running monikers from the SCM. Finally, put that list
//              into the enumerator object.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRunningObjectTable::EnumRunning(LPENUMMONIKER *ppenumMoniker)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::EnumRunning"
       "( %p )\n", this, ppenumMoniker));

    HRESULT hr = E_INVALIDARG;
    CRotMonikerEnum *protenumMoniker = NULL;
    MkInterfaceList *pMkIFList = NULL;

    do {

        if (!IsValidPtrOut(ppenumMoniker, sizeof(*ppenumMoniker)))
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::EnumRunning invalid params\n"));
            break;
        }

        protenumMoniker = new CRotMonikerEnum();

        if ((protenumMoniker == NULL) || !protenumMoniker->CreatedOk())
        {
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::EnumRunning couldn't create enumerator\n"));

            hr = E_OUTOFMEMORY;

            break;
        }


        hr = gResolver.IrotEnumRunning(&pMkIFList);

        if (hr != NOERROR)
        {
            // Return the error from the SCM
            CairoleDebugOut((DEB_ERROR,
                "CRunningObjectTable::EnumRunning call to SCM failed\n"));

            break;
        }

        hr = protenumMoniker->LoadResultFromScm(pMkIFList);

        if (hr == NOERROR)
        {
            *ppenumMoniker = protenumMoniker;
            protenumMoniker = NULL;
        }

    } while(FALSE);

    if (protenumMoniker != NULL)
    {
        // If our local pointer is not NULL then we just delete it and
        // ignore the reference count since this means an error occurred.
        delete protenumMoniker;
    }

    if (pMkIFList != NULL)
    {
        // Free all the entries
        for (DWORD i = 0; i < pMkIFList->dwSize; i++)
        {
            MIDL_user_free(pMkIFList->apIFDList[i]);
        }

        // Then free the structure itself
        MIDL_user_free(pMkIFList);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::EnumRunning"
       "( %lX ) [ %p ]\n", this, hr, *ppenumMoniker));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::GetObjectByPath
//
//  Synopsis:   Locate object in ROT by path
//
//  Arguments:  [lpstrPath] - path to locate in the rot
//              [ppunkObject] - where to put the object if requested
//              [dwThreadID] - what thread the object s/b in
//
//  Returns:    S_OK - successfully built enumerator
//              E_OUTOFMEMORY - could not build enumerator
//
//  Algorithm:  Build a buffer full of objects from the local table then
//              consult the ROT directory.
//
//  History:    30-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRunningObjectTable::IGetObjectByPath(
    LPOLESTR lpstrPath,
    LPUNKNOWN *ppunkObject,
    DWORD dwThreadID)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRunningObjectTable::IGetObjectByPath"
       "( %p , %p , %lX )\n", this, lpstrPath, ppunkObject, dwThreadID));

    HRESULT hr = S_FALSE;

    // Where we put the moniker we use for the moniker
    CSafeMoniker smk;

    if (ppunkObject)
    {
        *ppunkObject = NULL;
    }

    // Create a buffer for the comparison
    CTmpMkEqBuf tmpMkEqBuf;

    hr = CreateFileMonikerComparisonBuffer(lpstrPath, tmpMkEqBuf.GetBuf(),
        tmpMkEqBuf.GetSize(), tmpMkEqBuf.GetSizeAddr());

    if (SUCCEEDED(hr))
    {
        hr = IGetObject(tmpMkEqBuf.GetMkEqBuf(), ppunkObject, dwThreadID);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRunningObjectTable::IGetObjectByPath"
       "( %lX ) [ %p ]\n", this, hr,
           ((ppunkObject == NULL) ? NULL : *ppunkObject)));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::OnDisconnect
//
//  Synopsis:   Called when a stub is being disconnected.  Revoke the object
//              from the ROT.
//
//  Arguments:  pvCookie -- the registration cookie we stashed with the
//              stub.
//
//  History:    09-Mar-02 JohnDoty  Created
//
//--------------------------------------------------------------------------
void CRunningObjectTable::OnDisconnect(void *pvCookie)
{
    // That void * is really a DWORD.
    DWORD dwCookie = PtrToUlong(pvCookie);

    // Ignore the return code... what are we gonna do about it?
    RevokeHelper(dwCookie, TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRunningObjectTable::RevokeHelper
//
//  Synopsis:   Does the work of revoking a ROT entry
//
//  Arguments:  dwRegister -- the registration cookie for the ROT entry 
//                 to revoke
//
//              fFromStubDisconnect - TRUE if this Revoke is caused by the 
//                 server's stub going away, or FALSE otherwise (ie, 
//                 caused by a user revoke).
//
//  History:    24-Jul-02 JSimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRunningObjectTable::RevokeHelper(DWORD dwRegister, 
                                              BOOL fFromStubDisconnect)
{
    // Default response to bad argument
    HRESULT hr = E_INVALIDARG;

    // Entry
    CROTItem *protitm = NULL;
    BOOL fScmRegKeyValid = FALSE;
    BOOL fRemovedEntryFromTable = FALSE;
    SCMREGKEY scmregkey = {0};
    BOOL fDontCallApp = TRUE;
    LPVOID pvStubRegistration = NULL;

    // Convert handle to pointer
    DWORD idwIndexToEntry;
    WORD wItemSig;
    GetSigAndIndex(dwRegister, &wItemSig, &idwIndexToEntry);

    //
    // If the revoke is coming from a stub-disconnect, we want to
    // revoke the SCM's entry, but leave our entry in the table so 
    // that if a user revoke arrives later, we will still find it.  
    // If the revoke is coming from the user, we do the whole 
    // operation right now.
    //

    do
    {
        // Lock from other processes so another simultaneous revoke
        // will not cause something strange to happen.
        COleStaticLock lckSem(g_RotSem);

        protitm = GetRotItem(idwIndexToEntry);
        if (protitm != NULL)
        {
            // Found an entry so verify its signature
            if (protitm->ValidSig(wItemSig, TRUE))
            {	
                hr = S_OK;	        	

                pvStubRegistration = protitm->TakeOverStubRegistration();

                fScmRegKeyValid = protitm->TakeOverScmRegKey(&scmregkey);
					
                fDontCallApp = protitm->GetDontCallApp();

                if (!fFromStubDisconnect)
                {
                    // This is the full delete, so go ahead and clear
                    // it from the table.
                    CROTItem **pprotitm = (CROTItem **)
                                _afvRotList.GetAt(idwIndexToEntry);
                    *pprotitm = NULL;
                    fRemovedEntryFromTable = TRUE;
                }
            }
        }
    }
    while (FALSE);

    // Outside of the lock at this point. We don't want to make an RPC
    // to the SCM under a lock.

    if (hr == S_OK)
    {
        // Since hr is S_OK, assert that we have some work to do
        Win4Assert(fScmRegKeyValid || protitm);

        // Revoke the stub disconnect registration if there was one
        if (pvStubRegistration)
        {
            CoUnregisterDisconnectCallback(pvStubRegistration);
        }

        // Revoke the SCMREGKEY if we have one
        if (fScmRegKeyValid)
        {
            // Place to put returned marshaled interfaces
            InterfaceData *pifdObject = NULL;
            InterfaceData *pifdName = NULL;

            // In previous OS platforms we did not fail the revoke on
            // errors from the SCM.  Hence the separate hrRevoke here.
            HRESULT hrRevoke = gResolver.IrotRevoke(&scmregkey, &pifdObject, &pifdName);
            if (FAILED(hrRevoke))
            {
                CairoleDebugOut((DEB_ROT, "Revoke FAILED: %lx\n", hrRevoke));
            }

            if (!fDontCallApp)
            {
                ReleaseInterfaceData(pifdObject, MEM_PRIV);
                ReleaseInterfaceData(pifdName, MEM_PRIV);
            }
        }

        // Delete the entry object if we have one
        if (fRemovedEntryFromTable)
        {
            delete protitm;
        }
    }

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     GetRunningObjectTable
//
//  Synopsis:   Get a pointer to the ROT
//
//  Arguments:  [reserved] - reserved!
//              [pprot] - where to put interface pointer
//
//  Returns:    S_OK - got pointer
//              E_UNEXPECTED - table not initialized
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDAPI GetRunningObjectTable(DWORD reserved, LPRUNNINGOBJECTTABLE *pprot)
{
    OLETRACEIN((API_GetRunningObjectTable, PARAMFMT("reserved= %x, pprot= %p"), pprot));

    CairoleDebugOut((DEB_ROT, "%p _IN GetRunningObjectTable"
       "( %p )\n", NULL, pprot));

    HRESULT hr = CO_E_NOTINITIALIZED;

    if ((pROT == NULL) && (g_cProcessInits > 0))
    {
        // If we haven't created it, create it now.
        CRunningObjectTable::Create();
    }

    *pprot = pROT;      // will be NULL in error case

    if (pROT != NULL)
    {
        hr = S_OK;
    }

    CALLHOOKOBJECTCREATE(hr,CLSID_NULL,IID_IRunningObjectTable,(IUnknown **)pprot);

    CairoleDebugOut((DEB_ROT, "%p OUT GetRunningObjectTable"
       "( %lX ) [ %p ]\n", NULL, hr, *pprot));

    OLETRACEOUT((API_GetRunningObjectTable, hr));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Function:   CleanROTForApartment
//
//  Synopsis:   Get rid of running object table entries for the current APT.
//
//  History:    24-Jun-94 Rickhi          Created
//
//--------------------------------------------------------------------------
void CleanROTForApartment(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CleanROTForApartment"
       "\n", NULL));

    if (pROT)
    {
        pROT->CleanupApartment(GetCurrentApartmentId());
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CleanROTForApartment"
       "\n", NULL));
}

//+-------------------------------------------------------------------------
//
//  Function:   DestroyRunningObjectTable
//
//  Synopsis:   Get rid of running object table
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
void DestroyRunningObjectTable(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN DestroyRunningObjectTable"
       "\n", NULL));

    // Need to synchronize ROT destruction in a multithreaded environment
    COleStaticLock lckSem(g_RotSem);

    // It doesn't matter what the ref count is, when OLE goes, the ROT goes too.
    delete pROT;

    pROT = NULL;

#ifndef DCOM
    // Our endpoint is history. Note that this just resides here as a
    // convenient place for this to happen (and for historical reasons
    // since it used to serve some practical purpose for being here).
    epiForProcess.MakeEndpointInvalid();
#endif

    CairoleDebugOut((DEB_ROT, "%p OUT DestroyRunningObjectTable"
       "\n", NULL));
}


//+-------------------------------------------------------------------------
//
//  Member:     CMonikerPtrBuf::CMonikerPtrBuf
//
//  Synopsis:   Copy constructor for the buffer
//
//  Arguments:  [mkptrbuf] - buffer to copy
//
//  History:    20-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CMonikerPtrBuf::CMonikerPtrBuf(CMonikerPtrBuf& mkptrbuf)
    : CMonikerBag(mkptrbuf)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CMonikerPtrBuf::CMonikerPtrBuf"
       "( %p )\n", this, &mkptrbuf));

    // Now AddRef the copied monikers so they stay around
    IMoniker **ppmk = GetArrayBase();

    for (DWORD i = 0; i < GetMax(); i++)
    {
        ppmk[i]->AddRef();
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CMonikerPtrBuf::CMonikerPtrBuf"
       "( %p )\n", this));
}




//+-------------------------------------------------------------------------
//
//  Member:     CMonikerPtrBuf::~CMonikerPtrBuf
//
//  Synopsis:   Free items
//
//  History:    23-Dec-93 Ricksa    Created
//
//  Notes:      This object assumes that it gets its monikers addref'd
//              so it is up to this object to free them.
//
//--------------------------------------------------------------------------
CMonikerPtrBuf::~CMonikerPtrBuf(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CMonikerPtrBuf::~CMonikerPtrBuf"
       "\n", this));

    DWORD dwSize = GetMax();

    if (dwSize > 0)
    {
        IMoniker **ppmk = GetArrayBase();

        for (DWORD i = 0; i < dwSize; i++)
        {
            ppmk[i]->Release();
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CMonikerPtrBuf::~CMonikerPtrBuf"
       "\n", this));
}







//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::CRotMonikerEnum
//
//  Synopsis:   Constructor for ROT moniker enumerator
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CRotMonikerEnum::CRotMonikerEnum(void)
    : _cRefs(1), _dwOffset(0)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::CRotMonikerEnum"
       "\n", this));

    // Header does the work

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::CRotMonikerEnum"
       "\n", this));
}




//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::CRotMonikerEnum
//
//  Synopsis:   Copy constructor for ROT moniker enumerator
//
//  Arguments:  [rotenumMoniker] - Enumerator to copy from
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
CRotMonikerEnum::CRotMonikerEnum(CRotMonikerEnum& rotenumMoniker)
    : _cRefs(1), _dwOffset(rotenumMoniker._dwOffset),
        _mkptrbuf(rotenumMoniker._mkptrbuf)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::CRotMonikerEnum"
       "( %p )\n", this, &rotenumMoniker));

    // Header does the work

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::CRotMonikerEnum"
       "\n", this));
}




//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::QueryInterface
//
//  Synopsis:   QI for ROT moniker enumerator
//
//  Arguments:  [riid] - requested interface
//              [ppvObj] - where to put requested interface
//
//  Returns:    S_OK - returned interface
//              E_NOINTERFACE - requested interface is not supported
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRotMonikerEnum::QueryInterface(REFIID riid, void **ppvObj)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::QueryInterface"
       "( %p , %p )\n", this, &riid, ppvObj));

    HRESULT hr = S_OK;

    do {

        *ppvObj = NULL;

        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IEnumMoniker))
        {
            *ppvObj = (LPVOID)this;
            AddRef();
            break;
        }

        hr = E_NOINTERFACE;

    } while(FALSE);

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::QueryInterface"
       "( %lX ) [ %p ]\n", this, hr, *ppvObj));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::AddRef
//
//  Synopsis:   Add to ref count
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRotMonikerEnum::AddRef(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::AddRef"
       "\n", this));

    InterlockedIncrement((LONG *) &_cRefs);

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::AddRef"
       "( %lX )\n", this, _cRefs));

    return _cRefs;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::Release
//
//  Synopsis:   Release reference count
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRotMonikerEnum::Release(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::Release"
       "\n", this));

    LONG lRefs = InterlockedDecrement((LONG *) &_cRefs);

    if (0 == lRefs)
    {
        delete this;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::Release"
       "( %lX )\n", this, lRefs));

    return (ULONG) lRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::Next
//
//  Synopsis:   Get next number of requested monikers from the buffer
//
//  Arguments:  [celt] - number of items requested
//              [reelt] - where to put table of monikers
//              [pceltFetched] - number of monikers retrieved
//
//  Returns:    S_OK - all requested monikers successfully retrieved
//              S_FALSE - entire buffer not filled.
//
//  Algorithm:  Loop through list returning monikers.
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRotMonikerEnum::Next(
    ULONG celt,
    LPMONIKER *reelt,
    ULONG *pceltFetched)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::Next"
       "( %lX , %p , %p )\n", this, celt, reelt, pceltFetched));

    // Validate pceltFetched
    if ((celt != 1) && (pceltFetched != NULL))
    {
        *pceltFetched = 0;
    }

    // Loop loading monikers until request is satisfied or we run out
    for (ULONG i = 0; i < celt; i++)
    {
        IMoniker *pmk = _mkptrbuf.GetItem(_dwOffset++);

        if (pmk == NULL)
        {
            break;
        }

        reelt[i] = pmk;
    }

    if (pceltFetched != NULL)
    {
        *pceltFetched = i;
    }

    HRESULT hr = (i == celt) ? S_OK : S_FALSE;

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::Next"
       "( %lX  )\n", this, hr));

    return hr;

}




//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::Skip
//
//  Synopsis:   Skip designated number of monikers
//
//  Arguments:  [celt] - number to skip
//
//  Returns:    S_OK - skipped requested number
//              S_FALSE - # skipped greater than remaining
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRotMonikerEnum::Skip(ULONG celt)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::Skip"
       "( %lX )\n", this, celt));

    // Error return -- assume count to skip is larger than number of items
    HRESULT hr = S_FALSE;

    if (_dwOffset + celt <= _mkptrbuf.GetMax())
    {
        _dwOffset += celt;
        hr = S_OK;
    }
    else
    {
        _dwOffset = _mkptrbuf.GetMax();
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::Skip"
       "( %lX )\n", this, hr));

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::Reset
//
//  Synopsis:   Reset the enumerator
//
//  Returns:    S_OK
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRotMonikerEnum::Reset(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::Reset"
       "\n", this));

    _dwOffset = 0;

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::Reset"
       "\n", this));

    return S_OK;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::Clone
//
//  Synopsis:   Make a copy of the current enumerator
//
//  Arguments:  [ppenumMoniker] - where to put copy
//
//  Returns:    S_OK - moniker successfully cloned
//              E_OUTOFMEMORY - not enough memory to clone
//
//  History:    11-Nov-93 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRotMonikerEnum::Clone(LPENUMMONIKER FAR* ppenumMoniker)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::Clone"
       "( %p )\n", this, ppenumMoniker));

    // Error return
    HRESULT hr = S_OK;

    // Use copy constructor to create duplicate enumerator
    CRotMonikerEnum *pcrotenumMoniker = new CRotMonikerEnum(*this);

    if ((pcrotenumMoniker == NULL) || !pcrotenumMoniker->CreatedOk())
    {
        delete pcrotenumMoniker;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        *ppenumMoniker = (LPENUMMONIKER) pcrotenumMoniker;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::Clone"
       "( %lX ) [ %p ]\n", this, hr, *ppenumMoniker));
    return hr;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRotMonikerEnum::LoadResultFromScm
//
//  Synopsis:   Add a list of monikers to enumerator from an object server
//
//  Arguments:  [pMkIFList] - list to use for input
//
//  Returns:    S_OK - moniker added
//              E_OUTOFMEMORY - could not add any more to buffer
//
//  History:    11-Nov-93 Ricksa    Created
//              27-Jan-95 Ricksa    New ROT
//
//  Note:
//
//--------------------------------------------------------------------------
HRESULT CRotMonikerEnum::LoadResultFromScm(MkInterfaceList *pMkIFList)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CRotMonikerEnum::LoadResultFromScm"
       "( %p )\n", this, pMkIFList));

    HRESULT hr = S_OK;

    for (DWORD i = 0; i < pMkIFList->dwSize; i++)
    {
        // Where to put the unmarshaled moniker
        IMoniker *pmk;

        // Unmarshal the interface from the buffer
        CXmitRpcStream xrpc(pMkIFList->apIFDList[i]);

        hr = CoUnmarshalInterface(&xrpc, IID_IMoniker, (void **) &pmk);

        if (FAILED(hr))
        {
            // Really two important possibilities for failure: (1) Out of
            // memory or (2) Somekind of communication failure during the
            // unmarshal. Out of memory means that we are pretty well dead
            // so we will return that error and ignore the others since
            // if the moniker is remotely served, it can actually have
            // gone away before we got around to unmarshaling it.
            if (hr == E_OUTOFMEMORY)
            {
                break;
            }

            continue;
        }

        // Put the moniker in the array
        _mkptrbuf.Add(pmk);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CRotMonikerEnum::LoadResultFromScm"
       "( %lX )\n", this, hr));

    return hr;
}





//+---------------------------------------------------------------------------
//
//  Function:   GetLocalRunningObjectForDde
//
//  Synopsis:   Searches for and optionally returns an object by path for
//              the DDE layer.
//
//  Effects:    Attempts to find an entry in the local ROT that matches
//              the provided path. If there is a hit in the table, and
//              ppunkObject is not NULL, then it also returns a pointer
//              to the object.
//
//  Arguments:  [lpstrPath] -- Path to search for
//              [ppunkObject] -- Output for the object pointer
//
//  Returns:    S_OK - Found object in local ROT
//              S_FALSE - Didn't find object in local ROT
//              OTHER - Something else happened.
//
//  History:    6-29-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetLocalRunningObjectForDde(
    LPOLESTR lpstrPath,
    LPUNKNOWN *ppunkObject)
{
    CairoleDebugOut((DEB_ROT, "%p _IN GetLocalRunningObjectForDde"
       "( %p , %p )\n", NULL, lpstrPath, ppunkObject));

    HRESULT hr = S_FALSE;

    // POSTPPC - We're getting close to RTM for NT/PPC, so we'll make this fix
    // for Chicago only for now
    //
    // If there currently isn't a local ROT, then the object surely isn't
    // registered.
    //
    if (pROT != NULL)
    {
        hr = pROT->IGetObjectByPath(lpstrPath, ppunkObject,
                                    CoGetCurrentProcess());
    }

    CairoleDebugOut((DEB_ROT, "%p OUT GetLocalRunningObjectForDde"
       "( %lX ) [ %p ]\n", NULL, hr,
           ((ppunkObject == NULL) ? NULL : *ppunkObject)));

    return(hr);
}





//+---------------------------------------------------------------------------
//
//  Function:   GetObjectFromRotByPath
//
//  Synopsis:   Searches for and optionally returns an object by path for
//              pbkect binding.
//
//  Effects:    Attempts to find an entry in the ROT that matches
//              the provided path. If there is a hit in the table, and
//              ppunkObject is not NULL, then it also returns a pointer
//              to the object.
//
//  Arguments:  [lpstrPath] -- Path to search for
//              [ppunkObject] -- Output for the object pointer
//
//  Returns:    S_OK - Found object in local ROT
//              S_FALSE - Didn't find object in local ROT
//              OTHER - Something else happened.
//
//  History:    30-Jan-95   Ricksa  Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetObjectFromRotByPath(
    LPOLESTR lpstrPath,
    LPUNKNOWN *ppunkObject)
{
    CairoleDebugOut((DEB_ROT, "%p _IN GetObjectFromRotByPath"
       "( %p , %p )\n", NULL, lpstrPath, ppunkObject));

    HRESULT hr = S_FALSE;

    // Is the rot in existence yet?
    if (pROT == NULL)
    {
        // No - create the ROT. Remember that pROT is real pointer to the
        // running object table. GetRunningObjectTable returns this and
        // initializes it if it is NULL. This is why we don't pay very much
        // attention to prot.
        IRunningObjectTable *prot;

        GetRunningObjectTable(0, &prot);

        // Note that we don't have to release the prot because the ROT
        // doesn't care about its reference count. Its lifetime is independent
        // of the reference count.
    }

    if (pROT != NULL)
    {
        hr = pROT->IGetObjectByPath(lpstrPath, ppunkObject, 0);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT GetObjectFromRotByPath"
       "( %lX ) [ %p ]\n", NULL, hr, *ppunkObject));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\rot\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME= rot
TARGETPATH= obj
TARGETTYPE= LIBRARY

INCLUDES=   ..\..\..\common\$(DEST_TREE);..\..\..\ih;..;..\..\inc
INCLUDES=   $(INCLUDES);..\..\objact;..\..\dcomrem
INCLUDES=   $(INCLUDES);..\..\..\actprops
INCLUDES=   $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=   $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=   $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)

SOURCES=    \
            ..\access.cxx   \
            ..\crot.cxx     \
            ..\crothint.cxx \
            ..\getif.cxx

UMTYPE=     windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\stackwalk\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   stackwalk
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES    = obj
INCLUDES=     $(INCLUDES);..\..\..\idl\public\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\ih
INCLUDES=     $(INCLUDES);..\..\inc
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

SOURCES=      $(SOURCES)                                      \
              ..\stackwalk.cxx

UMTYPE=       windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\rot\getif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       getif.cxx
//
//  Contents:   APIs used to get an interface from a window
//
//  Classes:    CEndPointAtom
//
//  Functions:  AssignEndpointProperty
//              GetInterfaceFromWindowProp
//              PrivDragDrop
//              UnmarshalDragDataObject
//
//  History:
//              29-Dec-93 Ricksa    Created
//              01-Feb-94 alexgo    fixed a bug in multiple registration
//              29-Mar-94 brucema   GetInterfaceFromWindowProp returns E_FAIL
//                                  for invalid endpoint
//              18-May-94 alexgo    fixed race condition in
//                                  RemGetInterfaceFromWindowProp
//              15-Jun-94 JohannP   added apartment support
//              28-Jul-94 BruceMa   Memory sift fix
//              30-Sep-94 Ricksa    Drag/Drop optimization
//		08-Nov-94 alexgo    added PrivDragDrop protocol
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <crot.hxx>
#include    <getif.h>
#include    <getif.hxx>
#include    <dragopt.h>
#include    <resolver.hxx>


#define ENDPOINT_PROP_NAME      L"OleEndPointID"
#define OLEDRAG_DATAOBJ_PROP	L"Drag_DataObj_Prop"


static WCHAR *apwszValidProperties[] = { OLE_DROP_TARGET_PROP,
					 CLIPBOARD_DATA_OBJECT_PROP };
const int MAX_PROPERTIES = sizeof(apwszValidProperties) / sizeof(WCHAR *);

extern ATOM g_aDropTarget;

HRESULT UnmarshalFromEndpointProperty(HWND hWnd,
				      IInterfaceFromWindowProp **ppIFWP,
				      BOOL *pfLocal);

//+-------------------------------------------------------------------------
//
//  Class:  	CInterfaceFromWindowProp
//
//  Purpose:  	Passes back interface pointers stored on windows for drag drop
//
//  Interface:  IInterfaceFromWindowProp
//
//  History:    dd-mmm-yy Author    Comment
//		14 May 95 AlexMit   Created
//
//--------------------------------------------------------------------------
class CInterfaceFromWindowProp : public IInterfaceFromWindowProp,
				 public CPrivAlloc
{
public:
    CInterfaceFromWindowProp();

    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    STDMETHOD (GetInterfaceFromWindowProp)(
	HWND hWnd,
	REFIID riid,
	IUnknown **ppunk,
	WCHAR *pwszPropertyName );

    STDMETHOD (PrivDragDrop)(
        HWND  hWnd,
        InterfaceData *pIFDDataObject,
	    DWORD dop,
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect,
        DWORD dwSmId,
	    IDataObject *pRealDataObject,
	    HWND  hwndSource );

private:
    ULONG _ulRefCnt;	// Reference count
};

//+-------------------------------------------------------------------
//
//  Member:	CInterfaceFromWindowProp::CInterfaceFromWindowProp, public
//
//  Synopsis:	construction
//
//  History:	10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
CInterfaceFromWindowProp::CInterfaceFromWindowProp() : _ulRefCnt(1)
{
}

//+-------------------------------------------------------------------
//
//  Member:	CInterfaceFromWindowProp::AddRef, public
//
//  Synopsis:	increment reference count
//
//  History:	10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
ULONG CInterfaceFromWindowProp::AddRef(void)
{
    InterlockedIncrement((long *)&_ulRefCnt);
    return _ulRefCnt;
}

//+-------------------------------------------------------------------
//
//  Member:	CInterfaceFromWindowProp::Release, public
//
//  Synopsis:	decrement reference count
//
//  History:	10 Apr 95    AlexMit     Created
//
//--------------------------------------------------------------------
ULONG CInterfaceFromWindowProp::Release(void)
{
    ULONG RefCnt = _ulRefCnt-1;
    if (InterlockedDecrement((long*)&_ulRefCnt) == 0)
    {
	delete this;
	return 0;
    }

    return RefCnt;
}

//+-------------------------------------------------------------------
//
//  Member:     CInterfaceFromWindowProp::QueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:	10 Apr 95   AlexMit	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CInterfaceFromWindowProp::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IInterfaceFromWindowProp) ||  //   more common than IUnknown
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IInterfaceFromWindowProp *) this;
	AddRef();
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Class:  	SDDInfo
//
//  Purpose:  	caches information across drag drop calls
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
// 		08-Jan-95 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
struct SDDInfo : public CPrivAlloc
{
    BOOL                      fLocal;
    IInterfaceFromWindowProp *pIFWP;

    SDDInfo(HWND hWnd, HRESULT& hr);
    ~SDDInfo();
};

//+-------------------------------------------------------------------------
//
//  Member:  	SDDInfo::SDDInfo
//
//  Synopsis:	constructor
//
//  Effects:
//
//  Arguments:	[hr]		-- the return result
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Jan-95 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
inline SDDInfo::SDDInfo(HWND hWnd, HRESULT& hr)
{
    hr = UnmarshalFromEndpointProperty(hWnd,
				       &pIFWP,
				       &fLocal);
}

//+-------------------------------------------------------------------------
//
//  Member:  	SDDInfo::SDDInfo
//
//  Synopsis:	destructor
//
//  Effects:
//
//  History:    dd-mmm-yy Author    Comment
// 		14 May 95 AlexMit   Destroyed
//
//--------------------------------------------------------------------------
inline SDDInfo::~SDDInfo()
{
    if (pIFWP != NULL)
    {
	pIFWP->Release();
	pIFWP = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Class:      CEndPointAtom
//
//  Purpose:    Abstract way of init/delete global atom for end point property
//
//  Interface:  GetPropPtr - get atom of appropriate type to pass to prop APIs
//
//  History:    31-Dec-93 Ricksa    Created
//
//--------------------------------------------------------------------------
class CEndPointAtom
{
public:
                        ~CEndPointAtom(void);

    LPCWSTR             GetPropPtr(void);

private:

    static ATOM		 s_AtomProp;
};

// make this static since there is only one of them and so we dont have
// to run a ctor at process intialization time.

ATOM CEndPointAtom::s_AtomProp = 0;

// Atom for endpoint property string
CEndPointAtom epatm;


//+-------------------------------------------------------------------------
//
//  Member:     CEndPointAtom::~CEndPointAtom
//
//  Synopsis:   Clean up atom at destruction of object
//
//  History:    31-Dec-93 Ricksa    Created
//
//--------------------------------------------------------------------------
inline CEndPointAtom::~CEndPointAtom(void)
{
    if (s_AtomProp != 0)
    {
        //
        //  16-bit WinWord is evil and does not call UnregisterDragDrop
        //  before terminating.  When a window is destroyed under Win95,
        //  all attached properties are removed and atoms deleted.  This
        //  causes a problem with other applications when more deletes than
        //  adds are performed.  This 'hack' will disable the deletion of
        //  the EndPointAtom under Chicago.  Not a big deal since the
        //  Explorer will keep this Atom alive anyways.
        //
        GlobalDeleteAtom(s_AtomProp);

        s_AtomProp = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CEndPointAtom::GetPropPtr
//
//  Synopsis:   Return an atom suitable for passing to prop APIs
//
//  Returns:    Endpoint string as atom or NULL.
//
//  History:    31-Dec-93 Ricksa    Created
//
//--------------------------------------------------------------------------
inline LPCWSTR CEndPointAtom::GetPropPtr(void)
{
    if (s_AtomProp == 0)
    {
	s_AtomProp = GlobalAddAtom(ENDPOINT_PROP_NAME);
    }

    return (LPCWSTR) s_AtomProp;
}

//+-------------------------------------------------------------------------
//
//  Function:   AssignEndpointProperty
//
//  Synopsis:   Assigns a end point as a property of a window
//
//  Arguments:  [hWnd] - window to assign the endpoint property
//
//  Returns:    S_OK - end point successfully added to the window
//              E_INVALIDARG - property could not be set
//
//  Algorithm:  Get the endpoint Id and assign it as a property to the
//              window.
//
//  History:
//              26-Jul-94 AndyH     #20843 - restarting OLE in the shared WOW
//              01-Feb-94 alexgo    fixed a bug to ensure that
//                                  RpcServerRegisterIf gets called only
//                                  once.
//              29-Dec-93 Ricksa    Created
//		22-Jan-95 Rickhi    marshaled interface stored in SCM
//
//--------------------------------------------------------------------------
extern "C" HRESULT AssignEndpointProperty(HWND hWnd)
{
    ComDebOut((DEB_ROT, "AssignEndpointProperty hWnd:%x\n", hWnd));

    // Create an object for this window.
    CInterfaceFromWindowProp *pIFWP = new CInterfaceFromWindowProp;
    if (pIFWP == NULL)
    {
	return E_OUTOFMEMORY;
    }

    // Marshal the interface into the OBJREF
    DWORD_PTR dwCookie = 0;
    OBJREF objref;
    HRESULT hr = MarshalObjRef(objref, IID_IInterfaceFromWindowProp, pIFWP,
			       MSHLFLAGS_TABLESTRONG, MSHCTX_LOCAL, NULL);

    if (SUCCEEDED(hr))
    {
    	OXID_INFO oxidInfo;
    	hr = FillLocalOXIDInfo(objref, oxidInfo);

        if (SUCCEEDED(hr))
        {
            // register the STDOBJREF part of the marshaled interface with the SCM
            hr = gResolver.RegisterWindowPropInterface(hWnd,
                                                       &objref.u_objref.u_standard.std,
                                                       &oxidInfo,
                                                       &dwCookie);
            if (SUCCEEDED(hr))
            {
                // Stuff the magic values in properties on the window.
                if (!SetProp(hWnd, epatm.GetPropPtr(), (void *) dwCookie))
                {
                    hr = E_INVALIDARG;
                }
            }

            // Free the resources containing the String Bindings.
            MIDL_user_free(oxidInfo.psa);
        }

        // release the resources held by the objref.
        FreeObjRef(objref);
    }

    // The stub holds the object alive until UnAssignEndpointProperty
    // is called.  Get rid of the extra reference.
    pIFWP->Release();

    ComDebOut((DEB_ROT, "AssignEndpointProperty hr:%x dwCookie:%x\n", hr, dwCookie));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnAssignEndpointProperty
//
//  Synopsis:   Remove end point property
//
//  Arguments:  [hWnd] - window to remove the endpoint property
//		[dwAssignAptID] - Apartment that Assigned the Endpoint Property
//
//  Returns:    S_OK - end point successfully removed from the window
//              E_INVALIDARG - property could not be removed
//
//  Algorithm:  Remove the end point id property from the window.
//
//  History:	30-Dec-93 Ricksa    Created
//		22-Jan-95 Rickhi    marshaled interface stored in SCM
//		15-Apr-96 Rogerg    Added dwAssignThreadID.
//
//--------------------------------------------------------------------------
extern "C" HRESULT UnAssignEndpointProperty(HWND hWnd,DWORD* dwAssignAptID)
{
    ComDebOut((DEB_ROT, "UnAssignEndpointProperty hWnd:%x\n", hWnd));

    // Read the cookie value from the window property and remove the
    // property from the window.

//
// Sundown v-thief 06/98: GetProp()'s returned HANDLE can be truncated to a DWORD
//                        The returned value is an atom.
//
//
// Note: There is still a major decision to make. In scm.idl and with the fact that
//       com\dcomrem\resolver.cxx:CRpcResolver::GetWindowPropInterface() stores an HWND in 
//       dwCookie. Should we modify the interface?. 
//       In a wider scope: what is the MIDL solution for HWND in remotable or local interfaces?
//
	LPCWSTR   wszProp  = epatm.GetPropPtr();
    DWORD_PTR dwCookie = (wszProp ? (DWORD_PTR)RemoveProp(hWnd, wszProp) : 0);
    BOOL      fSuccess = (dwCookie != 0);

    // use the cookie to extract and release the STDOBJREF entry from the SCM
    OBJREF     objref;
    OXID_INFO  oxidInfo;
    memset(&oxidInfo, 0, sizeof(oxidInfo));

    HRESULT hr = gResolver.GetWindowPropInterface(hWnd, 
                                                  dwCookie,
												  TRUE, // fRevoke
												  &objref.u_objref.u_standard.std,
												  &oxidInfo);
    if (SUCCEEDED(hr))
    {
		BOOL fLocal;

		hr = CompleteObjRef(objref, oxidInfo, IID_IInterfaceFromWindowProp, &fLocal);
		
		MIDL_user_free(oxidInfo.psa);

		if (SUCCEEDED(hr))
		{
			// release the marshal data and free resources on the ObjRef
			hr = ReleaseMarshalObjRef(objref);
			FreeObjRef(objref);
		}
    }

    if (!fSuccess && SUCCEEDED(hr))
    {
        hr = E_INVALIDARG;
    }

    *dwAssignAptID = SUCCEEDED(hr) ? oxidInfo.dwTid : 0;

    ComDebOut((DEB_ROT, "UnAssignEndpointProperty hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:	UnmarshalFromEndpointProperty
//
//  Synopsis:	Get the IInterfaceFromWindowProp interface from the window
//
//  Arguments:	[hWnd] - window to get the endpoint property
//
//  Returns:    S_OK - end point successfully removed from the window
//              E_INVALIDARG - property could not be removed
//
//  Algorithm:
//
//  History:	22-Jan-95 Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT UnmarshalFromEndpointProperty(HWND hWnd,
				      IInterfaceFromWindowProp **ppIFWP,
				      BOOL *pfLocal)
{
    HRESULT hr = E_INVALIDARG;
    *ppIFWP = NULL;

    // get the magic cookie from the window

//
// Sundown v-thief 06/98: GetProp()'s returned HANDLE can be truncated to a DWORD
//                        The returned value is an atom.
//

    DWORD_PTR dwCookie = (DWORD_PTR) GetProp(hWnd, epatm.GetPropPtr());

    if (dwCookie != NULL)
    {
	// Get a proxy to the CInterfaceFromWindowProp object.  Note
	// that if this is the thread that object is on, it will just
	// return the real object.

	OBJREF	   objref;
	OXID_INFO  oxidInfo;
	memset(&oxidInfo, 0, sizeof(oxidInfo));

	hr = gResolver.GetWindowPropInterface(hWnd, 
                                              dwCookie,
					      FALSE, // fRevoke
					      &objref.u_objref.u_standard.std,
					      &oxidInfo);

	if (SUCCEEDED(hr))
	{
	    hr = CompleteObjRef(objref, oxidInfo, IID_IInterfaceFromWindowProp, pfLocal);

	    MIDL_user_free(oxidInfo.psa);

	    if (SUCCEEDED(hr))
	    {
		// unmarshal and release resouces on the ObjRef
		hr = UnmarshalObjRef(objref, (void **) ppIFWP);
		FreeObjRef(objref);
	    }
	}
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetInterfaceFromWindowProp
//
//  Synopsis:   Get an interface that is assigned to a window as a property
//
//  Arguments:  [hWnd] - window of interest
//              [riid] - interface we want back
//              [ppunk] - where to put the requested interface pointer
//              [pwszPropertyName] - name of property holding interface.
//
//  Returns:    S_OK - got the interface
//              E_INVALIDARG - no endpoint property
//
//  Algorithm:  Get the end point from the window and then convert that
//              end point to a proxy. Then call the remote
//              get interface call to get the actual interface.
//
//  History:    29-Dec-93 Ricksa    Created
//		20-Jul-94 alexgo    Optimization for same-thread case
//		22-Jan-95 Rickhi    marshaled interface stored in SCM
//
//--------------------------------------------------------------------------
extern "C" GetInterfaceFromWindowProp(
    HWND hWnd,
    REFIID riid,
    IUnknown **ppunk,
    LPOLESTR pwszPropertyName)
{
    ComDebOut((DEB_ROT,
	"GetInterfaceFromWindowProp hWnd:%x ppunk:%x riid:%I pszPropName%ws\n",
	hWnd, ppunk, &riid, pwszPropertyName));

    *ppunk = NULL;

    BOOL fLocal;
    IInterfaceFromWindowProp *pIFWP;
    HRESULT hr = UnmarshalFromEndpointProperty(hWnd, &pIFWP, &fLocal);

    if (SUCCEEDED(hr))
    {
	hr = pIFWP->GetInterfaceFromWindowProp( hWnd,
					       riid, ppunk,
					       pwszPropertyName);
	pIFWP->Release();
    }

    ComDebOut((DEB_ROT,
	"GetInterfaceFromWindowProp *ppunk:0x%p hr:%x\n", *ppunk, hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method:	CInterfaceFromWindowProp::GetInterfaceFromWindowProp, public
//
//  Synopsis:   Get information from object server ROT
//
//  Arguments:  [pData] - data for call
//
//  Returns:    S_OK - got information
//              S_FALSE - entry for moniker not found in the ROT
//              E_INVALIDARG - bad arguments
//
//  Algorithm:  Unmarshal the moniker interface. Then look up the object
//              in the ROT. If found, return the requested data.
//
//  History:    15-Dec-93 Ricksa    Created
//              18-May-94 alexgo    fixed race condition, this function now
//                                  fetches the interface from the hwnd
//
//--------------------------------------------------------------------------
STDMETHODIMP CInterfaceFromWindowProp::GetInterfaceFromWindowProp(
    HWND hWnd,
    REFIID riid,
    IUnknown **ppunk,
    WCHAR *pwszPropertyName )
{
    HRESULT hr;

    // Validate the requested property
    for (int i = 0; i < MAX_PROPERTIES; i++)
    {
        if (lstrcmpW(apwszValidProperties[i], pwszPropertyName) == 0)
        {
            break;
        }
    }

    if (i == MAX_PROPERTIES)
    {
	*ppunk = NULL;
	return E_INVALIDARG;
    }

    // Get the interface pointer from the window
    *ppunk = (IUnknown *) GetProp( hWnd, pwszPropertyName );

    // Could we get the property requested?
    if (*ppunk != NULL)
    {
	hr = S_OK;
	(*ppunk)->AddRef();
    }
    else
    {
        // No property -- this can happen when the object got shutdown
        // during the time that the client was trying to get the property.
        hr = E_FAIL;
    }
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Method:	CInterfaceFromWindowProp::PrivDragDrop, public
//
//  Synopsis: 	interprets the DragOp parameter and makes the appropriate
//		call to the drop target.
//
//  Effects:
//
//  Arguments:	[hwnd]		-- the target window
//	 	[dop]		-- the drag drop op
//		[grfKeyState] 	-- the keyboard state
//		[ptl]		-- the mouse position
//		[pdwEffects] 	-- the drag drop effects
//		[pIFDataObject]	-- interface data for the drag data object
//		[dwSmId]	-- shared memory ID for the data formats
//		[hwndSource]	-- the window handle to the drag drop source
//				   (i.e. our private dragdrop/clipboard
//				   window)
//
//  Requires: 	pIFDataObject && dwSmId must be NULL if pRealDataObj is
//		not NULL.
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//		finds the drop target and calls it according to 'dop'
//		(the drag drop op code)
//
//		for DRAGOP_ENTER:
//			create the psuedo-data object for returning enumerated
//			formats. Stuff this data object as a property on the
//			target window.  Then through to the actual drag enter
//			object.
//
// 		for DRAGOP_OVER:
//			simply call IDropTarget::DragOver
//
//		for DRAGOP_LEAVE
//			remove the data object from the target window
//			and call IUnknown->Release();  Then call IDropTarget::
//			DragLeave
//
//		for DRAGOP_DROP
//			remove the data object from the target window and
//			pass it into IDropTarget::Drop call.  Once the call
//			completes, Release the data object
//
//  History:    dd-mmm-yy Author    Comment
//		08-Nov-94 alexgo    author
//
//  Notes:
//		HACK ALERT!!  It is important that we use the same data object
//		for DragEnter and Drop calls.  Some 16bit apps (like
//		MS PowerPoint) check to see if the data object pointer value
//		is the same--if it's not, then they fail the drop call.
//
//--------------------------------------------------------------------------
STDMETHODIMP CInterfaceFromWindowProp::PrivDragDrop(
        HWND hwnd,
		InterfaceData *pIFDataObject,
		DWORD dop,
		DWORD grfKeyState,
		POINTL ptl,
	    DWORD * pdwEffects,
		DWORD dwSmId,
		IDataObject *pRealDataObject,
		HWND hwndSource )
{
    IDropTarget *pIDropTarget;
    IDataObject *pIDataObject;
    HRESULT	hr = E_FAIL;


#if DBG == 1
    if( pRealDataObject != NULL )
    {
	Assert(!pIFDataObject);
    }
#endif // DBG == 1

    pIDropTarget = (IDropTarget *)GetProp((HWND) hwnd, (LPCWSTR)g_aDropTarget);

    if (pIDropTarget != NULL)
    {
	// check the drag drop op code and do the right thing

	switch( dop )
	{
	case DRAGOP_ENTER:
	    // Create a data object for use in the Drag Enter if we
	    // weren't given one

	    if( pRealDataObject == NULL )
	    {
		InterfaceData *pIFTemp = NULL;

		Assert(pIFDataObject);

		if( pIFDataObject )
		{
		    // we need to make a copy of the interface data, as
		    // the fake data object may use it after this function
		    // returns (see ido.cpp)
	
		    pIFTemp = (InterfaceData *)PrivMemAlloc(
				    IFD_SIZE(pIFDataObject));
	
		    if( !pIFTemp )
		    {
			return E_OUTOFMEMORY;
		    }
	
		    memcpy(pIFTemp, pIFDataObject,
			    IFD_SIZE(pIFDataObject));
		}
		hr = CreateDragDataObject(pIFTemp, dwSmId,
			&pIDataObject);
	    }
	    else
	    {
		pIDataObject = pRealDataObject;
		pIDataObject->AddRef();
		hr = NOERROR;
	    }

	    if (hr == NOERROR)
	    {
		// Call through to the drop target
		hr = pIDropTarget->DragEnter(
			pIDataObject,
			grfKeyState,
			ptl,
			pdwEffects);

		// Bug#12835 Win16 set the DROPEFFECT to none on an error returned by DragEnter
                //  but continued the drag within the window
                if ( (NOERROR != hr) && IsWOWThread() )
                {
		    *pdwEffects = DROPEFFECT_NONE;
		    hr = NOERROR;
		}

		if (NOERROR == hr)
		{
		    SetProp((HWND) hwnd, OLEDRAG_DATAOBJ_PROP, pIDataObject);
		}
		else
		{
		    pIDataObject->Release();
		}
	    }

	    break;

	case DRAGOP_OVER:

	    hr = pIDropTarget->DragOver(grfKeyState, ptl, pdwEffects);

	    break;

	case DRAGOP_LEAVE:

	    pIDataObject = (IDataObject *)RemoveProp((HWND) hwnd,	
				OLEDRAG_DATAOBJ_PROP);

	    if( pIDataObject )
	    {
		pIDataObject->Release();
	    }

	    hr = pIDropTarget->DragLeave();

	    break;

	case DRAGOP_DROP:

	    pIDataObject = (IDataObject *)RemoveProp((HWND) hwnd,
				OLEDRAG_DATAOBJ_PROP);


	    if( pIDataObject )
	    {
		DWORD pidSource;
		DWORD tidSource = 0;
		BOOL fAttached = FALSE;

		// HACK ALERT!!!  Some 16bit apps (like Word) try to
		// become the foreground window via SetActiveWindow.
		// However, if a 32bit app is the source, it is the
		// foreground *thread*; SetActiveWindow only makes the
		// window the foreground window for the current input
		// queue.
		// In order to maket this work, if we are a 16bit target
		// and the source exists in a different process (either
		// a 32bit process or a different VDM), then attach
		// our input queue to the source's input queue.
		//
		// Within one VDM the thread's queues are already attached

		if( IsWOWThread() && hwndSource != NULL )
		{
		    tidSource = GetWindowThreadProcessId((HWND)hwndSource,
					&pidSource);

		    if( pidSource != GetCurrentProcessId() )
		    {
    			AttachThreadInput(GetCurrentThreadId(), tidSource,
    			    TRUE);
    			fAttached = TRUE;
		    }
		}

		hr = pIDropTarget->Drop( pIDataObject, grfKeyState, ptl,
			    pdwEffects);

		if( fAttached == TRUE )
		{
		    AttachThreadInput(GetCurrentThreadId(), tidSource,
			    FALSE);
		}

		pIDataObject->Release();
	    }

	    break;

	default:
	    Assert(0);
	    hr = E_UNEXPECTED;

	}

	// HACK ALERT!! Well, it turns out that 16bit OLE used
	// "CurScrollMove" for the Scroll-NoDrop cursor.  Better yet,
	// MFC *depends* on this in their drag drop implementation.
	// An MFC target doing scroll-move will actually return
	// drop effect scroll-nodrop.
	//
	// So if we are in a 16bit app as the target, munge the
	// effect to better match 16bit OLE behavior.

	if( IsWOWThread() && pdwEffects )
	{
	    // test for SCROLL-NODROP
	    if( *pdwEffects == DROPEFFECT_SCROLL )
	    {
		*pdwEffects |= DROPEFFECT_MOVE;
	    }
	}
	
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   PrivDragDrop
//
//  Synopsis:   Package up drag enter to be sent to the drop target.
//
//  Arguments:  [hWnd]- handle to the window to get target from
//		[dop] - the drag drop operation to perform
//		[IDOBuffer] - the marshalled buffer for the data object
//              [pIDataObject] - data object from source
//              [grfKeyState] - current key state
//              [ptl] - point where drop would occur
//              [pdwEffect] - proposed valid effects
//		[hwndSource] - the handle to OLE's drag drop source window
//		[phDDInfo]    -- pointer to a DragDropInfo handle, for
//				 caching rpc info about the drop target.
//			         May not be NULL, but on DragEnter,
//				 should be a pointer to NULL.
//
//  Returns:    S_OK - call succeeded
//              Other - call failed
//
//  Algorithm:  First determine if the the window is for the current thread
//              If it is, then immediately interpret the drag op. If not,
//		get the end point from the window and package up
//		the call to be dispatched to RPC.
//
//  History:    30-Sep-94 Ricksa    Created
//		08-Nov-94 alexgo    modified to use DRAGOP's
//		08-Jan-95 alexgo    added caching of RPC binding handles via
//				    DDInfo handles
//
//--------------------------------------------------------------------------
HRESULT PrivDragDrop(
    HWND hWnd,
    DRAGOP dop,
    IFBuffer IDOBuffer,
    IDataObject *pIDataObject,
    DWORD grfKeyState,
    POINTL ptl,
    DWORD *pdwEffect,
    HWND hwndSource,
    DDInfo *phDDInfo)
{
    HRESULT hr = S_FALSE;    // If the endpoint is invalid
    SDDInfo *pddinfo = *(SDDInfo **)phDDInfo;

    InterfaceData *pIFData = (InterfaceData *)IDOBuffer;

#if DBG == 1
    Assert(phDDInfo);
    if( dop == DRAGOP_ENTER )
    {
	Assert(*phDDInfo == NULL);
    }
    // we can't assert the reverse case because phDDInfo will be NULL
    // in DROPOP_OVER, etc if we are drag drop'ing to the same thread...

#endif // DBG == 1


    // If we don't have any cached information (i.e. pddinfo == NULL),
    // then get the endpoint id from the window	and construct a
    // PrivDragDrop data structure.  If the window is on the current
    // thread, the PrivDragDrop structure will end up with a pointer
    // to the CInterfaceFromWindowProp object rather then a proxy.

    if( pddinfo == NULL )
    {
	{
	    pddinfo = new SDDInfo(hWnd, hr);

	    if( pddinfo == NULL )
	    {
   		return E_OUTOFMEMORY;
	    }

	    if( hr != NOERROR )
	    {
		delete pddinfo;
		return E_FAIL;
	    }

	    *phDDInfo = (DDInfo)pddinfo;
	}
    }

    if( pddinfo != NULL )
    {
	hr = pddinfo->pIFWP->PrivDragDrop( hWnd,
			    (pddinfo->fLocal) ? NULL : pIFData,
			    dop,
	                    grfKeyState, ptl,
			    (pdwEffect) ? pdwEffect : DROPEFFECT_NONE,
			    GetCurrentThreadId(),
			    (pddinfo->fLocal) ? pIDataObject : NULL,
			    hwndSource );
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   UnmarshalDragDataObject
//
//  Synopsis:   Unmarshal the drag source's data object
//
//  Arguments:  [pvMarshaledDataObject] - pointer to interface buffer
//
//  Returns:    NULL - unmarshal failed
//              ~NULL - got the real data object on source
//
//  Algorithm:  Unmarshal interface and return whether we got an interface
//              back.
//
//  History:    30-Sep-94 Ricksa    Created
//
//  Note:       This call really exists so that the drag code over in
//              ole232/drag won't have to copy in all the marshaling stuff.
//
//--------------------------------------------------------------------------
IDataObject *UnmarshalDragDataObject(void *pvMarshaledDataObject)
{
    InterfaceData *pIFD = (InterfaceData *) pvMarshaledDataObject;

    // Convert returned interface to  a stream
    CXmitRpcStream xrpc(pIFD);

    IDataObject *pIDataObject;

    HRESULT hr = CoUnmarshalInterface(
        &xrpc,
        IID_IDataObject,
        (void **) &pIDataObject);

    return (SUCCEEDED(hr)) ? pIDataObject : NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:	GetMarshalledInterfaceBuffer
//
//  Synopsis:	marshals the given interface into an allocated buffer.  The
//		buffer is returned
//
//  Effects:
//
//  Arguments:	[refiid]	-- the iid of the interface to marshal
//		[punk]		-- the IUnknown to marshal
//		[pIFBuf]	-- where to return the buffer
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm: 	calls CoMarshalInterface(MSHFLAGS_TABLESTRONG)
//
//  History:    dd-mmm-yy Author    Comment
// 		03-Dec-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT GetMarshalledInterfaceBuffer( REFIID riid, IUnknown *punk, IFBuffer
	    *pIFBuf)
{
    HRESULT hr;

    InterfaceData *pIFD = NULL;

    CXmitRpcStream xrpc;

    hr = CoMarshalInterface(&xrpc, riid, punk, MSHCTX_NOSHAREDMEM, NULL,
	    MSHLFLAGS_TABLESTRONG);

    if( hr == NOERROR )
    {
	xrpc.AssignSerializedInterface(&pIFD);
    }

    *pIFBuf = (IFBuffer)pIFD;

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:	ReleaseMarshalledInterfaceBuffer
//
//  Synopsis:	releases the buffer allocated by GetMarshalledInterfaceBuffer
//
//  Effects:
//
//  Arguments: 	[IFBuf]		-- the interface buffer to release
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm: 	calls CoReleaseMarshalData to undo the TABLE_STRONG
//		marshalling
//
//  History:    dd-mmm-yy Author    Comment
//  		03-Dec-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT ReleaseMarshalledInterfaceBuffer( IFBuffer IFBuf )
{
    HRESULT hr = E_INVALIDARG;

    if( IFBuf )
    {
	CXmitRpcStream xrpc( (InterfaceData *)IFBuf );

	hr = CoReleaseMarshalData(&xrpc);

	CoTaskMemFree((void *)IFBuf);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:  	FreeDragDropInfo
//
//  Synopsis:	frees the SPrivDragDrop structure
//
//  Effects:
//
//  Arguments:	[hDDInfo]	-- pointer to free
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Jan-95 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------
void FreeDragDropInfo( DDInfo hDDInfo )
{
    SDDInfo *pddinfo = (SDDInfo *)hDDInfo;

    delete pddinfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\stackwalk\stackwalk.cxx ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.

#include <windows.h>
#include <objbase.h>
#include <strsafe.h>

#include "StackWalk.h"
#include "debnot.h"
#include "olesem.hxx"

#include "StackWalk.hxx"

// Critical section protecting SymInitialize and SymCleanup
COleStaticMutexSem gSymInitLock;

extern LONG SymAPIExceptionFilter (LPEXCEPTION_POINTERS lpep);

HRESULT CStackWalkerCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    CStackWalker* stackwalk = new CStackWalker(); // Implicit addref
    if (stackwalk == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = stackwalk->QueryInterface (riid, ppv);
    stackwalk->Release();
    return hr;
}

inline HRESULT ConvertToUnicode (LPCSTR pszAnsi, LPWSTR* ppwszUnicode)
{
    int nLen;

    if (!pszAnsi || *pszAnsi == '\0')
    {
        *ppwszUnicode = new WCHAR;
        if (!*ppwszUnicode)
            return E_OUTOFMEMORY;
        
        **ppwszUnicode = L'\0';
        return S_OK;
    }

    nLen = MultiByteToWideChar (CP_THREAD_ACP, 0,  pszAnsi, -1, NULL, 0);
    if (!nLen)
        return HRESULT_FROM_WIN32 (GetLastError());

    *ppwszUnicode = new WCHAR [nLen];
    if (!*ppwszUnicode)
        return E_OUTOFMEMORY;

    nLen = MultiByteToWideChar (CP_THREAD_ACP, 0,  pszAnsi, -1, *ppwszUnicode, nLen);
    if (!nLen)
    {
        delete [] (*ppwszUnicode);
        *ppwszUnicode = NULL;
        return HRESULT_FROM_WIN32 (GetLastError());
    }

    return S_OK;
}


//
// Thread-safe wrappers around Sym* APIs
//

void CoSymLock()
{
    ASSERT_LOCK_NOT_HELD(gSymInitLock);
    LOCK(gSymInitLock);
    ASSERT_LOCK_HELD(gSymInitLock);
}

void CoSymUnlock()
{
    ASSERT_LOCK_HELD(gSymInitLock);
    UNLOCK(gSymInitLock);
    ASSERT_LOCK_NOT_HELD(gSymInitLock);
}

#define SYMWRAP(fxncall) { CoSymLock(); __try { fxncall; } __except (SymAPIExceptionFilter (GetExceptionInformation())) {} CoSymUnlock(); }


BOOL CoSymInitialize(
  HANDLE hProcess,     
  PSTR UserSearchPath,  
  BOOL fInvadeProcess)
{
    BOOL fRet = FALSE;
    SYMWRAP (fRet = SymInitialize (hProcess, UserSearchPath, fInvadeProcess));
    return fRet;
}

void CoSymCleanup (
    HANDLE hProcess)
{
    SYMWRAP (SymCleanup (hProcess));
}

DWORD CoSymSetOptions(
  DWORD SymOptions  )
{
    DWORD dwRet = 0;
    SYMWRAP (dwRet = SymSetOptions (SymOptions));
    return dwRet;
}


BOOL CoSymGetModuleInfoW64(
  HANDLE hProcess,              
  DWORD64 dwAddr,                 
  PIMAGEHLP_MODULEW64 ModuleInfo)
{
    BOOL fRet = FALSE;
    SYMWRAP (fRet = SymGetModuleInfoW64 (hProcess, dwAddr, ModuleInfo));
    return fRet;
}

DWORD64 CoSymLoadModule64(
  HANDLE hProcess,  
  HANDLE hFile,     
  PSTR ImageName,  
  PSTR ModuleName, 
  DWORD64 BaseOfDll,  
  DWORD SizeOfDll)
{
    DWORD64 dw64 = 0;
    SYMWRAP (dw64 = SymLoadModule64 (hProcess, hFile, ImageName, ModuleName, BaseOfDll, SizeOfDll));
    return dw64;
}

BOOL CoSymGetSymFromAddr64(
  HANDLE hProcess,             
  DWORD64 Address,               
  PDWORD64 Displacement,       
  PIMAGEHLP_SYMBOL64 Symbol)
{
    BOOL fRet = FALSE;
    SYMWRAP (fRet = SymGetSymFromAddr64 (hProcess, Address, Displacement, Symbol));
    return fRet;
}

BOOL CoStackWalk64(
  DWORD MachineType, 
  HANDLE hProcess, 
  HANDLE hThread, 
  LPSTACKFRAME64 StackFrame, 
  PVOID ContextRecord, 
  PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,  
  PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
  PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine, 
  PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress)
{
    BOOL fRet = FALSE;
    SYMWRAP (fRet = StackWalk64 (MachineType, hProcess, hThread, StackFrame, ContextRecord, ReadMemoryRoutine, FunctionTableAccessRoutine, GetModuleBaseRoutine, TranslateAddress));
    return fRet;
}

//
// CStackWalker
//
CStackWalker::CStackWalker()
{
    m_cRef = 1;
    m_hProcess = NULL;
}

CStackWalker::~CStackWalker()
{
    // SymInit / SymCleanup pairs refcount
    if (m_hProcess)
    {
        CoSymCleanup (m_hProcess);

        if (m_hProcess != GetCurrentProcess())
        {
            CloseHandle (m_hProcess);
        }
    }
}

STDMETHODIMP CStackWalker::QueryInterface (REFIID riid, LPVOID* ppvObj)
{
    if (!ppvObj)
        return E_POINTER;

    if (riid == IID_IStackWalker || riid == IID_IUnknown)
    {
        *ppvObj = (IStackWalker*) this;
        AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CStackWalker::AddRef()
{
    return InterlockedIncrement (&m_cRef);
}

STDMETHODIMP_(ULONG) CStackWalker::Release()
{
    LONG cRef = InterlockedDecrement (&m_cRef);
    if (cRef == 0) delete this;
    return cRef;
}

DWORD64 CStackWalker::LoadModule (HANDLE hProcess, DWORD64 dw64Address)
{
    MEMORY_BASIC_INFORMATION mbi = {0};

    if (VirtualQueryEx (hProcess, (LPCVOID) dw64Address, &mbi, sizeof (mbi)))
    {
        if (mbi.Type & MEM_IMAGE)
        {
            char module[MAX_PATH + 1] = {0};
            DWORD cch = GetModuleFileNameA ((HMODULE) mbi.AllocationBase, module, sizeof (module) / sizeof (module[0]));

            if (CoSymLoadModule64 (hProcess, NULL, (cch) ? module : NULL, NULL, (DWORD64) mbi.AllocationBase, 0))
            {
                return (DWORD64) mbi.AllocationBase;
            }
        }
    }

    return 0;
}

STDMETHODIMP CStackWalker::Attach (HANDLE hProcess)
{
    if (m_hProcess)
        return HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

    HRESULT hr = S_OK;
    
    if (!hProcess)
    {
        hProcess = GetCurrentProcess();
    }
    else if (hProcess != GetCurrentProcess())
    {
        if (!DuplicateHandle (
            GetCurrentProcess(),
            hProcess, 
            GetCurrentProcess(),
            &hProcess,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS))
            
            return HRESULT_FROM_WIN32 (GetLastError());            
    }

    if (CoSymInitialize (hProcess, NULL, FALSE))
    {
        CoSymSetOptions (0);
    }
    else
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());
    }

    if (SUCCEEDED (hr))
    {
        m_hProcess = hProcess;
    }
    else if (hProcess != GetCurrentProcess())
    {
        CloseHandle (hProcess);
    }

    return hr;
}

STDMETHODIMP_(IStackWalkerSymbol*) CStackWalker::ResolveAddress (DWORD64 dw64Addr)
{
    if (!m_hProcess)
        return NULL;
    
    return ResolveAddressInternal (dw64Addr, 0);
}

CStackWalkerSymbol* CStackWalker::ResolveAddressInternal (DWORD64 dw64Addr, DWORD dwFlags)
{
    DWORD64 dw64displacement = dw64Addr, dw64SymbolAddress = dw64Addr;
    CStackWalkerSymbol* pSymbol = NULL;

    LPCWSTR pwszModule = NULL;
    char* symbolName = NULL;
    char* undecoratedName = NULL;

    WCHAR* pwszSymbolName = NULL;

    PIMAGEHLP_SYMBOL64 symbolInfo = NULL;
    IMAGEHLP_MODULEW64 moduleInfo = {0};
    moduleInfo.SizeOfStruct = sizeof (moduleInfo);

    if (!(dwFlags & CREATESTACKTRACE_ONLYADDRESSES))
    {
        // Find out what module the address lies in
        if (CoSymGetModuleInfoW64 (m_hProcess, dw64Addr, &moduleInfo))
        {
            pwszModule = moduleInfo.ModuleName;
        }
        else
        {
            // First attempt failed, so best effort load the module info.
            LoadModule (m_hProcess, dw64Addr);

            if (CoSymGetModuleInfoW64 (m_hProcess, dw64Addr, &moduleInfo))
                pwszModule = moduleInfo.ModuleName;
        }

        // Allocate memory for the name
        undecoratedName = new char [MAX_SYM_NAME + 1];
        if (!undecoratedName)
            goto Cleanup;

        symbolInfo = (PIMAGEHLP_SYMBOL64) new BYTE [sizeof (IMAGEHLP_SYMBOL64) + MAX_SYM_NAME + 1];
        if (!symbolInfo)
            goto Cleanup;

        symbolInfo->SizeOfStruct = sizeof (IMAGEHLP_SYMBOL64) + MAX_SYM_NAME;
        symbolInfo->MaxNameLength = MAX_SYM_NAME;

        // Resolve the name
        if (CoSymGetSymFromAddr64 (m_hProcess, dw64Addr, &dw64displacement, symbolInfo))
        {
            static const DWORD flags = UNDNAME_NO_MS_KEYWORDS 
                | UNDNAME_NO_ACCESS_SPECIFIERS
                | UNDNAME_NO_FUNCTION_RETURNS
                | UNDNAME_NO_MEMBER_TYPE;
            
            if (UnDecorateSymbolName (symbolInfo->Name, undecoratedName, MAX_SYM_NAME, flags))
                symbolName = undecoratedName;
            else
                symbolName = symbolInfo->Name;
        }
        else if (pwszModule)
        {
            dw64displacement = dw64Addr - moduleInfo.BaseOfImage;
        }
    }

    pSymbol = new CStackWalkerSymbol();
    if (pSymbol)
    {
        if (FAILED (ConvertToUnicode (symbolName, &pwszSymbolName)) ||
            FAILED (pSymbol->Init (pwszModule, pwszSymbolName, dw64SymbolAddress, dw64displacement)))
        {
            delete pSymbol;
            pSymbol = NULL;
        }
    }

Cleanup:

    if (undecoratedName) delete [] undecoratedName;
    if (symbolInfo) delete symbolInfo;
    if (pwszSymbolName) delete [] pwszSymbolName;

    return pSymbol;
}

STDMETHODIMP_(IStackWalkerStack*)  CStackWalker::CreateStackTrace (LPVOID pContext, HANDLE hThread, DWORD dwFlags)
{
    if (!m_hProcess)
        return NULL;
    
    if (hThread == NULL)
        hThread = GetCurrentThread();

    const PCONTEXT context = (PCONTEXT) pContext;

    // Make a local copy of the context
    CONTEXT cLocalContext;
    CopyMemory (&cLocalContext, context, sizeof (CONTEXT));

    DWORD dwMachineType;
    STACKFRAME64 frame = {0};

    frame.AddrPC.Mode = AddrModeFlat;

#if defined(_M_IX86)
    dwMachineType          = IMAGE_FILE_MACHINE_I386;
    frame.AddrPC.Offset    = context->Eip;  // Program Counter    
    frame.AddrStack.Offset = context->Esp;  // Stack Pointer
    frame.AddrStack.Mode   = AddrModeFlat;
    frame.AddrFrame.Offset = context->Ebp;  // Frame Pointer

#elif defined(_M_IA64)
    dwMachineType          = IMAGE_FILE_MACHINE_IA64;
    frame.AddrPC.Offset    = context->StIIP;  // Program Counter
    frame.AddrStack.Offset = context->IntSp; //Stack Pointer
    frame.AddrStack.Mode   = AddrModeFlat;

#elif defined(_M_AMD64)
    dwMachineType          = IMAGE_FILE_MACHINE_AMD64;
    frame.AddrPC.Offset    = context->Rip;  // Program Counter
    frame.AddrStack.Offset = context->Rsp;  //Stack Pointer
    frame.AddrStack.Mode   = AddrModeFlat;
    frame.AddrFrame.Offset = context->Rbp;  // Frame Pointer

#else
#error ("Unknown Target Machine");
#endif
    
    // These variables are used to count the number of consecutive frames 
    // with the exact same PC returned by StackWalk().  On the Alpha infinite
    // loops (and infinite lists!) were being caused by StackWalk() never 
    // returning FALSE (see Raid Bug #8354 for details).
    const DWORD dwMaxNumRepetitions = 40;
    DWORD dwRepetitions = 0;
    ADDRESS64 addrRepeated = {0, 0, AddrModeFlat};

    // Walk the stack...
    CStackWalkerSymbol* prev = NULL;
    CStackWalkerSymbol* head = NULL;

    for (;;)
    {
        if (!CoStackWalk64 (dwMachineType,
            m_hProcess,
            hThread,
            &frame,
            &cLocalContext,
            NULL,
            SymFunctionTableAccess64,
            SymGetModuleBase64,
            NULL))
            break;

        // Check for repeated addresses;  if dwMaxNumRepetitions are found,
        // then we break out of the loop and exit the stack walk
        if (addrRepeated.Offset == frame.AddrPC.Offset && addrRepeated.Mode == frame.AddrPC.Mode)
        {
            dwRepetitions ++;
            if (dwRepetitions == dwMaxNumRepetitions)
                break;
        }
        else
        {
            dwRepetitions = 0;
            addrRepeated.Offset = frame.AddrPC.Offset;
            addrRepeated.Mode = frame.AddrPC.Mode;
        }

        // There have been reports of StackWalk returning an offset of
        // -1, which SymLoadModule later av's on.   If this happens,
        // we simply skip that frame.
        if (frame.AddrPC.Offset == -1)
            continue;

        CStackWalkerSymbol* sym = ResolveAddressInternal (frame.AddrPC.Offset, dwFlags);
        if (sym == NULL)
            break;

        // Append this symbol to the previous one, if any.
        if (prev == NULL)
        {
            prev = sym;
            head = sym;
        }
        else
        {
            // Prev owns reference on sym
            prev->Append(sym);
            prev = sym;
        }
    }

    if (head)
    {
        CStackWalkerStack* pStack = new CStackWalkerStack (head, dwFlags);
        if (pStack)
            // This object now owns the reference on the list head
            return pStack;

        // Destroy the list
        head->Release();
    }

    return NULL;
}


//
// CStackWalkerStack
//
CStackWalkerStack::CStackWalkerStack (CStackWalkerSymbol* pTopSymbol, DWORD dwFlags)
{
    m_cRef = 1;
    m_pTopSymbol = pTopSymbol;
    m_dwFlags = dwFlags;
}
    
CStackWalkerStack::~CStackWalkerStack()
{
    if (m_pTopSymbol)
        m_pTopSymbol->Release();
}    

STDMETHODIMP CStackWalkerStack::QueryInterface (REFIID riid, LPVOID* ppvObj)
{
    if (!ppvObj)
        return E_POINTER;

    if (riid == IID_IStackWalkerStack || riid == IID_IUnknown)
    {
        *ppvObj = (IStackWalkerStack*) this;
        AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CStackWalkerStack::AddRef()
{
    return InterlockedIncrement (&m_cRef);
}

STDMETHODIMP_(ULONG) CStackWalkerStack::Release()
{
    LONG cRef = InterlockedDecrement (&m_cRef);
    if (cRef == 0) delete this;
    return cRef;
}

STDMETHODIMP_(SIZE_T) CStackWalkerStack::Size (LONG lMaxNumLines)
{
    SIZE_T nSize = 3; // Start with a "\r\n" and a null terminator
    LPCWSTR module = NULL;
    LPCWSTR symbolName = NULL;

    LONG lNumLines = 0;
    static const SIZE_T stDigits = 48;

    IStackWalkerSymbol* sym = m_pTopSymbol, * tmp = NULL;
    if (sym)
        // Balance Release() below
        sym->AddRef();
    
    while (sym != NULL)
    {
        if (m_dwFlags & CREATESTACKTRACE_ONLYADDRESSES)
        {
            nSize += stDigits;
        }
        else
        {
            module = sym->ModuleName();
            symbolName = sym->SymbolName();
            nSize += lstrlen (module);
            nSize += lstrlen (symbolName);
            nSize += stDigits; // displacement, spaces, etc.
        }

        tmp = sym;
        sym = sym->Next();
        tmp->Release();

        lNumLines ++;
        if (lNumLines == lMaxNumLines)
        {
            if (sym)
                sym->Release();
            break;
        }
    }
    return nSize;
}

STDMETHODIMP_(IStackWalkerSymbol*) CStackWalkerStack::TopSymbol()
{
    if (m_pTopSymbol)
        m_pTopSymbol->AddRef();

    return m_pTopSymbol;
}

STDMETHODIMP_(BOOL) CStackWalkerStack::GetStack (SIZE_T nChars, LPWSTR wsz, LONG lMaxNumLines)
{
    if (!nChars || !wsz)
        return FALSE;

    LPCWSTR module = NULL;
    LPCWSTR symbolName = NULL;

    LONG lNumLines = 0;
    IStackWalkerSymbol* sym = m_pTopSymbol, * tmp = NULL;
    if (sym)
        // Balance Release() below
        sym->AddRef();

    // Start with a CR-LF.
    StringCchCopy (wsz, nChars, L"\r\n");

    while (sym != NULL) 
    {   
        if (m_dwFlags & CREATESTACKTRACE_ONLYADDRESSES)
        {
            CStackWalkerSymbol::AppendAddress (wsz, nChars, sym->Address());
        }
        else
        {
            module = sym->ModuleName();
            symbolName = sym->SymbolName();         
            if (module) 
            {
                StringCchCat (wsz, nChars, module);
                if (symbolName != NULL)
                    StringCchCat (wsz, nChars, L"!");
            }

            if (symbolName)
                StringCchCat (wsz, nChars, symbolName);

            CStackWalkerSymbol::AppendDisplacement (wsz, nChars, sym->Displacement());
        }

        StringCchCat (wsz, nChars, L"\r\n");

        tmp = sym;
        sym = sym->Next();
        tmp->Release();

        lNumLines ++;
        if (lNumLines == lMaxNumLines)
        {
            if (sym)
                sym->Release();
            break;
        }
    }

    return TRUE;
}


//
// CStackWalkerSymbol
//
CStackWalkerSymbol::CStackWalkerSymbol()
{
    m_cRef = 1;
    m_pwszModuleName = NULL;
    m_pwszSymbolName = NULL;
    m_dw64Displacement = 0;
    m_dw64Address = 0;
    m_pNext = NULL;
}

CStackWalkerSymbol::~CStackWalkerSymbol()
{
    free (m_pwszModuleName);
    free (m_pwszSymbolName);

    if (m_pNext)
        m_pNext->Release();
}

HRESULT CStackWalkerSymbol::Init (LPCWSTR pwszModuleName, LPCWSTR pwszSymbolName, DWORD64 dw64Address, DWORD64 dw64Displacement)
{
    if (pwszModuleName != NULL)
    {
        m_pwszModuleName = _wcsdup (pwszModuleName);
        if (!m_pwszModuleName)
            return E_OUTOFMEMORY;
    }

    if (pwszSymbolName != NULL)
    {
        m_pwszSymbolName = _wcsdup (pwszSymbolName);
        if (!m_pwszSymbolName)
        {
            free (m_pwszModuleName);
            m_pwszModuleName = NULL;
            return E_OUTOFMEMORY;
        }
    }

    m_dw64Displacement = dw64Displacement;
    m_dw64Address = dw64Address;
    
    return S_OK;
}

STDMETHODIMP CStackWalkerSymbol::QueryInterface (REFIID riid, LPVOID* ppvObj)
{
    if (!ppvObj)
        return E_POINTER;

    if (riid == IID_IStackWalkerSymbol || riid == IID_IUnknown)
    {
        *ppvObj = (IStackWalkerSymbol*) this;
        AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CStackWalkerSymbol::AddRef()
{
    return InterlockedIncrement (&m_cRef);
}

STDMETHODIMP_(ULONG) CStackWalkerSymbol::Release()
{
    LONG cRef = InterlockedDecrement (&m_cRef);
    if (cRef == 0) delete this;
    return cRef;
}

LPCWSTR CStackWalkerSymbol::ModuleName()
{
    return m_pwszModuleName;
}

LPCWSTR CStackWalkerSymbol::SymbolName()
{
    return m_pwszSymbolName;
}

DWORD64 CStackWalkerSymbol::Address()
{
    return m_dw64Address;
}

DWORD64 CStackWalkerSymbol::Displacement()
{
    return m_dw64Displacement;
}
    
IStackWalkerSymbol* CStackWalkerSymbol::Next()
{
    if (m_pNext)
        m_pNext->AddRef();

    return m_pNext;
}

void CStackWalkerSymbol::Append (CStackWalkerSymbol* sym)
{
    Win4Assert (!m_pNext);
    m_pNext = sym;
}

void CStackWalkerSymbol::AppendDisplacement (LPWSTR wsz, SIZE_T nChars, DWORD64 dw64Displacement)
{
    WCHAR wszDisp [64];
    StringCchPrintf (wszDisp, sizeof (wszDisp) / sizeof (wszDisp[0]), L" + 0x%I64x", dw64Displacement);
    StringCchCat (wsz, nChars, wszDisp);
}

void CStackWalkerSymbol::AppendAddress (LPWSTR wsz, SIZE_T nChars, DWORD64 dw64Address)
{
    WCHAR wszDisp [64];
    StringCchPrintf (wszDisp, sizeof (wszDisp) / sizeof (wszDisp[0]), L"0x%I64x", dw64Address);
    StringCchCat (wsz, nChars, wszDisp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\cache.h ===
//  Copyright (C) 1995-2002 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
 Microsoft COM+ (Microsoft Confidential)

 @doc
 @module cache.H : Implements a time-out cache for callframe-related objects
 
-------------------------------------------------------------------------------
Revision History:

 @rev 0     | 09/14/2000 | mfeingol  | Created
---------------------------------------------------------------------------- */

#ifndef _CALLFRAME_CACHE_H_
#define _CALLFRAME_CACHE_H_

// Arbitrary value used as "never" marker.  One object in 2^32-1 will
// not be aged out properly before an extra addref / release cycle
// on systems that stay up longer than 49 days.
// I think we can live with this.
#define TYPEINFO_RELEASE_TIME_NEVER	(0xffffffff)

// How often we try to age out old cache entries
#define TYPEINFO_AGEOUT_FREQUENCY	(60 * 1000)

// How old an unused entry has to be to be considered "old"
#define TYPEINFO_AGEOUT_PERIOD		(60 * 1000)

//
// NOTE: The constructor here can throw an exception because it contains a
//       MAP_SHARED, which contains an XSLOCK, and... well... see concurrent.h
//
template <class T> class CALLFRAME_CACHE : public MAP_SHARED <MAP_KEY_GUID, T*>
{

protected:

    XSLOCK m_xslAgeOutLock;
    DWORD m_dwLastAgeOutTime;
    DWORD m_dwNumPtrsInPage;

public:

    CALLFRAME_CACHE()
	{
		SYSTEM_INFO siInfo;
		GetSystemInfo (&siInfo);

		// Initialize to the number of pointers a page can contain
		m_dwNumPtrsInPage = siInfo.dwPageSize / sizeof (void*);
		m_dwLastAgeOutTime = GetTickCount();
	}

    // you must successfully call FInit to use this class.
    // return TRUE on success, FALSE on failure.
    virtual BOOL FInit()
    {
        if (MAP_SHARED<MAP_KEY_GUID, T*>::FInit() == FALSE)
        {
            return FALSE;
        }
        else
        {
            return m_xslAgeOutLock.FInit();
        }
    }
    	

    void Shutdown()
    {

        iterator iCurrent, iLast;
        T* ptCacheEntry;

        // First, take an exclusive lock.
        // If this function is called, then everyone else should have shut down, but let's be safe
        LockExclusive();

        iCurrent = First();
        iLast = End();

        while (iCurrent != iLast)
        {
            ptCacheEntry = iCurrent.GetValue();

            if (ptCacheEntry->GetReleaseTime() == TYPEINFO_RELEASE_TIME_NEVER)
            {
                // This entry is actually alive. Someone probably leaked a reference on it
                T::NotifyLeaked (ptCacheEntry);
            }
            else
            {
                // Clean up the cached object
                // This removes it from the hash table
                ASSERT (ptCacheEntry->m_refs == 0);
                ptCacheEntry->DeleteSelf();
            }   

            iCurrent ++;
        }
        
        ReleaseLock();
    }

    void AgeOutEntries()
    {
        // Static used to control how many entries we can age out
        static ULONG s_ulEntries = 50;
    	
        T* ptCacheEntry;
        T** pptTimedOut;
    	
        DWORD dwCurrentTime, dwLastAgeOut, dwNextAgeOut;
        ULONG i, ulNumAgedOut, ulNumEntries;
        iterator iCurrent, iLast;

        dwCurrentTime = GetTickCount();
        dwLastAgeOut = m_dwLastAgeOutTime;
        dwNextAgeOut = dwLastAgeOut + TYPEINFO_AGEOUT_FREQUENCY;

        if (dwCurrentTime < dwNextAgeOut ||
            InterlockedCompareExchange (&m_dwLastAgeOutTime, dwCurrentTime, dwLastAgeOut) != dwLastAgeOut)
        {
            // Time isn't up yet, or someone else got here first
            return;
        }

        ulNumAgedOut = 0;

        // Synchronize access to this code- even though we'll get here once a minute at most,
        // you never know what might happen under stress
        m_xslAgeOutLock.LockExclusive();

        // Get the read lock
        LockShared();

        ulNumEntries = Size();

        // Short circuit if no entries
        if (ulNumEntries == 0)
        {
            ReleaseLock();
            m_xslAgeOutLock.ReleaseLock();
            return;
        }		

    	// Don't alloca more than the static number of entries
        if (ulNumEntries > s_ulEntries)
        {
            ulNumEntries = s_ulEntries;
        }

        // Allocate memory on the stack to contain the max number of entries we expect to release
        pptTimedOut = (T**) _alloca (ulNumEntries * sizeof (T*));

        iCurrent = First();
        iLast = End();

        while (iCurrent != iLast && ulNumAgedOut < ulNumEntries)
        {
            ptCacheEntry = iCurrent.GetValue();

            if (ptCacheEntry->CanBeAgedOut (dwCurrentTime))
            {
                pptTimedOut[ulNumAgedOut ++] = ptCacheEntry;
                ptCacheEntry->AddRef();	// Stabilizing addref
            }

            iCurrent ++;
        }

        ReleaseLock();

        // Increase the static limit for next time if we need more space for age-outs,
        // but make sure we never use more than a page of stack
        if (ulNumAgedOut == ulNumEntries && s_ulEntries < m_dwNumPtrsInPage)
        {
            s_ulEntries += 10;
        }

        if (ulNumAgedOut > 0)
        {
            // Get the write lock and age 'em out!
            LockExclusive();

            for (i = 0; i < ulNumAgedOut; i ++)
            {
                if (!pptTimedOut[i]->AttemptAgeOut (dwCurrentTime))
                {
                    // The object wasn't deleted, so decrease its refcount
                    // to balance the stabilizing addref performed above
                    pptTimedOut[i]->Release (FALSE);
                }
            }

            // else the object was destructed and we're done, so no need to balance the addref

            ReleaseLock();
        }

        m_xslAgeOutLock.ReleaseLock();
    }
    
    HRESULT FindExisting(REFIID iid, T** ppT)
    {
        HRESULT hr = S_OK;
        *ppT = NULL;
        
        LockShared();

        if (Lookup(iid, ppT))
        {
            (*ppT)->AddRef(); // give caller his own reference
            (*ppT)->SetCantBeAgedOut();
        }
        else
        {
            hr = E_NOINTERFACE;
        }

        ReleaseLock();

        return hr;
    }
};

template <class T> class CALLFRAME_CACHE_ENTRY
{

protected:

    DWORD m_dwReleaseTime;

    CALLFRAME_CACHE<T>* m_pcache;

public:

    LONG m_refs;
    GUID m_guidkey;

    CALLFRAME_CACHE_ENTRY()
    {
        m_refs = 1; // Refcount starts at 1!
        m_dwReleaseTime = TYPEINFO_RELEASE_TIME_NEVER;
        m_pcache = NULL;

        m_guidkey = GUID_NULL;
    }

    ULONG AddRef()
    {
        InterlockedIncrement(&m_refs); return m_refs;
    }

    ULONG Release (BOOL bAgeOutOldEntries = TRUE)
    {
        // Careful: if we're in the cache then we could be dug out 
        // from the cache to get more references.

        // NOTE:
        //
        // This code is WRONG if m_pcache can change out from underneath us. But it can't
        // in current usage because the cache/no-cache decision is always made as part of
        // the creation logic, which is before another independent thread can get a handle
        // on us.
        //
        // If this ceases to be true, then we can deal with it by stealing a bit from the ref count word 
        // for the 'am in cache' decistion and interlocked operations to update the ref count and this 
        // bit together.
        //

        // Global used to reduce traffic on the age-out code
    	static ULONG s_ulTimes = 0;

        if (m_pcache)
        {
            // We're in a cache. Get us out of there carefully.
            //
            LONG crefs;
            //
            for (;;)
            {
                crefs = m_refs;
                //
                if (crefs > 1)
                {
                    // There is at least one non-cache reference out there. We definitely won't
                    // be poofing if we release with that condition holding
                    //
                    if (crefs == InterlockedCompareExchange(&m_refs, (crefs - 1), crefs))
                    {
    				    return crefs - 1;
                    }
                    else
                    {
                        // Someone diddled with the ref count while we weren't looking. Go around and try again
                    }
                }
                else
                {
                    CALLFRAME_CACHE<T>* pcache = m_pcache;  ASSERT(pcache);

                    // We need the exclusive lock because otherwise we'll race with TYPEINFO_CACHE::FindExisting
                    pcache->LockExclusive();
                    //
                    crefs = InterlockedDecrement(&m_refs);
                    if (0 == crefs)
                    {
                        // The last public reference just went away, and, because the cache is locked, no
                        // more can appear. Make the entry ready to be aged out.
                        //
                        ASSERT(m_guidkey != GUID_NULL);
                        ASSERT(pcache->IncludesKey(m_guidkey));
                        //
                        m_dwReleaseTime = GetTickCount();
                    }
                    //
                    pcache->ReleaseLock();

                    // Every five times we arrive here, see if we can age anything out
                   	if (bAgeOutOldEntries && InterlockedIncrement (&s_ulTimes) % 5 == 0)
                    {
                   		pcache->AgeOutEntries();
                   	}
                    
                    //
                    return crefs;
                }
            }
        }
        else
        {
            // We are getting released, yet we have yet to ever be put into the cache. Just
            // the normal, simple case. 
            //
            long crefs = InterlockedDecrement(&m_refs); 
            if (crefs == 0)
            {
                delete this;
            }
            return crefs;
        }
    }

    void SetCantBeAgedOut()
    {
        m_dwReleaseTime = TYPEINFO_RELEASE_TIME_NEVER;
    }
    
    BOOL CanBeAgedOut (DWORD dwCurrentTime)
 	{
        DWORD dwDiff;

    	// If it's never, just say no
        if (m_dwReleaseTime == TYPEINFO_RELEASE_TIME_NEVER)
        {
    	    return FALSE;
        }

        // Handle overflows to the extent that we're able
        if (m_dwReleaseTime > dwCurrentTime)
        {
            // Tick count overflowed!
        	dwDiff = dwCurrentTime + (0xffffffff - m_dwReleaseTime);
        }
        else
        {
            // Normal difference
         	dwDiff = dwCurrentTime - m_dwReleaseTime;
        }

        // Test against hard-coded age out period
        return dwDiff > TYPEINFO_AGEOUT_PERIOD;
   	}

    BOOL AttemptAgeOut (DWORD dwCurrentTime)
    {
        // Make sure we're still ready to be aged out - should have one ref right now
        if (!CanBeAgedOut (dwCurrentTime))
    	{
    	    return FALSE;
    	}

        ASSERT (m_refs == 1);
        DeleteSelf();

        return TRUE;
    }
    
    void DeleteSelf()
    {       
        ASSERT (m_guidkey != GUID_NULL);
        ASSERT (m_pcache->IncludesKey (m_guidkey));

        m_pcache->RemoveKey (m_guidkey);
        delete this;
    }
    
    DWORD GetReleaseTime()
    {
        return m_dwReleaseTime;
    }

    HRESULT AddToCache (CALLFRAME_CACHE<T>* pcache)
    {
        // Add us into the indicated cache. We'd better not already be in one
        HRESULT hr = S_OK;

        ASSERT (pcache);
        ASSERT (NULL == m_pcache);

        ASSERT (m_guidkey != GUID_NULL);

        pcache->LockExclusive();

        // Make sure nobody beat us first
        if (pcache->IncludesKey (m_guidkey))
        {
            hr = S_FALSE;
        }
        else
        {
            if (pcache->SetAt (m_guidkey, (T*) this))
            {
                m_pcache = pcache;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        
        pcache->ReleaseLock();
        return hr;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\callframeinline.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrameInline.h
//

inline CallFrame::~CallFrame()
{
    if (m_pInterceptor) 
        m_pInterceptor->Release();

    if (m_fIsCopy)
    {
        Free(m_pvArgs);
    }

    if (m_fWeOwnBlobBuffer)
    {
        CoTaskMemFree(m_blobBuffer.pBlobData);
    }
}

#ifdef _IA64_

extern "C"
void __stdcall SpillFPRegsForIA64( REGISTER_TYPE* pStack, 
								   ULONG          FloatMask);
#endif

inline void CallFrame::Init(void* pvArgs, MD_METHOD* pmdMethod, Interceptor* pInterceptor)
{
    SetStackLocation_(pvArgs);
    m_pmd           = pmdMethod;
    m_fCanUseBuffer = TRUE;
    m_pInterceptor  = pInterceptor;
    m_pInterceptor->AddRef();

#ifdef _IA64_
	if (m_pmd->m_pHeaderExts && pvArgs)
	{
		// ASSUMPTION: If we're on Win64, this is going to be NDR_PROC_HEADER_EXTS64.
		// That seems to be what the NDR code assumes.
		PNDR_PROC_HEADER_EXTS64 exts = (PNDR_PROC_HEADER_EXTS64)m_pmd->m_pHeaderExts;
		if (exts->FloatArgMask)
		{
			// IMPORTANT:  YOU MUST NOT USE THE FLOATING POINT ARGUMENT 
			//             REGISTERS IN BETWEEN THE FIRST INTERCEPTION 
			//             AND THIS FUNCTION CALL.
			SpillFPRegsForIA64((REGISTER_TYPE *)m_pvArgs, exts->FloatArgMask);
		}
	}
#endif
}


//////////////////////////////////////////////////////////////////////////////////

__inline void CopyBaseTypeOnStack(void* pvArgTo, void* pvArgFrom, BYTE chFromat)
{
    // All base types simply occupy a single REGISTER_TYPE slot on the stack.
    // Also, caller is responsible for probing stack before we get here.
    //
    memcpy(pvArgTo, pvArgFrom, sizeof(REGISTER_TYPE));
}


inline BOOL CallFrame::FIndirect(BYTE bPointerAttributes, PFORMAT_STRING pFormatPointee, BOOL fFromCopy) const
{
    if (POINTER_DEREF(bPointerAttributes))
    {
        // We don't indirect on interface pointers, since we need their address
        // during Walk and Free calls.
        //
        if (!fFromCopy && *pFormatPointee == FC_IP)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    return FALSE;
}

inline BOOL CallFrame::ByValue(const PARAM_ATTRIBUTES& paramAttr, PFORMAT_STRING pFormatParam, BOOL fFromCopy) const
// Check to see whether we should consider the given parameter as 'by value'. We differ
// from NDR in that for interface pointers, pMemory in the worker routines is the pointer to the 
// location at which the interface pointer is stored rather than the interface pointer itself.
//
// In the NDR world, 'by-value' here means, specifically, a by-value struct.
//
// See also FIndirect().
//
{
    if (paramAttr.IsByValue)
    {
        // It's by-value because MIDL told us so
        //
        return TRUE;
    }
    else if (!fFromCopy && *pFormatParam == FC_IP)
    {
        // It's an interface pointer. For copy operations we don't consider these by value, but
        // otherwise we do.
        //
        return TRUE;
    }
    else
        return FALSE;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Memory management functions
//

inline void* CallFrame::AllocBuffer(size_t cb) // Must call w/ an exception handling frame around 
// Allocate from our private buffer if we can, otherwise use the task allocator
{ 
    BYTE* pb    = (BYTE*)m_pvMem;
    BYTE* pbCur = (BYTE*)m_pvMemCur;
    //
    // Round cb up to eight bytes in length to assure that our returned pv is always at least eight byte aligned
    //
    cb = RoundToNextMultiple((ULONG)cb, 8UL);

    if (pbCur+cb <= pb+CB_PRIVATE_BUFFER)
    {
        void* pvReturn = m_pvMemCur;
        pvReturn = (void*)((ULONG_PTR)((ULONG_PTR)pvReturn + 7) & ~7);
        m_pvMemCur = pbCur+cb;
        ASSERT(WeOwn(pvReturn));
        return pvReturn;
    }
    else
    {
        void* pvReturn = Alloc(cb);
        pvReturn = (void*)((ULONG_PTR)((ULONG_PTR)pvReturn + 7) & ~7);
        ASSERT(!WeOwn(pvReturn));
        return pvReturn;
    }
}

///////////////////////////
//
// Alloc: allocate some actual memory. Must call w/ an exception handling frame around 
//
// Allocate from the task allocator. Throw on out of memory
inline void* CallFrame::Alloc(size_t cb)
{
    void* pv;
    pv = CoTaskMemAlloc(cb);

    if (NULL == pv) ThrowOutOfMemory();
    return pv;
}

///////////////////////////

inline void CallFrame::Free(void* pv)
{
    if (NULL == pv || WeOwn(pv))
    {
        // Do nothing
    }
    else
    {
        CoTaskMemFree(pv);
    }
}

inline BOOL CallFrame::WeOwn(void* pv) 
// Answer as to whether the pointer here is one of our internal ones and thus 
// should not be freed by the system.
{ 
    if (m_pvMem)
    {
        if (m_pvMem <= pv   &&   pv < &((BYTE*)m_pvMem)[CB_PRIVATE_BUFFER])
        {
            return TRUE;
        }
    }
    if (m_blobBuffer.pBlobData)
    {
        if (m_blobBuffer.pBlobData <= pv   &&   pv < &m_blobBuffer.pBlobData[m_blobBuffer.cbSize])
        {
            return TRUE;
        }
    }

    return FALSE;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void CallFrame::OutInit(CallFrame* pFrameTo, BYTE** ppArgFrom, BYTE** ppArgTo, PFORMAT_STRING pFormat)
// See also NdrOutInit in the NDR runtime. Here we are a bit different, in that
// ppArgFrom is source data which is guaranteed to be valid, but ppArgTo is destination
// data which may not yet be valid in terms of, e.g., conformance routines
//
{
    LONG cb;
    PBYTE pArgFrom;
    //
    // Check for a non-interface pointer
    //
    if (IS_BASIC_POINTER(pFormat[0]))
    {
        if (SIMPLE_POINTER(pFormat[1]))
        {
            // A pointer to a base type
            //
            cb = SIMPLE_TYPE_MEMSIZE(pFormat[2]);
            goto DoAlloc;
        }
        if (POINTER_DEREF(pFormat[1]))
        {
            // A pointer to a pointer
            //
            cb = sizeof(void*);
            goto DoAlloc;
        }
        //
        // A pointer to a complex type
        //
        pFormat += 2;
        pFormat += *(signed short *)pFormat;
    }
    
    ASSERT(pFormat[0] != FC_BIND_CONTEXT);
    //
    // Make a call to size a complex type
    // 
    pArgFrom = *ppArgFrom;
    cb = (LONG) (MemoryIncrement(pArgFrom, pFormat, TRUE) - pArgFrom);

 DoAlloc:

    if (cb > 0)
    {
        *ppArgTo = (BYTE*)pFrameTo->Alloc(cb);
        ZeroMemory(*ppArgTo, cb);
        //
        // We are almost done, except for an out ref to ref to ... etc.
        // If this is the case then keep allocating pointees of ref pointers.
        //
        if (pFormat[0] == FC_RP && POINTER_DEREF(pFormat[1]))
        {
            pFormat += 2;
            pFormat += *(signed short *)pFormat;
            if (pFormat[0] == FC_RP)
            {
                OutInit( pFrameTo, ppArgFrom, (BYTE**)*ppArgTo, pFormat);
            }
        }
    }
    else
        Throw(STATUS_INFO_LENGTH_MISMATCH);
}


static const IID __IID_ICallFrameWalker_ = 
{0x08B23919, 0x392D, 0x11d2, {0xB8,0xA4,0x00,0xC0,0x4F,0xB9,0x61,0x8A}};

struct SSimpleWalker : public ICallFrameWalker
{
	STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
	{
		if ( riid == IID_IUnknown || riid == __IID_ICallFrameWalker_ )
		{
			*ppv = (ICallFrameWalker*) this;
	    }
	    else
	    {
	    	*ppv = NULL;
	    	return E_NOINTERFACE;
	    }
	    return S_OK;
	}

	STDMETHOD_(ULONG, AddRef)() { return 1; }
	STDMETHOD_(ULONG, Release)() { return 1; }
    

	STDMETHOD(OnWalkInterface)( REFIID iid,                     
                                PVOID* ppvInterface,  
                                BOOL   fIn,                       
                                BOOL   fOut )
	{
		//If the interface is NULL, there's nothing for us to do.
        if (*ppvInterface == NULL)
        {
            return S_OK;
        }
        if (_cItfs < 10)
        {
            // Less than 10 interface pointers.  We can Copy the interface pointer 
            // into our primary array.
            
            _arpUnk[_cItfs++] = ((IUnknown *)*ppvInterface);
        }
        else
        {
            // More than 10 interface pointers.  We have to use our overflow array.            
            if ( _cItfs % 10 == 0 )
            {
                // Allocate another block of memory.               
                if ( NULL == _ppUnk )
                {
                    // Allocate first overflow array.
                    _ppUnk = (IUnknown**)CoTaskMemAlloc( sizeof( IUnknown* ) * 10 );
                }
                else
                {
                    // We've run out of room in the overflow array.  We need to grow the
                    // backup array by 10.
                    //
                    // Allocate another set of 10 interface pointers.
                    IUnknown** ppTemp = (IUnknown**)CoTaskMemAlloc( sizeof( IUnknown* ) * _cItfs );

                    if (ppTemp != NULL)
					{
						// Copy existing array into new array.
						for ( ULONG i = 0; i < _cItfs - 10; i++ )
							ppTemp[i] = _ppUnk[i];
                        
						// Delete the old array.
						CoTaskMemFree( _ppUnk );
                        
						// Set the new array.
						_ppUnk = ppTemp;
					}
					else
						return E_OUTOFMEMORY;
                }
            }
                
            // If could not alloc a backup array, fail.  Interface ptr will leak.
            if ( NULL == _ppUnk )
                return E_OUTOFMEMORY;
             
            // Copy the interface pointer into our overflow array.
            _ppUnk[_cItfs++ - 10] = ((IUnknown *)*ppvInterface);
        }
        
		return S_OK;
    }
	
	SSimpleWalker() : _cItfs( 0 ), _ppUnk( NULL ) {}
    
    void ReleaseInterfaces()
    {
        // Release everything in the primary array.
        for( ULONG i = 0; i < 10 && i < _cItfs; i++ )
            _arpUnk[i]->Release();
            
        // If we had to create a backup array, Release everything in it
        // and then free the array.
        if ( NULL != _ppUnk )
        {
            for( i = 0; i < _cItfs - 10; i++ )
                _ppUnk[i]->Release();
            
            CoTaskMemFree( _ppUnk );
            _ppUnk = NULL;
        }
    }
    
    ULONG      _cItfs;
    IUnknown*  _arpUnk[10];
    IUnknown** _ppUnk;
};


inline void CallFrame::OutCopy(BYTE* pMemFrom, BYTE* pMemTo, PFORMAT_STRING pFormat)
// Copy an [in,out] or [out] parameter which is not a base type. Modelled after NdrClearOutParameters.
{
    // Don't blow up on NULL pointers
    //
    if (!pMemFrom || !pMemTo)
        return;

    ULONG cb;
    //
    // Look for a non-interface pointer
    //
    if (IS_BASIC_POINTER(pFormat[0]))
    {
        if (SIMPLE_POINTER(pFormat[1]))
        {
            // Pointer to a base type
            cb = SIMPLE_TYPE_MEMSIZE(pFormat[2]);
            goto DoCopy;
        }

        if (POINTER_DEREF(pFormat[1]))
        {
            // Pointer to a pointer
            cb = sizeof(PVOID);
            goto DoCopy;
        }

        pFormat += 2;
        pFormat += *(signed short *)pFormat;

        ASSERT(pFormat[0] != FC_BIND_CONTEXT);
    }

    cb = (ULONG) (MemoryIncrement(pMemFrom, pFormat, TRUE) - pMemFrom);

 DoCopy:
    
    CopyMemory(pMemTo, pMemFrom, cb);

	// Walk the parameter.
    // Note: We are walking here to collect [out] interface pointers
    //       in the parameter so we can release them.
    WalkWorker( pMemFrom, pFormat );
    
	// Zero the memory.
    ZeroMemory(pMemFrom, cb);
}


inline void CallFrame::OutZero(BYTE* pMem, PFORMAT_STRING pFormat, BOOL fDst)
// Zero an out parameter
{
    // Don't blow up on NULL pointers
    //
    if (!pMem)
        return;

    ULONG cb;
    //
    // Look for a non-interface pointer
    //
    if (IS_BASIC_POINTER(pFormat[0]))
    {
        if (SIMPLE_POINTER(pFormat[1]))
        {
            // Pointer to a base type
            cb = SIMPLE_TYPE_MEMSIZE(pFormat[2]);
            goto DoZero;
        }

        if (POINTER_DEREF(pFormat[1]))
        {
            // Pointer to a pointer
            cb = sizeof(PVOID);
            goto DoZero;
        }

        pFormat += 2;
        pFormat += *(signed short *)pFormat;

        ASSERT(pFormat[0] != FC_BIND_CONTEXT);
    }

    cb = (ULONG) (MemoryIncrement(pMem, pFormat, FALSE) - pMem);

 DoZero:

    ZeroMemory(pMem, cb);
}


////////////////////////////////////////////////////////
//
// Helper walker.  This walker is used to NULL interface
// pointers on the stack.  It can also be handed another
// walker, to which it will delegate before nulling the
// pointer.  The delegate can actually call release.
//
// This object is allocated on the stack.
//
////////////////////////////////////////////////////////

struct InterfaceWalkerFree : ICallFrameWalker
{
    ICallFrameWalker* m_pWalker;

    InterfaceWalkerFree(ICallFrameWalker* p) 
    { 
        m_pWalker = p; 
        if (m_pWalker) m_pWalker->AddRef();
    }
    ~InterfaceWalkerFree()
    {
        ::Release(m_pWalker);
    }

    HRESULT STDCALL OnWalkInterface(REFIID iid, PVOID *ppvInterface, BOOL fIn, BOOL fOut)
    {
        if (m_pWalker)
        {
            m_pWalker->OnWalkInterface(iid, ppvInterface, fIn, fOut);
        }

        //
        // Null the interface pointer.
        //
        *ppvInterface = NULL;

        return S_OK;
    }
    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv)
    {
        if (iid == IID_IUnknown || iid == __uuidof(ICallFrameWalker)) *ppv = (ICallFrameWalker*)this;
        else {*ppv = NULL; return E_NOINTERFACE; }
        ((IUnknown*)*ppv)->AddRef(); return S_OK;
    }
    ULONG   STDCALL AddRef()    { return 1; }
    ULONG   STDCALL Release()   { return 1; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\callframe.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrame.h
//
#include "CallFrameImpl.h"

//////////////////////////////////////////////////////////////////////////////////////////////////

class CallFrame : 
  public ICallFrame, 
  public ICallFrameInit,
  public DedicatedAllocator<CallFrame>
{
  public:
    ///////////////////////////////////////////////////////////////////
    //
    // State of valid interest outside of any worker routine
    //
    ///////////////////////////////////////////////////////////////////

    BYTE* PMemberFirst() { return (BYTE*)&m_pmd; }

    // Our meta data reference
    MD_METHOD*                  m_pmd;

    // Pointer to the stack frame containing the argument data
    PVOID                       m_pvArgs;
    BOOL                        m_fIsCopy;      // Are we a copy? (that is, generated by a copy or unmarshal?)
    BOOL                        m_fIsUnmarshal; // Are we an unmarshalled call frame?


    // The return value of an invocation on us. Is REGISTER_TYPE in order that it can
    // be directly marshalled.
    REGISTER_TYPE               m_hrReturnValue;

    // Current location in the one-off block of memory we use for private buffer management
    PVOID                       m_pvMemCur;

    // If we share memory with someone, then this is the stack of the guy with whom we do
    PVOID                       m_pvArgsSrc;

    // Do our in-parameters share state with our parent frame
    BOOL                        DoWeShareMemory()   { return m_pvArgsSrc != NULL; }

#ifdef DBG
    // If true, then we definitely have made a call on this frame
    BOOL                        m_fAfterCall;
#endif

    // Our interceptor. We need to keep it alive as long as we are alive. 
    //
    Interceptor*                m_pInterceptor;

    ///////////////////////////////////////////////////////////////////
    //
    // State used to communicate with various worker routines as we
    // copy, free, etc.
    //
    ///////////////////////////////////////////////////////////////////

    BOOL                        m_fPropogatingOutParam;
    BOOL                        m_fWorkingOnInParam;
    BOOL                        m_fWorkingOnOutParam;

    // The frame that should allocate memory as we need it
    CallFrame*                  m_pAllocatorFrame;

    // Used during a Copy etc call as the guy who should get our callbacks
    ICallFrameWalker*           m_pWalkerCopy;
    ICallFrameWalker*           m_pWalkerFree;
    ICallFrameWalker*           m_pWalkerWalk;


    ///////////////////////////////////////////////////////////////////
    //
    // State used to mirror NDR runtime pStubMsg state
    //
    ///////////////////////////////////////////////////////////////////

    BYTE*                       m_StackTop;             // base pointer used for FC_TOP_LEVEL_CONFORMANCE conformance computations
    BYTE*                       m_Memory;               // base pointer used for FC_POINTER_CONFORMANCE   conformance computations

    SIZE_T                      m_MaxCount;             // Holds the max counts for a conformant array
    SIZE_T                      m_Offset;               // Holds the offsets for a varying array
    SIZE_T                      m_ActualCount;          // Holds the actual counts for a varying array
    PARRAY_INFO                 m_pArrayInfo;

    // Set limit pointer as to what we zero out during construction
    // 
    BYTE* PMemberMax() { return (BYTE*)&m_pArrayInfo + sizeof(m_pArrayInfo); }


    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    friend GenericInstantiator<CallFrame>;

    CallFrame()
    {
        m_refs              = 1;    // nb starts at one

        ZeroMemory(PMemberFirst(), PMemberMax() - PMemberFirst());

        Zero(&m_blobBuffer);
        m_fWeOwnBlobBuffer = FALSE;

        m_pvMemCur = &m_pvMem[0];
        m_fIsCopy = FALSE;

#ifdef DBG
        memset(&m_pvMem[0], 0xBB, CB_PRIVATE_BUFFER);   // init to something we'll recognize in the debugger
#endif
    }

    ~CallFrame();

    HRESULT Init() const
    {
        return S_OK;
    }

#define SetStackLocation_(pvArgs) { m_pvArgs = pvArgs; }

    void Init(void* pvArgs, MD_METHOD* pmdMethod, Interceptor* pInterceptor);

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetInfo(CALLFRAMEINFO *pInfo);

    HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*);

    HRESULT STDCALL GetNames(LPWSTR* pwszInterface, LPWSTR* pwszMethod);

    PVOID STDCALL GetStackLocation()
    {
        return m_pvArgs;
    }

    void STDCALL SetStackLocation(PVOID pvArgs)
    {
        SetStackLocation_(pvArgs);
    }

    HRESULT STDCALL GetMarshalSizeMax(
        CALLFRAME_MARSHALCONTEXT *pmshlContext, 
        MSHLFLAGS mshlflags, 
        ULONG *pcbBufferNeeded);

    HRESULT STDCALL Marshal( 
        CALLFRAME_MARSHALCONTEXT  *pmshlContext,
        MSHLFLAGS	mshlflags,	/* As in the IMarshal interface */
        PVOID pBuffer,
        ULONG cbBuffer,
        ULONG  *pcbBufferUsed,
        RPCOLEDATAREP* pdataRep,
        ULONG *prpcFlags);

    void MarshalParam(
        MIDL_STUB_MESSAGE& stubMsg, 
        ULONG iParam, 
        const PARAM_DESCRIPTION& param, 
        const PARAM_ATTRIBUTES paramAttr, 
        PBYTE pArg);

    HRESULT STDCALL Unmarshal(
        PVOID pBuffer, 
        ULONG cbBuffer,
        RPCOLEDATAREP dataRep, 
        CALLFRAME_MARSHALCONTEXT*, 
        ULONG* pcbUnmarhalled);

    HRESULT STDCALL ReleaseMarshalData(
        PVOID pBuffer, 
        ULONG cbBuffer, 
        ULONG ibFirstRelease, 
        RPCOLEDATAREP dataRep, 
        CALLFRAME_MARSHALCONTEXT* pctx);
    
    void UnmarshalParam(
        MIDL_STUB_MESSAGE& stubMsg, 
        const PARAM_DESCRIPTION& param, 
        const PARAM_ATTRIBUTES paramAttr, 
        PBYTE pArg);
    
    HRESULT STDCALL Free( 
        ICallFrame*        pframeArgsDest,
        ICallFrameWalker*  pWalkerFreeDest,
        ICallFrameWalker*  pWalkerCopy,
        DWORD              freeFlags,
        ICallFrameWalker*  pWalkerFree,
        DWORD              nullFlags);

    HRESULT STDCALL FreeParam(
        ULONG              iparam,
        DWORD              freeFlags,
        ICallFrameWalker*  pWalkerFree,
        DWORD              nullFlags);
    
    void STDCALL SetReturnValue(HRESULT hrReturnValue)
    {
        m_hrReturnValue = hrReturnValue;
    }
    HRESULT STDCALL GetReturnValue()
    {
        return (HRESULT)m_hrReturnValue;
    }
    HRESULT GetReturnValueFast()
    {
        return (HRESULT)m_hrReturnValue;
    }

    HRESULT STDCALL Invoke(void *pvReceiver, ...);

    HRESULT STDCALL Copy(
        CALLFRAME_COPY callControl,
        ICallFrameWalker* pWalker,
        ICallFrame** ppFrame
    );

    HRESULT STDCALL WalkFrame(DWORD walkWhat, ICallFrameWalker *pWalker);

    HRESULT STDCALL GetParamInfo(IN ULONG iparam, OUT CALLFRAMEPARAMINFO*);
    HRESULT STDCALL GetParam(ULONG iparam, VARIANT* pvar);
    HRESULT STDCALL SetParam(ULONG iparam, VARIANT* pvar);


    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrameInit
    //
    ///////////////////////////////////////////////////////////////////

    CallFrame* STDCALL GetCallFrame()
    {
        return this;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    LONG        m_refs;

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL AddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL Release()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs; }

    ///////////////////////////////////////////////////////////////////
    //
    // Memory management
    //
    ///////////////////////////////////////////////////////////////////

    enum { CB_PRIVATE_BUFFER = 256 };
    //
    // We maintain inside ourselves a chunk of memory that we use in order to do very quickly
    // get memory needed in copied frames. If we run out of this memory, we start getting memory
    // from the task allocator. We also use this memory for the child stack itself, so the size
    // of this buffer effectively puts a limit on the size of a stack frame we can deal with.
    //
    BYTE  m_pvMem[CB_PRIVATE_BUFFER];
    BOOL  m_fCanUseBuffer;
    //
    // Also, during an unmarshal call, we are given a buffer into which some of the umarshalled
    // data might eventually point. We are not to free such pointers, of course. Further we might
    // actually own the buffer, and so be responsible for freeing it when we go bye bye.
    //
    BLOB  m_blobBuffer;
    BOOL  m_fWeOwnBlobBuffer;


    void* AllocBuffer(size_t cb);
    void* Alloc(size_t cb);

    void* Alloc(size_t cb, BOOL fForceAlloc)
    {
        if (!m_fCanUseBuffer)
        {
            fForceAlloc = TRUE;
        }

        if (fForceAlloc)
        {
            return Alloc(cb);
        }
        else
        {
            return AllocBuffer(cb);
        }
    }


    HRESULT AllocStack(size_t cb, BOOL fForceUserMode = FALSE)
    {
        ASSERT(m_pvArgs == NULL);
        //
        // Automatically determine size if we can and if asked to
        //
        if (cb == 0)
        {
            cb = m_pmd->m_cbPushedByCaller;
        }
        ASSERT(cb > 0); // should always have at least a receiver

        if (m_fIsCopy)
            Free(m_pvArgs);

        // SetStackLocation assigns to m_pvArgs.
        SetStackLocation_(AllocBuffer(cb));

        if (NULL != m_pvArgs)
        {
            m_fIsCopy = TRUE;
            ZeroMemory(m_pvArgs, cb);

            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    void  Free(void* pv);
    BOOL  WeOwn(void* pv);

    ///////////////////////////////////////////////////////////////////
    //
    // Worker routines
    //
    ///////////////////////////////////////////////////////////////////

    void           CopyWorker                (BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    void           CopyConformantArrayPriv   (BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    void           CopyEmbeddedPointers      (BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    PFORMAT_STRING CopyEmbeddedRepeatPointers(BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);

    void           FreeWorker                (BYTE* pMemoryFrom, PFORMAT_STRING pFormat, BOOL fFreePointer);
    void           FreeEmbeddedPointers      (BYTE* pMemory,     PFORMAT_STRING pFormat);
    PFORMAT_STRING FreeEmbeddedRepeatPointers(BYTE* pMemory,     PFORMAT_STRING pFormat);

    void            WalkWorker                  (BYTE* pMemory, PFORMAT_STRING pFormat);
    void            WalkConformantArrayPriv     (BYTE* pMemory, PFORMAT_STRING pFormat);
    PFORMAT_STRING  WalkEmbeddedRepeatPointers  (BYTE* pMemory, PFORMAT_STRING pFormat);
    void            WalkEmbeddedPointers        (BYTE* pMemory, PFORMAT_STRING pFormat);

    void OutInit(CallFrame*, BYTE** ppArgFrom, BYTE** ppArgTo, PFORMAT_STRING pFormat);
    void OutCopy(            BYTE*  pMemFrom,  BYTE*  pMemTo,  PFORMAT_STRING pFormat);
    void OutZero(            BYTE*  pMem,                      PFORMAT_STRING pFormat, BOOL fDst = TRUE);

//Review API Change for WIN64
#ifndef _WIN64
    ULONG ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);
#else
    ULONGLONG ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);
#endif

    void  ComputeVariance   (BYTE* pMemory, PFORMAT_STRING pFormat, ULONG* pOffset, ULONG* pCount, BOOL fProbeSrc);
    BYTE* MemoryIncrement   (BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);

    BOOL ByValue(const PARAM_ATTRIBUTES& paramAttr, PFORMAT_STRING pFormatParam,   BOOL fFromCopy) const;
    BOOL FIndirect(BYTE bPointerAttributes,         PFORMAT_STRING pFormatPointee, BOOL fFromCopy) const;
    BOOL IsSafeArray(PFORMAT_STRING pFormat) const;

    // Get a new pointer that will probe correctly in the destination space. pbIn
    // should be a stack variable that we might use for scratch.
    PBYTE* GetAllocatedPointer(PBYTE& pbIn)
    {
        return &pbIn;
    }

    void FreeAllocatedPointer(PBYTE* ppb)
    {
#ifndef _WIN64
        DEBUG(*ppb = (PBYTE)0xfefefefe);
#else
        DEBUG(*ppb = (PBYTE)0xfefefefefefefefe);
#endif
    }

    BYTE* SetMemory(BYTE* pMemory)
    {
        BYTE* p = m_Memory;
        m_Memory = pMemory;
        return p;
    }
    
    CallFrame* GetFrame(CallFrame*& pFrame, PVOID pvArgs);

    OAUTIL GetHelper() const
    {
        return OAUTIL(m_pWalkerCopy, m_pWalkerFree, m_pWalkerWalk, m_fWorkingOnInParam, m_fWorkingOnOutParam);
    }

    OAUTIL GetWalker() const
    {
        return OAUTIL(m_pWalkerCopy, m_pWalkerFree, m_pWalkerWalk, m_fWorkingOnInParam, m_fWorkingOnOutParam);
    }

    BOOL AnyWalkers() const
    {
        return m_pWalkerCopy || m_pWalkerFree || m_pWalkerWalk;
    }

    BOOL CanShareParameter(ULONG iparam) const
    {
        return m_pmd->m_rgParams[iparam].m_fCanShare;
    }

    ULONG CbParam(ULONG iparam, const PARAM_DESCRIPTION& param) const
    {
        return (iparam == m_pmd->m_numberOfParams ? m_pmd->m_cbPushedByCaller : m_pmd->m_params[iparam+1].StackOffset) - param.StackOffset;
    }
    
    void GetStackSize(ULONG* pcbArgs) const
    {
        *pcbArgs = m_pmd->m_cbPushedByCaller;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Misc
    //
    ///////////////////////////////////////////////////////////////////

    PMIDL_STUB_DESC GetStubDesc() const
    {
        PMIDL_SERVER_INFO pServerInfo = (PMIDL_SERVER_INFO) m_pmd->m_pHeader->pServerInfo;
        return pServerInfo->pStubDesc;
    }

    //////////////////////////////////////////

    BSTR SysAllocStringSrc(LPCWSTR wszSrc)
    {
		return g_oaUtil.SysAllocString(wszSrc);
    }

	BSTR SysCopyBSTRSrc(BSTR bstrSrc)
    {
		UINT len = g_oaUtil.SysStringByteLen(bstrSrc);
		return g_oaUtil.SysAllocStringByteLen((LPCSTR)bstrSrc, len);
    }

    void SysFreeStringDst(BSTR bstrDst)
    {
        if (bstrDst)
        {
            BSTR_INTERNAL* pint = BSTR_INTERNAL::From(bstrDst);
            g_oaUtil.SysFreeString(bstrDst);
        }
    }

};

//////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\callframeworker.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrameWorker.cpp
//
#include "stdpch.h"
#include "common.h"
#include "ndrclassic.h"
#include "typeinfo.h"

#ifdef DBG

#define ThrowIfError(hr)    ThrowIfError_(hr, __FILE__, __LINE__)

void ThrowIfError_(HRESULT hr, LPCSTR szFile, ULONG iline)
{
    if (hr != S_OK) Throw(hr, szFile, iline);
}

#else

void ThrowIfError(HRESULT hr)
{
    if (hr != S_OK) Throw(hr);
}

#endif

//
// Alignment macros.
//
#define ALIGNED_VALUE(pStuff, cAlign)           ((uchar *)((ULONG_PTR)((pStuff) + (cAlign)) & ~ (cAlign)))


///////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

// See rpc's attack.h
#define NDR_CORR_EXTENSION_SIZE 2

#define CORRELATION_DESC_INCREMENT( pFormat )                                           \
  if ( m_pmd && m_pmd->m_pHeaderExts && m_pmd->m_pHeaderExts->Flags2.HasNewCorrDesc)    \
     pFormat += NDR_CORR_EXTENSION_SIZE;

#ifndef LOW_NIBBLE
#define LOW_NIBBLE(Byte)            (((unsigned char)Byte) & 0x0f)
#endif

#ifndef HIGH_NIBBLE
#define HIGH_NIBBLE(Byte)           (((unsigned char)Byte) >> 4)
#endif

void CallFrame::CopyWorker(BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc)
  // Copy from the indicated source location to the destination location, allocating
  // if requested. Source and destination pointers are to be considered not yet probed.
  // 
{
    switch (*pFormat)
    {
        /////////////////////////////////////////////////////////////////////
        //
        // Pointers
        //
        // In the future, we can be more clever here about sharing with our
        // source data than we are. For example, we could take advantage of the
        // ALLOCED_ON_STACK information that MIDL emits. For the moment, that 
        // would complicate things beyond their worth, however.
        //
        /////////////////////////////////////////////////////////////////////
    case FC_RP: // ref pointer
        if (NULL == pMemoryFrom)
        {
            Throw(RPC_NT_NULL_REF_POINTER);
        }
        //
        // Fall through
        //
    case FC_UP: // unique pointer
    case FC_OP: // a unique pointer, which is not the top most pointer, in a COM interface, 
    {
        if (NULL == pMemoryFrom)
        {
            ZeroMemory(ppMemoryTo, sizeof(void*));
            return;
        }
        //
        // Make the "must allocate" decision
        //
        BOOL fPointeeAlloc;
        if (m_fPropogatingOutParam)
        {
            ASSERT(m_fWorkingOnOutParam);
            PVOID pvPointee = *(PVOID*)ppMemoryTo;
            fPointeeAlloc = (pvPointee == NULL) || fMustAlloc;
        }
        else
        {
            fPointeeAlloc = TRUE;
        }
        //
        BYTE bPointerAttributes = pFormat[1];
        if (SIMPLE_POINTER(bPointerAttributes))
        {
            // It's a pointer to a simple type or a string pointer. Either way, just recurse to copy
            //
            CopyWorker(pMemoryFrom, ppMemoryTo, &pFormat[2], fPointeeAlloc);
        }
        else
        {
            // It's a more complex pointer type
            //
            PFORMAT_STRING pFormatPointee = pFormat + 2;
            pFormatPointee += *((signed short *)pFormatPointee);
            //
            // We don't handle [allocate] attributes in this implementation
            //
            //if (ALLOCATE_ALL_NODES(bPointerAttributes) || DONT_FREE(bPointerAttributes)) ThrowNYI();

            if (FIndirect(bPointerAttributes, pFormatPointee, TRUE))
            {
                if (fPointeeAlloc)
                {
                    PVOID pv = m_pAllocatorFrame->Alloc(sizeof(PVOID), m_fWorkingOnOutParam); // guarantees to return a safe buffer
                    ZeroMemory(pv, sizeof(PVOID));                                            // null out that buffer
                    *((PVOID*)ppMemoryTo) = pv;
                }
                ppMemoryTo  = *((PBYTE**)ppMemoryTo);
                pMemoryFrom = *((PBYTE*)pMemoryFrom);
            }
            CopyWorker(pMemoryFrom, ppMemoryTo, pFormatPointee, fPointeeAlloc);
        }
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Copying interface Pointers
    //
    /////////////////////////////////////////////////////////////////////
    case FC_IP:
    {
        // Copy the binary value of the interface pointer over. Do it carefully.
        //
        LPUNKNOWN   punkFrom = (LPUNKNOWN) pMemoryFrom;
        LPUNKNOWN* ppunkTo   = (LPUNKNOWN*)ppMemoryTo;
        //
        memcpy(ppunkTo, &punkFrom, sizeof(LPUNKNOWN));
        //
        // Figure out the IID and call the walker if there is one. If there's no
        // walker, then just AddRef the pointer.
        //
        if (m_pWalkerCopy)
        {
            IID UNALIGNED *pIID;

            if (pFormat[1] == FC_CONSTANT_IID)
            {
                pIID = (IID UNALIGNED *)&pFormat[2];
            }
            else
            {
                pIID = (IID UNALIGNED *)ComputeConformance(pMemoryFrom, pFormat, TRUE);
                if (NULL == pIID)
                    Throw(STATUS_INVALID_PARAMETER);
            }

            IID iid;
            CopyMemory(&iid, pIID, sizeof(IID));
            ThrowIfError(m_pWalkerCopy->OnWalkInterface(iid, (PVOID*)ppunkTo, m_fWorkingOnInParam, m_fWorkingOnOutParam));
        }
        else
        {
            // There is no walker. Just do an AddRef. But only do that if object
            // appears to be in same space as us: a sanity check, not a security
            // safeguard.
            //
            if (punkFrom)
            {
                punkFrom->AddRef();
            }
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Simple structs
    //
    /////////////////////////////////////////////////////////////////////
    case FC_STRUCT:
    case FC_PSTRUCT:
    {
        if (NULL == pMemoryFrom)
        {
            Throw(RPC_NT_NULL_REF_POINTER);
        }

        ULONG cbStruct = (ULONG) *((ushort *)(&pFormat[2]));
        //
        // If the destination is already pointing to something, then use that rather
        // than allocating. One case of this is that of by-value structures on the stack.
        //
        BYTE* pbStruct = *(ppMemoryTo);
        if (NULL == pbStruct || fMustAlloc)
        {
            pbStruct = (BYTE*) m_pAllocatorFrame->Alloc(cbStruct, m_fWorkingOnOutParam);
            *ppMemoryTo = pbStruct;
        }

        CopyMemory(pbStruct, pMemoryFrom, cbStruct);
        if (*pFormat == FC_PSTRUCT)
        {
            CopyEmbeddedPointers(pMemoryFrom, pbStruct, &pFormat[4], fMustAlloc);
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Conformant strings
    //
    /////////////////////////////////////////////////////////////////////
    case FC_C_CSTRING:  // ascii string
    case FC_C_WSTRING:  // unicode string
    {
        SIZE_T cbCopy = 0;
        SIZE_T cbAlloc = 0;

        if (pFormat[1] == FC_STRING_SIZED)
        {
            // A sized string. Not presently implemented, though that's just out of laziness.
            ThrowNYI();
        }
        else
        {
            // An unsized string; that is, a NULL-terminated string.
            //
            switch (*pFormat)
            {
            case FC_C_CSTRING:  cbCopy =  strlen((LPSTR)pMemoryFrom)  + 1;                  break;
            case FC_C_WSTRING:  cbCopy = (wcslen((LPWSTR)pMemoryFrom) + 1) * sizeof(WCHAR); break;
            default: ThrowNYI();    // Must be something we don't support yet
            }
            cbAlloc = cbCopy;
        }

        PVOID pvNew = m_pAllocatorFrame->Alloc(cbAlloc, m_fWorkingOnOutParam);
        *ppMemoryTo = (BYTE*)pvNew;
        CopyMemory(pvNew, pMemoryFrom, (ULONG)cbCopy);
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Simple Types
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CHAR:
    case FC_BYTE:
    case FC_SMALL:
    case FC_WCHAR:
    case FC_SHORT:
    case FC_LONG:
    case FC_HYPER:
    case FC_ENUM16:
    case FC_ENUM32:
    case FC_DOUBLE:
    case FC_FLOAT:
    case FC_INT3264:
    case FC_UINT3264:
    {
        ULONG cb = SIMPLE_TYPE_MEMSIZE(*pFormat);
        BYTE* pMemoryTo = *(ppMemoryTo);
        if (fMustAlloc || NULL == pMemoryTo)
        {
            pMemoryTo = (BYTE*)m_pAllocatorFrame->Alloc(cb, m_fWorkingOnOutParam);
            *ppMemoryTo = pMemoryTo;
        }
        CopyMemory(pMemoryTo, pMemoryFrom, cb);
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Fixed sized arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_SMFARRAY:   // small fixed array
    case FC_LGFARRAY:   // large fixed array
    {
        ULONG cbArray;
        if (*pFormat == FC_SMFARRAY)
        {
            pFormat += 2;               // skip code and alignment
            cbArray = *(ushort*)pFormat;
            pFormat += sizeof(ushort);
        }
        else // FC_LGFARRAY
        {
            pFormat += 2;
            cbArray = *(ulong UNALIGNED*)pFormat;
            pFormat += sizeof(ulong);
        }

        BYTE* pbArray = *(ppMemoryTo);
        if (!fMustAlloc && pbArray) 
        { /* nothing to do */ }
        else
        {
            pbArray = (BYTE*) m_pAllocatorFrame->Alloc(cbArray, m_fWorkingOnOutParam);
            *ppMemoryTo = pbArray;
        }

        CopyMemory(pbArray, pMemoryFrom, cbArray);

        if (*pFormat == FC_PP)
        {
            CopyEmbeddedPointers(pMemoryFrom, *(ppMemoryTo), pFormat, fMustAlloc);
        }

        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Copying Conformant arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CARRAY:
    {
        ULONG count = (ULONG)ComputeConformance(pMemoryFrom, pFormat, TRUE);
        ASSERT(count == m_MaxCount);

        SIZE_T cbAlloc = m_MaxCount *   *((ushort*)(pFormat+2));

        BYTE* pArray = *(ppMemoryTo);
        if (!fMustAlloc && pArray) 
        { /* nothing to allocate */ }
        else
        {
            if (cbAlloc > 0)
            {
                pArray = (BYTE*)m_pAllocatorFrame->Alloc(cbAlloc, m_fWorkingOnOutParam);
                if (pArray == NULL)
                    ThrowHRESULT(E_OUTOFMEMORY);
                ZeroMemory(pArray, cbAlloc);
            }
            else
                pArray = 0;                
        }

        *ppMemoryTo = pArray;
        
        if (pArray)
        {
            CopyConformantArrayPriv(pMemoryFrom, ppMemoryTo, pFormat, fMustAlloc);
        }
    
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Really hard arrays. These are arrays that do not fall into any of
    // the other more simple categories. See also NdrpComplexArrayMarshall
    // and NdrpComplexArrayUnmarshall.
    //
    /////////////////////////////////////////////////////////////////////
    case FC_BOGUS_ARRAY:
    {
        ARRAY_INFO*     pArrayInfoStart = m_pArrayInfo;
        PFORMAT_STRING  pFormatStart    = pFormat;

        __try
        {
            // Initialize m_pArrayInfo if necessary
            //
            ARRAY_INFO arrayInfo;
            if (NULL == m_pArrayInfo)
            {
                m_pArrayInfo = &arrayInfo;
                Zero(&arrayInfo);
            }
            const LONG dimension = m_pArrayInfo->Dimension;
            //
            // Get the array's alignment
            //
            const BYTE alignment = pFormat[1];
            pFormat += 2;
            //
            // Get the number of elements (0 if the array has conformance)
            //
            ULONG_PTR cElements = *(USHORT*)pFormat;
            pFormat += sizeof(USHORT);
            //
            // Check for conformance description
            //
            if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
            {
                cElements = ComputeConformance(pMemoryFrom, pFormatStart, TRUE);
            }
            
            pFormat += 4;
            CORRELATION_DESC_INCREMENT( pFormat );
            
            //
            // Check for variance description
            //
            ULONG offset;
            ULONG count;
            if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
            {
                ComputeVariance(pMemoryFrom, pFormatStart, &offset, &count, TRUE);
            }
            else
            {
                offset = 0;
                count  = (ULONG)cElements;
            }
            pFormat += 4;
            CORRELATION_DESC_INCREMENT( pFormat );
            
            /////////////////////////////////////////////////
            //
            // Compute the size of each element in the array
            //
            ULONG cbElement;
            //
            BYTE bFormat = pFormat[0];
            switch (bFormat)
            {
            case FC_EMBEDDED_COMPLEX:
            {
                pFormat += 2;
                pFormat += *((signed short *)pFormat);
                //
                m_pArrayInfo->Dimension = dimension + 1;
                cbElement = (ULONG)(MemoryIncrement(pMemoryFrom, pFormat, TRUE) - pMemoryFrom);
                break;
            }
            
            case FC_RP: 
            case FC_UP: 
            case FC_FP: 
            case FC_OP:
            case FC_IP:
            {
                cbElement = PTR_MEM_SIZE;
                break;
            }
            
            case FC_ENUM16:
            {
                cbElement = sizeof(int);
                for (ULONG i = 0 ; i < count; i++)
                {
                    int element = *( (int*)pMemoryFrom + i );
                    if (element & ~((int)0x7FFF))
                    {
                        Throw(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
                    }
                }
                break;
            }
            
            default:
                ASSERT(IS_SIMPLE_TYPE(pFormat[0]));
                cbElement = SIMPLE_TYPE_MEMSIZE(pFormat[0]);
                break;
            }
            
            /////////////////////////////////////////////////
            //
            // Allocate and initialize the destination array
            //
            ULONG cbArray = (ULONG)cElements * (ULONG)cbElement;
            ULONG cbValid =     count * cbElement;
            //
            BYTE* pMemoryTo = *(ppMemoryTo);
            if (fMustAlloc || NULL == pMemoryTo)
            {
                pMemoryTo = (BYTE*)m_pAllocatorFrame->Alloc(cbArray, m_fWorkingOnOutParam);
                if (pMemoryTo == NULL)
                    ThrowHRESULT(E_OUTOFMEMORY);
                *ppMemoryTo = pMemoryTo;
            }
            ZeroMemory(pMemoryTo, cbArray);
            
            /////////////////////////////////////////////////
            //
            // Adjust source and destination pointers to the start of the variance, if any
            //
            pMemoryFrom += offset * cbElement;
            pMemoryTo   += offset * cbElement;
            
            /////////////////////////////////////////////////
            //
            // Actually do the copying of the array
            //
            switch (bFormat)
            {
            case FC_EMBEDDED_COMPLEX:
            {
                BOOL fIsArray = IS_ARRAY_OR_STRING(pFormat[0]);
                if (!fIsArray)
                {
                    m_pArrayInfo = NULL;
                }
                //
                // Do it element by element
                //
                if (FC_IP == pFormat[0])
                {
                    for (ULONG i = 0; i < count ; i++)
                    {
                        // Keep track of multidimensional array information
                        //
                        if (fIsArray)
                        {
                            m_pArrayInfo->Dimension = dimension + 1;
                        }
                        // A conformant array of interface pointers shows up as an FC_EMBEDDED_COMPLEX
                        // case. Don't ask me why, but be sure to give the right levels of indirection
                        // in any case.
                        //
                        ASSERT(cbElement == sizeof(LPUNKNOWN));
                        PBYTE* rgpbMemoryFrom = (PBYTE*)pMemoryFrom;
                        PBYTE* rgpbMemoryTo   = (PBYTE*)pMemoryTo;
                        CopyWorker(*(rgpbMemoryFrom + i), &rgpbMemoryTo[i], pFormat, /*we've already allocated the pointer for him*/ FALSE);
                    }
                }
                else
                {
                    // As we recurse to copy, we need to make sure we have
                    // memory in the right spaces for checking purposes.
                    //
                    PBYTE pbTemp;
                    PBYTE* ppbTo = GetAllocatedPointer(pbTemp);
                    for (ULONG i = 0; i < count ; i++)
                    {
                        // Keep track of multidimensional array information
                        //
                        if (fIsArray)
                        {
                            m_pArrayInfo->Dimension = dimension + 1;
                        }
                        //
                        PBYTE  pbFrom = pMemoryFrom + (i*cbElement);
                        PBYTE  pbTo   = pMemoryTo   + (i*cbElement);
                        
                        *ppbTo = pbTo;
                        CopyWorker(pbFrom, ppbTo, pFormat, FALSE);
                    }
                    FreeAllocatedPointer(ppbTo);
                }
                
                break;
            }
            
            case FC_RP: case FC_UP: case FC_FP: case FC_OP:
            case FC_IP:
            {
                PBYTE* rgpbMemoryFrom = (PBYTE*)pMemoryFrom;
                PBYTE* rgpbMemoryTo   = (PBYTE*)pMemoryTo;
                //
                for (ULONG i = 0; i < count; i++)
                {
                    CopyWorker(*(rgpbMemoryFrom + i), &rgpbMemoryTo[i], pFormat, FALSE);
                }
                break;
            }
            
            case FC_ENUM16:
            default:
                CopyMemory(pMemoryTo, pMemoryFrom, cbValid);
                break;
            }
        }
        __finally
        {
            m_pArrayInfo = pArrayInfoStart;
        }
    }
    break;

    /////////////////////////////////////////////////////////////////////
    //
    // Copying bogus structures
    //
    /////////////////////////////////////////////////////////////////////

    case FC_BOGUS_STRUCT:
    {
        const BYTE alignment = pFormat[1];              // wire alignment of the structure
        const LONG_PTR alignMod8 = ((LONG_PTR)pMemoryFrom) % 8;
        const LONG_PTR alignMod4 = ((LONG_PTR)pMemoryFrom) % 4;

        const PBYTE prevMemory = m_Memory;
        m_Memory = pMemoryFrom;

        __try
        {
            const PFORMAT_STRING pFormatSave = pFormat;
            const PBYTE pMemFrom = pMemoryFrom;
            //
            pFormat += 4;   // to conformant array offset field
            //
            // Get conformant array description
            //
            const PFORMAT_STRING pFormatArray = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Get pointer layout description
            //
            PFORMAT_STRING pFormatPointers = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Compute the size of this struct
            //
            ULONG cbStruct = (ULONG)(MemoryIncrement(pMemFrom, pFormatSave, TRUE) - pMemFrom);
            //
            // Allocate and initialize the destination struct
            //
            PBYTE pbT = *(ppMemoryTo);
            if (fMustAlloc || NULL == pbT)
            {
                pbT = (BYTE*)m_pAllocatorFrame->Alloc(cbStruct, m_fWorkingOnOutParam);
                if (pbT == NULL)
                    ThrowHRESULT(E_OUTOFMEMORY);
                *ppMemoryTo = pbT;
            }
            const PBYTE pMemoryTo = pbT;
            ZeroMemory(pMemoryTo, cbStruct);
            //
            // Copy the structure member by member
            //
            PBYTE pbTemp;
            PBYTE* ppbTo = GetAllocatedPointer(pbTemp);
            __try
            {
                ULONG dib = 0;
                for (BOOL fContinue = TRUE; fContinue ; pFormat++)
                {
                    switch (pFormat[0])
                    {
                    case FC_CHAR:  case FC_BYTE:  case FC_SMALL:  case FC_WCHAR:  case FC_SHORT: case FC_LONG:
                    case FC_FLOAT: case FC_HYPER: case FC_DOUBLE: case FC_ENUM16: case FC_ENUM32: 
                    case FC_INT3264: case FC_UINT3264:
                    {
                        *ppbTo = pMemoryTo + dib;
                        CopyWorker(pMemFrom + dib, ppbTo, pFormat, FALSE);
                        dib += SIMPLE_TYPE_MEMSIZE(pFormat[0]);
                        break;
                    }
                    case FC_IGNORE:
                        break;
                    case FC_POINTER:
                    {
                        PBYTE* ppbFrom = (PBYTE*)(pMemFrom  + dib);
                        PBYTE* ppbTo   = (PBYTE*)(pMemoryTo + dib);
                        CopyWorker(*(ppbFrom), ppbTo, pFormatPointers, FALSE);
                        dib += PTR_MEM_SIZE;
                        pFormatPointers += 4;
                        break;
                    }
                    case FC_EMBEDDED_COMPLEX:
                    {
                        dib += pFormat[1]; // skip padding
                        pFormat += 2;
                        PFORMAT_STRING pFormatComplex = pFormat + * ((signed short UNALIGNED*) pFormat);
                        if (FC_IP == pFormatComplex[0])
                        {
                            LPUNKNOWN* ppunkFrom = (LPUNKNOWN*)(pMemFrom  + dib);
                            LPUNKNOWN* ppunkTo   = (LPUNKNOWN*)(pMemoryTo + dib);
                            CopyWorker((PBYTE)*(ppunkFrom), (PBYTE*)(ppunkTo), pFormatComplex, FALSE);
                        }
                        else
                        {
                            *ppbTo = pMemoryTo + dib;
                            CopyWorker(pMemFrom + dib, ppbTo, pFormatComplex, FALSE);
                        }
                        dib = (ULONG)(MemoryIncrement(pMemFrom + dib, pFormatComplex, TRUE) - pMemFrom);
                        pFormat++;      // main loop does one more for us
                        break;
                    }
                    case FC_ALIGNM2:
                        dib = (ULONG)(ALIGNED_VALUE(pMemFrom + dib, 0x01) - pMemFrom);
                        break;
                    case FC_ALIGNM4:
                        dib = (ULONG)(ALIGNED_VALUE(pMemFrom + dib, 0x03) - pMemFrom);
                        break;
                    case FC_ALIGNM8:
                        //
                        // Handle 8 byte aligned structure passed by value. Alignment of the struct on 
                        // the stack isn't guaranteed to be 8 bytes
                        //
                        dib -= (ULONG)alignMod8;
                        dib  = (ULONG)(ALIGNED_VALUE(pMemFrom + dib, 0x07) - pMemFrom);
                        dib += (ULONG)alignMod8;
                        break;
                    case FC_STRUCTPAD1: case FC_STRUCTPAD2: case FC_STRUCTPAD3: case FC_STRUCTPAD4:
                    case FC_STRUCTPAD5: case FC_STRUCTPAD6: case FC_STRUCTPAD7: 
                        dib += (pFormat[0] - FC_STRUCTPAD1) + 1;
                        break;
                    case FC_PAD:
                        break;
                    case FC_END:
                        //
                        fContinue = FALSE;
                        break;
                        //
                    default:
                        NOTREACHED();
                        return;
                    }
                }
                //
                // Copy the conformant array if we have one
                //
                if (pFormatArray)
                {
                    if (FC_C_WSTRING == pFormatArray[0])
                    {
                        dib = (ULONG)(ALIGNED_VALUE(pMemFrom + dib, 0x01) - pMemFrom);
                    }
                    
                    *ppbTo = pMemoryTo + dib;
                    CopyWorker(pMemFrom + dib, ppbTo, pFormatArray, FALSE);
                }
            }
            __finally
            {
                FreeAllocatedPointer(ppbTo);
            }
        }
        __finally
        {
            m_Memory = prevMemory;
        }
    }
    break;

    /////////////////////////////////////////////////////////////////////
    //
    // We handle a few special cases of user-marshal in our copying
    //
    /////////////////////////////////////////////////////////////////////
    case FC_USER_MARSHAL:
    {
        HRESULT hr;
        //
        // The format string layout is as follows:
        //      FC_USER_MARSHAL
        //      flags & alignment<1>
        //      quadruple index<2>
        //      memory size<2>
        //      wire size<2>
        //      type offset<2>
        // The wire layout description is at the type offset.  
        //
        USHORT iquad = *(USHORT *)(pFormat + 2);
        const USER_MARSHAL_ROUTINE_QUADRUPLE* rgQuad = GetStubDesc()->aUserMarshalQuadruple;
        
        if (g_oa.IsVariant(rgQuad[iquad]))
        {
            VARIANT* pvarFrom = (VARIANT*)  pMemoryFrom;
            VARIANT** ppvarTo = (VARIANT**) ppMemoryTo;
            
            VARIANT*   pvarTo = *(ppvarTo);
            if (fMustAlloc || NULL==pvarTo)
            {
                pvarTo = (VARIANT*)m_pAllocatorFrame->Alloc(sizeof(VARIANT), m_fWorkingOnOutParam);             
                *ppvarTo = pvarTo;
            }
            
            if (pvarTo)
            {
                VariantInit(pvarTo);
                hr = GetHelper().VariantCopy(pvarTo, pvarFrom, TRUE);
            }
            else
                hr = E_OUTOFMEMORY;
            
            if (!!hr) 
            { ThrowHRESULT(hr); }
        }
        
        else if (g_oa.IsBSTR(rgQuad[iquad]))
        {
            BSTR* pbstrFrom = (BSTR*) pMemoryFrom;
            BSTR   bstrFrom = *(pbstrFrom);
            
            BSTR** ppbstrTo = (BSTR**) ppMemoryTo;
            BSTR*   pbstrTo = *(ppbstrTo);
            
            if (NULL==pbstrTo) // REVIEW: also for fMustAlloc case?
            {
                pbstrTo = (BSTR*)m_pAllocatorFrame->Alloc(sizeof(BSTR), m_fWorkingOnOutParam);
                *ppbstrTo = pbstrTo;
            }
            
            if (pbstrTo)
            {
                hr = S_OK;
                //
                BSTR bstrNew = NULL;
                if (bstrFrom)
                {
                    bstrNew = SysCopyBSTRSrc(bstrFrom);
                    if (NULL == bstrNew)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                *pbstrTo = bstrNew;
            }
            else
                hr = E_OUTOFMEMORY;
            
            if (!!hr) 
            { ThrowHRESULT(hr); }
        }
        
        else if (g_oa.IsSAFEARRAY(rgQuad[iquad]))
        {
            SAFEARRAY** ppsaFrom = (SAFEARRAY**) pMemoryFrom;
            SAFEARRAY*   psaFrom = *(ppsaFrom);

            SAFEARRAY*** pppsaTo = (SAFEARRAY***) ppMemoryTo;
            SAFEARRAY**   ppsaTo = *(pppsaTo);

            if (NULL==ppsaTo) // REVIEW: also for fMustAlloc case?
            {
                ppsaTo = (SAFEARRAY**)m_pAllocatorFrame->Alloc(sizeof(SAFEARRAY*), m_fWorkingOnOutParam);
                *pppsaTo = ppsaTo;
            }

            if (ppsaTo)
            {
                hr = GetHelper().SafeArrayCopy(psaFrom, ppsaTo);
            }
            else
                hr = E_OUTOFMEMORY;

            if (!!hr) 
            { ThrowHRESULT(hr); }
        }

        else
        {
            ThrowNYI();
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Unimplemented stuff that probably we just should forget about
    //
    /////////////////////////////////////////////////////////////////////

    case FC_C_BSTRING:          // obsolete. only used by stubs compiled with an old NT Beta2 Midl compiler
    case FC_TRANSMIT_AS:        // need MIDL changes in order to support
    case FC_REPRESENT_AS:       // need MIDL changes in order to support
    case FC_TRANSMIT_AS_PTR:    // need MIDL changes in order to support
    case FC_REPRESENT_AS_PTR:   // need MIDL changes in order to support
    case FC_PIPE:               // a DCE-only-ism
        ThrowNYI();
        break;


        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that maybe we should get around to
        //
        /////////////////////////////////////////////////////////////////////

    case FC_C_SSTRING:              // 'struct string': is rare
    case FC_FP:                     // full pointer
    case FC_ENCAPSULATED_UNION:
    case FC_NON_ENCAPSULATED_UNION:
        ThrowNYI();
        break;

        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that remains to be evaluated
        //
        /////////////////////////////////////////////////////////////////////

    case FC_CSTRUCT:                // conformant struct
    case FC_CPSTRUCT:               // conformant struct with pointers
    case FC_CVSTRUCT:               // conformant varying struct
    case FC_CVARRAY:                // conformant varying array
    case FC_SMVARRAY:               
    case FC_LGVARRAY:
    case FC_CSTRING:                // [size_is(xxx), string]
    case FC_BSTRING:                // [size_is(xxx), string]
    case FC_SSTRING:                // [size_is(xxx), string]
    case FC_WSTRING:                // [size_is(xxx), string]
    case FC_BYTE_COUNT_POINTER:
    case FC_HARD_STRUCT:
    case FC_BLKHOLE:
    case FC_RANGE:
    default:
        ThrowNYI();
    }
}


void CallFrame::CopyConformantArrayPriv(BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc)
  // Copy the body of a conformant array after the allocation has been done elsewhere
{
    if (m_MaxCount > 0)
    {
        SIZE_T cbCopy = m_MaxCount * (*((ushort*)(pFormat+2)));
        CopyMemory(*(ppMemoryTo), pMemoryFrom, cbCopy);
        pFormat += 8;
        if (*pFormat == FC_PP)      // Is there a trailing pointer layout?
        {
            CopyEmbeddedPointers(pMemoryFrom, *(ppMemoryTo), pFormat, fMustAlloc);
        }
    }
}


inline PFORMAT_STRING CallFrame::CopyEmbeddedRepeatPointers(BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc)
  // Copies an array's embedded pointers
{
    SIZE_T repeatCount, repeatIncrement;
    //
    // Get the repeat count
    //
    switch (*pFormat)
    {
    case FC_FIXED_REPEAT:
        pFormat += 2;
        repeatCount = *(ushort*)pFormat;
        break;

    case FC_VARIABLE_REPEAT:
        repeatCount = m_MaxCount;           // ??? the last conformance calculation or something?
        //
        // Check if this variable repeat instance also has a variable offset (this would be the case for a conformant
        // varying array of pointers, or structures which contain pointers). If so then increment the format string
        // to point to the actual first array element which is being copied
        //
        if (pFormat[1] == FC_VARIABLE_OFFSET)
        {
            pbFrom += *((ushort *)(&pFormat[2])) * m_Offset;       // REVIEW!
            pbTo   += *((ushort *)(&pFormat[2])) * m_Offset;       // REVIEW!
        } 
        else
        {
            ASSERT(pFormat[1] == FC_FIXED_OFFSET);
        }
        break;

    default:
        NOTREACHED();
        repeatCount = 0;
    }

    pFormat += 2;                           // increment to increment field

    repeatIncrement = *(ushort*)pFormat;    // get increment amount between successive pointers
    pFormat += sizeof(ushort);
    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from the current embedding structure
    // or array to the array whose pointers we're copying.
    //
    m_Memory += *((ushort *)pFormat);
    pFormat += sizeof(ushort);

    ULONG cPointersSave = *(ushort*)pFormat;// get number of pointers in each array element
    pFormat += sizeof(ushort);

    PFORMAT_STRING pFormatSave = pFormat;

    // Loop over the number of array elements
    //
    for( ; repeatCount--; pbFrom += repeatIncrement, pbTo += repeatIncrement, m_Memory += repeatIncrement )
    {
        pFormat = pFormatSave;
        ULONG cPointers = cPointersSave;
        //
        // Loop over the number of pointers per array element. Can be more than one for an array of structures
        //
        for ( ; cPointers--; )
        {
            PVOID* ppvFrom = (PVOID*) (pbFrom + *((signed short *)(pFormat)));    // address of source pointer
            PVOID* ppvTo   = (PVOID*) (pbTo   + *((signed short *)(pFormat)));    // address of dest pointer

            pFormat += sizeof(signed short) * 2;

            if (fMustAlloc)
            {
                *ppvTo = NULL;
            }
            
            ASSERT(IsPointer(pFormat));     // Recurse to copy the pointer
            CopyWorker((BYTE*)*(ppvFrom), (BYTE**)ppvTo, pFormat, fMustAlloc);

            pFormat += 4;                   // increment to the next pointer description
        }
    }

    // return location of format string after the array's pointer description
    return pFormatSave + cPointersSave * 8;
}


void CallFrame::CopyEmbeddedPointers(BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc)
  // Fix up the embedded pointers in a copied struct or array. pFormat is pointing to the pointer_layout<>
  // description of the struct or array; pbStruct is the copied structure / array which needs rectification.
  // See also NdrpEmbeddedPointerUnmarshal in unmrshlp.c.
{
    ULONG_PTR       MaxCountSave = m_MaxCount;
    ULONG_PTR       OffsetSave   = m_Offset;

    // From NDR:
    // "The Memory field in the stub message keeps track of the pointer to the current embedding structure or 
    // array.  This is needed to handle size/length pointers, so that we can get a pointer to the current 
    // embedding struct when computing conformance and variance."
    //
    BYTE* pMemoryOld = SetMemory(pbFrom);

    ASSERT(*pFormat == FC_PP);
    pFormat += 2;   // Skip FC_PP and FC_PAD

    while (FC_END != *pFormat)
    {
        if (FC_NO_REPEAT == *pFormat)
        {
            PVOID* ppvFrom = (PVOID*) (pbFrom + *((signed short *)(pFormat + 2)));    // address of source pointer
            PVOID* ppvTo   = (PVOID*) (pbTo   + *((signed short *)(pFormat + 2)));    // address of dest pointer
            
            pFormat += 6;                   // increment to the pointer description

            if (fMustAlloc)
                *ppvTo = NULL;              // if the incoming encapsulating ptr was just allocated then NULL it
            
            ASSERT(IsPointer(pFormat));     // Recurse to copy the pointer
            CopyWorker((BYTE*)*(ppvFrom), (BYTE**)ppvTo, pFormat, m_fPropogatingOutParam);

            pFormat += 4;                   // increment ot the next pointer description
        }
        else
        {
            pFormat = CopyEmbeddedRepeatPointers(pbFrom, pbTo, pFormat, m_fPropogatingOutParam);
        }
    }

    SetMemory(pMemoryOld);
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////


void CallFrame::FreeWorker(BYTE* pMemory, PFORMAT_STRING pFormat, BOOL fFreePointer)
  // Free this darn data. 
  //
{
    switch (*pFormat)
    {
        /////////////////////////////////////////////////////////////////////
        //
        // Pointers
        //
        /////////////////////////////////////////////////////////////////////
    case FC_RP: // ref pointer
    case FC_UP: // unique pointer
    case FC_OP: // a unique pointer in a COM interface, which is not the top most pointer
    {
        if (NULL == pMemory) break;

        BYTE* pMemoryPointee = pMemory;
        BYTE  bPointerAttributes = pFormat[1];

        ASSERT(!DONT_FREE(bPointerAttributes));
        ASSERT(!ALLOCATE_ALL_NODES(bPointerAttributes));

        if (!SIMPLE_POINTER(bPointerAttributes))
        {
            // Free embedded pointers
            //
            PFORMAT_STRING pFormatPointee = &pFormat[2];
            pFormatPointee += *((signed short *)pFormatPointee);
            
            if (FIndirect(bPointerAttributes, pFormatPointee, FALSE))
            {
                pMemoryPointee = *((BYTE**)pMemoryPointee);
            }
            
            FreeWorker(pMemoryPointee, pFormatPointee, TRUE);
        }
        //
        // Free top level pointer. 
        //
        // We only check one byte for being in the proper memory space, since
        // the free logic, if it is in user mode, will go to user mode to free it,
        // where any bogosities beyond that one byte will be caught by the hardware.
        //
        if (fFreePointer)
        {
            Free(pMemory);
        }

        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Simple structs
    //
    /////////////////////////////////////////////////////////////////////
    case FC_PSTRUCT:
    {
        FreeEmbeddedPointers(pMemory, &pFormat[4]);
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Simple Types
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CHAR:
    case FC_BYTE:
    case FC_SMALL:
    case FC_WCHAR:
    case FC_SHORT:
    case FC_LONG:
    case FC_HYPER:
    case FC_ENUM16:
    case FC_ENUM32:
    case FC_DOUBLE:
    case FC_FLOAT:
    case FC_INT3264:
    case FC_UINT3264:
    {
        NOTREACHED();
    }
    break;

    /////////////////////////////////////////////////////////////////////
    //
    // Fixed sized arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_SMFARRAY:   // small fixed array
    case FC_LGFARRAY:   // large fixed array
    {
        if (pMemory) 
        {
            if (*pFormat == FC_SMFARRAY) 
                pFormat += 4;
            else
                pFormat += 6;

            if (*pFormat == FC_PP) 
                FreeEmbeddedPointers(pMemory, pFormat);
        }
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Conformant arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CARRAY:
    {
        if (pMemory)
        {
            if (pFormat[8] == FC_PP)
            {
                ComputeConformance(pMemory, pFormat, FALSE);
                FreeEmbeddedPointers(pMemory, pFormat + 8);
            }
        }
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Freeing really hard arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_BOGUS_ARRAY:
    {
        ARRAY_INFO*     pArrayInfoStart = m_pArrayInfo;
        PFORMAT_STRING  pFormatStart    = pFormat;

        __try
        {
            // Initialize m_pArrayInfo if necessary
            //
            ARRAY_INFO arrayInfo;
            if (NULL == m_pArrayInfo)
            {
                m_pArrayInfo = &arrayInfo;
                Zero(&arrayInfo);
            }
            const LONG dimension = m_pArrayInfo->Dimension;
            //
            // Get the array's alignment
            //
            const BYTE alignment = pFormat[1];
            pFormat += 2;
            //
            // Get the number of elements (0 if the array has conformance)
            //
            ULONG cElements = *(USHORT*)pFormat;
            pFormat += sizeof(USHORT);
            //
            // Check for conformance description
            //
            if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
            {
                cElements = (ULONG)ComputeConformance(pMemory, pFormatStart, FALSE);
            }
            pFormat += 4;
            CORRELATION_DESC_INCREMENT( pFormat );
            
            //
            // Check for variance description
            //
            ULONG offset;
            ULONG count;
            if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
            {
                ComputeVariance(pMemory, pFormatStart, &offset, &count, FALSE);
            }
            else
            {
                offset = 0;
                count  = cElements;
            }
            pFormat += 4;
            CORRELATION_DESC_INCREMENT( pFormat );
            
            /////////////////////////////////////////////////
            //
            // Compute the size of each element in the array
            //
            ULONG cbElement;
            //
            BYTE bFormat = pFormat[0];
            switch (bFormat)
            {
            case FC_EMBEDDED_COMPLEX:
            {
                pFormat += 2;
                pFormat += *((signed short *)pFormat);
                //
                m_pArrayInfo->Dimension = dimension + 1;
                cbElement = (ULONG)(MemoryIncrement(pMemory, pFormat, FALSE) - pMemory);
                break;
            }
            
            case FC_RP: case FC_UP: case FC_FP: case FC_OP:
            case FC_IP:
            {
                cbElement = PTR_MEM_SIZE;
                break;
            }
            
            default:
                ASSERT(IS_SIMPLE_TYPE(pFormat[0]));
                //
                // Fall through
                //
            case FC_ENUM16:
                //
                // Nothing to free
                //
                return;
            }
            
            /////////////////////////////////////////////////
            //
            // Adjust memory pointer to the start of the variance, if any
            //
            pMemory += offset * cbElement;
            
            /////////////////////////////////////////////////
            //
            // Actually do the freeing
            //
            switch (bFormat)
            {
            case FC_EMBEDDED_COMPLEX:
            {
                BOOL fIsArray = IS_ARRAY_OR_STRING(pFormat[0]);
                if (!fIsArray)
                {
                    m_pArrayInfo = NULL;
                }
                //
                // Do it element by element
                //
                for (ULONG i = 0; i < count ; i++)
                {
                    if (fIsArray)
                    {
                        m_pArrayInfo->Dimension = dimension + 1;
                    }
                    //
                    PBYTE pb = pMemory + (i*cbElement);
                    FreeWorker(pb, pFormat, TRUE);
                    //
                }
                
                break;
            }
            
            case FC_RP: case FC_UP: case FC_FP: case FC_OP:
            {
                PBYTE* rgpbMemory = (PBYTE*)pMemory;
                //
                for (ULONG i = 0; i < count; i++)
                {
                    FreeWorker(*(rgpbMemory + i), pFormat, TRUE);
                }
                break;
            }
            
            case FC_IP:
                // In the free cycle, interface pointers have one less level of indirection than FC_RP etc
            {
                LPUNKNOWN* rgpunk = (LPUNKNOWN*)pMemory;
                //
                for (ULONG i = 0; i < count; i++)
                {
                    FreeWorker( (PBYTE) &rgpunk[i], pFormat, TRUE);
                }
                break;
            }
            
            default:
                NOTREACHED();
            }
        }
        __finally
        {
            m_pArrayInfo = pArrayInfoStart;
        }
    }
    break;

    /////////////////////////////////////////////////////////////////////
    //
    // Freeing bogus structures
    //
    /////////////////////////////////////////////////////////////////////
    case FC_BOGUS_STRUCT:
    {
        const BYTE alignment = pFormat[1];          // wire alignment of the structure
        const LONG_PTR alignMod8 = ((LONG_PTR)pMemory) % 8;
        const LONG_PTR alignMod4 = ((LONG_PTR)pMemory) % 4;

        const PBYTE prevMemory = m_Memory;
        m_Memory = pMemory;

        __try
        {
            const PFORMAT_STRING pFormatSave = pFormat;
            const PBYTE pMem = pMemory;
            //
            pFormat += 4;   // to conformant array offset field
            //
            // Get conformant array description
            //
            const PFORMAT_STRING pFormatArray = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Get pointer layout description
            //
            PFORMAT_STRING pFormatPointers = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Free the structure member by member
            //
            ULONG dib = 0;
            for (BOOL fContinue = TRUE; fContinue ; pFormat++)
            {
                switch (pFormat[0])
                {
                case FC_CHAR:  case FC_BYTE:  case FC_SMALL:  case FC_WCHAR:  case FC_SHORT: case FC_LONG:
                case FC_FLOAT: case FC_HYPER: case FC_DOUBLE: case FC_ENUM16: case FC_ENUM32:
                case FC_INT3264: case FC_UINT3264:
                {
                    // Nothing to free
                    dib += SIMPLE_TYPE_MEMSIZE(pFormat[0]);
                    break;
                }
                case FC_IGNORE:
                    break;
                case FC_POINTER:
                {
                    PBYTE* ppb = (PBYTE*)(pMem + dib);
                    FreeWorker(*(ppb), pFormatPointers, TRUE);
                    *ppb = NULL;
                    //
                    dib += PTR_MEM_SIZE;
                    pFormatPointers += 4;
                    break;
                }
                case FC_EMBEDDED_COMPLEX:
                {
                    dib += pFormat[1]; // skip padding
                    pFormat += 2;
                    PFORMAT_STRING pFormatComplex = pFormat + * ((signed short UNALIGNED*) pFormat);
                    FreeWorker(pMem + dib, pFormatComplex, TRUE);
                    ULONG dibNew = (ULONG)(MemoryIncrement(pMem + dib, pFormatComplex, TRUE) - pMem);
                    if (pFormatComplex[0] == FC_IP)     // REVIEW: Also for other pointer types?
                    {
                        ZeroMemory(pMem + dib, dibNew - dib);
                    }
                    dib = dibNew;
                    pFormat++;      // main loop does one more for us
                    break;
                }
                case FC_ALIGNM2:
                    dib = (ULONG)(ALIGNED_VALUE(pMem + dib, 0x01) - pMem);
                    break;
                case FC_ALIGNM4:
                    dib = (ULONG)(ALIGNED_VALUE(pMem + dib, 0x03) - pMem);
                    break;
                case FC_ALIGNM8:
                    //
                    // Handle 8 byte aligned structure passed by value. Alignment of the struct on 
                    // the stack isn't guaranteed to be 8 bytes
                    //
                    dib -= (ULONG)alignMod8;
                    dib  = (ULONG)(ALIGNED_VALUE(pMem + dib, 0x07) - pMem);
                    dib += (ULONG)alignMod8;
                    break;
                case FC_STRUCTPAD1: case FC_STRUCTPAD2: case FC_STRUCTPAD3: case FC_STRUCTPAD4:
                case FC_STRUCTPAD5: case FC_STRUCTPAD6: case FC_STRUCTPAD7: 
                    dib += (pFormat[0] - FC_STRUCTPAD1) + 1;
                    break;
                case FC_PAD:
                    break;
                case FC_END:
                    //
                    fContinue = FALSE;
                    break;
                    //
                default:
                    NOTREACHED();
                    return;
                }
            }
            //
            // Copy the conformant array if we have one
            //
            if (pFormatArray)
            {
                if (FC_C_WSTRING == pFormatArray[0])
                {
                    dib = (ULONG)(ALIGNED_VALUE(pMem + dib, 0x01) - pMem);
                }
                FreeWorker(pMem + dib, pFormatArray, TRUE);
            }
        }
        __finally
        {
            m_Memory = prevMemory;
        }
    }
    break;
    
    
    /////////////////////////////////////////////////////////////////////
    //
    // Freeing interface pointers: 
    //
    /////////////////////////////////////////////////////////////////////
    case FC_IP:
    {
        // Figure out the IID and call the walker if there is one. Otherwise,
        // leave the interface pointer just as it is.
        //
        IUnknown** ppUnk = (IUnknown**)pMemory;

        if (m_pWalkerFree)
        {
            IID UNALIGNED *pIID;

            if (pFormat[1] == FC_CONSTANT_IID)
            {
                pIID = (IID UNALIGNED *)&pFormat[2];
            }
            else
            {
                pIID = (IID UNALIGNED *)ComputeConformance(pMemory, pFormat, FALSE);
                if (NULL == pIID)
                    Throw(STATUS_INVALID_PARAMETER);
            }
            //
            // Note: in freeing case, changing the interface pointer has no effect
            // in its container; our caller will NULL it anyway.
            //
            IID iid;
            CopyMemory(&iid, pIID, sizeof(IID));
            ThrowIfError(m_pWalkerFree->OnWalkInterface(iid, (void**)ppUnk, m_fWorkingOnInParam, m_fWorkingOnOutParam));
        }
        else
        {
            // We've been asked to free the thing, but he hasn't given us a walker
            // to do so. So just release the thing. Note that in the post-'unmarshal'
            // case on the server side, this will be the right thing.
            //
            IUnknown* punk = *(ppUnk);
            *ppUnk = NULL;
            if (punk)
            {
                punk->Release();
            }
        }
        
        *ppUnk = (LPUNKNOWN)NULL; // NULL out the pointer
        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // We handle a few special cases of user-marshal
    //
    /////////////////////////////////////////////////////////////////////
    case FC_USER_MARSHAL:
    {
        const USHORT iquad = *(USHORT *)(pFormat + 2);
        const USER_MARSHAL_ROUTINE_QUADRUPLE* rgQuad = GetStubDesc()->aUserMarshalQuadruple;

        if (m_fIsUnmarshal)
        {
            // If we're beeing asked to Free() on an umarshalled frame, we should just do 
            // the "user free" routine.  (Since it was allocated with the "user unmarshal"
            // routine.)
            ULONG Flags = 0;
            rgQuad[iquad].pfnFree(&Flags, pMemory);
        }
        else
        {
            if (g_oa.IsVariant(rgQuad[iquad]))
            {            
                VARIANT* pvar = (VARIANT*) pMemory;
                GetHelper().VariantClear(pvar, TRUE);
                //
                // Don't free the pointer here, do this, as 'container' will free us. Consider,
                // for example, an array of VARIANTs, where each VARIANT itself isn't independently
                // allocated. Can't happen with BSTRs and LPSAFEARRAYs, where the runtime always
                // owns the allocation thereof.
            }
            else if (g_oa.IsBSTR(rgQuad[iquad]))
            {
                BSTR* pbstr = (BSTR*) pMemory;
                BSTR bstr = *(pbstr);
                *pbstr = NULL;
                
                SysFreeStringDst(bstr);
            }
            else if (g_oa.IsSAFEARRAY(rgQuad[iquad]))
            {
                LPSAFEARRAY* ppsa = (LPSAFEARRAY*) pMemory;
                LPSAFEARRAY   psa = *(ppsa);
                *ppsa = NULL;
                
                GetHelper().SafeArrayDestroy(psa);
            }
            else
                ThrowNYI();
        }
            
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Stuff that doesn't need freeing
    //
    /////////////////////////////////////////////////////////////////////
    case FC_STRUCT:
    case FC_CSTRUCT:
    case FC_C_CSTRING:
    case FC_C_BSTRING:
    case FC_C_SSTRING:
    case FC_C_WSTRING:
    case FC_CSTRING:
    case FC_BSTRING:
    case FC_SSTRING:
    case FC_WSTRING:

        break;

        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that probably we just should forget about
        //
        /////////////////////////////////////////////////////////////////////

    case FC_TRANSMIT_AS:        // need MIDL changes in order to support
    case FC_REPRESENT_AS:       // need MIDL changes in order to support
    case FC_TRANSMIT_AS_PTR:    // need MIDL changes in order to support
    case FC_REPRESENT_AS_PTR:   // need MIDL changes in order to support
    case FC_PIPE:               // a DCE-only-ism
        ThrowNYI();
        break;


        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that maybe we should get around to
        //
        /////////////////////////////////////////////////////////////////////

    case FC_FP:                     // full pointer
    case FC_ENCAPSULATED_UNION:
    case FC_NON_ENCAPSULATED_UNION:
        ThrowNYI();
        break;

        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that remains to be evaluated
        //
        /////////////////////////////////////////////////////////////////////

    case FC_CPSTRUCT:               // conformant struct with pointers
    case FC_CVSTRUCT:               // conformant varying struct
    case FC_CVARRAY:                // conformant varying array
    case FC_SMVARRAY:               
    case FC_LGVARRAY:
    case FC_BYTE_COUNT_POINTER:
    case FC_HARD_STRUCT:
    case FC_BLKHOLE:
    case FC_RANGE:
    default:
        ThrowNYI();
    }
}


inline PFORMAT_STRING CallFrame::FreeEmbeddedRepeatPointers(BYTE* pMemory, PFORMAT_STRING pFormat)
{
    ULONG_PTR repeatCount, repeatIncrement;

    switch (*pFormat)
    {
    case FC_FIXED_REPEAT:
        pFormat += 2;                       // past FC_FIXED_REPEAT and FC_PAD
        repeatCount = *(ushort*)pFormat;
        break;

    case FC_VARIABLE_REPEAT:
        repeatCount = m_MaxCount;           // ??? the last conformance calculation or something?
        //
        // Check if this variable repeat instance also has a variable offset (this would be the case for a conformant
        // varying array of pointers, or structures which contain pointers). If so then incremnent the format string
        // to point to the actual first array element which is being copied
        //
        if (pFormat[1] == FC_VARIABLE_OFFSET)
        {
            pMemory += *((ushort*)(&pFormat[2])) * m_Offset;        // REVIEW!
        } 
        else
        {
            ASSERT(pFormat[1] == FC_FIXED_OFFSET);
        }
        break;

    default:
        NOTREACHED();
        repeatCount = 0;
    }

    pFormat += 2;                           // increment to increment field
    repeatIncrement = *(ushort*)pFormat;    // get increment amount between successive pointers
    pFormat += sizeof(ushort);              // skip that 
    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from the current embedding structure
    // or array to the array whose pointers we're copying.
    //
    m_Memory += *((ushort *)pFormat);
    pFormat += sizeof(ushort);

    ULONG cPointersSave = *(ushort*)pFormat;// get number of pointers in each array element
    pFormat += sizeof(ushort);

    PFORMAT_STRING pFormatSave = pFormat;

    // Loop over the number of array elements
    //
    for( ; repeatCount--; pMemory += repeatIncrement, m_Memory += repeatIncrement )
    {
        pFormat = pFormatSave;
        ULONG cPointers = cPointersSave;
        //
        // Loop over the number of pointers per array element. Can be more than one for an array of structures
        //
        for ( ; cPointers--; )
        {
            PVOID* pp = (PVOID*) (pMemory + *((signed short *)(pFormat)));    // address of pointer to free

            pFormat += sizeof(signed short) * 2;

            ASSERT(IsPointer(pFormat));     
            FreeWorker((BYTE*)*(pp), pFormat, TRUE);
            *pp = (PVOID)NULL;

            pFormat += 4;                   // increment to the next pointer description
        }
    }

    // return location of format string after the array's pointer description
    return pFormatSave + cPointersSave * 8;
}

void CallFrame::FreeEmbeddedPointers(BYTE* pMemory, PFORMAT_STRING pFormat)
  // Free pointers in an embedded struct or array
{
    ASSERT(*pFormat == FC_PP);
    pFormat += 2;   // Skip FC_PP and FC_PAD

    BYTE* pMemoryOld = SetMemory(pMemory);

    while (FC_END != *pFormat)
    {
        if (FC_NO_REPEAT == *pFormat)
        {
            PVOID* pp = (PVOID*) (pMemory + *((signed short *)(pFormat + 2)));    // address of pointer in struct
            
            pFormat += 6;                       // skip to pointer description

            ASSERT(IsPointer(pFormat));     
            FreeWorker((BYTE*)*(pp), pFormat, TRUE);    // recurse to free the pointer
            *pp = (PVOID)NULL;

            pFormat += 4;                       // skip to next pointer description
        }
        else
        {
            pFormat = FreeEmbeddedRepeatPointers(pMemory, pFormat);
        }
    }

    SetMemory(pMemoryOld);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

void CallFrame::WalkWorker(BYTE* pMemory, PFORMAT_STRING pFormat)
  // Walk the call frame, looking for interface pointers, calling our walker callback when we find them
  // 
{
    switch (*pFormat)
    {
        /////////////////////////////////////////////////////////////////////
        //
        // Pointers
        //
        // In the future, we can be more clever here about sharing with our
        // source data than we are. For example, we could take advantage of the
        // ALLOCED_ON_STACK information that MIDL emits. For the moment, that 
        // would complicate things beyond their worth, however.
        //
        /////////////////////////////////////////////////////////////////////
    case FC_RP: // ref pointer
        if (NULL == pMemory)
        {
            Throw(RPC_NT_NULL_REF_POINTER);
        }
        //
        // Fall through
        //
    case FC_UP: // unique pointer
    case FC_OP: // a unique pointer, which is not the top most pointer, in a COM interface, 
    {
        if (NULL == pMemory)
        {
            return;
        }
        BYTE bPointerAttributes = pFormat[1];
        if (SIMPLE_POINTER(bPointerAttributes))
        {
            // It's a pointer to a simple type or a string pointer. Either way, just recurse to Walk
            //
            WalkWorker(pMemory, &pFormat[2]);
        }
        else
        {
            // It's a more complex pointer type
            //
            PFORMAT_STRING pFormatPointee = pFormat + 2;
            pFormatPointee += *((signed short *)pFormatPointee);
            //
            // We don't handle [allocate] attributes
            //
            //if (ALLOCATE_ALL_NODES(bPointerAttributes) || DONT_FREE(bPointerAttributes)) ThrowNYI();

            if (FIndirect(bPointerAttributes, pFormatPointee, FALSE))
            {
                pMemory = *((PBYTE*)pMemory);
            }
            WalkWorker(pMemory, pFormatPointee);
        }
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Walking interface Pointers
    //
    /////////////////////////////////////////////////////////////////////
    case FC_IP:
    {
        // Figure out the IID and call the walker if there is one
        //
        if (m_pWalkerWalk)
        {
            IID UNALIGNED *pIID;

            if (pFormat[1] == FC_CONSTANT_IID)
            {
                pIID = (IID UNALIGNED *)&pFormat[2];
            }
            else
            {
                pIID = (IID UNALIGNED *)ComputeConformance(pMemory, pFormat, TRUE);
                if (NULL == pIID)
                    Throw(STATUS_INVALID_PARAMETER);
            }

            IID iid;
            CopyMemory(&iid, pIID, sizeof(IID));
            ThrowIfError(m_pWalkerWalk->OnWalkInterface(iid, (PVOID*)pMemory, m_fWorkingOnInParam, m_fWorkingOnOutParam));
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Walking simple structs
    //
    /////////////////////////////////////////////////////////////////////
    case FC_STRUCT:
    case FC_PSTRUCT:
    {
        if (NULL == pMemory)
            Throw(RPC_NT_NULL_REF_POINTER);

        if (*pFormat == FC_PSTRUCT)
        {
            WalkEmbeddedPointers(pMemory, &pFormat[4]);
        }

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Types that never have interface pointers
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CHAR:
    case FC_BYTE:
    case FC_SMALL:
    case FC_WCHAR:
    case FC_SHORT:
    case FC_LONG:
    case FC_HYPER:
    case FC_ENUM16:
    case FC_ENUM32:
    case FC_DOUBLE:
    case FC_FLOAT:
    case FC_CSTRING:                // [size_is(xxx), string]
    case FC_BSTRING:                // [size_is(xxx), string]
    case FC_SSTRING:                // [size_is(xxx), string]
    case FC_WSTRING:                // [size_is(xxx), string]
    case FC_C_CSTRING:              // ascii zero-terminated-string
    case FC_C_WSTRING:              // unicode zero-terminated-string
    case FC_INT3264:
    case FC_UINT3264:
    {
        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Fixed sized arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_SMFARRAY:   // small fixed array
    case FC_LGFARRAY:   // large fixed array
    {
        ULONG cbArray;
        if (*pFormat == FC_SMFARRAY)
        {
            pFormat += 2;               // skip code and alignment
            cbArray = *(ushort*)pFormat;
            pFormat += sizeof(ushort);
        }
        else // FC_LGFARRAY
        {
            pFormat += 2;
            cbArray = *(ulong UNALIGNED*)pFormat;
            pFormat += sizeof(ulong);
        }

        if (*pFormat == FC_PP)
        {
            WalkEmbeddedPointers(pMemory, pFormat);
        }

        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Walking conformant arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_CARRAY:
    {
        ULONG count = (ULONG)ComputeConformance(pMemory, pFormat, FALSE);
        ASSERT(count == m_MaxCount);

        if (m_MaxCount > 0)
        {
            WalkConformantArrayPriv(pMemory, pFormat);
        }

        break;
    }

    /////////////////////////////////////////////////////////////////////
    //
    // Walking bogus arrays
    //
    /////////////////////////////////////////////////////////////////////
    case FC_BOGUS_ARRAY:
    {
        ARRAY_INFO*     pArrayInfoStart = m_pArrayInfo;
        PFORMAT_STRING  pFormatStart    = pFormat;

        __try
          {
              // Initialize m_pArrayInfo if necessary
              //
              ARRAY_INFO arrayInfo;
              if (NULL == m_pArrayInfo)
              {
                  m_pArrayInfo = &arrayInfo;
                  Zero(&arrayInfo);
              }
              const LONG dimension = m_pArrayInfo->Dimension;
              //
              // Get the array's alignment
              //
              const BYTE alignment = pFormat[1];
              pFormat += 2;
              //
              // Get the number of elements (0 if the array has conformance)
              //
              ULONG cElements = *(USHORT*)pFormat;
              pFormat += sizeof(USHORT);
              //
              // Check for conformance description
              //
              if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
              {
                  cElements = (ULONG)ComputeConformance(pMemory, pFormatStart, TRUE);
              }
              pFormat += 4;
              CORRELATION_DESC_INCREMENT( pFormat );

              //
              // Check for variance description
              //
              ULONG offset;
              ULONG count;
              if ( *((LONG UNALIGNED*)pFormat) != 0xFFFFFFFF )
              {
                  ComputeVariance(pMemory, pFormatStart, &offset, &count, TRUE);
              }
              else
              {
                  offset = 0;
                  count  = cElements;
              }
              pFormat += 4;
              CORRELATION_DESC_INCREMENT( pFormat );

              /////////////////////////////////////////////////
              //
              // Compute the size of each element in the array
              //
              ULONG cbElement;
              //
              BYTE bFormat = pFormat[0];
              switch (bFormat)
              {
              case FC_EMBEDDED_COMPLEX:
              {
                  pFormat += 2;
                  pFormat += *((signed short *)pFormat);
                  //
                  m_pArrayInfo->Dimension = dimension + 1;
                  cbElement = (ULONG)(MemoryIncrement(pMemory, pFormat, TRUE) - pMemory);
                  break;
              }

              case FC_RP: case FC_UP: case FC_FP: case FC_OP:
              case FC_IP:
              {
                  cbElement = PTR_MEM_SIZE;
                  break;
              }

              default:
                  ASSERT(IS_SIMPLE_TYPE(pFormat[0]));
                  //
                  // Fall through
                  //
              case FC_ENUM16:
                  //
                  // Nothing to walk
                  //
                  return;
              }

              /////////////////////////////////////////////////
              //
              // Adjust memory pointer to the start of the variance, if any
              //
              pMemory += offset * cbElement;

              /////////////////////////////////////////////////
              //
              // Actually do the walking
              //
              switch (bFormat)
              {
              case FC_EMBEDDED_COMPLEX:
              {
                  BOOL fIsArray = IS_ARRAY_OR_STRING(pFormat[0]);
                  if (!fIsArray)
                  {
                      m_pArrayInfo = NULL;
                  }
                  //
                  // Do it element by element
                  //
                  for (ULONG i = 0; i < count ; i++)
                  {
                      if (fIsArray)
                      {
                          m_pArrayInfo->Dimension = dimension + 1;
                      }
                      //
                      PBYTE pb = pMemory + (i*cbElement);
                      WalkWorker(pb, pFormat);
                      //
                  }

                  break;
              }

              case FC_RP: case FC_UP: case FC_FP: case FC_OP:
              {
                  PBYTE* rgpbMemory = (PBYTE*)pMemory;
                  //
                  for (ULONG i = 0; i < count; i++)
                  {
                      WalkWorker(*(rgpbMemory + i), pFormat);
                  }
                  break;
              }

              case FC_IP:
                  // In the walk cycle, interface pointers have one less level of indirection than FC_RP etc
              {
                  LPUNKNOWN* rgpunk = (LPUNKNOWN*)pMemory;
                  //
                  for (ULONG i = 0; i < count; i++)
                  {
                      WalkWorker( (PBYTE) &rgpunk[i], pFormat);
                  }
                  break;
              }

              default:
                  NOTREACHED();
              }
          }
        __finally
          {
              m_pArrayInfo = pArrayInfoStart;
          }
    }
    break;

    /////////////////////////////////////////////////////////////////////
    //
    // Walking bogus structures
    //
    /////////////////////////////////////////////////////////////////////

    case FC_BOGUS_STRUCT:
    {
        const BYTE alignment = pFormat[1];          // wire alignment of the structure
        const LONG_PTR alignMod8 = ((LONG_PTR)pMemory) % 8;
        const LONG_PTR alignMod4 = ((LONG_PTR)pMemory) % 4;

        const PBYTE prevMemory = m_Memory;
        m_Memory = pMemory;

        __try
        {
            const PFORMAT_STRING pFormatSave = pFormat;
            const PBYTE pMem = pMemory;
            //
            pFormat += 4;   // to conformant array offset field
            //
            // Get conformant array description
            //
            const PFORMAT_STRING pFormatArray = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Get pointer layout description
            //
            PFORMAT_STRING pFormatPointers = *((USHORT*)pFormat) ? pFormat + * ((signed short*) pFormat) : NULL;
            pFormat += 2;
            //
            // Walk the structure member by member
            //
            ULONG dib = 0;
            for (BOOL fContinue = TRUE; fContinue ; pFormat++)
            {
                switch (pFormat[0])
                {
                case FC_CHAR:  case FC_BYTE:  case FC_SMALL:  case FC_WCHAR:  case FC_SHORT: case FC_LONG:
                case FC_FLOAT: case FC_HYPER: case FC_DOUBLE: case FC_ENUM16: case FC_ENUM32:
                case FC_INT3264: case FC_UINT3264:
                {
                    // Nothing to walk
                    dib += SIMPLE_TYPE_MEMSIZE(pFormat[0]);
                    break;
                }
                case FC_IGNORE:
                    break;
                case FC_POINTER:
                {
                    PBYTE* ppb = (PBYTE*)(pMem + dib);
                    WalkWorker(*(ppb), pFormatPointers);
                    //
                    dib += PTR_MEM_SIZE;
                    pFormatPointers += 4;
                    break;
                }
                case FC_EMBEDDED_COMPLEX:
                {
                    dib += pFormat[1]; // skip padding
                    pFormat += 2;
                    PFORMAT_STRING pFormatComplex = pFormat + * ((signed short UNALIGNED *) pFormat);
                    WalkWorker(pMem + dib, pFormatComplex);
                    dib = (ULONG)(MemoryIncrement(pMem + dib, pFormatComplex, TRUE) - pMem);
                    pFormat++;      // main loop does one more for us
                    break;
                }
                case FC_ALIGNM2:
                    dib = (ULONG)(ALIGNED_VALUE(pMem + dib, 0x01) - pMem);
                    break;
                case FC_ALIGNM4:
                    dib = (ULONG)(ALIGNED_VALUE(pMem + dib, 0x03) - pMem);
                    break;
                case FC_ALIGNM8:
                    //
                    // Handle 8 byte aligned structure passed by value. Alignment of the struct on 
                    // the stack isn't guaranteed to be 8 bytes
                    //
                    dib -= (ULONG)alignMod8;
                    dib  = (ULONG)(ALIGNED_VALUE(pMem + dib, 0x07) - pMem);
                    dib += (ULONG)alignMod8;
                    break;
                case FC_STRUCTPAD1: case FC_STRUCTPAD2: case FC_STRUCTPAD3: case FC_STRUCTPAD4:
                case FC_STRUCTPAD5: case FC_STRUCTPAD6: case FC_STRUCTPAD7: 
                    dib += (pFormat[0] - FC_STRUCTPAD1) + 1;
                    break;
                case FC_PAD:
                    break;
                case FC_END:
                    //
                    fContinue = FALSE;
                    break;
                    //
                default:
                    NOTREACHED();
                    return;
                }
            }
            //
            // Walk the conformant array if we have one
            //
            if (pFormatArray)
            {
                if (FC_C_WSTRING == pFormatArray[0])
                {
                    dib = (ULONG)(ALIGNED_VALUE(pMem + dib, 0x01) - pMem);
                }
                WalkWorker(pMem + dib, pFormatArray);
            }
        }
        __finally
        {
            m_Memory = prevMemory;
        }
    }
    break;


    /////////////////////////////////////////////////////////////////////
    //
    // We handle a few special cases of user-marshal in our walking
    //
    /////////////////////////////////////////////////////////////////////
    case FC_USER_MARSHAL:
    {
        // The format string layout is as follows:
        //      FC_USER_MARSHAL
        //      flags & alignment<1>
        //      quadruple index<2>
        //      memory size<2>
        //      wire size<2>
        //      type offset<2>
        // The wire layout description is at the type offset.  
        //
        USHORT iquad = *(USHORT *)(pFormat + 2);
        const USER_MARSHAL_ROUTINE_QUADRUPLE* rgQuad = GetStubDesc()->aUserMarshalQuadruple;

        if (g_oa.IsVariant(rgQuad[iquad]))
        {
            VARIANT* pvar = (VARIANT*) pMemory;
            ThrowIfError(GetWalker().Walk(pvar));
        }
        else if (g_oa.IsBSTR(rgQuad[iquad]))
        {
            // No interfaces here
        }
        else if (g_oa.IsSAFEARRAY(rgQuad[iquad]))
        {
            LPSAFEARRAY* ppsa = (LPSAFEARRAY*) pMemory;
            ThrowIfError(GetWalker().Walk(*ppsa));
        }
        else
            ThrowNYI();

        break;
    }


    /////////////////////////////////////////////////////////////////////
    //
    // Unimplemented stuff that probably we just should forget about
    //
    /////////////////////////////////////////////////////////////////////

    case FC_C_BSTRING:          // obsolete. only used by stubs compiled with an old NT Beta2 Midl compiler
    case FC_TRANSMIT_AS:        // need MIDL changes in order to support
    case FC_REPRESENT_AS:       // need MIDL changes in order to support
    case FC_TRANSMIT_AS_PTR:    // need MIDL changes in order to support
    case FC_REPRESENT_AS_PTR:   // need MIDL changes in order to support
    case FC_PIPE:               // a DCE-only-ism
        ThrowNYI();
        break;


        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that maybe we should get around to
        //
        /////////////////////////////////////////////////////////////////////

    case FC_C_SSTRING:              // 'struct string': is rare
    case FC_FP:                     // full pointer
    case FC_ENCAPSULATED_UNION:
    case FC_NON_ENCAPSULATED_UNION:
        ThrowNYI();
        break;

        /////////////////////////////////////////////////////////////////////
        //
        // Unimplemented stuff that remains to be evaluated
        //
        /////////////////////////////////////////////////////////////////////

    case FC_CSTRUCT:                // conformant struct
    case FC_CPSTRUCT:               // conformant struct with pointers
    case FC_CVSTRUCT:               // conformant varying struct
    case FC_CVARRAY:                // conformant varying array
    case FC_SMVARRAY:               
    case FC_LGVARRAY:
    case FC_BYTE_COUNT_POINTER:
    case FC_HARD_STRUCT:
    case FC_BLKHOLE:
    case FC_RANGE:
    default:
        ThrowNYI();
    }
}


void CallFrame::WalkConformantArrayPriv(BYTE* pMemory, PFORMAT_STRING pFormat)
  // Walk the body of a conformant array
{
    if (m_MaxCount > 0)
    {
        pFormat += 8;
        if (*pFormat == FC_PP)      // Is there a trailing pointer layout?
        {
            WalkEmbeddedPointers(pMemory, pFormat);
        }
    }
}


inline PFORMAT_STRING CallFrame::WalkEmbeddedRepeatPointers(BYTE* pMemory, PFORMAT_STRING pFormat)
  // Walks an array's embedded pointers
{
    ULONG_PTR repeatCount, repeatIncrement;
    //
    // Get the repeat count
    //
    switch (*pFormat)
    {
    case FC_FIXED_REPEAT:
        pFormat += 2;
        repeatCount = *(ushort*)pFormat;
        break;

    case FC_VARIABLE_REPEAT:
        repeatCount = m_MaxCount;           // ??? the last conformance calculation or something?
        //
        // Check if this variable repeat instance also has a variable offset (this would be the case for a conformant
        // varying array of pointers, or structures which contain pointers). If so then increment the format string
        // to point to the actual first array element which is being walked
        //
        if (pFormat[1] == FC_VARIABLE_OFFSET)
        {
            pMemory += *((ushort *)(&pFormat[2])) * m_Offset;       // REVIEW!
        } 
        else
        {
            ASSERT(pFormat[1] == FC_FIXED_OFFSET);
        }
        break;

    default:
        NOTREACHED();
        repeatCount = 0;
    }

    pFormat += 2;                           // increment to increment field
    repeatIncrement = *(ushort*)pFormat;    // get increment amount between successive pointers
    pFormat += sizeof(ushort);              // skip that 
    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from the current embedding structure
    // or array to the array whose pointers we're copying.
    //
    m_Memory += *((ushort *)pFormat);
    pFormat += sizeof(ushort);

    ULONG cPointersSave = *(ushort*)pFormat;// get number of pointers in each array element
    pFormat += sizeof(ushort);

    PFORMAT_STRING pFormatSave = pFormat;

    // Loop over the number of array elements
    //
    for( ; repeatCount--; pMemory += repeatIncrement, m_Memory += repeatIncrement )
    {
        pFormat = pFormatSave;
        ULONG cPointers = cPointersSave;
        //
        // Loop over the number of pointers per array element. Can be more than one for an array of structures
        //
        for ( ; cPointers--; )
        {
            PVOID* ppvFrom = (PVOID*) (pMemory + *((signed short *)(pFormat)));    // address of source pointer

            pFormat += sizeof(signed short) * 2;

            ASSERT(IsPointer(pFormat));     // Recurse to Walk the pointer

            WalkWorker((BYTE*)*(ppvFrom), pFormat);

            pFormat += 4;                   // increment to the next pointer description
        }
    }

    // return location of format string after the array's pointer description
    return pFormatSave + cPointersSave * 8;
}


void CallFrame::WalkEmbeddedPointers(BYTE* pMemory, PFORMAT_STRING pFormat)
  // Fix up the embedded pointers in a copied struct or array. pFormat is pointing to the pointer_layout<>
  // description of the struct or array; pbStruct is the copied structure / array which needs rectification.
  // See also NdrpEmbeddedPointerUnmarshal in unmrshlp.c.
{
    ULONG_PTR       MaxCountSave = m_MaxCount;
    ULONG_PTR       OffsetSave   = m_Offset;

    // From NDR:
    // "The Memory field in the stub message keeps track of the pointer to the current embedding structure or 
    // array.  This is needed to handle size/length pointers, so that we can get a pointer to the current 
    // embedding struct when computing conformance and variance."
    //
    BYTE* pMemoryOld = SetMemory(pMemory);

    ASSERT(*pFormat == FC_PP);
    pFormat += 2;   // Skip FC_PP and FC_PAD

    while (FC_END != *pFormat)
    {
        if (FC_NO_REPEAT == *pFormat)
        {
            PVOID* ppvFrom = (PVOID*) (pMemory + *((signed short *)(pFormat + 2)));    // address of source pointer
            
            pFormat += 6;                   // increment to the pointer description

            ASSERT(IsPointer(pFormat));     // Recurse to Walk the pointer
            WalkWorker((BYTE*)*(ppvFrom), pFormat);

            pFormat += 4;                   // increment ot the next pointer description
        }
        else
        {
            pFormat = WalkEmbeddedRepeatPointers(pMemory, pFormat);
        }
    }

    SetMemory(pMemoryOld);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

static BYTE ComputeConformanceIncrements[] = 
{ 
    4,              // Conformant array.
    4,              // Conformant varying array.
    0, 0,           // Fixed arrays - unused.
    0, 0,           // Varying arrays - unused.
    4,              // Complex array.

    2,              // Conformant char string. 
    2,              // Conformant byte string.
    4,              // Conformant stringable struct. 
    2,              // Conformant wide char string.

    0, 0, 0, 0,     // Non-conformant strings - unused.

    0,              // Encapsulated union - unused. 
    2,              // Non-encapsulated union.
    2,              // Byte count pointer.
    0, 0,           // Xmit/Rep as - unused.
    2               // Interface pointer.
};

// Review: There are places in callframes where the output of this
// method is cast to a pointer.
#ifndef _WIN64
ULONG CallFrame::ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat, BOOL fProbeSrc)
#else
ULONGLONG CallFrame::ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat, BOOL fProbeSrc)
#endif
  // This routine computes the conformant size for an array or the switch_is value for a union.
  // 
{
    void* pCount = NULL;
    //
    // Advance the format string to the size_is, switch_is, iid_is, or byte count description.
    //
    pFormat += ComputeConformanceIncrements[*pFormat - FC_CARRAY];
    //
    // First check if this is a 'callback'. A 'callback' requires that we call some compiled
    // code in order to compute the conformance. The compiled code expects a MIDL_STUB_MESSAGE
    // parameter with certain of its fields appropriately initialized
    //
    //      StackTop    - pointer to the top level structure relavant to the conformance computation
    //
    // The code then returns the computed result in the
    //
    //      MaxCount
    //      Offset
    //
    // field(s).
    //
    if (pFormat[1] == FC_CALLBACK)
    {
        // Index into expression callback routines table.
        ushort iexpr = *((ushort *)(pFormat + 2));
        
        ASSERT(GetStubDesc()->apfnExprEval != 0);
        ASSERT(GetStubDesc()->apfnExprEval[iexpr] != 0);
        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        MIDL_STUB_MESSAGE stubMsg; Zero(&stubMsg); stubMsg.StackTop = m_StackTop;
        
        if ((*pFormat & 0xf0) != FC_TOP_LEVEL_CONFORMANCE) 
        {
            if ((*pFormat & 0xf0) == FC_POINTER_CONFORMANCE)
            {
                pMemory = m_Memory;
            }
            stubMsg.StackTop = pMemory;
        }
        //
        // This call puts the result in stubMsg.MaxCount
        //
        // REVIEW: For security reasons we might have to disallow callbacks
        // in kernel mode. The reason is that the code we call can be touching arbitrary
        // chunks of user mode memory w/o doing the proper probing.
        //
        // HOWEVER: Given that this is READING the memory only, and given that we'll be
        // using the returned count in a protected probing manner anyway, maybe it's ok?
        //
        (GetStubDesc()->apfnExprEval[iexpr])(&stubMsg);
        
        m_MaxCount = stubMsg.MaxCount;
        m_Offset   = stubMsg.Offset;
        return m_MaxCount;
    }
    
    if ((*pFormat & 0xf0) == FC_NORMAL_CONFORMANCE)
    {
        // Get the address where the conformance variable is in the struct.
        pCount = pMemory + *((signed short *)(pFormat + 2));
        goto GetCount;
    }
    
    //
    // Get a pointer to the conformance describing variable.
    //
    if ((*pFormat & 0xf0) == FC_TOP_LEVEL_CONFORMANCE) 
    {
        // Top level conformance.  For /Os stubs, the stubs put the max
        // count in the stub message.  For /Oi stubs, we get the max count
        // via an offset from the stack top. We don't support /Os stubs here.
        //
        ASSERT(m_StackTop);
        pCount = m_StackTop + *((signed short *)(pFormat + 2));
        goto GetCount;
    }
    //
    // If we're computing the size of an embedded sized pointer then we
    // use the memory pointer in the stub message, which points to the 
    // beginning of the embedding structure.
    //
    if ((*pFormat & 0xf0) == FC_POINTER_CONFORMANCE)
    {
        pMemory = m_Memory;
        pCount = pMemory + *((signed short *)(pFormat + 2));
        goto GetCount;
    }
    //
    // Check for constant size/switch.
    //
    if ((*pFormat & 0xf0) == FC_CONSTANT_CONFORMANCE)
    {
        // The size/switch is contained in the lower three bytes of the 
        // long currently pointed to by pFormat.
        //
        ULONG count = (ULONG)pFormat[1] << 16;
        count |= (ULONG) *((ushort *)(pFormat + 2));
        m_MaxCount = count;
        return m_MaxCount;
    }
    
    //
    // Check for conformance of a multidimensional array element in a -Os stub.
    //
    if ((*pFormat & 0xf0) == FC_TOP_LEVEL_MULTID_CONFORMANCE)
    {
        // If pArrayInfo is non-null than we have a multi-D array.  If it is null then we have multi-leveled sized pointers.
        //
        if ( m_pArrayInfo ) 
        {
            m_MaxCount = m_pArrayInfo->MaxCountArray[m_pArrayInfo->Dimension];
        }
        else
        {
            ThrowNYI(); // probably not needed for fully interpreted stubs ?
            // long dimension = *((ushort *)(pFormat + 2));
            // pStubMsg->MaxCount = pStubMsg->SizePtrCountArray[dimension];
        }
        return m_MaxCount;
    }
    
GetCount:
    
    //
    // Must check now if there is a dereference op.
    //
    if (pFormat[1] == FC_DEREFERENCE)
    {
        pCount = *((PVOID*)pCount);
    }
    //
    // Now get the conformance count.
    //
    // BLOCK
    {
        long count = 0;
        switch (*pFormat & 0x0f)
        {
        case FC_ULONG :
        case FC_LONG :
            count = (long) *((long *)pCount);
            break;
            
        case FC_ENUM16:
        case FC_USHORT :
            count = (long) *((unsigned short *)pCount);
            break;
            
        case FC_SHORT :
            count = (long) *((short *)pCount);
            break;
            
        case FC_USMALL :
            count = (long) *((unsigned  *)pCount);
            break;
            
        case FC_SMALL :
            count = (long) *((signed char *)pCount);
            break;
            
        default :
            NOTREACHED();
            count = 0;
        } 
        
        //
        // Check the operator.
        //
        switch (pFormat[1])
        {
        case FC_DIV_2:      count /= 2; break;
        case FC_MULT_2:     count *= 2; break;
        case FC_SUB_1:      count -= 1; break;
        case FC_ADD_1:      count += 1; break;
        default :           /* OK */    break;
        }
        m_MaxCount = count;
    }
    
    return m_MaxCount;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

static BYTE ComputeVarianceIncrements[] = 
{ 
    8,      // Conformant varying array.
    0,      // Fixed arrays - unsed.
    0,      // Fixed arrays - unsed.
    8,      // Varying array.
    12,     // Varying array.
    8       // Complex array. 
};

void CallFrame::ComputeVariance(BYTE* pMemory, PFORMAT_STRING pFormat, ULONG* pOffset, ULONG* pActualCount, BOOL fProbeSrc)
{
    pFormat += ComputeVarianceIncrements[*pFormat - FC_CVARRAY];

    PVOID pLength = NULL;
    //
    // First check if this is a callback: if we have to run code to compute the variance
    //
    if (pFormat[1] == FC_CALLBACK)
    {
        // Index into expression callback routines table.
        ushort iexpr = *((ushort *)(pFormat + 2));

        ASSERT(GetStubDesc()->apfnExprEval != 0);
        ASSERT(GetStubDesc()->apfnExprEval[iexpr] != 0);
        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        MIDL_STUB_MESSAGE stubMsg; Zero(&stubMsg); stubMsg.StackTop = m_StackTop;
        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        if ((*pFormat & 0xf0) != FC_TOP_LEVEL_CONFORMANCE) 
        {
            if ((*pFormat & 0xf0) == FC_POINTER_CONFORMANCE)
            {
                pMemory = m_Memory;
            }
            stubMsg.StackTop = pMemory;
        }
        //
        // This puts the computed offset in pStubMsg->Offset and the length in pStubMsg->MaxCount.
        //
        (GetStubDesc()->apfnExprEval[iexpr])(&stubMsg);
        //
        *pOffset      = stubMsg.Offset;
        *pActualCount = (ULONG)stubMsg.MaxCount;
        return;
    }

    else if ((*pFormat & 0xf0) == FC_NORMAL_VARIANCE)
    {
        // Get the address where the variance variable is in the struct.
        //
        pLength = pMemory + *((signed short *)(pFormat + 2));
        goto GetCount;
    }
    //
    // Get a pointer to the variance variable.
    //
    else if ((*pFormat & 0xf0) == FC_TOP_LEVEL_VARIANCE)
    {
        // Top level variance. For /Oi stubs, we get the 
        // actual count via an offset from the stack top.  The first_is must
        // be zero if we get here.
        //
        ASSERT(m_StackTop);
        pLength = m_StackTop + *((signed short *)(pFormat + 2));
        goto GetCount;
    }
    //
    // If we're computing the length of an embedded size/length pointer then we
    // use the memory pointer in the stub message, which points to the 
    // beginning of the embedding structure.
    //
    else if ((*pFormat & 0xf0) == FC_POINTER_VARIANCE)
    {
        pMemory = m_Memory;
        pLength = pMemory + *((signed short *)(pFormat + 2));
        goto GetCount;
    }
    //
    // Check for constant length.
    //
    else if ((*pFormat & 0xf0) == FC_CONSTANT_VARIANCE)
    {
        // The length is contained in the lower three bytes of the 
        // long currently pointed to by pFormat.
        //
        LONG length  = (ULONG)pFormat[1] << 16;
        length |= (ULONG) *((ushort *)(pFormat + 2));
        *pOffset      = 0;
        *pActualCount = length;
        return;
    }

    //
    // Check for variance of a multidimensional array element
    //
    else if ((*pFormat & 0xf0) == FC_TOP_LEVEL_MULTID_CONFORMANCE)
    {
        // If pArrayInfo is non-null than we have a multi-D array.  If it
        // is null then we have multi-leveled sized pointers.
        //
        if (m_pArrayInfo)
        {
            *pOffset      =  m_pArrayInfo->OffsetArray[m_pArrayInfo->Dimension];
            *pActualCount =  m_pArrayInfo->ActualCountArray[m_pArrayInfo->Dimension];
        }
        else
        {
            ThrowNYI();
            long Dimension = *((ushort *)(pFormat + 2));
        }

        return;
    }

GetCount:
    //
    LONG length;
    //
    // Must check now if there is a dereference op.
    //
    if (pFormat[1] == FC_DEREFERENCE)
    {
        pLength = *((PVOID*)pLength);
    }
    //
    // Now get the variance length
    //
    switch (*pFormat & 0x0f)
    {
    case FC_ULONG:
    case FC_LONG:
        length = (long) *((long*)pLength);
        break;

    case FC_USHORT:
        length = (long) *((ushort *)pLength);
        break;

    case FC_SHORT :
        length = (long) *((short *)pLength);
        break;

    case FC_USMALL :
        length = (long) *((uchar *)pLength);
        break;

    case FC_SMALL :
        length = (long) *((char *)pLength);
        break;

    default :
        NOTREACHED();
        length = 0;
    } 
    //
    // Check the operator.
    //
    switch (pFormat[1])
    {
    case FC_DIV_2:      length /= 2; break;
    case FC_MULT_2:     length *= 2; break;
    case FC_SUB_1:      length -= 1; break;
    case FC_ADD_1:      length += 1; break;
    default :           /* ok */     break;
    }

    *pOffset      = 0;
    *pActualCount = length;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

BYTE* CallFrame::MemoryIncrement(PBYTE pMemory, PFORMAT_STRING pFormat, BOOL fCheckFrom)
/* Returns a memory pointer incremeted past a complex data type.  This routine
   is also overloaded to compute the size of a complex data type by passing
   a NULL memory pointer.

   Return value: A memory pointer incremented past the complex type.  If a NULL pMemory
   was passed in then the returned value is the size of the complex type.
*/
{
    long Elements;
    long ElementSize;

    switch (*pFormat)
    {
        // Structs
        //
    case FC_STRUCT :
    case FC_PSTRUCT :
    case FC_HARD_STRUCT :
        pMemory += *((ushort *)(pFormat + 2));
        break;

    case FC_CSTRUCT :
    case FC_CVSTRUCT :
        pMemory += *((ushort *)(pFormat + 2));
        
        // Get conformant array or string description.
        pFormat += 4;
        pFormat += *((signed short *)pFormat);

        // Get the memory pointer past the conformant array.
        pMemory = MemoryIncrement(pMemory, pFormat, fCheckFrom);
        break;

    case FC_BOGUS_STRUCT :
        pMemory += *((ushort *)(pFormat + 2));
            
        pFormat += 4;

        // Check for a conformant array or string in the struct.
        if ( *((signed short *)pFormat) )
        {
            pFormat += *((signed short *)pFormat);

            // Get the memory pointer past the conformant array.
            pMemory = MemoryIncrement(pMemory, pFormat, fCheckFrom);
        }
        break;

        // Unions
        //
    case FC_ENCAPSULATED_UNION :
        pMemory += HIGH_NIBBLE(pFormat[1]);
        pMemory += *((ushort *)(pFormat + 2));
        break;

    case FC_NON_ENCAPSULATED_UNION :
        // Go to the size/arm description.
        pFormat += 6;
        pFormat += *((signed short *)pFormat);
        
        pMemory += *((ushort *)pFormat);
        break;

        // Arrays
        //
    case FC_SMFARRAY :
    case FC_SMVARRAY :
        pMemory += *((ushort *)(pFormat + 2));
        break;

    case FC_LGFARRAY :
    case FC_LGVARRAY :
        pMemory += *((ulong UNALIGNED *)(pFormat + 2));
        break;

    case FC_CARRAY:
    case FC_CVARRAY:
        pMemory += *((ushort *)(pFormat + 2)) * ComputeConformance(pMemory, pFormat, fCheckFrom);
        break;

    case FC_BOGUS_ARRAY :
    {
        ULONG cElements;

        if (*((long UNALIGNED *)(pFormat + 4)) == 0xffffffff)
        {
            cElements = *((ushort *)(pFormat + 2));
        }
        else
        {
            if (m_pArrayInfo && m_pArrayInfo->MaxCountArray && (m_pArrayInfo->MaxCountArray == m_pArrayInfo->BufferConformanceMark))
            {
                cElements = m_pArrayInfo->MaxCountArray[m_pArrayInfo->Dimension];
            }
            else
            {
                cElements = (ULONG)ComputeConformance(pMemory, pFormat, fCheckFrom);
            }
        }

        // Go to the array element's description.
        pFormat += 12;
        CORRELATION_DESC_INCREMENT( pFormat );
        CORRELATION_DESC_INCREMENT( pFormat );

        // 
        // Get the size of one element.
        //
        ULONG cbElementSize;
        switch (*pFormat)
        {
        case FC_ENUM16 :    cbElementSize = sizeof(int);    break;

        case FC_RP :
        case FC_UP :
        case FC_FP :
        case FC_OP :        cbElementSize = sizeof(void*);  break;

        case FC_EMBEDDED_COMPLEX :
        {
            // It's some complicated thingy.
            //
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            if ((*pFormat == FC_TRANSMIT_AS) || (*pFormat == FC_REPRESENT_AS) || (*pFormat == FC_USER_MARSHAL))
            {
                cbElementSize = *((ushort *)(pFormat + 4)); // Get the presented type size.
            }
            else
            {
                if (m_pArrayInfo) m_pArrayInfo->Dimension++;
                cbElementSize = (ULONG)(MemoryIncrement(pMemory, pFormat, fCheckFrom) - pMemory);
                if (m_pArrayInfo) m_pArrayInfo->Dimension--;
            }
        }
        break;

        default:
        {
            if (IS_SIMPLE_TYPE(*pFormat))
            {
                cbElementSize = SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;
            }
            NOTREACHED();
            return 0;
        }
        }

        pMemory += cElements * cbElementSize; 
    }
    break;

    //
    // String arrays (a.k.a. non-conformant strings).
    //
    case FC_CSTRING :
    case FC_BSTRING :
    case FC_WSTRING :
        pMemory += *((ushort *)(pFormat + 2))   *  ((*pFormat == FC_WSTRING) ? sizeof(wchar_t) : sizeof(char));
        break;

    case FC_SSTRING :
        pMemory += pFormat[1] * *((ushort *)(pFormat + 2));
        break;

        //
        // Sized conformant strings.
        //
    case FC_C_CSTRING:
    case FC_C_BSTRING:
    case FC_C_WSTRING:
    {
        ULONG cElements;
        if (pFormat[1] == FC_STRING_SIZED)
        {
            if (m_pArrayInfo && m_pArrayInfo->MaxCountArray &&(m_pArrayInfo->MaxCountArray == m_pArrayInfo->BufferConformanceMark))
            {
                cElements = m_pArrayInfo->MaxCountArray[m_pArrayInfo->Dimension];
            }
            else
            {
                cElements = (ULONG)ComputeConformance(pMemory, pFormat, fCheckFrom);
            }
            pMemory += cElements * ( (*pFormat == FC_C_WSTRING) ? sizeof(wchar_t) : sizeof(char) );
        }
        else
        {
            // An unsized string; that is, a NULL-terminated string. We shouldn't be calling 
            // MemoryIncrement on these!
            //
            NOTREACHED();
            pMemory += sizeof(PVOID);
        }
    }
    break;

    case FC_C_SSTRING:
    {
        ULONG cElements;
        if (m_pArrayInfo && m_pArrayInfo->MaxCountArray && (m_pArrayInfo->MaxCountArray == m_pArrayInfo->BufferConformanceMark))
        {
            cElements = m_pArrayInfo->MaxCountArray[m_pArrayInfo->Dimension];
        }
        else
        {
            cElements = (ULONG)ComputeConformance(pMemory, pFormat, fCheckFrom);
        }
        pMemory += cElements * pFormat[1];
    }
    break;


    case FC_TRANSMIT_AS :
    case FC_REPRESENT_AS :
    case FC_USER_MARSHAL :
        pMemory += *((ushort *)(pFormat + 4));  // Get the presented type size.
        break;

    case FC_BYTE_COUNT_POINTER:
        //
        // ???? REVIEW ????
        //
        // Should only hit this case when called from NdrSrvOutInit(). In this case it's the 
        // total byte count allocation size we're looking for.
        //
        pMemory += ComputeConformance(pMemory, pFormat, fCheckFrom);
        break;

    case FC_IP :
        pMemory += sizeof(void *);
        break;

    default:
        NOTREACHED();
        return 0;
    }

    return pMemory;
}

BOOL CallFrame::IsSafeArray(PFORMAT_STRING pFormat) const
{
    ASSERT(pFormat[0] == FC_USER_MARSHAL);

    USHORT iquad = *(USHORT *)(pFormat + 2);
    const USER_MARSHAL_ROUTINE_QUADRUPLE* rgQuad = GetStubDesc()->aUserMarshalQuadruple;

    return (g_oa.IsSAFEARRAY(rgQuad[iquad]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\callframeinternal.c ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrameInternal.c
//
// Make sure that the global variable names used in dlldata.c
// don't conflict with those in other places. 
//
#define aProxyFileList          CallFrameInternal_aProxyFileList
#define gPFactory               CallFrameInternal_gPFactory
#define GetProxyDllInfo         CallFrameInternal_GetProxyDllInfo
#define hProxyDll               CallFrameInternal_hProxyDll
#define _purecall               CallFrameInternal__purecall
#define CStdStubBuffer_Release  CallFrameInternal_CStdStubBuffer_Release
#define CStdStubBuffer2_Release CallFrameInternal_CStdStubBuffer2_Release
#define UserMarshalRoutines     CallFrameInternal_UserMarshalRoutines
#define Object_StubDesc         CallFrameInternal_Object_StubDesc

#define __MIDL_ProcFormatString CallFrameInternal___MIDL_ProcFormatString
#define __MIDL_TypeFormatString CallFrameInternal___MIDL_TypeFormatString

#include "callframeimpl_i.c"

//////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

#define IRpcStubBufferVtbl_DEFINED

#include "callframeinternal_p.c"

#pragma data_seg(".data") 

#include "callframeinternal_dlldata.c" 

// The only thing we need is IID_IDispatch_In_Memory, so here it is.
const IID IID_IDispatch_In_Memory = {0x83FB5D85,0x2339,0x11d2,{0xB8,0x9D,0x00,0xC0,0x4F,0xB9,0x61,0x8A}};


#include <debnot.h>

//+-------------------------------------------------------------------------
//
//  Function:   IDispatch_Invoke_Proxy
//
//  Synopsis:   Thunk.  We need this in order to be able to link the MIDL-
//              generated proxy/stub stuff, but we never ever ever want
//              to call this.
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDispatch_Invoke_Proxy(
    IDispatch * This, DISPID dispIdMember, REFIID riid, LCID lcid,
    WORD wFlags, DISPPARAMS *pDispParams,
    VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
  Win4Assert(!"HEY!  DON'T CALL THIS EVER!");
  return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Function:   IDispatch_Invoke_Stub
//
//  Synopsis:   See description for IDispatch_Invoke_Proxy
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IDispatch_Invoke_Stub(
    IDispatch * This, DISPID dispIdMember,
    REFIID riid, LCID lcid, DWORD dwFlags, DISPPARAMS * pDispParams,
    VARIANT * pVarResult, EXCEPINFO * pExcepInfo, UINT * puArgErr,
    UINT cVarRef, UINT * rgVarRefIdx, VARIANTARG * rgVarRef)
{
  Win4Assert(!"HEY!  DON'T CALL THIS EVER!");
  return E_NOTIMPL;  
}



//////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\cleginterface.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
   Microsoft COM Plus (Microsoft Confidential)

   @doc
   @module CLegInterface.Cpp : Implementaion of classes for supporting interceptor
   for legacy interfaces: IDispatch, etc
 
   Description:<nl>
 
-------------------------------------------------------------------------------
Revision History:

@rev 0     | 04/30/98 | Gaganc  | Created
@rev 1     | 07/17/98 | BobAtk  | Rewrote & finished
---------------------------------------------------------------------------- */

#include "stdpch.h"
#include "common.h"
#include "ndrclassic.h"
#include "typeinfo.h"
#include "tiutil.h"
#include "CLegInterface.H"

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//
// LEGACY_FRAME
//
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

HRESULT LEGACY_FRAME::GetInfo(CALLFRAMEINFO *pInfo) 
{ 
    return m_pInterceptor->GetMethodInfo(m_iMethod, pInfo, NULL);
}

HRESULT DISPATCH_FRAME::GetIIDAndMethod(IID* piid, ULONG* piMethod) 
{ 
    if (piid)
    {
        if (m_pInterceptor->m_pmdMostDerived)
        {
            *piid = *m_pInterceptor->m_pmdMostDerived->m_pHeader->piid;
        }
        else
        {
            *piid = __uuidof(IDispatch);
        }
    }
               
    if (piMethod)   *piMethod = m_iMethod;
    return S_OK;
}


HRESULT LEGACY_FRAME::GetRemoteFrame()
// Get ourselves an engine for the wire-version of our interface
{
    HRESULT hr = S_OK;
    if (NULL == m_premoteFrame)
    {
        hr = m_pInterceptor->GetRemoteFrameFor(&m_premoteFrame, this);
        if (m_premoteFrame)
        {
            // All is well
        }
        else if (!hr)
            hr = E_OUTOFMEMORY;
    }
    return hr;
}
    
HRESULT LEGACY_FRAME::GetMemoryFrame()
// Get ourselves an engine for the in-memory-version of our interface
{
    HRESULT hr = S_OK;
    if (NULL == m_pmemoryFrame)
    {
        hr = m_pInterceptor->GetMemoryFrameFor(&m_pmemoryFrame, this);
        if (m_pmemoryFrame)
        {
            // All is well
        }
        else if (!hr)
            hr = E_OUTOFMEMORY;
    }
    return hr;
}
    

////////////////////////////////////////////////////////////////////////////////////////
//
// DISPATCH_FRAME
//

HRESULT DISPATCH_CLIENT_FRAME::ProxyPreCheck()
// Prepare our additional parameters needed to do the [call_as]-based remote call.
// Yucko-ramma, but we have to mimic what OleAut32 actually does. See also InvokeProxyPreCheck.
{
    HRESULT hr = S_OK;

    if (!m_fDoneProxyPrecheck)
    {
        m_dispParams.rgvarg       = &m_aVarArg[0];

        Zero(&m_remoteFrame);
        m_remoteFrame.rgVarRefIdx = &m_aVarRefIdx[0];
        m_remoteFrame.rgVarRef    = &m_aVarRef[0];
        m_remoteFrame.pDispParams = &m_dispParams;

        FRAME_Invoke* pframe = (FRAME_Invoke*)m_pvArgs;

        if (pframe->pDispParams == NULL || pframe->pDispParams->cNamedArgs > pframe->pDispParams->cArgs)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            m_remoteFrame.dwFlags    = pframe->wFlags;
            m_remoteFrame.dwFlags   &= (DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF);

            // Copy DISPPARAMS from stack.  Must reset rgvarg to point to our array
            // or we overwrite the one on the stack.
            m_dispParams = *pframe->pDispParams;
            m_dispParams.rgvarg = &m_aVarArg[0];

            m_remoteFrame.pVarResult =  pframe->pVarResult;
            m_remoteFrame.pExcepInfo =  pframe->pExcepInfo;
            m_remoteFrame.puArgErr   =  pframe->puArgErr;


            const UINT cArgs = pframe->pDispParams->cArgs;

            if (cArgs != 0 && pframe->pDispParams->rgvarg == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (pframe->pDispParams->cNamedArgs != 0 && pframe->pDispParams->rgdispidNamedArgs == NULL)
            {
                hr = E_INVALIDARG;
            }
            else if (pframe->pDispParams->cNamedArgs > cArgs)
            {
                hr = E_INVALIDARG;
            }
            else if (cArgs == 0) 
            {
                if (m_remoteFrame.dwFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
                {
                    hr = E_INVALIDARG;
                }
            }

            if (!hr)
            {
                if (m_remoteFrame.dwFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)) 
                {
                    m_remoteFrame.pVarResult = NULL;    // ignore VARIANT result parameter
                }

                // count how many [in,out] parameters we have
                //
                for (UINT i = 0; i < cArgs; i++) 
                {
                    VARIANT* pvar = &pframe->pDispParams->rgvarg[i];
                    if ((V_VT(pvar) & VT_BYREF) != 0) 
                    {
                        m_remoteFrame.cVarRef++;
                    }
                }

                // Make sure we have enough space for the out array that holds pointers to VARIANT
                //
                if (cArgs > PREALLOCATE_PARAMS) 
                {
                    UINT cbBufSize = (cArgs * sizeof(VARIANT)) + (m_remoteFrame.cVarRef * (sizeof(UINT) + sizeof(VARIANT)));
                    
                    m_pBuffer = (BYTE*)CoTaskMemAlloc(cbBufSize);
                    if (m_pBuffer)
                    {
                        m_dispParams.rgvarg       = (VARIANT*) m_pBuffer;
                        m_remoteFrame.rgVarRef    = (VARIANT*) (m_dispParams.rgvarg + cArgs);
                        m_remoteFrame.rgVarRefIdx = (UINT*)    (m_remoteFrame.rgVarRef + m_remoteFrame.cVarRef);
                    }
                    else
                        hr = E_OUTOFMEMORY;
                }

                if (!hr)
                {
                    // Initialize the derived arguments
                    //
                    VARIANT* rgVarRef    = m_remoteFrame.rgVarRef;
                    UINT*    rgVarRefIdx = m_remoteFrame.rgVarRefIdx;

                    for (i = 0; i < cArgs; i++) 
                    {
                        VARIANT* pvarFrom = &pframe->pDispParams->rgvarg[i];
                        VARIANT* pvarTo   = &m_dispParams.rgvarg[i];

                        if ((V_VT(pvarFrom) & VT_BYREF) != 0) 
                        {
                            // Marshalling as [in,out]
                            //
                            *rgVarRef++     = *pvarFrom;
                            *rgVarRefIdx++  = i;
                            V_VT(pvarTo)    = VT_EMPTY;
                        }
                        else
                        {
                            // Marshalling as [in] only
                            //
                            *pvarTo = *pvarFrom;
                        }
                    }
                    //
                    // Make sure that optional parameters are always non-NULL in order to satisfy MIDL,
                    // where they can't be declared [out, unique] like we'd like them to be
                    //
                    if (NULL == m_remoteFrame.pVarResult)
                    {
                        m_remoteFrame.pVarResult = &m_varResult;
                        m_remoteFrame.dwFlags   |= MARSHAL_INVOKE_fakeVarResult;
                    }
                    
                    if (NULL == m_remoteFrame.pExcepInfo)
                    {
                        m_remoteFrame.pExcepInfo = &m_excepInfo;
                        m_remoteFrame.dwFlags   |= MARSHAL_INVOKE_fakeExcepInfo;
                    }
                    
                    if (NULL == m_remoteFrame.puArgErr)
                    {
                        m_remoteFrame.puArgErr   = &m_uArgErr;
                        m_remoteFrame.dwFlags   |= MARSHAL_INVOKE_fakeArgErr;
                    }
                    //
                    // Finish filling out our remote frame
                    //
                    m_remoteFrame.dispIdMember  = pframe->dispIdMember;
                    m_remoteFrame.piid          = pframe->piid;
                    m_remoteFrame.lcid          = pframe->lcid;
                }
            }
        }
    }

    if (!hr)
    {
        m_fDoneProxyPrecheck = TRUE;
    }
        
    return hr;
}

////////////////////////////

HRESULT DISPATCH_SERVER_FRAME::StubPreCheck()
// As in InvokeStubPreCheck(), prepare newly-unmarshalled remote in-arguments for execution
// on the actual server object. Yucko-rama.
//
// This must be done before we get an actual in-memory frame
//
{
    HRESULT hr = S_OK;

    if (!m_fDoneStubPrecheck)
    {
        m_fDoneStubPrecheck = TRUE;
        Zero(&m_memoryFrame);

        FRAME_RemoteInvoke* premoteFrame = (FRAME_RemoteInvoke*)m_pvArgs;

        const UINT cArgs = premoteFrame->pDispParams->cArgs;

        if (cArgs == 0)
        {
            premoteFrame->pDispParams->cNamedArgs = 0;
        }
        else
        {
            if (premoteFrame->pDispParams->rgvarg == NULL || (premoteFrame->pDispParams->cNamedArgs != 0 && premoteFrame->pDispParams->rgdispidNamedArgs == NULL))
                return E_INVALIDARG;

            // Restore what should be in the pDispParams->rgvarg array
            //
            for (UINT i = 0; i < premoteFrame->cVarRef; i++)                  
            {
                UINT iRef = premoteFrame->rgVarRefIdx[i];
                if (iRef >= cArgs)
                    return E_INVALIDARG;

                premoteFrame->pDispParams->rgvarg[iRef] = premoteFrame->rgVarRef[i];
            }
        }
        //
        // Initialize our local copy of the actual in-memory frame from the remote frame that we're given
        //
        m_memoryFrame.CopyFrom(*premoteFrame);
        //
        // NULL the parameters that were in-fact given as NULL way back on the client side
        //
        const DWORD dwFlags = premoteFrame->dwFlags;
        if ((dwFlags & MARSHAL_INVOKE_fakeVarResult) != 0)
        {
            m_memoryFrame.pVarResult = NULL;    // was NULL in the first place, so set it back
        }

        if ((dwFlags & MARSHAL_INVOKE_fakeExcepInfo) != 0)
        {
            m_memoryFrame.pExcepInfo = NULL;    // was NULL in the first place, so set it back
        }
        else
        {
            (m_memoryFrame.pExcepInfo)->pfnDeferredFillIn = NULL;
        }

        if ((dwFlags & MARSHAL_INVOKE_fakeArgErr) != 0)
        {
            m_memoryFrame.puArgErr = NULL;      // was NULL in the first place, so set it back
        }
    }

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::StubPostCheck()
// See also InvokeStubPostCheck().
//
// This must be done before we can marshal our out parameters
//
{
    HRESULT hr = S_OK;

    if (!m_fDoneStubPostcheck)
    {
        m_fDoneStubPostcheck = TRUE;
        //
        if (m_hrReturnValue == DISP_E_EXCEPTION) 
        {
            if (m_memoryFrame.pExcepInfo != NULL && m_memoryFrame.pExcepInfo->pfnDeferredFillIn != NULL) 
            {
                // since we are going to cross address space, fill in ExcepInfo now
                //
                (*m_memoryFrame.pExcepInfo->pfnDeferredFillIn)(m_memoryFrame.pExcepInfo);
                m_memoryFrame.pExcepInfo->pfnDeferredFillIn = NULL;
            }
        }
        //
        ASSERT(m_premoteFrame);
        PVOID pvArgsRemote = m_premoteFrame->GetStackLocation();

        FRAME_RemoteInvoke* premoteFrame = (FRAME_RemoteInvoke*)pvArgsRemote;
        for (UINT i=0; i<premoteFrame->cVarRef; i++)
        {
            V_VT(& premoteFrame->pDispParams->rgvarg[premoteFrame->rgVarRefIdx[i]]) = VT_EMPTY;
        }
    }

    return hr;
}

HRESULT DISPATCH_FRAME::GetParamInfo(IN ULONG iparam, OUT CALLFRAMEPARAMINFO* pInfo)
{
    HRESULT hr = S_OK;

    hr = GetMemoryFrame();
    if (!hr)
    {
        m_pmemoryFrame->GetParamInfo(iparam, pInfo);
    }

    return hr;
}

HRESULT DISPATCH_FRAME::GetParam(ULONG iparam, VARIANT* pvar)
{
    VariantClear(pvar);
    return E_NOTIMPL;
}
HRESULT DISPATCH_FRAME::SetParam(ULONG iparam, VARIANT* pvar)
{
    return E_NOTIMPL;
}


///////////////////////////////

HRESULT DISPATCH_CLIENT_FRAME::GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pctx, MSHLFLAGS mshlflags, ULONG *pcbBufferNeeded)
{ 
    HRESULT hr = S_OK;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        // These three methods are completely declarative in the OICF strings. So we can just use
        // the underlying declarative callframe engine.
        //
        hr = GetRemoteFrame();
        if (!hr) hr = m_premoteFrame->GetMarshalSizeMax(pctx, mshlflags, pcbBufferNeeded);
    }
    break;

    case IMETHOD_Invoke:
    {
        // Invoke, however, uses a [call_as] attribution, so it's a little trickier.
        //
        hr = GetRemoteFrame();
        if (!hr)
        {
            if (pctx->fIn)
            {
                // Marshal the in-parameters
                //
                hr = ProxyPreCheck();
                if (!hr)
                {
                    // Set the stack location for the oicf frame. It needs to be a fn that has the signature
                    // of IDispatch::RemoteInvoke, excepting the receiver. We don't bother to restore the 
                    // previous setting, on the theory that it'll always get re-set appropriately whenever
                    // it's needed, since you have to cons up a IDispatch::RemoteInvoke frame to do so.
                    //
                    m_premoteFrame->SetStackLocation(&m_remoteFrame);
                    //
                    // Having got a frame and a CallFrame that have the remote signature, re-issue the sizing request.
                    //
                    hr = m_premoteFrame->GetMarshalSizeMax(pctx, mshlflags, pcbBufferNeeded);
                }
            }
            else
            {
                // Marshal the out-parameters. 
                //
                // This is quite rare: (re)marshalling the out-parameters on the client side of a call.
                //
                NYI(); hr = E_NOTIMPL;
            }
        }
    }
    break;

    default:
        NOTREACHED();
        *pcbBufferNeeded = 0;
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pctx, MSHLFLAGS mshlflags, ULONG *pcbBufferNeeded)
{ 
    HRESULT hr = S_OK;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        hr = GetRemoteFrame();
        if (!hr) hr = m_premoteFrame->GetMarshalSizeMax(pctx, mshlflags, pcbBufferNeeded);
    }
    break;

    case IMETHOD_Invoke:
    {
        // Invoke, however, uses a [call_as] attribution, so it's a little trickier.
        //
        hr = GetRemoteFrame();
        if (!hr)
        {
            if (pctx->fIn)
            {
                // Marshal the in-parameters. 
                //
                // This is quite rare: (re)marshalling the in-parameters on the server side of a remote call.
                //
                NYI(); hr = E_NOTIMPL;
            }
            else
            {
                // Marshal the out-parameters
                //
                hr = StubPostCheck();
                if (!hr)
                {
                    // Having got a frame and a CallFrame that have the remote signature, re-issue the sizing request.
                    //
                    hr = m_premoteFrame->GetMarshalSizeMax(pctx, mshlflags, pcbBufferNeeded);
                }
            }
        }
    }
    break;

    default:
        NOTREACHED();
        *pcbBufferNeeded = 0;
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}

/////////////////////////////////

HRESULT DISPATCH_CLIENT_FRAME::Marshal(CALLFRAME_MARSHALCONTEXT *pctx, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
                                       ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags) 
{ 
    HRESULT hr = S_OK;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        hr = GetRemoteFrame();
        if (!hr)
        {
            hr = m_premoteFrame->Marshal(pctx, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
        }
    }
    break;

    case IMETHOD_Invoke:
    {
        // Tricky because we have to deal correctly with the transformations performed by
        // IDispatch_Invoke_Proxy: remember that there's a [call_as] on IDispatch::Invoke.
        //
        hr = GetRemoteFrame();
        if (!hr)
        {
            if (pctx->fIn)
            {
                // Marshal the in-parameters
                //
                hr = ProxyPreCheck();
                if (!hr)
                {
                    // Set the stack location for the oicf frame. It needs to be a fn that has the signature
                    // of IDispatch::RemoteInvoke, excepting the receiver. We don't bother to restore the 
                    // previous setting, on the theory that it'll always get re-set appropriately whenever
                    // it's needed, since you have to cons up a IDispatch::RemoteInvoke frame to do so.
                    //
                    m_premoteFrame->SetStackLocation(&m_remoteFrame);
                    //
                    // Having got a frame and a CallFrame that have the remote signature, re-issue the marshalling request.
                    //
                    hr = m_premoteFrame->Marshal(pctx, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
                }
            }
            else
            {
                // Marshal the out-parameters. 
                //
                // This is quite rare: (re)marshalling the out-parameters on the client side of a call.
                //
                NYI(); hr = E_NOTIMPL;
            }
        }
    }
    break;

    default:
        NOTREACHED();
        *pcbBufferUsed = 0;
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::Marshal(CALLFRAME_MARSHALCONTEXT *pctx, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
                                       ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags) 
{
    HRESULT hr = S_OK;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        // These three methods are completely declarative in the OICF strings. So we can just use
        // the underlying declarative callframe engine.
        //
        hr = GetRemoteFrame();
        if (!hr)
        {
            m_premoteFrame->SetReturnValue((HRESULT)m_hrReturnValue);
            hr = m_premoteFrame->Marshal(pctx, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
        }
    }
    break;

    case IMETHOD_Invoke:
    {
        // Invoke, however, uses a [call_as] attribution, so it's a little trickier.
        //
        hr = GetRemoteFrame();
        if (!hr)
        {
            if (pctx->fIn)
            {
                // Marshal the in-parameters. 
                //
                // This is quite rare: (re)marshalling the in-parameters on the server side of a remote call.
                // REVIEW: Probably should make it work, though.
                //
                NYI(); hr = E_NOTIMPL;
            }
            else
            {
                // Marshal the out-parameters
                //
                hr = StubPostCheck();
                if (!hr)
                {
                    // Having got a frame and a CallFrame that have the remote signature, re-issue the request.
                    //
                    m_premoteFrame->SetReturnValue((HRESULT)m_hrReturnValue);
                    hr = m_premoteFrame->Marshal(pctx, mshlflags, pBuffer, cbBuffer, pcbBufferUsed, pdataRep, prpcFlags);
                }
            }
        }
    }
    break;

    default:
        NOTREACHED();
        *pcbBufferUsed = 0;
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}


///////////////////////////////

HRESULT DISPATCH_CLIENT_FRAME::Unmarshal(PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx, ULONG* pcbUnmarhalled)
// Unmarshal out-parameters back into this call frame
{ 
    HRESULT hr = S_OK;

    m_hrReturnValue = RPC_E_CLIENT_CANTUNMARSHAL_DATA;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        hr = GetRemoteFrame();
        if (!hr)
        {
            hr = m_premoteFrame->Unmarshal(pBuffer, cbBuffer, dataRep, pctx, pcbUnmarhalled);
            if (!hr)
            {
                m_hrReturnValue = m_premoteFrame->GetReturnValue();
            }
        }
    }
    break;

    case IMETHOD_Invoke:
    {
        hr = GetRemoteFrame();
        if (!hr)
        {
            m_premoteFrame->SetStackLocation(&m_remoteFrame);
            hr = m_premoteFrame->Unmarshal(pBuffer, cbBuffer, dataRep, pctx, pcbUnmarhalled);
            if (!hr)
            {
                m_hrReturnValue = m_premoteFrame->GetReturnValue();
            }
        }
    }
    break;

    default:
        NOTREACHED();
        *pcbUnmarhalled = 0;
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::Unmarshal(PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx, ULONG* pcbUnmarhalled)
//
// Very rarely needed, if ever.
//
{
    HRESULT hr = S_OK;
    NYI(); hr = E_NOTIMPL;
    return hr;
}

//////////////////////////////////
    
HRESULT DISPATCH_CLIENT_FRAME::ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx) 
{ 
    HRESULT hr = S_OK;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    case IMETHOD_GetTypeInfo:
    case IMETHOD_GetIDsOfNames:
    {
        hr = GetRemoteFrame();
        if (!hr)
        {
            hr = m_premoteFrame->ReleaseMarshalData(pBuffer, cbBuffer, ibFirstRelease, dataRep, pctx);
        }
    }
    break;

    case IMETHOD_Invoke:
    {
        NYI(); hr = E_NOTIMPL;
    }
    break;

    default:
        NOTREACHED();
        hr = RPC_E_INVALIDMETHOD;
    };

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx) 
{
    HRESULT hr = S_OK;
    NYI(); hr = E_NOTIMPL;
    return hr;
}

////////////////////////////////////

inline void DISPATCH_CLIENT_FRAME::InitializeInvoke()
{
    FRAME_Invoke* pframe = (FRAME_Invoke*) m_pvArgs;
    //
    // Initialize the [out, unique] parameters if needed. In our hacked IDispatch_In_Memory, they're 
    // declared as [in,out,unique]. But if non-NULL, caller will NOT have initialized them, since he
    // thinks they're [out]-only. Thus, we must initialize things for him now.
    //
    // Sure wish MIDL would just support [out, unique] by themselves in this manner.
    //
    if (!m_fAfterCall && m_iMethod == IMETHOD_Invoke)
    {
        if (pframe->pVarResult) { V_VT(pframe->pVarResult) = VT_EMPTY; }
        if (pframe->pExcepInfo) { Zero(pframe->pExcepInfo);            }
        if (pframe->puArgErr)
        {
            // just a UINT; leave as junk
        }
    }
}

#if _MSC_VER >= 1200
#pragma warning (push)
#pragma warning (disable : 4509)
#endif


HRESULT GetFieldCount(IRecordInfo *, ULONG *);          // Defined in oautil.cpp
HRESULT SafeArrayDestroyDescriptor(SAFEARRAY *);        // Defined in oautil.cpp

HRESULT DISPATCH_CLIENT_FRAME::Free(ICallFrame* pframeArgsTo, ICallFrameWalker* pWalkerFreeDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags) 
{ 
    HRESULT hr = S_OK;

    InitializeInvoke();    
    //
    // Ask our memory frame to do the actual work on the stack.
    //
    hr = GetMemoryFrame();
    if (!hr)
    {
        if (m_iMethod == IMETHOD_Invoke)
        {
            __try
            {
                // Invoke has the quirk that pDispParams is an [in] datum with [in,out] members, which
                // you can't express correctly in MIDL (sigh). So we have to fool the NDR engine here
                // into not freeing that which it really isn't supposed to. We also have to be particularly
                // careful with our user mode addresses, capturing and probing them carefully.
                //
                PVOID pvArgsTo;
                FRAME_Invoke *pstackFrameMe,*pstackFrameHim;
                DISPPARAMS   *pdispparamsMe,*pdispparamsHim = NULL;
                DISPPARAMS     dispParamsMe,  dispParamsHim = {0};
                //
                pstackFrameMe = (FRAME_Invoke*)m_pvArgs;
                //
                // Save away copy of the actual DISPPARAMS structure
                //
                pdispparamsMe = pstackFrameMe->pDispParams;
                dispParamsMe = *pdispparamsMe; 
                //
                // NULL out the offending [in,out] pointers inside the frames. They're [unique]
                // pointers, so we're allowed to do that.
                //
                pdispparamsMe->rgvarg = NULL;
                pdispparamsMe->rgdispidNamedArgs = NULL;
                //
                // Do the same to the destination frame, if there is one
                //
                if (pframeArgsTo)
                {
                    pvArgsTo = pframeArgsTo->GetStackLocation(); 
                    pstackFrameHim = (FRAME_Invoke*)pvArgsTo; 
                    //
                    pdispparamsHim = pstackFrameHim->pDispParams;
                    dispParamsHim = *pdispparamsHim;
                    //
                    pdispparamsHim->rgvarg = NULL;
                    pdispparamsHim->rgdispidNamedArgs = NULL;
                }
                //
                // Call our helper to do the bulk of the work
                //
                hr = m_pmemoryFrame->Free(pframeArgsTo, pWalkerFreeDest, pWalkerCopy, freeFlags, pWalkerFree, nullFlags);
                //
                if (!hr)
                {
                    // Now fix up the DISPPARAMs
                    //
                    if (pframeArgsTo)
                    {
                        // Copy pDispParams->rgvarg back to the parent frame
                        //
                        OAUTIL util(pWalkerCopy, pWalkerFreeDest, NULL, TRUE, TRUE);
                        //
                        const ULONG cArgs = min(dispParamsMe.cArgs, dispParamsHim.cArgs);
                        //
                        for (ULONG iArg = 0; !hr && iArg < cArgs; iArg++)
                        {
                            VARIANT* pvarSrc = &dispParamsMe.rgvarg[iArg];      
                            VARIANT* pvarDst = &dispParamsHim.rgvarg[iArg];     
                            
                            //
                            // We are propagating the individual members of a DISPPARAMS
                            // from a server frame back to a client frame.  
                            //
                            // We must ONLY do this if we've got a byref variant here.
                            // Those map to [in,out] parameters.  We must ignore all
                            // others.
                            //
                            // Now, logic would dictate that we call VariantClear on the
                            // original variant (pvarDst) before we copy it back over.
                            // This would be true, if our VariantCopy weren't so damned
                            // clever.  Our VariantCopy shares a lot of memory.  A LOT of
                            // memory.  So, for example, when copy a VT_BYREF | VT_VARIANT
                            // or VT_BYREF | VT_UNKNOWN back, we won't bother to allocate 
                            // the new variant or interface pointer wrapper for them.  Since
                            // the top-level VT is not allowed to change, we can safely assume
                            // that this will work.  What about a VT_BYREF | VT_BSTR?  Surely
                            // we need to free the BSTR in that variant before we copy back?
                            // Not so!  Our VariantCopy() routine just blindly copies the pointer
                            // in this case, instead of copying the BSTR.  So if the caller
                            // changed it, they've already free'd the memory.  Thus, we can
                            // just blindly copy the pointer on the way back, too.
                            //
                            // So we don't need to call VariantClear on the original variant.
                            //
                            // Note that VariantCopy *does* call VariantClear on the original
                            // variant, but since we don't own the byref, we don't care.
                            // 
                            if (V_VT(pvarSrc) & VT_BYREF)
                            {
                                // Make sure we're walking correctly.
                                BOOL WalkInterface = util.WalkInterfaces();
                                
                                util.SetWalkInterfaces(TRUE);
                                
                                // You are not allowed to change the VT of a
                                // dispparam during a call.  Period.
                                ASSERT(V_VT(pvarSrc) == V_VT(pvarDst));
                                
                                // Copy the variant back.
                                hr = util.VariantCopy(pvarDst, pvarSrc);
                                
                                // Reset interface walking.
                                util.SetWalkInterfaces(WalkInterface);
                            }
                        }
                    }

                    if (freeFlags && SUCCEEDED(hr))
                    {
                        // Free our pDispParams->rgvarg and pDispParams->rgdispidNamedArgs.
                        //
                        OAUTIL util(NULL, pWalkerFree, NULL, TRUE, TRUE);
                        
                        //
                        // pDispParams->rgvarg is logically [in,out]. So we always free its
                        // contents if there's anything at all to free.
                        //
                        const ULONG cArgs = dispParamsMe.cArgs;
                        for (ULONG iArg = 0; !hr && iArg < cArgs; iArg++)
                        {
                            // Parameters are in reverse order inside the DISPPARAMS.  We iterate
                            // in forward order as a matter of style and for consistency with the
                            // CallFrame implementation.
                            //
                            VARIANTARG *pvarDst = &dispParamsMe.rgvarg[cArgs-1 - iArg];

                            // We only own byrefs if we're a copy.
                            hr = util.VariantClear(pvarDst, m_fIsCopy);
                        }                        

                        if (SUCCEEDED(hr))
                        {
                            //
                            // The two arrays themselves, pDispParams->rgvarg and pDispParams->rgdispidNamedArgs
                            // are actually caller allocated. We shouldn't, properly, actually free them at all.
                            // Only exception is if we're actually a copy, in which case they're ours and should
                            // be free'd as would be the case in a normal call.
                            //
                            if (m_fIsCopy)
                            {
                                ICallFrameInit* pinit;
                                HRESULT hr2 = QI(m_pmemoryFrame, pinit);
                                if (!hr2)
                                {
                                    //
                                    CallFrame* pMemoryFrame = pinit->GetCallFrame();
                                    pMemoryFrame->Free(dispParamsMe.rgvarg);
                                    pMemoryFrame->Free(dispParamsMe.rgdispidNamedArgs);
                                    //
                                    pinit->Release();
                                }
                                else
                                {
                                    DEBUG(NOTREACHED()); // Ignore bug and leak the memory
                                }
                                
                                dispParamsMe.rgvarg = NULL;
                                dispParamsMe.rgdispidNamedArgs = NULL;
                            }
                        }
                    }
                    //
                    if (nullFlags & (CALLFRAME_NULL_INOUT))
                    {
                        // Don't restore the rgvarg/rgdispidNamedargs in the callframe.
                        // Nulling work has already been done in the helper and by hand above
                    }
                    else
                    {
                        if ((freeFlags & (CALLFRAME_FREE_IN | CALLFRAME_FREE_OUT | CALLFRAME_FREE_INOUT)) == 0)
                        {
                            // Restore our pDispParams to what they were before we started, but
                            // only if we didn't just free them.
                            //
                            pdispparamsMe->rgvarg            = dispParamsMe.rgvarg;
                            pdispparamsMe->rgdispidNamedArgs = dispParamsMe.rgdispidNamedArgs;
                        }
                    }
                    //
                    if (pframeArgsTo)
                    {
                        // Restore his pDispParams to what they were before we started
                        //
                        pdispparamsHim->rgvarg            = dispParamsHim.rgvarg;
                        pdispparamsHim->rgdispidNamedArgs = dispParamsHim.rgdispidNamedArgs;
                    }
                }
            }
            __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
            {
                hr = HrNt(GetExceptionCode());
            }
        }
        else
        {
            // Normal call. Just propogate/free/null the in-memory variation
            //
            hr = m_pmemoryFrame->Free(pframeArgsTo, pWalkerFreeDest, pWalkerCopy, freeFlags, pWalkerFree, nullFlags);
        }
    }
    
    if (!hr)
    {
        // We ourselves are the guys that have the actual return value: it's not on the stack and so
        // what our helper has set already is bogus.
        //
        if (pframeArgsTo)
        {
            pframeArgsTo->SetReturnValue((HRESULT)m_hrReturnValue);
        }
    }

    return hr;
}

HRESULT DISPATCH_CLIENT_FRAME::FreeParam(ULONG iparam, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags)
{
    HRESULT hr = S_OK;

    BOOL fUseMemoryFrame = TRUE;

    if (m_iMethod == IMETHOD_Invoke)
    {
        FRAME_Invoke *pstackFrameMe = (FRAME_Invoke*)m_pvArgs;

        switch (iparam)
        {
            //
            // Some of the parameters are declared as [in,out,unique] to MIDL when they are in fact [out,unique].
            // So we must modify the conditions under which the freeing happens.
            //
        case IPARAM_Invoke_PVarResult:
        case IPARAM_Invoke_PExcepInfo:
        {
            freeFlags = freeFlags & (CALLFRAME_FREE_OUT | CALLFRAME_FREE_TOP_OUT);
            nullFlags = nullFlags & (CALLFRAME_NULL_OUT);
        }
        break;
        //
        // The DISPPARAMS are just special, period. We handle them here.
        //
        case IPARAM_Invoke_DispParams:
        {
            __try
            {
                // Invoke has the quirk that pDispParams is an [in] datum with [in,out] members.
                // So we do the freeing by hand.
                //
                // Save away copy of the actual DISPPARAMS structure
                //
                DISPPARAMS *pdispparamsMe = pstackFrameMe->pDispParams;
                DISPPARAMS dispParamsMe = *pdispparamsMe; 
                
                if (freeFlags) // REVIEW: Should this be a finer grained check?
                {
                    OAUTIL util(NULL, pWalkerFree, NULL, TRUE, TRUE);
                    //
                    // pDispParams->rgvarg is logically [in,out]. So we always free its
                    // contents if there's anything at all to free.
                    //
                    const ULONG cArgs = dispParamsMe.cArgs;
                    if (dispParamsMe.rgvarg)
                    {
                        for (ULONG iArg = 0; !hr && iArg < cArgs; iArg++)
                        {
                            VARIANT* pvarDst = &dispParamsMe.rgvarg[iArg]; 
                            void* pvTemp = pvarDst->ppunkVal;
                            hr = util.VariantClear(pvarDst);
                            pvarDst->ppunkVal = (IUnknown**)pvTemp;                            
                        }                        
                    }
                    else
                    {
                        // Ignore missing arguments. It's a unique pointer, so technically that's legal, and
                        // besides, we reliably NULL this out during propogation in DISPATCH_CLIENT_FRAME::Free
                        // so as to be able to handle things ourself very carefully there.
                    }
                    //
                }
            }
            __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
            {
                hr = HrNt(GetExceptionCode());
            }
            
            fUseMemoryFrame = FALSE;
        }
        break;
        
        default:
            //
            // The other IDispatch::Invoke don't need any freeing
            //
            fUseMemoryFrame = FALSE;
            break;
            
            /* end switch */
        }
    }
    //
    // If we still have more work to do, then get our memory frame to carry it out
    //
    if (!hr && fUseMemoryFrame)
    {
        hr = GetMemoryFrame();
        if (!hr)
        {
            hr = m_pmemoryFrame->FreeParam(iparam, freeFlags, pWalkerFree, nullFlags);
        }
    }

    return hr;
}

#if _MSC_VER >= 1200
#pragma warning (pop)
#endif

///////////////////////////////////////////////

HRESULT DISPATCH_SERVER_FRAME::Free(ICallFrame* pframeArgsTo, ICallFrameWalker* pWalkerFreeDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags) 
{
    HRESULT hr = S_OK;

    if (m_iMethod == IMETHOD_Invoke)
    {
        hr = GetMemoryFrame();
        if (!hr)
        {            
            // Remote call to invoke. Remote frame has some additional arguments that need to be freed but
            // must not be propogated. So use the memory frame to do the propogation.
            // 
            hr = m_pmemoryFrame->Free(pframeArgsTo, pWalkerFreeDest, pWalkerCopy, CALLFRAME_FREE_NONE, NULL, CALLFRAME_NULL_NONE);
            if (!hr)
            {
                // Now that we've propagated the things we were going to propagate, do a 
                // SubPostCheck to make sure that we don't try to free memory more than once.
                //
                StubPostCheck();
                
                // Always use the remote frame to do the actual freeing, since it did the allocations in the first place
                //
                ASSERT(m_premoteFrame);
                hr = m_premoteFrame->Free(NULL, NULL, NULL, freeFlags, pWalkerFree, nullFlags);
            }
        }
    }
    else
    {
        // Always use the remote frame to do the actual freeing, since it did the allocations in the first place
        //
        ASSERT(m_premoteFrame);
        hr = m_premoteFrame->Free(pframeArgsTo, pWalkerFreeDest, pWalkerCopy, freeFlags, pWalkerFree, nullFlags);
    }

    if (!hr)
    {
        // We ourselves are the guys that have the actual return value: it's not on the stack
        //
        if (pframeArgsTo)
        {
            pframeArgsTo->SetReturnValue((HRESULT)m_hrReturnValue);
        }
    }

    return hr;
}

HRESULT DISPATCH_SERVER_FRAME::FreeParam(ULONG iparam, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags)
{
    HRESULT hr = S_OK;
    //
    // Always use the remote frame to do the actual freeing, since it did the allocations in the first place
    //
    ASSERT(m_premoteFrame);
    hr = m_premoteFrame->FreeParam(iparam, freeFlags, pWalkerFree, nullFlags);
    //
    return hr;
}

/////////////////////////////////////

HRESULT DISPATCH_CLIENT_FRAME::Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame) 
{ 
    HRESULT hr = S_OK;

    *ppFrame = NULL;
    //
    // IDispatch::Invoke needs some prepatory work on its [out,unique] parameters.
    //
    InitializeInvoke();
    //
    // Ask our memory frame to actually do the copying
    //
    DISPATCH_CLIENT_FRAME* pNewFrame = NULL;
    //
    hr = GetMemoryFrame();
    if (!hr)
    {
        ICallFrame*   pframeCopy;
        
        if (m_iMethod == IMETHOD_Invoke)
        {
            // Need to do some free-esque work here...
            // The problem is that the walker needs to know whether the DISPPARAM we're marshalling
            // is in or in-out.  This is only a valid distinction to make for the top-level variant,
            // so we can't encode the logic into OAUTIL (which is used in CopyWorker, etc.).
            //
            FRAME_Invoke *pstackFrameMe,*pstackFrameHim;
            DISPPARAMS   *pdispparamsMe,*pdispparamsHim;
            DISPPARAMS     dispParamsMe,  dispParamsHim;
            //
            pstackFrameMe = (FRAME_Invoke*)m_pvArgs;
            //
            // Save away copy of the actual DISPPARAMS structure
            //
            pdispparamsMe = pstackFrameMe->pDispParams;
            dispParamsMe = *pdispparamsMe; 
            //
            // NULL out the offending [in,out] pointers inside the frames. They're [unique]
            // pointers, so we're allowed to do that.
            //
            pdispparamsMe->rgvarg = NULL;
            //
            // Call our helper to do the bulk of the work
            // This will copy everything but the DISPPARAMS.
            //
            hr = m_pmemoryFrame->Copy(callControl, pWalker, &pframeCopy);
            if (!hr)
            {
                // Allocate his DISPPARAMS arrays.
                //
                // This is a bit of a back door, since we know that pframeCopy
                // is really a CallFrame, and we need to allocate some more memory
                // for the DISPPARAMS.
                //
                CallFrame *cfDest = (CallFrame *)(pframeCopy);
                
                PVOID pvArgsTo = pframeCopy->GetStackLocation(); 
                pstackFrameHim = (FRAME_Invoke*)pvArgsTo; 
                pdispparamsHim = pstackFrameHim->pDispParams;
                
                pdispparamsHim->rgvarg     = (VARIANTARG *)cfDest->Alloc(sizeof(VARIANTARG) * dispParamsMe.cArgs);
                if (!pdispparamsHim->rgvarg)
                    hr = E_OUTOFMEMORY;
                
                if (!hr)
                {
                    // OK! Copy the DISPPARAMS!
                    //
                    OAUTIL util(pWalker, NULL, NULL, TRUE, FALSE);
                    
                    for (ULONG iArg = 0; iArg < dispParamsMe.cArgs; iArg++)
                    {
                        VARIANT* pvarSrc = &dispParamsMe.rgvarg[iArg];      
                        VARIANT* pvarDst = &(pdispparamsHim->rgvarg[iArg]);
                        
                        VariantInit(pvarDst);
                        //
                        // We 'accumulate' hr's from VariantCopy below.
                        // We cannot break out of the loop because we want
                        // each VARIANTARG to be at least initialized (above).
                        //
                        if (!hr)
                        {
                            // Set the OAUTIL's 'this is an out parameter' flag.
                            // Note that the 'in' flag is always on. 
                            //
                            // (My favorite part is that the following two lines
                            // are the whole reason for doing this complicated
                            // allocation and loop.  ^_^)
                            //
                            BOOL fInOut = (V_VT(pvarSrc) & VT_BYREF) ? TRUE : FALSE;
                            util.SetWorkingOnOut(fInOut);
                            
                            hr = util.VariantCopy(pvarDst, pvarSrc, TRUE);
                        }
                    }
                }
                else
                {
                    // Allocations failed, going to be returing E_OUTOFMEMORY.
                    ::Release(pframeCopy);
                }
            }

            // Restore our DISPPARAMS.
            //
            pdispparamsMe->rgvarg  = dispParamsMe.rgvarg;
        }
        else
        {
            // Call our helper to do the bulk of the work            
            //
            hr = m_pmemoryFrame->Copy(callControl, pWalker, &pframeCopy);
        }
            
        if (!hr)
        {
            // Got a copy of the memory frame; now wrap with a legacy guy around that
            //
            PVOID pvArgsCopy = pframeCopy->GetStackLocation();
            
            pNewFrame = new DISPATCH_CLIENT_FRAME(NULL, m_iMethod, pvArgsCopy, m_pInterceptor);
            if (pNewFrame)  
            {
                // Tell him his memory frame
                //
                ::Set(pNewFrame->m_pmemoryFrame, pframeCopy);
                //
                // Tell him that he's in fact a copy. This modifies his freeing behaviour
                // on pDispParams in IDispatch::Invoke.
                //
                pNewFrame->m_fIsCopy = TRUE;
            }
            else
                hr = E_OUTOFMEMORY;

            ::Release(pframeCopy);
        }
    }

    if (!hr)
    {
        hr = QI(pNewFrame, *ppFrame);
        ::Release(pNewFrame);
    }

    return hr;
}



HRESULT DISPATCH_SERVER_FRAME::Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame) 
{
    HRESULT hr = S_OK;
    *ppFrame = NULL;
    //
    // Ask our _remote_ frame to actually do the copying
    //
    DISPATCH_SERVER_FRAME* pframeCopy = NULL;
    //
    if (!hr) hr = StubPreCheck();
    if (!hr) hr = GetMemoryFrame();
    if (!hr)
    {
        ICallFrame* premoteFrameCopy;
        hr = m_premoteFrame->Copy(callControl, pWalker, &premoteFrameCopy);
        if (!hr)
        {
            // Got a copy of the remote frame; now wrap with a legacy guy around that
            //
            PVOID pvArgsCopy = premoteFrameCopy->GetStackLocation();

            pframeCopy = new DISPATCH_SERVER_FRAME(NULL, m_iMethod, pvArgsCopy, m_pInterceptor);
            if (pframeCopy)  
            {
                ::Set(pframeCopy->m_premoteFrame, premoteFrameCopy);
                //
                // Copy over the in-memory frame that we'll use for actually invoking
                //
                pframeCopy->m_fDoneStubPrecheck = m_fDoneStubPrecheck;
                pframeCopy->m_memoryFrame       = m_memoryFrame;
            }
            else
                hr = E_OUTOFMEMORY;

            ::Release(pframeCopy);
        }
    }

    if (!hr)
    {
        hr = QI(pframeCopy, *ppFrame);
        ::Release(pframeCopy);
    }

    return hr;
}





HRESULT DISPATCH_FRAME::WalkFrame(DWORD walkWhat, ICallFrameWalker *pWalker) 
// Walk the in-parameters and / or out-parameters for interface pointers
{
    HRESULT hr = S_OK;
    
    if (pWalker)
    { 
        switch (m_iMethod)
        {
        case IMETHOD_GetTypeInfoCount:
        {
            FRAME_GetTypeInfoCount* pframe = (FRAME_GetTypeInfoCount*)m_pvArgs;
            //
            // No interfaces here
            //
        }
        break;

        case IMETHOD_GetTypeInfo:
        {
            FRAME_GetTypeInfo* pframe = (FRAME_GetTypeInfo*)m_pvArgs;
            // REVIEW: Should this really be walked?  (See oautil.cpp and the UDT stuff)
            if (walkWhat & CALLFRAME_WALK_OUT)
            {
                hr = OAUTIL(NULL, NULL, pWalker, FALSE, TRUE).WalkInterface(pframe->ppTInfo);
            }
        }
        break;

        case IMETHOD_GetIDsOfNames:
        {
            FRAME_GetIDsOfNames* pframe = (FRAME_GetIDsOfNames*)m_pvArgs;
            //
            // No interfaces here
            //
        }
        break;

        case IMETHOD_Invoke:
        {
            FRAME_Invoke* pframe = (FRAME_Invoke*)m_pvArgs;
            //
            // DISPPARAMS are [in,out]
            //
            if (pframe->pDispParams)
            {
                hr = OAUTIL(NULL, NULL, pWalker, TRUE, TRUE).Walk(walkWhat, pframe->pDispParams);
            }
            //
            // pVarResult is just [out]
            //
            if ((walkWhat & CALLFRAME_WALK_OUT) && SUCCEEDED(hr))
            {
                if (pframe->pVarResult)
                {
                    hr = OAUTIL(NULL, NULL, pWalker, FALSE, TRUE).Walk(pframe->pVarResult);
                }
            }
        }
        break;

        default:
            NOTREACHED();
            hr = RPC_E_INVALIDMETHOD;
            break;
        }
    }
    else
        hr = E_INVALIDARG;
        
    return hr;  
}










////////////////////////////////////////////////////////////////////////////////////////
//
// Invoking


HRESULT DISPATCH_FRAME::Invoke(void *pvReceiver) 
// Invoke ourselves on the indicated receiver
{ 
    HRESULT hr = S_OK; 
    IDispatch* pdisp = reinterpret_cast<IDispatch*>(pvReceiver);

    m_fAfterCall = TRUE;

    switch (m_iMethod)
    {
    case IMETHOD_GetTypeInfoCount:
    {
        FRAME_GetTypeInfoCount* pframe = (FRAME_GetTypeInfoCount*)m_pvArgs;
        m_hrReturnValue = pdisp->GetTypeInfoCount(pframe->pctinfo);
    }
    break;

    case IMETHOD_GetTypeInfo:
    {
        FRAME_GetTypeInfo* pframe = (FRAME_GetTypeInfo*)m_pvArgs;
        m_hrReturnValue = pdisp->GetTypeInfo(pframe->iTInfo, pframe->lcid, pframe->ppTInfo);
    }
    break;

    case IMETHOD_GetIDsOfNames:
    {
        FRAME_GetIDsOfNames* pframe = (FRAME_GetIDsOfNames*)m_pvArgs;
        m_hrReturnValue = pdisp->GetIDsOfNames(pframe->riid, pframe->rgszNames, pframe->cNames, pframe->lcid, pframe->rgDispId);
    }
    break;

    default:
        NOTREACHED();
        m_hrReturnValue = CALLFRAME_E_COULDNTMAKECALL;
        m_fAfterCall = FALSE;
        break;
    }
        
    return hr;  
}
    
HRESULT DISPATCH_CLIENT_FRAME::Invoke(void *pvReceiver, ...) 
// Invoke ourselves on the indicated receiver
{ 
    HRESULT hr = S_OK; 
    
    if (m_iMethod == IMETHOD_Invoke)
    {
        FRAME_Invoke* pframe = (FRAME_Invoke*)m_pvArgs;
        IDispatch* pdisp = reinterpret_cast<IDispatch*>(pvReceiver);
        //
        m_hrReturnValue = pdisp->Invoke(pframe->dispIdMember, *pframe->piid, pframe->lcid, pframe->wFlags, pframe->pDispParams, pframe->pVarResult, pframe->pExcepInfo, pframe->puArgErr);
        //
        m_fAfterCall = TRUE;
    }
    else
        hr = DISPATCH_FRAME::Invoke(pvReceiver);
        
    return hr;  
}


HRESULT DISPATCH_SERVER_FRAME::Invoke(void *pvReceiver, ...) 
// Invoke ourselves on the indicated receiver
{ 
    HRESULT hr = S_OK;
    
    m_hrReturnValue = CALLFRAME_E_COULDNTMAKECALL; 
    
    if (m_iMethod == IMETHOD_Invoke)
    {
        hr = StubPreCheck();
        if (!hr)
        {
            IDispatch* pdisp = reinterpret_cast<IDispatch*>(pvReceiver);
            //
            m_hrReturnValue = pdisp->Invoke(m_memoryFrame.dispIdMember, *m_memoryFrame.piid, m_memoryFrame.lcid, m_memoryFrame.wFlags, m_memoryFrame.pDispParams, m_memoryFrame.pVarResult, m_memoryFrame.pExcepInfo, m_memoryFrame.puArgErr);
            //
            m_fAfterCall = TRUE;
        }
    }
    else
        hr = DISPATCH_FRAME::Invoke(pvReceiver);
        
    return hr;  
}


////////////////////////////////////////////////////////////////////////////////////////
//
// COM infrastructure


STDMETHODIMP LEGACY_FRAME::InnerQueryInterface (REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown)           { *ppv = (IUnkInner*) this; }
    else if (iid == __uuidof(ICallFrame))   { *ppv = (ICallFrame*) this; }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}








////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//
// LEGACY_INTERCEPTOR
//
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

LEGACY_INTERCEPTOR::LEGACY_INTERCEPTOR(IUnknown * punkOuter)
{
    m_refs              = 1;
    m_punkOuter         = punkOuter ? punkOuter : (IUnknown *)(void*)((IUnkInner *)this);
    m_psink             = NULL;
    m_iid               = IID_NULL;
    m_premoteInterceptor         = NULL;
    m_pmemoryInterceptor         = NULL;
    m_fRegdWithRemoteInterceptor = FALSE;
    m_fRegdWithMemoryInterceptor = FALSE;
    m_ppframeCustomer            = NULL;
    m_fShuttingDown              = FALSE;
    m_pmdMostDerived             = NULL;
}

LEGACY_INTERCEPTOR::~LEGACY_INTERCEPTOR (void)
{
    // Paranoia: Prevent reference count disturbences on our aggregator as we
    // shut ourselves down.
    //
    m_punkOuter = (IUnknown *)(void*)((IUnkInner *)this);
    //
    // Don't let _ourselves_ get bothered 
    //
    m_fShuttingDown = TRUE;
    //
    // Actually do the cleanup work
    //
    ::Release(m_psink);
    //
    ::Release(m_pmdMostDerived);
    //
    ReleaseRemoteInterceptor();
    ReleaseMemoryInterceptor();
}

HRESULT LEGACY_INTERCEPTOR::Init()
{
    HRESULT hr = S_OK;
    if (m_frameLock.FInit() == FALSE)
        hr = E_OUTOFMEMORY;
    return hr;
}

HRESULT LEGACY_INTERCEPTOR::GetRemoteFrameFor(ICallFrame** ppFrame, LEGACY_FRAME* pFrame)
// Create and return a reference on an oicf-driven frame for the indicated legacy frame
{
    HRESULT hr = S_OK;
    m_frameLock.LockExclusive();
    m_ppframeCustomer = ppFrame;

    HRESULT hrReturnValue;
    ULONG cbArgs;
    hr = m_premoteInterceptor->CallIndirect(&hrReturnValue, pFrame->m_iMethod, pFrame->m_pvArgs, &cbArgs);

    m_ppframeCustomer = NULL;
    m_frameLock.ReleaseLock();
    return hr;
}

HRESULT LEGACY_INTERCEPTOR::GetMemoryFrameFor(ICallFrame** ppFrame, LEGACY_FRAME* pFrame)
// Create and return a reference on an oicf-driven frame that understands the in-memory
// representation of the interface.
{
    HRESULT hr = S_OK;
    m_frameLock.LockExclusive();
    m_ppframeCustomer = ppFrame;

    HRESULT hrReturnValue;
    ULONG cbArgs;
    hr = m_pmemoryInterceptor->CallIndirect(&hrReturnValue, pFrame->m_iMethod, pFrame->m_pvArgs, &cbArgs);

    m_ppframeCustomer = NULL;
    m_frameLock.ReleaseLock();
    return hr;
}

HRESULT LEGACY_INTERCEPTOR::OnCall(ICallFrame* pframe)
// Callback from our m_premoteInterceptor when it gets a call. It only ever does so in
// response to our stimulous in GetRemoteFrameFor above.
{
    HRESULT hr = S_OK;
    ASSERT(m_frameLock.WeOwnExclusive() && m_ppframeCustomer);

    *m_ppframeCustomer = pframe;
    (*m_ppframeCustomer)->AddRef(); // hold on to the frame beyond the callback here

    return hr;
}

///////////////////////////////////////////////////////////////////
//
// IDispatch
//
///////////////////////////////////////////////////////////////////
#if defined(_AMD64_) || defined(_X86_)
HRESULT LEGACY_INTERCEPTOR::GetTypeInfoCount(UINT* pctinfo)
{
    INTERCEPT_CALL(pctinfo, pctinfo, IMETHOD_GetTypeInfoCount);
}
HRESULT LEGACY_INTERCEPTOR::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo ** ppTInfo)
{
    INTERCEPT_CALL(iTInfo, ppTInfo, IMETHOD_GetTypeInfo);
}
HRESULT LEGACY_INTERCEPTOR::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgDispId)
{
    return GetIDsOfNames(&riid, rgszNames, cNames, lcid, rgDispId); // avoid & problems with the ref
}
HRESULT LEGACY_INTERCEPTOR::GetIDsOfNames(const IID* piid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgDispId)
{
    INTERCEPT_CALL(piid, rgDispId, IMETHOD_GetIDsOfNames);
}
HRESULT LEGACY_INTERCEPTOR::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,DISPPARAMS * pDispParams,
                                   VARIANT * pVarResult, EXCEPINFO * pExcepInfo, UINT * puArgErr)
{
    INTERCEPT_CALL(dispIdMember, puArgErr, IMETHOD_Invoke);
}
#else
HRESULT LEGACY_INTERCEPTOR::GetTypeInfoCount(UINT* pctinfo)
{
    return GenericCall(IMETHOD_GetTypeInfoCount,
                       this,
                       pctinfo);
}
HRESULT LEGACY_INTERCEPTOR::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo ** ppTInfo)
{
    return GenericCall(IMETHOD_GetTypeInfo,
                       this,
                       iTInfo,
                       lcid, ppTInfo);
}
HRESULT LEGACY_INTERCEPTOR::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, 
                                          UINT cNames, LCID lcid, DISPID * rgDispId)
{
    return GenericCall(IMETHOD_GetIDsOfNames, 
                       this, 
                       &riid, 
                       rgszNames, 
                       cNames, 
                       lcid, 
                       rgDispId);
}
HRESULT LEGACY_INTERCEPTOR::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
                                   WORD wFlags,DISPPARAMS * pDispParams,
                                   VARIANT * pVarResult, EXCEPINFO * pExcepInfo, 
                                   UINT * puArgErr)
{
    return GenericCall(IMETHOD_Invoke, 
                       this, 
                       dispIdMember,
                       &riid,
                       lcid,
                       wFlags,
                       pDispParams,
                       pVarResult,
                       pExcepInfo,
                       puArgErr);
}

    
HRESULT LEGACY_INTERCEPTOR::GenericCall(ULONG iMethod, ...)
{
    va_list va;
    va_start(va, iMethod);

    const void* pvArgs = va;
    ULONG cbArgs;
    HRESULT hrReturn;
    CallIndirect(&hrReturn, iMethod, const_cast<void*>(pvArgs), &cbArgs);
    return hrReturn;
}
#endif



///////////////////////////////////////////////////////////////////
//
// ICallIndirect
//
///////////////////////////////////////////////////////////////////
    
STDMETHODIMP LEGACY_INTERCEPTOR::CallIndirect(HRESULT* phReturnValue, ULONG iMethod, void* pvArgs, ULONG* pcbArgs)
// Act as though an invocation on the indicated method in this interface
// has been received, with the indicated stack frame.
{
    HRESULT hr = S_OK;
    //
    // Assume a failed call until we know otherwise
    //
    if (phReturnValue) *phReturnValue = CALLFRAME_E_COULDNTMAKECALL;

    if (IMETHOD_FIRST <= iMethod && iMethod < m_cMethods)
    {
        // Make a new frame to service the call
        //
        LEGACY_FRAME* pNewFrame = NULL;
        
        if (__uuidof(IDispatch) == m_iid)
        {
            pNewFrame = new DISPATCH_CLIENT_FRAME(NULL, iMethod, pvArgs, this);
        }
        else
            hr = E_NOINTERFACE;

        if (pNewFrame) 
        {
            if (m_psink)
            {
                // Deliver the call to the registered sink
                //
                hr = m_psink->OnCall( static_cast<ICallFrame*>(pNewFrame) );
                if (!hr && phReturnValue)
                {
                    // Pass the return value back to our caller
                    //
                    *phReturnValue = pNewFrame->GetReturnValue();
                }
            }
            
            pNewFrame->Release();
        }
        else if (!hr)
        {
            hr = E_OUTOFMEMORY;
        }
        //
        // In all valid-iMethod cases compute the stack size
        //
        GetStackSize(iMethod, pcbArgs);
    }
    else
    {
        *pcbArgs = 0;
        hr = E_INVALIDARG;  // Caller bug, so we're graceful
    }

    return hr;
}

STDMETHODIMP LEGACY_INTERCEPTOR::GetStackSize(ULONG iMethod, ULONG * pcbStack)
// Return the stack size for the indicated method in this interface
{
    HRESULT hr = S_OK;
    ASSERT (pcbStack);
    //
    // Should be implemented by subclasses
    //
    *pcbStack = 0;
    hr = E_INVALIDARG;

    return hr;
}

STDMETHODIMP DISPATCH_INTERCEPTOR::GetStackSize(ULONG iMethod, ULONG* pcbStack)
// Return the stack size for the indicated method in this interface
{
    HRESULT hr = S_OK;

    if (m_pmemoryInterceptor)
    {
        return m_pmemoryInterceptor->GetStackSize(iMethod, pcbStack);
    }
    else
    {
        *pcbStack = 0;
        hr = E_UNEXPECTED;
    }

    return hr;
}
        
STDMETHODIMP LEGACY_INTERCEPTOR::GetIID(IID* piid, BOOL* pfDerivesFromIDispatch, ULONG* pcMethod, LPWSTR* pwszInterface)
{
    HRESULT hr = S_OK;

    if (piid)
    {
        if (m_pmdMostDerived)
        {
            *piid = *m_pmdMostDerived->m_pHeader->piid;
        }
        else
        {
            *piid = m_iid;
        }
    }

    if (pfDerivesFromIDispatch)
    {
        *pfDerivesFromIDispatch = (m_iid == __uuidof(IDispatch));
    }
           
    if (pcMethod)
    {
        if (m_pmdMostDerived)
        {
            *pcMethod = m_pmdMostDerived->m_pHeader->DispatchTableCount;
        }
        else
        {
            *pcMethod = m_cMethods;
        }
    }

    if (pwszInterface)
    {
        *pwszInterface = NULL;

        if (m_pmdMostDerived)
        {
            if (m_pmdMostDerived->m_szInterfaceName)
            {
                *pwszInterface = ToUnicode(m_pmdMostDerived->m_szInterfaceName);
                if (NULL == *pwszInterface) hr = E_OUTOFMEMORY;
            }
        }
        else if (m_iid == __uuidof(IDispatch))
        {
            *pwszInterface = CopyString(L"IDispatch");
            if (NULL == *pwszInterface) hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

STDMETHODIMP LEGACY_INTERCEPTOR::GetMethodInfo(ULONG iMethod, CALLFRAMEINFO * pinfo, LPWSTR* pwszMethodName)
{
    HRESULT hr = S_OK;

    ASSERT(pinfo);
    Zero(pinfo);
    if (pwszMethodName) *pwszMethodName = NULL;

    if (m_pmdMostDerived)
    {
        pinfo->iid     = *m_pmdMostDerived->m_pHeader->piid;
        pinfo->cMethod =  m_pmdMostDerived->m_pHeader->DispatchTableCount;
        //
        ASSERT(pinfo->cMethod >= m_cMethods);   // can never have too many asserts!
    }
    else
    {
        pinfo->iid     = m_iid;
        pinfo->cMethod = m_cMethods;
    }
    pinfo->iMethod = iMethod;
    
    if (m_iid == __uuidof(IDispatch))
    {
        pinfo->fDerivesFromIDispatch = TRUE;

        switch (iMethod)
        {
        case IMETHOD_GetTypeInfoCount:
            pinfo->fHasOutValues         = TRUE;
            if (pwszMethodName) *pwszMethodName = CopyString(L"GetTypeInfoCount");
            break;

        case IMETHOD_GetTypeInfo: 
            pinfo->fHasInValues          = TRUE;
            pinfo->fHasOutValues         = TRUE;
            pinfo->cOutInterfacesMax     = 1;
            if (pwszMethodName) *pwszMethodName = CopyString(L"GetTypeInfo");
            break;

        case IMETHOD_GetIDsOfNames:
            pinfo->fHasInValues          = TRUE;
            pinfo->fHasOutValues         = TRUE;
            if (pwszMethodName) *pwszMethodName = CopyString(L"GetIDsOfNames");
            break;

        case IMETHOD_Invoke:
            pinfo->fHasInValues            = TRUE; // dispIdMember, riid, lcid, wFlags
            pinfo->fHasInOutValues         = TRUE; // dispParams
            pinfo->fHasOutValues           = TRUE; // pVarResult, pExcepInfo, puArgErr
            pinfo->cInInterfacesMax        = -1;   // an unbounded number of them can be in dispparams
            pinfo->cInOutInterfacesMax     = -1;   // an unbounded number of them can be in dispparams
            pinfo->cOutInterfacesMax       = -1;   // an unbounded number of them can be in pVarResult
            if (pwszMethodName) *pwszMethodName = CopyString(L"Invoke");
            break;

        default:
            NOTREACHED();
            hr = E_INVALIDARG;
            break;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (!hr && pwszMethodName && *pwszMethodName == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    
    if (!!hr && pwszMethodName)
    {
        CoTaskMemFree(*pwszMethodName);
        *pwszMethodName = NULL;
    }

    return hr;
} //end GetMethodInfo

HRESULT LEGACY_FRAME::GetNames(LPWSTR* pwszInterface, LPWSTR* pwszMethod)
{
    HRESULT hr = S_OK;

    if (pwszInterface)
    {
        hr = m_pInterceptor->GetIID((IID*)NULL, (BOOL*)NULL, (ULONG*)NULL, pwszInterface);
    }

    if (pwszMethod)
    {
        if (!hr)
        {
            CALLFRAMEINFO info;
            hr = m_pInterceptor->GetMethodInfo(m_iMethod, &info, pwszMethod);
        }
        else
            *pwszMethod = NULL;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
// ICallInterceptor
//
///////////////////////////////////////////////////////////////////

STDMETHODIMP LEGACY_INTERCEPTOR::RegisterSink(ICallFrameEvents* psink)
{
    HRESULT hr = S_OK;
    ::Set(m_psink, psink);
    return hr;
}
        
STDMETHODIMP LEGACY_INTERCEPTOR::GetRegisteredSink(ICallFrameEvents ** ppsink)
{
    ::Set(*ppsink, m_psink);
    return (m_psink ? S_OK : CO_E_OBJNOTREG); 
}

STDMETHODIMP DISPATCH_INTERCEPTOR::Unmarshal( 
    ULONG                       iMethod,
    PVOID                       pBuffer,
    ULONG                       cbBuffer,
    BOOL                        fForceCopyBuffer,
    RPCOLEDATAREP               dataRep,
    CALLFRAME_MARSHALCONTEXT *  pcontext,
    ULONG *                     pcbUnmarshalled,
    ICallFrame **               ppFrame)
// Unmarshal in-parameters to create a new call frame
{
    HRESULT hr = S_OK;
    *ppFrame = NULL;
    //
    // Ask our remote interceptor to cons us up a new frame from the remote invocation
    //
    DISPATCH_SERVER_FRAME* pNewFrame = NULL;
    //
    ICallUnmarshal* punmarshal;
    hr = QI(m_premoteInterceptor, punmarshal);
    if (!hr)
    {
        ICallFrame* premoteFrame;
        hr = punmarshal->Unmarshal(iMethod, pBuffer, cbBuffer, fForceCopyBuffer, dataRep, pcontext, pcbUnmarshalled, &premoteFrame);
        if (!hr)
        {
            // Got the remote frame into memory. Wrap in a DISPATCH_FRAME
            //
            PVOID pvArgsRemote = premoteFrame->GetStackLocation();

            pNewFrame = new DISPATCH_SERVER_FRAME(NULL, iMethod, pvArgsRemote, this);
            if (pNewFrame)  
            {
                ::Set(pNewFrame->m_premoteFrame, premoteFrame);
                //
                // Always make sure that these things are initialized
                //
                if (iMethod == IMETHOD_Invoke)
                {
                    hr = pNewFrame->StubPreCheck();
                }
            }
            else
                hr = E_OUTOFMEMORY;

            ::Release(premoteFrame);
        }
        ::Release(punmarshal);
    }

    if (!hr)
    {
        hr = QI(pNewFrame, *ppFrame);
        ::Release(pNewFrame);
    }

    return hr;
}

        
STDMETHODIMP LEGACY_INTERCEPTOR::ReleaseMarshalData( 
    ULONG                       iMethod,
    PVOID                       pBuffer,
    ULONG                       cbBuffer,
    ULONG                       ibFirstRelease,
    RPCOLEDATAREP               dataRep,
    CALLFRAME_MARSHALCONTEXT *  pcontext)
{
    HRESULT hr = S_OK;
    NYI(); hr = E_NOTIMPL;
    return hr;
}

//////////////////////////////////////////////////////////


HRESULT LEGACY_INTERCEPTOR::GetInternalInterceptor(REFIID iid, ICallInterceptor** ppInterceptor)
{
    HRESULT hr = S_OK;
    *ppInterceptor = NULL;

    // Get an oicf-driven interceptor that we can delegate to as we need
    //
    Interceptor* pnew = new Interceptor(NULL);
    if (pnew)
    {
        // Set it's proxy-file-list by hand; in the normal case, this is
        // done by its class factory. See ComPsClassFactory::CreateInstance.
        //
        pnew->m_pProxyFileList = CallFrameInternal_aProxyFileList;

        IUnkInner* pme = (IUnkInner*)pnew;
        if (hr == S_OK)
        {
            hr = pme->InnerQueryInterface(__uuidof(**ppInterceptor), (void**)ppInterceptor);
            if (!hr)
            {
                // If we got the interceptor, then initialize it with the right IID
                //
                IInterfaceRelated* prelated;
                hr = QI(*ppInterceptor, prelated);
                if (!hr)
                {
                    hr = prelated->SetIID(iid);
                    //
                    // We only tolerate one error.. out of memory.  Anything else is a bad failure
                    // on our part.
                    if (hr != E_OUTOFMEMORY)
                    {
                        ASSERT(!hr);
                    }
                    prelated->Release();
                }
                //
                // Set up ourselves as the sink for this guy, being careful not to create a refcnt cycle
                //
                if (!hr)
                {
                    ICallFrameEvents* psink = (ICallFrameEvents*)this;
                    hr = (*ppInterceptor)->RegisterSink(psink);
                    if (!hr)
                    {
                        psink->Release();
                    }
                }
            }
        }
        pme->InnerRelease();                // balance starting ref cnt of one    
    }
    else 
        hr = E_OUTOFMEMORY;

    return hr;
}

STDMETHODIMP LEGACY_INTERCEPTOR::SetIID(REFIID iid)
{
    HRESULT hr = S_OK;

    ReleaseRemoteInterceptor();
    ReleaseMemoryInterceptor();
    //
    if (!hr)
    {
        hr = GetInternalInterceptor(iid, &m_premoteInterceptor);
        if (!hr)
        {
            m_fRegdWithRemoteInterceptor = TRUE;
        }
    }
    
    return hr;
}

STDMETHODIMP DISPATCH_INTERCEPTOR::SetIID(REFIID iid)
{
    HRESULT hr = LEGACY_INTERCEPTOR::SetIID(iid);
    if (!hr)
    {
        // Set our IID and method count.
        //
        if (iid == IID_IDispatch)
        {
            m_iid      = iid;
            m_cMethods = IMETHOD_DISPATCH_MAX;

            hr = GetInternalInterceptor(__uuidof(IDispatch_In_Memory), &m_pmemoryInterceptor);
            if (!hr)
            {
                m_fRegdWithMemoryInterceptor = TRUE;
            }
        }
        else
            hr = E_NOINTERFACE;
    }

    return hr;
}

/////////////////
        
STDMETHODIMP LEGACY_INTERCEPTOR::GetIID(IID* piid)
{
    if (piid) *piid = m_iid;
    return S_OK;
}

//////////////////////////////////////////////////////////

STDMETHODIMP LEGACY_INTERCEPTOR::InnerQueryInterface (REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown)               { *ppv = (IUnkInner*) this; }
  
    else if ((iid == __uuidof(ICallIndirect)) || (iid == __uuidof(ICallInterceptor)))
    {
        *ppv = (ICallInterceptor *) this;
    }
    else if (iid == __uuidof(IInterfaceRelated))   { *ppv = (IInterfaceRelated*) this; }
    else if (iid == __uuidof(ICallUnmarshal))      { *ppv = (ICallUnmarshal*)    this; }
    else if (iid == __uuidof(ICallFrameEvents))    { *ppv = (ICallFrameEvents*)  this; }
    else if (iid == __uuidof(IInterceptorBase))    { *ppv = (IInterceptorBase*)  this; }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP DISPATCH_INTERCEPTOR::InnerQueryInterface(REFIID iid, void ** ppv)
{
    if (iid == __uuidof(IDispatch))
    {
        *ppv = (IDispatch*) this;
    }
    else
        return LEGACY_INTERCEPTOR::InnerQueryInterface(iid, ppv);

    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Our pool of allocated call frames. We keep dead shells around so that they can quickly
// be allocated w/o taking any locks.

IFastStack<DISPATCH_CLIENT_FRAME>* 
DedicatedAllocator<DISPATCH_CLIENT_FRAME>::g_pStack;

IFastStack<DISPATCH_SERVER_FRAME>* 
DedicatedAllocator<DISPATCH_SERVER_FRAME>::g_pStack;

BOOL InitLegacy()
{
        BOOL fOK = FALSE;

        if (DedicatedAllocator<DISPATCH_CLIENT_FRAME>::g_pStack 
                = DedicatedAllocator<DISPATCH_CLIENT_FRAME>::CreateStack())
        {
                if (DedicatedAllocator<DISPATCH_SERVER_FRAME>::g_pStack 
                        = DedicatedAllocator<DISPATCH_SERVER_FRAME>::CreateStack())
                {
                        fOK = TRUE;
                }
                else
                {
                        DedicatedAllocator<DISPATCH_CLIENT_FRAME>::DeleteStack();
                }
        }

        return fOK;
}

extern "C"
void ShutdownCallFrame()
// Support for making PrintMemoryLeaks more intelligent
{
    DedicatedAllocator<CallFrame            >::DeleteStack();
    DedicatedAllocator<DISPATCH_CLIENT_FRAME>::DeleteStack();
    DedicatedAllocator<DISPATCH_SERVER_FRAME>::DeleteStack();
        
    FreeTypeInfoCache();
        
    FreeMetaDataCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\callframe.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrame.cpp
//
#include "stdpch.h"
#include "common.h"
#include "ndrclassic.h"

#if _MSC_VER >= 1200
#pragma warning (push)
#pragma warning (disable : 4509)
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Our pool of allocated call frames. We keep dead shells around so that they can quickly
// be allocated w/o taking any locks.

IFastStack<CallFrame>* DedicatedAllocator<CallFrame>::g_pStack;

BOOL InitCallFrame()
{
    if (DedicatedAllocator<CallFrame>::g_pStack = DedicatedAllocator<CallFrame>::CreateStack())
        return TRUE;

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

inline CallFrame* CallFrame::GetFrame(CallFrame*& pFrame, PVOID pvArgs)
  // Helper routine that instantiates a CallFrame if and only if we need it
{
    if (NULL == pFrame)
    {
        pFrame = new CallFrame;
        if (NULL == pFrame)
        {
            Throw(STATUS_NO_MEMORY);
        }
        pFrame->Init(pvArgs, m_pmd, m_pInterceptor);
        pFrame->m_StackTop = (BYTE*)pvArgs;
    }
    return pFrame;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


HRESULT CallFrame::Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame)
  // Create a deep copy of this call frame, either a fleeting or a durable one, as requested by the caller.
  //
  // Format string for a procedure is
  //
  //      handle_type <1>      FC_BIND_PRIMITIVE | FC_BIND_GENERIC | FC_AUTO_HANDLE | FC_CALLBACK_HANDLE | 0
  //      Oi_flags    <1>         
  //      [rpc_flags  <4>]     if Oi_HAS_RPCFLAGS is set
  //      proc_num    <2>
  //      stack_size  <2>
  //      [explicit_handle_description<>] Omitted for implicit handles. Explicit handles indicated by handle_type==0.
  //                                      SanityCheck verifies that there is no explicit handle.
  //      ...more stuff...
  //
{
    HRESULT hr = S_OK;

    //
    // Can the Dst frame share parameters with the parent frame?
    //
    const BOOL fShareMemory = (callControl == CALLFRAME_COPY_NESTED);

#ifdef DBG
    if (m_fAfterCall)
    {
        ASSERT(!m_pmd->m_info.fHasOutValues);
    }
#endif

    CallFrame* pDstFrame = NULL;

    __try
    {
        const ULONG cbStack = m_pmd->m_cbPushedByCaller;
        //
        // Create a new CallFrame to work with. This is the frame that will be the result of our copy
        //
        if (!hr)
        {
            hr = GetFrame(pDstFrame, NULL)->AllocStack(cbStack);
            pDstFrame->m_pvArgsSrc = fShareMemory ? m_pvArgs : NULL;
        }
        
        //
        // OK! off to the races with actually doing the work!
        //
        if (!hr)
        {
            //
            // Copy each of the in parameters beyond the 'this' pointer. The 'this' pointer isn't in the 
            // list of parameters as emitted by MIDL.
            //
            if (fShareMemory && m_pmd->m_fCanShareAllParameters)
            {
                //
                // Copy the entire stack in one fell swoop
                //
                CopyMemory(pDstFrame->m_pvArgs, m_pvArgs, cbStack);
            }
            else
            { 
                //
                // Set up state so that worker routines can find it
                //
                ASSERT(m_pAllocatorFrame == NULL);
                m_pAllocatorFrame = pDstFrame;
                
                ASSERT(!AnyWalkers());
                m_StackTop              = (PBYTE)m_pvArgs;
                m_pWalkerCopy           = pWalker;
                m_fPropogatingOutParam  = FALSE;
                
                //
                // Copy the 'this' pointer. It's what pvArgs is pointing at. The type is our iid.
                // On purpose, we don't call the walker for the receiver.
                //
                CopyMemory(pDstFrame->m_pvArgs, m_pvArgs, sizeof(void*));
                
                //
                // Copy each of the in parameters beyond the 'this' pointer. The 'this'
                // pointer isn't in the list of parameters as emitted by MIDL.
                //
                for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
                {
                    const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                    const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                    
                    PBYTE pArgFrom = (PBYTE)m_pvArgs  + param.StackOffset;
                    PBYTE pArgTo   = (PBYTE)pDstFrame->m_pvArgs  + param.StackOffset;
                    
                    if (fShareMemory && CanShareParameter(iparam))
                    {
                        //
                        // We just snarf the actual stack contents, whatever type that happens to be
                        //
                        ULONG cbParam = CbParam(iparam, param);
                        CopyMemory(pArgTo, pArgFrom, cbParam);
                        continue;
                    }
                    
                    m_fWorkingOnInParam  = paramAttr.IsIn;
                    m_fWorkingOnOutParam = paramAttr.IsOut;
                    
                    if (paramAttr.IsIn)
                    {
                        //
                        // We are an [in] or an [in,out] parameter 
                        //
                        if (paramAttr.IsBasetype)
                        {
                            if (paramAttr.IsSimpleRef)
                            {
                                // The IsSimpleRef bit is set for a parameter which is a ref pointer to anything
                                // other than another pointer, and which has no allocate attributes. For such a type
                                // the parameter description's offset_to_type_description field (except for a ref 
                                // pointer to a basetype) gives the offset to the referent's type - the ref pointer is
                                // simply skipped.
                                //
                                // In the unmarshal case, what NDR does is simply refer into the incoming RPC
                                // buffer. We, here copying instead of unmarshalling, sort-of do that, but we 
                                // have to create a buffer on the fly.
                                //
                                if (fShareMemory)
                                {
                                    ASSERT(paramAttr.IsOut);                    // otherwise we'd catch it above
                                    //
                                    // In the sharing case, we can actually share pointers to simple out-data types. We
                                    // have to get the freeing and the NULLing logic to correspond, though.
                                    //
                                    CopyMemory(pArgTo, pArgFrom, sizeof(PVOID));
                                }
                                else
                                {
                                    ULONG cbParam = SIMPLE_TYPE_MEMSIZE(param.SimpleType.Type);
                                    void* pvParam = pDstFrame->AllocBuffer(cbParam);
                                    CopyMemory(pvParam, *((PVOID*)pArgFrom), cbParam);
                                    *((PVOID *)pArgTo) = pvParam;
                                }
                            }
                            else
                            {
                                //
                                // It's just a normal, non pointer base type. Copy it over.
                                //
                                CopyBaseTypeOnStack(pArgTo, pArgFrom, param.SimpleType.Type);
                            }
                        }
                        else
                        {
                            //
                            // Else [in] or [in,out] parameter which is not a base type
                            //
                            // From NDR: "This is an initialization of [in] and [in,out] ref pointers to pointers.  
                            //            These can not be initialized to point into the rpc buffer and we want to 
                            //            avoid doing a malloc of 4 bytes!"
                            //
                            if (paramAttr.ServerAllocSize != 0 )
                            {
                                PVOID pv = pDstFrame->AllocBuffer(paramAttr.ServerAllocSize * 8); // will throw on oom
                                *((PVOID *)pArgTo) = pv;
                                ZeroMemory(pv, paramAttr.ServerAllocSize * 8);
                            }
                            //
                            // Actually carry out the copying
                            //
                            PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                            //
                            // We don't indirect on interface pointers, even though they are listed as not by value.
                            // In the copy routine, therefore, pMemoryFrom for interface pointers points to the location
                            // at which they reside instead of being the actual value.
                            //
                            BOOL  fByValue = ByValue(paramAttr, pFormatParam, TRUE);
                            pArgFrom = fByValue ? pArgFrom : *((PBYTE *)pArgFrom);
                            PBYTE* ppArgTo = fByValue ? &pArgTo  : (PBYTE*)pArgTo;
                            
                            CopyWorker(pArgFrom, ppArgTo, pFormatParam, FALSE);
                        }
                    }
                    else if (paramAttr.IsOut)
                    {
                        //
                        // An out-only parameter. We really have to allocate
                        // space in which callee can place his result.
                        //
                        ASSERT(!paramAttr.IsReturn);
                        ULONG cbParam = 0;
                        if (paramAttr.ServerAllocSize != 0)
                        {
                            cbParam = paramAttr.ServerAllocSize * 8;
                        }
                        else if (paramAttr.IsBasetype)
                        {
                            // cbParam = SIMPLE_TYPE_MEMSIZE(param.SimpleType.Type);
                            cbParam = 8;
                        }
                        
                        if (cbParam > 0)
                        {
                            void* pvParam = pDstFrame->AllocBuffer(cbParam);
                            ZeroMemory(pvParam, cbParam);
                            *((PVOID *)pArgTo) = pvParam;
                        }
                        else
                        {
                            PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                            OutInit(pDstFrame, (PBYTE*)pArgFrom, (PBYTE*)pArgTo, pFormatParam);
                        }
                    }
                }
            }
        }
    }
    __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
    {
        hr = GetExceptionCode();
        if(SUCCEEDED(hr))
        {
            hr = HrNt(hr);
            if (SUCCEEDED(hr))
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
            }
        }
    }
    
    //
    // Return allocated frame to caller and / or cleanup the new frame as needed
    //
    if (!hr)
    {
        ASSERT(pDstFrame->m_refs == 1);
        *ppFrame = static_cast<ICallFrame*>(pDstFrame);
    }
    else
    {
        *ppFrame = NULL;
        delete pDstFrame;
    }
    
    m_pAllocatorFrame = NULL;
    m_pWalkerCopy = NULL;
    ASSERT(!AnyWalkers());

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CallFrame::Free(ICallFrame* pframeArgsTo, ICallFrameWalker* pWalkerFreeDest, ICallFrameWalker* pWalkerCopy, 
                        DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags)
  // Copy out parameters and / or free data and / or null out parameters.
  //
{
    HRESULT hr = S_OK;

    __try
    {
        // Set up state so that worker routines can find it
        //
        m_StackTop = (PBYTE)m_pvArgs;
        ASSERT(!AnyWalkers());
        
        ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////
        //
        // Copy the out values to parent frame if requested.
        //
        if (pframeArgsTo)
        {
            pframeArgsTo->SetReturnValue((HRESULT)m_hrReturnValue);
            //
            // Find out the location of the destination stack
            //
            PVOID pvArgsTo = pframeArgsTo->GetStackLocation();
            //
            // Are we copying back to the guy with which we share things?
            //
            const BOOL fShareMemory = DoWeShareMemory() && m_pvArgsSrc == pvArgsTo;
            //
            // Loop through all of the parameters, looking for [in,out] or [out] parameters
            // that need to be propogated.
            //
            if (m_pmd->m_fCanShareAllParameters && fShareMemory)
            {
                // Nothing to copy up since we shared all the parameters in the first place
            }
            else 
            {
                ASSERT(m_pAllocatorFrame == NULL);
                CallFrame* pFrameTo = NULL;
                //
                //
                // Propogate parameter by parameter
                //
                for (ULONG iparam = 0; !hr && iparam < m_pmd->m_numberOfParams; iparam++)
                {
                    const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                    const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                    
                    if (!paramAttr.IsOut) continue;
                    ASSERT(!paramAttr.IsReturn);
                    
                    PBYTE pArgFrom = (PBYTE)m_pvArgs  + param.StackOffset;
                    PBYTE pArgTo   = (PBYTE)pvArgsTo  + param.StackOffset;
                    
                    if (fShareMemory && CanShareParameter(iparam))
                    {
                        // Nothing to copy up since we shared the parameter in the first place
                    }
                    else if (paramAttr.IsBasetype)
                    {
                        if (paramAttr.IsSimpleRef)
                        {
                            // We can simply blt the parameter back on over
                            //
                            ULONG cb = SIMPLE_TYPE_MEMSIZE(param.SimpleType.Type);
                            PVOID pvFrom = *((PVOID*)pArgFrom);
                            PVOID pvTo   = *((PVOID*)pArgTo);
                            CopyMemory(pvTo, pvFrom, cb);
                            ZeroMemory(pvFrom, cb);
                        }
                        else
                        {
                            NOTREACHED();
                        }
                    }
                    else
                    {
                        // Else is [in,out] or [out] parameter which is not a base type.
                        //
                        PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                        //
                        hr = pframeArgsTo->FreeParam(iparam, CALLFRAME_FREE_INOUT, pWalkerFreeDest, CALLFRAME_NULL_OUT | CALLFRAME_NULL_INOUT);
                        if (hr != S_OK) 
                        {
                            break;
                        }

                        //
                        // Create a simple walker object on the stack.
                        //
                        SSimpleWalker SimpleWalker;                        
                        // Save the current walker.
                        //
                        ICallFrameWalker* pWalkerSave = m_pWalkerWalk;                        
                        // Set the walker so our simple walker gets called.
                        //
                        m_pWalkerWalk = &SimpleWalker;                        
                        // Transfer ownership of the out parameter, zero out our source copy
                        //
                        OutCopy( *((PBYTE*)pArgFrom), *((PBYTE*)pArgTo), pFormatParam );
                        // Replace the original walker.
                        //
                        m_pWalkerWalk = pWalkerSave;                                                        
                        //
                        // Walk any contained interface pointers, doing the copy call back on each of them
                        //
                        if (m_pmd->m_rgParams[iparam].m_fMayHaveInterfacePointers && pWalkerCopy)
                        {
                            // We don't indirect on interface pointers, even though they are listed as not by value.
                            // In the walk routine, therefore, pMemory for interface pointers points to the location
                            // at which they reside instead of being the actual value.
                            //
                            BYTE* pArg = ByValue(paramAttr, pFormatParam, FALSE) ? pArgTo : *((PBYTE*)pArgTo);
                            //
                            // Use internal methods on our helper frame to carry this out
                            //                    
                            GetFrame(pFrameTo, pvArgsTo)->m_pWalkerWalk = pWalkerCopy;
                            //
                            pFrameTo->m_fWorkingOnInParam    = paramAttr.IsIn;
                            pFrameTo->m_fWorkingOnOutParam   = paramAttr.IsOut;
                            pFrameTo->m_fPropogatingOutParam = TRUE;
                            //
                            pFrameTo->WalkWorker(pArg, pFormatParam);
                            pFrameTo->m_pWalkerWalk = NULL;
                            
                            SimpleWalker.ReleaseInterfaces();
                        }
                    }
                }
                
                delete pFrameTo;
                
                m_pAllocatorFrame = NULL;
            }
        }
        
        ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////
        //
        // Free the parameters (other than the this pointer) if we're asked to
        //
        if (freeFlags && !hr)
        {
            if (DoWeShareMemory() && m_pmd->m_fCanShareAllParameters)
            {
                // All parameters are shared with someone else. So we never free them, since
                // that someone else has the responsibility of doing so, not us.
            }
            else for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                ASSERT(!paramAttr.IsDontCallFreeInst);
                //
                if (DoWeShareMemory() && CanShareParameter(iparam))
                {
                    // This parameter is shared with someone else. So we never free it, since
                    // that someone else has the responsibility of doing so, not us.
                    continue;
                }
                
                // Are we in fact supposed to free this parameter?
                //
                BOOL fFreeData = 0;
                BOOL fFreeTop  = 0;
                
                if (paramAttr.IsIn)
                {
                    if (paramAttr.IsOut)                       
                    {
                        fFreeData   = (freeFlags & CALLFRAME_FREE_INOUT);
                        fFreeTop    = (freeFlags & CALLFRAME_FREE_TOP_INOUT);
                    }
                    else
                    {
                        fFreeData   = (freeFlags & CALLFRAME_FREE_IN);
                        fFreeTop    = fFreeData;
                    }
                }
                else if (paramAttr.IsOut)
                {
                    fFreeData   = (freeFlags & CALLFRAME_FREE_OUT);
                    fFreeTop    = (freeFlags & CALLFRAME_FREE_TOP_OUT);
                }
                else
                    NOTREACHED();
                
                if ( !(fFreeData || fFreeTop) ) continue;
                //
                // Yes we are supposed to free it. Find out where it is.
                //
                PBYTE pArg = (PBYTE)m_pvArgs + param.StackOffset;
                //
                // Remember this?
                //
                // "The IsSimpleRef bit is set for a parameter which is a ref pointer to anything
                // other than another pointer, and which has no allocate attributes. For such a type
                // the parameter description's offset_to_type_description field (except for a ref 
                // pointer to a basetype) gives the offset to the referent's type - the ref pointer is
                // simply skipped."
                //
                // This means we have to handle the freeing of the top level pointer as a special case.
                // We also have to explicitly free arrays and strings, or so NDR says (why?).
                //
                if (paramAttr.IsBasetype)
                {
                    if (paramAttr.IsSimpleRef && fFreeTop)
                    {
                        Free( *(PVOID*)pArg );
                    }
                    else
                    {
                        // Nothing to do. Just a simple parameter on the stack
                    }
                }
                else
                {
                    PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                    BOOL fByValue = ByValue(paramAttr, pFormatParam, FALSE);
                    PBYTE pMemory = fByValue ? pArg : *((PBYTE*)pArg);
                    if (pMemory) 
                    {
                        m_fWorkingOnInParam  = paramAttr.IsIn;
                        m_fWorkingOnOutParam = paramAttr.IsOut;
                        m_pWalkerFree = pWalkerFree;
                        //
                        // Carry out the freeing of the pointed to data
                        //
                        __try
                        {
                            FreeWorker(pMemory, pFormatParam, !fByValue && fFreeTop);
                            //
                            // Free the top level pointer
                            //
                            if (!fByValue && fFreeTop && (paramAttr.IsSimpleRef || IS_ARRAY_OR_STRING(*pFormatParam)))
                            {
                                // REVIEW: Why exactly do we need to do this for arrays and strings? For now we
                                //         do it just because NDR does. We DO believe it's necessary, but we just
                                //         don't exactly understand in which particular situations.
                                //
                                Free(pMemory);
                            }
                        }
                        __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
                        {
                            // Remember the bad HR, but don't do anything about it yet.
                            //
                            // It will just fall out of this loop.
                            hr = HrNt(GetExceptionCode());
                            if (SUCCEEDED(hr))
                                hr = HRESULT_FROM_WIN32(GetLastError());
                        }

                        //
                        m_pWalkerFree = NULL;
                    }
                }
            }
        }
        
        ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////
        //
        // NULL out parameters if requested
        //
        if (nullFlags && !hr)
        {
            for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                
                if (paramAttr.IsIn)
                {
                    if (paramAttr.IsOut)                       
                    {
                        if (!(nullFlags & CALLFRAME_NULL_INOUT)) continue;
                    }
                    else
                        continue;
                }
                else if (paramAttr.IsOut)
                {
                    if (!(nullFlags & CALLFRAME_NULL_OUT)) continue;
                }
                
                ASSERT(!paramAttr.IsReturn);
                
                if (paramAttr.IsBasetype)
                {
                    if (paramAttr.IsSimpleRef)
                    {
                        // Out pointer to base type. Don't have to zero these; indeed, musn't.
                    }
                    else
                    {
                        // It's just a base type on the stack, which is never an out parameter
                    }
                }
                else
                {
                    // Else [in,out] or [out] parameter which is not a base type
                    //
                    PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                    PBYTE pArg = (PBYTE)m_pvArgs + param.StackOffset;
                    OutZero( *((PBYTE*)pArg), pFormatParam );
                }
            }
        }
    }
    __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
    {
        hr = GetExceptionCode();
        if(SUCCEEDED(hr))
        {
            hr = HrNt(hr);
            if (SUCCEEDED(hr))
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
            }
        }
    }
    
    ASSERT(!AnyWalkers());
    return hr;
}


HRESULT CallFrame::FreeParam(ULONG iparam, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags)
  // Free a particular parameter to this invocation
{
    HRESULT hr = S_OK;
        
    const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
    const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
        
    if (freeFlags)
    {
        //
        // Are we in fact supposed to free this parameter?
        //
        BOOL fFreeData = 0;
        BOOL fFreeTop  = 0;
                
        if (paramAttr.IsIn)
        {
            if (paramAttr.IsOut)                       
            {
                fFreeData   = (freeFlags & CALLFRAME_FREE_INOUT);
                fFreeTop    = (freeFlags & CALLFRAME_FREE_TOP_INOUT);
            }
            else
            {
                fFreeData   = (freeFlags & CALLFRAME_FREE_IN);
                fFreeTop    = fFreeData;
            }
        }
        else if (paramAttr.IsOut)
        {
            fFreeData   = (freeFlags & CALLFRAME_FREE_OUT);
            fFreeTop    = (freeFlags & CALLFRAME_FREE_TOP_OUT);
        }
        else
            NOTREACHED();

        if (fFreeData || fFreeTop)
        {
            // Yep, we're to free it all right
            //
            PBYTE pArg = (PBYTE)m_pvArgs + param.StackOffset;
            //
            if (paramAttr.IsBasetype)
            {
                if (paramAttr.IsSimpleRef && fFreeTop)
                {
                    Free( *(PVOID*)pArg );
                }
                else
                {
                    // Nothing to do. Just a simple parameter on the stack
                }
            }
            else
            {
                PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                BOOL fByValue = ByValue(paramAttr, pFormatParam, FALSE);
                PBYTE pMemory = fByValue ? pArg : *((PBYTE*)pArg);
                if (pMemory) 
                {
                    ICallFrameWalker* pWalkerFreePrev = m_pWalkerFree;
                    m_pWalkerFree = pWalkerFree;
                    //
                    m_fWorkingOnInParam  = paramAttr.IsIn;
                    m_fWorkingOnOutParam = paramAttr.IsOut;
                    //
                    // Carry out the freeing of the pointed to data
                    //
                    __try
                    {
                        FreeWorker(pMemory, pFormatParam, !fByValue && fFreeTop);
                        //
                        // Free the top level pointer
                        //
                        if (!fByValue && fFreeTop && (paramAttr.IsSimpleRef || IS_ARRAY_OR_STRING(*pFormatParam)))
                        {
                            // REVIEW: Why exactly do we need to do this for arrays and strings? For now we
                            //         do it just because NDR does. We DO believe it's necessary, but we just
                            //         don't exactly understand in which particular situations.
                            //
                            Free(pMemory);
                        }
                    }
                    __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
                    {
                        hr = HrNt(GetExceptionCode());
                        if (SUCCEEDED(hr))
                            hr = HRESULT_FROM_WIN32(GetLastError());
                    }

                    //
                    m_pWalkerFree = pWalkerFreePrev;
                }
            }
        }
    }

    if (nullFlags)
    {
        do  
        {
            if (paramAttr.IsIn)
            {
                if (paramAttr.IsOut)                       
                {
                    if (!(nullFlags & CALLFRAME_NULL_INOUT)) break;
                }
                else
                    break;
            }
            else if (paramAttr.IsOut)
            {
                if (!(nullFlags & CALLFRAME_NULL_OUT)) break;
            }
                        
            ASSERT(!paramAttr.IsReturn);
                        
            if (paramAttr.IsBasetype)
            {
                if (paramAttr.IsSimpleRef)
                {
                    // Out pointer to base type. Don't have to zero these; indeed, musn't.
                }
                else
                {
                    // It's just a base type on the stack, which is never an out parameter
                }
            }
            else
            {
                // Else [in,out] or [out] parameter which is not a base type
                //
                PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                PBYTE pArg = (PBYTE)m_pvArgs + param.StackOffset;
                OutZero( *((PBYTE*)pArg), pFormatParam );
            }
        }
        while (FALSE);
    }
        
    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#if defined(_X86_)

HRESULT CallFrame::Invoke(PVOID pvReceiver, ...)
  // Invoke ourselves on the given frame
{
#ifdef DBG
    if (m_fAfterCall)
    {
        ASSERT(!m_pmd->m_info.fHasOutValues);
    }
#endif

    //
    // Figure out the function which is to be invoked
    //
    typedef HRESULT (__stdcall* PFN)(void);
    PFN pfnToCall = ((HRESULT (__stdcall***)(void))pvReceiver)[0][m_pmd->m_iMethod];
    //
    // Allocate space for the callee's stack frame. We ignore stack overflow
    // exceptions that may come here, for if we're that close to the stack 
    // limit, then we'll be hitting it anyway really soon now just in the normal
    // course of calling things.
    //
    PVOID pvArgsCopy = _alloca(m_pmd->m_cbPushedByCaller);
    //
    // Copy the caller stack frame to the top of the current stack.
    // This code assumes (dangerously) that the alloca'd copy of the
    // actual arguments is at [esp].
    //
    memcpy(pvArgsCopy, m_pvArgs, m_pmd->m_cbPushedByCaller);
    //
    // Push the receiver
    //
    *((PVOID*)pvArgsCopy) = pvReceiver;
    //
    // Carry out the call!
    //
    if (m_pmd->m_optFlags.HasReturn)
        m_hrReturnValue = (*pfnToCall)();
    else
    {
        (*pfnToCall)();
        m_hrReturnValue = S_OK;
    }
#ifdef DBG
    m_fAfterCall = TRUE;
#endif
    return S_OK;
}

#endif

#if defined(_AMD64_)

typedef _int64 (__RPC_API * MANAGER_FUNCTION)(void);

// Invoke defined in amd64\stubless.asm
extern "C"
REGISTER_TYPE Invoke(
    MANAGER_FUNCTION pFunction, 
    REGISTER_TYPE *pvArgs, 
    ULONG cArguments);

HRESULT CallFrame::Invoke(PVOID pvReceiver, ...)
  // Invoke ourselves on the given frame
{
#ifdef DBG
    if (m_fAfterCall)
    {
        ASSERT(!m_pmd->m_info.fHasOutValues);
    }
#endif
    //
    // Figure out the function which is to be invoked
    //
    typedef HRESULT (*const PFN)(void);
    typedef HRESULT (***INTERFACE_PFN)(void);
    PFN pfnToCall = ((INTERFACE_PFN)pvReceiver)[0][m_pmd->m_iMethod];
    //
    // Allocate space for the caller argument list. We ignore stack overflow
    // exceptions that may come here, for if we're that close to the stack 
    // limit, then we'll be hitting it anyway really soon now just in the
    // normal course of calling things.
    //
    REGISTER_TYPE *pArgumentList = (REGISTER_TYPE *)_alloca(m_pmd->m_cbPushedByCaller);
    //
    // Copy the caller argument list to the allocated area.
    //
    memcpy(pArgumentList, m_pvArgs, m_pmd->m_cbPushedByCaller);
    //
    // Insert the receiver as the first argument in the argument list.
    //
    *pArgumentList = (REGISTER_TYPE)pvReceiver;
    //
    // Carry out the call!
    //
    m_hrReturnValue = (HRESULT)::Invoke((MANAGER_FUNCTION)pfnToCall,
                                        pArgumentList,
                                        m_pmd->m_cbPushedByCaller / sizeof(REGISTER_TYPE));
    if (!m_pmd->m_optFlags.HasReturn)
    {
        m_hrReturnValue = S_OK;
    }
#ifdef DBG
    m_fAfterCall = TRUE;
#endif
    return S_OK;
}

#endif

#ifdef IA64

////////////////////////////////////////////////////////////////////////////////////
//
// Invocation utilities
//

extern "C"
void __stdcall FillFPRegsForIA64( REGISTER_TYPE* pStack, ULONG FloatMask);

#include <ia64reg.h>
#include <kxia64.h>

extern "C" {
unsigned __int64 __getReg (int);
#pragma intrinsic (__getReg)
}

LPVOID pvGlobalSideEffect = NULL;

HRESULT CallFrame::Invoke(PVOID pvReceiver, ...)
  // Invoke ourselves on the given frame. Invoking on the IA64 is
  // a bit tricky, since we have to treat the first set of arguments
  // specially.
  //
  // This code was taken from the MTS 1.0 context wrapper code, originally
  // written by Jan Gray.
  //
{
#ifdef DBG
    if (m_fAfterCall)
    {
        ASSERT(!m_pmd->m_info.fHasOutValues);
    }
#endif

    // Figure out the function which is to be invoked
    //
    typedef HRESULT (*const PFN)      (__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64);
    typedef HRESULT (***INTERFACE_PFN)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64);
    PFN pfnToCall = ((INTERFACE_PFN)pvReceiver)[0][m_pmd->m_iMethod];

    const DWORD cqArgs = m_pmd->m_cbPushedByCaller / 8; // no. of arguments (each a quadword)

    // Setup the call stack and argument registers.
    //
    // Each argument fills a 64b slot, regardless of its actual size.  
    // Arguments [0..7] sit in registers r32 through r39, and the 
    // remainder of the arguments sit at sp+STACK_SCRATCH_AREA.  So our 
    // strategy for building the stack is:
    //
    //   1. alloca space for the extra arguments, if any.  This pushes
    //      the value of the sp register up by the amount we alloca.
    //      This will be the top of the stack for the function we call.
    //   2. Get the value of sp after the alloca, using the magic 
    //      intrinsic function __getReg.  Add STACK_SCRATCH_AREA to
    //      it, and we've got the address where the 8th parameter is
    //      supposed to sit.
    //   3. Copy the arguments [8..] into the buffer at the top of
    //      the stack.
    //
    // JOHNDOTY: This is a bit too magical for me.  I would rather see
    //           this function re-written in assembly, I think.
    //
    // Initialize a[] to address the arguments.
    //
    __int64 *const a = (__int64*)m_pvArgs;

    // Ensure there is space for any args past the 8th arg.
    //
    DWORD cbExtra = m_pmd->m_cbPushedByCaller > 64 ? 
      (m_pmd->m_cbPushedByCaller - 64 + STACK_SCRATCH_AREA) : 0;
    pvGlobalSideEffect = alloca(cbExtra);

    // Copy args [8..] to the stack, at 0(sp+16), 8(sp+16), ... . Note we copy them in first 
    // to last order so that stack faults (if any) occur in the right order.
    //
    __int64 *const sp = (__int64 *)(__getReg(CV_IA64_IntSp) + STACK_SCRATCH_AREA);
    for (DWORD iarg = cqArgs - 1; iarg >= 8; --iarg)
    {
        sp[iarg-8] = a[iarg];
    }

    //
    // Establish F8-F15 with the original caller's fp arguments.
    //
    if (m_pmd->m_pHeaderExts)
    {
        // ASSUMPTION: If we're on Win64, this is going to be NDR_PROC_HEADER_EXTS64.
        // That seems to be what the NDR code assumes.
        PNDR_PROC_HEADER_EXTS64 exts = (PNDR_PROC_HEADER_EXTS64)m_pmd->m_pHeaderExts;
        FillFPRegsForIA64((REGISTER_TYPE *)m_pvArgs, exts->FloatArgMask);
    }

    // Call method, establishing A0-A7 with the original caller's integer arguments.
    //
    if (m_pmd->m_optFlags.HasReturn)
        m_hrReturnValue = (*pfnToCall)((__int64)pvReceiver, a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
    else
    {
        (*pfnToCall)((__int64)pvReceiver, a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
        m_hrReturnValue = S_OK;
    }

#ifdef DBG
    m_fAfterCall = TRUE;
#endif
    return S_OK;
}

#endif

///////////////////////////////////////////////////////////////////////////////////////
//
// Miscellaneous
//
///////////////////////////////////////////////////////////////////////////////////////

HRESULT CallFrame::QueryInterface(REFIID iid, void** ppv)
{
    if (iid == __uuidof(ICallFrame) || iid == __uuidof(IUnknown))
    {
        *ppv = (ICallFrame*) this;
    }
    else if (iid == __uuidof(ICallFrameInit))
    {
        *ppv = (ICallFrameInit*) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*) *ppv)->AddRef();
    return S_OK;
}


HRESULT CallFrame::GetInfo(CALLFRAMEINFO *pInfo)
{
    *pInfo = m_pmd->m_info;
    if (m_pInterceptor->m_pmdMostDerived)
    {
        pInfo->iid     = *m_pInterceptor->m_pmdMostDerived->m_pHeader->piid;
        pInfo->cMethod =  m_pInterceptor->m_pmdMostDerived->m_pHeader->DispatchTableCount;

#ifdef DBG
        //
        // Since neither of us is the actual IDispatch interceptor, we should agree
        // in our readings of derivability
        //
        ASSERT(!!pInfo->fDerivesFromIDispatch == !!m_pInterceptor->m_pmdMostDerived->m_fDerivesFromIDispatch);
#endif
    }
    return S_OK;
}

HRESULT CallFrame::GetParamInfo(ULONG iparam, CALLFRAMEPARAMINFO* pInfo)
{
    HRESULT hr = S_OK;

    if (iparam < m_pmd->m_numberOfParams)
    {
        const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
        const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;

        pInfo->fIn         = (BOOLEAN) (paramAttr.IsIn ? TRUE : FALSE);
        pInfo->fOut        = (BOOLEAN) (paramAttr.IsOut ? TRUE : FALSE);
        pInfo->stackOffset = param.StackOffset;
        pInfo->cbParam     = CbParam(iparam, param);
    }
    else
    {
        Zero(pInfo);
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CallFrame::GetParam(ULONG iParam, VARIANT* pvar)    
{
    HRESULT hr = S_OK;
    unsigned short vt;

    if (pvar == NULL)
        return E_POINTER;


    VariantInit(pvar);

    const PARAM_DESCRIPTION& param = m_pmd->m_params[iParam];

    BYTE* stackLocation = (BYTE*)GetStackLocation();
    stackLocation += param.StackOffset;

    // A temporary VARIANT that points into our stack.  Must be VariantCopy'd before
    // being sent back.
    VARIANT varTemp;
    VariantInit(&varTemp);

    int iMethod = m_pmd->m_info.iMethod;

    METHOD_DESCRIPTOR& descriptor = m_pInterceptor->m_ptypeinfovtbl->m_rgMethodDescs[iMethod];
    if (iParam >= (ULONG)descriptor.m_cParams)
        return DISP_E_BADPARAMCOUNT;
    vt = varTemp.vt = descriptor.m_paramVTs[iParam];

    // VT_ARRAY is not a specific type, however, everything marked with VT_ARRAY
    // needs to be handled the same way.  What it's an array *of* is not 
    // important.
    if (vt & VT_ARRAY)
    {
        // Remove the type bits.  (This leaves VT_BYREF, etc.)
        vt = (VARTYPE) (vt & ~VT_TYPEMASK);
    }

    switch (vt)
    {
    case VT_DECIMAL:
        memcpy(&varTemp.decVal, stackLocation, sizeof varTemp.decVal);
        break;
                
    case VT_VARIANT:
    {
        // The parameter at the specified stack location is a VARIANT.  We
        // allocate a VARIANT, copy the VARIANT from the stack location
        // into it, and make the VARIANT supplied by the caller a BYREF
        // that points to the one we allocate.
            
        VARIANT* pvarNew = (VARIANT*)CoTaskMemAlloc(sizeof(VARIANT));
        if (!pvarNew)
            return E_OUTOFMEMORY;
        
        VariantInit(pvarNew);
            
        VARIANT* pvarStack = (VARIANT*)stackLocation;
            
        pvarNew->vt = pvarStack->vt;
            
        memcpy(&pvarNew->lVal, &pvarStack->lVal, sizeof(VARIANT) - (sizeof(WORD) * 4));
            
        varTemp.vt |= VT_BYREF;
        varTemp.pvarVal = pvarNew;
           
        break;
    }

    case VT_I4:
    case VT_UI1:
    case VT_I2:
    case VT_R4:
    case VT_R8:
    case VT_BOOL:
    case VT_ERROR:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_UNKNOWN:
    case VT_DISPATCH:
    case VT_ARRAY:
    case VT_BYREF|VT_UI1:
    case VT_BYREF|VT_I2:
    case VT_BYREF|VT_I4:
    case VT_BYREF|VT_R4:
    case VT_BYREF|VT_R8:
    case VT_BYREF|VT_BOOL:
    case VT_BYREF|VT_ERROR:
    case VT_BYREF|VT_CY:
    case VT_BYREF|VT_DATE:
    case VT_BYREF|VT_BSTR:
    case VT_BYREF|VT_UNKNOWN:
    case VT_BYREF|VT_DISPATCH:
    case VT_BYREF|VT_ARRAY:
    case VT_BYREF|VT_VARIANT:
    case VT_BYREF:
    case VT_I1:
    case VT_UI2:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_BYREF|VT_DECIMAL:
    case VT_BYREF|VT_I1:
    case VT_BYREF|VT_UI2:
    case VT_BYREF|VT_UI4:
    case VT_BYREF|VT_INT:
    case VT_BYREF|VT_UINT:
    case VT_BYREF|VT_RECORD:
    case VT_RECORD:
        // All these start at the same place within the VARIANT, I arbitrarily chose .lVal.
        memcpy(&varTemp.lVal, stackLocation, CbParam(iParam, param));
        break;
                
    default:
        return DISP_E_BADVARTYPE;
    }
        
    hr = (g_oa.get_VariantCopy())(pvar, &varTemp);
    // Don't clear varTemp... it doesn't own any of its data.
        
    return hr;
}

HRESULT CallFrame::SetParam(ULONG iParam, VARIANT* pvar)
{
    return E_NOTIMPL;
}

HRESULT CallFrame::GetIIDAndMethod(IID* piid, ULONG* piMethod)
{
    if (piid)
    {
        if (m_pInterceptor->m_pmdMostDerived)
        {
            *piid = *m_pInterceptor->m_pmdMostDerived->m_pHeader->piid;
        }
        else
        {
            *piid = *m_pmd->m_pHeader->piid;
        }
    }
    if (piMethod)   *piMethod = m_pmd->m_iMethod;
    return S_OK;
}

HRESULT CallFrame::GetNames(LPWSTR* pwszInterface, LPWSTR* pwszMethod)
{
    HRESULT hr = S_OK;

    if (pwszInterface)
    {
        hr = m_pInterceptor->GetIID((IID*)NULL, (BOOL*)NULL, (ULONG*)NULL, pwszInterface);
    }

    if (pwszMethod)
    {
        CALLFRAMEINFO info;
        hr = m_pInterceptor->GetMethodInfo(m_pmd->m_iMethod, &info, pwszMethod);
    }

    return hr;
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////



inline HRESULT ProxyInitialize(CALLFRAME_MARSHALCONTEXT *pcontext, MarshallingChannel* pChannel, RPC_MESSAGE* pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg, PMIDL_STUB_DESC pStubDescriptor, ULONG ProcNum)
  // Modelled after NdrProxyInitialize
{
    HRESULT hr = S_OK;

    pStubMsg->dwStubPhase = PROXY_CALCSIZE;

    NdrClientInitializeNew(pRpcMsg, pStubMsg, pStubDescriptor, ProcNum);

    pRpcMsg->ProcNum &= ~RPC_FLAGS_VALID_BIT;

    if (pChannel)
    {
        pChannel->m_dwDestContext = pcontext->dwDestContext;
        pChannel->m_pvDestContext = pcontext->pvDestContext;
        
        if (pcontext->punkReserved)
        {
            IMarshallingManager *pMgr;
            hr = pcontext->punkReserved->QueryInterface(IID_IMarshallingManager, (void **)&pMgr);
            if (SUCCEEDED(hr))
            {
                ::Set(pChannel->m_pMarshaller, pMgr);
                pMgr->Release();
            }
        }
        hr = S_OK;
        
        ASSERT(pChannel->m_refs == 1);
        pStubMsg->pRpcChannelBuffer = pChannel;
        pChannel->GetDestCtx(&pStubMsg->dwDestContext, &pStubMsg->pvDestContext);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT CallFrame::GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pcontext, MSHLFLAGS mshlflags, ULONG *pcbBufferNeeded)
  // Execute the sizing pass on marshalling this call frame
  //
{ 
    HRESULT hr = S_OK;
    RPC_MESSAGE         rpcMsg;
    MIDL_STUB_MESSAGE   stubMsg;
    void               *pCorrInfo = alloca(NDR_DEFAULT_CORR_CACHE_SIZE);
    MarshallingChannel  channel;

#ifdef DBG
    ASSERT(pcontext && (pcontext->fIn ? !m_fAfterCall : TRUE));                         // not allowed to marshal in params after call has been made
#endif

    hr = ProxyInitialize(pcontext, &channel, &rpcMsg, &stubMsg, GetStubDesc(), m_pmd->m_iMethod);

    if (!hr)
    {
        stubMsg.RpcMsg->RpcFlags = m_pmd->m_rpcFlags;                                   // Set Rpc flags after the call to client initialize.
        stubMsg.StackTop         = (BYTE*)m_pvArgs;
        //
        // Need to deal with things the extensions, if they exist.
        // Stolen from RPC.
        //
        if (m_pmd->m_pHeaderExts)
        {
            stubMsg.fHasExtensions = 1;
            stubMsg.fHasNewCorrDesc = m_pmd->m_pHeaderExts->Flags2.HasNewCorrDesc;

            if (pcontext->fIn ? (m_pmd->m_pHeaderExts->Flags2.ClientCorrCheck)
                : (m_pmd->m_pHeaderExts->Flags2.ServerCorrCheck))
            {
                NdrCorrelationInitialize( &stubMsg,
                                          (unsigned long *)pCorrInfo,
                                          NDR_DEFAULT_CORR_CACHE_SIZE,
                                          0 /* flags */ );
            }
        }

        //
        // Figure out the constant-part of the size as emitted by the compiler
        //
        stubMsg.BufferLength = pcontext->fIn ? m_pmd->m_cbClientBuffer : m_pmd->m_cbServerBuffer; // Get the compile time computed buffer size.
        //
        // If there's more, then add that in too
        //
        if (pcontext->fIn ? m_pmd->m_optFlags.ClientMustSize : m_pmd->m_optFlags.ServerMustSize)
        {
            // Make sure that marshalling is done in the requested form
            //
            __try // catch exceptions thrown during sizing parameters
            {
                for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
                {
                    const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                    const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                    //
                    m_fWorkingOnInParam  = paramAttr.IsIn;
                    m_fWorkingOnOutParam = paramAttr.IsOut;
                    //
                    if ((pcontext->fIn ? paramAttr.IsIn : paramAttr.IsOut) && paramAttr.MustSize)
                    {
                        PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                        BYTE* pArg = (BYTE*)m_pvArgs + param.StackOffset;
                        if (!paramAttr.IsByValue)
                        {
                            pArg = *(PBYTE*)pArg;
                        }
                        NdrTypeSize(&stubMsg, pArg, pFormatParam);
                    }
                }
                //
                // Don't forget the size of the return value
                //
                if (pcontext->fIn && m_pmd->m_optFlags.HasReturn)
                {
                    const PARAM_DESCRIPTION& param   = m_pmd->m_params[m_pmd->m_numberOfParams];
                    const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                    //
                    // Compiler should always include this in the constant calculation so we
                    // should never have to actually do anything
                    //
                    ASSERT(!paramAttr.MustSize);
                }
            }
            __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
            {
                hr = GetExceptionCode();
                if(SUCCEEDED(hr))
                {
                    hr = HrNt(hr);
                    if (SUCCEEDED(hr))
                    {                        
                        hr = HRESULT_FROM_WIN32(GetExceptionCode());
                    }
                }
            }
        }
    }

    if (!hr)
        *pcbBufferNeeded = stubMsg.BufferLength;
    else
        *pcbBufferNeeded = 0;

    return hr;
}

///////////////////////////////////////////////////////////////////

inline void CallFrame::MarshalParam(MIDL_STUB_MESSAGE& stubMsg, ULONG iParam, const PARAM_DESCRIPTION& param, const PARAM_ATTRIBUTES paramAttr, PBYTE pArg)
{
    if (paramAttr.IsBasetype)
    {
        if (paramAttr.IsSimpleRef)
        {
            // Pointer to base type
            pArg = *((PBYTE*)pArg);
        }

        if (param.SimpleType.Type == FC_ENUM16)
        {
            if ( *((int *)pArg) & ~((int)0x7fff) )
                Throw(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
        }
        ALIGN (stubMsg.Buffer,       SIMPLE_TYPE_ALIGNMENT(param.SimpleType.Type));
        memcpy(stubMsg.Buffer, pArg, SIMPLE_TYPE_BUFSIZE  (param.SimpleType.Type));
        stubMsg.Buffer +=            SIMPLE_TYPE_BUFSIZE  (param.SimpleType.Type);
    }
    else
    {
        if (!paramAttr.IsByValue)
        {
            pArg = *((PBYTE*)pArg);
        }
        PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
        NdrTypeMarshall(&stubMsg, pArg, pFormatParam);
    }
}

///////////////////////////////////////////////////////////////////


HRESULT CallFrame::Marshal(CALLFRAME_MARSHALCONTEXT *pcontext, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer, ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags)
  // Marshal this call frame
{ 
    HRESULT hr = S_OK;
    RPC_MESSAGE         rpcMsg;
    MIDL_STUB_MESSAGE   stubMsg;
    void               *pCorrInfo = alloca(NDR_DEFAULT_CORR_CACHE_SIZE);
    MarshallingChannel  channel;

    ASSERTMSG("marshalling buffer misaligned", ((ULONG_PTR)pBuffer & 0x07) == 0);

    hr = ProxyInitialize(pcontext, &channel, &rpcMsg, &stubMsg, GetStubDesc(), m_pmd->m_iMethod);
    if (!hr)
    {
        stubMsg.RpcMsg->RpcFlags = m_pmd->m_rpcFlags;
        stubMsg.StackTop         = (BYTE*)m_pvArgs;
        stubMsg.BufferLength     = cbBuffer;
        stubMsg.Buffer           = (BYTE*)pBuffer;
        stubMsg.fBufferValid     = TRUE;
        stubMsg.dwStubPhase      = pcontext->fIn ? (DWORD)PROXY_MARSHAL : (DWORD)STUB_MARSHAL;

        stubMsg.RpcMsg->Buffer              = stubMsg.Buffer;
        stubMsg.RpcMsg->BufferLength        = stubMsg.BufferLength;
        stubMsg.RpcMsg->DataRepresentation  = NDR_LOCAL_DATA_REPRESENTATION;

        //
        // Need to deal with things the extensions, if they exist.
        // Stolen from RPC.
        //
        if (m_pmd->m_pHeaderExts)
        {
            stubMsg.fHasExtensions = 1;
            stubMsg.fHasNewCorrDesc = m_pmd->m_pHeaderExts->Flags2.HasNewCorrDesc;

            if (m_pmd->m_pHeaderExts->Flags2.ClientCorrCheck)
            {
                NdrCorrelationInitialize( &stubMsg,
                                          (unsigned long *)pCorrInfo,
                                          NDR_DEFAULT_CORR_CACHE_SIZE,
                                          0 /* flags */ );
            }
        }
        else
        {
            stubMsg.fHasExtensions = 0;
            stubMsg.fHasNewCorrDesc = 0;
        }

        __try
        {
            //
            // Marshal everything that we're asked to
            //
            for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                //
                m_fWorkingOnInParam  = paramAttr.IsIn;
                m_fWorkingOnOutParam = paramAttr.IsOut;
                //
                if (pcontext->fIn ? paramAttr.IsIn : paramAttr.IsOut)
                {
                    PBYTE pArg = (PBYTE)m_pvArgs + param.StackOffset;
                    MarshalParam(stubMsg, iparam, param, paramAttr, pArg);
                }
            }
            //
            // Marshal the return value if we have one
            //
            if (!pcontext->fIn && m_pmd->m_optFlags.HasReturn)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[m_pmd->m_numberOfParams];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                PBYTE pArg                       = (BYTE*)&m_hrReturnValue;
                MarshalParam(stubMsg, iparam, param, paramAttr, pArg);
            }
            
        }
        __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
        {
            // 
            // REVIEW: Ideally we'd clean up the interface references (a la ReleaseMarshalData) that lie within 
            // the marshalling buffer that we've so far managed to construct. Not doing this can in theory at
            // least lead to resource leakage caused by interface references sticking around longer than they
            // need to. But the NDR library doesn't do this (see NdrClientCall2), so, for now at least, neither do we.
            //            
            hr = GetExceptionCode();
            if(SUCCEEDED(hr))
            {
                hr = HrNt(hr);
                if (SUCCEEDED(hr))
                {
                    hr = HRESULT_FROM_WIN32(GetExceptionCode());
                }
            }
        }
    }

    if (pdataRep)   *pdataRep  = NDR_LOCAL_DATA_REPRESENTATION;
    if (prpcFlags)  *prpcFlags = m_pmd->m_rpcFlags;

    if (!hr)
    {
        if (pcbBufferUsed) *pcbBufferUsed = (ULONG)(((BYTE *)stubMsg.Buffer) - ((BYTE *)pBuffer));
    }
    else
    {
        if (pcbBufferUsed) *pcbBufferUsed = 0;
    }

    return hr;
}

///////////////////////////////////////////

inline void CallFrame::UnmarshalParam(MIDL_STUB_MESSAGE& stubMsg, const PARAM_DESCRIPTION& param, const PARAM_ATTRIBUTES paramAttr, PBYTE pArg)
{
    ASSERT(paramAttr.IsOut);

    if (paramAttr.IsBasetype)
    {
        if (paramAttr.IsSimpleRef)
            pArg = *(PBYTE*)pArg;

        if (param.SimpleType.Type == FC_ENUM16)
        {
            *((int *)(pArg)) = *((int *)pArg) & ((int)0x7fff);  // there's only 16 bits worth (15 bits?) in the buffer
        }

        ALIGN(stubMsg.Buffer, SIMPLE_TYPE_ALIGNMENT(param.SimpleType.Type));
        memcpy(pArg, stubMsg.Buffer, SIMPLE_TYPE_BUFSIZE(param.SimpleType.Type));
        stubMsg.Buffer += SIMPLE_TYPE_BUFSIZE(param.SimpleType.Type);
    }
    else
    {
        PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
        //
        // Transmit/Represent as can be passed as [out] only, thus the IsByValue check.
        //
        NdrTypeUnmarshall(
            &stubMsg, 
            param.ParamAttr.IsByValue ? &pArg : (uchar **) pArg,
            pFormatParam,
            FALSE);
    }
}

///////////////////////////////////////////

HRESULT CallFrame::Unmarshal(PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pcontext, ULONG* pcbUnmarshalled)
  // Unmarshal out values in the indicated buffer into our already existing call frame
{
    HRESULT hr = S_OK;
    RPC_MESSAGE         rpcMsg;
    MIDL_STUB_MESSAGE   stubMsg;
    void               *pCorrInfo = alloca(NDR_DEFAULT_CORR_CACHE_SIZE);
    MarshallingChannel  channel;

    ASSERTMSG("unmarshalling buffer misaligned", ((ULONG_PTR)pBuffer & 0x07) == 0);

    ASSERT(m_pvArgs);
#ifdef DBG
    ASSERT(!m_fAfterCall);      // that would have init'd the out params
#endif

    hr = ProxyInitialize(pcontext, &channel, &rpcMsg, &stubMsg, GetStubDesc(), m_pmd->m_iMethod);
    if (!hr)
    {
        stubMsg.RpcMsg->RpcFlags = m_pmd->m_rpcFlags;
        stubMsg.StackTop         = (BYTE*)m_pvArgs;
        stubMsg.BufferLength     = cbBuffer;
        stubMsg.Buffer           = (BYTE*)pBuffer;
        stubMsg.BufferStart      = (BYTE*)pBuffer;
        stubMsg.BufferEnd        = ((BYTE*)pBuffer) + cbBuffer;
        stubMsg.fBufferValid     = TRUE;
        stubMsg.dwStubPhase      = PROXY_UNMARSHAL;

        stubMsg.RpcMsg->Buffer              = stubMsg.Buffer;
        stubMsg.RpcMsg->BufferLength        = stubMsg.BufferLength;
        stubMsg.RpcMsg->DataRepresentation  = dataRep;
        

        //
        // Need to deal with things the extensions, if they exist.
        // Stolen from RPC.
        //
        if (m_pmd->m_pHeaderExts)
        {
            stubMsg.fHasExtensions = 1;
            stubMsg.fHasNewCorrDesc = m_pmd->m_pHeaderExts->Flags2.HasNewCorrDesc;

            if (m_pmd->m_pHeaderExts->Flags2.ServerCorrCheck)
            {
                NdrCorrelationInitialize( &stubMsg,
                                          (unsigned long *)pCorrInfo,
                                          NDR_DEFAULT_CORR_CACHE_SIZE,
                                          0 /* flags */ );
            }
        }
        else
        {
            stubMsg.fHasExtensions = 0;
            stubMsg.fHasNewCorrDesc = 0;
        }

        __try
        {
            // Do endian/floating point conversions if necessary.
            //
            if ((dataRep & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION)
            {
                NdrConvert2(&stubMsg, (PFORMAT_STRING)m_pmd->m_params, m_pmd->m_optFlags.HasReturn ? m_pmd->m_numberOfParams + 1 : m_pmd->m_numberOfParams);
            }
            //
            // Make sure that all parameters are known to be in some sort of reasonable state.
            // Caller took care of [in] and [in,out] parameters; we have to deal with outs. We
            // do this so that freeing can be sane.
            //
            for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                //
                m_fWorkingOnInParam  = paramAttr.IsIn;
                m_fWorkingOnOutParam = paramAttr.IsOut;
                //
                if (paramAttr.IsOut && !paramAttr.IsIn && !paramAttr.IsBasetype)
                {
                    PBYTE pArg = (BYTE*)m_pvArgs + param.StackOffset;
                    PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                    NdrClientZeroOut(&stubMsg, pFormatParam, *(PBYTE*)pArg);
                }
            }
            //
            // Unmarshal the out-values proper
            //
            for (iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                if (paramAttr.IsOut)
                {
                    PBYTE pArg = (BYTE*)m_pvArgs + param.StackOffset;
                    UnmarshalParam(stubMsg, param, paramAttr, pArg);
                }
            }
            //
            // Unmarshal the return value
            //
            if (m_pmd->m_optFlags.HasReturn)
            {
                const PARAM_DESCRIPTION& param   = m_pmd->m_params[m_pmd->m_numberOfParams];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                PBYTE pArg = (PBYTE)&m_hrReturnValue;
                UnmarshalParam(stubMsg, param, paramAttr, pArg);
            }
        }
        __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
        {
            hr = GetExceptionCode();
            if(SUCCEEDED(hr))
            {
                hr = HrNt(hr);
                if (SUCCEEDED(hr))
                {
                    hr = HRESULT_FROM_WIN32(GetExceptionCode());
                }
            }
            
            m_hrReturnValue = hr;
            //
            // REVIEW: Do we need to clean up anything here? I don't think so: the parameters
            // will be guaranteed to be in a state where a call to Free, which is the caller's
            // responsibility, will clear them up.
            //
        }
        //
        // Record how many bytes we unmarshalled. Do this even in error return cases.
        // Knowing this is important in order to be able to clean things up with ReleaseMarshalData
        //
        if (pcbUnmarshalled) *pcbUnmarshalled = PtrToUlong(stubMsg.Buffer) - PtrToUlong(pBuffer);
    }
    else
        if (pcbUnmarshalled) *pcbUnmarshalled = 0;

    //
    // We now contain valid out values.
    //
#ifdef DBG
    m_fAfterCall = TRUE;
#endif

    return hr;
}

//////////////////////////////////////////////////////

HRESULT CallFrame::ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////

HRESULT CallFrame::WalkFrame(DWORD walkWhat, ICallFrameWalker *pWalker)
  // Walk the interfaces and / or denoted data of interest in this call frame
{
    HRESULT hr = S_OK;

    __try
    {
        //
        // Set state examined by walker routines
        // 
        ASSERT(!AnyWalkers());
        m_StackTop    = (BYTE*)m_pvArgs;
        m_pWalkerWalk = pWalker;
        //
        // Loop over each parameter
        //
        for (ULONG iparam = 0; iparam < m_pmd->m_numberOfParams; iparam++)
        {
            const PARAM_DESCRIPTION& param   = m_pmd->m_params[iparam];
            const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
            //
            BOOL fWalk;
            if (paramAttr.IsIn)
            {
                if (paramAttr.IsOut)                       
                {
                    fWalk = (walkWhat & CALLFRAME_WALK_INOUT);
                }
                else
                {
                    fWalk = (walkWhat & CALLFRAME_WALK_IN);
                }
            }
            else if (paramAttr.IsOut)
            {
                fWalk = (walkWhat & CALLFRAME_WALK_OUT);
            }
            else
            {
                fWalk = FALSE;
                NOTREACHED();
            }
            //
            if (fWalk)
            {
                if (!m_pmd->m_rgParams[iparam].m_fMayHaveInterfacePointers)
                {
                    // Do nothing 
                }
                else
                {
                    PBYTE pArg = (PBYTE)m_pvArgs  + param.StackOffset;
                    //
                    m_fWorkingOnInParam  = paramAttr.IsIn;
                    m_fWorkingOnOutParam = paramAttr.IsOut;
                    //
                    // Parameter which is not a base type or ptr thereto
                    //
                    PFORMAT_STRING pFormatParam = GetStubDesc()->pFormatTypes + param.TypeOffset;
                    //
                    // We don't indirect on interface pointers, even though they are listed as not by value.
                    // In the walk routine, therefore, pMemory for interface pointers points to the location
                    // at which they reside instead of being the actual value.
                    //
                    pArg = ByValue(paramAttr, pFormatParam, FALSE) ? pArg : *((PBYTE*)pArg);
                    
                    WalkWorker(pArg, pFormatParam);
                }
            }
        }        
    }
    __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
    {
        hr = GetExceptionCode();
        if(SUCCEEDED(hr))
        {
            hr = HrNt(hr);
            if (SUCCEEDED(hr))
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
            }
        }
    }
    
    m_pWalkerWalk = NULL;
   
    ASSERT(!AnyWalkers());
    return hr;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\common.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// common.h
//
#pragma once
#ifndef __COMMON_H__
#define __COMMON_H__


#define STDCALL __stdcall

#define TRAP_HRESULT_ERRORS

///////////////////////////////////////////////////////////////////////////////////
//
// Control of whether we turn on legacy and / or typelib-driven interceptor support

#define ENABLE_INTERCEPTORS_LEGACY      (TRUE)
#define ENABLE_INTERCEPTORS_TYPELIB     (TRUE)

///////////////////////////////////////////////////////////////////////////////////
//
// What key do we look for interface helpers under? We allow independent, separate
// registration for user mode and kernel mode.
//
#define PSCLSID_KEY_NAME                                  L"ProxyStubClsid32"
#define INTERFACE_HELPER_VALUE_NAME                       L"InterfaceHelperUser"

#define PS_CLASS_NAME                                     L"Interface Proxy Stub"

#define INTERFACE_HELPER_DISABLE_ALL_VALUE_NAME           L"InterfaceHelperDisableAll"
#define INTERFACE_HELPER_DISABLE_TYPELIB_VALUE_NAME       L"InterfaceHelperDisableTypeLib"
#define INTERFACE_HELPER_DISABLE_ALL_FOR_OLE32_VALUE_NAME L"InterfaceHelperDisableAllForOle32"

///////////////////////////////////////////////////////////////////////////////////
//
// Miscellany

typedef unsigned char  uchar;
typedef unsigned short ushort;
typedef unsigned int   uint;
typedef unsigned long  ulong;

#define GUID_CCH    39 // length of a printable GUID, with braces & trailing NULL

///////////////////////////////////////////////////////////////////////////////////
//
// 
#include "txfcommon.h"
#include "oainternalrep.h"

typedef struct tagCStdPSFactoryBuffer CStdPSFactoryBuffer;
#include "TxfRpcProxy.h"

//
// Internal CLSCTX used for loading Proxy/Stub DLLs. Specifying
// this class context overrides thread model comparisons in 
// certain (all?) cases.
//
#define CLSCTX_PS_DLL                 0x80000000

#include "registry.h"
#include "CallObj.h"
#include "vtable.h"

///////////////////////////////////////////////////////////////////////////////////

#include <ndrtoken.h>
#include <ndrmisc.h>

#ifndef Oi_OBJ_USE_V2_INTERPRETER
#define Oi_OBJ_USE_V2_INTERPRETER               0x20
#endif

#include "oleautglue.h"
#include "metadata.h"

class Interceptor;

#include "CallFrame.h"
#include "Interceptor.h"

#include "CallFrameInline.h"

//////////////////////////////////////////////////////////////////////////
//
// Leak tracing support
//
#ifdef _DEBUG
extern "C" void ShutdownCallFrame();
#endif

void FreeTypeInfoCache();
void FreeMetaDataCache();


//////////////////////////////////////////////////////////////////////////
//
// Miscellaneous macros
//
#define PCHAR_LV_CAST   *(char **)&
#define PSHORT_LV_CAST  *(short **)&
#define PHYPER_LV_CAST  *(hyper **)&

#define PUSHORT_LV_CAST *(unsigned short **)&

// This is a conversion macro for WIN64.  It is defined here so that
// It works on 32 bit builds.
#ifndef LongToHandle
#define LongToHandle( h) ((HANDLE)(LONG_PTR) (h))
#endif

//////////////////////////////////////////////////////////////////////////
//
// Name "proxy file list" that we use internally here as our support engine
// See also CallFrameInternal.c
//
extern "C" const ProxyFileInfo * CallFrameInternal_aProxyFileList[];

//////////////////////////////////////////////////////////////////////////
//
// Flag as to whether this DLL is detaching from the process. Implemented
// in txfaux/init.cpp
//
extern BOOL g_fProcessDetach;

#endif // end #ifndef __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\cleginterface.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
   Microsoft COM Plus (Microsoft Confidential)

   @doc
   @module CLegInterface.H : Header file for the supporting interceptor for 
   legacy interfaces
 
   Description:<nl>
 
-------------------------------------------------------------------------------
Revision History:

@rev 0     | 04/30/98 | Gaganc  | Created
@rev 1     | 07/17/98 | BobAtk  | Cleaned, fixed leaks etc
---------------------------------------------------------------------------- */
#ifndef __CLEGINTERFACE_H_
#define __CLEGINTERFACE_H_

#include "CallFrameInternal.h"

struct LEGACY_INTERCEPTOR;
struct LEGACY_FRAME;

struct DISPATCH_INTERCEPTOR;
struct DISPATCH_FRAME;
struct DISPATCH_CLIENT_FRAME;
struct DISPATCH_SERVER_FRAME;


////////////////////////////////////////////////////////////////////////////////////////
//
// An interceptor for legacy interfaces
//
struct LEGACY_INTERCEPTOR : ICallInterceptor,
                            ICallUnmarshal,
                            IInterfaceRelated,
                            ICallFrameEvents,
                            IInterceptorBase,
                            IDispatch,
                            IUnkInner
{
    ///////////////////////////////////////////////////////////////////
    //
    // state
    //
    ///////////////////////////////////////////////////////////////////

    ICallFrameEvents*           m_psink;
    IID                         m_iid;
    ULONG                       m_cMethods;
                                
    XLOCK_LEAF                  m_frameLock;
    ICallFrame**                m_ppframeCustomer;
    //
    // An interceptor that dispenses frames that understand the wire-format variation
    // of methods in this interface. A difference between the in-memory and wire variations
    // arises through the use of [call_as] attribution on methods.
    //
    ICallInterceptor*           m_premoteInterceptor;
    BOOL                        m_fRegdWithRemoteInterceptor;
    //
    // An interceptor that dispenses frames that actually understand the in-memory call
    // stack representation of our interface's methods, as opposed to the wire-rep call stack.
    // 
    ICallInterceptor*           m_pmemoryInterceptor;
    BOOL                        m_fRegdWithMemoryInterceptor;
    //
    // Support for being a base interceptor
    //
    MD_INTERFACE*               m_pmdMostDerived;       // If we're a base, then the most derived interface that we actually service

#ifdef DBG
    ULONG                       m_signature;
#endif


    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    LEGACY_INTERCEPTOR(IUnknown * punkOuter);
    virtual ~LEGACY_INTERCEPTOR();
    HRESULT Init();
    
    ///////////////////////////////////////////////////////////////////
    //
    // IInterceptorBase
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL SetAsBaseFor(MD_INTERFACE* pmdMostDerived, BOOL* pfDerivesFromIDispatch)
    {
        ASSERT(pmdMostDerived);
        ::Set(m_pmdMostDerived, pmdMostDerived);
        *pfDerivesFromIDispatch = FALSE;
        return S_OK;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallIndirect
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP CallIndirect   (HRESULT * phReturn, ULONG iMethod, void* pvArgs, ULONG* pcbArgs);
    STDMETHODIMP GetStackSize   (ULONG iMethod, ULONG* pcbArgs);
    STDMETHODIMP GetIID         (IID * piid, BOOL* pfDerivesFromIDispatch, ULONG* pcMethod, LPWSTR* pwszInterfaceName);
    STDMETHODIMP GetMethodInfo  (ULONG iMethod, CALLFRAMEINFO* pinfo, LPWSTR* pwszMethodName);

    ///////////////////////////////////////////////////////////////////
    //
    // ICallInterceptor
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP RegisterSink       (ICallFrameEvents * psink);
    STDMETHODIMP GetRegisteredSink  (ICallFrameEvents ** ppsink);

    ///////////////////////////////////////////////////////////////////
    //
    // ICallUnmarshal
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP ReleaseMarshalData
    ( 
        ULONG                       iMethod,
        PVOID                       pBuffer,
        ULONG                       cbBuffer,
        ULONG                       ibFirstRelease,
        RPCOLEDATAREP               dataRep,
        CALLFRAME_MARSHALCONTEXT *  pcontext
    );

    ///////////////////////////////////////////////////////////////////
    //
    // IInterfaceRelated
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP SetIID     (REFIID iid);
    STDMETHODIMP GetIID     (IID * piid);

    ///////////////////////////////////////////////////////////////////
    //
    // IDispatch
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo ** ppTInfo);
    STDMETHODIMP GetIDsOfNames(REFIID     riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgDispId);
    STDMETHODIMP GetIDsOfNames(const IID* piid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgDispId);
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,DISPPARAMS * pDispParams,
                        VARIANT * pVarResult, EXCEPINFO * pExcepInfo, UINT * puArgErr);
#if defined(_IA64_)                        
    STDMETHODIMP GenericCall(ULONG iMethod, ...);
#endif    

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    IUnknown*   m_punkOuter;
    LONG        m_refs;
    BOOL        m_fShuttingDown;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL InnerAddRef()   { ASSERT(m_refs>0 || m_fShuttingDown); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  { if (!m_fShuttingDown) { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;} else return 0; }

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrameEvents
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL OnCall(ICallFrame*);

    ///////////////////////////////////////////////////////////////////
    //
    // Utilities
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT GetRemoteFrameFor(ICallFrame**, LEGACY_FRAME* pFrame);
    HRESULT GetMemoryFrameFor(ICallFrame**, LEGACY_FRAME* pFrame); 

    void ReleaseRemoteInterceptor()
    {
        if (m_fRegdWithRemoteInterceptor)
        {
            m_fRegdWithRemoteInterceptor = FALSE;
            ((ICallFrameEvents*)this)->AddRef();
        }
        ::Release(m_premoteInterceptor);
    }
   
    void ReleaseMemoryInterceptor()
    {
        if (m_fRegdWithMemoryInterceptor)
        {
            m_fRegdWithMemoryInterceptor = FALSE;
            ((ICallFrameEvents*)this)->AddRef();
        }
        ::Release(m_pmemoryInterceptor);
    }

    HRESULT GetInternalInterceptor(REFIID iid, ICallInterceptor** ppInterceptor);
};


struct DISPATCH_INTERCEPTOR : public LEGACY_INTERCEPTOR
{
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    friend class GenericInstantiator<DISPATCH_INTERCEPTOR>;

public:
    DISPATCH_INTERCEPTOR(IUnknown * punkOuter = NULL) : LEGACY_INTERCEPTOR(punkOuter)
    {
    }

    ~DISPATCH_INTERCEPTOR()
    {
    }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallUnmarshal
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP Unmarshal
    ( 
        ULONG                       iMethod,
        PVOID                       pBuffer,
        ULONG                       cbBuffer,
        BOOL                        fForceCopyBuffer,
        RPCOLEDATAREP               dataRep,
        CALLFRAME_MARSHALCONTEXT *  pcontext,
        ULONG *                     pcbUnmarshalled,
        ICallFrame **               ppFrame
    );

    ///////////////////////////////////////////////////////////////////
    //
    // IInterceptorBase
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL SetAsBaseFor(MD_INTERFACE* pmdMostDerived, BOOL* pfDerivesFromIDispatch)
    {
        LEGACY_INTERCEPTOR::SetAsBaseFor(pmdMostDerived, pfDerivesFromIDispatch);
        //
        *pfDerivesFromIDispatch = TRUE;
        //
        return S_OK;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // IInterfaceRelated
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL SetIID(REFIID iid);

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);

    ///////////////////////////////////////////////////////////////////
    //
    // ICallIndirect
    //
    ///////////////////////////////////////////////////////////////////

    STDMETHODIMP GetStackSize   (ULONG iMethod, ULONG* pcbArgs);
};



////////////////////////////////////////////////////////////////////////////////////////
//
// A hand-coded call frame. For now, just IDispatch. Later, will subclass and
// factor for other interfaces.
//
struct LEGACY_FRAME : IUnkInner, public ICallFrame
{
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    PVOID                   m_pvArgs;
    const ULONG             m_iMethod;

    REGISTER_TYPE           m_hrReturnValue;
    LEGACY_INTERCEPTOR*     m_pInterceptor;
    ICallFrame*             m_premoteFrame;
    ICallFrame*             m_pmemoryFrame;
    BOOL                    m_fAfterCall;

    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    friend struct DISPATCH_FRAME;
    friend struct DISPATCH_INTERCEPTOR;

    friend struct LEGACY_INTERCEPTOR;

    LEGACY_FRAME(IUnknown* punkOuter, ULONG iMethod, PVOID pvArgs, LEGACY_INTERCEPTOR* pinterceptor)
      : m_iMethod(iMethod)
    {
        m_refs              = 1;            // nb starts at one
        m_punkOuter         = punkOuter ? punkOuter : (IUnknown*)(void*)(IUnkInner*)this;
        m_pInterceptor      = pinterceptor;
        m_premoteFrame      = NULL;
        m_pmemoryFrame      = NULL;
        m_fAfterCall        = FALSE;

        m_pInterceptor->AddRef();

        SetStackLocation(pvArgs);
    }

protected:
    virtual ~LEGACY_FRAME()
    {
        ::Release(m_pmemoryFrame);
        ::Release(m_premoteFrame);
        m_pInterceptor->Release();
    }
public:

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetInfo(CALLFRAMEINFO *pInfo);

    PVOID   STDCALL GetStackLocation()
    {
        return m_pvArgs;
    }
    void    STDCALL SetStackLocation(PVOID pvArgs)
    {
        m_pvArgs = pvArgs;
    }

    void STDCALL SetReturnValue(HRESULT hrReturnValue)
    { 
        m_hrReturnValue = hrReturnValue;
    }
    HRESULT STDCALL GetReturnValue()
    { 
        return (HRESULT)m_hrReturnValue;
    }

    HRESULT STDCALL GetNames(LPWSTR* pwszInterface, LPWSTR* pwszMethod);

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    IUnknown*   m_punkOuter;
    LONG        m_refs;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL InnerAddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;}

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }

    ///////////////////////////////////////////////////////////////////
    //
    // Utilties
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT GetRemoteFrame();
    HRESULT GetMemoryFrame();
};


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//
// Meta data about methods in particular interfaces.
//
#include "IDispatchInfo.h"


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////


#include "DispatchFrame.h"


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//
// Support for spilling and getting access to stack frames. 
//

#if defined(_AMD64_) || defined(_X86_)

#define INTERCEPT_CALL(firstNonThisParam, lastParam, iMethod)                                       \
        const void* pvArgs = reinterpret_cast<const BYTE*>(&firstNonThisParam) - sizeof(PVOID);     \
        ULONG cbArgs;                                                                               \
        HRESULT hrReturn;                                                                           \
        CallIndirect(&hrReturn, iMethod, const_cast<void*>(pvArgs), &cbArgs);                       \
        return hrReturn;                                                                        

#endif

#if defined(_IA64_)

#define INTERCEPT_CALL(firstNonThisParam, lastParam, iMethod)                                       \
                va_list va;                                                                         \
                va_start(va, lastParam);                                                            \
                                                                                                    \
        const void* pvArgs = reinterpret_cast<const BYTE*>(&firstNonThisParam) - sizeof(PVOID);     \
        ULONG cbArgs;                                                                               \
        HRESULT hrReturn;                                                                           \
        CallIndirect(&hrReturn, iMethod, const_cast<void*>(pvArgs), &cbArgs);                       \
        return hrReturn;                                                                        

#endif

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//

inline void FRAME_RemoteInvoke::CopyTo(FRAME_Invoke& him) const
{
    him.CopyFrom(*this);
}
inline void FRAME_Invoke::CopyTo(FRAME_RemoteInvoke& him) const
{
    him.CopyFrom(*this);
}

inline void FRAME_Invoke::CopyFrom(const FRAME_RemoteInvoke& him)
{
    This            = him.This;
    dispIdMember    = him.dispIdMember;
    piid            = him.piid;
    lcid            = him.lcid;
    wFlags          = LOWORD(him.dwFlags);
    pDispParams     = him.pDispParams;
    pVarResult      = him.pVarResult;
    pExcepInfo      = him.pExcepInfo;
    puArgErr        = him.puArgErr;
}

inline void FRAME_RemoteInvoke::CopyFrom(const FRAME_Invoke& him)
{
    This            = him.This;
    dispIdMember    = him.dispIdMember;
    piid            = him.piid;
    lcid            = him.lcid;
    dwFlags         = him.wFlags;
    pDispParams     = him.pDispParams;
    pVarResult      = him.pVarResult;
    pExcepInfo      = him.pExcepInfo;
    puArgErr        = him.puArgErr;
    cVarRef         = 0;
    rgVarRefIdx     = NULL;
    rgVarRef        = NULL;
}


#endif __CLEGINTERFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\getsp.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// 
// getsp.cpp in CallFrame
//
// Used on the AMD64 and IA64 to return the caller's stack pointer. This code was taken
// from the original implementation in the Context Wrapper code of MTS 1.0, written
// by Jan Gray, the stud.
//
// This is in a separate compilation unit because to perform the trickery we have to 
// have callers use a different signature to the method than what it's implementation
// says it should be, namely  extern "C" void* getSP();. See common.h.
//
#include "stdpch.h"
//
// Return the caller's SP.
//
#pragma warning(disable: 4172) // returning address of local variable or temporary
#if defined(_AMD64_)
extern "C" void* getSP(int rcx)
    {
        return (void*)&rcx;
    }
#else
#error "No Target Architecture"
#endif // _AMD64_
#pragma warning(default: 4172)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\comps.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// ComPs.cpp
//
#include "stdpch.h"
#include "common.h"
#include "comps.h"

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Class factory
//
///////////////////////////////////////////////////////////////////////////////////////////////////

class ComPsClassFactory : public IClassFactory, IPSFactoryBuffer
{
public:
    ////////////////////////////////////////////////////////////
    //
    // IUnknown methods
    //
    ////////////////////////////////////////////////////////////

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv)
    {
        if (iid == IID_IUnknown || iid == IID_IClassFactory)   { *ppv = (IClassFactory*)this; }
        else if (iid == IID_IPSFactoryBuffer)                       { *ppv = (IPSFactoryBuffer*)this; }
        else { *ppv = NULL; return E_NOINTERFACE; }

        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    ULONG STDCALL AddRef()  { InterlockedIncrement(&m_crefs); return (m_crefs); }
    ULONG STDCALL Release() { long cRef = InterlockedDecrement(&m_crefs); if (cRef == 0) delete this; return cRef; }

    ////////////////////////////////////////////////////////////
    //
    // IClassFactory methods
    //
    ////////////////////////////////////////////////////////////

    HRESULT STDCALL LockServer (BOOL fLock) { return S_OK; }

    HRESULT STDCALL CreateInstance(IUnknown* punkOuter, REFIID iid, LPVOID* ppv)
      // Create an instance of an interceptor. It needs to know the m_pProxyFileList
    {
        HRESULT hr = S_OK;
        if (!(ppv && (punkOuter==NULL || iid==IID_IUnknown))) return E_INVALIDARG;
        
        *ppv = NULL;
        Interceptor* pnew = new Interceptor(punkOuter);
        if (pnew)
        {
            pnew->m_pProxyFileList = m_pProxyFileList;

            IUnkInner* pme = (IUnkInner*)pnew;
            if (hr == S_OK)
            {
                hr = pme->InnerQueryInterface(iid, ppv);
            }
            pme->InnerRelease();                // balance starting ref cnt of one    
        }
        else 
            hr = E_OUTOFMEMORY;
    
        return hr;
    }

    ////////////////////////////////////////////////////////////
    //
    // IPSFactoryBuffer methods
    //
    ////////////////////////////////////////////////////////////

    HRESULT STDCALL CreateProxy(IUnknown* punkOuter, REFIID iid, IRpcProxyBuffer** ppProxy, void** ppv)
    {
        return m_pDelegatee->CreateProxy(punkOuter, iid, ppProxy, ppv);
    }

    HRESULT STDCALL CreateStub(REFIID iid, IUnknown* punkServer, IRpcStubBuffer** ppStub)
    {
        return m_pDelegatee->CreateStub(iid, punkServer, ppStub);
    }

    ////////////////////////////////////////////////////////////
    //
    // State / Construction
    //
    ////////////////////////////////////////////////////////////
    
    long                    m_crefs;
    IPSFactoryBuffer*       m_pDelegatee;
    const ProxyFileInfo **  m_pProxyFileList;

    ComPsClassFactory(IUnknown* punkDelegatee, CStdPSFactoryBuffer *pPSFactoryBuffer)
    {
        m_crefs = 1;

        punkDelegatee->QueryInterface(IID_IPSFactoryBuffer, (void**)&m_pDelegatee);
        ASSERT(m_pDelegatee);
        m_pProxyFileList = pPSFactoryBuffer->pProxyFileList;
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Instantiation
//
///////////////////////////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT RPC_ENTRY ComPs_NdrDllGetClassObject(
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer)
{
    //
    // What we do is delegate to the NdrDllGetClassObject in rpcrt4.dll, and then
    // wrap it with our own class factory.
    //
    IUnknown *punkRet = NULL;
    HRESULT hr = NdrDllGetClassObject(rclsid, 
                                      IID_IUnknown, 
                                      (void **)&punkRet, 
                                      pProxyFileList, 
                                      pclsid, 
                                      pPSFactoryBuffer);
    if (SUCCEEDED(hr))
    {
        // Great, now wrap it.
        ComPsClassFactory *pFactory = new ComPsClassFactory(punkRet, pPSFactoryBuffer);
        if (pFactory)
        {
            hr = pFactory->QueryInterface(riid, ppv);
            pFactory->Release();
        }

        punkRet->Release();
    }

    return hr;
}

extern "C" HRESULT RPC_ENTRY ComPs_NdrDllCanUnloadNow(IN CStdPSFactoryBuffer * pPSFactoryBuffer)
{
    // We don't pretend to be unloadable, as the the DllCanUnloadNow mechanism works poorly at best
    // if at all for free threaded DLLs such as us.
    return S_FALSE;
}



///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Small Helper Function
//
// Stolen from RPC (because it's not exported from there) 02/23/2002
//
///////////////////////////////////////////////////////////////////////////////////////////////////

BOOL NdrpFindInterface(
    IN  const ProxyFileInfo **  pProxyFileList,
    IN  REFIID                  riid,
    OUT const ProxyFileInfo **  ppProxyFileInfo,
    OUT long *                  pIndex)
/*++

Routine Description:
    Search the ProxyFileInfo and find the specified interface.
    If the count is specified in the ProxyFileInfo, then the interfaces in
    the file are sorted by IID.  This means that we can perform a binary
    search for the IID.

Arguments:
    pProxyFileList  - Specifies a list of proxy files to be searched.
    riid            - Specifies the interface ID to be found.
    ppProxyFileInfo - Returns a pointer to the proxy file info.
    pIndex          - Returns the index of the interface in the proxy file info.

Return Value:
    TRUE    - The interface was found.
    FALSE   - The interface was not found.

--*/
{
    long                j = 0;
    BOOL                fFound = FALSE;
    ProxyFileInfo   **  ppProxyFileCur;
    ProxyFileInfo   *   pProxyFileCur = NULL;

    //Search the list of proxy files.
    for( ppProxyFileCur = (ProxyFileInfo **) pProxyFileList;
        (*ppProxyFileCur != 0) && (fFound != TRUE);
        ppProxyFileCur++)
        {
        //Search for the interface proxy vtable.
        pProxyFileCur = *ppProxyFileCur;

        // see if it has a lookup routine already
        if ( ( pProxyFileCur->TableVersion >= 1 ) &&
             ( pProxyFileCur->pIIDLookupRtn ) ) 
            {
            fFound = (*pProxyFileCur->pIIDLookupRtn)( &riid, (int*)&j );
            }
        else    //Linear search.
            {
            for(j = 0;
                (pProxyFileCur->pProxyVtblList[j] != 0);
                j++)
                {
                if(memcmp(&riid,
                    pProxyFileCur->pStubVtblList[j]->header.piid,
                    sizeof(IID)) == 0)
                    {
                    fFound = TRUE;
                    break;
                    }
                }
            }
        }

    if ( fFound )
        {
        //We found the interface!
        if(ppProxyFileInfo != 0)
            *ppProxyFileInfo = pProxyFileCur;

        if(pIndex != 0)
            *pIndex = j;
        }

    return fFound;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\compsregistration.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// ComPsRegistration.cpp
//
#include "stdpch.h"
#include "common.h"
#include <comregistration.h>
#include "comps.h"
#include <debnot.h>

//////////////////////////////////////////////////////////////////////////////////////////
//
// Proxy-stub registration utiltiies
//

HRESULT GetProxyStubClsid(const CLSID* pclsid, const ProxyFileInfo ** pProxyFileList, CLSID* pclsidOut)
{
    HRESULT hr = S_OK;
    //
    // If necessary, use the IID of the first interface as the CLSID.
    //
    for(int i = 0; (pProxyFileList[i] != 0) && (!pclsid); i++)
    {
        for(int j = 0; (pProxyFileList[i]->pProxyVtblList[j] != 0) && (!pclsid); j++)
        {
            pclsid = pProxyFileList[i]->pStubVtblList[j]->header.piid;
        }
    }
    if (pclsid)
        *pclsidOut = *pclsid;
    else
        hr = E_NOINTERFACE;
    return hr;
}

static inline UNICODE_STRING From(LPCWSTR wsz) 
{
    UNICODE_STRING u;
    RtlInitUnicodeString(&u, wsz);
    return u;
}

HRESULT TestRegistryValue(HREG hreg, LPCWSTR wszValueName, LPCWSTR wszTestValue)
  // Answer as to whether the indcated registry value exists and is equal to 
  // the indicated test value.
{
    HRESULT hr = S_OK;

    PKEY_VALUE_FULL_INFORMATION pinfo = NULL;
    hr = GetRegistryValue(hreg, wszValueName, &pinfo, REG_SZ);
	Win4Assert(pinfo || FAILED(hr));
    if (!hr && pinfo)
	{
        LPWSTR wszExistingValue = StringFromRegInfo(pinfo);
        //
        // If the existing value is in fact our class, then delete the clsid key
        //
        UNICODE_STRING u1 = From(wszExistingValue);
        UNICODE_STRING u2 = From(wszTestValue);
        if (RtlCompareUnicodeString(&u1, &u2, TRUE) == 0)
		{
            hr = S_OK;
		}
        else
		{
            hr = S_FALSE;
		}
        CoTaskMemFree(pinfo);
	}

    return hr;
}


HRESULT RegisterUnregisterInterface
(
    IN BOOL     fRegister,
    IN HREG     hKeyInterface,
    IN REFIID   riid, 
    IN LPCSTR   szInterfaceName,
    IN LPCWSTR  wszClassID,
    IN long     NumMethods,
    IN BOOL     fMarshal,
    IN BOOL     fCallFrame
)
{
    HRESULT hr = S_OK;
    WCHAR wszIID[GUID_CCH];
    StringFromGuid(riid, &wszIID[0]);
    //
    // Open or create the IID key itself
    //
    HREG hKeyIID;
    if (fRegister)
        hr = CreateRegistryKey(&hKeyIID, hKeyInterface, wszIID);
    else
        hr = OpenRegistryKey(&hKeyIID, hKeyInterface, wszIID, KEY_ALL_ACCESS);
    //
    if (!hr)
    {
        /////////////////////////////////////////////////////////////////////////////
        //
        // Add the interface name if we're registering; leave it alone 
        // if we're unregistering.
        // 
        if (!hr && fRegister)
        {
            LPWSTR wszInterfaceName = ToUnicode(szInterfaceName);
            if (wszInterfaceName)
            {
                hr= SetRegistryValue(hKeyIID, L"", wszInterfaceName);
                CoTaskMemFree(wszInterfaceName);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        //
        /////////////////////////////////////////////////////////////////////////////
        //
        // In the marshalling case, create the ProxyStubClsid32 if registering
        // but delete it when unregistering only if it's in fact our class that's
        // registered there in the first place.
        //
        if (!hr && fMarshal)
        {
            HREG hKeyClsid;
            if (fRegister)
            {
                hr = CreateRegistryKey(&hKeyClsid, hKeyIID, PSCLSID_KEY_NAME);
                if (!hr)
                {
                    // Note the appropriate CLSID
                    hr = SetRegistryValue(hKeyClsid, L"", wszClassID);
                    CloseRegistryKey(hKeyClsid);
                }
            }
            else
            {
                hr = OpenRegistryKey(&hKeyClsid, hKeyIID, PSCLSID_KEY_NAME, KEY_ALL_ACCESS);
                if (!hr)
                {
                    if (TestRegistryValue(hKeyClsid, L"", wszClassID) == S_OK)
                        DeleteRegistryKey(hKeyClsid);
                    else
                        CloseRegistryKey(hKeyClsid);
                }
                //
                hr = S_OK; // In unregister case, we did our best
            }
        }
        //
        /////////////////////////////////////////////////////////////////////////////
        //
        if (!hr && fCallFrame)
        {
            if (fRegister)
            {
                // Make sure that InterfaceHelper exists
                // 
                hr = SetRegistryValue(hKeyIID, INTERFACE_HELPER_VALUE_NAME, wszClassID);
            }
            else
            {
                // Delete InterfaceHelper value if it's equal to us
                //
                if (TestRegistryValue(hKeyIID, INTERFACE_HELPER_VALUE_NAME, wszClassID) == S_OK)
                {
                    DeleteRegistryValue(hKeyIID, INTERFACE_HELPER_VALUE_NAME);
                }

                hr = S_OK;
            }
        }
        //
        /////////////////////////////////////////////////////////////////////////////
        //
        CloseRegistryKey(hKeyIID);
    }

    //
    // Ignore errors during unregistration: we did the best we can
    //
    if (!fRegister)
    {
        hr = S_OK;
    }

    return hr;
}

BOOL IsIidInList(REFIID iid, const IID** rgiid)
{
    while (rgiid && *rgiid)
    {
        if (iid == **rgiid)
            return TRUE;
        rgiid++;
    }
    return FALSE;
}


HRESULT RegisterUnregisterProxy(
    IN BOOL                     fRegister,
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN const IID**              rgiidNoCallFrame,
    IN const IID**              rgiidNoMarshal
)
{
    HRESULT hr = S_OK;
    //
    // Find the right CLSID
    //
    CLSID clsid;
    hr = GetProxyStubClsid(pclsid, pProxyFileList, &clsid);
    if (!hr)
    {
        // Register/unregister the class
        //
        WCHAR wszClsid[GUID_CCH];
        StringFromGuid(clsid, &wszClsid[0]);

        ClassRegistration c;
        c.clsid             = clsid;
        c.className         = PS_CLASS_NAME;
        c.threadingModel    = L"Both";
        c.hModule           = hDll;

        if (fRegister)
        {
            hr = c.Register();
        }
        else
        {
            c.Unregister(); // Ignore errors: we try our best
        }

        if (!hr)
        {
            // Register/unregister the interfaces serviced by this class
            //
            HREG hKeyInterface;
            
            LPCWSTR wszInterface = L"\\Registry\\Machine\\Software\\Classes\\Interface";

            if (fRegister)
            {
                hr = CreateRegistryKey(&hKeyInterface, HREG(), wszInterface);
            }
            else
            {
                hr = OpenRegistryKey(&hKeyInterface, HREG(), wszInterface);
            }

            if (!hr)
            {
                // Iterate over the list of proxy files
                for(int i = 0; pProxyFileList[i] != 0; i++)
                {
                    //iterate over the list of interfaces in the proxy file
                    for(int j = 0; pProxyFileList[i]->pProxyVtblList[j] != 0; j++)
                    {
                        IID iid = *pProxyFileList[i]->pStubVtblList[j]->header.piid;

                        BOOL fMarshal   = !IsIidInList(iid, rgiidNoMarshal);
                        BOOL fCallFrame = !IsIidInList(iid, rgiidNoCallFrame);

                        HRESULT hr2 = RegisterUnregisterInterface(
                            fRegister,
                            hKeyInterface, 
                            iid, 
                            pProxyFileList[i]->pNamesArray[j], 
                            &wszClsid[0],
                            pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                            fMarshal,
                            fCallFrame
                        );

                        if (!!hr2 && !hr)
                            hr = hr2;
                    }
                }
                CloseRegistryKey(hKeyInterface);
            }
        }
    }

    if (!fRegister)
    {
        hr = S_OK; // Ignore errors: we tried our best
    }

    return hr; 
}

extern "C" HRESULT RPC_ENTRY ComPs_NdrDllRegisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN const IID**              rgiidNoCallFrame,
    IN const IID**              rgiidNoMarshal
)
{
    return RegisterUnregisterProxy(TRUE, hDll, pProxyFileList, pclsid, rgiidNoCallFrame, rgiidNoMarshal);
}

extern "C" HRESULT RPC_ENTRY ComPs_NdrDllUnregisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN const IID**              rgiidNoCallFrame,
    IN const IID**              rgiidNoMarshal
)
{
    return RegisterUnregisterProxy(FALSE, hDll, pProxyFileList, pclsid, rgiidNoCallFrame, rgiidNoMarshal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\dispatchframe.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// DispatchFrame.h
//


////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//
// Implementation of a call frame that handles IDispatch
// 

struct DISPATCH_FRAME : LEGACY_FRAME
{
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    DISPATCH_FRAME(IUnknown* punkOuter, ULONG iMethod, PVOID pvArgs, LEGACY_INTERCEPTOR* pinterceptor) 
      : LEGACY_FRAME(punkOuter, iMethod, pvArgs, pinterceptor)
    {
    }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*);
    //  HRESULT STDCALL GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, ULONG *pcbBufferNeeded);
    //  HRESULT STDCALL Marshal     (CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
    //                                  ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags);
    //  HRESULT STDCALL Unmarshal   (PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT*, ULONG* pcbUnmarhalled);
    //  HRESULT STDCALL ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx);
    //  HRESULT STDCALL Free        (ICallFrame* pframeArgsDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags);

    HRESULT STDCALL Invoke(void *pvReceiver);
    //  HRESULT STDCALL Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame);
    HRESULT STDCALL WalkFrame(DWORD walkWhat, ICallFrameWalker *pWalker);
    HRESULT STDCALL GetParamInfo(IN ULONG iparam, OUT CALLFRAMEPARAMINFO*);
    HRESULT STDCALL GetParam(ULONG iparam, VARIANT* pvar);
    HRESULT STDCALL SetParam(ULONG iparam, VARIANT* pvar);
};


//////////////////////////////////////////


struct DISPATCH_CLIENT_FRAME : DISPATCH_FRAME, DedicatedAllocator<DISPATCH_CLIENT_FRAME>
{
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    BOOL                    m_fDoneProxyPrecheck;
    BOOL                    m_fIsCopy;
    FRAME_RemoteInvoke      m_remoteFrame;

    DISPPARAMS              m_dispParams;
    VARIANT                 m_varResult;
    EXCEPINFO               m_excepInfo;
    UINT                    m_uArgErr;

    UINT                    m_aVarRefIdx[PREALLOCATE_PARAMS];
    VARIANT                 m_aVarRef   [PREALLOCATE_PARAMS];
    VARIANT                 m_aVarArg   [PREALLOCATE_PARAMS];

    BYTE*                   m_pBuffer;

    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    DISPATCH_CLIENT_FRAME(IUnknown* punkOuter, ULONG iMethod, PVOID pvArgs, LEGACY_INTERCEPTOR* pinterceptor) 
      : DISPATCH_FRAME(punkOuter, iMethod, pvArgs, pinterceptor)
    {
        m_fDoneProxyPrecheck      = FALSE;
        m_pBuffer                 = NULL;
        m_fIsCopy                 = FALSE;
    }

private:
    ~DISPATCH_CLIENT_FRAME()
    {
        CoTaskMemFree(m_pBuffer);
    }
public:

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

//  HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*);
    HRESULT STDCALL GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, ULONG *pcbBufferNeeded);
    HRESULT STDCALL Marshal     (CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
                                 ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags);
    HRESULT STDCALL Unmarshal   (PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT*, ULONG* pcbUnmarhalled);
    HRESULT STDCALL ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx);
    HRESULT STDCALL Free        (ICallFrame* pframeArgsDest, ICallFrameWalker* pWalkerFreeDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags);
    HRESULT STDCALL FreeParam(
        ULONG              iparam,
        DWORD              freeFlags,
        ICallFrameWalker*  pWalkerFree,
        DWORD              nullFlags);

    HRESULT STDCALL Invoke(void *pvReceiver, ...);
    HRESULT STDCALL Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame);
    //  HRESULT STDCALL WalkFrame(BOOLEAN fIn, GUID*pguidTag, ICallFrameWalker *pWalker);


    ///////////////////////////////////////////////////////////////////
    //
    // Utilties
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT ProxyPreCheck();
    void    InitializeInvoke();

};

struct DISPATCH_SERVER_FRAME : DISPATCH_FRAME, DedicatedAllocator<DISPATCH_SERVER_FRAME>
{
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////
    //
    // NB: In a DISPATCH_SERVER_FRAME, m_pvArgs is of shape FRAME_RemoteInvoke, not FRAME_Invoke
    //

    FRAME_Invoke    m_memoryFrame;
    BOOL            m_fDoneStubPrecheck;
    BOOL            m_fDoneStubPostcheck;

    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    DISPATCH_SERVER_FRAME(IUnknown* punkOuter, ULONG iMethod, PVOID pvArgs, LEGACY_INTERCEPTOR* pinterceptor) 
      : DISPATCH_FRAME(punkOuter, iMethod, pvArgs, pinterceptor)
    {
        m_fDoneStubPrecheck = FALSE;
        m_fDoneStubPostcheck = FALSE;
    }

private:
    ~DISPATCH_SERVER_FRAME()
    {
    }
public:

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

    //  HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*);
    HRESULT STDCALL GetMarshalSizeMax(CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, ULONG *pcbBufferNeeded);
    HRESULT STDCALL Marshal     (CALLFRAME_MARSHALCONTEXT *pmshlContext, MSHLFLAGS mshlflags, PVOID pBuffer, ULONG cbBuffer,
                                 ULONG *pcbBufferUsed, RPCOLEDATAREP* pdataRep, ULONG *prpcFlags);
    HRESULT STDCALL Unmarshal   (PVOID pBuffer, ULONG cbBuffer, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT*, ULONG* pcbUnmarhalled);
    HRESULT STDCALL ReleaseMarshalData(PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx);
    HRESULT STDCALL Free        (ICallFrame* pframeArgsDest, ICallFrameWalker* pWalkerFreeDest, ICallFrameWalker* pWalkerCopy, DWORD freeFlags, ICallFrameWalker* pWalkerFree, DWORD nullFlags);
    HRESULT STDCALL FreeParam(
        ULONG              iparam,
        DWORD              freeFlags,
        ICallFrameWalker*  pWalkerFree,
        DWORD              nullFlags);
    HRESULT STDCALL Invoke(void *pvReceiver, ...);
    HRESULT STDCALL Copy(CALLFRAME_COPY callControl, ICallFrameWalker* pWalker, ICallFrame** ppFrame);
    //  HRESULT STDCALL WalkFrame(BOOLEAN fIn, GUID*pguidTag, ICallFrameWalker *pWalker);

    ///////////////////////////////////////////////////////////////////
    //
    // Utilties
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT StubPreCheck();
    HRESULT StubPostCheck();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\interceptor.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Interceptor.h
//
#include "CallFrameImpl.h"
#include <obase.h>

extern "C" const PFN_VTABLE_ENTRY g_InterceptorVtable[];

struct TYPEINFOVTBL;

class Interceptor :
  ICallInterceptor,
  ICallUnmarshal,
  IInterfaceRelated,
  IInterceptorBase,
  IUnkInner
{
    friend class CallFrame;

public:
    ///////////////////////////////////////////////////////////////////
    //
    // Public instantiation
    //
    ///////////////////////////////////////////////////////////////////

    static HRESULT For               (REFIID iidIntercepted, IUnknown* punkOuter, REFIID, void** ppInterceptor);
    static HRESULT ForTypeInfo       (REFIID iidIntercepted, IUnknown* punkOuter, ITypeInfo* pITypeInfo, REFIID iid, void** ppv);
    static HRESULT TryInterfaceHelper(REFIID iidIntercepted, IUnknown* punkOuter, REFIID, void** ppInterceptor, BOOL* pfDisableTyplib);
    static HRESULT TryTypeLib        (REFIID iidIntercepted, IUnknown* punkOuter, REFIID, void** ppInterceptor);

    // Versions of For and ForInterfaceHelper which honor different disable keys so ole32 can selectively
    // disable interceptors without affecting other components.
    static HRESULT ForOle32                  (REFIID iidIntercepted, IUnknown* punkOuter, REFIID, void** ppInterceptor);
    static HRESULT TryInterfaceHelperForOle32(REFIID iidIntercepted, IUnknown* punkOuter, REFIID, void** ppInterceptor, BOOL* pfDisableTyplib);
    

private:
    static HRESULT CreateFromTypeInfo(REFIID iidIntercepted, IUnknown* punkOuter, ITypeInfo* pITypeInfo, REFIID iid, void** ppv);

private:
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    ICallFrameEvents*               m_pCallSink;        // the sink who wants to hear of our calls, if any 

public:
    const PFN_VTABLE_ENTRY*         m_pvtbl;            // the intercepted vtable, the address of which is our interface pointer of interception

private:
    //
    MD_INTERFACE*                   m_pmdInterface;
    const CInterfaceStubHeader*     m_pHeader;          // meta data for our interface
    const ProxyFileInfo **          m_pProxyFileList;   // meta data for the whole proxy dll of which we are a part
    //
    LPCSTR                          m_szInterfaceName;  // the name of our interface: someone else owns the allocation, not us
    //
    // Support for typeinfo-based interceptors
    //
    BOOL                            m_fMdOwnsHeader;    // does our MD_INTERFACE own m_pHeader?
#ifndef KERNELMODE
    BOOL                            m_fUsingTypelib;    // whether we're a typeinfo-based interceptor or not
    TYPEINFOVTBL*                   m_ptypeinfovtbl;    // our TYPEINFOVTBL if we are
#endif
    //
    // Support for delegating to a 'base' interceptor. Necessary given how MIDL emits the meta data
    //
    unsigned int                    m_cMethodsBase;         // number of methods in the base interface
    ICallInterceptor*               m_pBaseInterceptor;     // the base interceptor, if we have to have one
    IUnknown*                       m_punkBaseInterceptor;  // controlling unknown on our base interceptor
    //
    // Support for being a base interceptor
    //
    MD_INTERFACE*                   m_pmdMostDerived;       // If we're a base, then the most derived interface that we actually service


    ///////////////////////////////////////////////////////////////////
    //
    // Construction / initialization
    //
    ///////////////////////////////////////////////////////////////////

    friend GenericInstantiator<Interceptor>;
    friend class ComPsClassFactory;
    friend HRESULT STDMETHODCALLTYPE Interceptor_QueryInterface(IUnknown* This, REFIID riid, void** ppv);
    friend ULONG   STDMETHODCALLTYPE Interceptor_AddRef(IUnknown* This);
    friend ULONG   STDMETHODCALLTYPE Interceptor_Release(IUnknown* This);
    friend void                      InterceptorThunk(ULONG extraParam, IUnknown* This, ...);
    friend struct LEGACY_INTERCEPTOR;

    Interceptor(IUnknown* punkOuter = NULL)
    {
        m_refs              = 1;            // nb starts at one
        m_punkOuter         = punkOuter ? punkOuter : (IUnknown*)(void*)(IUnkInner*)this;
        m_pCallSink         = NULL;
        m_pmdInterface      = NULL;
        m_pmdMostDerived    = NULL;
        m_pHeader           = NULL;
        m_pProxyFileList    = NULL;
        m_pvtbl             = g_InterceptorVtable;
        m_cMethodsBase      = 0;
        m_pBaseInterceptor  = NULL;
        m_punkBaseInterceptor = NULL;
        m_szInterfaceName   = NULL;

        m_fMdOwnsHeader     = FALSE;
#ifndef KERNELMODE
        m_fUsingTypelib     = FALSE;
        m_ptypeinfovtbl     = NULL;
#endif
    }

    virtual ~Interceptor();

    HRESULT Init()
    {
        return S_OK;
    }

    HRESULT InitUsingTypeInfo(REFIID i_riidIntercepted, ITypeInfo * i_pITypeInfo);

    HRESULT SetMetaData(TYPEINFOVTBL* pTypeInfoVtbl);

    ///////////////////////////////////////////////////////////////////
    //
    // IInterceptorBase
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL SetAsBaseFor(MD_INTERFACE* pmdMostDerived, BOOL* pfDerivesFromIDispatch)
    {
        HRESULT hr = S_OK;
        ASSERT(pmdMostDerived);
        // 
        // Remember this ourselves
        //
        ::Set(m_pmdMostDerived, pmdMostDerived);
        *pfDerivesFromIDispatch = FALSE;
        //
        // Let OUR base know the actual bottom level!
        //
        if (m_punkBaseInterceptor)
        {
            IInterceptorBase* pbase;
            hr = QI(m_punkBaseInterceptor, pbase);
            if (!hr)
            {
                pbase->SetAsBaseFor(pmdMostDerived, pfDerivesFromIDispatch);
                pbase->Release();
            }
        }
            
        return hr;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // ICallIndirect / ICallInterceptor, IInterfaceRelated
    //
    ///////////////////////////////////////////////////////////////////
public:
    HRESULT STDCALL CallIndirect    (HRESULT* phrReturnValue, ULONG iMethod, void* pvArgs, ULONG* pcbArgs); 
private:
    HRESULT STDCALL GetStackSize    (ULONG iMethod, ULONG* pcbArgs);

    HRESULT STDCALL GetIID          (IID* piid, BOOL* pfDerivesFromIDispatch, ULONG* pcMethod, LPWSTR* pwszInterface)
    {
        HRESULT hr = S_OK;

        if (m_pHeader)
        {
            if (piid) 
            {
                if (m_pmdMostDerived)
                {
                    *piid = *m_pmdMostDerived->m_pHeader->piid;
                }
                else
                {
                    *piid = *m_pHeader->piid;
                }
            }
            if (pfDerivesFromIDispatch)
            {
                *pfDerivesFromIDispatch = m_pmdInterface->m_fDerivesFromIDispatch;
            }
            if (pcMethod) 
            {
                if (m_pmdMostDerived)
                {
                    *pcMethod = m_pmdMostDerived->m_pHeader->DispatchTableCount;
                }
                else
                {
                    *pcMethod = m_pHeader->DispatchTableCount;
                }
            }
            if (pwszInterface)
            {
                *pwszInterface = NULL;

                if (m_pmdMostDerived)
                {
                    if (m_pmdMostDerived->m_szInterfaceName)
                    {
                        *pwszInterface = ToUnicode(m_pmdMostDerived->m_szInterfaceName);
                        if (NULL == *pwszInterface) hr = E_OUTOFMEMORY;
                    }
                }
                else if (m_pmdInterface->m_szInterfaceName)
                {
                    *pwszInterface = ToUnicode(m_pmdInterface->m_szInterfaceName);
                    if (NULL == *pwszInterface) hr = E_OUTOFMEMORY;
                }
            }
            return S_OK;
        }
        else
            hr = E_UNEXPECTED;

        return hr;
    }

    HRESULT STDCALL GetMethodInfo   (ULONG, CALLFRAMEINFO*, LPWSTR* pwszMethod);

    HRESULT STDCALL GetIID          (IID* piid)
    {
        if (m_pHeader)
        {
            if (piid)     *piid     = *m_pHeader->piid;
            return S_OK;
        }
        else
            return E_UNEXPECTED;
    }

    HRESULT STDCALL SetIID          (REFIID);

    HRESULT STDCALL RegisterSink    (ICallFrameEvents* psink)
    {
        ::SetConcurrent(m_pCallSink, psink);
        if (m_pBaseInterceptor) m_pBaseInterceptor->RegisterSink(psink);
        return S_OK;
    }

    HRESULT STDCALL GetRegisteredSink(ICallFrameEvents** ppsink)
    {
        *ppsink = NULL; // set concurrent releases what was there, if anything was
        ::SetConcurrent(*ppsink, m_pCallSink);
        return *ppsink ? S_OK : CO_E_OBJNOTREG;
    }


    ///////////////////////////////////////////////////////////////////
    //
    // ICallUnmarshal
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL Unmarshal(ULONG iMethod, PVOID pBuffer, ULONG cbBuffer, BOOL fForceBufferCopy, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx, ULONG* pcbUnmarshalled, ICallFrame** ppFrame);
    HRESULT STDCALL ReleaseMarshalData(ULONG iMethod, PVOID pBuffer, ULONG cbBuffer, ULONG ibFirstRelease, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx);

    // Xml Marshalling
    HRESULT STDCALL UnmarshalXml(ULONG iMethod, PVOID pBuffer, ULONG cbBuffer, BOOL fForceBufferCopy, RPCOLEDATAREP dataRep, CALLFRAME_MARSHALCONTEXT* pctx, ULONG* pcbUnmarshalled, ICallFrame** ppFrame);

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    IUnknown*   m_punkOuter;
    LONG        m_refs;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL InnerAddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;}

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }

    IUnknown* InnerUnknown()    { return (IUnknown*)(void*)(IUnkInner*)this; }
};


////////////////////////////////////////////////////////////////////////////////////////////
//
// Channel object to help with marshalling and unmarshalling
//
////////////////////////////////////////////////////////////////////////////////////////////

struct MarshallingChannel : IRpcChannelBuffer2, IMarshallingManager, IUnkInner
{
    ///////////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////////

    IMarshallingManager* m_pMarshaller;
    ULONG                m_dwDestContext;
    PVOID                m_pvDestContext;

    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    MarshallingChannel(IUnknown* punkOuter = NULL)
    {
        m_refs              = 1;    // nb starts at one. In stack alloc case, it remains there
        m_punkOuter         = punkOuter ? punkOuter : (IUnknown*)(void*)(IUnkInner*)this;
        m_pMarshaller       = NULL;
    }
        
    ~MarshallingChannel()
    {
        ::Release(m_pMarshaller);
    }
        

    ///////////////////////////////////////////////////////////////////
    //
    // IMarshallingManager
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetMarshallerFor(REFIID iidToMarshal, void*pv, IMarshalSomeone** ppMarshal)
    {
        if (m_pMarshaller)
            return m_pMarshaller->GetMarshallerFor(iidToMarshal, pv, ppMarshal);
        else    
        {
            *ppMarshal = NULL;
            return E_UNEXPECTED;
        }
    }

    HRESULT STDCALL GetStandardMarshallerFor(REFIID iidToMarshal, PVOID pv, IUnknown* punkOuter, REFIID iid, void** ppv)
    {
        if (m_pMarshaller)
            return m_pMarshaller->GetStandardMarshallerFor(iidToMarshal, pv, punkOuter, iid, ppv);
        else    
        {
            *ppv= NULL;
            return E_UNEXPECTED;
        }
    }

    HRESULT STDCALL GetUnmarshaller(REFIID iidHint, IMarshalSomeone** ppMarshal)
    {
        if (m_pMarshaller)
            return m_pMarshaller->GetUnmarshaller(iidHint, ppMarshal);
        else
        {
            *ppMarshal = NULL;
            return E_UNEXPECTED;
        }
    }

    ///////////////////////////////////////////////////////////////////
    //
    // IRpcChannelBuffer. We implement only to be able to be stuck into a stub message
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetBuffer(RPCOLEMESSAGE *pMessage, REFIID riid)         { return E_NOTIMPL; }
    HRESULT STDCALL SendReceive(RPCOLEMESSAGE *pMessage, ULONG *pStatus)    { return E_NOTIMPL; }
    HRESULT STDCALL FreeBuffer(RPCOLEMESSAGE *pMessage)                     { return E_NOTIMPL; }
    HRESULT STDCALL GetDestCtx(DWORD *pdwDestContext,void **ppvDestContext) 
    { 
        *pdwDestContext = m_dwDestContext;
        *ppvDestContext = m_pvDestContext;
        return S_OK;
    }
    HRESULT STDCALL IsConnected()                                           { return E_NOTIMPL; }

    ///////////////////////////////////////////////////////////////////
    //
    // IRpcChannelBuffer2. We implement only to be able to be stuck into a stub message,
    // so we can ask for a high enough DCOM version.
    //
    ///////////////////////////////////////////////////////////////////
    HRESULT STDCALL GetProtocolVersion(DWORD *pdwVersion)
    {
        *pdwVersion = MAKELONG(COM_MAJOR_VERSION, COM_MINOR_VERSION);
        return(S_OK);
    }


    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    IUnknown*   m_punkOuter;
    LONG        m_refs;

    HRESULT STDCALL InnerQueryInterface(REFIID iid, LPVOID* ppv)
    {
        if ((iid == IID_IRpcChannelBuffer) || (iid == IID_IRpcChannelBuffer2))
        {
            *ppv = (IRpcChannelBuffer2*)this;
        }
        else if (iid == __uuidof(IMarshallingManager))
        {
            *ppv = (IMarshallingManager*)this;
        }
        else if (iid == IID_IUnknown)
        {
            *ppv = (IUnkInner*)this;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }
    ULONG   STDCALL InnerAddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL InnerRelease()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs;}

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv) { return m_punkOuter->QueryInterface(iid, ppv); }
    ULONG   STDCALL AddRef()    { return m_punkOuter->AddRef();  }
    ULONG   STDCALL Release()   { return m_punkOuter->Release(); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\midlver.h ===
#ifndef __MIDLVER_H__
#define __MIDLVER_H__

//
// The MIDL version is contained in the stub descriptor starting with
// MIDL version 2.00.96 (pre NT 3.51 Beta 2, 2/95) and can be used for a finer
// granularity of compatability checking.  The MIDL version was zero before
// MIDL version 2.00.96.  The MIDL version number is converted into
// an integer long using the following expression :
//     ((Major << 24) | (Minor << 16) | Revision)
//
#ifndef MIDL_NT_3_51
#define MIDL_NT_3_51           ((2UL << 24) | (0UL << 16) | 102UL)
#endif

#ifndef MIDL_VERSION_3_0_39
#define MIDL_VERSION_3_0_39    ((3UL << 24) | (0UL << 16) |  39UL)
#endif

#ifndef MIDL_VERSION_3_2_88
#define MIDL_VERSION_3_2_88    ((3UL << 24) | (2UL << 16) |  88UL)
#endif

#ifndef MIDL_VERSION_5_0_136
#define MIDL_VERSION_5_0_136   ((5UL << 24) | (0UL << 16) | 136UL)
#endif

#ifndef MIDL_VERSION_5_2_202
#define MIDL_VERSION_5_2_202   ((5UL << 24) | (2UL << 16) | 202UL)
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\metadata.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Metadata.h
//
struct MD_INTERFACE;
struct MD_METHOD;
struct MD_PARAM;
struct MD_INTERFACE_CACHE;

#include "typeinfo.h"

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//
// A structure to keep track of whether in a given type we have any interface pointers, 
// and, if so whether we have an upper bound on them
// 

inline BOOL IsUnbounded(LONG l)
{
    return l < 0;
}
inline void MakeUnbounded(LONG& l)
{
    l = -1;
    ASSERT(IsUnbounded(l));
}


struct HAS_INTERFACES
{
    LONG m_cInterfaces;
    
    HAS_INTERFACES()
    {
        m_cInterfaces = 0;
    }

    void MakeUnbounded()
    {
        ::MakeUnbounded(m_cInterfaces);
        ASSERT(IsUnbounded());
    }

    BOOL IsUnbounded() const
    {
        return ::IsUnbounded(m_cInterfaces);
    }

    BOOL HasAnyInterfaces() const
    {
        return m_cInterfaces != 0;
    }

    void Add(const HAS_INTERFACES& him)
    {
        if (!IsUnbounded())
        {
            if (him.IsUnbounded())
                MakeUnbounded();
            else
                m_cInterfaces += him.m_cInterfaces;
        }
    } 

    void Update(LONG& cInterfaces) const
      // Update external state variables based on our contents
    {
        if (!::IsUnbounded(cInterfaces))
        {
            if (this->IsUnbounded())
                ::MakeUnbounded(cInterfaces);
            else
                cInterfaces += m_cInterfaces;
        }
    }

};

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

HAS_INTERFACES IsShareableType(PFORMAT_STRING pFormat);

inline BOOL IsPointer(PFORMAT_STRING pFormat)
{
    // FC_RP, FC_UP, FC_OP, and FC_FP are contiguous
    return (FC_RP <= *pFormat && *pFormat <= FC_FP);
}

inline HAS_INTERFACES IsSharableEmbeddedRepeatPointers(PFORMAT_STRING& pFormat)
{
    HAS_INTERFACES me;

    LONG repeatCount;

    if (*pFormat == FC_FIXED_REPEAT)
    {
        pFormat += 2;                       
        repeatCount = *(ushort*)pFormat;
    }
    else
    {
        repeatCount = 0;                    // a variable repeat count: treat as unbounded if we get any interfaces at all
    }

    pFormat += 2;                           // increment to increment field
    pFormat += sizeof(ushort);              // skip that 
    pFormat += 2;                           // ignore the 'array offset'

    ULONG cPointersSave = *(ushort*)pFormat;// get number of pointers in each array element
    pFormat += sizeof(ushort);

    PFORMAT_STRING pFormatSave = pFormat;
    ULONG          cPointers   = cPointersSave;
    //
    // Loop over the number of pointers per array element. Can be more than one for an array of structures
    //
    for ( ; cPointers--; )
    {
        pFormat += 4;
        ASSERT(IsPointer(pFormat));         // recurse to check the pointer

        HAS_INTERFACES him = IsShareableType(pFormat);
        if (repeatCount == 0 && him.HasAnyInterfaces())
        {
            me.MakeUnbounded();             // A variable repeat count of any interfaces is out of here!
        }
        else
        {
            him.m_cInterfaces *= repeatCount; // Scale his interface count by our array size
            me.Add(him);                      // fold in his contribution
        }

        pFormat += 4;                       // increment to the next pointer description
    }

    // return location of format string after the array's pointer description
    pFormat = pFormatSave + cPointersSave * 8;
    return me;
}

///////////////////////////////////////////////////////////////////////

inline HAS_INTERFACES IsSharableEmbeddedPointers(PFORMAT_STRING pFormat)
{
    HAS_INTERFACES me;

    pFormat += 2;   // Skip FC_PP and FC_PAD
    while (FC_END != *pFormat)
    {
        if (FC_NO_REPEAT == *pFormat)
        {
            pFormat += 6;                   // increment to the pointer description

            ASSERT(IsPointer(pFormat));     // recurse to check the pointer
            me.Add(IsShareableType(pFormat));

            pFormat += 4;                   // increment to the next pointer description
        }
        else
        {
            me.Add(IsSharableEmbeddedRepeatPointers(pFormat));
        }
    }
    return me;
}

///////////////////////////////////////////////////////////////////////

inline HAS_INTERFACES IsShareableType(PFORMAT_STRING pFormat)
  // We don't want to spend too much time figuring this out, as the whole point of asking is to save
  // time in the copying process. Err on the conservative side if we have to and answer FALSE.
{
    HAS_INTERFACES me;

    switch(*pFormat)
    {
    case FC_STRUCT:     case FC_CSTRUCT:        case FC_C_CSTRING:      case FC_C_BSTRING:
    case FC_C_SSTRING:  case FC_C_WSTRING:      case FC_CSTRING:        case FC_BSTRING:
    case FC_SSTRING:    case FC_WSTRING:   
    case FC_CHAR:       case FC_BYTE:           case FC_SMALL:          case FC_WCHAR:
    case FC_SHORT:      case FC_LONG:           case FC_HYPER:          case FC_ENUM16:
    case FC_ENUM32:     case FC_DOUBLE:         case FC_FLOAT:
        //
        // No interfaces here!
        //     
        break;

    case FC_IP:
        me.m_cInterfaces = 1;
        break;

    case FC_RP:         case FC_UP:             case FC_OP:
    {
        if (SIMPLE_POINTER(pFormat[1]))
        {
            // No interface pointers 
        }
        else
        {
            PFORMAT_STRING pFormatPointee = pFormat + 2;
            pFormatPointee += *((signed short *)pFormatPointee);
            me.Add(IsShareableType(pFormatPointee));
        }
    }
    break;

    case FC_SMFARRAY:   // small fixed array
    case FC_LGFARRAY:   // large fixed array
    {
        if (pFormat[0] == FC_SMFARRAY)
            pFormat += 2 + sizeof(ushort);
        else
            pFormat += 2 + sizeof(ulong);

        if (pFormat[0] == FC_PP)
        {
            me.Add(IsSharableEmbeddedPointers(pFormat));
        }
        break;
    }

    case FC_CARRAY:     // conformant array
    {
        pFormat += 8;
        if (pFormat[0] == FC_PP)
        {
            if (IsSharableEmbeddedPointers(pFormat).HasAnyInterfaces())
            {
                // Ignore the count: any interfaces means no fixed upper bound since we're conformant
                //
                me.MakeUnbounded();
            }
        }
        break;
    }

    case FC_PSTRUCT:
    {
        pFormat += 4;
        me.Add(IsSharableEmbeddedPointers(pFormat));
        break;
    }

    case FC_BOGUS_ARRAY:  // NYI
    case FC_BOGUS_STRUCT: // NYI
    case FC_USER_MARSHAL: // NYI

    default:
        me.MakeUnbounded();
        break;
    }

    return me;
}


///////////////////////////////////////////////////////////////////////


inline HAS_INTERFACES CanShareParameter(PMIDL_STUB_DESC pStubDesc, const PARAM_DESCRIPTION& param, const PARAM_ATTRIBUTES& paramAttr)
  // Answer whether this parameter is the kind of parameter which can be shared by a child
  // frame with its parent. We answer based on the parameter type only; caller is responsible for,
  // e.g., checking whether any sort of sharing is allowed at all.
  //
  // REVIEW: There are probably more cases that can legitimately be shared beyond
  // those which we presently call out.
  //
{
    if (paramAttr.IsBasetype)   // Covers simple refs thereto too. All cases are shareable.
    {
        return HAS_INTERFACES();
    }
    else
    {
        PFORMAT_STRING pFormat = pStubDesc->pFormatTypes + param.TypeOffset;
        return IsShareableType(pFormat);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

struct MD_PARAM
{
    BOOL                        m_fCanShare;
    BOOL                        m_fMayHaveInterfacePointers;
};

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

struct MD_METHOD
{
    ///////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////

    ULONG                       m_numberOfParams;       // number of parameters, not counting the receiver
    PPARAM_DESCRIPTION          m_params;
    INTERPRETER_OPT_FLAGS       m_optFlags;
    ULONG                       m_rpcFlags;
    PMIDL_STUB_DESC             m_pStubDesc;
    ULONG                       m_cbPushedByCaller;
    USHORT                      m_cbClientBuffer;
    USHORT                      m_cbServerBuffer;
    ULONG                       m_cbStackInclRet;

    ///////////////////////////////////////

    CALLFRAMEINFO               m_info;
    BOOL                        m_fCanShareAllParameters;

    ///////////////////////////////////////

    const CInterfaceStubHeader* m_pHeader;
    ULONG                       m_iMethod;
    struct MD_INTERFACE*        m_pmdInterface;
    MD_PARAM*                   m_rgParams;
    LPWSTR                      m_wszMethodName;
    PNDR_PROC_HEADER_EXTS       m_pHeaderExts;

    ///////////////////////////////////////////////////////////////
    //
    // Meta data setting
    //
    ///////////////////////////////////////////////////////////////

    void SetMetaData(const CInterfaceStubHeader* pHeader, ULONG iMethod, struct MD_INTERFACE* pmdInterface, TYPEINFOVTBL* pTypeInfoVtbl)
      // Initialize our meta data that has other than to do with parameters
    {
        // Set up the key pieces of base information
        //
        m_pHeader       = pHeader;
        m_iMethod       = iMethod;
        m_pmdInterface  = pmdInterface;
        //
        // Extract the key information from the format string
        //
        PMIDL_SERVER_INFO   pServerInfo      = (PMIDL_SERVER_INFO) m_pHeader->pServerInfo;
        m_pStubDesc        = pServerInfo->pStubDesc;
        ushort              formatOffset     = pServerInfo->FmtStringOffset[m_iMethod];

        m_numberOfParams = 0;

        if (formatOffset != 0xffff)
        {
            PFORMAT_STRING pFormat;
            INTERPRETER_FLAGS interpreterFlags;
            ULONG procNum;
            PFORMAT_STRING pNewProcDescr;
            ULONG numberOfParamsInclRet;
            
            pFormat = &pServerInfo->ProcString[formatOffset];
            ASSERT(pFormat[0] != 0);  // no explicit handle is permitted, must be implicit

            interpreterFlags = *((PINTERPRETER_FLAGS)&pFormat[1]);
    
            if (interpreterFlags.HasRpcFlags) 
            {
                m_rpcFlags = *(ulong UNALIGNED *)pFormat;
                pFormat += sizeof(ulong);
            }
            else
                m_rpcFlags = 0;

            procNum = *(USHORT*)(&pFormat[2]); ASSERT(procNum == m_iMethod);
            m_cbStackInclRet = *(USHORT*)(&pFormat[4]);

            pNewProcDescr = &pFormat[6]; // additional procedure descriptor info provided in the 'new' interprater
            m_cbClientBuffer = *(USHORT*)&pNewProcDescr[0];
            m_cbServerBuffer = *(USHORT*)&pNewProcDescr[2];
            m_optFlags = *((INTERPRETER_OPT_FLAGS*)&pNewProcDescr[4]);
            numberOfParamsInclRet = pNewProcDescr[5];     // includes return value
            m_params = (PPARAM_DESCRIPTION)(&pNewProcDescr[6]);

            if ( m_optFlags.HasExtensions )
            {
                m_pHeaderExts = (NDR_PROC_HEADER_EXTS *)m_params;
                m_params = (PPARAM_DESCRIPTION)(((uchar*)m_params) + (m_pHeaderExts->Size));
            }
            else 
            {
                m_pHeaderExts = NULL;
            }

            m_numberOfParams = m_optFlags.HasReturn ? numberOfParamsInclRet-1 : numberOfParamsInclRet;
            m_cbPushedByCaller = m_optFlags.HasReturn ? m_params[numberOfParamsInclRet-1].StackOffset : m_cbStackInclRet; // See ::GetStackSize
        }
            
        //
        // And some of the supplementary information
        //
        m_info.iid                      = *m_pHeader->piid;
        m_info.cMethod                  = m_pHeader->DispatchTableCount;
        m_info.iMethod                  = m_iMethod;
        m_info.cParams                  = m_numberOfParams;
        m_info.fHasInValues             = FALSE;
        m_info.fHasInOutValues          = FALSE;
        m_info.fHasOutValues            = FALSE;
        m_info.fDerivesFromIDispatch    = FALSE;
        m_info.cInInterfacesMax         = 0;
        m_info.cInOutInterfacesMax      = 0;
        m_info.cOutInterfacesMax        = 0;
        m_info.cTopLevelInInterfaces    = 0;
        //
        m_fCanShareAllParameters        = TRUE;     // until proven otherwise
        //
        if (pTypeInfoVtbl && pTypeInfoVtbl->m_rgMethodDescs[m_iMethod].m_szMethodName)
        {
            m_wszMethodName = CopyString(pTypeInfoVtbl->m_rgMethodDescs[m_iMethod].m_szMethodName);
        }
        else
            m_wszMethodName = NULL;
    }

    MD_METHOD()
    {
        m_wszMethodName = NULL;
    }

    ~MD_METHOD()
    {
        CoTaskMemFree(m_wszMethodName);
    }

    void SetParamMetaData(MD_PARAM* rgParams)
      // Set our parameter-based meta data. Caller is giving a big-enough array of parameter meta data.
    {
        m_rgParams = rgParams;
        //
        // Iterate through each parameter
        //
        for (ULONG iparam = 0; iparam < m_numberOfParams; iparam++)
        {
            const PARAM_DESCRIPTION& param   = m_params[iparam];
            const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
            //
            const HAS_INTERFACES me = CanShareParameter(m_pStubDesc, param, paramAttr);
            const BOOL fShare = !me.HasAnyInterfaces();
            //
            m_rgParams[iparam].m_fMayHaveInterfacePointers = me.HasAnyInterfaces();
            //
            m_rgParams[iparam].m_fCanShare = fShare;
            m_fCanShareAllParameters = (m_fCanShareAllParameters && fShare);
            //
            if (!!paramAttr.IsIn)        
            {
                if (!!paramAttr.IsOut)
                {
                    m_info.fHasInOutValues  = TRUE;
                    me.Update(m_info.cInOutInterfacesMax);
                }
                else
                {
                    m_info.fHasInValues  = TRUE;
                    me.Update(m_info.cInInterfacesMax);
                    //
                    // Update the top-level in-interface count
                    //
                    PFORMAT_STRING pFormatParam = m_pHeader->pServerInfo->pStubDesc->pFormatTypes + param.TypeOffset;
                    BOOL fIsInterfacePointer = (*pFormatParam == FC_IP);
                    if (fIsInterfacePointer)
                    {
                        m_info.cTopLevelInInterfaces++;
                    }
                }
            }
            else if (!!paramAttr.IsOut)
            {
                m_info.fHasOutValues  = TRUE;
                me.Update(m_info.cOutInterfacesMax);
            }
        }
    }

};

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

struct MD_INTERFACE
{
    ///////////////////////////////////////////////////////////////
    //
    // State
    //
    ///////////////////////////////////////////////////////////////

    LONG                        m_refs;

    ULONG                       m_cMethods;
    ULONG                       m_cMethodsInBaseInterface;

    MD_METHOD*                  m_rgMethodsAlloc;
    MD_METHOD*                  m_rgMethods;
    MD_PARAM*                   m_rgParams;

    BOOL                        m_fFreeInfoOnRelease;
    BOOL                        m_fDerivesFromIDispatch;
    const CInterfaceStubHeader* m_pHeader;
    LPCSTR                      m_szInterfaceName;

    struct MD_INTERFACE_CACHE*  m_pcache;

    ///////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////

    MD_INTERFACE()
    {
        m_rgMethodsAlloc = NULL;
        m_rgParams       = NULL;
        m_pcache         = NULL;
        
        m_fFreeInfoOnRelease = FALSE;

        m_refs           = 1;
    }

    ULONG AddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG Release();

    HRESULT AddToCache(MD_INTERFACE_CACHE* pcache);

private:

    ~MD_INTERFACE()
    {
        delete [] m_rgMethodsAlloc;
        delete [] m_rgParams;

        if (m_fFreeInfoOnRelease)
        {
            delete const_cast<CInterfaceStubHeader*>(m_pHeader);
            CoTaskMemFree(*const_cast<LPSTR*>(&m_szInterfaceName));
        }
    }

public:

    ///////////////////////////////////////////////////////////////
    //
    // Meta data setting
    //
    ///////////////////////////////////////////////////////////////

    HRESULT SetMetaData(TYPEINFOVTBL* pTypeInfoVtbl, const CInterfaceStubHeader* pHeader, LPCSTR szInterfaceName)
      // Set the meta data of this interface given a reference to the header
    {
        HRESULT hr = S_OK;
        //
        m_fFreeInfoOnRelease = (pTypeInfoVtbl != NULL);
        m_pHeader            = pHeader;
        m_szInterfaceName    = szInterfaceName;
        m_fDerivesFromIDispatch = FALSE;
        //
        m_cMethods = m_pHeader->DispatchTableCount;
        
        //
        // Figure out how many methods are in the base interface.
        //
        if (pTypeInfoVtbl)
        {
            if (pTypeInfoVtbl->m_iidBase == IID_IUnknown)
            {
                m_cMethodsInBaseInterface = 3;
            }
            else if (pTypeInfoVtbl->m_iidBase == IID_IDispatch)
            {
                m_cMethodsInBaseInterface = 7;
            }
            else
            {
                m_cMethodsInBaseInterface = 3;
            }
        }
        else
        {
            m_cMethodsInBaseInterface = 3;
        }
        ASSERT(m_cMethodsInBaseInterface >= 3);

        //
        // Allocate and initialize the md for each method
        //
        ULONG cMethods = m_cMethods - m_cMethodsInBaseInterface;
        m_rgMethodsAlloc = new MD_METHOD[cMethods];
        if (m_rgMethodsAlloc)
        {
            m_rgMethods = &m_rgMethodsAlloc[-(LONG)m_cMethodsInBaseInterface];
            for (ULONG iMethod = m_cMethodsInBaseInterface; iMethod < m_cMethods; iMethod++)
            {
                m_rgMethods[iMethod].SetMetaData(m_pHeader, iMethod, this, pTypeInfoVtbl);
            }
            //
            // How many parameters are there, total?
            //
            ULONG cParam = 0;
            for (iMethod = m_cMethodsInBaseInterface; iMethod < m_cMethods; iMethod++)
            {
                cParam += m_rgMethods[iMethod].m_numberOfParams;
            }
            //
            // Allocate and initialize the parameter information
            //
            m_rgParams = new MD_PARAM[cParam];
            if (m_rgParams)
            {
                cParam = 0;
                for (iMethod = m_cMethodsInBaseInterface; iMethod < m_cMethods; iMethod++)
                {
                    m_rgMethods[iMethod].SetParamMetaData(&m_rgParams[cParam]);
                    cParam += m_rgMethods[iMethod].m_numberOfParams;
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            hr = E_OUTOFMEMORY;

        return hr;
    }

    HRESULT SetDerivesFromIDispatch(BOOL fDerivesFromIDispatch)
    {
        m_fDerivesFromIDispatch = fDerivesFromIDispatch;

        for (ULONG iMethod = m_cMethodsInBaseInterface; iMethod < m_cMethods; iMethod++)
        {
            m_rgMethods[iMethod].m_info.fDerivesFromIDispatch = fDerivesFromIDispatch;
        }
        return S_OK;
    }
};


///////////////////////////////////////////////////////////////////////////
//
// MD_INTERFACE_CACHE
//
///////////////////////////////////////////////////////////////////////////

//
// NOTE: The constructor of this object can throw an exception, because
//       MAP_SHARED contains an XSLOCK, and, well.... look at the comment
//       on MAP_SHARED in lookaside.h.
//
struct MD_INTERFACE_CACHE : MAP_SHARED<MAP_KEY_GUID, MD_INTERFACE*>
{
    /////////////////////////////////////////////////
    //
    // Construction & destruction
    //
    /////////////////////////////////////////////////

    MD_INTERFACE_CACHE()
    {
    }

    ~MD_INTERFACE_CACHE()
    {
        //
        // Before the cache is destroyed, all interceptors therein should be
        // too, which will remove themselves from us.
        //
        // ASSERT(0 == Size() && "likely leak: interceptor support dll unloading while interceptors still exist");
    }

    /////////////////////////////////////////////////
    //
    // Operations
    //
    /////////////////////////////////////////////////

    HRESULT FindExisting(REFIID iid, MD_INTERFACE** ppmdInterface)
    {
        HRESULT hr = S_OK;
        *ppmdInterface = NULL;
        
        LockShared();

        if (Lookup(iid, ppmdInterface))
        {
            (*ppmdInterface)->AddRef(); // give caller his own reference
        }
        else
            hr = E_NOINTERFACE;

        ReleaseLock();

        return hr;
    }

};

inline HRESULT MD_INTERFACE::AddToCache(MD_INTERFACE_CACHE* pcache)
  // Add us into the indicated cache. We'd better not already be in one
{
    HRESULT hr = S_OK;
    ASSERT(NULL == m_pcache);
    ASSERT(pcache);

    pcache->LockExclusive();

    const IID& iid = *m_pHeader->piid;
    ASSERT(iid != GUID_NULL);
    ASSERT(!pcache->IncludesKey(iid));

    if (pcache->SetAt(iid, this))
    {
        m_pcache = pcache;
    }
    else
        hr = E_OUTOFMEMORY;

    pcache->ReleaseLock();
    return hr;
}

inline ULONG MD_INTERFACE::Release()  
  // Release a MD_INTERFACE. Careful: if we're in the cache, then we could be dug out 
  // from the cache to get more references.
{
    // NOTE:
    //
    // This code is WRONG if m_pcache can change out from underneath us. But it can't
    // in current usage because the cache/no-cache decision is always made as part of
    // the creation logic, which is before another independent thread can get a handle
    // on us.
    //
    // If this ceases to be true, then we can deal with it by stealing a bit from the ref count word 
    // for the 'am in cache' decistion and interlocked operations to update the ref count and this 
    // bit together.
    //
    if (m_pcache)
    {
        // We're in a cache. Get us out of there carefully.
        //
        LONG crefs;
        //
        for (;;)
        {
            crefs = m_refs;
            //
            if (crefs > 1)
            {
                // There is at least one non-cache reference out there. We definitely won't
                // be poofing if we release with that condition holding
                //
                if (crefs == InterlockedCompareExchange(&m_refs, (crefs - 1), crefs))
                {
                    return crefs - 1;
                }
                else
                {
                    // Someone diddled with the ref count while we weren't looking. Go around and try again
                }
            }
            else
            {
                MD_INTERFACE_CACHE* pcache = m_pcache;  ASSERT(pcache);
                //
                pcache->LockExclusive();
                //
                crefs = InterlockedDecrement(&m_refs);
                if (0 == crefs)
                {
                    // The last public reference just went away, and, because the cache is locked, no
                    // more can appear. Nuke us!
                    //
                    const IID& iid = *m_pHeader->piid;
                    ASSERT(pcache->IncludesKey(iid));
                    //
                    pcache->RemoveKey(iid);
                    m_pcache = NULL;
                    //
                    delete this;
                }
                //
                pcache->ReleaseLock();
                //
                return crefs;
            }
#ifdef _X86_
            _asm 
            {
                _emit 0xF3
                _emit 0x90
            };
#endif
        }
    }
    else
    {
        // We are getting released, yet we have yet to ever be put into the cache. Just
        // the normal, simple case. 
        //
        long crefs = InterlockedDecrement(&m_refs); 
        if (crefs == 0)
        {
            delete this;
        }
        return crefs;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\interceptor.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Interceptor.cpp
//
#include "stdpch.h"
#include "common.h"
#include "ndrclassic.h"
#include "typeinfo.h"
#include "tiutil.h"
#include "CLegInterface.H"
#include "midlver.h"

#include <debnot.h>

#include "cache.h"

extern CALLFRAME_CACHE<INTERFACE_HELPER_CLSID>* g_pihCache;

BOOL NdrpFindInterface(
    IN  const ProxyFileInfo **  pProxyFileList,
    IN  REFIID                  riid,
    OUT const ProxyFileInfo **  ppProxyFileInfo,
    OUT long *                  pIndex);

/////////////////////////////////////////////////////////////////////////////////
//
// Registry support for disabling interceptors works as follows:
//
//  HKCR/Interface/"InterfaceHelperDisableAll"      - disables all interceptors
//  HKCR/Interface/"InterfaceHelperDisableTypeLib"  - disables all typelib-based interceptors
//   
//  HKCR/Interface/{iid}/"InterfaceHelperDisableAll"      - disables all interceptors for this IID
//  HKCR/Interface/{iid}/"InterfaceHelperDisableTypeLib"  - disables typelib-based interceptor for this IID
//
#define CALLFRAME_E_DISABLE_INTERCEPTOR (HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED))

// Answer as to whether there's an indicatation that interceptors semantically
// related to this key should be disabled.
BOOL FDisableAssociatedInterceptor(HREG hkey, LPCWSTR wsz)
{
    HRESULT hr = S_OK;

    BOOL fDisable = FALSE;

    PKEY_VALUE_FULL_INFORMATION pinfo = NULL;
    hr = GetRegistryValue(hkey, wsz, &pinfo, REG_SZ);
    Win4Assert(pinfo || FAILED(hr));
    if (!hr && pinfo)
    {
        // Disable if is not N or is non-zero
        //
        LPWSTR wsz = StringFromRegInfo(pinfo);
        if (wcslen(wsz) > 0)
        {
            LPWSTR wszEnd;
            LONG l = wcstol(wsz, &wszEnd, 10);
            if (wsz[0] == 'n' || wsz[0] == 'N' || l == 0)
            {
                fDisable = FALSE;
            }
            else
            {
                fDisable = TRUE;
            }
        }
        else
        {
            fDisable = TRUE;    // empty value
        }

        CoTaskMemFree(pinfo);
    }
    else
    {
        // No disable key: leave enabled
    }

    return fDisable;
}


struct DISABLED_FEATURES
{
    BOOL    fDisableAll;
    BOOL    fDisableTypelibs;
    BOOL    fDisableDispatch;
    BOOL    fDisableAllForOle32;
    BOOL    fDisableDispatchForOle32;

    void INIT_DISABLED_FEATURES()
    {
        HRESULT hr = S_OK;
        HREG hkey;        
        hr = OpenRegistryKey(&hkey, HREG(), L"\\Registry\\Machine\\Software\\Classes\\Interface");
        if (!hr)
        {
            fDisableAll         = FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_ALL_VALUE_NAME);
            fDisableAllForOle32 = FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_ALL_FOR_OLE32_VALUE_NAME);
            fDisableTypelibs    = FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_TYPELIB_VALUE_NAME);

            CloseRegistryKey(hkey);
        }
        hr = OpenRegistryKey(&hkey, HREG(), L"\\Registry\\Machine\\Software\\Classes\\Interface\\{00020400-0000-0000-C000-000000000046}");
        if (!hr)
        {
            fDisableDispatch         = FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_ALL_VALUE_NAME);
            fDisableDispatchForOle32 = FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_ALL_FOR_OLE32_VALUE_NAME);
            CloseRegistryKey(hkey);
        }
    }
} g_DISABLED_FEATURES;

BOOL InitDisabledFeatures(void)
{
    g_DISABLED_FEATURES.INIT_DISABLED_FEATURES();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
//
// Public API
//
/////////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT STDCALL CoGetInterceptor(REFIID iidIntercepted, IUnknown* punkOuter, REFIID iid, void** ppInterceptor)
{
    return Interceptor::For(iidIntercepted, punkOuter, iid, ppInterceptor);
}

extern "C" HRESULT STDCALL CoGetInterceptorFromTypeInfo(REFIID iidIntercepted, IUnknown* punkOuter, ITypeInfo* typeInfo, REFIID iid, void** ppInterceptor)
{
    return Interceptor::ForTypeInfo(iidIntercepted, punkOuter, typeInfo, iid, ppInterceptor);
}

extern "C" HRESULT STDCALL CoGetInterceptorForOle32(REFIID iidIntercepted, IUnknown* punkOuter, REFIID iid, void** ppInterceptor)
{
    return Interceptor::ForOle32(iidIntercepted, punkOuter, iid, ppInterceptor);
}

/////////////////////////////////////////////////////////////////////////////////
//
// Constuction / destruction
//
/////////////////////////////////////////////////////////////////////////////////

Interceptor::~Interceptor()
{
    ::Release(m_pCallSink);
    ::Release(m_pBaseInterceptor);
    ::Release(m_punkBaseInterceptor);
    ::Release(m_pmdInterface);
    ::Release(m_pmdMostDerived);

    ::Release(m_ptypeinfovtbl);
    if (m_fUsingTypelib && !m_fMdOwnsHeader)
    {
        delete const_cast<CInterfaceStubHeader*>(m_pHeader); // See Interceptor::InitUsingTypeInfo
    }
}



HRESULT GetInterfaceHelperClsid(REFIID iid, CLSID* pClsid, BOOL* pfDisableTypelib)
  // Answer the CLSID that should serve as the interceptor for the indicated interface. 
  // This only looks for the "InterfaceHelper" override.
  //
  // Returns CALLFRAME_E_DISABLE_INTERCEPTOR if all interceptor functionality for this INTERFACE
  // is to be disabled.
  //
{
    HRESULT hr = S_OK, hrTemp;

    INTERFACE_HELPER_CLSID* pihCached, * pihInCache;

    // Give the cache a try
    if (!g_pihCache->FindExisting (iid, &pihCached))
    {
        ASSERT (pihCached);
        
        //
        // Imitate the logic below
        //
        
        // Disable typelib?
        *pfDisableTypelib = pihCached->m_fDisableTypeLib;

        // Disable all?
        if (pihCached->m_fDisableAll)
        {
            hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
        }
        else
        {
            if (pihCached->m_fFoundHelper)
            {
                *pClsid = pihCached->m_clsid;
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND);
            }
        }          

        // Release our reference
        pihCached->Release();

        return hr;
    }

    //
    // Cache miss
    //
    
    WCHAR wszKey[20 + GUID_CCH];
    wcscpy(wszKey, L"Interface\\");
    StringFromGuid(iid, &wszKey[wcslen(wszKey)]);

    HREG hkey;
    LPWSTR wszFullKeyName;

    BOOL bAddedToCache = FALSE;

    *pfDisableTypelib = FALSE;

    pihCached = new INTERFACE_HELPER_CLSID();   // Initializes everything to false
    if (!pihCached)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pihCached->m_guidkey = iid;

        hr = StringCat(&wszFullKeyName, L"\\Registry\\Machine\\Software\\Classes\\", wszKey, NULL);
        if (!hr)
        {
            hr = OpenRegistryKey(&hkey, HREG(), wszFullKeyName);
            if (!hr)
            {
                // See if we should avoid looking for interceptors 
                //
                if (FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_TYPELIB_VALUE_NAME))
                {
                    *pfDisableTypelib = TRUE;
                    pihCached->m_fDisableTypeLib = TRUE;
                }

                if (FDisableAssociatedInterceptor(hkey, INTERFACE_HELPER_DISABLE_ALL_VALUE_NAME))
                {
                    hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
                    pihCached->m_fDisableAll = TRUE;
                }
                else
                {
                    PKEY_VALUE_FULL_INFORMATION pinfo;
                    hr = GetRegistryValue(hkey, INTERFACE_HELPER_VALUE_NAME, &pinfo, REG_SZ);
                    if (!hr)
                    {
                        LPWSTR wszClsid = StringFromRegInfo(pinfo);
                        //
                        // Got the classid. Convert it!
                        //
                        hr = GuidFromString(&wszClsid[0], pClsid);

                        pihCached->m_fFoundHelper = TRUE;
                        pihCached->m_clsid = *pClsid;

                        CoTaskMemFree(pinfo);
                    }
                }
                CloseRegistryKey(hkey);
            }
            CoTaskMemFree(wszFullKeyName);

            // Add to cache
            hrTemp = pihCached->AddToCache (g_pihCache);
            if (SUCCEEDED(hrTemp))
            {
                bAddedToCache = TRUE;

                // Leave references at zero, because the cache shouldn't hold a reference
                // This allows us to time references out
                pihCached->Release();
            }
        }

        // Clean up entry if it didn't find its way to the cache
        if (!bAddedToCache)
        {
            delete pihCached;
        }
    }

    return hr;
}

HRESULT Interceptor::For(REFIID iidIntercepted, IUnknown *punkOuter, REFIID iid, void** ppv)
// Dynamically lookup and return the interceptor which services the given interface
//
{
    HRESULT hr = g_DISABLED_FEATURES.fDisableAll ? CALLFRAME_E_DISABLE_INTERCEPTOR : S_OK;

    *ppv = NULL;

    if (punkOuter && iid != IID_IUnknown)
    {
        // If aggregating, then you must ask for IUnknown
        //
        return E_INVALIDARG;
    }
    //
    // First attempt to create an interceptor using the InterfaceHelper key
    //
    BOOL fDisableTypelib = FALSE;
    if (!hr)
    {
        hr = Interceptor::TryInterfaceHelper(iidIntercepted, punkOuter, iid, ppv, &fDisableTypelib);
    }
    //
    //
    if (!hr)
    {
        // All is well
    }
    else if (fDisableTypelib)
    {
        hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
    }
    else if (hr != CALLFRAME_E_DISABLE_INTERCEPTOR)
    {
        // Can't get a MIDL-oriented interceptor; try something else.
        //
        if (ENABLE_INTERCEPTORS_TYPELIB)
        {
            //
            // There must not be an interfacehelper attribute for this iid, try the typelib path.
            //
            hr = Interceptor::TryTypeLib(iidIntercepted, punkOuter, iid, ppv);
        }
    }

    if (!hr)
    {
        ASSERT (*ppv);
    }

    return hr;
}

HRESULT Interceptor::ForOle32(REFIID iidIntercepted, IUnknown *punkOuter, REFIID iid, void** ppv)
  // Dynamically lookup and return the interceptor which services the given interface
  //
{
    HRESULT hr = g_DISABLED_FEATURES.fDisableAllForOle32 ? CALLFRAME_E_DISABLE_INTERCEPTOR : S_OK;

    *ppv = NULL;

    if (punkOuter && iid != IID_IUnknown)
    {
        // If aggregating, then you must ask for IUnknown
        //
        return E_INVALIDARG;
    }
    //
    // First attempt to create an interceptor using the InterfaceHelper key
    //
    BOOL fDisableTypelib = FALSE;
    if (!hr)
    {
        hr = Interceptor::TryInterfaceHelperForOle32(iidIntercepted, punkOuter, iid, ppv, &fDisableTypelib);
    }
    //
    //
    if (!hr)
    {
        // All is well
    }
    else if (fDisableTypelib)
    {
        hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
    }
    else if (hr != CALLFRAME_E_DISABLE_INTERCEPTOR)
    {
        // Can't get a MIDL-oriented interceptor; try something else.
        //
        if (ENABLE_INTERCEPTORS_TYPELIB)
        {
            //
            // There must not be an interfacehelper attribute for this iid, try the typelib path.
            // But not in kernel mode, as that causes linkages problems.
            //
            hr = Interceptor::TryTypeLib(iidIntercepted, punkOuter, iid, ppv);
        }
    }

    if (!hr)
    {
        ASSERT (*ppv);
    }

    return hr;
}

HRESULT Interceptor::ForTypeInfo(REFIID iidIntercepted, IUnknown* punkOuter, ITypeInfo* pITypeInfo, REFIID iid, void** ppv)
  // Create an interceptor for a given ITypeInfo that describes iidIntercepted.
  //
{
    HRESULT hr = g_DISABLED_FEATURES.fDisableAll ? CALLFRAME_E_DISABLE_INTERCEPTOR : S_OK;

    *ppv = NULL;

    if (punkOuter && iid != IID_IUnknown)
    {
        // If aggregating, then you must ask for IUnknown
        //
        return E_INVALIDARG;
    }

    // 
    // First, try an interface helper
    // 
    BOOL fDisableTypelib = FALSE;
    hr = Interceptor::TryInterfaceHelper(iidIntercepted, punkOuter, iid, ppv, &fDisableTypelib);
    if (!hr)
    {
        // All is well, the interface helper handled it.
    }
    else if (fDisableTypelib)
    {
        hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
    }
    else if (hr != CALLFRAME_E_DISABLE_INTERCEPTOR)
    {
        // Can't get a MIDL-oriented interceptor; try something else.
        //
        if (ENABLE_INTERCEPTORS_TYPELIB)
        {
            //
            // There must not be an interfacehelper attribute for this iid, use the
            // typeinfo.  But not in kernel mode, as that causes linkages problems.
            //
            hr = CreateFromTypeInfo(iidIntercepted, punkOuter, pITypeInfo, iid, ppv);
        }
    }

    return hr;
}

#define CLSCTX_PROXY_STUB   (CLSCTX_INPROC_SERVER | CLSCTX_PS_DLL)

HRESULT Interceptor::TryInterfaceHelper(REFIID iidIntercepted, IUnknown* punkOuter, REFIID iid, void** ppv, BOOL* pfDisableTypelib)
  // Lookup and return the interceptor, if any, which services the given intercepted interface
  //
  // Returns CALLFRAME_E_DISABLE_INTERCEPTOR if all interceptor functionality for this INTERFACE
  // is to be disabled.
  //
{
    HRESULT hr = S_OK;
    CLSID   clsid;
    IUnknown* punk = NULL;
    //
    *ppv = NULL;
    *pfDisableTypelib = FALSE;
    //
    if (ENABLE_INTERCEPTORS_LEGACY && (iidIntercepted == IID_IDispatch))
    {
        // We have a special-case implementation for the requested iid. Always get the 
        // inner unknown on it.
        // 
        if (!g_DISABLED_FEATURES.fDisableDispatch)
        {
            hr = GenericInstantiator<DISPATCH_INTERCEPTOR>::CreateInstance(punkOuter, __uuidof(IUnknown), (void**)&punk);
        }
        else
        {
            hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
            *pfDisableTypelib = TRUE;
        }
    }
    else
    {
        // We try to find dynamically installed helpers
        //
        hr = GetInterfaceHelperClsid(iidIntercepted, &clsid, pfDisableTypelib);
        if (!hr)
        {
            IClassFactory* pcf;

            hr = CoGetClassObject(clsid, CLSCTX_PROXY_STUB, NULL, IID_IClassFactory, (void**)&pcf);

            if (!hr)
            {
                // Always ask for the inner unknown
                //
                hr = pcf->CreateInstance(punkOuter, __uuidof(IUnknown), (void**)&punk);
                pcf->Release();
            }
        }
    }

    if (!hr)
    {
        ASSERT(punk);
        IInterfaceRelated* pSet;
        hr = punk->QueryInterface(__uuidof(IInterfaceRelated), (void**)&pSet);
        if (!hr)
        {
            hr = pSet->SetIID(iidIntercepted);
            if (!hr)
            {
                // Ask the inner unknown for the interface they guy wants
                //
                hr = punk->QueryInterface(iid, ppv);
            }
            pSet->Release();
        }
    }

    ::Release(punk);

    return hr;
}

HRESULT Interceptor::TryInterfaceHelperForOle32(REFIID iidIntercepted, IUnknown* punkOuter, REFIID iid, void** ppv, BOOL* pfDisableTypelib)
  // Lookup and return the interceptor, if any, which services the given intercepted interface
  //
  // Returns CALLFRAME_E_DISABLE_INTERCEPTOR if all interceptor functionality for this INTERFACE
  // is to be disabled.
  //
{
    HRESULT hr = S_OK;
    CLSID   clsid;
    IUnknown* punk = NULL;
    //
    *ppv = NULL;
    *pfDisableTypelib = FALSE;
    //
    if (ENABLE_INTERCEPTORS_LEGACY && (iidIntercepted == IID_IDispatch))
    {
        // We have a special-case implementation for the requested iid. Always get the 
        // inner unknown on it.
        // 
        if (!g_DISABLED_FEATURES.fDisableDispatchForOle32)
        {
            hr = GenericInstantiator<DISPATCH_INTERCEPTOR>::CreateInstance(punkOuter, __uuidof(IUnknown), (void**)&punk);
        }
        else
        {
            hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
            *pfDisableTypelib = TRUE;
        }
    }
    else
    {
        // We try to find dynamically installed helpers
        //
        hr = GetInterfaceHelperClsid(iidIntercepted, &clsid, pfDisableTypelib);
        if (!hr)
        {
            IClassFactory* pcf;

            hr = CoGetClassObject(clsid, CLSCTX_PROXY_STUB, NULL, IID_IClassFactory, (void**)&pcf);

            if (!hr)
            {
                // Always ask for the inner unknown
                //
                hr = pcf->CreateInstance(punkOuter, __uuidof(IUnknown), (void**)&punk);
                pcf->Release();
            }
        }
    }

    if (!hr)
    {
        ASSERT(punk);
        IInterfaceRelated* pSet;
        hr = punk->QueryInterface(__uuidof(IInterfaceRelated), (void**)&pSet);
        if (!hr)
        {
            hr = pSet->SetIID(iidIntercepted);
            if (!hr)
            {
                // Ask the inner unknown for the interface they guy wants
                //
                hr = punk->QueryInterface(iid, ppv);
            }
            pSet->Release();
        }
    }

    ::Release(punk);

    return hr;
}


HRESULT Interceptor::TryTypeLib(REFIID iidIntercepted, IUnknown* punkOuter, REFIID iid, void** ppv)
  // Try to create a typelib-based interceptor for the indicated interface
  //
{
    HRESULT         hr              = S_OK;
    CLSID           clsid           = CLSID_NULL;
    Interceptor *   pInterceptor    = NULL;

    if (g_DISABLED_FEATURES.fDisableTypelibs)
    {
        hr = CALLFRAME_E_DISABLE_INTERCEPTOR;
    }
    
    if (!hr)
    {
        // Create a new interceptor from the ITypeInfo.
        //
        hr = CreateFromTypeInfo(iidIntercepted, punkOuter, NULL, iid, ppv);
    }

    return hr;
} //end TryTypeLib

HRESULT Interceptor::CreateFromTypeInfo(REFIID iidIntercepted, IUnknown* punkOuter, ITypeInfo* pITypeInfo, REFIID iid, void** ppv)
{
    HRESULT hr = S_OK;

    Interceptor* pInterceptor = new Interceptor(punkOuter);
    if (pInterceptor)
    {
        // Initialize the interceptor
        //
        hr = pInterceptor->InitUsingTypeInfo(iidIntercepted, pITypeInfo);
        if (!hr)    
        {
            // Give caller his interface
            //
            hr = pInterceptor->InnerQueryInterface(iid, ppv);
        }
        //
        // Release the initial reference that 'new' gave us.
        //
        pInterceptor->InnerRelease();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////
//
// Initialization
//
/////////////////////////////////////////////////////////////////////////////////

HRESULT Interceptor::InitUsingTypeInfo(REFIID iidIntercepted, ITypeInfo * ptypeinfo)
  // Initialize a typelib-based interceptor
  //
{
    HRESULT                 hr              = S_OK;
    TYPEINFOVTBL *          pTypeInfoVtbl   = 0x0;  
    CInterfaceStubHeader *  pHeader         = 0x0;
    ITypeInfo*                              pBaseTypeInfo   = 0x0;
    //
    // Get the meta information regarding this interface. This gives us a new refcnt
    // 
    hr = GetVtbl(ptypeinfo, iidIntercepted, &pTypeInfoVtbl, &pBaseTypeInfo);
    if (!hr)
    {
        // Create a CInterfaceStubHeader object to store the information
        //
        pHeader = new CInterfaceStubHeader;
        if (pHeader)
        {
            // Remember that this uses the typelib to get the interface meta data
            //
            m_fUsingTypelib = TRUE;

            // initialize the structure
            //
            pHeader->piid               = &(pTypeInfoVtbl->m_guidkey);              
            pHeader->pServerInfo        = &(pTypeInfoVtbl->m_stubInfo); 
            pHeader->DispatchTableCount =  (pTypeInfoVtbl->m_stubVtbl.header.DispatchTableCount);
            pHeader->pDispatchTable     =  (pTypeInfoVtbl->m_stubVtbl.header.pDispatchTable);
            //
            // initialize our meta data therefrom
            //
            ASSERT(NULL == m_pHeader);
            m_pHeader       = pHeader;
            m_fMdOwnsHeader = FALSE;
            m_ptypeinfovtbl = pTypeInfoVtbl;
            m_ptypeinfovtbl->AddRef();
            //
            m_szInterfaceName = pTypeInfoVtbl->m_szInterfaceName; // share a ref, but we don't own it!
            //
            // Set our new meta data
            //
            hr = SetMetaData(pTypeInfoVtbl);

            if (!hr)
            {
                // Delegate base methods if appropriate
                //
                if (m_ptypeinfovtbl->m_iidBase != GUID_NULL && m_ptypeinfovtbl->m_iidBase != __uuidof(IUnknown))
                {
                    IID iidBase = m_ptypeinfovtbl->m_iidBase;
                    //
                    ASSERT(NULL == m_pBaseInterceptor);
                    ASSERT(NULL == m_punkBaseInterceptor);
                    //
                    hr = Interceptor::ForTypeInfo(iidBase, NULL, pBaseTypeInfo, IID_IUnknown, (void **) &m_punkBaseInterceptor);
                    if (!hr)
                    {
                        hr = m_punkBaseInterceptor->QueryInterface(__uuidof(ICallInterceptor), (void**)&m_pBaseInterceptor);
                        if (!hr)
                        {
                            // Ask the base interface how many methods he has
                            //
                            ULONG cMethodsBase;
                            hr = m_pBaseInterceptor->GetIID(NULL, NULL, &cMethodsBase, NULL);
                            if (!hr)
                            {
                                m_cMethodsBase = (unsigned int)cMethodsBase;
                            }
                        }
                    }
                    if (!hr)
                    {
                        // Tell the base interceptor that he is in fact a base!
                        //
                        IInterceptorBase* pbase;
                        hr = QI(m_punkBaseInterceptor, pbase);
                        if (!hr)
                        {
                            BOOL fDerivesFromIDispatch;
                            hr = pbase->SetAsBaseFor(m_pmdInterface, &fDerivesFromIDispatch);
                            if (!hr)
                            {
                                hr = m_pmdInterface->SetDerivesFromIDispatch(fDerivesFromIDispatch);
                            }
                            pbase->Release();
                        }
                    }
                }
            }
        }
        else
            hr = E_OUTOFMEMORY;

        pTypeInfoVtbl->Release();

        if (pBaseTypeInfo != NULL)
            pBaseTypeInfo->Release();
    }

    return hr;
} //end InityUsingTypeInfo


const CInterfaceStubHeader* HeaderFromStub(IRpcStubBuffer* This)
{
    // struct CInterfaceStubVtbl
    //  {
    //  CInterfaceStubHeader header;
    //  IRpcStubBufferVtbl Vtbl;                    <= *This points to here
    //  };
    //
    return &(*((const CInterfaceStubHeader**)This))[-1];
}

inline unsigned GetDelegatedMethodCount(const CInterfaceStubHeader* pHeader)
// Return the number of methods, which is always at least three, which are not herein defined.
//
{
    PMIDL_SERVER_INFO pServerInfo = (PMIDL_SERVER_INFO) pHeader->pServerInfo;

    const unsigned cMethod = pHeader->DispatchTableCount;
    for (unsigned iMethod = cMethod - 1; iMethod >= 3; iMethod--)
    {
        if ( (unsigned short)(-1) == pServerInfo->FmtStringOffset[iMethod] )
            return iMethod + 1;
    }
    return 3;
}

HRESULT Interceptor::SetIID(REFIID iid)
  // Set the interface ID for this interceptor. As a side effect, we set up our 
  // meta data. This method should only be called once per interceptor. 
  // Further, caller must control concurrency.
{
    ASSERT(NULL == m_pBaseInterceptor);
    ASSERT(NULL == m_pHeader);
    if (m_pBaseInterceptor || m_pHeader) return E_UNEXPECTED;

    HRESULT hr = S_OK;
    long j;
    const ProxyFileInfo *pProxyFileInfo;
    //
    // Is the requested interface something that this interceptor supports?
    //
    BOOL fFound = NdrpFindInterface(m_pProxyFileList, iid, &pProxyFileInfo, &j);
    if (fFound)
    {
        // Set our meta data
        //
        IRpcStubBufferVtbl* vptr = &pProxyFileInfo->pStubVtblList[j]->Vtbl;
        m_pHeader = HeaderFromStub((IRpcStubBuffer*)&vptr);
        //
        // Remember our interface name if it's given to us
        //
        m_szInterfaceName = pProxyFileInfo->pNamesArray[j]; // share a ref, but we don't own it!
        //
        // Set our new meta data
        //
        hr = SetMetaData(NULL);
        if (!hr)
        {
            // Set up a delegation interceptor for our base interface if we have to. When MIDL expects us to do delegation, 
            // we have no choice but to do so, since in those cases it doesn't bother to emit the meta data for the base interface.
            //
            BOOL fDelegate = 
              (pProxyFileInfo->pDelegatedIIDs     != 0) && 
              (pProxyFileInfo->pDelegatedIIDs[j]  != 0) && 
              (*pProxyFileInfo->pDelegatedIIDs[j]) != IID_IUnknown;

            if (fDelegate)
            {
                ULONG cMethodsInInterface       = pProxyFileInfo->pStubVtblList[j]->header.DispatchTableCount;
                ULONG cMethodsInBaseInterface   = GetDelegatedMethodCount(m_pHeader);
            
                m_cMethodsBase = cMethodsInBaseInterface; 
                ASSERT(m_cMethodsBase > 3); /* since fDelegate is true, there should actually be some */
                // 
                // Instantiate the interceptor for the base interface. Since we delegate explicitly to this guy, there's
                // no point in aggregating him into us.
                //
                IID iidBase = *pProxyFileInfo->pDelegatedIIDs[j];
                ASSERT(NULL == m_pBaseInterceptor);
                hr = Interceptor::For(iidBase, NULL, IID_IUnknown, (void **) &m_punkBaseInterceptor);
                if (!hr)
                {
                    hr = m_punkBaseInterceptor->QueryInterface(__uuidof(ICallInterceptor), (void**)&m_pBaseInterceptor);
                    if (!hr)
                    {
                        // Tell the base interceptor that he is in fact a base!
                        //
                        IInterceptorBase* pbase;
                        hr = QI(m_punkBaseInterceptor, pbase);
                        if (!hr)
                        {
                            BOOL fDerivesFromIDispatch;
                            hr = pbase->SetAsBaseFor(m_pmdInterface, &fDerivesFromIDispatch);
                            if (!hr)
                            {
                                m_pmdInterface->SetDerivesFromIDispatch(fDerivesFromIDispatch);
                            }
                            pbase->Release();
                        }
                    }
                }
            }
        }
    }
    else
        hr = E_NOINTERFACE;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////
//
// Meta data manipulation
//
/////////////////////////////////////////////////////////////////////////////////

MD_INTERFACE_CACHE* g_pmdCache;

BOOL InitMetaDataCache()
{
    g_pmdCache = new MD_INTERFACE_CACHE();
    if (g_pmdCache)
    {
        if (g_pmdCache->FInit()==FALSE)
        {
            ASSERT(FALSE);
            delete g_pmdCache;
            g_pmdCache = NULL;
        }
    }
    if (NULL == g_pmdCache)
    {
        return FALSE;
    }
    return TRUE;
}

void FreeMetaDataCache()
{
    if (g_pmdCache)
    {
        delete g_pmdCache;
        g_pmdCache = NULL;
    }
}


HRESULT Interceptor::SetMetaData(TYPEINFOVTBL* pTypeInfoVtbl)
  // Set our meta data based on m_pHeader && m_pmdInterface
{
    HRESULT hr = S_OK;

    ASSERT(m_pHeader);
    ASSERT(NULL == m_pmdInterface);

    HRESULT hr2 = g_pmdCache->FindExisting(*m_pHeader->piid, &m_pmdInterface);
    if (!hr2)
    {
        // Found it in the cache
    }
    else
    {
        // Not in the cache. Make a new one.
        //
        m_pmdInterface = new MD_INTERFACE;
        if (m_pmdInterface)
        {
            LPCSTR szInterfaceName = m_szInterfaceName;
            //
            // In typelib case, give the MD_INTERFACE a COPY of the string that it can own
            // so that it doesn't depend on the lifetime of the TYPEINFOVTBL.
            //
            if (pTypeInfoVtbl)
            {
                if (szInterfaceName)
                {
                    szInterfaceName = CopyString(szInterfaceName);
                    if (NULL == szInterfaceName)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            //
            // Actually initialize our meta data
            //
            if (!hr)
            {
                // NOTE: Regardless of pass/fail, m_pmdInterface owns szInterfaceName.
                hr = m_pmdInterface->SetMetaData(pTypeInfoVtbl, m_pHeader, szInterfaceName);
                if (pTypeInfoVtbl)
                {
                    m_fMdOwnsHeader = TRUE;
                }
            }

            if (!hr)
            {
                // Put it in the table if not already there; if already there, we were racing 
                // with someone else, who won. We'll use this MD_INTERFACE that we already have,
                // but we'll be the only client. Redundant, but not worth worrying about.
                //
                g_pmdCache->LockExclusive();

                if (!g_pmdCache->IncludesKey(*m_pHeader->piid))
                {
                    // One isn't yet there in the cache. Store ours
                    //
                    hr = m_pmdInterface->AddToCache(g_pmdCache);
                }

                g_pmdCache->ReleaseLock();
            }
            else
            {
                ::Release(m_pmdInterface);
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////
//
// COM plumbing
//
/////////////////////////////////////////////////////////////////////////////////


HRESULT Interceptor::InnerQueryInterface(REFIID iid, void**ppv)
{
    if (iid == IID_IUnknown)
    {
        *ppv = (IUnkInner*) this;
    }
    else if (m_pHeader && iid == *m_pHeader->piid)
    {
        // Unfortunately, this violates the letter of the QI stability rules, in that
        // the interface set we service will change after we have been fully initialized.
        // But, then, we've always hedged on the law in that case.
        //
        *ppv = &m_pvtbl;
    }
    else if (iid == __uuidof(ICallIndirect) || iid == __uuidof(ICallInterceptor))
    {
        *ppv = (ICallInterceptor*) this;
    }
    else if (iid == __uuidof(IInterfaceRelated))
    {
        *ppv = (IInterfaceRelated*) this;
    }
    else if (iid == __uuidof(ICallUnmarshal))
    {
        *ppv = (ICallUnmarshal*) this;
    }
    else if (iid == __uuidof(IInterceptorBase))
    {
        *ppv = (IInterceptorBase*) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

HRESULT SanityCheck(const CInterfaceStubHeader* pHeader, ULONG iMethod)
// Make sure that the meta data we have for this method at least smells somewhat pretty
//
{
#ifdef _DEBUG
    // Check the method number for sanity before we try to use it to index into the meta data
    //
    if ((iMethod >= pHeader->DispatchTableCount) || (iMethod < 3))          
        return RPC_E_INVALIDMETHOD;
    
    PMIDL_SERVER_INFO pServerInfo  = (PMIDL_SERVER_INFO) pHeader->pServerInfo;
    PMIDL_STUB_DESC   pStubDesc    = pServerInfo->pStubDesc;
    unsigned short    formatOffset = pServerInfo->FmtStringOffset[iMethod];
    PFORMAT_STRING    pFormat      = &pServerInfo->ProcString[formatOffset];
    //
    // Since MIDL 3.0.39 there has been an explicit proc flag that indicates which interpeter to 
    // call. Earlier versions used some other means that we don't support.
    //
    if ( !(MIDL_VERSION_3_0_39 <= pServerInfo->pStubDesc->MIDLVersion) )    
        return RPC_E_VERSION_MISMATCH;
    //
    // Our code will assume elsewhere that the format string of a procedure descriptor
    // doesn't have an explicit_handle_description. It's presence is signified by a
    // handle_type of 0. handle_type is the first element in the format string
    //
    if (0 == pFormat[0])                                                    
        return RPC_E_VERSION_MISMATCH;    
#endif
    
    return S_OK;
}


HRESULT STDCALL Interceptor::CallIndirect(HRESULT* phReturnValue, ULONG iMethod, void* pvArgs, ULONG* pcbArgs)
  // Indirectly invoke the indicated method on the object to which we are connected
{
    HRESULT hr = S_OK;
        
    if (phReturnValue)
        *phReturnValue = CALLFRAME_E_COULDNTMAKECALL;
        
    if (iMethod < m_cMethodsBase)
    {
        if (m_pBaseInterceptor)
        {
            // This method is one that our base interface will handle. Tell him to do so
            //
            hr = m_pBaseInterceptor->CallIndirect(phReturnValue, iMethod, pvArgs, pcbArgs);
        }
        else
            hr = E_UNEXPECTED;
    }
    else
    {
        hr = SanityCheck(m_pHeader, iMethod);
                
        if (!hr)
        {
            MD_METHOD* pmd = &m_pmdInterface->m_rgMethods[iMethod];
            //
            // OK! Do the work. Do we have a sink? If not, then it isn't worth doing much...
            //
            if (m_pCallSink)
            {
                // Create a call frame and ping our sink.
                //
                CallFrame* pNewFrame = new CallFrame;   // reference count starts as one
                if (pNewFrame)
                {
                    pNewFrame->Init(pvArgs, pmd, this);
                    //
                    // Let our sink know that the call actually happened
                    //
                    hr = m_pCallSink->OnCall( static_cast<ICallFrame*>(pNewFrame) );
                    if (!hr && phReturnValue)
                    {
                        *phReturnValue = pNewFrame->GetReturnValueFast();
                    }
                                        
                    pNewFrame->Release();
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            //
            // Figure out the size of the arguments that need popping
            //
            *pcbArgs = pmd->m_cbPushedByCaller;
        }
    }

    return hr;
}

HRESULT STDCALL Interceptor::GetStackSize(ULONG iMethod, ULONG* pcbArgs)
// Answer the size of a stack frame of the indicated method in this interface
{
    HRESULT hr = S_OK;

    if (iMethod < m_cMethodsBase)
    {
        if (m_pBaseInterceptor)
        {
            // This method is one that our base interface will handle. Tell him to do so
            //
            hr = m_pBaseInterceptor->GetStackSize(iMethod, pcbArgs);
        }
        else
            hr = E_UNEXPECTED;
    }
    else
    {
        hr = SanityCheck(m_pHeader, iMethod);

        if (!hr)
        {
            MD_METHOD* pmd = &m_pmdInterface->m_rgMethods[iMethod];
            *pcbArgs = pmd->m_cbPushedByCaller;
        }
    }

    return hr;
}



////////////////////////////////////////////////////////////////////////////////////////////
//
// ICallUnmarshal implementation
//
////////////////////////////////////////////////////////////////////////////////////////////

#if _MSC_VER >= 1200
#pragma warning (push)
#pragma warning (disable : 4509)
#endif

HRESULT Interceptor::Unmarshal(
    ULONG iMethod, 
    PVOID pBuffer, 
    ULONG cbBuffer, 
    BOOL fForceBufferCopy, 
    RPCOLEDATAREP dataRep, 
    CALLFRAME_MARSHALCONTEXT* pctx, 
    ULONG* pcbUnmarshalled, 
    ICallFrame** ppFrame)
// Unmarshal the in-values of a call and return the reconstructed ICallFrame*. This is modeled 
// very much on the server side unmarshalling routines NdrStubCall2 / __ComPs_NdrStubCall2.
{
    HRESULT hr = S_OK;
    
    if (iMethod < m_cMethodsBase)
    {
        if (m_punkBaseInterceptor)
        {
            ICallUnmarshal* pUnmarshal;
            hr = QI(m_punkBaseInterceptor, pUnmarshal);
            if (!hr)
            {
                hr = pUnmarshal->Unmarshal(iMethod, 
                                           pBuffer, 
                                           cbBuffer, 
                                           fForceBufferCopy, 
                                           dataRep, 
                                           pctx, 
                                           pcbUnmarshalled, 
                                           ppFrame);
                pUnmarshal->Release();
            }
        }
        else
            hr = E_UNEXPECTED;
        return hr;
    }
        
    *ppFrame = NULL;
        
    ASSERT(pctx && pctx->fIn); if (!(pctx && pctx->fIn)) return E_INVALIDARG;    
    //
    // Initialize out parameters
    //
    if (pcbUnmarshalled) 
    {
        *pcbUnmarshalled = 0;
    }
    *ppFrame = NULL;
    //
    // Get some of the memory we need
    //
    CallFrame* pFrame = new CallFrame;
    if (pFrame)
    {
        pFrame->m_fIsUnmarshal = TRUE;

        if (fForceBufferCopy)
        {
            PVOID pv = CoTaskMemAlloc(cbBuffer);
            if (pv)
            {
                memcpy(pv, pBuffer, cbBuffer);
                pBuffer = pv;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        if (!hr)
        {
            pFrame->m_blobBuffer.pBlobData = (PBYTE)pBuffer;
            pFrame->m_blobBuffer.cbSize    = cbBuffer;
            pFrame->m_fWeOwnBlobBuffer     = fForceBufferCopy;
        }
    }
    else
        hr = E_OUTOFMEMORY;
    //
    if (!hr)
    {
        // Initialize the new frame on the indicated method and ask it to internally allocate and zero a new stack
        //
        pFrame->Init(NULL, &m_pmdInterface->m_rgMethods[iMethod], this);
        hr = pFrame->AllocStack(0, FALSE);
    }

    if (!hr)
    {
        //
        // Find out and remember the stack address
        //
        BYTE* pArgBuffer = (BYTE*)pFrame->m_pvArgs;
        //
        // Cons up an RPC_MESSAGE to look like an incoming call
        //
        RPC_MESSAGE rpcMsg; Zero(&rpcMsg);
        rpcMsg.Buffer               = pBuffer;
        rpcMsg.BufferLength         = cbBuffer;
        rpcMsg.ProcNum              = iMethod;
        rpcMsg.DataRepresentation   = dataRep;
        //
        // Cons up a pseudo channel kinda object in order to have the act of unmarshalling interfaces
        // come on back to the passed-in-here IMarshallingManager.
        //
        MarshallingChannel channel;

        if (pctx->punkReserved)
        {
            IMarshallingManager *pMgr;
            hr = pctx->punkReserved->QueryInterface(IID_IMarshallingManager, (void **)&pMgr);
            if (SUCCEEDED(hr))
            {
                ::Set(channel.m_pMarshaller, pMgr);
                pMgr->Release();
            }
            hr = S_OK;
        }

        channel.m_dwDestContext = pctx->dwDestContext;
        channel.m_pvDestContext = pctx->pvDestContext;
        //
        // Initialize a stub message from that stuff
        //
        MIDL_STUB_MESSAGE stubMsg;
        NdrStubInitialize(&rpcMsg, &stubMsg, pFrame->GetStubDesc(), (IRpcChannelBuffer*)&channel);
        stubMsg.StackTop = pArgBuffer;
                
        //
        // Need to deal with things the extensions, if they exist.
        // Stolen from RPC.
        //
        if (pFrame->m_pmd->m_pHeaderExts)
        {
            stubMsg.fHasExtensions = 1;
            stubMsg.fHasNewCorrDesc = pFrame->m_pmd->m_pHeaderExts->Flags2.HasNewCorrDesc;
                        
            if (pFrame->m_pmd->m_pHeaderExts->Flags2.ServerCorrCheck)
            {
                void *pCorrInfo = alloca(NDR_DEFAULT_CORR_CACHE_SIZE);                                
                if (!pCorrInfo)
                    RpcRaiseException (RPC_S_OUT_OF_MEMORY);
                                
                NdrCorrelationInitialize( &stubMsg,
                                          (unsigned long *)pCorrInfo,
                                          NDR_DEFAULT_CORR_CACHE_SIZE,
                                          0 /* flags */ );
            }
        }
        else
        {
            stubMsg.fHasExtensions = 0;
            stubMsg.fHasNewCorrDesc = 0;
        }
                
        __try
        {
            // Unmarshal in [in] parameters
            //
            const MD_METHOD* pmd = pFrame->m_pmd;
            for (ULONG iparam = 0; iparam < pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                
                BYTE* pArg = pArgBuffer + param.StackOffset;
                
                if (paramAttr.IsIn)
                {
                    ASSERT(!paramAttr.IsPipe);
                    //
                    // Quick check for the common case
                    //
                    if (paramAttr.IsBasetype)
                    {
                        if (paramAttr.IsSimpleRef)
                        {
                            ALIGN(stubMsg.Buffer, SIMPLE_TYPE_ALIGNMENT(param.SimpleType.Type));
                            *(PBYTE*)pArg = stubMsg.Buffer;
                            stubMsg.Buffer += SIMPLE_TYPE_BUFSIZE(param.SimpleType.Type);
                        }
                        else
                        {
                            NdrUnmarshallBasetypeInline(&stubMsg, pArg, param.SimpleType.Type);
                        }
                        continue;
                    }
                    //
                    // Initialize [in] and [in,out] ref pointers to pointers
                    //
                    if (paramAttr.ServerAllocSize != 0)
                    {
                        *(PVOID*)pArg = pFrame->AllocBuffer(paramAttr.ServerAllocSize * 8);
                        ZeroMemory( *(PVOID*)pArg, paramAttr.ServerAllocSize * 8);
                    }
                    //
                    // Actually carry out the unmarshal the long way
                    //
                    BYTE** ppArg = paramAttr.IsByValue ? &pArg : (BYTE**)pArg;
                    PFORMAT_STRING pFormatParam = pFrame->GetStubDesc()->pFormatTypes + param.TypeOffset;
                    NdrTypeUnmarshall(&stubMsg, ppArg, pFormatParam, FALSE);
                }
            }
            //
            // Initialize the out-parameters. Must be done AFTER unmarshalling the in parameters because
            // some of the conformance routines we encounter might need to refer in-parameter data.
            //
            for (iparam = 0; iparam < pmd->m_numberOfParams; iparam++)
            {
                const PARAM_DESCRIPTION& param   = pmd->m_params[iparam];
                const PARAM_ATTRIBUTES paramAttr = param.ParamAttr;
                
                BYTE* pArg = pArgBuffer + param.StackOffset;
                
                if (!paramAttr.IsIn)
                {
                    ASSERT(paramAttr.IsOut); ASSERT(!paramAttr.IsReturn && !paramAttr.IsPipe);
                    
                    if (paramAttr.ServerAllocSize != 0)
                    {
                        *(PVOID*)pArg = pFrame->AllocBuffer(paramAttr.ServerAllocSize * 8);
                        if (*(PVOID*)pArg == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        ZeroMemory( *(PVOID*)pArg, paramAttr.ServerAllocSize * 8);
                    }
                    else if (paramAttr.IsBasetype)
                    {
                        *(PVOID*)pArg = pFrame->AllocBuffer(8);
                        if (*(PVOID*)pArg == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        ZeroMemory( *(PVOID*)pArg, 8);
                    }
                    else
                    {
                        PFORMAT_STRING pFormatParam = pFrame->GetStubDesc()->pFormatTypes + param.TypeOffset;
                        NdrOutInit(&stubMsg, pFormatParam, (BYTE**)pArg);
                    }
                }
            }
            //
            // Return the newly unmarshalled frame to our caller
            //
            ASSERT(pFrame->m_refs == 1);
            *ppFrame = pFrame;  // Transfer ownership of the reference
        }
        __except(DebuggerFriendlyExceptionFilter(GetExceptionCode()))
        {
            // Unlike NDR, we choose to clean up if we happen to fail because of unmarshalling bad stub
            // data.
            //
            hr = HrNt(GetExceptionCode());
            if (SUCCEEDED(hr))
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
            }
            
            pFrame->Free(NULL, NULL, NULL, CALLFRAME_FREE_IN, NULL, CALLFRAME_NULL_NONE);
            delete pFrame;

            pFrame = NULL;
            *ppFrame = NULL;
        }
        //
        // Record how many bytes we unmarshalled. Do this even in error return cases.
        // Knowing this is important in order to be able to clean things up with ReleaseMarshalData
        //
        if (pcbUnmarshalled) *pcbUnmarshalled = PtrToUlong(stubMsg.Buffer) - PtrToUlong(pBuffer);
    }

    if (FAILED(hr))
    {
        delete pFrame;
        pFrame = NULL;
        *ppFrame = NULL;
    }
        
    return hr;
}

#if _MSC_VER >= 1200
#pragma warning (pop)
#endif

// Call release marshal data on all of the marshalled interface pointers contained herein
HRESULT Interceptor::ReleaseMarshalData(
    ULONG iMethod, 
    PVOID pBuffer, 
    ULONG cbBuffer, 
    ULONG ibFirstRelease, 
    RPCOLEDATAREP dataRep, 
    CALLFRAME_MARSHALCONTEXT* pctx)
{ 
    HRESULT hr = S_OK;

    if (iMethod < m_cMethodsBase)
    {
        if (m_punkBaseInterceptor)
        {
            ICallUnmarshal* pUnmarshal;
            hr = QI(m_punkBaseInterceptor, pUnmarshal);
            if (!hr)
            {
                hr = pUnmarshal->ReleaseMarshalData(iMethod, pBuffer, cbBuffer, ibFirstRelease, dataRep, pctx);
                pUnmarshal->Release();
            }
        }
        else
            hr = E_UNEXPECTED;
        return hr;
    }

    CallFrame* pNewFrame = new CallFrame;
    if (pNewFrame)
    {
        pNewFrame->Init(NULL, &m_pmdInterface->m_rgMethods[iMethod], this);
        hr = pNewFrame->ReleaseMarshalData(pBuffer, cbBuffer, ibFirstRelease, dataRep, pctx);
        delete pNewFrame;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT Interceptor::GetMethodInfo(ULONG iMethod, CALLFRAMEINFO* pInfo, LPWSTR* pwszMethodName)
// Provide interesting per-method information
//
{
    if (iMethod < m_cMethodsBase)
    {
        if (m_pBaseInterceptor)
        {
            return m_pBaseInterceptor->GetMethodInfo(iMethod, pInfo, pwszMethodName);
        }
        else
            return E_UNEXPECTED;
    }
    else if ((iMethod < 3) || (iMethod >= m_pmdInterface->m_cMethods))
    {
        // These are either IUnknown methods, or invalid methods.
        return E_INVALIDARG;
    }
    else
    {
        *pInfo = m_pmdInterface->m_rgMethods[iMethod].m_info;
        if (pwszMethodName)
        {
            if (m_pmdInterface->m_rgMethods[iMethod].m_wszMethodName)
            {
                *pwszMethodName = CopyString(m_pmdInterface->m_rgMethods[iMethod].m_wszMethodName);
                if (NULL == *pwszMethodName)
                {
                    return E_OUTOFMEMORY;
                }
            }
            else
                *pwszMethodName = NULL;
        }
        return S_OK;
    }
}


////////////////////////////////////////////////////////////////////////////////////////////
//
// Definition of the method thunks for the Interceptor. 
//
////////////////////////////////////////////////////////////////////////////////////////////

#define GetInterceptor(This) CONTAINING_RECORD(This, Interceptor, m_pvtbl)

HRESULT STDMETHODCALLTYPE Interceptor_QueryInterface(IUnknown* This, REFIID riid, void** ppv)
{
    return GetInterceptor(This)->QueryInterface(riid, ppv);
};
ULONG STDMETHODCALLTYPE Interceptor_AddRef(IUnknown* This)
{
    return GetInterceptor(This)->AddRef();
};
ULONG STDMETHODCALLTYPE Interceptor_Release(IUnknown* This)
{
    return GetInterceptor(This)->Release();
};

#define methname(i) __Interceptor_meth##i

//
/////////////////////////////////////////////////////////////////////////
//
#if defined(_X86_)

#define meth(i)                                                         \
HRESULT __declspec(naked) methname(i)(void* const this_, ...)           \
    {                                                                   \
    __asm mov eax, i                                                    \
    __asm jmp InterceptorThunk                                          \
    }

void __declspec(naked) InterceptorThunk(ULONG iMethod, IUnknown* This, ...)
{
    // Manually establish a stack frame so that references to locals herein will work
    // 
    __asm 
    {
        pop      ecx            // pop return address
        push     eax            // push iMethod
        push     ecx            // push return address
        push     ebp            // link the stack frame
        mov      ebp, esp       //      ...
        sub      esp, 8         // reserve space for cbArgs and hr
    }
    // 
    // Stack is now (numbers are offsets from ebp)
    //
    //      12  This
    //      8   iMethod         
    //      4   return address  
    //      0   saved ebp
    //
    // Do the actual interception
    //
    DWORD   cbArgs;
    HRESULT hr;
    GetInterceptor(This)->CallIndirect(&hr, iMethod, /*pvArgs*/&This, &cbArgs);
    //
    // Now deal with the return values, and return to the caller....
    _asm 
    {
        mov     eax, hr         // get hr ready to return to our caller
        mov     ecx, cbArgs     // get cbArgs into ecx
        add     esp, 8          // de-alloc our stack variables
        pop     ebp             // unlink stack frame
        pop     edx             // get return address to edx
        add     ecx, 4          // account for our extra push of iMethod
        add     esp, ecx        // remove stack frame pushed by caller
        jmp     edx             // return to caller
    }
}

#endif // _X86_

//
/////////////////////////////////////////////////////////////////////////
//
#if defined(_AMD64_)

#define meth(i)                                                                 \
HRESULT methname(i)(void* const This, ...)                                      \
    {                                                                           \
    DWORD cbArgs;                                                               \
    HRESULT hr;                                                                 \
    GetInterceptor((IUnknown*)This)->CallIndirect(&hr, i, (void *)&This, &cbArgs); \
    return hr;                                                                  \
    }

#endif // _AMD64_

//
/////////////////////////////////////////////////////////////////////////
#if defined(_IA64_)
#define meth(i)                                                         \
extern "C" HRESULT methname(i)(void* const this_, ...);
#endif
//
/////////////////////////////////////////////////////////////////////////

#include "vtableimpl.h"

defineVtableMethods();

defineVtable(g_InterceptorVtable, Interceptor_QueryInterface, Interceptor_AddRef, Interceptor_Release);

////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\oautil.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// oautil.cpp
//
#include "stdpch.h"
#include "common.h"

#include "ndrclassic.h"
#include "txfrpcproxy.h"
#include "typeinfo.h"
#include "tiutil.h"

#include <debnot.h>

OAUTIL g_oaUtil(NULL, NULL, NULL, FALSE, FALSE);

/////////////////////////////////////////////////////////////////////////////////////
//
// Stubs for the non-qualified APIs

BSTR SysAllocString(LPCWSTR psz)
{
    return g_oaUtil.SysAllocString(psz);
}

BSTR SysAllocStringLen(LPCWSTR wsz, UINT cch)
{
    return g_oaUtil.SysAllocStringLen(wsz, cch);
}

BSTR SysAllocStringByteLen(LPCSTR sz, UINT cb)
{
    return g_oaUtil.SysAllocStringByteLen(sz, cb);
}

void SysFreeString(BSTR bstr)
{
    g_oaUtil.SysFreeString(bstr);
}

UINT SysStringByteLen(BSTR bstr)
{
    return g_oaUtil.SysStringByteLen(bstr);
}

INT SysReAllocStringLen(BSTR* pbstr, LPCWSTR wsz, UINT ui)
{
    return g_oaUtil.SysReAllocStringLen(pbstr, wsz, ui);
}

HRESULT SafeArrayCopy(SAFEARRAY * psa, SAFEARRAY ** ppsaOut)
{
    return g_oaUtil.SafeArrayCopy(psa, ppsaOut);
}

HRESULT VariantClear(VARIANTARG* pv)
{
    return g_oaUtil.VariantClear(pv);
}

HRESULT VariantCopy(VARIANTARG* pv1, VARIANTARG* pv2)
{
    return g_oaUtil.VariantCopy(pv1, pv2);
}

HRESULT LoadRegTypeLib(REFGUID libId, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib** pptlib)
{
    return (g_oa.get_pfnLoadRegTypeLib())(libId, wVerMajor, wVerMinor, lcid, pptlib);
}

HRESULT LoadTypeLibEx(LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib)
{
    return (g_oa.get_pfnLoadTypeLibEx())(szFile, regkind, pptlib);
}


/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////


BSTR OAUTIL::SysAllocString(LPCWSTR psz)
{
    return (g_oa.get_SysAllocString())(psz);
}


BSTR OAUTIL::SysAllocStringLen(LPCWSTR psz, UINT cch)
{
    return (g_oa.get_SysAllocStringLen())(psz, cch);
}

BSTR OAUTIL::SysAllocStringByteLen(LPCSTR psz, UINT cb)
{
    return (g_oa.get_SysAllocStringByteLen())(psz, cb);
}

void OAUTIL::SysFreeString(BSTR bstr)
{
    (g_oa.get_SysFreeString())(bstr);
}


INT OAUTIL::SysReAllocString(BSTR* pbstr, LPCWSTR psz)
{
    return (g_oa.get_SysReAllocString())(pbstr, psz);
}

INT OAUTIL::SysReAllocStringLen(BSTR* pbstr, LPCWSTR psz, UINT cch)
{
    return (g_oa.get_SysReAllocStringLen())(pbstr, psz, cch);
}

UINT OAUTIL::SysStringLen(BSTR bstr)
{
    return bstr ? BSTR_INTERNAL::From(bstr)->Cch() : 0; // Works user or kernel mode
}

UINT OAUTIL::SysStringByteLen(BSTR bstr)
{
    return bstr ? BSTR_INTERNAL::From(bstr)->Cb()  : 0; // Works user or kernel mode
}

/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////

#if _DEBUG
struct CFTaggedPunk
{
    PVOID pv;
    ULONG tag;
};

struct CFTaggedVariant
{
    VARIANT variant;
    ULONG tag;
};
#endif


//
// Walk a SAFEARRAY, calling our version of VariantClear on the contained
// variants, if necessary.  This makes sure we clean up any memory we might
// have allocated within.
//
HRESULT OAUTIL::SafeArrayClear(SAFEARRAY *psa, BOOL fWeOwnByRefs)
{
    if ((psa == NULL) || !(psa->fFeatures & FADF_VARIANT))
        return S_OK;

    Win4Assert(psa->cDims > 0);

    //
    // Existing array-- number of elements is not going to be larger
    // than a ulong or we wouldn't have been able to copy it. (Would
    // have got SAFEARRAYOVERFLOW in the copy.  Count the number of
    // elements by multiplying the number of elements in each dimension.
    //  
    ULONG i;
    ULONG cElementsTotal = psa->rgsabound[0].cElements; // First dim...
    for (i=1; i < psa->cDims; i++)
    {
        cElementsTotal *= psa->rgsabound[i].cElements;  // * next dim...
    }

    HRESULT hr = S_OK;
    BYTE *pbData = (BYTE *)psa->pvData;
    for (i=0; SUCCEEDED(hr) && (i < cElementsTotal); i++)
    {
        VARIANT *pv = (VARIANT *)pbData;
        
        hr = VariantClear(pv, fWeOwnByRefs);

        pbData += psa->cbElements;
    }

    return hr;
}


//
// Our version of VariantClear can't simply defer to oleaut, because:
//
// 1. It needs to interact correctly with the walker.
// 2. We might need to free the stuff we allocated in VariantCopy.
//
// Expanding on point number 2:  The problem is that if the byref
// bit is set on a variant, oleaut will just set the vt to VT_EMPTY
// and be done with it.  But when we have copied a byref variant, 
// we might have allocated all kinds of extra memory.  We actually
// want that memory to be free'd, so we need to do special things to 
// free it.
//
// VariantCopy allocates memory for the following things:
//    VT_VARIANT  | VT_BYREF
//    VT_UNKNOWN  | VT_BYREF
//    VT_DISPATCH | VT_BYREF
//
// We also need to walk into embedded safearrays because we copy them 
// with our version of VariantCopy.
//
HRESULT OAUTIL::VariantClear (VARIANT *pvarg, BOOL fWeOwnByRefs)
{
    HRESULT hr = S_OK;

    if (pvarg == NULL)
        return E_POINTER;

    //
    // Special handling for records, since we copy them
    // differently.
    //
    if (fWeOwnByRefs && ((pvarg->vt & ~VT_BYREF) == VT_RECORD))
    {
        if (V_RECORDINFO(pvarg) != NULL)
        {
            if (V_RECORD(pvarg) != NULL)
            {
                hr = FreeRecord(V_RECORD(pvarg),
                                V_RECORDINFO(pvarg),
                                fWeOwnByRefs);
            }
            
            if (SUCCEEDED(hr))
            {
                if (!(pvarg->vt & VT_BYREF))
                    V_RECORDINFO(pvarg)->Release();
                
                pvarg->vt = VT_EMPTY;
            }
        }
        return hr;
    }

    if (m_pWalkerFree)
    {
        InterfaceWalkerFree walkerFree(m_pWalkerFree);
        ICallFrameWalker* pWalkerPrev = m_pWalkerWalk;
        m_pWalkerWalk = &walkerFree;
        hr = Walk(pvarg);
        m_pWalkerWalk = pWalkerPrev;
    }

    if (FAILED(hr))
        return hr;

    VARTYPE vt = pvarg->vt;

    if (fWeOwnByRefs && (vt & VT_BYREF))
    {
        vt &= ~VT_BYREF;

        // Free all the extra stuff that we allocate specially.
        // Everything else here is copied.
        if (vt & VT_ARRAY)
        {
            SAFEARRAY **ppSA = V_ARRAYREF(pvarg);
            if (ppSA)
            {
                // First of all, we need to "clear" it, because
                // it might be a SA of variants, which means we
                // did some funny allocations.
                //
                hr = SafeArrayClear(*ppSA, TRUE);
                //
                // Now we need to free up all of the memory
                // taken by the safearray.  This will clear
                // more conventional resources.
                //
                if (SUCCEEDED(hr) && (*ppSA))
                    hr = (g_oa.get_SafeArrayDestroy())(*ppSA);
                //
                // Now we free the extra 4 or 8 bytes allocated
                // for the pointer, and NULL everything out.
                //
                if (SUCCEEDED(hr))
                {
                    // Free the pointer we allocated.
                    CoTaskMemFree(ppSA);
                    V_ARRAYREF(pvarg) = NULL;
                }                
            }
        }
        else
        {
            switch (vt)
            {
            case VT_VARIANT:
                // We are saved pain by the fact that VT_VARIANT must be VT_BYREF.
                // That's just the way it is.  Recurse.
                if (pvarg->pvarVal)
                {
                    hr = VariantClear(pvarg->pvarVal, TRUE);
                    CoTaskMemFree(pvarg->pvarVal);
                }
                break;
                
            case VT_UNKNOWN:
            case VT_DISPATCH:
                // Should be already walked, so don't need to release.
                if (pvarg->ppunkVal)
                    CoTaskMemFree(pvarg->ppunkVal);
                
            default:
                // Don't need to do anything special here.
                // Nothing allocated, nothing to free.
                break;
            }
        }
    }
    else
    {
        //
        // Not byref, or byref but not ours.
        //
        // What are all the reasons we could get here?
        //  1. Copying in or in,out parameter over, clearing the destination.
        //     In this case the destination is empty, and this does the right thing.
        //
        //  2. Copy out or in,out parameter over, clearing the source.
        //     In this case, we don't own byrefs.  If the variant is ByRef, then it
        //     is VariantCopy's job to deal with freeing memory.  If the variant is
        //     NOT ByRef, then oleaut will clear everything it's supposed to.
        //
        //  We don't get here when clearing out the used destination, after the call.
        //  In that case, we'll own the byrefs.
        //
        //  Why do I say all this?  To prove that we don't have to call 
        //  SafeArrayClear in this code path.
        //
        hr = (g_oa.get_VariantClear())(pvarg);
    }

    pvarg->vt = VT_EMPTY;

    return hr;
}


//
// Copy the variant. We don't defer to OLEAUT32 in order to interact
// correctly with m_pWalker
//
// At one time this code was horribly broken.  I'm working on trying to make it cleaner
// every time I go through it.  The implicit assumption is that we're just copying data
// and we try to share memory whenever possible.
//
HRESULT OAUTIL::VariantCopy(VARIANTARG* pvargDest, VARIANTARG * pvargSrc, BOOL fNewFrame)
{
    HRESULT hr = S_OK;
    BSTR bstr;

    if (pvargDest == pvargSrc)
    {
        // Copying to yourself is a no-op
    }
    else
    {
        const VARTYPE vt = V_VT(pvargSrc);
        
        //
        // free up strings or objects pvargDest is currently referencing.
        //
        void *pvTemp = pvargDest->ppunkVal;

        hr = VariantClear(pvargDest);

        pvargDest->ppunkVal = (IUnknown**)pvTemp;
        
        if (!hr)
        {
            if ((vt & (VT_ARRAY | VT_BYREF)) == VT_ARRAY)
            {
                hr = SafeArrayCopy(V_ARRAY(pvargSrc), &V_ARRAY(pvargDest));
                V_VT(pvargDest) = vt;
            }
            else if (vt == VT_BSTR) 
            {
                bstr = V_BSTR(pvargSrc);

                if(bstr)
                {
                    // Make the string copy first, so if it fails, the destination
                    // variant still is VT_EMPTY.
                    V_BSTR(pvargDest) = Copy(bstr);
                    if (V_BSTR(pvargDest))
                        V_VT(pvargDest) = VT_BSTR;
                    else
                        hr = E_OUTOFMEMORY;
                }
                else
                {
                    V_VT(pvargDest) = VT_BSTR;
                    V_BSTR(pvargDest) = NULL;
                }
            } 
            else if ((vt & ~VT_BYREF) == VT_RECORD) 
            {
                if (V_RECORDINFO(pvargSrc))
                {
                    if (V_RECORD(pvargSrc))
                    {
                        hr = CopyRecord(V_RECORDINFO(pvargSrc),
                                        V_RECORD(pvargSrc),
                                        &(V_RECORD(pvargDest)),
                                        fNewFrame);
                    }
                    else
                    {
                        V_RECORD(pvargDest) = NULL;
                    }

                    V_RECORDINFO(pvargDest) = V_RECORDINFO(pvargSrc);
                    if (!(vt & VT_BYREF))
                        V_RECORDINFO(pvargDest)->AddRef();
                }
                else
                {
                    V_RECORDINFO(pvargDest) = NULL;
                    V_RECORD(pvargDest) = NULL;
                }

                V_VT(pvargDest) = vt;
            }
            else
            {                
                if (vt & VT_BYREF)
                {
#if _DEBUG
                    CFTaggedPunk *pCFTaggedPunk = NULL;
                    CFTaggedVariant* pCFTaggedVariant = NULL;
#endif                    
                    if (vt & VT_ARRAY)
                    {
                        // Byref array of something.
                        // 
                        hr = S_OK;
                        if (fNewFrame)
                        {
                            // Need to allocate a pointer size thing because we can't re-use any memory.
                            *pvargDest = *pvargSrc;
                            V_ARRAYREF(pvargDest) = (SAFEARRAY **)CoTaskMemAlloc(sizeof(SAFEARRAY *));
                            if (V_ARRAYREF(pvargDest))
                                *V_ARRAYREF(pvargDest) = NULL;
                            else
                                hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            // Re-use the array pointer.
                            // Take care to save the ppSA, because we'll refer to it later.
                            SAFEARRAY **ppSA = V_ARRAYREF(pvargDest);
                            *pvargDest = *pvargSrc;
                            V_ARRAYREF(pvargDest) = ppSA;
                        }

                        if (SUCCEEDED(hr))
                        {
                            SAFEARRAY **ppaSrc = V_ARRAYREF(pvargSrc);
                            SAFEARRAY *paSrc   = *ppaSrc;
                            SAFEARRAY **ppaDst = V_ARRAYREF(pvargDest);
                            SAFEARRAY *paDst   = *ppaDst;
                            
                            // These rules were taken out of the marshalling code from oleaut.
                            // There is one optimization, though-- marshalling only allocs if
                            // necessary.  We're allocating always, to make life simple.
                            //
                            // Note: that we took great care (above) to make sure paDst stays 
                            //       the same if we're not going to a new frame.
                            BOOL fDestResizeable = fNewFrame || 
                              (paDst == NULL) || 
                              (!(paDst->fFeatures & (FADF_AUTO|FADF_STATIC|FADF_EMBEDDED|FADF_FIXEDSIZE)));

                            if (fDestResizeable)
                            {
                                if (paDst)
                                    hr = SafeArrayDestroy(paDst);

                                if (SUCCEEDED(hr))
                                {
                                    if (paSrc)
                                        hr = SafeArrayCopy(paSrc, ppaDst);
                                    else
                                        *ppaDst = NULL;
                                }
                            }
                            else
                            {
                                hr = SafeArrayCopyData(paSrc, paDst);
                                
                                // Not resizeable.... 
                                if (hr == E_INVALIDARG)
                                    hr = DISP_E_BADCALLEE;
                            }
                        }
                    }
                    else // vt & VT_ARRAY
                    {
                        switch (vt & ~VT_BYREF)
                        {
                        case VT_VARIANT:
                            // BYREF VARIANTs must be checked to see if the VARIANT pointed to by
                            // pvarVal is a DISPATCH or UNKNOWN interface.  If it is, a copy of
                            // the VARIANT at this level must be made so the original interface
                            // pointer and the copy do note share the same address.  If they share
                            // the same address, the original will be overwritten if a walker
                            // marshals the interface pointer in place.
                            
                            // In any case, we need to see about space for the VARIANT we point to.
                            if (fNewFrame)
                            {
                                *pvargDest = *pvargSrc;
#if _DEBUG                            
                                pCFTaggedVariant = (CFTaggedVariant*) CoTaskMemAlloc(sizeof(CFTaggedVariant));
                                pCFTaggedVariant->tag = 0xF000BAAA;
                                
                                pvargDest->pvarVal = (VARIANT*) &pCFTaggedVariant->variant;
#else
                                pvargDest->pvarVal = (VARIANT*) CoTaskMemAlloc(sizeof(VARIANT));
#endif                            
                                // "VariantInit".
                                pvargDest->pvarVal->vt = VT_EMPTY;
                            }
                            else
                            {
                                // If we are copying back to an existing callframe,
                                // we want to copy use the existing memory.
                                VARIANT *pvar = pvargDest->pvarVal;
                                *pvargDest = *pvargSrc;
                                pvargDest->pvarVal = pvar;
                            }
                            
                            if (pvargDest->pvarVal)
                            {
                                // Simple recursion... copy the underlying variant
                                OAUTIL::VariantCopy(pvargDest->pvarVal, pvargSrc->pvarVal, fNewFrame); 
                            }
                            else
                                hr = E_OUTOFMEMORY;                            

                            break;
                        
                        case VT_UNKNOWN:
                        case VT_DISPATCH:
                            // If we are copying to a new callframe, we must 
                            // allocate wrappers for BYVAL interface pointers
                            // because they cannot be shared between callframes.
                            if (fNewFrame)
                            {
                                *pvargDest = *pvargSrc;
#if _DEBUG                            
                                pCFTaggedPunk = (CFTaggedPunk*) CoTaskMemAlloc(sizeof(CFTaggedPunk));
                                pCFTaggedPunk->tag = 0xF000BAAA;
                                
                                pvargDest->ppunkVal = (LPUNKNOWN*) &pCFTaggedPunk->pv;
#else
                                pvargDest->ppunkVal = (LPUNKNOWN*) CoTaskMemAlloc(sizeof(LPUNKNOWN));
#endif                            
                            }
                            else
                            {
                                // If we are copying back to an existing callframe,
                                // we want to copy use the existing memory.
                                LPUNKNOWN *ppunk = pvargDest->ppunkVal;
                                *pvargDest = *pvargSrc;
                                pvargDest->ppunkVal = ppunk;
                            }
                                                    
                            if (pvargDest->ppunkVal)
                            {
                                // Copy the interface pointer from the source
                                // into our wrapper.
                                *pvargDest->ppunkVal = *pvargSrc->ppunkVal;
                                
                                // AddRef the interface appropriately.  If the
                                // caller supplied a walker, this will cause
                                // the walker to get called.
                                if (*V_UNKNOWNREF(pvargDest) && WalkInterfaces())
                                    AddRefInterface(*V_UNKNOWNREF(pvargDest));
                            }
                            else
                            {
                                if (fNewFrame)
                                    hr = E_OUTOFMEMORY;
                            }
                            break;

                        default:
                            // Byref something else.
                            *pvargDest = *pvargSrc;
                            
                            break;
                        };
                    } // if not vt & VT_ARRAY
                }
                else // if (vt & VT_BYREF)
                {                    
                    // We begin by just copying the source into the destination
                    // by value.  We will fixup any pieces appropriately below.
                    *pvargDest = *pvargSrc;
                
                    switch(vt)
                    {
                    case VT_UNKNOWN:
                        if (WalkInterfaces())
                            AddRefInterface(V_UNKNOWN(pvargDest));
                        else
                            pvargDest->punkVal->AddRef();
                        break;

                    case VT_DISPATCH:
                        if (WalkInterfaces())
                            AddRefInterface(V_DISPATCH(pvargDest));
                        else
                            pvargDest->pdispVal->AddRef();
                        break;
                    default:
                        break;
                    }      
                }
            }
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////


//
// From oa/src/dispatch/sarray.cpp
//

#define SAFEARRAYOVERFLOW   0xffffffff

#if 0
#define PVTELEM(psa)        ((LONG *)(psa) - 1)
#define PIIDELEM(psa)       ((BYTE *)(psa) - sizeof(GUID))
#define PPIRIELEM(psa)      ((IRecordInfo **)(psa) - 1)
#else
#define PVTELEM(psa)                (&SAFEARRAY_INTERNAL::From(psa)->vt)
#define PIIDELEM(psa)       ((BYTE*)(&SAFEARRAY_INTERNAL::From(psa)->iid))
#define PPIRIELEM(psa)              (&SAFEARRAY_INTERNAL::From(psa)->piri)
#endif


HRESULT OAUTIL::SafeArrayCopy(SAFEARRAY * psa, SAFEARRAY ** ppsaOut)
{
    HRESULT hr        = S_OK;
    SAFEARRAY* psaNew = NULL;

    if (NULL == ppsaOut)
        hr = E_INVALIDARG;
    else
    {
        *ppsaOut = NULL;

        if (psa)
        {
            SAFEARRAY_INTERNAL* psaInt = SAFEARRAY_INTERNAL::From(psa);
            //
            // Allocate the descriptor first
            //
            if (psa->fFeatures & (FADF_RECORD | FADF_HAVEIID | FADF_HAVEVARTYPE)) 
            {
                if (psa->fFeatures & FADF_RECORD) 
                {
                    hr = SafeArrayAllocDescriptorEx(VT_RECORD, psa->cDims, &psaNew);
                    if (!hr)
                    {
                        SAFEARRAY_INTERNAL::From(psaNew)->piri = psaInt->piri;

                        // We do not walk the IRecordInfo-- it must be context agnostic.
                        //AddRefInterface(SAFEARRAY_INTERNAL::From(psaNew)->piri);
                        if (psaInt->piri)
                            psaInt->piri->AddRef();
                    }
                } 
                else if (psa->fFeatures & FADF_HAVEIID) 
                {
                    hr = SafeArrayAllocDescriptorEx(VT_UNKNOWN, psa->cDims, &psaNew);
                    if (!hr)
                    {
                        SAFEARRAY_INTERNAL::From(psaNew)->iid = psaInt->iid;
                    }
                } 
                else if (psa->fFeatures & FADF_HAVEVARTYPE)
                {
                    hr = SafeArrayAllocDescriptorEx((VARTYPE)*PVTELEM(psa), psa->cDims, &psaNew);
                }
            } 
            else
            {
                hr = SafeArrayAllocDescriptor(psa->cDims, &psaNew);
            }

            if (!hr)
            {
                psaNew->cLocks     = 0;
                psaNew->cDims      = psa->cDims;
                psaNew->fFeatures  = psa->fFeatures & ~(FADF_AUTO | FADF_STATIC | FADF_EMBEDDED | FADF_FORCEFREE | FADF_FIXEDSIZE);
                psaNew->cbElements = psa->cbElements;

                memcpy(psaNew->rgsabound, psa->rgsabound, sizeof(SAFEARRAYBOUND) * psa->cDims);

                hr = SafeArrayAllocData(psaNew);
                if (!hr)
                {
                    hr = SafeArrayCopyData(psa, psaNew);
                    if (!hr)
                    {
                        *ppsaOut = psaNew;
                        psaNew = NULL;
                    }
                }
            }
        }
    }

    if (psaNew)
    {
        // Error case
        //
        SafeArrayDestroy(psaNew);
    }
   
    return hr;
}

ULONG SafeArraySize(USHORT cDims, ULONG cbElements, SAFEARRAYBOUND* psabound)
{
    ULONG cb = 0;
    if (cDims)
    {
        cb = cbElements;
        for (USHORT us = 0; us < cDims; ++us)
        {
            // Do a 32x32 multiply, with overflow checking
            //
            LONGLONG dw1 = cb;
            LONGLONG dw2 = psabound->cElements;

            LARGE_INTEGER product;
            product.QuadPart = dw1 * dw2;
            if (product.HighPart == 0)
            {
                cb = product.LowPart;
            }
            else
            {
                return SAFEARRAYOVERFLOW;
            }
            ++psabound;
        }
    }
    return cb;
}

ULONG SafeArraySize(SAFEARRAY * psa)
{
    return SafeArraySize(psa->cDims, psa->cbElements, psa->rgsabound);
}

HRESULT OAUTIL::SafeArrayDestroyData(SAFEARRAY * psa)
{
    HRESULT hr = S_OK;

    if (m_pWalkerFree)
    {
        // Release & NULL the interface pointers first by doing a walk.
        //
        InterfaceWalkerFree walkerFree(m_pWalkerFree);
        ICallFrameWalker* pWalkerPrev = m_pWalkerWalk;
        m_pWalkerWalk = &walkerFree;
        hr = Walk(psa);
        m_pWalkerWalk = pWalkerPrev;
    }
    
    if (!hr)
    {
        // Then call OleAut32 to do the real work
        //
        hr = (g_oa.get_SafeArrayDestroyData())(psa);
    }
    
    return hr;
}

HRESULT OAUTIL::SafeArrayDestroy(SAFEARRAY * psa)
{
    HRESULT hr = S_OK;

    if (m_pWalkerFree)
    {
        // Release & NULL the interface pointers first
        //
        InterfaceWalkerFree walkerFree(m_pWalkerFree);
        ICallFrameWalker* pWalkerPrev = m_pWalkerWalk;
        m_pWalkerWalk = &walkerFree;
        hr = Walk(psa);
        m_pWalkerWalk = pWalkerPrev;
    }
    
    if (!hr)
    {
        // Then call OleAut32 to do the real work
        //
        hr = (g_oa.get_SafeArrayDestroy())(psa);
    }

    return hr;
}

HRESULT SafeArrayAllocDescriptor(UINT cDims, SAFEARRAY** ppsaOut)
  // Alloc a new array descriptor for the indicated number of dimensions,
  // We may or may not have the extra 16 bytes at the start, depending on
  // what version of OLEAUT32 we're talking to.
{
    HRESULT hr = S_OK;

    hr = (g_oa.get_SafeArrayAllocDescriptor())(cDims, ppsaOut);

    return hr;
}

HRESULT SafeArrayAllocDescriptorEx(VARTYPE vt, UINT cDims, SAFEARRAY** ppsaOut)
{       
    HRESULT hr = S_OK;

    hr = (g_oa.get_SafeArrayAllocDescriptorEx())(vt, cDims, ppsaOut);
   
    return hr;
}

HRESULT SafeArrayAllocData(SAFEARRAY* psa)
{
    HRESULT hr = S_OK;

    hr = (g_oa.get_SafeArrayAllocData())(psa);

    return hr;
}

HRESULT SafeArrayDestroyDescriptor(SAFEARRAY* psa)
{
    HRESULT hr = S_OK;

    hr = (g_oa.get_SafeArrayDestroyDescriptor())(psa);

    return hr;
}

HRESULT OAUTIL::SafeArrayCopyData(SAFEARRAY* psaSource, SAFEARRAY* psaTarget)
  // Copy over the the body of a safe array. We do NOT defer to OLEAUT32 because
  // we want to ensure that we interact with m_pWalker appropriately.
  //
{
    HRESULT hr = S_OK;

    if (NULL == psaSource || NULL == psaTarget || psaSource->cbElements == 0 || psaSource->cDims != psaTarget->cDims)
        hr = E_INVALIDARG;

    for (UINT i = 0; !hr && i < psaSource->cDims; i++)
    {
        if (psaSource->rgsabound[i].cElements != psaTarget->rgsabound[i].cElements)
            hr = E_INVALIDARG;
    }

    if (!hr) 
    {
        hr = SafeArrayLock(psaSource);
        if (!hr)
        {
            hr = SafeArrayLock(psaTarget);
            if (!hr)
            {
                ULONG cbSize    = SafeArraySize(psaSource);
                ULONG cElements = cbSize / psaSource->cbElements;

                if (psaSource->fFeatures & FADF_BSTR)
                {
                    BSTR* pbstrDst, *pbstrSrc;
                    pbstrSrc = (BSTR*)psaSource->pvData;
                    pbstrDst = (BSTR*)psaTarget->pvData;

                    for(i = 0; !hr && i < cElements; ++i)
                    {
                        if (NULL != *pbstrDst)
                        {
                            SysFreeString(*pbstrDst);
                            *pbstrDst = NULL;
                        }
                        if(*pbstrSrc)
                        {
                            *pbstrDst = Copy(*pbstrSrc);
                            if (NULL == *pbstrDst)
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        else
                        {
                            *pbstrDst = NULL;    
                        }
                        ++pbstrDst, ++pbstrSrc; 
                    }
                }
                else if (psaSource->fFeatures & FADF_UNKNOWN)
                {
                    IUnknown** ppunkDst, ** ppunkSrc;
                    ppunkSrc = (IUnknown**)psaSource->pvData;
                    ppunkDst = (IUnknown**)psaTarget->pvData;

                    for(i = 0; !hr && i < cElements; ++i)
                    {
                        IUnknown* punkDst = *ppunkDst;
                        //
                        *ppunkDst = *ppunkSrc;
                        AddRefInterface(*ppunkDst);
                        //
                        if (m_pWalkerFree)
                            ReleaseInterface(punkDst);
                        //
                        ++ppunkDst, ++ppunkSrc;
                    }
                }
                else if (psaSource->fFeatures & FADF_DISPATCH)
                {
                    IDispatch** ppdispDst, ** ppdispSrc;
                    ppdispSrc = (IDispatch**)psaSource->pvData;
                    ppdispDst = (IDispatch**)psaTarget->pvData;

                    for(i = 0; !hr && i < cElements; ++i)
                    {
                        IDispatch* pdispDst = *ppdispDst;
                        //
                        *ppdispDst = *ppdispSrc;
                        AddRefInterface(*ppdispDst);
                        //
                        if (m_pWalkerFree)
                            ReleaseInterface(pdispDst);
                        //
                        ++ppdispDst, ++ppdispSrc;
                    }
                }
                else if(psaSource->fFeatures & FADF_VARIANT)
                {
                    VARIANT * pvarDst, * pvarSrc;
                    pvarSrc = (VARIANT *)psaSource->pvData;
                    pvarDst = (VARIANT *)psaTarget->pvData;

                    for(i = 0; !hr && i < cElements; ++i)
                    {
                        hr = VariantCopy(pvarDst, pvarSrc, TRUE);
                        ++pvarDst, ++pvarSrc;
                    }

                }
                else if (psaSource->fFeatures & FADF_RECORD)
                {
                    PBYTE pbSrc, pbDst;
                    pbSrc = (PBYTE)psaSource->pvData;
                    pbDst = (PBYTE)psaTarget->pvData;

                    IRecordInfo *priSource = *PPIRIELEM(psaSource);

                    if (priSource != NULL) 
                    {
                        for (i = 0; !hr && i < cElements; ++i)
                        {
                            hr = (*PPIRIELEM(psaSource))->RecordCopy(pbSrc, pbDst);

                            pbSrc += psaSource->cbElements;
                            pbDst += psaSource->cbElements;
                        }
                    }
                }
                else
                {
                    if (0 < cbSize)
                    {
                        memcpy(psaTarget->pvData, psaSource->pvData, cbSize);
                    }
                }
                SafeArrayUnlock(psaTarget);
            }
            SafeArrayUnlock(psaSource);
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
//
// Walking
//

HRESULT OAUTIL::Walk(SAFEARRAY* psa, IRecordInfo* pinfo, ULONG iDim, PVOID pvData, PVOID* ppvDataOut)
  // Walk the safe array for interface pointers. Walk the indicated dimension,
  // recursing to higher numbered dimensions
{
    HRESULT hr = S_OK;

    // This is technically a mal-formed SAFEARRAY, but I'm not going to complain about it.
    // There's certainly nothing to walk here.
    if (psa->cDims == 0)
        return S_OK;

    //
    // FYI: The bounds are stored in the array descriptor in reverse-textual order
    //
    const SAFEARRAYBOUND bound = psa->rgsabound[psa->cDims-1 - iDim];

    if (iDim + 1 == psa->cDims)
    {
        // We're at the innermost dimension. 
        //
        for (ULONG iElement = 0; !hr && iElement < bound.cElements; iElement++)
        {
            // Process the one element
            //
            if (psa->fFeatures & FADF_UNKNOWN)
            {
                IUnknown** punk = (IUnknown**)pvData;
                hr = WalkInterface(punk);
            }
            else if (psa->fFeatures & FADF_DISPATCH)
            {
                IDispatch** pdisp = (IDispatch**)pvData;
                hr = WalkInterface(pdisp);
            }
            else if (psa->fFeatures & FADF_VARIANT)
            {
                VARIANT* pv = (VARIANT*)pvData;
                hr = Walk(pv);
            }
            else if (psa->fFeatures & FADF_RECORD)
            {
                hr = WalkRecord(pvData, pinfo);
            }
            //
            // Point to the next element
            //
            pvData = (BYTE*)pvData + psa->cbElements;
        }
    }
    else
    {
        // We're not at the innermost dimension. Walk that dimension
        //
        for (ULONG iElement = 0; !hr && iElement < bound.cElements; iElement++)
        {
            // Recurse for the next dimension
            //
            hr = Walk(psa, pinfo, iDim+1, pvData, &pvData);
        }
    }

    if (ppvDataOut)
    {
        *ppvDataOut = pvData;
    }

    return hr;
}

HRESULT OAUTIL::Walk(SAFEARRAY* psa)
{
    if (psa)
    {
        return Walk(psa, psa->pvData);
    }
    else
        return S_OK;
}

HRESULT OAUTIL::Walk(SAFEARRAY* psa, PVOID pvData)
  // Walk the safe array for interface pointers. Walk the indicated dimension,
  // recursing to higher numbered dimensions
{
    HRESULT hr = S_OK;

    if (psa)
    {
        if (psa->fFeatures & (FADF_UNKNOWN | FADF_DISPATCH | FADF_VARIANT))
        {
            if (pvData)
            {
                hr = Walk(psa, NULL, 0, pvData, NULL);
            }
        }
        else if (psa->fFeatures & FADF_RECORD)
        {
            // Hold the record info ourselves so no one stomps on it
            //
            IRecordInfo* pinfo = SAFEARRAY_INTERNAL::From(psa)->piri;
            pinfo->AddRef();

            //    
            // Walk the data.
            //
            if (!hr)
            {
                if (pvData)
                {
                    hr = Walk(psa, pinfo, 0, pvData, NULL);
                }
            }

            ::Release(pinfo);
        }
    }

    return hr;
}

HRESULT OAUTIL::Walk(VARIANTARG* pvar)
  // Walk the variant for interface pointers
{
    HRESULT hr = S_OK;

    if (pvar)
    {
        VARTYPE vt = pvar->vt;
        BOOL fByRef = (vt & VT_BYREF);

        switch (vt & (~VT_BYREF))
        {
        case VT_DISPATCH:
            if (fByRef) { hr = WalkInterface(pvar->ppdispVal); }
            else        { hr = WalkInterface(&pvar->pdispVal); }
            break;
        
        case VT_UNKNOWN:
            if (fByRef) { hr = WalkInterface(pvar->ppunkVal); }
            else        { hr = WalkInterface(&pvar->punkVal); }
            break;

        case VT_VARIANT:
            if (fByRef) { hr = Walk(pvar->pvarVal);  }
            else        { /* caller error: ignore */ }
            break;

        case VT_RECORD:
            hr = WalkRecord(pvar->pvRecord, pvar->pRecInfo);
            break;

        default:        
        { 
            if (vt & VT_ARRAY)
            {
                if (fByRef) { hr = Walk(*pvar->pparray);   }
                else        { hr = Walk(pvar->parray); }
            }
            else
            {
                /* nothing to walk */
            }
        }
            break;

            /* end switch */
        }
    }

    return hr;
}

HRESULT OAUTIL::Walk(DWORD walkWhat, DISPPARAMS* pdispParams)
  // Walk the list of DISPARAMS for interface pointers
{
    HRESULT hr = S_OK;

    if (pdispParams)
    {
        const UINT cArgs = pdispParams->cArgs;

        BOOL fOldIn  = m_fWorkingOnInParam;
        BOOL fOldOut = m_fWorkingOnOutParam;

        for (UINT iarg = 0; !hr && iarg < cArgs; iarg++)
        {
            // Parameters are in reverse order inside the DISPARAMS. We iterate 
            // in forward order as a matter of style and for consistency with 
            // the CallFrame implementation.
            //
            VARIANTARG* pvar = &pdispParams->rgvarg[cArgs-1 - iarg];
            //
            // References are logically in-out, others are just in.
            //
            m_fWorkingOnInParam = TRUE;
            if (pvar->vt & VT_BYREF)
            {
                m_fWorkingOnOutParam = TRUE;
                if (walkWhat & CALLFRAME_WALK_INOUT)
                {
                    hr = Walk(pvar);
                }
            }
            else
            {
                m_fWorkingOnOutParam = FALSE;
                if (walkWhat & CALLFRAME_WALK_IN)
                {
                    hr = Walk(pvar);
                }
            }

            m_fWorkingOnInParam  = fOldIn;
            m_fWorkingOnOutParam = fOldOut;
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


HRESULT OLEAUTOMATION_FUNCTIONS::GetProc(HRESULT hr, LPCSTR szProcName, PVOID* ppfn)
{
    if (!hr)
    {
        PVOID pfnTemp = GetProcAddress(hOleAut32, szProcName);
        if (pfnTemp)
        {
            InterlockedExchangePointer(ppfn, pfnTemp);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

HRESULT OLEAUTOMATION_FUNCTIONS::LoadOleAut32()
  // Load OLEAUT32 if it hasn't already been loaded
{
    HRESULT hr = S_OK;

    if (0 == hOleAut32)
    {
        HINSTANCE hinst = LoadLibraryA("OLEAUT32");
        if (hinst)
        {
            if (NULL == InterlockedCompareExchangePointer((PVOID*)&hOleAut32, hinst, NULL))
            {
                // We were the first one in, so our LoadLibrary counts!
            }
            else
            {
                // Someone else got in there. Free our LoadLibrary ref
                //
                FreeLibrary(hinst);
            }
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

void OLEAUTOMATION_FUNCTIONS::Load()
{
    HRESULT hr = S_OK;

    if (!fProcAddressesLoaded)
    {
        hr = LoadOleAut32();
        if (!hr)
        {
            hr = GetProc(hr, "BSTR_UserSize",               (PVOID*)& UserMarshalRoutines[UserMarshal_Index_BSTR].pfnBufferSize);
            hr = GetProc(hr, "BSTR_UserMarshal",            (PVOID*)& UserMarshalRoutines[UserMarshal_Index_BSTR].pfnMarshall);
            hr = GetProc(hr, "BSTR_UserUnmarshal",          (PVOID*)& UserMarshalRoutines[UserMarshal_Index_BSTR].pfnUnmarshall);
            hr = GetProc(hr, "BSTR_UserFree",               (PVOID*)& UserMarshalRoutines[UserMarshal_Index_BSTR].pfnFree);
            hr = GetProc(hr, "VARIANT_UserSize",            (PVOID*)& UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnBufferSize);
            hr = GetProc(hr, "VARIANT_UserMarshal",         (PVOID*)& UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnMarshall);
            hr = GetProc(hr, "VARIANT_UserUnmarshal",       (PVOID*)& UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnUnmarshall);
            hr = GetProc(hr, "VARIANT_UserFree",            (PVOID*)& UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnFree);
            hr = GetProc(hr, "LPSAFEARRAY_UserSize",        (PVOID*)& pfnLPSAFEARRAY_UserSize);
            hr = GetProc(hr, "LPSAFEARRAY_UserMarshal",     (PVOID*)& pfnLPSAFEARRAY_UserMarshal);
            hr = GetProc(hr, "LPSAFEARRAY_UserUnmarshal",   (PVOID*)& pfnLPSAFEARRAY_UserUnmarshal);
            hr = GetProc(hr, "LPSAFEARRAY_UserFree",        (PVOID*)& UserMarshalRoutines[UserMarshal_Index_SafeArray].pfnFree);

            hr = GetProc(hr, "LPSAFEARRAY_Size",            (PVOID*)& pfnLPSAFEARRAY_Size);
            hr = GetProc(hr, "LPSAFEARRAY_Marshal",         (PVOID*)& pfnLPSAFEARRAY_Marshal);
            hr = GetProc(hr, "LPSAFEARRAY_Unmarshal",       (PVOID*)& pfnLPSAFEARRAY_Unmarshal);
            
            hr = GetProc(hr, "LoadTypeLib",                 (PVOID*)& pfnLoadTypeLib);
            hr = GetProc(hr, "LoadTypeLibEx",               (PVOID*)& pfnLoadTypeLibEx);
            hr = GetProc(hr, "LoadRegTypeLib",              (PVOID*)& pfnLoadRegTypeLib);
            
            hr = GetProc(hr, "SysAllocString",              (PVOID*)& pfnSysAllocString);
            hr = GetProc(hr, "SysAllocStringLen",           (PVOID*)& pfnSysAllocStringLen);
            hr = GetProc(hr, "SysAllocStringByteLen",       (PVOID*)& pfnSysAllocStringByteLen);
            hr = GetProc(hr, "SysReAllocString",            (PVOID*)& pfnSysReAllocString);
            hr = GetProc(hr, "SysReAllocStringLen",         (PVOID*)& pfnSysReAllocStringLen);
            hr = GetProc(hr, "SysFreeString",               (PVOID*)& pfnSysFreeString);
            hr = GetProc(hr, "SysStringByteLen",            (PVOID*)& pfnSysStringByteLen);
            
            hr = GetProc(hr, "VariantClear",                (PVOID*)& pfnVariantClear);
            hr = GetProc(hr, "VariantCopy",                 (PVOID*)& pfnVariantCopy);

            hr = GetProc(hr, "SafeArrayDestroy",            (PVOID*)& pfnSafeArrayDestroy);
            hr = GetProc(hr, "SafeArrayDestroyData",        (PVOID*)& pfnSafeArrayDestroyData);
            hr = GetProc(hr, "SafeArrayDestroyDescriptor",  (PVOID*)& pfnSafeArrayDestroyDescriptor);
            hr = GetProc(hr, "SafeArrayAllocDescriptor",    (PVOID*)& pfnSafeArrayAllocDescriptor);
            hr = GetProc(hr, "SafeArrayAllocDescriptorEx",  (PVOID*)& pfnSafeArrayAllocDescriptorEx);
            hr = GetProc(hr, "SafeArrayAllocData",          (PVOID*)& pfnSafeArrayAllocData);
            hr = GetProc(hr, "SafeArrayCopyData",           (PVOID*)& pfnSafeArrayCopyData);

            if (!hr)
            {
                fProcAddressesLoaded = TRUE;
            }
        }
    }

    if (!!hr)
    {
        Throw(hr);
    }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

OLEAUTOMATION_FUNCTIONS g_oa;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\stdpch.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.cpp
//
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\oleautglue.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// oleautglue.h
//

#ifndef __OLEAUTGLUE_H__
#define __OLEAUTGLUE_H__

typedef HRESULT (STDCALL* LOADTYPELIB_ROUTINE)(LPCWSTR szFile, ITypeLib** pptlib);
typedef HRESULT (STDCALL* LOADTYPELIBEX_ROUTINE)(LPCWSTR szFile, REGKIND, ITypeLib** pptlib);
typedef HRESULT (STDCALL* LOADREGTYPELIB_ROUTINE)(REFGUID libId, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib** pptlib);

typedef ULONG (STDCALL* PFNSAFEARRAY_SIZE)      (ULONG* pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray, const IID *piid);
typedef BYTE* (STDCALL* PFNSAFEARRAY_MARSHAL)   (ULONG* pFlags, BYTE* pBuffer, LPSAFEARRAY * ppSafeArray,const IID *piid);
typedef BYTE* (STDCALL* PFNSAFEARRAY_UNMARSHAL) (ULONG * pFlags,BYTE * pBuffer,LPSAFEARRAY * ppSafeArray,const IID *piid);
    
typedef BSTR    (STDCALL* PFNSYSALLOCSTRING)           (LPCWSTR);
typedef BSTR    (STDCALL* PFNSYSALLOCSTRINGLEN)        (LPCWSTR wsz, UINT);
typedef BSTR    (STDCALL* PFNSYSALLOCSTRINGBYTELEN)    (LPCSTR psz, UINT len);
typedef INT     (STDCALL* PFNSYSREALLOCSTRING)         (BSTR*, LPCWSTR);
typedef INT     (STDCALL* PFNSYSREALLOCSTRINGLEN)      (BSTR*, LPCWSTR, UINT);
typedef void    (STDCALL* PFNSYSFREESTRING)            (LPWSTR);
typedef UINT    (STDCALL* PFNSYSSTRINGBYTELEN)         (BSTR);

typedef HRESULT (STDCALL* PFNSAFEARRAYDESTROY)         (SAFEARRAY*);
typedef HRESULT (STDCALL* PFNSAFEARRAYDESTROYDATA)     (SAFEARRAY*);
typedef HRESULT (STDCALL* PFNSAFEARRAYDESTROYDESCRIPTOR)(SAFEARRAY*);
typedef HRESULT (STDCALL* PFNSAFEARRAYALLOCDATA)       (SAFEARRAY*);
typedef HRESULT (STDCALL* PFNSAFEARRAYALLOCDESCRIPTOR) (UINT, SAFEARRAY**);
typedef HRESULT (STDCALL* PFNSAFEARRAYALLOCDESCRIPTOREX)(VARTYPE, UINT, SAFEARRAY**);
typedef HRESULT (STDCALL* PFNSAFEARRAYCOPYDATA)        (SAFEARRAY*, SAFEARRAY*);

typedef HRESULT (STDCALL* PFNVARIANTCLEAR)             (VARIANTARG*);
typedef HRESULT (STDCALL* PFNVARIANTCOPY)              (VARIANTARG*, VARIANTARG*);


struct OLEAUTOMATION_FUNCTIONS
{
    //////////////////////////////////////////////////////////////////////
    //
    // User mode OLEAUTOMATION_FUNCTIONS
    //
  private:
    HINSTANCE                          hOleAut32;
    BOOL                               fProcAddressesLoaded;
    
    USER_MARSHAL_SIZING_ROUTINE        pfnLPSAFEARRAY_UserSize;
    USER_MARSHAL_MARSHALLING_ROUTINE   pfnLPSAFEARRAY_UserMarshal;
    USER_MARSHAL_UNMARSHALLING_ROUTINE pfnLPSAFEARRAY_UserUnmarshal;
    LOADTYPELIB_ROUTINE                pfnLoadTypeLib;
    LOADTYPELIBEX_ROUTINE              pfnLoadTypeLibEx;
    LOADREGTYPELIB_ROUTINE             pfnLoadRegTypeLib;
    PFNSAFEARRAY_SIZE                  pfnLPSAFEARRAY_Size;
    PFNSAFEARRAY_MARSHAL               pfnLPSAFEARRAY_Marshal;
    PFNSAFEARRAY_UNMARSHAL             pfnLPSAFEARRAY_Unmarshal;
    PFNSYSALLOCSTRING                  pfnSysAllocString;
    PFNSYSALLOCSTRINGLEN               pfnSysAllocStringLen;
    PFNSYSALLOCSTRINGBYTELEN           pfnSysAllocStringByteLen;
    PFNSYSREALLOCSTRING                pfnSysReAllocString;
    PFNSYSREALLOCSTRINGLEN             pfnSysReAllocStringLen;
    PFNSYSFREESTRING                   pfnSysFreeString;
    PFNSYSSTRINGBYTELEN                pfnSysStringByteLen;
    
    PFNSAFEARRAYDESTROY                pfnSafeArrayDestroy;
    PFNSAFEARRAYDESTROYDATA            pfnSafeArrayDestroyData;
    PFNSAFEARRAYDESTROYDESCRIPTOR      pfnSafeArrayDestroyDescriptor;
    PFNSAFEARRAYALLOCDATA              pfnSafeArrayAllocData;
    PFNSAFEARRAYALLOCDESCRIPTOR        pfnSafeArrayAllocDescriptor;
    PFNSAFEARRAYALLOCDESCRIPTOREX      pfnSafeArrayAllocDescriptorEx;
    PFNSAFEARRAYCOPYDATA               pfnSafeArrayCopyData;

    PFNVARIANTCLEAR                    pfnVariantClear;
    PFNVARIANTCOPY                     pfnVariantCopy;

    USER_MARSHAL_ROUTINE_QUADRUPLE     UserMarshalRoutines[3];

    enum {
        UserMarshal_Index_BSTR = 0,
        UserMarshal_Index_VARIANT,
        UserMarshal_Index_SafeArray,
    };

    void    Load();
    HRESULT GetProc(HRESULT hr, LPCSTR szProcName, PVOID* ppfn);
    HRESULT LoadOleAut32();

    static ULONG SafeArraySize(ULONG * pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray);
    static BYTE* SafeArrayMarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray);
    static BYTE* SafeArrayUnmarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray);

  public:

    USER_MARSHAL_SIZING_ROUTINE         get_pfnLPSAFEARRAY_UserSize()       { Load(); return pfnLPSAFEARRAY_UserSize;       }
    USER_MARSHAL_MARSHALLING_ROUTINE    get_pfnLPSAFEARRAY_UserMarshal()    { Load(); return pfnLPSAFEARRAY_UserMarshal;    }
    USER_MARSHAL_UNMARSHALLING_ROUTINE  get_pfnLPSAFEARRAY_UserUnmarshal()  { Load(); return pfnLPSAFEARRAY_UserUnmarshal;  }
    LOADTYPELIB_ROUTINE                 get_pfnLoadTypeLib()                { Load(); return pfnLoadTypeLib;                }
    LOADTYPELIBEX_ROUTINE               get_pfnLoadTypeLibEx()              { Load(); return pfnLoadTypeLibEx;              }
    LOADREGTYPELIB_ROUTINE              get_pfnLoadRegTypeLib()             { Load(); return pfnLoadRegTypeLib;             }
    PFNSAFEARRAY_SIZE                   get_pfnLPSAFEARRAY_Size()           { Load(); return pfnLPSAFEARRAY_Size;           }
    PFNSAFEARRAY_MARSHAL                get_pfnLPSAFEARRAY_Marshal()        { Load(); return pfnLPSAFEARRAY_Marshal;        }
    PFNSAFEARRAY_UNMARSHAL              get_pfnLPSAFEARRAY_Unmarshal()      { Load(); return pfnLPSAFEARRAY_Unmarshal;      }

    USER_MARSHAL_SIZING_ROUTINE         get_BSTR_UserSize()                 { Load(); return UserMarshalRoutines[UserMarshal_Index_BSTR].pfnBufferSize; }
    USER_MARSHAL_MARSHALLING_ROUTINE    get_BSTR_UserMarshal()              { Load(); return UserMarshalRoutines[UserMarshal_Index_BSTR].pfnMarshall;   }    
    USER_MARSHAL_UNMARSHALLING_ROUTINE  get_BSTR_UserUnmarshal()            { Load(); return UserMarshalRoutines[UserMarshal_Index_BSTR].pfnUnmarshall; }
    USER_MARSHAL_FREEING_ROUTINE        get_BSTR_UserFree()                 { Load(); return UserMarshalRoutines[UserMarshal_Index_BSTR].pfnFree;       }

    USER_MARSHAL_SIZING_ROUTINE         get_VARIANT_UserSize()              { Load(); return UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnBufferSize; }
    USER_MARSHAL_MARSHALLING_ROUTINE    get_VARIANT_UserMarshal()           { Load(); return UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnMarshall;   }    
    USER_MARSHAL_UNMARSHALLING_ROUTINE  get_VARIANT_UserUnmarshal()         { Load(); return UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnUnmarshall; }
    USER_MARSHAL_FREEING_ROUTINE        get_VARIANT_UserFree()              { Load(); return UserMarshalRoutines[UserMarshal_Index_VARIANT].pfnFree;       }

    USER_MARSHAL_FREEING_ROUTINE        get_LPSAFEARRAY_UserFree()          { Load(); return UserMarshalRoutines[UserMarshal_Index_SafeArray].pfnFree;     }

    USER_MARSHAL_ROUTINE_QUADRUPLE*     get_UserMarshalRoutines()           { Load(); return &UserMarshalRoutines[0]; }

    PFNSYSALLOCSTRING                   get_SysAllocString()                { Load(); return pfnSysAllocString;        }
    PFNSYSALLOCSTRINGLEN                get_SysAllocStringLen()             { Load(); return pfnSysAllocStringLen;     }
    PFNSYSALLOCSTRINGBYTELEN            get_SysAllocStringByteLen()         { Load(); return pfnSysAllocStringByteLen; }
    PFNSYSREALLOCSTRING                 get_SysReAllocString()              { Load(); return pfnSysReAllocString;      }
    PFNSYSREALLOCSTRINGLEN              get_SysReAllocStringLen()           { Load(); return pfnSysReAllocStringLen;   }
    PFNSYSFREESTRING                    get_SysFreeString()                 { Load(); return pfnSysFreeString;         }
    PFNSYSSTRINGBYTELEN                 get_SysStringByteLen()              { Load(); return pfnSysStringByteLen;      }

    PFNSAFEARRAYDESTROY                 get_SafeArrayDestroy()              { Load(); return pfnSafeArrayDestroy;      }
    PFNSAFEARRAYDESTROYDATA             get_SafeArrayDestroyData()          { Load(); return pfnSafeArrayDestroyData;  }
    PFNSAFEARRAYDESTROYDESCRIPTOR       get_SafeArrayDestroyDescriptor()    { Load(); return pfnSafeArrayDestroyDescriptor; }
    PFNSAFEARRAYALLOCDESCRIPTOR         get_SafeArrayAllocDescriptor()      { Load(); return pfnSafeArrayAllocDescriptor; }
    PFNSAFEARRAYALLOCDESCRIPTOREX       get_SafeArrayAllocDescriptorEx()    { Load(); return pfnSafeArrayAllocDescriptorEx; }
    PFNSAFEARRAYALLOCDATA               get_SafeArrayAllocData()            { Load(); return pfnSafeArrayAllocData;    }
    PFNSAFEARRAYCOPYDATA                get_SafeArrayCopyData()             { Load(); return pfnSafeArrayCopyData;     }

    PFNVARIANTCLEAR                     get_VariantClear()                  { Load(); return pfnVariantClear;          }
    PFNVARIANTCOPY                      get_VariantCopy()                   { Load(); return pfnVariantCopy;           }

    OLEAUTOMATION_FUNCTIONS()
    {
        Zero(this); // no vtables, so this is ok
        UserMarshalRoutines[UserMarshal_Index_SafeArray].pfnBufferSize = (USER_MARSHAL_SIZING_ROUTINE)SafeArraySize;
        UserMarshalRoutines[UserMarshal_Index_SafeArray].pfnMarshall   = (USER_MARSHAL_MARSHALLING_ROUTINE)SafeArrayMarshal;
        UserMarshalRoutines[UserMarshal_Index_SafeArray].pfnUnmarshall = (USER_MARSHAL_UNMARSHALLING_ROUTINE)SafeArrayUnmarshal;
    }

    ~OLEAUTOMATION_FUNCTIONS()
    {
        if (hOleAut32)
        {
            FreeLibrary(hOleAut32);
            hOleAut32 = NULL;
        }
    }

    //////////////////////////////////////////////////////////////////////
    //
    // OLEAUTOMATION_FUNCTIONS - both modes
  private:

    BOOL IsEqualPfn(PVOID pfnImported, PVOID pfnReal)
        // Answer as to whether these two PFNs are equal. pfnReal is known to be the
        // actual start of the routine (since it came from a GetProcAddress). pfnImported
        // may be the real start of the routine, or it may be the address of an import
        // descriptor to the routine.
        //
        // For example, in x86, pfnImported may be &BSTR_UserFree, where that's actually:
        //
        // _BSTR_UserFree@8:
        // 00C92E42 FF 25 80 20 C9 00    jmp         dword ptr [__imp__BSTR_UserFree@8(0x00c92080)]
        //
        // On ALPHA, the code sequence looks something like:
        //
        //  BSTR_UserFree:
        //  00000000: 277F0000 ldah          t12,0
        //  00000004: A37B0000 ldl           t12,0(t12)
        //  00000008: 6BFB0000 jmp           zero,(t12),0
        //
    {
        if (pfnImported == pfnReal)
            return TRUE;
        else
        {
            __try
                {
                    typedef void (__stdcall*PFN)(void*);
#pragma pack(push, 1)
#if defined(_X86_)
      
                    struct THUNK
                    {
                        BYTE jmp[2]; PFN* ppfn;                    
                    };

                    THUNK* pThunk = (THUNK*)pfnImported;

                    if (pThunk->jmp[0] == 0xFF) // avoid AVs in debugger (harmless, but annoying)
                    {
                        return *pThunk->ppfn == (PFN)pfnReal;
                    }
                    else
                    {
                        return FALSE;
                    }

#elif defined(_AMD64_)

                    struct THUNK
                    {
                        BYTE jmp[2]; PFN* ppfn;                    
                    };

                    THUNK* pThunk = (THUNK*)pfnImported;

                    // BUGBUG this won't be correct for amd64

                    if (pThunk->jmp[0] == 0xFF) // avoid AVs in debugger (harmless, but annoying)
                    {
                        return *pThunk->ppfn == (PFN)pfnReal;
                    }
                    else
                    {
                        return FALSE;
                    }
                    return FALSE;
                
#elif defined(IA64)
                    
                    // BUGBUG needs to be implemented
                    return FALSE;

#else
#error Unknown processor
                    return FALSE;

#endif
#pragma pack(pop)
                }

            __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return FALSE;
                }
        }
    }

  public:

    BOOL IsVariant(const USER_MARSHAL_ROUTINE_QUADRUPLE& quad)
    {
        if (quad.pfnFree == (USER_MARSHAL_FREEING_ROUTINE)VARIANT_UserFree)
        {
            return TRUE;
        }
        else
        {
            PVOID pfnInOleAut = get_VARIANT_UserFree();
            return IsEqualPfn(quad.pfnFree, pfnInOleAut);
        }

        return FALSE;
    }
    BOOL IsBSTR(const USER_MARSHAL_ROUTINE_QUADRUPLE& quad)
    {
        if (quad.pfnFree == (USER_MARSHAL_FREEING_ROUTINE)BSTR_UserFree)
        {
            return TRUE;
        }
        else
        {
            PVOID pfnInOleAut = get_BSTR_UserFree();
            return IsEqualPfn(quad.pfnFree, pfnInOleAut);
        }

        return FALSE;
    }
    BOOL IsSAFEARRAY(const USER_MARSHAL_ROUTINE_QUADRUPLE& quad)
    {
        if (quad.pfnFree == (USER_MARSHAL_FREEING_ROUTINE)LPSAFEARRAY_UserFree)
        {
            return TRUE;
        }
        else
        {
            PVOID pfnInOleAut = get_LPSAFEARRAY_UserFree();
            return IsEqualPfn(quad.pfnFree, pfnInOleAut);
        }

        return FALSE;
    }    
};


extern OLEAUTOMATION_FUNCTIONS g_oa;


/////////////////////////////////////////////////////////////////////////////////////
//
// Functions that do some type-specific walking.
//
/////////////////////////////////////////////////////////////////////////////////////
inline void VariantInit(VARIANT* pvar)
{
    V_VT(pvar) = VT_EMPTY;
}


struct OAUTIL
{
    ICallFrameWalker* m_pWalkerCopy;
    ICallFrameWalker* m_pWalkerFree;
    ICallFrameWalker* m_pWalkerWalk;
    BOOL              m_fWorkingOnInParam;
    BOOL              m_fWorkingOnOutParam;
    BOOL              m_fDoNotWalkInterfaces;


    ///////////////////////////////////////////////////////////////////

    OAUTIL(ICallFrameWalker* pWalkerCopy, 
           ICallFrameWalker* pWalkerFree, 
           ICallFrameWalker* pWalkerWalk, 
           BOOL fIn, 
           BOOL fOut)
    {
        m_pWalkerWalk = pWalkerWalk; if (m_pWalkerWalk) m_pWalkerWalk->AddRef();
        m_pWalkerFree = pWalkerFree; if (m_pWalkerFree) m_pWalkerFree->AddRef();
        m_pWalkerCopy = pWalkerCopy; if (m_pWalkerCopy) m_pWalkerCopy->AddRef();
        m_fWorkingOnInParam  = fIn;
        m_fWorkingOnOutParam = fOut;
        m_fDoNotWalkInterfaces = FALSE;
    }

    ~OAUTIL()
    {
        ::Release(m_pWalkerCopy);
        ::Release(m_pWalkerFree);
        ::Release(m_pWalkerWalk);
    }

    HRESULT Walk(DWORD walkWhat, DISPPARAMS* pdispParams);
    HRESULT Walk(VARIANTARG* pv);
    HRESULT Walk(SAFEARRAY* psa);

    ///////////////////////////////////////////////////////////////////

    HRESULT SafeArrayClear (SAFEARRAY *psa, BOOL fWeOwnByRefs);

    HRESULT VariantClear(VARIANTARG * pvarg, BOOL fWeOwnByrefs = FALSE);
    HRESULT VariantCopy (VARIANTARG * pvargDest, VARIANTARG * pvargSrc, BOOL fNewFrame = FALSE);

    ///////////////////////////////////////////////////////////////////

    BSTR  SysAllocString(LPCWSTR);
    BSTR  SysAllocStringLen(LPCWSTR, UINT);
    BSTR  SysAllocStringByteLen(LPCSTR psz, UINT cb);
    INT   SysReAllocString(BSTR *, LPCWSTR);
    INT   SysReAllocStringLen(BSTR *, LPCWSTR, UINT);
    void  SysFreeString(BSTR);
    UINT  SysStringLen(BSTR);

    UINT  SysStringByteLen(BSTR bstr);

    BSTR  Copy(BSTR bstr)
    {
        return SysAllocStringByteLen((LPCSTR)bstr, SysStringByteLen(bstr));
    }

    void SetWalkInterfaces(BOOL fWalkInterfaces)
    {
        m_fDoNotWalkInterfaces = !fWalkInterfaces;
    }

    BOOL WalkInterfaces()
    {
        return !m_fDoNotWalkInterfaces;
    }


    void SetWorkingOnIn(BOOL fIn)
    {
        m_fWorkingOnInParam = fIn;
    }

    void SetWorkingOnOut(BOOL fOut)
    {
        m_fWorkingOnOutParam = fOut;
    }

    ///////////////////////////////////////////////////////////////////

    HRESULT WalkInterface(REFIID riid, void **ppv, ICallFrameWalker *pWalker)
    {
        if (pWalker)
        {
            return pWalker->OnWalkInterface(riid, ppv, m_fWorkingOnInParam, m_fWorkingOnOutParam);
        }
        return S_OK;
    }

    HRESULT WalkInterface(REFIID riid, void **ppv)
    {
        return WalkInterface(riid, ppv, m_pWalkerWalk);
    }


    template <class INTERFACE_TYPE> HRESULT WalkInterface(INTERFACE_TYPE** ppt, ICallFrameWalker* pWalker)
    {
        return WalkInterface(__uuidof(INTERFACE_TYPE), (void **)ppt, pWalker);
    }
    
    template <class INTERFACE_TYPE> HRESULT WalkInterface(INTERFACE_TYPE** ppt)
    {
        return WalkInterface(ppt, m_pWalkerWalk);
    }


    HRESULT AddRefInterface(REFIID riid, void **ppv)
    {
        if (m_pWalkerCopy)
        {
            return WalkInterface(riid, ppv, m_pWalkerCopy);
        }
        else
        {
            if (*ppv)
            {
                (*((IUnknown **)ppv))->AddRef();
            }
            return S_OK;
        }
    }

    template <class INTERFACE_TYPE> HRESULT AddRefInterface(INTERFACE_TYPE*& refpt)
    {
        return AddRefInterface(__uuidof(INTERFACE_TYPE), (void **)(&refpt));
    }


    HRESULT ReleaseInterface(REFIID riid, void **ppv)
    {
        if (m_pWalkerFree)
        {
            return WalkInterface(riid, ppv, m_pWalkerFree);
        }
        else
        {
            if (*ppv)
            {
                (*((IUnknown **)ppv))->Release();
            }
            return S_OK;
        }
    }


    template <class INTERFACE_TYPE> HRESULT ReleaseInterface(INTERFACE_TYPE*& refpt)
    {
        return ReleaseInterface(__uuidof(INTERFACE_TYPE), (void **)(&refpt));
    }



    ///////////////////////////////////////////////////////////////////

    HRESULT SafeArrayCopy(SAFEARRAY * psa, SAFEARRAY ** ppsaOut);
    HRESULT SafeArrayCopyData(SAFEARRAY* psaSource, SAFEARRAY* psaTarget);
    HRESULT SafeArrayDestroyData(SAFEARRAY * psa);
    HRESULT SafeArrayDestroy(SAFEARRAY* psa);

    HRESULT SafeArrayLock(SAFEARRAY* psa)
    {
        if (psa)
        {
            ++psa->cLocks;
            if (psa->cLocks == 0)
            {
                --psa->cLocks;
                return E_UNEXPECTED;
            }
            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

    HRESULT SafeArrayUnlock(SAFEARRAY* psa)
    {
        if (psa)
        {
            if (psa->cLocks == 0)
            {
                return E_UNEXPECTED;
            }
            --psa->cLocks;
            return S_OK;
        }
        else
            return E_INVALIDARG;
    }

  private:

    HRESULT Walk(SAFEARRAY* psa, PVOID pvData);
    HRESULT Walk(SAFEARRAY* psa, IRecordInfo*, ULONG iDim, PVOID pvDataIn, PVOID* ppvDataOut);
    
    HRESULT CopyRecordField(
        IN LPBYTE       pbSrc,
        IN LPBYTE       pbDst,
        IN TYPEDESC    *ptdesc,
        IN ITypeInfo   *ptinfo,
        IN BOOL         fNewFrame);
    
    HRESULT CopyRecord(
        IN PVOID pvDst, 
        IN PVOID pvSrc, 
        IN ITypeInfo *ptiRecord, 
        IN BOOL fNewFrame);
    
    HRESULT CopyRecord(
        IN IRecordInfo *pri,
        IN PVOID pvSrc, 
        IN OUT PVOID *ppvDst, 
        IN BOOL fNewFrame);
    
    HRESULT FreeRecordField(
        IN LPBYTE       pbSrc,
        IN TYPEDESC    *ptdesc,
        IN ITypeInfo   *ptinfo,
        IN BOOL         fWeOwnByRefs);
    
    HRESULT FreeRecord(
        IN PVOID pvSrc, 
        IN ITypeInfo *ptinfo, 
        IN BOOL fWeOwnByRefs);
    
    HRESULT FreeRecord(
        IN LPVOID pvRecord,
        IN IRecordInfo *priRecord,
        IN BOOL fWeOwnByRefs);    

    HRESULT WalkRecordField(
        IN LPBYTE       pbSrc,
        IN TYPEDESC    *ptdesc,
        IN ITypeInfo   *ptinfo);

    HRESULT WalkRecord(
        IN PVOID pvSrc, 
        IN ITypeInfo *ptinfo);

    HRESULT WalkRecord(
        IN LPVOID pvRecord,
        IN IRecordInfo *priRecord);
};

extern OAUTIL g_oaUtil;

#endif // #ifndef __OLEAUTGLUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\stdpch.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.h
//
#ifndef __STDPCH_H__
#define __STDPCH_H__

//JohnDoty:  Pulled out KernelMode stuff... 

//
// All routines we need that would normally be found in oleaut32.dll
// need to be implemented locally here, either in full or in such a
// way so as to dyna-load OLEAUT32.DLL
//
#define _OLEAUT32_


#include <stdio.h>
#include <stdarg.h>
#include <memory.h>
#include <malloc.h>

//JohnDoty:  We actually WANT to be WIN32_LEAN_AND_MEAN.  If we don't
//           then windows.h pulls in rpcndr.h from the publics.  This would
//           be fine if we weren't dependent on an old and brittle copy of
//           the same.
//#undef WIN32_LEAN_AND_MEAN

extern "C" {

//JohnDoty:  Removed dependency on kernel headers
//#include "ntos.h"
//#include "fsrtl.h"

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"

#define NT_INCLUDED

#include "windows.h"
#include "objbase.h"

#include "rpcndr.h"

#include "imagehlp.h"
#include "ocidl.h"
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\tiutil.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// tiutil.h
//
// Utility stuff for typeinfo.cpp etc.


////////////////////////////////////////////////////////////////////////////
//
// From oa\src\dispatch\oledisp.h
//
// VT_VMAX is the first VARENUM value that is *not* legal in a VARIANT.
//
#define VT_VMAX     VT_DECIMAL+1
//
// The largest unused value in VARENUM enumeration
//
#define VT_MAX      (VT_CLSID+1)
//
// This is a special value that is used internally for marshaling interfaces.
//
#define VT_INTERFACE VT_MAX
#if defined(_WIN64)
#define VT_MULTIINDIRECTIONS (VT_TYPEMASK - 1)
#endif

////////////////////////////////////////////////////////////////////////////
//
// From oa\src\dispatch\oautil.h

#define FADF_FORCEFREE  0x1000  /* SafeArrayFree() ignores FADF_STATIC and frees anyway */

////////////////////////////////////////////////////////////////////////////
//
// From oa\src\dispatch\rpcallas.cpp

#define PREALLOCATE_PARAMS           16         // prefer stack to malloc
#define MARSHAL_INVOKE_fakeVarResult 0x020000   // private flags in HI word
#define MARSHAL_INVOKE_fakeExcepInfo 0x040000
#define MARSHAL_INVOKE_fakeArgErr    0x080000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\records.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
//  records.cpp
//
//  Support for copying UDTs with ITypeinfo's.  (Really, support for copying
//  one blob to another blob that's defined by an ITypeInfo, but we only use
//  it for copying UDTs.)
//
//  Apr-11-2002  JohnDoty  Done Made Up
//
#include "stdpch.h"
#include "common.h"

#include <debnot.h>

#define LENGTH_ALIGN( Length, cAlign ) \
            Length = (((Length) + (cAlign)) & ~ (cAlign))

HRESULT
SizeOfTYPEDESC(
    IN ITypeInfo *ptinfo,
    IN TYPEDESC *ptdesc,
    OUT ULONG *pcbSize
)
{
    ITypeInfo *ptiUDT  = NULL;
    TYPEATTR  *ptattr  = NULL;
    ULONG      cbAlign = 0;
    HRESULT    hr      = S_OK;


    *pcbSize = 0;

    switch (ptdesc->vt) 
    {
    case VT_I1:
    case VT_UI1:
        *pcbSize = 1;
        break;
    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        *pcbSize = 2;
        break;
    case VT_PTR:
        if (ptdesc->lptdesc->vt != VT_USERDEFINED) 
        {
            hr = TYPE_E_UNSUPFORMAT;
            break;
        }

        *pcbSize = sizeof(void*);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_HRESULT:
        *pcbSize = 4;
        break;

    case VT_BSTR:
    case VT_UNKNOWN:
    case VT_DISPATCH:
    case VT_SAFEARRAY:
        *pcbSize = sizeof(void*);
        break;
        
    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
        *pcbSize = 8;
        break;

    case VT_DECIMAL:
        *pcbSize = 16;
        break;

    case VT_USERDEFINED:        
        hr = ptinfo->GetRefTypeInfo(ptdesc->hreftype, &ptiUDT);
        if (SUCCEEDED(hr))
        {
            hr = ptiUDT->GetTypeAttr(&ptattr);
            if (SUCCEEDED(hr))
            {
                *pcbSize = ptattr->cbSizeInstance;
                cbAlign = ptattr->cbAlignment;

                ptiUDT->ReleaseTypeAttr(ptattr);
            }
            ptiUDT->Release();
        }
        break;

    case VT_VARIANT:
        *pcbSize = sizeof(VARIANT);
        break;

    case VT_INT_PTR:
    case VT_UINT_PTR:
        *pcbSize = sizeof(INT_PTR);
        break;
        
    default:
        hr = DISP_E_BADVARTYPE;
        break;
    }

    if (cbAlign)
    {
        LENGTH_ALIGN(*pcbSize, (cbAlign-1));
    }
    
    return hr;
}

inline
HRESULT
WalkThroughAlias(
    IN OUT ITypeInfo **pptiUDT, 
    IN OUT TYPEATTR **pptattrUDT
)
{
    ITypeInfo *ptiUDT    = *pptiUDT;
    TYPEATTR  *ptattrUDT = *pptattrUDT;
    HRESULT    hr        = S_OK;

    // Walk through aliases.
    while (ptattrUDT->typekind == TKIND_ALIAS)
    {
        ITypeInfo *ptiTmp = NULL;

        if (ptattrUDT->tdescAlias.vt != VT_USERDEFINED)
        {
            hr = TYPE_E_UNSUPFORMAT;
            goto cleanup;
        }
        
        HREFTYPE hreftype = ptattrUDT->tdescAlias.hreftype;
        
        ptiUDT->ReleaseTypeAttr(ptattrUDT); 
        ptattrUDT = NULL;
        
        hr = ptiUDT->GetRefTypeInfo(hreftype, &ptiTmp);
        if (FAILED(hr)) goto cleanup;

        ptiUDT->Release();
        ptiUDT = ptiTmp;

        hr = ptiUDT->GetTypeAttr(&ptattrUDT);
        if (FAILED(hr)) goto cleanup;            
    }

cleanup:

    *pptiUDT    = ptiUDT;
    *pptattrUDT = ptattrUDT;

    return hr;
}


HRESULT 
OAUTIL::CopyRecordField(
    IN LPBYTE       pbSrc,
    IN LPBYTE       pbDst,
    IN TYPEDESC    *ptdesc,
    IN ITypeInfo   *ptinfo,
    IN BOOL         fNewFrame
)
{
    ITypeInfo *ptiUDT      = NULL;
    TYPEATTR  *ptattrUDT   = NULL;
    HRESULT    hr          = S_OK;
    IID        iid;

    // Enforce some type rules here.
    //
    // If this is a pointer, it needs to be a pointer to a userdefined,
    // specifically, a pointer to an interface pointer other than IUnknown
    // or IDispatch.  (If IFoo : IDispatch, then IFoo * is 
    // VT_PTR->VT_USERDEFINED(TKIND_DISPATCH))
    //
    // As of 3-12-2002, these are the rules that oleaut follows.
    if (ptdesc->vt == VT_PTR)
    {
        if (ptdesc->lptdesc->vt != VT_USERDEFINED)
        {
            hr = TYPE_E_UNSUPFORMAT;
            goto cleanup;
        }

        ptdesc = ptdesc->lptdesc;
        hr = ptinfo->GetRefTypeInfo(ptdesc->hreftype, &ptiUDT);
        if (FAILED(hr)) goto cleanup;

        hr = ptiUDT->GetTypeAttr(&ptattrUDT);
        if (FAILED(hr)) goto cleanup;
        
        // Walk through aliases.
        hr = WalkThroughAlias(&ptiUDT, &ptattrUDT);
        if (FAILED(hr)) goto cleanup;

        if ((ptattrUDT->typekind == TKIND_INTERFACE) ||
            (ptattrUDT->typekind == TKIND_DISPATCH))
        {
            // Great, we've got an interface pointer here.
            //
            // Just do our copy now.
            IUnknown **ppunkSrc = (IUnknown **)pbSrc;
            IUnknown **ppunkDst = (IUnknown **)pbDst;

            *ppunkDst = *ppunkSrc;
            if (WalkInterfaces())
            {
                hr = AddRefInterface(ptattrUDT->guid, (void **)ppunkDst);
            }
            else if (*ppunkDst)
                (*ppunkDst)->AddRef();

            goto cleanup;
        }
        else
        {
            hr = TYPE_E_UNSUPFORMAT;
            goto cleanup;
        }
    }
    else
    {
        switch(ptdesc->vt)
        {
        case VT_UNKNOWN:
            {
                IUnknown **ppunkSrc = (IUnknown **)pbSrc;
                IUnknown **ppunkDst = (IUnknown **)pbDst;
                
                *ppunkDst = *ppunkSrc;
                if (WalkInterfaces())
                {
                    AddRefInterface(*ppunkDst);
                    if (FAILED(hr)) goto cleanup;
                }
                else if (*ppunkDst)
                    (*ppunkDst)->AddRef();
            }
            break;
            
        case VT_DISPATCH:
            {
                IDispatch **ppdspSrc = (IDispatch **)pbSrc;
                IDispatch **ppdspDst = (IDispatch **)pbDst;
                
                *ppdspDst = *ppdspSrc;
                if (WalkInterfaces())
                {
                    hr = AddRefInterface(*ppdspDst);
                    if (FAILED(hr)) goto cleanup;
                }
                else if (*ppdspDst)
                    (*ppdspDst)->AddRef();
            }
            break;
            
        case VT_VARIANT:
            {
                VARIANT *pvarSrc = (VARIANT *)pbSrc;
                VARIANT *pvarDst = (VARIANT *)pbDst;
                
                hr = VariantCopy(pvarDst, pvarSrc, fNewFrame);
                if (FAILED(hr)) goto cleanup;
            }
            break;

        case VT_CARRAY:
            {                
                ARRAYDESC *parrdesc = ptdesc->lpadesc;
                DWORD cElements = 1;
                ULONG cbElement;

                DWORD i;
                for (i = 0; i < parrdesc->cDims; i++)
                {
                    cElements *= parrdesc->rgbounds[i].cElements;
                }

                hr = SizeOfTYPEDESC(ptinfo, &(parrdesc->tdescElem), &cbElement);
                if (FAILED(hr)) goto cleanup;

                for (i = 0; i < cElements; i++)
                {
                    // Recurse on the array elements.
                    hr = CopyRecordField(pbSrc, pbDst, &(parrdesc->tdescElem), ptinfo, fNewFrame);
                    if (FAILED(hr)) goto cleanup;

                    pbSrc += cbElement;
                    pbDst += cbElement;
                }
            }
            break;

        case VT_SAFEARRAY:
            {
                SAFEARRAY **ppsaSrc = (SAFEARRAY **)pbSrc;
                SAFEARRAY **ppsaDst = (SAFEARRAY **)pbDst;
                SAFEARRAY *paSrc   = *ppsaSrc;
                SAFEARRAY *paDst   = *ppsaDst;
                
                // These rules were taken out of the marshalling code from oleaut.
                // There is one optimization, though-- marshalling only allocs if
                // necessary.  We're allocating always, to make life simple.
                //
                // Note: that we took great care (above) to make sure paDst stays 
                //       the same if we're not going to a new frame.
                BOOL fDestResizeable = fNewFrame || (paDst == NULL) ||
                  (!(paDst->fFeatures & (FADF_AUTO|FADF_STATIC|FADF_EMBEDDED|FADF_FIXEDSIZE)));
                
                if (fDestResizeable)
                {
                    if (paDst)
                        hr = SafeArrayDestroy(paDst);
                    
                    if (SUCCEEDED(hr))
                    {
                        if (paSrc)
                            hr = SafeArrayCopy(paSrc, ppsaDst);
                        else
                            *ppsaDst = NULL;
                    }
                }
                else
                {
                    hr = SafeArrayCopyData(paSrc, paDst);
                    
                    // Not resizeable.... 
                    if (hr == E_INVALIDARG)
                        hr = DISP_E_BADCALLEE;
                }
            }
            break;

        case VT_USERDEFINED:
            {
                hr = ptinfo->GetRefTypeInfo(ptdesc->hreftype, &ptiUDT);
                if (FAILED(hr)) goto cleanup;

                hr = ptiUDT->GetTypeAttr(&ptattrUDT);
                if (FAILED(hr)) goto cleanup;

                hr = WalkThroughAlias(&ptiUDT, &ptattrUDT);
                if (FAILED(hr)) goto cleanup;

                if (ptattrUDT->typekind == TKIND_RECORD)
                {
                    // Aha!  Simply recurse on this record.
                    hr = CopyRecord(pbDst,
                                    pbSrc,
                                    ptiUDT,
                                    fNewFrame);
                    goto cleanup;
                }
                // else fall through...
            }
            // FALL THROUGH!
            
        default:
            {
                // Not something we need to walk.  Just copy the value.
                ULONG cbField;
                hr = SizeOfTYPEDESC(ptinfo, ptdesc, &cbField);
                if (FAILED(hr)) goto cleanup;

                memcpy(pbDst, pbSrc, cbField);
            }
            break;
        }
    }

cleanup:

    if (ptiUDT)
    {
        if (ptattrUDT)
            ptiUDT->ReleaseTypeAttr(ptattrUDT);
        ptiUDT->Release();
    }

    return hr;
}


HRESULT 
OAUTIL::CopyRecord(
    PVOID pvDst, 
    PVOID pvSrc, 
    ITypeInfo *ptinfo, 
    BOOL fNewFrame
)
{
    TYPEATTR *ptattr = NULL;
    VARDESC *pvardesc = NULL;


    HRESULT hr = ptinfo->GetTypeAttr(&ptattr);	
    if (FAILED(hr))
        return hr;
    
    // Walk, and copy.
    for (DWORD i = 0; i < ptattr->cVars; i++)
    {        
        hr = ptinfo->GetVarDesc(i, &pvardesc);
        if (FAILED(hr)) goto cleanup;

        // We just don't care, if this is not PerInstance.        
        if (pvardesc->varkind != VAR_PERINSTANCE)
        {
            ptinfo->ReleaseVarDesc(pvardesc);
            continue;
        }

        LPBYTE pbSrc = ((BYTE *)pvSrc) + pvardesc->oInst;
        LPBYTE pbDst = ((BYTE *)pvDst) + pvardesc->oInst;

        // Copy the field.
        hr = CopyRecordField(pbSrc, 
                             pbDst, 
                             &(pvardesc->elemdescVar.tdesc),
                             ptinfo,
                             fNewFrame);
        if (FAILED(hr)) goto cleanup;

        ptinfo->ReleaseVarDesc(pvardesc);
        pvardesc = NULL;
    }

cleanup:

    if (pvardesc != NULL) 
        ptinfo->ReleaseVarDesc(pvardesc);
    
    if (ptattr)
        ptinfo->ReleaseTypeAttr(ptattr);
    
    return hr;
}


HRESULT 
OAUTIL::CopyRecord(
    IRecordInfo *pri,
    PVOID pvSrc, 
    PVOID *ppvDst, 
    BOOL fNewFrame
)
{
    ITypeInfo *ptiRecord = NULL;
    TYPEATTR  *ptattr = NULL;
    LPVOID     pvDst = NULL;

    HRESULT hr = pri->GetTypeInfo(&ptiRecord);
    if (FAILED(hr)) return hr;

    if (fNewFrame)
    {
        hr = ptiRecord->GetTypeAttr(&ptattr);
        if (FAILED(hr)) goto cleanup;

        pvDst = CoTaskMemAlloc(ptattr->cbSizeInstance);
        if (NULL == pvDst)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        ZeroMemory(pvDst, ptattr->cbSizeInstance);
    }
    else
    {
        // We don't allocate new structs on the way [out] of 
        // a call.  It never works like that.
        pvDst = *ppvDst;
        Win4Assert(pvDst != NULL);
        if (pvDst == NULL)
        {
            hr = E_UNEXPECTED;
            goto cleanup;            
        }
    }

    hr = CopyRecord(pvDst, pvSrc, ptiRecord, fNewFrame);
    if (FAILED(hr)) goto cleanup;

    *ppvDst = pvDst;
    pvDst = NULL;

cleanup:
    
    if (fNewFrame && pvDst)
        CoTaskMemFree(pvDst);

    if (ptattr)
        ptiRecord->ReleaseTypeAttr(ptattr);

    ptiRecord->Release();

    return hr;
}


HRESULT 
OAUTIL::FreeRecordField(
    IN LPBYTE       pbSrc,
    IN TYPEDESC    *ptdesc,
    IN ITypeInfo   *ptinfo,
    IN BOOL         fWeOwnByRefs
)
{
    ITypeInfo *ptiUDT      = NULL;
    TYPEATTR  *ptattrUDT   = NULL;
    HRESULT    hr          = S_OK;
    IID        iid;

    // Same type rules as in CopyRecordField.
    if (ptdesc->vt == VT_PTR)
    {
        if (ptdesc->lptdesc->vt != VT_USERDEFINED)
        {
            hr = TYPE_E_UNSUPFORMAT;
            goto cleanup;
        }

        ptdesc = ptdesc->lptdesc;
        hr = ptinfo->GetRefTypeInfo(ptdesc->hreftype, &ptiUDT);
        if (FAILED(hr)) goto cleanup;

        hr = ptiUDT->GetTypeAttr(&ptattrUDT);
        if (FAILED(hr)) goto cleanup;
        
        // Walk through aliases.
        hr = WalkThroughAlias(&ptiUDT, &ptattrUDT);
        if (FAILED(hr)) goto cleanup;

        if ((ptattrUDT->typekind == TKIND_INTERFACE) ||
            (ptattrUDT->typekind == TKIND_DISPATCH))
        {
            // Great, we've got an interface pointer here.
            IUnknown **ppunkSrc = (IUnknown **)pbSrc;

            if (WalkInterfaces())
            {
                hr = ReleaseInterface(ptattrUDT->guid, (void **)ppunkSrc);
            }
            else if (*ppunkSrc)
                (*ppunkSrc)->Release();

            goto cleanup;
        }
        else
        {
            hr = TYPE_E_UNSUPFORMAT;
            goto cleanup;
        }
    }
    else
    {
        switch(ptdesc->vt)
        {
        case VT_UNKNOWN:
            {
                IUnknown **ppunkSrc = (IUnknown **)pbSrc;
                
                if (WalkInterfaces())
                {
                    ReleaseInterface(*ppunkSrc);
                    if (FAILED(hr)) goto cleanup;
                }
                else if (*ppunkSrc)
                    (*ppunkSrc)->Release();
            }
            break;
            
        case VT_DISPATCH:
            {
                IDispatch **ppdspSrc = (IDispatch **)pbSrc;
                
                if (WalkInterfaces())
                {
                    hr = ReleaseInterface(*ppdspSrc);
                    if (FAILED(hr)) goto cleanup;
                }
                else if (*ppdspSrc)
                    (*ppdspSrc)->Release();
            }
            break;
            
        case VT_VARIANT:
            {
                VARIANT *pvarSrc = (VARIANT *)pbSrc;
                
                hr = VariantClear(pvarSrc, fWeOwnByRefs);
                if (FAILED(hr)) goto cleanup;
            }
            break;

        case VT_CARRAY:
            {                
                ARRAYDESC *parrdesc = ptdesc->lpadesc;
                DWORD cElements = 1;
                ULONG cbElement;

                DWORD i;
                for (i = 0; i < parrdesc->cDims; i++)
                {
                    cElements *= parrdesc->rgbounds[i].cElements;                    
                }

                hr = SizeOfTYPEDESC(ptinfo, &(parrdesc->tdescElem), &cbElement);
                if (FAILED(hr)) goto cleanup;

                for (i = 0; i < cElements; i++)
                {
                    // Recurse on the array elements.
                    hr = FreeRecordField(pbSrc, &(parrdesc->tdescElem), ptinfo, fWeOwnByRefs);
                    if (FAILED(hr)) goto cleanup;

                    pbSrc += cbElement;
                }
            }
            break;

        case VT_SAFEARRAY:
            {                
                SAFEARRAY **ppsaSrc = (SAFEARRAY **)pbSrc;
                SAFEARRAY *psaSrc = *ppsaSrc;
                hr = SafeArrayDestroy(psaSrc);
                if (FAILED(hr)) goto cleanup;
            }
            break;

        case VT_USERDEFINED:
            {
                hr = ptinfo->GetRefTypeInfo(ptdesc->hreftype, &ptiUDT);
                if (FAILED(hr)) goto cleanup;

                hr = ptiUDT->GetTypeAttr(&ptattrUDT);
                if (FAILED(hr)) goto cleanup;

                hr = WalkThroughAlias(&ptiUDT, &ptattrUDT);
                if (FAILED(hr)) goto cleanup;

                if (ptattrUDT->typekind == TKIND_RECORD)
                {
                    // Aha!  Simply recurse on this record.
                    hr = FreeRecord(pbSrc,
                                    ptiUDT,
                                    fWeOwnByRefs);
                    goto cleanup;
                }
                // else fall through...
            }
            // FALL THROUGH!
            
        default:
            // Not something we need to free.
            break;
        }
    }

cleanup:

    if (ptiUDT)
    {
        if (ptattrUDT)
            ptiUDT->ReleaseTypeAttr(ptattrUDT);
        ptiUDT->Release();
    }

    return hr;
}


HRESULT
OAUTIL::FreeRecord(
    PVOID pvSrc, 
    ITypeInfo *ptinfo, 
    BOOL fWeOwnByRefs
)
{
    TYPEATTR *ptattr = NULL;
    VARDESC  *pvardesc = NULL;

    HRESULT hr = ptinfo->GetTypeAttr(&ptattr);	
    if (FAILED(hr))
        return hr;

    for (UINT i = 0; i < ptattr->cVars; i++)
    {
        LPBYTE pbSrc;

        hr = ptinfo->GetVarDesc(i, &pvardesc);
        if (FAILED(hr)) goto cleanup;        

        // We just don't care, if this is not PerInstance.
        // PerInstance is the only things we cares about.
        if (pvardesc->varkind != VAR_PERINSTANCE)
        {
            ptinfo->ReleaseVarDesc(pvardesc);
            continue;
        }

        pbSrc = ((BYTE *)pvSrc) + pvardesc->oInst;

        hr = FreeRecordField(pbSrc,
                             &(pvardesc->elemdescVar.tdesc),
                             ptinfo,
                             fWeOwnByRefs);
        if (FAILED(hr)) goto cleanup;

        ptinfo->ReleaseVarDesc(pvardesc);
        pvardesc = NULL;
    }

cleanup:

    if (pvardesc)
        ptinfo->ReleaseVarDesc(pvardesc);
    if (ptattr)
        ptinfo->ReleaseTypeAttr(ptattr);
    
    return hr;
}


HRESULT
OAUTIL::FreeRecord(
    LPVOID pvRecord,
    IRecordInfo *priRecord,
    BOOL fWeOwnByRefs
)
{
    ITypeInfo *ptiRecord = NULL;
    HRESULT hr = priRecord->GetTypeInfo(&ptiRecord);
    if (SUCCEEDED(hr))
    {
        hr = FreeRecord(pvRecord, ptiRecord, fWeOwnByRefs);
        ptiRecord->Release();

        // If fWeOwnByRefs, then we own the memory for this
        // structure.
        if (fWeOwnByRefs)
            CoTaskMemFree(pvRecord);
    }

    return hr;
}

HRESULT 
OAUTIL::WalkRecordField(
    IN LPBYTE       pbSrc,
    IN TYPEDESC    *ptdesc,
    IN ITypeInfo   *ptinfo
)
{
    ITypeInfo *ptiUDT      = NULL;
    TYPEATTR  *ptattrUDT   = NULL;
    HRESULT    hr          = S_OK;
    IID        iid;

    // Same type rules as CopyRecordField.
    if (ptdesc->vt == VT_PTR)
    {
        if (ptdesc->lptdesc->vt != VT_USERDEFINED)
        {
            hr = TYPE_E_UNSUPFORMAT;
            goto cleanup;
        }

        ptdesc = ptdesc->lptdesc;
        hr = ptinfo->GetRefTypeInfo(ptdesc->hreftype, &ptiUDT);
        if (FAILED(hr)) goto cleanup;

        hr = ptiUDT->GetTypeAttr(&ptattrUDT);
        if (FAILED(hr)) goto cleanup;
        
        // Walk through aliases.
        hr = WalkThroughAlias(&ptiUDT, &ptattrUDT);
        if (FAILED(hr)) goto cleanup;

        if ((ptattrUDT->typekind == TKIND_INTERFACE) ||
            (ptattrUDT->typekind == TKIND_DISPATCH))
        {
            // Great, we've got an interface pointer here.
            hr = WalkInterface(ptattrUDT->guid, (void **)pbSrc);
            goto cleanup;
        }
        else
        {
            hr = TYPE_E_UNSUPFORMAT;
            goto cleanup;
        }
    }
    else
    {
        switch(ptdesc->vt)
        {
        case VT_UNKNOWN:
            {
                IUnknown **ppunkSrc = (IUnknown **)pbSrc;
                hr = WalkInterface(ppunkSrc);
            }
            break;
            
        case VT_DISPATCH:
            {
                IDispatch **ppdspSrc = (IDispatch **)pbSrc;
                hr = WalkInterface(ppdspSrc);
            }
            break;
            
        case VT_VARIANT:
            {
                hr = Walk((VARIANT *)pbSrc);
            }
            break;

        case VT_CARRAY:
            {
                ARRAYDESC *parrdesc = ptdesc->lpadesc;
                DWORD cElements = 1;
                ULONG cbElement;

                DWORD i;
                for (i = 0; i < parrdesc->cDims; i++)
                {
                    cElements *= parrdesc->rgbounds[i].cElements;
                }

                hr = SizeOfTYPEDESC(ptinfo, &(parrdesc->tdescElem), &cbElement);
                if (FAILED(hr)) goto cleanup;

                for (i = 0; i < cElements; i++)
                {
                    // Recurse on the array elements.
                    hr = WalkRecordField(pbSrc, &(parrdesc->tdescElem), ptinfo);
                    if (FAILED(hr)) goto cleanup;

                    pbSrc += cbElement;
                }
            }
            break;

        case VT_SAFEARRAY:
            {
                SAFEARRAY **ppsaSrc = (SAFEARRAY **)pbSrc;
                SAFEARRAY *paSrc   = *ppsaSrc;
                hr = Walk(paSrc);
            }
            break;

        case VT_USERDEFINED:
            {
                hr = ptinfo->GetRefTypeInfo(ptdesc->hreftype, &ptiUDT);
                if (FAILED(hr)) goto cleanup;

                hr = ptiUDT->GetTypeAttr(&ptattrUDT);
                if (FAILED(hr)) goto cleanup;

                hr = WalkThroughAlias(&ptiUDT, &ptattrUDT);
                if (FAILED(hr)) goto cleanup;

                if (ptattrUDT->typekind == TKIND_RECORD)
                {
                    // Aha!  Simply recurse on this record.
                    hr = WalkRecord(pbSrc,
                                    ptiUDT);
                    goto cleanup;
                }
                // else fall through...
            }
            // FALL THROUGH!
            
        default:
            break;
        }
    }

cleanup:

    if (ptiUDT)
    {
        if (ptattrUDT)
            ptiUDT->ReleaseTypeAttr(ptattrUDT);
        ptiUDT->Release();
    }

    return hr;
}


HRESULT 
OAUTIL::WalkRecord(
    PVOID pvSrc, 
    ITypeInfo *ptinfo
)
{
    TYPEATTR *ptattr = NULL;
    VARDESC *pvardesc = NULL;


    HRESULT hr = ptinfo->GetTypeAttr(&ptattr);	
    if (FAILED(hr))
        return hr;
    
    // Walk, and copy.
    for (DWORD i = 0; i < ptattr->cVars; i++)
    {        
        hr = ptinfo->GetVarDesc(i, &pvardesc);
        if (FAILED(hr)) goto cleanup;

        // We just don't care, if this is not PerInstance.        
        if (pvardesc->varkind != VAR_PERINSTANCE)
        {
            ptinfo->ReleaseVarDesc(pvardesc);
            continue;
        }

        LPBYTE pbSrc = ((BYTE *)pvSrc) + pvardesc->oInst;

        // Copy the field.
        hr = WalkRecordField(pbSrc, &(pvardesc->elemdescVar.tdesc), ptinfo);
        if (FAILED(hr)) goto cleanup;

        ptinfo->ReleaseVarDesc(pvardesc);
        pvardesc = NULL;
    }

cleanup:

    if (pvardesc != NULL) 
        ptinfo->ReleaseVarDesc(pvardesc);
    
    if (ptattr)
        ptinfo->ReleaseTypeAttr(ptattr);
    
    return hr;
}

HRESULT
OAUTIL::WalkRecord(
    LPVOID pvRecord,
    IRecordInfo *priRecord
)
{
    ITypeInfo *ptiRecord = NULL;
    HRESULT hr = priRecord->GetTypeInfo(&ptiRecord);
    if (SUCCEEDED(hr))
    {
        hr = WalkRecord(pvRecord, ptiRecord);
        ptiRecord->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\sources.inc ===
#
# Sources that build CallFrame{Dll,Sys,Static}.Lib
#

!include ..\..\sources.txf

TARGETPATH=$(TARGETVIPBIN)

PRECOMPILED_INCLUDE         =..\stdpch.h
PRECOMPILED_CXX             =1
PRECOMPILED_SOURCEFILE      =..\stdpch.cpp
VIPPERFLIBS                 =
VIPTHUNKLIBS                =
EXCEPTION_HANDLING          =$(SEHONLY)
VIPER_MIDL_FLAGS            =$(MIDL_EVERYTHING)
PASS0_HEADERDIR             =..
PASS0_SOURCEDIR             =..
MIDL_UUIDDIR                =..

!undef USE_INCREMENTAL_COMPILING

SOURCES=                        \
    ..\Interceptor.cpp          \
    ..\CallFrame.cpp            \
    ..\CallFrameworker.cpp      \
    ..\oautil.cpp               \
	..\records.cpp				\
    ..\cLegInterface.cpp        \
    ..\callframeinternal.c      \
    ..\rpcallas.cpp             \
    ..\typeinfo.cpp             \
    ..\ComPsRegistration.cpp    \
    ..\ComPs.cpp

AMD64_SOURCES=                  \
     ..\amd64\stubless.asm      \
     ..\getsp.cpp

IA64_SOURCES=                   \
    ..\IA64\extract.s


USER_INCLUDES=..;..\inc; 	\
              ..\..;..\..\inc;	\
              ..\..\..;..\..\..\inc;			\
              $(DS_INC_PATH);		\
              $(PROJECT_ROOT)\inc\ndrshared;	\
              ..\idl\$(O);    \
              ..\..\..\..\ih

USER_C_FLAGS = $(USER_C_FLAGS) -DNTENV /DENTRY_PREFIX=CallFrameInternal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\rpcallas.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/*** 
 *rpcallas.cpp
 *
 *  Information Contained Herein Is Proprietary and Confidential.
 *
 *Purpose:
 *  [call_as] wrapper functions for OA interfaces
 *
 *Revision History:
 *
 * [00]  18-Jan-96 Rong Chen    (rongc):  Created
 * [01]  21-Jul-98 Bob Atkinson (bobatk): Stole from Ole Automation tree & adapted
 *
*****************************************************************************/

#include "stdpch.h"
#include "common.h"

#include "ndrclassic.h"
#include "txfrpcproxy.h"
#include "typeinfo.h"
#include "tiutil.h"

#ifndef PLONG_LV_CAST
#define PLONG_LV_CAST        *(long __RPC_FAR * __RPC_FAR *)&
#endif

#ifndef PULONG_LV_CAST
#define PULONG_LV_CAST       *(ulong __RPC_FAR * __RPC_FAR *)&
#endif

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// Marshalling engines for various OLE Automation data types
//
// In user mode, we demand load OleAut32.dll and delegate to the routines
// found therein.
//
// In kernel mode, we have our own implementations, cloned from those found
// in OleAut32.  But this code don't run in kernel mode no more.
//
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ULONG BSTR_UserSize(ULONG * pFlags, ULONG Offset, BSTR * pBstr)
{
    return (g_oa.get_BSTR_UserSize())(pFlags, Offset, pBstr);
}

BYTE * BSTR_UserMarshal (ULONG * pFlags, BYTE * pBuffer, BSTR * pBstr)
{
    return (g_oa.get_BSTR_UserMarshal())(pFlags, pBuffer, pBstr);
}

BYTE * BSTR_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, BSTR * pBstr)
{
    return (g_oa.get_BSTR_UserUnmarshal())(pFlags, pBuffer, pBstr);
}

void  BSTR_UserFree(ULONG * pFlags, BSTR * pBstr)
{
    (g_oa.get_BSTR_UserFree())(pFlags, pBstr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


ULONG VARIANT_UserSize(ULONG * pFlags, ULONG Offset, VARIANT * pVariant)
{
    return (g_oa.get_VARIANT_UserSize())(pFlags, Offset, pVariant);
}

BYTE* VARIANT_UserMarshal (ULONG * pFlags, BYTE * pBuffer, VARIANT * pVariant)
{
    return (g_oa.get_VARIANT_UserMarshal())(pFlags, pBuffer, pVariant);
}

BYTE* VARIANT_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, VARIANT * pVariant)
{
    return (g_oa.get_VARIANT_UserUnmarshal())(pFlags, pBuffer, pVariant);
}

void VARIANT_UserFree(ULONG * pFlags, VARIANT * pVariant)
{
    (g_oa.get_VARIANT_UserFree())(pFlags, pVariant);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ULONG OLEAUTOMATION_FUNCTIONS::SafeArraySize(ULONG * pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray)
{
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;
    if (pUserMarshal->pReserve != 0)
    {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (g_oa.get_pfnLPSAFEARRAY_Size())(pFlags, Offset, ppSafeArray, &iid);
    }
    else
    {
        return (g_oa.get_pfnLPSAFEARRAY_UserSize())(pFlags, Offset, ppSafeArray);
    }
}

BYTE * OLEAUTOMATION_FUNCTIONS::SafeArrayMarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
{
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;
    if(pUserMarshal->pReserve != 0)
    {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (g_oa.get_pfnLPSAFEARRAY_Marshal())(pFlags, pBuffer, ppSafeArray, &iid);
    }
    else
    {
        return (g_oa.get_pfnLPSAFEARRAY_UserMarshal())(pFlags, pBuffer, ppSafeArray);
    }
}

BYTE * OLEAUTOMATION_FUNCTIONS::SafeArrayUnmarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
{
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;
    if(pUserMarshal->pReserve != 0)
    {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (g_oa.get_pfnLPSAFEARRAY_Unmarshal())(pFlags, pBuffer, ppSafeArray, &iid);
    }
    else
    {
        return (g_oa.get_pfnLPSAFEARRAY_UserUnmarshal())(pFlags, pBuffer, ppSafeArray);
    }
}

void LPSAFEARRAY_UserFree(ULONG * pFlags, LPSAFEARRAY * ppSafeArray)
{
    (g_oa.get_LPSAFEARRAY_UserFree())(pFlags, ppSafeArray);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\typeinfo.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
   Microsoft Transaction Server (Microsoft Confidential)

   @doc
   @module typeinfo.Cpp : Provides meta table info for an IID given it's ITypeInfo
   Borrowed from \\kernel\razzle3\src\rpc\ndr20\typeinfo.cxx
   and \\kernel\razzle3\src\rpc\ndr20\tiutil.cxx
 
   Description:<nl>
   Generates -Oi2 proxies and stubs from an ITypeInfo. 
   -------------------------------------------------------------------------------
   Revision History:

   @rev 0     | 04/16/98 | Gaganc  | Created
   @rev 1     | 07/16/98 | BobAtk  | Cleaned, fixed leaks etc
   @ref 2     | 09/28/99 | JohnStra| Updated, made Win64 capable
   ---------------------------------------------------------------------------- */

#include "stdpch.h"
#include "common.h"

#include "ndrclassic.h"
#include "txfrpcproxy.h"
#include "typeinfo.h"
#include "tiutil.h"
#include <alloca.h>

//////////////////////////////////////////////////////////////////////////////
//
// Miscellany
//
//////////////////////////////////////////////////////////////////////////////

void * __stdcall _LocalAlloc (size_t size)
{
    return CoTaskMemAlloc(size);
}

void __stdcall _LocalFree (void * pv)
{
    CoTaskMemFree(pv);
}

//////////////////////////////////////////////////////////////////////////////
//
// Globals 
//
//////////////////////////////////////////////////////////////////////////////

CALLFRAME_CACHE<TYPEINFOVTBL>* g_ptiCache = NULL;
CALLFRAME_CACHE<INTERFACE_HELPER_CLSID>* g_pihCache = NULL;

BOOL InitTypeInfoCache()
{
    __try
    {
        // NOTE: The constructors here can throw exceptions because they
        //       contains an XSLOCK. (See concurrent.h)  When this happens,
        //       block the DLL load.
        g_ptiCache = new CALLFRAME_CACHE<TYPEINFOVTBL>();
        g_pihCache = new CALLFRAME_CACHE<INTERFACE_HELPER_CLSID>();
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        g_ptiCache = NULL;
        g_pihCache = NULL;
        
        return FALSE;
    }

    if(g_ptiCache != NULL && g_pihCache != NULL)
    {

        if (g_ptiCache->FInit() == FALSE)
        {
            delete g_ptiCache;
            g_ptiCache = NULL;
        }

        if (g_pihCache->FInit() == FALSE)
        {
            delete g_pihCache;
            g_pihCache = NULL;
        }
    }
    
    if (NULL == g_ptiCache || NULL == g_pihCache)
    {

        if (g_ptiCache)
        {
            delete g_ptiCache;
            g_ptiCache = NULL;
        }
            
        if (g_pihCache)
        {
            delete g_pihCache;
            g_pihCache = NULL;
        }
    
        return FALSE;
    }

    return TRUE;
}

void FreeTypeInfoCache()
{
    if (g_ptiCache)
    {
        g_ptiCache->Shutdown();
        delete g_ptiCache;
        g_ptiCache = NULL;
    }

    if (g_pihCache)
    {
        g_pihCache->Shutdown();
        delete g_pihCache;
        g_pihCache = NULL;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// Utilities
//
//////////////////////////////////////////////////////////////////////////////

HRESULT GetBaseInterfaceIID(ITypeInfo* ptinfo, IID* piidBase, ITypeInfo** ppBaseTypeInfo)
  // Return the IID of the interface from which this typeinfo inherits, if any
{
    HRESULT hr = S_OK;
    *piidBase = GUID_NULL;
    *ppBaseTypeInfo = NULL;

    TYPEATTR* pattr;
    hr = ptinfo->GetTypeAttr(&pattr);
    if (!hr)
    {
        if (pattr->cImplTypes == 1)
        {
            // It inherits from something
            //
            HREFTYPE href;
            hr = ptinfo->GetRefTypeOfImplType(0, &href);
            if (!hr)
            {
                ITypeInfo* ptinfoBase;
                hr = ptinfo->GetRefTypeInfo(href, &ptinfoBase);
                if (!hr)
                {
                    TYPEATTR* pattrBase;
                    hr = ptinfoBase->GetTypeAttr(&pattrBase);
                    if (!hr)
                    {
                        //
                        *piidBase = pattrBase->guid;
                        //
                        ptinfoBase->ReleaseTypeAttr(pattrBase);
                    }

                    // Pass the base typeinfo back
                    *ppBaseTypeInfo = ptinfoBase;
                }
            }
        }
        ptinfo->ReleaseTypeAttr(pattr);
    }

    return hr;
}



HRESULT CheckTypeInfo(ITypeInfo *pTypeInfo, ITypeInfo **pptinfoProxy, ITypeInfo** pptinfoDoc, USHORT *pcMethods, BOOL *pfDerivesFromExternal, IID* piidBase, ITypeInfo** ppBaseTypeInfo)
  // Check the indicated typeinfo and determine some basic information about it
{
    HRESULT    hr = S_OK;
    TYPEATTR*    pTypeAttr;
    HREFTYPE     hRefType;
    UINT         cbSizeVft = 0;
    ITypeInfo*   ptinfoProxy = NULL;
    ITypeInfo*   ptinfoDoc   = NULL;
    USHORT       cMethods;

    *pfDerivesFromExternal = FALSE;
    *piidBase = __uuidof(IUnknown);
    *ppBaseTypeInfo = NULL;

    hr = pTypeInfo->GetTypeAttr(&pTypeAttr);

    if (!hr)
    {
        if (pTypeAttr->wTypeFlags & TYPEFLAG_FDUAL)
        {
            // A dual interface. By definition it is OA compatible
            //
            *pfDerivesFromExternal = TRUE;

            if (TKIND_DISPATCH == pTypeAttr->typekind)
            {
                // Get the TKIND_INTERFACE type info
                //
                hr = pTypeInfo->GetRefTypeOfImplType((UINT) -1, &hRefType);
                if (!hr)
                {
                    hr = pTypeInfo->GetRefTypeInfo(hRefType, &ptinfoProxy);
                    if (!hr)
                    {
                        TYPEATTR * ptattrProxy;
                        hr = ptinfoProxy->GetTypeAttr(&ptattrProxy);
                        if (!hr)
                        {
                            ASSERT((TKIND_INTERFACE == ptattrProxy->typekind) && "disp interface has associated non-dual interface with bogus type kind");
                            //
                            cbSizeVft = ptattrProxy->cbSizeVft;
                            //
                            ptinfoProxy->ReleaseTypeAttr(ptattrProxy);
                        }
                    }
                }
            }
            else if (TKIND_INTERFACE == pTypeAttr->typekind)
            {
                pTypeInfo->AddRef();
                ptinfoProxy = pTypeInfo;
                cbSizeVft = pTypeAttr->cbSizeVft;
            }
            else
            {
                hr = E_FAIL;
            }

            if (!hr) hr = GetBaseInterfaceIID(ptinfoProxy, piidBase, ppBaseTypeInfo);
            if (!hr)
            {
                ptinfoDoc = ptinfoProxy;
                ptinfoDoc->AddRef();
            }
        }
        else if (TKIND_INTERFACE == pTypeAttr->typekind)
        {
            // A non-dual interface
            //
            ptinfoProxy = pTypeInfo;
            ptinfoProxy->AddRef();
            cbSizeVft = pTypeAttr->cbSizeVft;
            //
            if (!hr) hr = GetBaseInterfaceIID(ptinfoProxy, piidBase, ppBaseTypeInfo);
            if (!hr)
            {
                ptinfoDoc = ptinfoProxy;
                ptinfoDoc->AddRef();
            }
        }
        else if (TKIND_DISPATCH == pTypeAttr->typekind)
        {
            // A non-dual disp interface
            //
            // Get the typeinfo of the base interface, which should be IDispatch. Note that dispinterfaces
            // are not (for some strange reason) allowed to inherit from each other, so we don't have to loop.
            //
            ASSERT(pTypeAttr->cImplTypes >= 1);

            HREFTYPE hrefBase;
            hr = pTypeInfo->GetRefTypeOfImplType(0, &hrefBase);
            if (!hr)
            {
                ITypeInfo* ptinfoBase;
                hr = pTypeInfo->GetRefTypeInfo(hrefBase, &ptinfoBase);
                if (!hr)
                {
                    TYPEATTR* pTypeAttrBase;
                    hr = ptinfoBase->GetTypeAttr(&pTypeAttrBase);
                    if (!hr)
                    {
                        ASSERT(pTypeAttrBase->guid      == __uuidof(IDispatch));
                        ASSERT(pTypeAttrBase->typekind  == TKIND_INTERFACE);
                        //
                        *piidBase          = pTypeAttrBase->guid;
                        ptinfoProxy        = ptinfoBase;    ptinfoProxy->AddRef();
                        ptinfoDoc          = pTypeInfo;     ptinfoDoc->AddRef();
                        cbSizeVft          = pTypeAttrBase->cbSizeVft;
                        *pfDerivesFromExternal = TRUE;
                        //
                        ptinfoBase->ReleaseTypeAttr(pTypeAttrBase);
                    }

                    // Pass the base interface back.
                    *ppBaseTypeInfo = ptinfoBase;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
        pTypeInfo->ReleaseTypeAttr(pTypeAttr);
    }

    cMethods = (USHORT) (cbSizeVft - VTABLE_BASE) / sizeof(void *);

    if (!hr && *pfDerivesFromExternal)
    {
        ASSERT(cMethods >= 7 && "A derived-from-dispatch interface should have at least as many methods as does IDispatch");
    }

    if (cMethods > 1024)
    {
        hr = RPC_E_INVALIDMETHOD; // There are too many methods in the vtable.
    }

    if (!hr)
    {
        *pptinfoProxy = ptinfoProxy;
        *pptinfoDoc   = ptinfoDoc;
        *pcMethods    = cMethods;
    }
    else
    {
        *pptinfoProxy = NULL;
        *pptinfoDoc   = NULL;
        *pcMethods    = 0;
        ::Release(ptinfoProxy);
    }    

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// If you have any problems with the functions below, it may be instructive
// to look at how RPC does it.  We can't use their code directly, but much of
// this code is based on theirs.
//
///////////////////////////////////////////////////////////////////////////////


BOOL FIsLCID(LPWSTR wszLcid)
  // Is the given string a valid stringized LCID?
{
    LPWSTR wszEnd;
    LCID lcid = (LCID)wcstoul(wszLcid, &wszEnd, 16);
    //
    // if converting to LCID consumed all characters..
    //
    if (*wszEnd == 0)
    {
        // and its a number the system claims to know about...
        //
        char rgch[32];
        if (GetLocaleInfoA(lcid, LOCALE_NOUSEROVERRIDE | LOCALE_ILANGUAGE, rgch, sizeof(rgch)) > 0)
        {
            // then assume its a valid stringized LCID
            //
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT SzLibIdOfIID(HREG hregTlb, GUID* plibid, WORD* pwMaj, WORD* pwMin, BOOL *pfHasVersion)
{
    HRESULT hr = S_OK;
    //
    // Default value of the TypeLib key is the string form of the LIBID
    //
    PKEY_VALUE_FULL_INFORMATION pinfo = NULL;
    if (!hr)
    {
        hr = GetRegistryValue(hregTlb, L"", &pinfo, REG_SZ);
        Win4Assert(pinfo || FAILED(hr));
        if (!hr && pinfo)
        {
            hr = GuidFromString(StringFromRegInfo(pinfo), plibid);
            CoTaskMemFree(pinfo);
            pinfo = NULL;
        }
    }
    if (!hr)
    {
        *pfHasVersion = FALSE;
        pinfo = NULL;
        hr = GetRegistryValue(hregTlb, L"Version", &pinfo, REG_SZ);
        Win4Assert(pinfo || FAILED(hr));
        if (!hr && pinfo)
        {
            LPWSTR wszVer = StringFromRegInfo(pinfo);
            LPWSTR wszEnd;
            WORD wMaj = (WORD)wcstoul(wszVer, &wszEnd, 16);
            if (*wszEnd == '.') 
            {
                *pwMaj = wMaj;
                *pwMin = (WORD)wcstoul(wszEnd+1, NULL, 16);
                *pfHasVersion = TRUE;
            }
            CoTaskMemFree(pinfo);
        }
        else
            hr = S_OK;
    }

    return hr;
}

HRESULT GetTypeInfoFromIID (REFIID iidIntercepted, ITypeInfo** pptypeinfo)
  // Find and return the typeinfo for the indicated IID
  //
{
    HRESULT hr = S_OK;
    *pptypeinfo = NULL;

    WCHAR wszKey[MAX_PATH];

    WCHAR wsziid[50];
    StringFromGuid(iidIntercepted, wsziid);
    //
    // Is there a forward entry for this interface?
    //
    BOOL fFound = FALSE;
    HREG hregForward;
    wsprintfW(wszKey, L"\\Registry\\Machine\\Software\\Classes\\Interface\\%s\\Forward", wsziid);
    hr = OpenRegistryKey(&hregForward, HREG(), wszKey);
    if (!hr)
    {
        PKEY_VALUE_FULL_INFORMATION pinfo = NULL;
        hr = GetRegistryValue(hregForward, L"", &pinfo, REG_SZ);
        Win4Assert(pinfo || FAILED(hr));
        if (!hr && pinfo)
        {
            LPWSTR wsz = StringFromRegInfo(pinfo);
            IID iidNew;
            hr = GuidFromString(wsz, &iidNew);
            if (!hr)
            {
                // Recurse on the new entry
                //
                hr = GetTypeInfoFromIID(iidNew, pptypeinfo);
                if (!hr)
                {
                    fFound = TRUE;
                }
            }
            CoTaskMemFree(pinfo);
        }
        CloseRegistryKey(hregForward);
    }
    //
    if (!fFound)
    {
        hr = S_OK;
        //
        // Didn't find it through a forward entry. Find the LibId (and possibly the version #) of 
        // TypeLib containing the definition of the given IID
        //
        wsprintfW(wszKey, L"\\Registry\\Machine\\Software\\Classes\\Interface\\%s\\TypeLib", wsziid);
        HREG hregTlbId;
        hr = OpenRegistryKey(&hregTlbId, HREG(), wszKey);
        if (!hr)
        {
            GUID libId;
            WORD wMajBest, wMinBest;
            WCHAR wszBest[MAX_PATH];
            BOOL fHasVersion;
            //
            // Get the version of the tlb that we seek.
            //
            wMajBest = wMinBest = 0;
            hr = SzLibIdOfIID(hregTlbId, &libId, &wMajBest, &wMinBest, &fHasVersion);
            if (!hr)
            {
                WCHAR wszLibId[39];
                StringFromGuid(libId, &wszLibId[0]);
                //
                // Open the key of the typelib itself
                //
                HREG hregTlb;
                wsprintfW(wszKey, L"\\Registry\\Machine\\Software\\Classes\\TypeLib\\%s", wszLibId);
                hr = OpenRegistryKey(&hregTlb, HREG(), wszKey);
                if (!hr)
                {
                    // Enumerate children of tlb key, looking for the largest sufficient entry
                    //
                    ULONG index = 0;
                    BOOL fStop = FALSE;
                    wszBest[0] = 0;
                    while (!hr && !fStop)
                    {
                        LPWSTR wszSubKey;
                        hr = EnumerateRegistryKeys(hregTlb, index, &wszSubKey);
                        if (!hr)
                        {
                            if (wszSubKey)
                            {
                                LPWSTR wszEnd;
                                WORD wMaj = (WORD)wcstoul(wszSubKey, &wszEnd, 16);
                                if (*wszEnd == '.') 
                                {
                                    WORD wMin = (WORD)wcstoul(wszEnd+1, NULL, 16);
                                    //
                                    // If the typelib's iid had a version # associated with it, then we
                                    // want to find the typelib with the same major version #, and a
                                    // minor version # >= the registered one.
                                    // If no version # was specified, then we just try the biggest version
                                    // # we can find, and hope for the best.
                                    //
                                    if ((!fHasVersion && wMaj > wMajBest) || (wMaj == wMajBest && wMin >= wMinBest))
                                    {
                                        wMajBest = wMaj;
                                        wMinBest = wMin;
                                        wcscpy(wszBest, wszSubKey);
                                    }
                                }
                                CoTaskMemFree(wszSubKey);
                            }
                            else
                            {
                                fStop = TRUE; // No more entries
                            }
                        }
                        index++;
                    }
                    
                    if (!hr)
                    {
                        // Open the version we found
                        //
                        HREG hregVersion;
                        hr = OpenRegistryKey(&hregVersion, hregTlb, wszBest);
                        if (!hr)
                        {
                            // Grab the first language subkey under the version.
                            // Need to possibly skip over FLAGS and HELPDIR subkeys
                            //
                            ULONG index = 0;
                            BOOL fStop = FALSE;
                            while (!hr && !fStop)
                            {
                                LPWSTR wszSubKey;
                                hr = EnumerateRegistryKeys(hregVersion, index, &wszSubKey);
                                if (!hr)
                                {
                                    if (wszSubKey)
                                    {
                                        if (FIsLCID(wszSubKey))
                                        {
                                            fStop = TRUE;
                                            //
                                            HREG hregLang;
                                            hr = OpenRegistryKey(&hregLang, hregVersion, wszSubKey);
                                            if (!hr)
                                            {
                                                // First attempt to find the current platform's typelib. If that
                                                // doesn't work, then grab the first platform subkey under the language.
                                                //
                                                HREG hregPlatform;
                                                hr = OpenRegistryKey(&hregPlatform, hregLang, L"win32");
                                                if (!!hr)
                                                {
                                                    LPWSTR wszPlatform;
                                                    hr = EnumerateRegistryKeys(hregLang, 0, &wszPlatform);
                                                    if (!hr)
                                                    {
                                                        if (wszPlatform)
                                                        {
                                                            hr = OpenRegistryKey(&hregPlatform, hregLang, wszPlatform);
                                                            CoTaskMemFree(wszPlatform);
                                                        }
                                                        else
                                                            hr = TYPE_E_LIBNOTREGISTERED;
                                                    }
                                                }
                                                if (!hr)
                                                {
                                                    // The value of the platform key is the path to the typelib!
                                                    //
                                                    PKEY_VALUE_FULL_INFORMATION pinfo;
                                                    hr = GetRegistryValue(hregPlatform, L"", &pinfo, REG_SZ);
                                                    if (!hr)
                                                    {
                                                        LPWSTR wszPath = StringFromRegInfo(pinfo);
                                                        //
                                                        //
                                                        //
                                                        ITypeLib* ptlb;
                                                        hr = LoadTypeLibEx(wszPath, REGKIND_NONE, &ptlb);
                                                        if (!hr)    
                                                        {
                                                            hr = ptlb->GetTypeInfoOfGuid(iidIntercepted, pptypeinfo);
                                                            ::Release(ptlb);
                                                        }
                                                        //
                                                        //
                                                        //
                                                        CoTaskMemFree(pinfo);
                                                    }
                                                    CloseRegistryKey(hregPlatform);
                                                }
                                                CloseRegistryKey(hregLang);
                                            }
                                        }
                                        CoTaskMemFree(wszSubKey);
                                    }
                                    else
                                    {
                                        fStop = TRUE; // No more entries
                                        hr = TYPE_E_LIBNOTREGISTERED;
                                    }
                                }
                                index++;
                            }
                            CloseRegistryKey(hregVersion);
                        }
                    }
                    CloseRegistryKey(hregTlb);
                }
            }
            CloseRegistryKey(hregTlbId);
        }
    }
    
    return hr;
} //end GetTypeInfoFromIID


HRESULT GetVtbl(IN ITypeInfo* pTypeInfo, IN REFIID riid, OUT TYPEINFOVTBL ** ppvtbl, OUT ITypeInfo** ppBaseTypeInfo)
  // Find or create a TYPEINFOVTBL for the given typeinfo, and return a new refcnt thereon.
  // 
{
    HRESULT    hr = S_OK;
    USHORT       numMethods;
    MethodInfo * aMethodInfo = NULL;
    BOOL         fDerivesFromExternal = FALSE;
    ITypeInfo  * ptinfoProxy = NULL;
    ITypeInfo  * ptinfoDoc   = NULL;
    BOOL         bWeGotTypeInfo = FALSE;

    *ppvtbl = NULL;
    *ppBaseTypeInfo = NULL;

    // Check the cache.
    //
    HRESULT hr2 = g_ptiCache->FindExisting(riid, ppvtbl);
    if (!hr2)
    {
        // Found it in the cache
    }
    else
    {
    
        //
        // Find the typeinfo for the requested interface
        //
        if (!pTypeInfo)
        {
            bWeGotTypeInfo = TRUE;
            hr = GetTypeInfoFromIID (riid, &pTypeInfo);
        }

        if (!hr)
        {    
            // We didn't find the interface in the cache.
            // Create a vtbl from the ITypeInfo.
            //
            IID iidBase = IID_NULL;
            //
            hr = CheckTypeInfo(pTypeInfo, &ptinfoProxy, &ptinfoDoc, &numMethods, &fDerivesFromExternal, &iidBase, ppBaseTypeInfo);
            if (!hr)
            {
                // Get the per-method data
                //
                SafeAllocaAllocate(aMethodInfo, numMethods * sizeof(MethodInfo));
                if (aMethodInfo == NULL)
                    hr = E_OUTOFMEMORY;

                if (!hr)
                {
                    ZeroMemory(aMethodInfo, numMethods * sizeof(MethodInfo));
                    hr = GetFuncDescs(ptinfoProxy, aMethodInfo);
                    if (!hr)
                    {
                        // Got the per-method data. Make a new vtable.
                        //
                        TYPEINFOVTBL* pvtbl;
                        hr = CreateVtblFromTypeInfo(ptinfoProxy, ptinfoDoc, riid, iidBase, fDerivesFromExternal, numMethods, aMethodInfo, &pvtbl);
                        if (!hr)
                        {
                            // Try to remember the vtable in the cache. But first we have to check
                            // that we aren't going to create a duplicate because of a race.
                            //
                            g_ptiCache->LockExclusive();

                            HRESULT hr3 = g_ptiCache->FindExisting(riid, ppvtbl);
                            if (!hr3)
                            {
                                // Someone else won the race. Release what we've built so far
                                // and return on out of here.
                            }
                            else
                            {
                                // Still not there, so register the one we've got
                                //
                                hr = pvtbl->AddToCache (g_ptiCache);                                
                                if (!hr)
                                {
                                    // Give caller back his reference
                                    //
                                    *ppvtbl = pvtbl;
                                    pvtbl->AddRef();
                                }
                            }

                            g_ptiCache->ReleaseLock();
                            pvtbl->Release();
                        }
                    }
                    ReleaseFuncDescs(numMethods, aMethodInfo);
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }

        if (bWeGotTypeInfo)
        {
            ::Release(pTypeInfo);
        }
    }

    SafeAllocaFree(aMethodInfo);

    ::Release(ptinfoDoc);
    ::Release(ptinfoProxy);

    return hr;
}

HRESULT CreateVtblFromTypeInfo(
    ITypeInfo* ptinfoInterface, 
    ITypeInfo*ptinfoDoc, 
    REFIID riid, 
    REFIID riidBase, 
    BOOL fDerivesFromExternal, 
    USHORT numMethods, 
    MethodInfo* rgMethodInfo, 
    TYPEINFOVTBL** ppvtbl)
  // Create a vtable structure from type information. Return to caller
  // a new refcnt on the the (new) TYPEINFOVTBL structure.
  //
{
    HRESULT             hr                          = S_OK;
    USHORT              iMethod;
    ULONG               cbVtbl;
    ULONG               cbOffsetTable;
    USHORT              cbProcFormatString          = 0;
    ULONG               cbSize;
    TYPEINFOVTBL *      pInfo;
    byte *              pTemp;
    PFORMAT_STRING      pTypeFormatString           = NULL;
    PFORMAT_STRING      pProcFormatString;
    unsigned short *    pFormatStringOffsetTable;
    void *              pvTypeGenCookie             = NULL;
    USHORT              cbFormat;
    USHORT              offset                      = 0;
    ULONG               cbDelegationTable;
    void **             pDispatchTable              = NULL;

    //-------------------------------------------------------------------------

    *ppvtbl = NULL;

    //-------------------------------------------------------------------------
    //
    // Compute the total size of the TYPEINFOVTBL structure
    //
    // Compute the size of the vtbl structure;
    //
    cbVtbl = numMethods * sizeof(void *);

    if (fDerivesFromExternal)
    {
        cbDelegationTable = cbVtbl;
    }
    else
    {
        cbDelegationTable = 0;
    }

    cbOffsetTable = numMethods * sizeof(USHORT);
    //
    // Compute the size of the proc format string.
    //
    for (iMethod = 3; iMethod < numMethods; iMethod++)
    {
        if (rgMethodInfo[iMethod].pFuncDesc != NULL)
        {
            cbProcFormatString += 22;
#ifdef _WIN64
            cbProcFormatString += sizeof(NDR_PROC_HEADER_EXTS64);
#endif            
            cbProcFormatString += rgMethodInfo[iMethod].pFuncDesc->cParams * 6;
        }
    }

    cbSize = cbVtbl + cbDelegationTable + cbOffsetTable + cbProcFormatString;
    //
    // Allocate and initialize the structure
    //                                        
    pInfo = new(cbSize) TYPEINFOVTBL;
    if (pInfo)
    {
        //
        // Determine the start of the dispatch table in the total allocated space
        //
        pTemp = (byte *) pInfo->m_proxyVtbl.Vtbl + cbVtbl;

        if (cbDelegationTable != 0)
        {
            pDispatchTable = (void **) pTemp;
            pInfo->m_stubVtbl.header.pDispatchTable = (const PRPC_STUB_FUNCTION *) pDispatchTable;
            pTemp += cbDelegationTable;
        }
        //
        // determine the start of the format string offset
        //
        pFormatStringOffsetTable = (unsigned short *) pTemp;
        pTemp += cbOffsetTable;
        //
        // determine the start of the ProcFormatString
        //
        pProcFormatString = (PFORMAT_STRING) pTemp;
        //
        // Initialize the proxyvtbl
        //
        // Since this only exists to provide metadata for interceptors, we do not fill in valid
        // function pointers for the m_proxyVtbl.Vtbl.  Ever.
        //
        pInfo->m_proxyVtbl.Vtbl[0] = NULL; //N(ComPs_IUnknown_QueryInterface_Proxy);
        pInfo->m_proxyVtbl.Vtbl[1] = NULL; //N(ComPs_IUnknown_AddRef_Proxy);
        pInfo->m_proxyVtbl.Vtbl[2] = NULL; //N(ComPs_IUnknown_Release_Proxy);
        //
        // Get the format strings. Generate -Oi2 proc format string from the ITypeInfo.
        //
        hr = NdrpGetTypeGenCookie(&pvTypeGenCookie);

        for (iMethod = 3; !hr && iMethod < numMethods; iMethod++)
        {
            if (rgMethodInfo[iMethod].pFuncDesc != NULL)
            {
                pFormatStringOffsetTable[iMethod] = offset;
                hr = NdrpGetProcFormatString(pvTypeGenCookie, 
                                             rgMethodInfo[iMethod].pTypeInfo, 
                                             rgMethodInfo[iMethod].pFuncDesc, 
                                             iMethod, 
                                             (PFORMAT_STRING)pTemp, 
                                             &cbFormat);
                if (!hr)
                {
                    pTemp += cbFormat;
                    offset = offset + (USHORT) cbFormat;

                    // Stubless client function.
                    // See the above comment about 'not filling in function pointers'.
                    pInfo->m_proxyVtbl.Vtbl[iMethod] = NULL;

                    if (pDispatchTable != NULL)
                    {
                        // Interpreted server function.
                        // See the above comment about 'not filling in function pointers'.
                        pDispatchTable[iMethod] = NULL;
                    }
                }
            }
            else
            {
                pFormatStringOffsetTable[iMethod] = (USHORT) -1;

                // Proxy delegation forwarding function.
                // See the above comment about 'not filling in function pointers'.
                pInfo->m_proxyVtbl.Vtbl[iMethod] = NULL; 

                if (pDispatchTable != NULL)
                {
                    // Stub delegation forwarding function.
                    // See the above comment about 'not filling in function pointers'.
                    pDispatchTable[iMethod] = NULL;
                }
            }
        }

        if (!hr)
        {
            // Get type format string and initialize the TYPEINFOVTBL
            //
            USHORT length;
            hr = NdrpGetTypeFormatString(pvTypeGenCookie, 
                                         &pTypeFormatString, 
                                         &length);
            
            if (!hr)
            {
                //---------------------------------------------------------------------
                // Initialize the iid.
                pInfo->m_guidkey = riid;
                pInfo->m_iidBase = riidBase;

                // Initialize the MIDL_STUB_DESC.
                pInfo->m_stubDesc.pfnAllocate     = _LocalAlloc;
                pInfo->m_stubDesc.pfnFree         = _LocalFree;
                pInfo->m_stubDesc.pFormatTypes    = pTypeFormatString;
#if !defined(_WIN64)                
                pInfo->m_stubDesc.Version         = 0x20000;      // Ndr library version 
#else
                pInfo->m_stubDesc.Version         = 0x50002;      // Ndr library version 
#endif
                pInfo->m_stubDesc.MIDLVersion     = MIDLVERSION;
                pInfo->m_stubDesc.aUserMarshalQuadruple = g_oa.get_UserMarshalRoutines();

                // Initialize the MIDL_SERVER_INFO.
                pInfo->m_stubInfo.pStubDesc       = &pInfo->m_stubDesc;
                pInfo->m_stubInfo.ProcString      = pProcFormatString;
                pInfo->m_stubInfo.FmtStringOffset = pFormatStringOffsetTable;

                // Initialize the stub vtbl.
                pInfo->m_stubVtbl.header.piid                 = &pInfo->m_guidkey;
                pInfo->m_stubVtbl.header.pServerInfo          = &pInfo->m_stubInfo;
                pInfo->m_stubVtbl.header.DispatchTableCount   = numMethods;

                // Initialize stub methods.
                ZeroMemory(&pInfo->m_stubVtbl.Vtbl, sizeof(pInfo->m_stubVtbl.Vtbl));

                // Initialize the proxy info.
                pInfo->m_proxyInfo.pStubDesc          = &pInfo->m_stubDesc;
                pInfo->m_proxyInfo.ProcFormatString   = pProcFormatString;
                pInfo->m_proxyInfo.FormatStringOffset = pFormatStringOffsetTable;

                // Initialize the proxy vtbl.
                pInfo->m_proxyVtbl.header.pStublessProxyInfo  = &pInfo->m_proxyInfo;
                pInfo->m_proxyVtbl.header.piid                = &pInfo->m_guidkey;
            }
        }

        if (!hr)
        {
            // Dig out the name of the interface
            //
            BSTR bstrInterfaceName;
            hr = ptinfoDoc->GetDocumentation(MEMBERID_NIL, &bstrInterfaceName, NULL, NULL, NULL);
            if (!hr)
            {
                // Convert to ANSI in order to store. Memory version is ANSI instead of Unicode 'cause
                // MIDL-generated interceptors emit ANSI names (see pProxyFileInfo->pNamesArray) as 
                // const data, and it doesn't seem worthwhile doing another alloc for those just to
                // fix that.
                //
                pInfo->m_szInterfaceName = ToUtf8(bstrInterfaceName);
                if (pInfo->m_szInterfaceName)   
                {
                    // all is swell
                }
                else
                    hr = E_OUTOFMEMORY;
                //
                SysFreeString(bstrInterfaceName);
            }
        }

        if (!hr)
        {
            // Initialize the method descriptors
            //
            ULONG cb = numMethods * sizeof pInfo->m_rgMethodDescs[0];
            pInfo->m_rgMethodDescs = (METHOD_DESCRIPTOR*)CoTaskMemAlloc(cb);
            if (pInfo->m_rgMethodDescs)
            {
                ZeroMemory(pInfo->m_rgMethodDescs, cb);
            }
            else
                hr = E_OUTOFMEMORY;

            for (iMethod = 3; !hr && iMethod < numMethods; iMethod++)
            {
                FUNCDESC* pFuncDesc     = rgMethodInfo[iMethod].pFuncDesc;
                ITypeInfo *ptinfoMethod = rgMethodInfo[iMethod].pTypeInfo;
                if (pFuncDesc != NULL)
                {
                    // Find out the method name and remember it
                    //
                    METHOD_DESCRIPTOR& methodDesc = pInfo->m_rgMethodDescs[iMethod];
                    BSTR bstrMethodName;
                    unsigned int cNames;
                    hr = rgMethodInfo[iMethod].pTypeInfo->GetNames(rgMethodInfo[iMethod].pFuncDesc->memid, &bstrMethodName, 1, &cNames);
                    if (!hr)
                    {
                        methodDesc.m_szMethodName = CopyString(bstrMethodName);
                        if (NULL == methodDesc.m_szMethodName)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        SysFreeString(bstrMethodName);
                    }

                    if (!hr)
                    {
                        methodDesc.m_cParams = pFuncDesc->cParams;
                        if (methodDesc.m_cParams != 0)
                        {
                            methodDesc.m_paramVTs = (VARTYPE*)CoTaskMemAlloc(methodDesc.m_cParams * sizeof(VARTYPE));
                            if (methodDesc.m_paramVTs)
                            {
                                for (short iParam = 0; iParam < methodDesc.m_cParams; ++iParam)                             
                                {
                                    VARTYPE vt;
                                    
                                    hr = NdrpVarVtOfTypeDesc(ptinfoMethod, 
                                                             &pFuncDesc->lprgelemdescParam[iParam].tdesc, 
                                                             &vt);
                                    
                                    if (!hr)
                                        methodDesc.m_paramVTs[iParam] = vt;
                                }
                            }
                            else
                                hr = E_OUTOFMEMORY;
                        }
                    }
                }
            }
        }

        if (!hr)
        {
            // Return a ref on the object to our caller
            *ppvtbl = pInfo;
            pInfo->AddRef();
        }

        pInfo->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    if (pvTypeGenCookie)
        NdrpReleaseTypeGenCookie(pvTypeGenCookie);

    return hr;
} //end CreateVtblFromTypeInfo




HRESULT GetFuncDescs(IN ITypeInfo *pTypeInfo, OUT MethodInfo *pMethodInfo)
  // Get the FUNCDESCs of each method in the TypeInfo
  //
{
    HRESULT hr = S_OK;
    TYPEATTR *pTypeAttr;

    hr = pTypeInfo->GetTypeAttr(&pTypeAttr);

    if (!hr)
    {
        if (IID_IUnknown == pTypeAttr->guid)
        {
            hr = S_OK;
        }
        else if (IID_IDispatch == pTypeAttr->guid)
        {
            hr = S_OK;
        }
        else
        {
            // This is an oleautomation interface.
            //
            ULONG i, iMethod;
            FUNCDESC *pFuncDesc;

            if (pTypeAttr->cImplTypes)
            {
                // Recursively get the inherited member functions. The recursion
                // will fill in a prefix of the MethodInfo array.
                //
                HREFTYPE hRefType;
                hr = pTypeInfo->GetRefTypeOfImplType(0, &hRefType);
                if (!hr)
                {
                    ITypeInfo *pRefTypeInfo;
                    hr = pTypeInfo->GetRefTypeInfo(hRefType, &pRefTypeInfo);
                    if (!hr)
                    {
                        hr = GetFuncDescs(pRefTypeInfo, pMethodInfo);
                        ::Release(pRefTypeInfo);
                    }
                }
            }

            // Get the member functions.
            //
            for(i = 0; !hr && i < pTypeAttr->cFuncs; i++)
            {
                hr = pTypeInfo->GetFuncDesc(i, &pFuncDesc);
                if (!hr)
                {
                    iMethod = (pFuncDesc->oVft - VTABLE_BASE) / sizeof(PVOID);
                    pMethodInfo[iMethod].pFuncDesc = pFuncDesc;
                    pMethodInfo[iMethod].pTypeInfo = pTypeInfo;
                    pTypeInfo->AddRef();
                }
            }
        }

        pTypeInfo->ReleaseTypeAttr(pTypeAttr);
    }

    return hr;
}


HRESULT ReleaseFuncDescs(USHORT numMethods, MethodInfo *pMethodInfo)
{
    USHORT iMethod;
    //
    // Release the funcdescs.
    //
    if (pMethodInfo != NULL)
    {
        for(iMethod = 0;
            iMethod < numMethods;
            iMethod++)
        {
            pMethodInfo[iMethod].Destroy();
        }
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\inc\ndrclassic.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// ndrclassic.h
//
#ifndef __NDRCLASSIC_H__
#define __NDRCLASSIC_H__

#define NDR_SERVER_SUPPORT
#define NDR_IMPORT_NDRP

#define IGNORED(x)                          
#define RpcRaiseException(dw)               Throw(dw)

////////////////////////////////////////////////////////////////////////////////////////////
//
// Inline routines. Here for visibility to all necessary clients
//
////////////////////////////////////////////////////////////////////////////////////////////

__inline void
NdrClientZeroOut(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar *             pArg
)
{
    long    Size;

    //
    // In an object proc, we must zero all [out] unique and interface
    // pointers which occur as the referent of a ref pointer or embedded in a
    // structure or union.
    //

    // Let's not die on a null ref pointer.

    if ( !pArg )
        return;

    //
    // The only top level [out] type allowed is a ref pointer or an array.
    //
    if ( *pFormat == FC_RP )
    {
        // Double pointer.
        if ( POINTER_DEREF(pFormat[1]) )
        {
            *((void **)pArg) = 0;
            return;
        }

        // Do we really need to zero out the basetype?
        if ( SIMPLE_POINTER(pFormat[1]) )
        {
            MIDL_memset( pArg, 0, (uint) SIMPLE_TYPE_MEMSIZE(pFormat[2]) );
            return;
        }

        // Pointer to struct, union, or array.
        pFormat += 2;
        pFormat += *((short *)pFormat);
    }

    Size = PtrToUlong(NdrpMemoryIncrement( pStubMsg,
                                           0,
                                           pFormat ));
    MIDL_memset( pArg, 0, (uint) Size );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\amd64\stubless.asm ===
title   "Stubless Support"
;++
;
; Copyright (C) 2001  Microsoft Corporation
;
; Module Name:
;
;   stubless.asm
;
; Abstract:
;
;   This module contain the routine neceeary to invoke a function with a
;   given parameter list.
;
; Author:
;
;   David N. Cutler 26-Jan-2001
;
; Environment:
;
;   User mode.
;
;--

include ksamd64.inc

        extern  __chkstk:proc

        subttl  "Invoke Function with Parameter List"
;++
;
; REGISTER_TYPE
; Invoke (
;     MANAGER_FUNCTION Function,
;     REGISTER_TYPE *ArgumentList,
;     ULONG Arguments
;     )
;
; Routine description:
;
;   This function builds an appropriate argument list and calls the specified
;   function.
;
; Arguments:
;
;   Function (rcx) - Supplies a pointer to the target function.
;
;   ArgumentList (rdx) - Supplies a pointer to the argument list.
;
;   Arguments (r8d) - Supplies the number of arguments.
;
; Return Value:
;
;   The value as returned by the target function.
;
;--

        NESTED_ENTRY Invoke, _TEXT$00

        push_reg rdi                    ; save nonvolatile registers
        push_reg rsi                    ;
        push_reg rbp                    ;
        set_frame rbp, 0                ; set frame pointer

        END_PROLOGUE

        mov     eax, r8d                ; round to even argument count
        inc     eax                     ;
        and     al, 0feh                ;
        shl     eax, 3                  ; compute number of bytes
        call    __chkstk                ; check stack allocation
        sub     rsp, rax                ; allocate argument list
        mov     r10, rcx                ; save address of function
        mov     rsi, rdx                ; set source argument list address
        mov     rdi, rsp                ; set destination argument list address
        mov     ecx, r8d                ; set number of arguments
    rep movsq                           ; copy arguments to the stack

;
; N.B. All four argument registers are loaded regardless of the actual number
;      of arguments.
;
; N.B. The first argument cannot be in a floating point register and therefore
;      xmm0 is not loaded.
;

        mov     rcx, 0[rsp]             ; load first four argument registers
        mov     rdx, 8[rsp]             ;
        movq    xmm1, 8[rsp]            ;
        mov     r8, 16[rsp]             ;
        movq    xmm2, 16[rsp]           ;
        mov     r9, 24[rsp]             ;
        movq    xmm3, 24[rsp]           ;
        call    r10                     ; call target function
        mov     rsp, rbp                ; deallocate argument list
        pop     rbp                     ; restore nonvolatile register
        pop     rsi                     ;
        pop     rdi                     ;
        ret                             ;

        NESTED_END Invoke, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\typeinfo.h ===
//  Copyright (C) 1995-2002 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
   Microsoft Transaction Server (Microsoft Confidential)

   @doc
   @module typeinfo.H : Provides meta table info for an IID given it's ITypeInfo
   Borrowed from \\kernel\razzle3\rpc\ndr20
 
   Description:<nl>
   Generates -Oi2 proxies and stubs from an ITypeInfo. 
   -------------------------------------------------------------------------------
   Revision History:

   @rev 0     | 04/16/98 | Gaganc  | Created
   @rev 1     | 07/16/98 | BobAtk  | Cleaned, fixed leaks etc
   ---------------------------------------------------------------------------- */

#ifndef _TYPEINFO_H_
#define _TYPEINFO_H_

#include "cache.h"
#include <debnot.h>
#include <ndrtoken.h>
#include <ndrtypegen.h>

/////////////////////////////////////////////////////////////////////////////////////
//
// 
//
/////////////////////////////////////////////////////////////////////////////////////

struct METHOD_DESCRIPTOR
{
    LPWSTR      m_szMethodName;
    short       m_cParams;
    VARTYPE*    m_paramVTs;
};

/////////////////////////////////////////////////////////////////////////////////////
//
// A vtable for a type-info-based interceptor, and a cache thereof
//
/////////////////////////////////////////////////////////////////////////////////////

struct TYPEINFOVTBL : CALLFRAME_CACHE_ENTRY<TYPEINFOVTBL>
{
    ////////////////////////////////////////////////////////
    //
    // State
    //
    ////////////////////////////////////////////////////////

    LPSTR                    m_szInterfaceName; // our (allocated and owned by us) interface name
    METHOD_DESCRIPTOR*       m_rgMethodDescs;   // an array, indexed by iMethod of method name/TDESC pairs
    IID                      m_iidBase;         // the iid of our base interface, if any (other than IUnknown)
    MIDL_STUB_DESC           m_stubDesc;
    MIDL_SERVER_INFO         m_stubInfo;
    CInterfaceStubVtbl       m_stubVtbl;
    MIDL_STUBLESS_PROXY_INFO m_proxyInfo;
    CInterfaceProxyVtbl      m_proxyVtbl;

    //
    // Other data adjacent in RAM. See CreateVtblFromTypeInfo
    //

    ////////////////////////////////////////////////////////
    //
    // Construction & destruction
    //
    ////////////////////////////////////////////////////////

    TYPEINFOVTBL()
    {
        m_iidBase         = GUID_NULL;
        m_szInterfaceName = NULL;
        m_rgMethodDescs   = NULL;
        m_dwReleaseTime   = TYPEINFO_RELEASE_TIME_NEVER;
        Zero(&m_stubDesc);
        Zero(&m_stubInfo);
        Zero(&m_stubVtbl);
        Zero(&m_proxyInfo);
        Zero(&m_proxyVtbl);
    }

private:

    ~TYPEINFOVTBL()
    {
        if (m_rgMethodDescs)
        {
            for (ULONG iMethod = 0; iMethod < MethodCount(); iMethod++)
            {
                METHOD_DESCRIPTOR& descriptor = m_rgMethodDescs[iMethod];
                CoTaskMemFree(descriptor.m_szMethodName);
                if (descriptor.m_paramVTs)
                    CoTaskMemFree(m_rgMethodDescs[iMethod].m_paramVTs);
            }
            CoTaskMemFree(m_rgMethodDescs);
        }

        CoTaskMemFree(m_szInterfaceName);

        NdrpReleaseTypeFormatString(m_stubDesc.pFormatTypes);
    }

public:

    // Answer the number of methods in this interface
    ULONG MethodCount()
    {
        return m_stubVtbl.header.DispatchTableCount;
    }

    static void NotifyLeaked (TYPEINFOVTBL* pThis)
    {
        TxfDebugOut((DEB_TYPEINFO,
                     "A TYPEINFOVTBL at address %p of type %s still has a reference on shutdown\n",
                     pThis,
                     pThis->m_szInterfaceName));
        Win4Assert (!"An interceptor still has a reference on shutdown. Someone leaked an interface pointer.");
    }

    void* __stdcall operator new(size_t cbCore, size_t cbTotal)
    {
        return CoTaskMemAlloc(cbTotal+cbCore);
    }
}; 

/////////////////////////////////////////////////////////////////////////////////////
//
// A structure that stores cached GetInterfaceHelperClsid lookups
//
/////////////////////////////////////////////////////////////////////////////////////

struct INTERFACE_HELPER_CLSID : CALLFRAME_CACHE_ENTRY<INTERFACE_HELPER_CLSID>
{
    CLSID m_clsid;
    BOOL m_fDisableTypeLib;
    BOOL m_fDisableAll;
    BOOL m_fFoundHelper;

    INTERFACE_HELPER_CLSID()
    {
        m_clsid = GUID_NULL;
        m_fDisableTypeLib = FALSE;
        m_fDisableAll = FALSE;
        m_fFoundHelper = FALSE;
    }

    ////////////////////////////////////////////////////////
    //
    // Operations
    //
    ////////////////////////////////////////////////////////

    static void NotifyLeaked (INTERFACE_HELPER_CLSID* pThis)
    {

#ifdef _DEBUG
        WCHAR wszClsid [sizeof ("{00000101-0000-0010-8000-00AA006D2EA4}") + 1] = L"";
        CHAR szClsid [sizeof ("{00000101-0000-0010-8000-00AA006D2EA4}") + 1] = "";

        if (StringFromGUID2 (pThis->m_clsid, wszClsid, sizeof (wszClsid) / sizeof (WCHAR)) != 0 &&
            WideCharToMultiByte (
                CP_THREAD_ACP,
                WC_DEFAULTCHAR,
                wszClsid,
                -1,
                szClsid,
                sizeof (szClsid),
                NULL,
                NULL
            )
        )
        {

            TxfDebugOut((DEB_TYPEINFO,
                         "An INTERFACE_HELPER_CLSID at address %p of with clsid %s still has a reference on shutdown\n",
                         pThis,
                         szClsid));
            Win4Assert (!"An INTERFACE_HELPER_CLSID still has a reference on shutdown.");

        }
#endif
    }

};

typedef struct tagMethodInfo 
{
    FUNCDESC  * pFuncDesc;
    ITypeInfo * pTypeInfo;

    void Destroy()
    {
        if (pFuncDesc)
        {
            // Release the funcdesc
            //
            pTypeInfo->ReleaseFuncDesc(pFuncDesc);
            pFuncDesc = NULL;
        }
        if (pTypeInfo)
        {
            // Release the type info
            //
            pTypeInfo->Release();
            pTypeInfo = NULL;
        }
    }

} MethodInfo;

HRESULT GetVtbl(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    OUT TYPEINFOVTBL **     ppVtbl,
    OUT ITypeInfo **        ppBaseTypeInfo);

HRESULT CreateVtblFromTypeInfo(
    IN  ITypeInfo*          ptinfoInterface,
    IN  ITypeInfo*          ptinfoDoc,
    IN  REFIID              riid,
    IN  REFIID              iidBase,
    IN  BOOL                fIsDual,
    IN  USHORT              numMethods,
    IN  MethodInfo   *      rgMethodInfo,
    OUT TYPEINFOVTBL **     ppVtbl);

HRESULT GetFuncDescs        (ITypeInfo *pTypeInfo, MethodInfo *pMethodInfo);
HRESULT ReleaseFuncDescs    (USHORT cMethods, MethodInfo *pMethodInfo);
HRESULT CountMethods        (ITypeInfo * pTypeInfo, USHORT* pNumMethods);

EXTERN_C HRESULT NdrpCreateProxy(
    IN  REFIID              riid, 
    IN  IUnknown *          punkOuter, 
    OUT IRpcProxyBuffer **  ppProxy, 
    OUT void **             ppv);

EXTERN_C HRESULT NdrpCreateStub(REFIID riid, IUnknown* punkServer, IRpcStubBuffer **ppStub);

EXTERN_C void * StublessClientVtbl[];
EXTERN_C const IRpcStubBufferVtbl CStdStubBuffer2Vtbl;

/////////////////////////////////////////////////////////////////

#define rmj 3
#define rmm 0
#define rup 44
#define MIDLVERSION (rmj<<24 | rmm << 16 | rup)

#include "OleAutGlue.h"

/////////////////////////////////////////////////////////////////

#define VTABLE_BASE 0


#endif // _TYPEINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\callframe\ia64\extract.s ===
//****************************************************************************
//
//  Copyright (C) 1995-2000 Microsoft Corporation.  All rights reserved.
//
// extract.s - IA64 generic thunks for callframe interceptors.
//
// Purpose:
//
//   This module implements the IA64-specific generic thunks for intercepted.
//   COM method calls.
//
// Revision Histor:
//
//    Created           1-17-2000               JohnStra
//
//****************************************************************************        

        .file "extract.s"
        .section .text

#include "ksia64.h"		
				        
//++
//
// ExtractParams
//
// Routine Description:
//
//     Common handler code for making an indirect IA64 call through an
//     interceptor.  Homes all the arguments to the call to the memory
//     stack and dispatches the call on to Interceptor::CallIndirect.
//
// On Entry:
// 
//     All of the arguments to the interface method are their proper
//     place as defined by the IA64 calling standard: ints in general
//     registers, floats in float registers, etc.
//
// Arguments:  
//
//     r31 - index of the method to call
//
// Note:
//
//     The only way this routine is executed is by way of an unconditional
//     branch from one of our own generic thunks.  When this routine
//     returns, it returns to the original caller of the interface method.
//
//		When we get the stack, it looks like this:
//		sp-> STACK_SCRATCH_AREA
//				...
//		     remainder of parameters
//
//		We're going to set up the stack to relocate the scratch area and
//		make it look like (upon calling):
//
//		 offset*		what
//		-SCRATCH_AREA	Scratch Area Proper
//		0				cbArgs
//		4				hr
//		...				Padding to Align with 16
//      16              farg0
//      32              farg1
//      48              farg2
//      64              farg3
//      80              farg4
//      96              farg5
//      112             farg6
//      128             farg7
//		144				in0
//		152				in1
//		160				in2
//		168				in3
//		176				in4
//		184				in5
//		192				in6
//		200				in7
//		208				remainder of parameters
//
//		(* for brevity, offset is offset from sp+STACK_SCRATCH_AREA)
//       
//
//--
        .proc ExtractParams#
        .align 32
        
		//
        // Stack based locals
        //
		cbArgs$ =   0+STACK_SCRATCH_AREA
		hr$     =   4+STACK_SCRATCH_AREA
        //
        // Other useful stack locations
        //
        fargs$  =  16+STACK_SCRATCH_AREA
        this_$  = 144+STACK_SCRATCH_AREA
        		        
		.global ExtractParams#
        .type ExtractParams#, @function
        .align 32
        
ExtractParams:
        .regstk 8, 6, 8, 0
        .prologue 0xE, loc0
        
        //
        // Allocate a frame.  We want 8 input slots, 6 locals, and 8
        // output slots.  We're not using the rotating registers feature.
        //
        
        alloc loc0=ar.pfs, 8, 6, 8, 0
        
        //
        // Register based local variables.
        //
         
        saved_ar                 =loc0          // r40
        saved_return_address     =loc1          // r41
        psp                      =loc2          // r42
        saved_gp                 =loc3          // r43
        saved_pr                 =loc4          // r44
        saved_unat               =loc5          // r45

        //
        // Prologue-- save registers.
        //
        
        mov     psp=sp                          // save stack pointer
        mov     saved_return_address=b0         // save return address
        mov     saved_gp=gp;;                   // save gp
        mov.m   saved_unat=ar.unat              // save ar.unat
        mov     saved_pr=pr;;                   // save pr
        
        //
        // Allocate some stack.  We need enough to hold stack-based
        // locals plus space to spill all the integer and FP arguments.
		//
		// Remember that although we're going to be eating space in
		// the scratch area, we need another one because we're calling
		// a function.
        //
		// 208 bytes needed (see diagram above)
		//
        
        adds    sp=-208, sp ;;

        //
        // Init a pointer into the stack where the floating point args are to
        // be placed.
        //

        adds    r14=fargs$, sp ;;
        adds    r15=16, r14

        //
        // Spill all the FP args onto the stack...
        //
        
        stf.spill [r14]=farg0, 32 ;; 
        stf.spill [r15]=farg1, 32 ;;
        stf.spill [r14]=farg2, 32
        stf.spill [r15]=farg3, 32 ;; 
        stf.spill [r14]=farg4, 32        
        stf.spill [r15]=farg5, 32 ;;
        stf.spill [r14]=farg6
        stf.spill [r15]=farg7     ;; 
                        
        //
        // Init a pointer into the stack where integer params are to be placed.
        //

        adds    r14=this_$, sp ;;
        adds    r15=8, r14
        
        //
        // Move all the integer arguments out of registers onto the stack.
        //

        st8.spill [r14]=in0, 16 ;;
        st8.spill [r15]=in1, 16 ;;
        st8.spill [r14]=in2, 16 ;;
        st8.spill [r15]=in3, 16 ;;
        st8.spill [r14]=in4, 16 ;;
        st8.spill [r15]=in5, 16 ;;
        st8.spill [r14]=in6 ;;
        st8.spill [r15]=in7 ;;
        
        //
        // Setup arguments to Interceptor::CallIndirect
        //

        adds    r19=this_$, sp ;;
        ld8     r18=[r19] ;;
        adds    out0=-48, r18                   // 'this'
		
        adds    out1=hr$, sp                    // &hr
		
        mov     out2=r31                        // i
		
        adds    out3=this_$, sp                 // pvArgs
		
        adds    out4=cbArgs$, sp                // &cbArgs
        
        //
        // Calculate the address Interceptor::CallIndirect
        //
	
        adds	r22=this_$, sp ;;               // this_ in r22
		ld8		r21=[r22] ;;                    // address of pVtbl in r21
		adds	r20=-48, r21;;                  // get containing pInterceptor in r20
		ld8		r17=[r20] ;;                    // address of pVtbl in r17
		adds	r16=24, r17;;                   // address of label for CallIndirect in r16
		ld8		r15=[r16] ;;                    // address of function ptr in r15
		ld8		r14=[r15], 8;;                  // address of function in r14
        mov		b6=r14                          // address of function in b6

        //
        // Make the call
        //
        
        br.call.sptk.few b0=b6;;

        //
        // Epilogue
        //        

		adds	r22=hr$,sp ;;					// calculate address of hr to return...
		ld4		r23=[r22]  ;;					// load hr into ret0
		sxt4	ret0=r23   ;;					// make sure it's sign extended		
		        
        mov     sp=psp                          // restore stack pointer
        mov     b0=saved_return_address         // restore return address
        mov.m   ar.unat=saved_unat              // restore ar.unat
        mov     pr=saved_pr, -1;;               // restore pr
        mov     ar.pfs=saved_ar;;               // restore previous function state

        //
        // Return to caller
        //
        
        br.ret.dpnt     b0
        
        .endp ExtractParams#
		
//++
//
//  Function:   void __stdcall SpillFPRegsForIA64(
//                                 REGISTER_TYPE* pStack, 
//                                 ULONG          FloatMask
//                                 );
//
//  Synopsis:   Given a pointer to the virtual stack and floating-point mask,
//              SpillFPRegsForIA64 copies the contents of the floating-point 
//              registers to the appropriate slots in pStack.
//
//				This was adapted from the RPC NDR function that does a similar
//				thing.
//
//              EXCEPT:  the fargs are actually stored a pStack - (32 * 8).
//                       This is because we cannot count on the fargs params
//                       being maintained in between the call to ExtractParams
//                       above and this method call.
//
//  Arguments:  pStack - Pointer to the virtual stack in memory.
//
//              FloatMask - A mask that indicates argument slots passed as float/double registers
//                          Each nibble indicates if the argument slot contains a float.
//                          Float       : D8 F8 D7 F7 D6 F6 D5 F5 D4 F4 D3 F3 D2 F2 D1 F1
//                          bit position: 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
//                          16 bits represents 8 slots
//        
//                          A bit in an F* position represents a float (4 bytes).  A bit in a D*
//                          position represents a double (8 bytes).  Both bits set indicates two
//                          floats side by side (in an 8 byte slot in memory, but in 2 regs.)
//
//  Notes:     In the __stdcall calling convention, the callee must pop
//             the parameters.
//
//--
        NESTED_ENTRY(SpillFPRegsForIA64)
        NESTED_SETUP(4,4,8,0)

        savedSP         = loc2                  // savedSP aliased to loc2
        savedLC         = loc3
        pStack          = a0                    // pStack  aliased to first param passed in
        FloatMask       = a1                    // FloatMask  aliased to second param passed in

        mov             savedSP = sp            // save sp
        mov             savedLC = ar.lc         // save lc

        PROLOGUE_END

        ARGPTR          (a0)                    // sign-extend pStack for WIN32

        //----------------------------------------------------------------
        // start of main algorithm
        //----------------------------------------------------------------
        mov             t0 = FloatMask;;        // FloatMask copied to t0
        mov             t1 = pStack             // pStack copied to t1
        
        popcnt          t4 = t0;;               // count number of bits in FloatMask; i.e. how many
                                                // active slots
        //
        // Load the fp regs from the stack up into real registers.
        //
        // Rotating registers rotate downward. because of this we
        // reverse the order of the fp regs fp8 - fp15 to 
        // fp47 - fp40.  This is so we can use the rotating registers
        // feature of the IA64.
        //
        
        adds            t2 = -16, t1            // t2 is the start of the fargs
        cmp.eq          pt0 = 8, t4             // look at the number of parameters and branch accordingly.
(pt0)   br.cond.sptk    ReverseFP8;;            
        adds            t2 = -16, t2
        cmp.eq          pt0 = 7, t4             // the fp args are ordered by their arguement order; i.e.
(pt0)   br.cond.sptk    ReverseFP7;;            // fp32 contains the first fp arg, fp32 contains the next
        adds            t2 = -16, t2
        cmp.eq          pt0 = 6, t4             // fp arg...etc. 
(pt0)   br.cond.sptk    ReverseFP6;;              
        adds            t2 = -16, t2
        cmp.eq          pt0 = 5, t4
(pt0)   br.cond.sptk    ReverseFP5;;
        adds            t2 = -16, t2
        cmp.eq          pt0 = 4, t4
(pt0)   br.cond.sptk    ReverseFP4;;
        adds            t2 = -16, t2
        cmp.eq          pt0 = 3, t4
(pt0)   br.cond.sptk    ReverseFP3;;
        adds            t2 = -16, t2
        cmp.eq          pt0 = 2, t4
(pt0)   br.cond.sptk    ReverseFP2;;
        adds            t2 = -16, t2
        cmp.eq          pt0 = 1, t4
(pt0)   br.cond.sptk    ReverseFP1;;


ReverseFP8:                                     // reverse fp reg order from the load
        ldf.fill       f40 = [t2], -16 ;; 
ReverseFP7:                                     
        ldf.fill       f41 = [t2], -16 ;; 
ReverseFP6:
        ldf.fill       f42 = [t2], -16 ;; 
ReverseFP5:
        ldf.fill       f43 = [t2], -16 ;; 
ReverseFP4:
        ldf.fill       f44 = [t2], -16 ;; 
ReverseFP3:
        ldf.fill       f45 = [t2], -16 ;; 
ReverseFP2:
        ldf.fill       f46 = [t2], -16 ;; 
ReverseFP1:
        ldf.fill       f47 = [t2]
     

StartSpill:
        mov             ar.lc  = 8              // the maximum loop count is total slots in FloatMask


ProcessNextSlot:
        extr.u          t10 = t0, 0, 2          // extract the two FP slot nibbles into t10
        shr.u           t0  = t0, 2;;           // shift FloatMask, since we've extracted the slot

        cmp.eq          pt0 = 0, t0             // check if FloatMask is zero; if so, we are done.
        cmp.eq          pt1 = 0, t10            // check if slot is 0; i.e. not a float or double
        cmp.eq          pt2 = 1, t10            // check if slot is 1: float
        cmp.eq          pt3 = 2, t10            // check if slot is 2: double
        cmp.ne          pt4 = 3, t10;;          // check if slot is 3: double-float
        
(pt2)   stfs            [t1] = f47;;            // store float at pStack
(pt3)   stfd            [t1] = f47;;            // store double at pStack        
(pt4)   br.cond.sptk    SpillDualFloatRegBump;; // CAN'T PREDICATE THROUGH THIS!!!
        
        stfs            [t1] = f47, 4;;         // store double-float.
        stfs            [t1] = f46, -4;; 
        br.ctop.sptk    SpillDualFloatRegBump;; // jump to next line to force reg rotate
SpillDualFloatRegBump:        

        adds            t1 = 8, t1              // advance to next stack slot
                        
(pt0)   br.cond.sptk    Done                    // FloatMask is zero, so we are done
(pt1)   br.cond.sptk    ProcessNextSlot         // a zero slot pays a branch penality; but it does not 
                                                // rotate the fp & pr registers
        br.ctop.sptk    ProcessNextSlot;;       // counted loop no penalty for branch rotate f32&pr16 


        //----------------------------------------------------------------
        // done, restore sp and exit
        //----------------------------------------------------------------
Done:
		mov             ar.lc = savedLC         // restore loop count register
        .restore
        mov             sp = savedSP            // restore sp

        NESTED_RETURN
     
        NESTED_EXIT(SpillFPRegsForIA64)		

//++
//		
//  Function:   void __stdcall FillFPRegsForIA64(
//                                 REGISTER_TYPE* pStack, 
//                                 ULONG          FloatMask
//                                 );
//
//  Synopsis:   Given a pointer to the virtual stack and floating-point mask,
//              FillFPRegsForIA64 copies the floating point contents of the stack
//              back to the appropriate registers.
//
//				This was adapted from the RPC NDR function that does a similar
//				thing, only backwards.
//
//  Arguments:  pStack - Pointer to the virtual stack in memory.
//
//              FloatMask - A mask that indicates argument slots passed as float/double registers
//                          Each nibble indicates if the argument slot contains a float
//                          Float       : D8 F8 D7 F7 D6 F6 D5 F5 D4 F4 D3 F3 D2 F2 D1 F1
//                          bit position: 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
//                          16 bits represents 8 slots
//
//                          A bit in an F* position represents a float (4 bytes).  A bit in a D*
//                          position represents a double (8 bytes).  Both bits set indicates two
//                          floats side by side (in an 8 byte slot in memory, but in 2 regs.)
//
//  Notes:     In the __stdcall calling convention, the callee must pop
//             the parameters.
//
//--
        NESTED_ENTRY(FillFPRegsForIA64)
        NESTED_SETUP(4,4,8,0)

        savedSP         = loc2                  // savedSP aliased to loc2
        savedLC         = loc3
        pStack          = a0                    // pStack  aliased to first param passed in
        FloatMask       = a1                    // FloatMask  aliased to second param passed in

        mov             savedSP = sp            // save sp
        mov             savedLC = ar.lc         // save lc

        PROLOGUE_END

        ARGPTR          (a0)                    // sign-extend pStack for WIN32

        //----------------------------------------------------------------
        // start of main algorithm
        //----------------------------------------------------------------
        mov             t0 = FloatMask;;        // FloatMask copied to t0
        mov             t1 = pStack             // pStack copied to t1

        popcnt          t4 = t0;;               // count number of bits in FloatMask; i.e. how many
                                                // active slots
		
StartFill:
        mov             ar.lc  = 8              // the maximum loop count is total slots in FloatMask


FillNextSlot:
        extr.u          t10 = t0, 0, 2          // extract the two FP slot nibbles into t10
        shr.u           t0  = t0, 2;;           // shift FloatMask, since we've extracted the slot

        cmp.eq          pt0 = 0, t0             // check if FloatMask is zero; if so, we are done.
        cmp.eq          pt1 = 0, t10            // check if slot is 0; i.e. not a float or double
        cmp.eq          pt2 = 1, t10            // check first nibble of extracted slot is float
        cmp.eq          pt3 = 2, t10            // check second nibble of extracted slot is double
        cmp.ne          pt4 = 3, t10;;          // check for dual-floats. 

        //
        // For all of these, f40 is the current "working" floating point register.
        // f41 is the "previous" register, f39 is the "next" register.
        //
(pt2)   ldfs            f40 = [t1];;             // load float from pStack
(pt3)   ldfd            f40 = [t1];;             // load double from pStack
(pt4)   br.cond.sptk    FillDualFloatRegBump;;   // CAN'T PREDICATE THROUGH THIS!! ARGH!!!
        
        // Dual float section.
        ldfps           f40,f39 = [t1];; 
        br.ctop.sptk    FillDualFloatRegBump;;   // jump to next line, but forces a reg. rotate.
FillDualFloatRegBump:

        adds            t1 = 8, t1              // move to next slot
                        
(pt0)   br.cond.sptk    FillDone                // FloatMask is zero, so we are done
(pt1)   br.cond.sptk    FillNextSlot            // a zero slot pays a branch penality; but it does not 
                                                // rotate the fp & pr registers
        br.ctop.sptk    FillNextSlot;;          // counted loop no penalty for branch rotate f32&pr16 


FillDone:										
		cmp.eq          pt0 = 8, t4             // look at the number of parameters and branch accordingly.
(pt0)   br.cond.sptk    FillEight;;				// At this point f40 contains the last fp arg, f41 the next
        cmp.eq          pt0 = 7, t4             // to last, etc.  A rather unfortunate situation, since we
(pt0)   br.cond.sptk    FillSeven;;				// need to put the FIRST one in f8, the second in f9, etc.
        cmp.eq          pt0 = 6, t4             // So, for each potential count of fp args, we go to a special
(pt0)   br.cond.sptk    FillSix;;               // block of code, to shuffle the values correctly.
        cmp.eq          pt0 = 5, t4             
(pt0)   br.cond.sptk    FillFive;;				
        cmp.eq          pt0 = 4, t4             
(pt0)   br.cond.sptk    FillFour;;
        cmp.eq          pt0 = 3, t4             
(pt0)   br.cond.sptk    FillThree;;
        cmp.eq          pt0 = 2, t4
(pt0)   br.cond.sptk    FillTwo;;
        cmp.eq          pt0 = 1, t4
(pt0)   br.cond.sptk    FillOne

		br.cond.sptk    DoneFillFloats;;		// Shouldn't ever get here, but just in case...
		
FillOne:
		mov				f8  = f40				// Move the floating values from their temporary positions
		br.cond.sptk DoneFillFloats;;			// into the floating point argument registers.

FillTwo:
		mov				f8  = f41
		mov				f9  = f40
		br.cond.sptk DoneFillFloats;;

FillThree:
		mov				f8  = f42
		mov				f9  = f41
		mov				f10 = f40
		br.cond.sptk DoneFillFloats;;

FillFour:
		mov				f8  = f43
		mov				f9  = f42
		mov				f10 = f41
		mov				f11 = f40
		br.cond.sptk DoneFillFloats;;

FillFive:
		mov				f8  = f44
		mov				f9  = f43
		mov				f10 = f42
		mov				f11 = f41
		mov				f12 = f40
		br.cond.sptk DoneFillFloats;;

FillSix:
		mov				f8  = f45
		mov				f9  = f44
		mov				f10 = f43
		mov				f11 = f42
		mov				f12 = f41
		mov				f13 = f40
		br.cond.sptk DoneFillFloats;; 

FillSeven:
		mov				f8  = f46
		mov				f9  = f45
		mov				f10 = f44
		mov				f11 = f43
		mov				f12 = f42
		mov				f13 = f41
		mov				f14 = f40
		br.cond.sptk DoneFillFloats;;

FillEight:
		mov				f8  = f47
		mov				f9  = f46
		mov				f10 = f45
		mov				f11 = f44
		mov				f12 = f43
		mov				f13 = f42
		mov				f14 = f41
		mov				f15 = f40

DoneFillFloats:

		rum				1 << PSR_MFH			// restore user mask for
												// floats.  I don't know
												// if this is strictly
												// necessary, but RPC does
												// it before invoking, so
												// I guess I should too.
     
        //----------------------------------------------------------------
        // done, restore sp and exit
        //----------------------------------------------------------------
		mov             ar.lc = savedLC         // restore loop count register
        .restore
        mov             sp = savedSP            // restore sp

        NESTED_RETURN
     
        NESTED_EXIT(FillFPRegsForIA64)		
		

		
//****************************************************************************
//
// The following macros are used to create the generic thunks with which
// we populate the interceptor vtbls.  The thunk simply saves away the
// the method index in saved register r31 and jumps to the ExtractParams
// routine.
//
//****************************************************************************
#define meth10IA64(i)  \
	methIA64(i##0) \
	methIA64(i##1) \
	methIA64(i##2) \
	methIA64(i##3) \
	methIA64(i##4) \
	methIA64(i##5) \
	methIA64(i##6) \
	methIA64(i##7) \
	methIA64(i##8) \
	methIA64(i##9)

#define meth100IA64(i)   \
	meth10IA64(i##0) \
	meth10IA64(i##1) \
	meth10IA64(i##2) \
	meth10IA64(i##3) \
	meth10IA64(i##4) \
	meth10IA64(i##5) \
	meth10IA64(i##6) \
	meth10IA64(i##7) \
	meth10IA64(i##8) \
	meth10IA64(i##9)       

#define methIA64(i)                             \
        .##global __Interceptor_meth##i;        \
        .##proc   __Interceptor_meth##i;        \
__Interceptor_meth##i::                         \
        mov r31=i;                               \
        br ExtractParams;                       \
        .##endp __Interceptor_meth##i;
        

        
//****************************************************************************
//
// The following statements expand, using the macros defined above, into
// the methods used in interceptor vtbls. 
//
//****************************************************************************
    methIA64(3)
    methIA64(4)
    methIA64(5)
    methIA64(6)
    methIA64(7)
    methIA64(8)
    methIA64(9)
    meth10IA64(1)
    meth10IA64(2)
    meth10IA64(3)
    meth10IA64(4)
    meth10IA64(5)
    meth10IA64(6)
    meth10IA64(7)
    meth10IA64(8)
    meth10IA64(9)
    meth100IA64(1)
    meth100IA64(2)
    meth100IA64(3)
    meth100IA64(4)
    meth100IA64(5)
    meth100IA64(6)
    meth100IA64(7)
    meth100IA64(8)
    meth100IA64(9)
    meth10IA64(100)
    meth10IA64(101)
    methIA64(1020)
    methIA64(1021)
    methIA64(1022)
    methIA64(1023)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\clinkable.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
/* -----------------------------------------------------------------------
   Microsoft Application Server (Microsoft Confidential)

   @rev 0 | 3/23/97 | jimbo  | Sherpa-M3
   @rev 1 | 10/9/98 | bobatk | made inline version in TXF
   ----------------------------------------------------------------------- */

//
// Includes
//
#include <Linkable.h>


//
// Class -- CLinkable
//		Elements on a linked list
//


//
// Member Function (public) -- InsertAfter
//		Insert 'that' onto the list after 'this'. Remove 'other' from its current
//		list, if necessary.
//
inline void CLinkable::InsertAfter( CLinkable* that )
{
	CLinkable* prev = that->m_pPrev;
	CLinkable* next = that->m_pNext;

	prev->m_pNext = next;
	next->m_pPrev = prev;

	next = this->m_pNext;

	this->m_pNext = that;
	that->m_pPrev = this;
	that->m_pNext = next;
	next->m_pPrev = that;
}


//
// Member Function (public) -- InsertBefore
//		Insert 'that' onto the list before 'this'. Remove 'other' from its current
//		list, if necessary.
//
inline void CLinkable::InsertBefore( CLinkable* that )
{
	CLinkable* prev = that->m_pPrev;
	CLinkable* next = that->m_pNext;

	prev->m_pNext = next;
	next->m_pPrev = prev;

	prev = this->m_pPrev;

	prev->m_pNext = that;
	that->m_pPrev = prev;
	that->m_pNext = this;
	this->m_pPrev = that;
}


//
// Member Function (public) -- Remove
//		Remove element from its current list, if any.
//
inline void CLinkable::Remove()
{
	CLinkable* prev = m_pPrev;
	CLinkable* next = m_pNext;

	prev->m_pNext = next;
	next->m_pPrev = prev;

	m_pPrev = m_pNext = this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\comps.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// comps.h
//
// Definitions exported from Kom to the ComPs static library

#ifdef __cplusplus
extern "C" {
#endif

    HRESULT __stdcall ComPs_NdrDllRegisterProxy(
        IN HMODULE                  hDll,
        IN const ProxyFileInfo **   pProxyFileList,
        IN const CLSID *            pclsid,
        IN const IID**              rgiidNoCallFrame,
        IN const IID**              rgiidNoMarshal
        );

    HRESULT __stdcall ComPs_NdrDllUnregisterProxy(
        IN HMODULE                  hDll,
        IN const ProxyFileInfo **   pProxyFileList,
        IN const CLSID *            pclsid,
        IN const IID**              rgiidNoCallFrame,
        IN const IID**              rgiidNoMarshal
        );


    HRESULT __stdcall ComPs_NdrDllGetClassObject(
        IN  REFCLSID                rclsid,
        IN  REFIID                  riid,
        OUT void **                 ppv,
        IN const ProxyFileInfo **   pProxyFileList,
        IN const CLSID *            pclsid,
        IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

    HRESULT __stdcall ComPs_NdrDllCanUnloadNow(
        IN CStdPSFactoryBuffer * pPSFactoryBuffer);

#ifdef __cplusplus
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\comregistration.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// ComRegistration.h
//
// A simple utility class that manages COM registration for you.
//
// To register a class, construct a instance of CComRegistration on the stack. Then:
//      Manditory: set the fields:
//          hModule     - module handle of the DLL to be registered
//          clsid       - clsid to register it under
//      Optional: set the remaining fields
//      Finally: call Register();
//
// To unregister a class, construct an instance of CComRegistration on the stack, 
//      set at least the clsid and hModule fields, then call Unregister(). If progID or 
//      versionIndependentProgID is not provided, they are computed from the information
//      presently found in the registry.
//
// Note that this class is fully Unicode. To be able to use it on Win95, you must 
// link with the Viper thunk libraries.
//

#ifndef _COMREGISTRATION_H_
#define _COMREGISTRATION_H_

#include <memory.h>

/////////////////////////////////////////////////////////////////////////////////////
//
// Registering information about a particular CLSID
//

#define CComRegistration ClassRegistration          // temporary, until we can change existing clients to use the new name

#ifndef LEGACY_VIPER_TREE
typedef GUID APPID;
#endif

class ClassRegistration
    {
public:
    
    //
    // REVIEW: We should eliminate SERVER_TYPE and just use the CLSCTX values
    //
    enum SERVER_TYPE
        {                       
        INPROC_SERVER    = CLSCTX_INPROC_SERVER,    // an inproc server (default)
        LOCAL_SERVER     = CLSCTX_LOCAL_SERVER,     // a  local server
        INPROC_HANDLER   = CLSCTX_INPROC_HANDLER,   // an inproc handler for a local server
        SERVER_TYPE_NONE = 0,                       // don't do any server dll/exe registration
        };

    CLSID               clsid;                      // class identifier to register
    DWORD               serverType;                 // what flavor of server to register
    HMODULE             hModule;                    // module handle of EXE/DLL being registered
    LPCWSTR             className;                  // e.g. "Recorder Class"
    LPCWSTR             progID;                     // e.g. "MTS.Recorder.1"
    LPCWSTR             versionIndependentProgID;   // e.g. "MTS.Recorder"
    LPCWSTR             threadingModel;             // e.g. "Both", "Free". Only for servers of type INPROC_SERVER.
    APPID               appid;                      // optional AppId to associate with this class
    
    GUID                moduleid;                   // for kernel servers: the id of the module under which to register
    BOOL                fCreateService;             // for kernel servers: whether we should create the service or assume it's there
    

    ClassRegistration()
        {
        memset(this, 0, sizeof(ClassRegistration)); // we have no virtual functions, so this is OK
        serverType = INPROC_SERVER;
        }
    
    HRESULT Register();         // Make CLASS registry entries
    HRESULT Unregister();       // Remove CLASS registry entries
    };


/////////////////////////////////////////////////////////////////////////////////////
//
// Registering information about a particular APPID
//

class AppRegistration
    {
public:
    APPID               appid;                      // app identifier to register
    LPCWSTR             appName;                    // name of said appid
    BOOL                dllSurrogate;               // if true, then set the DllSurrogate entry
    HMODULE             hModuleSurrogate;           // used to form DllSurrogate path

    HRESULT Register();
    HRESULT Unregister();

    AppRegistration()
        {
        memset(this, 0, sizeof(AppRegistration));
        }

    };


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\enum_t.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __ENUM_INCLUDED__
#define __ENUM_INCLUDED__

// Expected enumerator usage:
//	XS xs;
//	EnumXS exs(xs);
//	while (exs.next())
//		exs.get(&x);
//	exs.reset();
//	while (exs.next())
//		exs.get(&x)

class Enum {
public:
    virtual void reset() =0;
    virtual BOOL next() =0;
};

#endif // !__ENUM_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\idispatchinfo.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// IDispatchInfo.h
//
// Information about the IDispatch interface
//
// REVIEW: These stack layouts are NOT correct for 64 bit!

enum {
    IMETHOD_FIRST = 3,
    IMETHOD_GetTypeInfoCount = IMETHOD_FIRST,
    IMETHOD_GetTypeInfo,
    IMETHOD_GetIDsOfNames,
    IMETHOD_Invoke,
    IMETHOD_DISPATCH_MAX,

    IPARAM_Invoke_DispId     = 0,
    IPARAM_Invoke_Iid        = 1,
    IPARAM_Invoke_Lcid       = 2,
    IPARAM_Invoke_WFlags     = 3,
    IPARAM_Invoke_DispParams = 4,
    IPARAM_Invoke_PVarResult = 5,
    IPARAM_Invoke_PExcepInfo = 6,
    IPARAM_Invoke_PUArgErr   = 7,
    }; 


#if defined(_WIN64)
    #define PAD4(n)     char __pad ## n [4];
#else
    #define PAD4(n)     
#endif

#if !defined(_WIN64)
   #define PPAD4(n)     PAD4(n) 
#else
   #define PPAD4(n)
#endif

#ifndef _WIN64
#pragma pack(push, 4)   // mimic what MIDL does
#else
#pragma pack(push, 8)
#endif


//
////////////////////////////////////////////////////////////////////
//
// IDispatch

struct FRAME_GetTypeInfoCount 
    {
    IDispatch*  This;           PPAD4(0);
    UINT*       pctinfo;
    };

struct FRAME_GetTypeInfo
    {
    IDispatch*      This;       PPAD4(0);
    UINT            iTInfo;     PAD4(1);
    LCID            lcid;       PAD4(2);
    ITypeInfo**     ppTInfo;    PPAD4(3);
    };

struct FRAME_GetIDsOfNames
    {
    IDispatch*      This;       PPAD4(0);
    REFIID          riid;       PPAD4(1);
    LPOLESTR*       rgszNames;  PPAD4(2);
    UINT            cNames;     PAD4(3);
    LCID            lcid;       PAD4(4);
    DISPID*         rgDispId;   PPAD4(5);
    };

struct FRAME_RemoteInvoke;

struct FRAME_Invoke
    {
    IDispatch*      This;           PPAD4(0);
    DISPID          dispIdMember;   PAD4(1);
    IID*            piid;           PPAD4(2);
    LCID            lcid;           PAD4(3);
    WORD            wFlags;         PAD4(4);
    DISPPARAMS*     pDispParams;    PPAD4(5);
    VARIANT*        pVarResult;     PPAD4(6);
    EXCEPINFO*      pExcepInfo;     PPAD4(7);
    UINT*           puArgErr;       PPAD4(8);
    
    void CopyTo(FRAME_RemoteInvoke&) const;
    void CopyFrom(const FRAME_RemoteInvoke&);
    };

struct FRAME_RemoteInvoke
    {
    IDispatch*      This;           PPAD4(0);
    DISPID          dispIdMember;   PAD4(1);
    IID*            piid;           PPAD4(2);
    LCID            lcid;           PAD4(3);
    DWORD           dwFlags;        PAD4(4);        // ****
    DISPPARAMS*     pDispParams;    PPAD4(5);
    VARIANT*        pVarResult;     PPAD4(6);
    EXCEPINFO*      pExcepInfo;     PPAD4(7);
    UINT*           puArgErr;       PPAD4(8);
    UINT            cVarRef;        PAD4(9);        // ****
    UINT*           rgVarRefIdx;    PPAD4(10);       // ****
    VARIANTARG*     rgVarRef;       PPAD4(11);       // ****

    void CopyTo(FRAME_Invoke&) const;
    void CopyFrom(const FRAME_Invoke&);
    };

#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\genericclassfactory.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// GenericClassFactory.h
//
// A generic instantiator that drives two-phase initialization of COM objects
// that support aggregation through IUnkInner, together with a class factory
// wrapper on top of same.
//
#ifndef __GenericClassFactory__h__
#define __GenericClassFactory__h__

#ifndef STDCALL
#define STDCALL __stdcall
#endif

///////////////////////////////////////////////////////////////////////////////////////
//
// Generic instance creation function

template <class ClassToInstantiate>
class GenericInstantiator
{
public:
    template <class T>
    static HRESULT CreateInstance(IUnknown* punkOuter, T*& pt)
    {
        return CreateInstance(punkOuter, __uuidof(T), (void**)&pt);
    }

    static HRESULT CreateInstance(IUnknown* punkOuter, REFIID iid, LPVOID* ppv)
    {
        HRESULT hr = S_OK;
        ASSERT(ppv && (punkOuter == NULL || iid == IID_IUnknown));
        if  (!(ppv && (punkOuter == NULL || iid == IID_IUnknown))) return E_INVALIDARG;
   
        *ppv = NULL;
        ClassToInstantiate* pnew = new ClassToInstantiate(punkOuter);
        if (pnew)
        {
            IUnkInner* pme = (IUnkInner*)pnew;
            hr = pnew->Init();
            if (hr == S_OK)
            {
                hr = pme->InnerQueryInterface(iid, ppv);
            }
            pme->InnerRelease();                // balance starting ref cnt of one    
        }
        else 
            hr = E_OUTOFMEMORY;
    
        return hr;
    }

    static HRESULT New(OUT ClassToInstantiate** ppNewT)
    {
        HRESULT hr = S_OK;

        ClassToInstantiate* pnew = new ClassToInstantiate();
        if (pnew)
        {
            hr = pnew->Init();
            if (hr == S_OK)
            {
            }
            else
            {
                delete pnew;
                pnew = NULL;
            }
        }

        *ppNewT = pnew;

        return hr;
    }
};

//
////////////////////////////////////////////////////////////////////////////////////
//
// Generic class factory implemenation

template <class ClassToInstantiate>
class GenericClassFactory : public IClassFactory
{
public:
    GenericClassFactory() : m_crefs(1)  // NB: starting reference count of one
    {
    }

public:
    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv)
    {
        if (NULL == ppv)
            return E_INVALIDARG;

        if (iid == IID_IUnknown || iid == IID_IClassFactory)
        {
            *ppv = (IClassFactory*)this;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }

        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    ULONG STDCALL AddRef()  { InterlockedIncrement (&m_crefs); return (m_crefs); }
    ULONG STDCALL Release() { long cRef = InterlockedDecrement(&m_crefs); if (cRef == 0) delete this; return cRef; }

public:
    HRESULT STDCALL LockServer (BOOL fLock) { return S_OK; }

    HRESULT STDCALL CreateInstance(IUnknown* punkOuter, REFIID iid, LPVOID* ppv)
    {
        return GenericInstantiator< ClassToInstantiate >::CreateInstance(punkOuter, iid, ppv);
    }

    
private:
    long m_crefs;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\interlockedstack.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// InterlockedStack.h
//
// Implements a stack of T's, where T is an arbitrary type. 

#ifndef __INTERLOCKED_STACK_H__
#define __INTERLOCKED_STACK_H__

#include "TxfUtil.h"        // for CanUseCompareExchange64
#include "Concurrent.h"

////////////////////////////////////////////////////////////////////////////////////////
//
// Forward declarations
//
////////////////////////////////////////////////////////////////////////////////////////

template <class T> struct InterlockedStack;
template <class T> struct LockingStack;


////////////////////////////////////////////////////////////////////////////////////////
//
// Type-friendly interlocked swapping
//
////////////////////////////////////////////////////////////////////////////////////////

#ifndef _WIN64
template <class T> InterlockedStack<T> 
TxfInterlockedCompareExchange64(volatile InterlockedStack<T>* pDestination, const InterlockedStack<T>& exchange, const InterlockedStack<T>& comperand)
{
	return (InterlockedStack<T>)TxfInterlockedCompareExchange64((volatile LONGLONG*)pDestination, (LONGLONG)exchange, (LONGLONG)comperand);
}
#else
template <class T> InterlockedStack<T> 
TxfInterlockedCompareExchange64(InterlockedStack<T>* pDestination, const InterlockedStack<T>& exchange, const InterlockedStack<T>& comperand)
{
	return (InterlockedStack<T>)TxfInterlockedCompareExchange64((LONGLONG*)pDestination, (LONGLONG)exchange, (LONGLONG)comperand);
}
#endif


////////////////////////////////////////////////////////////////////////////////////////
//
// IFastStack: Generic interface to the fast stack functionality. Allows for either
//             InterlockedStack or non-interlocked versions to be used transparently
//             by clients.
//
////////////////////////////////////////////////////////////////////////////////////////

template <class T>
struct IFastStack
{
    virtual ~IFastStack() {};
    virtual void Push(T* pt) = 0;
    virtual T*   Pop()       = 0;    
};


////////////////////////////////////////////////////////////////////////////////////////
//
// InterlockedStack
//
////////////////////////////////////////////////////////////////////////////////////////


template <class T>
struct InterlockedStack
// A class that supports the interlocked pushing and popping of singly-linked list.
// The parameterized type here, T, must have a pNext field which is the list linkage.
//
{

    union { // Force this structure as a whole to have eight byte alignment
        struct
        {
            T*      m_p;        // the client data of interest that we point to
            ULONG   m_n;        // the operation number used to interlock the push and pop action 
        };
        LONGLONG dummy;
    };

    void Init() 
    {
#ifdef _WIN64
        ASSERT((ULONGLONG)this % 8 == 0);   // We require eight byte alignment
#endif
        m_p = NULL;                     // We don't care what m_n is, and can so leave it uninitialized
    }
    InterlockedStack()
    {
        Init();
    }
    InterlockedStack(const InterlockedStack& him)
    {
        *this = him;
    }
    InterlockedStack(const LONGLONG& ll)
    {
        *(LONGLONG*)this = ll;
    }

    operator LONGLONG() const
    {
        return *(LONGLONG*)this;
    }

    void Push(T* pt)
        // Push a new T* onto the stack of which you are the top. Type T must have
        // a pNext member of type T* which is to be the list linkage.
    {
        
        InterlockedStack<T> comp, xchg;
        for (;;)
        {
            // Capture what we expect the list top to be
            //
            comp = *this;
            // 
            // Set up what we want the new list top to be
            //
            pt->pNext   = comp.m_p;        // link the list
            xchg.m_p    = pt;              //       ...
            xchg.m_n    = comp.m_n + 1;    // set the operation number expectation
            //
            // Try to atomically push the list
            //
            if (comp == TxfInterlockedCompareExchange64(this, xchg, comp))
            {
                // List top was what we expected it to be, the push happened, and we are done!
                //
                return;
            }
            //
            // Otherwise, continue around the loop until we can successfully push
            //
        }
    }

    T* Pop()
        // Pop the top element from the stack of which you are the list head
    {
        
        InterlockedStack<T> comp, xchg;
        for (;;)
        {
            // Capture what we expect the list top to be
            //
            comp = *this;

            if (NULL == comp.m_p)
            {
                // The stack is empty, nothing to return
                //
                return NULL;
            }
            else
            {
                // Set up what we expect the new list top to be
                //
                xchg.m_p = comp.m_p->pNext;     // unlink the list
                xchg.m_n = comp.m_n + 1;        // set the operation number expectation
                //
                // Try to pop the list
                //
                if (comp == TxfInterlockedCompareExchange64(this, xchg, comp))
                {
                    // List top was what we expected it to be. We popped!
                    //
                    comp.m_p->pNext = NULL;     // NULL it for safety's sake
                    return comp.m_p;
                }
                //
                // Otherwise, go around and try again
                //
            }
        }        
    }


};

template <class T>
struct InterlockedStackIndirect : IFastStack<T>
{
    // The ALPHA requires that stack be eight-byte aligned
    // in order that we can use InterlockedCompareExchange64 on it
    //
    InterlockedStack<T> stack;
    void Push(T* pt)    { stack.Push(pt); }
    T*   Pop()          { return stack.Pop(); }
};


////////////////////////////////////////////////////////////////////////////////////////
//
// LockingStack
//
// A stack that must use locks to get what it needs. Used in the absence of 
// interlocked compare exchange support. We only really need this on X86, as the other
// platforms all have the necessary interlocked support.
//
////////////////////////////////////////////////////////////////////////////////////////

template <class T>
struct LockingStack : IFastStack<T>
{
    T*      m_p;
    XLOCK   m_lock;

    LockingStack()
    {
        m_p = NULL;
    }

    BOOL FInit()
    {
        return m_lock.FInit();
    }

    void Push(T* pt)
    {
        m_lock.LockExclusive();
        pt->pNext = m_p;        // link the list
        m_p       = pt;         //    ...
        m_lock.ReleaseLock();
    }

    T* Pop()
    {
        T* ptReturn;
        
        m_lock.LockExclusive();
        ptReturn = m_p;

        if (NULL != m_p)
        {
            m_p = m_p->pNext;   // unlink the list
            ptReturn->pNext = NULL; // for safety's sake
        }

        m_lock.ReleaseLock();

        return ptReturn;
    }
};


////////////////////////////////////////////////////////////////////////////////////////
//
// CreateFastStack
//
// Create a fast stack, using the hardware support if possible.
//
////////////////////////////////////////////////////////////////////////////////////////

template <class T>
HRESULT CreateFastStack(IFastStack<T>** ppStack)
{
    HRESULT hr = S_OK;

    ASSERT(ppStack);

    // BUGBUG: Until we repair the LL/SC data structures for Win64,
    // we can't use the InterlockedStack
#ifndef _WIN64
    if (CanUseCompareExchange64())
    {
        *ppStack = new InterlockedStackIndirect<T>;
    }
    else
 #endif // _WIN64
    {
        *ppStack = new LockingStack<T>;
        if (*ppStack != NULL)
        {
        	if (((LockingStack<T>*)*ppStack)->FInit() == FALSE)
        	{
        		delete *ppStack;
        		*ppStack = NULL;
        	}
        }	
    }

    if (NULL == *ppStack)
        hr = E_OUTOFMEMORY;

    return hr;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\iunkinner.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// IUnkInner.h
//

interface IUnkInner
	{
	virtual HRESULT __stdcall InnerQueryInterface(REFIID iid, LPVOID* ppv) = 0;
 	virtual ULONG   __stdcall InnerAddRef() = 0;
 	virtual ULONG   __stdcall InnerRelease() = 0;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\concurrent.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Concurrent.h
//
#ifndef __CONCURRENT_H__
#define __CONCURRENT_H__

////////////////////////////////////////////////////////////////////////////////////////////
//
// EVENT - An event object.
//
////////////////////////////////////////////////////////////////////////////////////////////

class EVENT
{
    HANDLE m_hEvent;

public:
    EVENT(BOOL manualReset, BOOL fSignalled)
    {
        m_hEvent = NULL;
        Initialize(manualReset, fSignalled);
    }
    EVENT()
    {
        m_hEvent = NULL;
        ASSERT(!IsInitialized());
    }
    void Initialize(BOOL manualReset, BOOL fSignalled)
    {
        ASSERT(!IsInitialized());
        m_hEvent = CreateEvent(NULL, manualReset, fSignalled, NULL);
        if (m_hEvent == NULL) FATAL_ERROR();
        ASSERT(IsInitialized());
    }
    BOOL IsInitialized()
    {
        return m_hEvent != NULL;
    }

    ~EVENT()
    {
        if (m_hEvent) CloseHandle(m_hEvent); DEBUG(m_hEvent = NULL;);
    }

    NTSTATUS Wait(ULONG msWait = INFINITE)
    {
        ASSERT(IsInitialized());
        DWORD ret = WaitForSingleObject(m_hEvent, msWait);
        switch (ret)
        {
        case WAIT_TIMEOUT:  return STATUS_TIMEOUT;
        case WAIT_OBJECT_0: return STATUS_SUCCESS;
        default:            return STATUS_ALERTED;  // REVIEW
        }
    }

    void Set()
    {
        ASSERT(IsInitialized());
        SetEvent(m_hEvent);
    }

    void Reset()
    {
        ASSERT(IsInitialized());
        ResetEvent(m_hEvent);
    }

    HANDLE& GetHandle() { return m_hEvent; }
};

////////////////////////////////////////////////////////////////////////////////////////////
//
// SEMAPHORE - A user implementation of a semaphore
//
////////////////////////////////////////////////////////////////////////////////////////////
class SEMAPHORE
{
    HANDLE m_hSem;
    
public:
    SEMAPHORE(LONG count, LONG limit = MAXLONG)
    {
        m_hSem = NULL;
        Initialize(count, limit);
    }
    SEMAPHORE()
    {
        m_hSem = NULL;
    }
    void Initialize(LONG count = 0, LONG limit = MAXLONG)
    {
        m_hSem = CreateSemaphore(NULL, count, limit, NULL);
        if (m_hSem == NULL) 
            FATAL_ERROR();
    }
    BOOL IsInitialized()
    {
        return m_hSem != NULL;
    }
    ~SEMAPHORE()
    {
        if (m_hSem) 
            CloseHandle(m_hSem);
    }

    void Wait(ULONG msWait = INFINITE)
    {
        WaitForSingleObject(m_hSem, msWait);
    }

    void Release(ULONG count = 1)
    {
        ReleaseSemaphore(m_hSem, count, NULL);
    }
};

////////////////////////////////////////////////////////////////////////////////////////////
//
// Use these macros in your code to actually use this stuff. Declare a variable of type
// XSLOCK and name m_lock. Or invent your own variation on these macros and call the
// XSLOCK methods as you see fit.
//

#define __SHARED(lock)      (lock).LockShared();       __try {
#define __EXCLUSIVE(lock)   (lock).LockExclusive();    __try {
#define __DONE(lock)        } __finally { (lock).ReleaseLock(); }  
    
#define __SHARED__      __SHARED(m_lock)
#define __EXCLUSIVE__   __EXCLUSIVE(m_lock)
#define __DONE__        __DONE(m_lock)
    
    
////////////////////////////////////////////////////////////////////////////////////////////
//
// XLOCK - supports only exclusive locks. That is, it supports the LockExclusive() and ReleaseLock() 
//         methods (recursively) but does not support LockShared(). An XLOCK is recursively
//         acquirable.
//
////////////////////////////////////////////////////////////////////////////////////////////

//
// NOTE: This constructor can throw an exception when out of memory.
//
class XLOCK
{
    CRITICAL_SECTION critSec;
    BOOL m_fCsInitialized;

public:
    XLOCK() : m_fCsInitialized(FALSE) {}
    
    BOOL FInit()                      
    { 
        if (m_fCsInitialized == FALSE)
        {
            NTSTATUS status = RtlInitializeCriticalSection(&critSec);
            if (NT_SUCCESS(status))
                m_fCsInitialized = TRUE;
        }

        return m_fCsInitialized;
    }

    BOOL FInited() { return m_fCsInitialized; }
            
    ~XLOCK()
    {
        if (m_fCsInitialized == TRUE) 
        {
#ifdef _DEBUG
            NTSTATUS status =
#endif
              RtlDeleteCriticalSection(&critSec); // if RtlDeleteCriticalSection fails, tough luck--we leak. 
#ifdef _DEBUG                                     // But I'm asserting for it to see if we ever really hit it.
            ASSERT(NT_SUCCESS(status));
#endif
        }
    }

    BOOL LockExclusive(BOOL fWait=TRUE)    
    { 
        ASSERT(fWait); 
        VALIDATE(); 
        ASSERT(m_fCsInitialized == TRUE);
        EnterCriticalSection(&critSec); 
        return TRUE; 
    }

    void ReleaseLock()
    { 
        VALIDATE(); 
        ASSERT(m_fCsInitialized == TRUE);
        LeaveCriticalSection(&critSec);
    }
    
#ifdef _DEBUG
    BOOL WeOwnExclusive()   
    { 
        ASSERT(this);
        return 
          (THREADID)critSec.OwningThread == GetCurrentThreadId() &&  // that someone is us
          critSec.LockCount    >= 0;                       // is locked by someone
    }
    void VALIDATE()
    {
        ASSERT(critSec.LockCount != 0xDDDDDDDD);    // This is the memory pattern set by the debug memory allocator upon freeing
    }
#else
    void VALIDATE() { }
#endif
};


////////////////////////////////////////////////////////////////////////////////////////////
//
// XSLOCK - supports both exclusive and shared locks
// 
// This specification describes functionality that implements multiple-readers, 
// single-writer access to a shared resource.  Access is controlled via a shared resource 
// variable and a set of routines to acquire the resource for shared access (also commonly 
// known as read access) or to acquire the resource for exclusive access (also called 
// write access).
//
// A resource is logically in one of three states:
//  o   Acquired for shared access
//  o   Acquired for exclusive access
//  o   Released (i.e., not acquired for shared or exclusive access)
//
// Initially a resource is in the released state, and can be acquired for either shared or 
// exclusive access by a user.  
//
// A resource that is acquired for shared access can be acquired by other users for shared 
// access.  The resource stays in the acquired for shared access state until all users that 
// have acquired it have released the resource, and then it becomes released.  Each resource, 
// internally, maintains information about the users that have been granted shared access.
//
// A resource that is acquired for exclusive access cannot be acquired by other users until 
// the single user that has acquired the resource for exclusive access releases the resource.  
// However, a thread can recursively acquire exclusive access to the same resource without blocking.
//
// The routines described in this specification do not return to the caller until the 
// resource has been acquired.
//
// NOTE: The constructor for XSLOCK can throw an exception when out of memory, as it
//       contains an XLOCK, which contains a critical section.
//
class XSLOCK
{
    struct OWNERENTRY
    {
        THREADID dwThreadId;
        union
        {
            LONG    ownerCount;                     // normal usage
            ULONG   tableSize;                      // only in entry m_ownerTable[0]
        };
        
        OWNERENTRY()
        {
            dwThreadId = 0;
            ownerCount = 0;
        }
    };

    XLOCK               m_lock;                     // controls access during locks & unlocks
    ULONG               m_cOwner;                   // how many threads own this lock
    OWNERENTRY          m_ownerThreads[2];          // 0 is exclusive owner; 1 is first shared. 0 can be shared in demote case
    OWNERENTRY*         m_ownerTable;               // the rest of the shared
    EVENT               m_eventExclusiveWaiters;    // the auto-reset event that exclusive guys wait on
    SEMAPHORE           m_semaphoreSharedWaiters;   // what shared guys wait on
    ULONG               m_cExclusiveWaiters;        // how many threads are currently waiting for exclusive access?
    ULONG               m_cSharedWaiters;           // how many threads are currently waiting for shared access?
    BOOL                m_isOwnedExclusive;         // whether we are at present owned exclusively
    
    BOOL            IsSharedWaiting();
    BOOL            IsExclusiveWaiting();
    OWNERENTRY*     FindThread      (THREADID dwThreadId);
    OWNERENTRY*     FindThreadOrFree(THREADID dwThreadId);
    void            LetSharedRun();
    void            LetExclusiveRun();
    void            SetOwnerTableHint(THREADID dwThreadId, OWNERENTRY*);
    ULONG           GetOwnerTableHint(THREADID dwThreadId);

    void            LockEnter();
    void            LockExit();

#ifdef _DEBUG
    void            CheckInvariants();
    BOOL            fCheckInvariants;
#endif

public:
    XSLOCK();
    ~XSLOCK();

    ////////////////////////////////////////////////////////////////////
    //
    // 2-phase construction. You must call FInit for an XSLOCK object to be
    // ready for use. Returns TRUE if initialization successful, otherwise FALSE.
    //
    BOOL FInit() { return m_lock.FInit(); }

    ////////////////////////////////////////////////////////////////////
    //
    // Lock for shared access. Shared locks may be acquired recursively,
    // (as can exclusive locks). Further, many threads can simultaneously
    // hold a shared lock, but not concurrently with any exclusive locks.
    // However, it _is_ permissible for the one thread which holds an 
    // exclusive lock to attempt to acquire a shared lock -- the shared lock 
    // request is automatically turned into a (recursive) exclusive lock 
    // request.
    //
    BOOL LockShared(BOOL fWait=TRUE);

    ////////////////////////////////////////////////////////////////////
    //
    // Lock for exclusive access. Exclusive locks may be acquired
    // recursively. At most one thread can hold concurrently hold an
    // exclusive lock.
    //
    BOOL LockExclusive(BOOL fWait=TRUE);

    ////////////////////////////////////////////////////////////////////
    //
    // Release the lock that this thread most recently acquired.
    //
    void ReleaseLock();

    ////////////////////////////////////////////////////////////////////
    //
    // Promote a shared lock to exlusive access. Similar in function to releasing a 
    // shared resource and then acquiring it for exclusive access; however, in the 
    // case where only one user has the resource acquired with shared access, the 
    // conversion to exclusive access with Promote can perhaps be more efficient.
    //
    void Promote()
    {
        ReleaseLock();
        LockExclusive();
    }

    ////////////////////////////////////////////////////////////////////
    //
    // Demote an exclusive lock to shared access. Similar in function to releasing an
    // exclusive resource and then acquiring it for shared access; however the user  
    // calling Demote probably does not relinquish access to the resource as the two 
    // step operation does.
    //
    void Demote();


    ////////////////////////////////////////////////////////////////////
    //
    // This routine determines if a resource is acquired exclusive by the
    // calling thread
    //
    BOOL WeOwnExclusive();

    ////////////////////////////////////////////////////////////////////
    //
    // This routine determines if a resource is acquired shared by the calling thread
    //
    BOOL WeOwnShared();
};


////////////////////////////////////////////////////////////////////////////////////////////
//
// XLOCK_LEAF - An exclusive lock that is NOT recursively acquirable, yet in kernel mode 
//              doesn't mess with your irql. You can take page faults while holding an
//              XLOCK_LEAF.
//
////////////////////////////////////////////////////////////////////////////////////////////
//
// User mode implementation of leaf locks just uses XLOCK, but checks to ensure
// that we're not acquiring recursively for compatibility with kernel mode.
//
struct XLOCK_LEAF : public XLOCK
{
    BOOL LockExclusive(BOOL fWait = TRUE)
    {
        ASSERT(!WeOwnExclusive());
        return XLOCK::LockExclusive(fWait);
    } 
};

//
////////////////////////////////////////////////////////////////////////////////////////////

#endif // #ifndef __CONCURRENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\linkable.h ===
/* -----------------------------------------------------------------------
   Microsoft Application Server (Microsoft Confidential)
   Copyright 1997 Microsoft Corporation.  All Rights Reserved.

   @rev 0 | 3/23/97 | jimbo | Sherpa-M3
   ----------------------------------------------------------------------- */

#ifndef _LINKABLE_H_
#define _LINKABLE_H_

#include <windows.h>

//
// Class -- CLinkable
//		Base class for objects that can be placed onto cheap circular doubly-linked lists.
//
class CLinkable
{
public:

	// Constructor
	CLinkable() { m_pNext = m_pPrev = this; }

	// Destructor
	~CLinkable() { Remove(); }

	// return TRUE iff on a list
	BOOL			IsLinked() { return ( m_pNext != this ); }

	// return next element on list
	CLinkable*		Next() { return m_pNext; }

	// return previous element on list
	CLinkable*		Previous() { return m_pPrev; }

	// insert parameter onto list after this, removing it first if necessary
	void			InsertAfter( CLinkable* other );

	// insert parameter onto list before this, removing it first if necessary
	void			InsertBefore( CLinkable* other );

	// remove us from list, if any
	void			Remove();

private:
	CLinkable*		m_pNext;		// next element on list
	CLinkable*		m_pPrev;		// previous element on list
};


//
// Class - CListHeader
//		List header for list of CLinkable's. This is merely a CLinkable with
//		some methods renamed for better readability.
//
class CListHeader : public CLinkable
{

public:

	// Constructor
	CListHeader() {}

	// Destructor
	~CListHeader() {};

	// return TRUE iff list is empty
	BOOL			IsEmpty()	{ return !IsLinked(); }

	// return first element on list
	CLinkable*		First()		{ return Next(); }

	// return last element on list
	CLinkable*		Last()		{ return Previous(); }

	// insert parameter at head of list
	void			InsertFirst ( CLinkable* other )	{ InsertAfter( other ); }

	// insert parameter at tail of list
	void			InsertLast ( CLinkable* other )		{ InsertBefore( other ); }
};

#endif _LINKABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\txfcommon.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfcommon.h
//

#include "txfdebug.h"
#include "txfmalloc.h"
#include "txfutil.h"
#include "concurrent.h"
#include "lookaside.h"
#include "IUnkInner.h"
#include "GenericClassFactory.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\oainternalrep.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// oaInternalRep.h
//
// Internal in-memory representations of OLE Automation data types

//////////////////////////////////////////////////////////////////////////
//
// BSTR
//
#pragma warning ( disable : 4200 ) // nonstandard extension used : zero-sized array in struct/union

//
// If one of these assertions fails, you will get a compiler error (C2118) about the subscript being bad.
//
#ifndef C_ASSERT
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#endif

struct BSTR_INTERNAL
{
private:
    ULONG cbPayload;
    WCHAR sz[];

public:
    BSTR_INTERNAL(ULONG cch)
    {
        cbPayload = cch * sizeof(WCHAR);
    }

    ULONG  Cch()     { return cbPayload / sizeof(WCHAR); }
    ULONG  Cb()      { return cbPayload;                 }
    WCHAR* Sz()      { return &sz[0];                    }
    ULONG  CbAlloc() { return (ULONG) CbFor(Cch());      }

    static BSTR_INTERNAL* From(BSTR bstr)
    {
        return bstr ? CONTAINING_RECORD(bstr, BSTR_INTERNAL, sz) : NULL;
    }

private:
    
    static size_t CbFor(size_t cch)
    {
        return sizeof(BSTR_INTERNAL) + (cch+1) * sizeof(WCHAR);
    }
};

//////////////////////////////////////////////////////////////////////////
//
// SAFEARRAY
//
struct SAFEARRAY_INTERNAL
{
    //////////////////////////////////////////////////////////
    //
    // State
    //
    //////////////////////////////////////////////////////////

    // See SafeArrayAllocDescriptor in oa\src\dispatch\sarray.cpp. An extra
    // GUID-sized-space is always allocated at the start.
    //
    union 
    {
        IID                 iid;

        struct
        {
            LONG            __dummy0[3];
            LONG            vt;
        };

        struct
        {
            // ::sigh:: There are 16 bytes before the pointer,
            // but the end of the valid part is always flush
            // with the SAFEARRAY structure.  Thus, we need to
            // pad according to the size of a pointer.
#ifdef _WIN64
            DWORD           __dummy1[2];
#else
            DWORD           __dummy1[3];
#endif
            IRecordInfo*    piri;
        };
    };

    SAFEARRAY array;

    //////////////////////////////////////////////////////////
    //
    // Operations
    //
    //////////////////////////////////////////////////////////

    SAFEARRAY* psa() { return &array; }

    SAFEARRAY_INTERNAL(UINT cDims)
    {
        ZeroMemory(this, CbFor(cDims));
        array.cDims = (USHORT)(cDims);
    }

    static SAFEARRAY_INTERNAL* From(SAFEARRAY* psa)
    {        
        return CONTAINING_RECORD(psa, SAFEARRAY_INTERNAL, array);
    }

private:
    
    static size_t CbFor(UINT cDims)
    {
        return sizeof(SAFEARRAY_INTERNAL) + (cDims-1u) * sizeof(SAFEARRAYBOUND);
    }
};

//
// If one of these assertions fails, you will get a compiler error (C2118) about the subscript being bad.
//
// The allocation before a SAFEARRAY is exactly 16 bytes, so make sure we don't
// get messed up by padding or something else.
C_ASSERT(sizeof(SAFEARRAY_INTERNAL) == (sizeof(SAFEARRAY)+16));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\registry.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// registry.h
//
extern "C" {

//////////////////////////////////////////////////////////////////////
//
// Open / create
//

typedef struct HREG {
    HANDLE h;

    HREG() { h = NULL; }

    } HREG;

HRESULT OpenRegistryKey(
        HREG*       phkey,                      // place to return new key
        HREG        hKeyParent OPTIONAL,        // parent key to open under. may be NULL.
        LPCWSTR     wszKeyName,                 // child key name
        DWORD       dwDesiredAccess=KEY_READ,   // read, write, etc 
        BOOL        fCreate=FALSE               // whether to force creation or not
        );

HRESULT EnumerateRegistryKeys(
        HREG        hkey,
        ULONG       index,
        LPWSTR*     pwsz);

inline HRESULT CreateRegistryKey(HREG* pNewKey, HREG hkeyParent, LPCWSTR wszKeyName)
    {
    return OpenRegistryKey(pNewKey, hkeyParent, wszKeyName, KEY_WRITE, TRUE);
    }

inline void CloseRegistryKey(HREG hKey)
    {
    ZwClose(hKey.h);
    }

inline HRESULT DeleteRegistryKey(HREG hKey)
    {
    NTSTATUS status = ZwDeleteKey(hKey.h);
    return HrNt(status);
    }

inline HRESULT DeleteRegistryValue(HREG hKey, LPCWSTR wszValueName)
    {
    UNICODE_STRING u;
    RtlInitUnicodeString(&u, wszValueName);
    NTSTATUS status = ZwDeleteValueKey(hKey.h, &u);
    return HrNt(status);
    }

//////////////////////////////////////////////////////////////////////
//
// Retrieval
//

HRESULT GetRegistryValue(HREG hkey, LPCWSTR wszValueName, PKEY_VALUE_FULL_INFORMATION *ppinfo, ULONG expectedType);
HRESULT DoesRegistryValueExist(HREG hkey, LPCWSTR wszValue);

inline LPWSTR StringFromRegInfo(PKEY_VALUE_FULL_INFORMATION pinfo)
    {
    ASSERT(pinfo->Type == REG_SZ || pinfo->Type == REG_EXPAND_SZ);
    return (LPWSTR)((BYTE*)pinfo + pinfo->DataOffset);
    }

}

//////////////////////////////////////////////////////////////////////
//
// Setting
//
HRESULT __cdecl SetRegistryValue(HREG hkey, LPCWSTR wszValueName, ...);

inline HRESULT SetRegistryValue(HREG hkey, LPCWSTR wszValueName, LPCWSTR wsz)
    {
    return SetRegistryValue(hkey, wszValueName, wsz, NULL);
    }

//////////////////////////////////////////////////////////////////////
//
// Helper routines
//
extern "C" HRESULT RegisterInterfaceName(REFIID iid, LPCWSTR wszInterfaceName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\lookaside.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// lookaside.h
//
// (A curious historically-based name for this header. A more apt name might be something
// like hashtable.h or something.)
//
// Contains a hash table implemention with several interesting features:
//
//  1) is template based in the key and value types, providing strong typing
//  2) associates a lock with the table for ease and convenience
//

#ifndef __LOOKASIDE_H__
#define __LOOKASIDE_H__

#include "concurrent.h"
#include "txfdebug.h"               
#include "map_t.h"
#include "clinkable.h"

///////////////////////////////////////////////////////////////////////////////////
//
// A memory allocator for use with the hash table in map_t.h. Said table assumes
// that memory allocation always succeeds; here, we turn failures into a throw
// that we'll catch in our MAP wrapper's routines.
//
///////////////////////////////////////////////////////////////////////////////////

#if _MSC_VER >= 1200
#pragma warning (push)
#pragma warning (disable : 4509)
#endif

struct AllocateThrow
{
    void* __stdcall operator new(size_t cb)
    {
        PVOID pv = CoTaskMemAlloc(cb);
        ThrowIfNull(pv);
        return pv;
    }

private:

    static void ThrowIfNull(PVOID pv)
    {
        if (NULL == pv)
        {
            ThrowOutOfMemory();
        }
    }
};

inline int CatchOOM(ULONG exceptionCode)
{
    return exceptionCode == STATUS_NO_MEMORY ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
}


///////////////////////////////////////////////////////////////////////////////////
//
// A wrapper for the hashing class that (for historical reasons, mostly) delegates
// the hashing to the object in question.
// 
///////////////////////////////////////////////////////////////////////////////////

template <class D> struct MAP_HASHER
{
    static HASH Hash(const D& d)
    {
        return d.Hash();
    }
    
    static BOOL Equals(const D& d1, const D& d2)
    {
        return d1 == d2;
    }
};

#pragma warning ( disable : 4200 )  // nonstandard extension used : zero-sized array in struct/union



///////////////////////////////////////////////////////////////////////////////////
//
// The hash table itself
//
///////////////////////////////////////////////////////////////////////////////////

template<class LOCK_T, class KEY_T, class VALUE_T>
class MAP
{
    /////////////////////////////////////////////////////////////////////////////
    //
    // Lock management
    //
    /////////////////////////////////////////////////////////////////////////////
protected:

    LOCK_T m_lock;  // normally will be some form of indirect lock because of paging requirements

public:
    BOOL LockExclusive(BOOL fWait=TRUE)   
    {
        ASSERT(m_fCsInitialized == TRUE);
        if (m_fCsInitialized)
            return m_lock.LockExclusive(fWait); 
        else
            return FALSE;
    }
    
    void ReleaseLock()
    {
        ASSERT(m_fCsInitialized == TRUE);
        if (m_fCsInitialized)
            m_lock.ReleaseLock();
    }

#ifdef _DEBUG
    BOOL WeOwnExclusive()
    {
        ASSERT(m_fCsInitialized == TRUE);
        if (m_fCsInitialized)
            return m_lock.WeOwnExclusive();     
        return FALSE;
    }
#endif

    /////////////////////////////////////////////////////////////////////////////
    //
    // Operations
    //
    /////////////////////////////////////////////////////////////////////////////
public:

    // This function must be called and return TRUE to use any functions in this class.
    virtual BOOL FInit()
    {
        if (m_fCsInitialized == FALSE)
            m_fCsInitialized = m_lock.FInit();
        return m_fCsInitialized;
    }
    
    BOOL IsEmpty() const 
    { 
        return Size() == 0;   
    }

    ULONG Size() const 
    { 
        return m_map.count(); 
    }

    BOOL Lookup(const KEY_T& key, VALUE_T* pvalue) const
    {
        return m_map.map(key, pvalue);
    }

    BOOL IncludesKey(const KEY_T& key) const
    {
        return m_map.contains(key);
    }

    BOOL SetAt(const KEY_T& key, const VALUE_T& value)
    {
        __try 
          {
              m_map.add(key, value);

#ifdef _DEBUG
              ASSERT(IncludesKey(key));
              //
              VALUE_T val;
              ASSERT(Lookup(key, &val));
              ASSERT(val == value);
#endif
          }
        __except(CatchOOM(GetExceptionCode()))
          {
              return FALSE;
          }
        return TRUE;
    }
    
    void RemoveKey(const KEY_T& key)
    {
        m_map.remove(key);
        ASSERT(!IncludesKey(key));
    }
    
    void RemoveAll()
    {
        m_map.reset();
    }

    /////////////////////////////////////////////////////////////////////////////
    //
    // Construction & copying
    //
    /////////////////////////////////////////////////////////////////////////////

    MAP() : m_fCsInitialized(FALSE)
    {
    }

    MAP(unsigned initialSize) : m_map(initialSize), m_fCsInitialized(FALSE)
    {
        FInit();
    }

    MAP* Copy()
    // Return a second map which is a copy of this one
    {
        MAP* pMapNew = new MAP(this->Size());
        if (pMapNew && pMapNew->FInit() == FALSE)
        {
            delete pMapNew;
            pMapNew = NULL;
        }
        
        if (pMapNew)
        {
            BOOL fComplete = TRUE;
            iterator itor;
            for (itor = First(); itor != End(); itor++)
            {
                if (pMapNew->SetAt(itor.key, itor.value))
                {
                }
                else
                {
                    fComplete = FALSE;
                    break;
                }
            }
            if (fComplete) 
                return pMapNew;
        }
        
        if (pMapNew)
            delete pMapNew;
        return NULL;
    }

    /////////////////////////////////////////////////////////////////////////////
    //
    // Iteration
    //
    /////////////////////////////////////////////////////////////////////////////
public:
    typedef MAP_HASHER<KEY_T> HASHER;
    //
    //
    //
    class iterator 
    //
    //
    {
        friend class MAP<LOCK_T, KEY_T, VALUE_T>;

        EnumMap<KEY_T, VALUE_T, HASHER, AllocateThrow >   m_enum;
        BOOL                                              m_fDone;
        KEY_T*                                            m_pkey;
        VALUE_T*                                          m_pvalue;
        Map<KEY_T, VALUE_T, HASHER, AllocateThrow >*      m_pmap;

    public:
        // Nice friendly data-like names for the keys and values being enumerated
        // 
        __declspec(property(get=GetKey))   KEY_T&   key;
        __declspec(property(get=GetValue)) VALUE_T& value;

        void Remove()
          // Remove the current entry, advancing to the subsequent entry in the interation
        {
            ASSERT(!m_fDone);
            m_pmap->remove(key);
            (*this)++;
        }
        
        void operator++(int postfix)
          // Advance the iteration forward
        {
            ASSERT(!m_fDone);
            if (m_enum.next())
            {
                m_enum.get(&m_pkey, &m_pvalue);
            }
            else
                m_fDone = TRUE;
        }

        BOOL operator==(const iterator& itor) const
        { 
            return m_pmap==itor.m_pmap && (m_fDone ? itor.m_fDone : (!itor.m_fDone && m_enum==itor.m_enum)); 
        }
        BOOL operator!=(const iterator& itor) const
        { 
            return ! this->operator==(itor); 
        }

        iterator& operator= (const iterator& itor)
        {
            m_enum   = itor.m_enum;
            m_fDone  = itor.m_fDone;
            m_pkey   = itor.m_pkey;
            m_pvalue = itor.m_pvalue;
            m_pmap   = itor.m_pmap;
            return *this;
        }

        KEY_T&   GetKey()   { return *m_pkey; }
        VALUE_T& GetValue() { return *m_pvalue; }

        iterator() 
        { 
            /* leave it uninitialized; initialize in First() or End() */ 
        }

        iterator(Map<KEY_T, VALUE_T, HASHER, AllocateThrow>& map)
          : m_enum(map)
        {
            m_pmap = &map;
        }

    };

    iterator First()
    {
        iterator itor(this->m_map);
        itor.m_fDone = FALSE;
        itor++;
        return itor;
    }

    iterator End()
    {
        iterator itor(this->m_map);
        itor.m_fDone = TRUE;
        return itor;
    }


protected:
    Map<KEY_T, VALUE_T, HASHER, AllocateThrow> m_map;
    BOOL m_fCsInitialized;
};


///////////////////////////////////////////////////////////////////////////////////

//
// NOTE: The constructor of this object, and thus the constructor of objects derived 
//       from this, can throw an exception, beause it contains an XSLOCK (which contains
//       an XLOCK, which contains a critical section).
//
template<class KEY_T, class VALUE_T>
struct MAP_SHARED : MAP<XSLOCK, KEY_T, VALUE_T>
{
    BOOL LockShared(BOOL fWait=TRUE) 
    {
        ASSERT(m_fCsInitialized == TRUE); // should not be called if critsec not initialized
        if (m_fCsInitialized)
            return m_lock.LockShared(fWait); 
        return FALSE;
    }
    
#ifdef _DEBUG
    BOOL WeOwnShared()           
    { 
        ASSERT(m_fCsInitialized == TRUE); // should not be called if critsec not initialized
        if (m_fCsInitialized)
            return m_lock.WeOwnShared();     
        return FALSE;
    }
#endif

    /////////////////////////////////////////////////////////////////////////////
    //
    // Construction & copying
    //
    /////////////////////////////////////////////////////////////////////////////

    MAP_SHARED()
    {
    }

    MAP_SHARED(unsigned initialSize) : MAP<XSLOCK, KEY_T, VALUE_T>(initialSize)
    {
    }

    MAP_SHARED* Copy()
    {
        return (MAP_SHARED*)(void*) MAP<XSLOCK, KEY_T, VALUE_T>::Copy();
    }
};


///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
//
// Hashing support
//
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
//
// A wrapper for GUIDs
//
///////////////////////////////////////////////////////////////////////////////////

class MAP_KEY_GUID
{
public:
    GUID    guid;

    MAP_KEY_GUID()                                  {                }
    MAP_KEY_GUID(const GUID& g)                     { guid = g;      }
    MAP_KEY_GUID(const MAP_KEY_GUID& w)             { guid = w.guid; }

    operator GUID()                                 { return guid; }
    operator GUID&()                                { return guid; }

    MAP_KEY_GUID& operator=(const MAP_KEY_GUID& h)  { guid = h.guid; return *this; }
    MAP_KEY_GUID& operator=(const GUID& g)          { guid = g;      return *this; }

    ULONG Hash() const
      // Hash the GUID
    { 
        return *(ULONG*)&guid * 214013L + 2531011L;
    }
    
    BOOL operator==(const MAP_KEY_GUID& him) const  { return (*this).guid == him.guid; }
    BOOL operator!=(const MAP_KEY_GUID& him) const  { return ! this->operator==(him);  }
};

#if _MSC_VER >= 1200
#pragma warning (pop)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\map_t.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#pragma once

#include <enum_t.h>
#include <Linkable.h>


typedef unsigned long HASH;

//
// Several common Hasher classes: HashGUID, HashWSTR, HashInt, HashVoidPtr
//
class HashGUID {
    // "The best hash of a GUID is its first word" -- jimbo
public:
    static HASH Hash(const GUID& g) { return *(unsigned long*)&g; }
	static BOOL Equals(const GUID& g1, const GUID& g2) { return g1 == g2; }
};

class HashWSTR {
public:
	static HASH Hash(const WCHAR* pwc) {
		unsigned long hash = 0x01234567;
		while (*pwc) hash = (hash << 5) + (hash >> 27) + *pwc++;
		return hash;
	}
	static BOOL Equals(const WCHAR* pwc1, const WCHAR* pwc2) { 
		if (pwc1 == pwc2) return TRUE;
		if (!pwc1 || !pwc2) return FALSE;
		while (*pwc1 == *pwc2) {
			if (*pwc1 == 0) return TRUE;
			pwc1++, pwc2++;
		}
		return FALSE;
	}
};

class HashInt {
public:
	static HASH Hash(int i) { return i; }
	static BOOL Equals(int i, int j) { return i == j; }
};

class HashVoidPtr {
public:
	static HASH Hash(const void* pv) { return PtrToUlong(pv); }
	static BOOL Equals(const void* pv1, const void* pv2) { return pv1 == pv2; }
};

// empty class used as default base
class EmptyMapBase {};

// fwd decl template enum class used as friend
template <class D, class R, class H, class Base> class EnumMap;

//
// Map class
// Map<D,R,H> defines a hash table that maps from instances of 'D' to instances of 'R',
// using hashing class H.
// Map<D,R,H,Base> does the same thing, except that memory allocators are inherited from 'Base'.
//
// Class H should contain methods compatible with the following:
//		static HASH Hash(D);
//		static BOOL Equals(D,D);
//		if you prefer, any of the D's above can be "D&", "const D" or "const D&".
//
// If a 'Base' class is defined, it should contain nothing but "operator new" and "operator delete".
// So far as the present code is concerned, it is explicitly OK for said "operator new" to throw on 
// OOM. One must, of course, also understand if clients are expecting such behaviour.

template <class D, class R, class H, class Base=EmptyMapBase>
class Map : public Base {	// map from Domain type to Range type
public:
	Map(unsigned cBucketsInitial =17);
	~Map();

	// Remove all elements from the table
	void reset();

	// Find mapping for 'd' if any. If found, sets *pr. Return TRUE iff found.
	BOOL map (const D& d, R* pr) const;

	// Find mapping for 'd' if any. If found, sets *ppr. Return TRUE iff found.
	BOOL map (const D& d, R** ppr) const;

	// Return TRUE iff mapping for 'd' exists. If 'pd' supplied, also return a copy
	// of the 'd' that is mapped. (When we return TRUE, H::Equals(d,*pd) is true, but
	// not necessarily d==*pd).
	BOOL contains (const D& d, D* pd=NULL) const;

	// Add new mapping for 'd' -> 'r'. Delete previous mapping for 'd' if any.
	void add (const D& d, const R& r);
	
	// Remove mapping for 'd' if any.
	void remove (const D& d);

	// Return number of entries currently mapped.
	unsigned count() const;

	// If mapping for 'd' already exists, set *prFound to the mapped value and return FALSE.
	// Otherwise, add mapping for 'd' -> 'r', set *prFound = r, and return TRUE.
	BOOL addIfAbsent (const D& d, const R& r, R* prFound);

	// Perform internal consistency checks. Return TRUE iff hash table is healthy.
	BOOL invariants();

private:
	class Assoc : private CLinkable {
	private:
		Assoc* m_pAssocNext;
		long m_lcUse;
		D m_d;
		R m_r;

		Assoc (const D& d, const R& r) : m_pAssocNext(NULL), m_lcUse(0), m_d(d), m_r(r) {}
		BOOL isPresent() const	{ return m_lcUse < 0; }
		void setPresent()		{ m_lcUse |= 0x80000000; }
		void clearPresent()		{ m_lcUse &= 0x7FFFFFFF; }
		void* operator new (size_t n, Assoc* p) { return p; }	// for re-initializing a previously allocated Assoc
		friend class Map<D,R,H,Base>;
		friend class EnumMap<D,R,H,Base>;
	};

	Assoc** m_rgpAssoc;		// hash buckets. Linked list of elements (through Assoc::m_pAssocNext) that hash to the same value.
	unsigned m_cAssoc;		// number of hash buckets.
	unsigned m_cPresent;	// number of currently mapped entries.
	Assoc* m_pAssocFree;	// linked list (through Assoc::m_pAssocNext) of unused elements.
	CListHeader m_listInUse; // doubly linked list (through CLinkable) of elements that are either mapped, or referred to by an enumerator.

	// Find mapping for 'd'. If found, set *pppAssoc to the pointer to the pointer to the mapping element, and return TRUE.
	// If not found, set *pppAssoc to the pointer to where to store a pointer to a mapping element if you're going to create one, and return FALSE.
	BOOL find (const D& d, Assoc*** pppAssoc) const;

	// Rehash, using a number of buckets which is larger than the current number of elements.
	void grow ();

	// Create a new mapping for 'd' -> 'r', linking it into the linked list at 'ppAssoc'.
	void newAssoc (const D& d, const R& r, Assoc** ppAssoc);

	// Add an enumerator's reference to an Assoc.
	void addRefAssoc (Assoc* pAssoc);

	// Remove an enumerator's reference to an Assoc.
	void releaseAssoc (Assoc* pAssoc);

	// "Free" an Assoc (put it onto our free list).
	void freeAssoc (Assoc* pAssoc);

	friend class EnumMap<D,R,H,Base>;
};


template <class D, class R, class H, class Base> inline
Map<D,R,H,Base>::Map(unsigned cBucketsInitial)
:
	m_rgpAssoc(NULL),
	m_cAssoc(cBucketsInitial > 0 ? cBucketsInitial : 17),
	m_cPresent(0),
	m_pAssocFree(NULL)
{
	m_rgpAssoc = (Assoc**) operator new (sizeof(Assoc*) * m_cAssoc);	// uses Base::operator new, if any
	for (unsigned i = 0; i < m_cAssoc; i++)
		m_rgpAssoc[i] = NULL;
}

template <class D, class R, class H, class Base> inline
Map<D,R,H,Base>::~Map() {
	Assoc* pAssoc;

	while (!m_listInUse.IsEmpty()) {
		pAssoc = (Assoc*) m_listInUse.First();
		delete pAssoc;
	}

	while (m_pAssocFree != NULL) {
		pAssoc = m_pAssocFree;
		m_pAssocFree = pAssoc->m_pAssocNext;
		operator delete (pAssoc);	// uses Base::operator delete, if any
	}

	operator delete (m_rgpAssoc);	// uses Base::operator delete, if any
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::reset() {
	Assoc* pAssoc;
	CLinkable* pLinkable;

	pLinkable = m_listInUse.First();
	while (pLinkable != &m_listInUse) {
		pAssoc = (Assoc*)pLinkable;
		pLinkable = pLinkable->Next();
		pAssoc->clearPresent();
		if (pAssoc->m_lcUse == 0) {
			freeAssoc (pAssoc);
		}
	}

	for (unsigned i = 0; i < m_cAssoc; i++) {
		m_rgpAssoc[i] = NULL;
	}
	m_cPresent = 0;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::map (const D& d, R* pr) const {
	R* pr2;
	if (map(d, &pr2)) {
		*pr = *pr2;
		return TRUE;
	}
	return FALSE;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::map (const D& d, R** ppr) const {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		*ppr = &(*ppAssoc)->m_r;
		return TRUE;
	}
	else
		return FALSE;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::contains (const D& d, D* pd) const {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		if (pd) *pd = (*ppAssoc)->m_d;
		return TRUE;
	}
	else {
		return FALSE;
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::add (const D& d, const R& r) {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		// some mapping d->r2 already exists, replace with d->r
		(*ppAssoc)->m_d = d;
		(*ppAssoc)->m_r = r;
	}
	else {
		newAssoc(d,r,ppAssoc);
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::remove (const D& d) {
	Assoc** ppAssoc;
	Assoc* pAssoc;
	if (find(d, &ppAssoc)) {
		pAssoc = *ppAssoc;
		*ppAssoc = pAssoc->m_pAssocNext;

		pAssoc->clearPresent();
		if (pAssoc->m_lcUse == 0) {
			freeAssoc (pAssoc);
		}

		m_cPresent--;
	}
}

// Return the count of elements
template <class D, class R, class H, class Base> inline
unsigned Map<D,R,H,Base>::count() const {
	return m_cPresent;
}

// Lookup at d.
// If absent, return TRUE
// In any case, establish *prFound.
template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::addIfAbsent(const D& d, const R& r, R* prFound) {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		// some mapping d->r2 already exists; return r2
		*prFound = (*ppAssoc)->m_r;
		return FALSE;
	}
	else {
		// establish a new mapping d->r in the first unused entry
		newAssoc(d,r,ppAssoc);
		*prFound = r;
		return TRUE;
	}
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::invariants() {
	Assoc* pAssoc;
	Assoc** ppAssoc;
	CLinkable* pLinkable;
	unsigned cPresent = 0;

#define INVARIANTASSERT(x) { if (!(x)) { DebugBreak(); return FALSE; } }

	// Verify each Assoc on the inuse list
	for (pLinkable = m_listInUse.First(); pLinkable != &m_listInUse; pLinkable = pLinkable->Next()) {
		pAssoc = (Assoc*) pLinkable;
		INVARIANTASSERT (pAssoc == ((Assoc*)pLinkable->Next())->Previous());
		INVARIANTASSERT (pAssoc->m_lcUse != 0);
		find (pAssoc->m_d, &ppAssoc);
		if (pAssoc->isPresent()) {
			cPresent++;
			INVARIANTASSERT (pAssoc == *ppAssoc);
		}
		else {
			INVARIANTASSERT (pAssoc != *ppAssoc);
		}
	}
	INVARIANTASSERT (m_cPresent == cPresent);

	// Verify each Assoc on the hash lists
	cPresent = 0;
	for (unsigned i = 0; i < m_cAssoc; i++) {
		for (pAssoc = m_rgpAssoc[i]; pAssoc != NULL; pAssoc = pAssoc->m_pAssocNext) {
			INVARIANTASSERT (pAssoc != pAssoc->Next());
			INVARIANTASSERT (pAssoc->isPresent());
			find (pAssoc->m_d, &ppAssoc);
			INVARIANTASSERT (pAssoc == *ppAssoc);
			cPresent++;
		}
	}
	INVARIANTASSERT (m_cPresent == cPresent);

	// Verify each Assoc on the free list
	for (pAssoc = m_pAssocFree; pAssoc != NULL; pAssoc = pAssoc->m_pAssocNext) {
		INVARIANTASSERT (pAssoc == pAssoc->Next());
		INVARIANTASSERT (pAssoc->m_lcUse == 0);
	}

#undef INVARIANTASSERT
	return TRUE;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::find (const D& d, Assoc*** pppAssoc) const {  
	unsigned h		= H::Hash(d) % m_cAssoc;

	*pppAssoc = &m_rgpAssoc[h];
	for (;;) {
		if (**pppAssoc == NULL)
			return FALSE;
		else if (H::Equals((**pppAssoc)->m_d,d))
			return TRUE;
		else
			*pppAssoc = &(**pppAssoc)->m_pAssocNext;
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::grow () {
	CLinkable* pLinkable;
	Assoc* pAssoc;
	Assoc** ppAssoc;
	unsigned i;

	static unsigned int rgprime[] = { 17, 37, 79, 163, 331, 673, 1361, 2729, 5471, 10949,
		21911, 43853, 87719, 175447, 350899, 701819, 1403641, 2807303, 5614657, 11229331,
		22458671, 44917381, 89834777, 179669557, 359339171, 718678369, 1437356741, 2874713497 };

	operator delete(m_rgpAssoc);	// uses Base::operator delete, if any
    m_rgpAssoc = NULL;              // in case the 'new' below throws, and we end up in our dtor

	for (i = 0; m_cPresent >= rgprime[i]; i++) /*nothing*/ ;
	m_rgpAssoc = (Assoc**)operator new(sizeof(Assoc*) * rgprime[i]);	// uses Base::operator new, if any
	m_cAssoc = rgprime[i];
	for (i = 0; i < m_cAssoc; i++)
		m_rgpAssoc[i] = NULL;

	pLinkable = m_listInUse.First();
	while (pLinkable != &m_listInUse) {
		pAssoc = (Assoc*) pLinkable;
		if (pAssoc->isPresent()) {
			find(pAssoc->m_d, &ppAssoc);
			pAssoc->m_pAssocNext = *ppAssoc;
			*ppAssoc = pAssoc;
		}
		pLinkable = pLinkable->Next();
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::newAssoc (const D& d, const R& r, Assoc** ppAssoc) {
	Assoc* pAssoc;
	if (m_pAssocFree == NULL) {
		pAssoc = (Assoc*) operator new(sizeof Assoc); // uses Base::operator new, if any
	}
	else {
		pAssoc = m_pAssocFree;
		m_pAssocFree = pAssoc->m_pAssocNext;
	}

	new(pAssoc) Assoc(d,r);	// run Assoc constructor on existing memory: ("yuck-o-rama!" -- BobAtk)
	pAssoc->setPresent();
	pAssoc->m_pAssocNext = *ppAssoc;
	*ppAssoc = pAssoc;
	m_listInUse.InsertLast(pAssoc);
	if (++m_cPresent > m_cAssoc)
		grow();
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::addRefAssoc (Assoc* pAssoc) {
	pAssoc->m_lcUse++;
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::releaseAssoc (Assoc* pAssoc) {
	pAssoc->m_lcUse--;
	if (pAssoc->m_lcUse == 0) {
		freeAssoc (pAssoc);
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::freeAssoc (Assoc* pAssoc) {
	pAssoc->~Assoc();		// run Assoc destructor
	pAssoc->m_pAssocNext = m_pAssocFree;
	m_pAssocFree = pAssoc;
}



// EnumMap must continue to enumerate correctly in the presence of Map<foo>::add()
// or Map<foo>::remove() being called in the midst of the enumeration.
template <class D, class R, class H, class Base=EmptyMapBase>
class EnumMap : public Enum, public Base {
public:
	EnumMap ();
	EnumMap (const Map<D,R,H,Base>& map);
	EnumMap (const EnumMap<D,R,H,Base>& e);
	~EnumMap ();

	void reset ();
	BOOL next ();
	void get (OUT D* pd, OUT R* pr) const;
	void get (OUT D* pd, OUT R** ppr) const;
    void get (OUT D** ppd, OUT R** ppr) const;
    void get (OUT D** ppd, OUT R* pr) const;

	EnumMap<D,R,H,Base>& operator= (const EnumMap<D,R,H,Base>& e);

    BOOL operator==(const EnumMap<D,R,H,Base>& enum2) const {
        return m_pmap == enum2.m_pmap && m_pLinkable == enum2.m_pLinkable;
    }

    BOOL operator!=(const EnumMap<D,R,H,Base>& enum2) const {
        return ! this->operator==(enum2);
    }

private:
	typedef typename Map<D,R,H,Base>::Assoc Assoc;

	Map<D,R,H,Base>* m_pmap;
	CLinkable* m_pLinkable;
};	



template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::EnumMap () {
	m_pmap = NULL;
	m_pLinkable = &m_pmap->m_listInUse;
	// The above is NOT a bug. It makes the mantra "if (m_pLinkable != &m_pmap->m_listInUse)" return the right answer for null enum's.
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::EnumMap (const Map<D,R,H,Base>& map) {
	m_pmap = const_cast<Map<D,R,H,Base>*> (&map);
	m_pLinkable = &m_pmap->m_listInUse;
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::EnumMap (const EnumMap<D,R,H,Base>& e) {
	m_pmap = e.m_pmap;
	m_pLinkable = e.m_pLinkable;
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->addRefAssoc((Assoc*)m_pLinkable);
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::~EnumMap () {
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::reset () {
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);
	m_pLinkable = &m_pmap->m_listInUse;
}

template <class D, class R, class H, class Base> inline
BOOL EnumMap<D,R,H,Base>::next () {
	CLinkable* pLink2 = m_pLinkable->Next();
	Assoc* pAssoc;
	
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);

	for(;;) {
		if (pLink2 == &m_pmap->m_listInUse) {
			m_pLinkable = pLink2;
			return FALSE;
		}
		pAssoc = (Assoc*)pLink2;
		if (pAssoc->isPresent()) {
			m_pmap->addRefAssoc(pAssoc);
			m_pLinkable = pLink2;
			return TRUE;
		}
		pLink2 = pLink2->Next();
	}
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D* pd, OUT R* pr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*pd = pAssoc->m_d;
	*pr = pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D* pd, OUT R** ppr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*pd = pAssoc->m_d;
	*ppr = &pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D** ppd, OUT R** ppr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*ppd = &pAssoc->m_d;
	*ppr = &pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D** ppd, OUT R* pr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*ppd = &pAssoc->m_d;
	*pr  = pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>& EnumMap<D,R,H,Base>::operator= (const EnumMap<D,R,H,Base>& e) {
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);
	m_pmap = e.m_pmap;
	m_pLinkable = e.m_pLinkable;
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->addRefAssoc((Assoc*)m_pLinkable);
	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\txfmalloc.h ===
//  Copyright (C) 1995-2002 Microsoft Corporation.  All rights reserved.
//
// txfmalloc.h
//
// Global, generic, memory managment related functionality
//
//

#ifndef __TXFMALLOC_H__
#define __TXFMALLOC_H__

#include "InterlockedStack.h"

template <class T>
struct DedicatedAllocator
{
    // The link we must have in order to use the interlocked stack
    //
    T* pNext;
    //
    // Our stack. Initialized somewhere else, one hopes. Clients are responsible
    // for declaring these variables and initializing them to the result of calling
    // CreateStack.
    //
    static IFastStack<T>* g_pStack;

    static IFastStack<T>* CreateStack()
    {
        IFastStack<T> *pFastStack;
        HRESULT hr = ::CreateFastStack(&pFastStack);
        return pFastStack;
    }
    
    static void DeleteStack()
    {
        if (g_pStack)
        {
            while (TRUE)
            {
                T* pt = g_pStack->Pop();
                if (pt)
                {
                    CoTaskMemFree(pt);
                }
                else
                {
                    break;
                }
            }
            delete g_pStack;
            g_pStack = NULL;
        }
    }
    
    /////////////////////////////

    static void* __stdcall DoAlloc(size_t cb)
    {
        ASSERT(cb == sizeof(T));
        ASSERT(g_pStack);
        T* pt = g_pStack->Pop();
        if (!pt)
        {
            pt = (T*)CoTaskMemAlloc(cb);
            if (pt)
                pt->pNext = NULL;
        }
        return pt;
    }
    
    void* __stdcall operator new(size_t cb)
    {
        return DoAlloc(cb);
    }
    
    void __cdecl operator delete(void* pv)
    {
        ASSERT(g_pStack);
        T* pt = (T*)pv;
        ASSERT(NULL == pt->pNext);
        g_pStack->Push(pt);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\txfdebug.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfdebug.h
//
// Suite of ASSERT macros usable from either kernel and / or user mode.
//
#ifndef __TXFDEBUG_H__
#define __TXFDEBUG_H__

#include <debnot.h>

/////////////////////////////////////////////////////////////////////////////
//
// In the x86 version, we in-line the int3 so that when you hit it the debugger
// stays in source mode instead of anoyingly switching to disassembly mode, which
// you then immediately always want to switch out of
//
#ifdef _X86_
#define DebugBreak()    {  __asm int 3 }
#endif
#define BREAKPOINT()        DebugBreak()
#define ASSERT_BREAK        BREAKPOINT()

/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

#undef ASSERT
#undef ASSERTMSG
#undef VERIFY

#define ASSERT(exp)          Win4Assert(exp)

#define ASSERTMSG(msg, exp)  Win4Assert(exp && (msg))

#define VERIFY(exp)          ASSERT(exp)
#define NYI()                ASSERTMSG("not yet implemented", FALSE)
#define FATAL_ERROR()        ASSERTMSG("a fatal error has occurred", FALSE)
#define	NOTREACHED()		 ASSERTMSG("this should not be reached", FALSE)

#undef  DEBUG
#define DEBUG(x)            x
#define PRECONDITION(x)     ASSERT(x)
#define POSTCONDITION(x)    ASSERT(x)

/////////////////////////////////////////////////////////////////////////////

#else

#undef ASSERTMSG
#undef ASSERT
#undef VERIFY

#define ASSERTMSG(msg,exp)
#define ASSERT(x)

#define VERIFY(exp)         (exp)
#define NYI()               BREAKPOINT()
#define FATAL_ERROR()       BREAKPOINT()        
#define NOTREACHED()                            

#undef  DEBUG
#define DEBUG(x)
#define PRECONDITION(x)
#define POSTCONDITION(x)

#endif

/////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////
//
// A wrapper for HRESULTs that will detect error assignments thereto
// Use sparingly!
//
///////////////////////////////////////////////////////////////////

#if defined(_DEBUG) && defined(TRAP_HRESULT_ERRORS)

struct HRESULT_
{
    HRESULT m_hr;
    
    void V()               { ASSERT(SUCCEEDED(m_hr)); }
    
    HRESULT_(HRESULT   hr) { m_hr = hr;      V(); }
    HRESULT_(HRESULT_& hr) { m_hr = hr.m_hr; V(); }
    
    HRESULT_& operator =(HRESULT   hr) { m_hr = hr;      V(); return *this;}
    HRESULT_& operator =(HRESULT_& hr) { m_hr = hr.m_hr; V(); return *this;}
    
    operator HRESULT()     { return m_hr; }
};

#else

typedef HRESULT HRESULT_;

#endif

#if DBG==1
DECLARE_DEBUG(Txf)

#define TxfDebugOut(x) TxfInlineDebugOut x

#else

#define TxfDebugOut(x)

#endif

#define DEB_CALLFRAME   DEB_USER1
#define DEB_TYPEINFO    DEB_USER2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\txfrpcproxy.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// TxfRpcProxy.h
//
// Version of RpcProxy.h that is compilable under C++ instead of C.
// Also, contains the external declarations for the marshalling runtime 
// thunks exported from komdll.dll / komsys.sys.
//
#ifndef __TxfRpcProxy__h__
#define __TxfRpcProxy__h__

// 
// First, copy the C-variation of the vtbl defintions of some 
// key interfaces whose definitions are needed by the standard
// rpcproxy.h, which was designed to only be compilable as C, not 
// as C++. As these interfaces are frozen (like all interfaces, natch')
// snarfing them here doesn't particularly cause us problems
//

    typedef struct IRpcStubBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkServer);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *_prpcmsg,
            /* [in] */ IRpcChannelBuffer __RPC_FAR *_pRpcChannelBuffer);
        
        IRpcStubBuffer __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *IsIIDSupported )( 
            IRpcStubBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *CountRefs )( 
            IRpcStubBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DebugServerQueryInterface )( 
            IRpcStubBuffer __RPC_FAR * This,
            void __RPC_FAR *__RPC_FAR *ppv);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *DebugServerRelease )( 
            IRpcStubBuffer __RPC_FAR * This,
            void __RPC_FAR *pv);
        
        END_INTERFACE
    } IRpcStubBufferVtbl;


    #define IRpcStubBufferVtbl_DEFINED


    typedef struct IPSFactoryBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPSFactoryBuffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPSFactoryBuffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateProxy )( 
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ IRpcProxyBuffer __RPC_FAR *__RPC_FAR *ppProxy,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStub )( 
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkServer,
            /* [out] */ IRpcStubBuffer __RPC_FAR *__RPC_FAR *ppStub);
        
        END_INTERFACE
    } IPSFactoryBufferVtbl;




    typedef struct IPSFactoryHookVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( __stdcall __RPC_FAR *QueryInterface )(
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( __stdcall __RPC_FAR *AddRef )(
            IPSFactoryBuffer __RPC_FAR * This);

        ULONG ( __stdcall __RPC_FAR *Release )(
            IPSFactoryBuffer __RPC_FAR * This);

        HRESULT ( __stdcall __RPC_FAR *CreateProxy )(
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ IRpcProxyBuffer __RPC_FAR *__RPC_FAR *ppProxy,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);

        HRESULT ( __stdcall __RPC_FAR *CreateStub )(
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkServer,
            /* [out] */ IRpcStubBuffer __RPC_FAR *__RPC_FAR *ppStub);


        HRESULT ( __stdcall __RPC_FAR *HkGetProxyFileInfo )(
            IPSFactoryBuffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out]*/ PINT     pOffset,
            /* [out]*/ PVOID    *ppProxyFileInfo);

        END_INTERFACE
    } IPSFactoryHookVtbl;


//
// Now, include the external definitions seen by COM proxies and stubs
//
extern "C" 
    {
    #define USE_STUBLESS_PROXY
    #include "rpcproxy.h"
    }



//////////////////////////////////////////////////////////////////////////////////
//
// Declarations for the ComPs exports
//



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\vtableimpl.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// vtableimpl.h
//
// Definitions for creating static vtables
//
// Use: define meth() and methname() macros before including this file
// Then, do (e.g.)
//
//      defineVtableMethods()
//      defineVtable(g_UKInterfaceVtable, pfnQI, pfnAddRef, pfnRelease)
// 
// to actually create the defintions
//

#define meth10(i) \
	meth(i##0) \
	meth(i##1) \
	meth(i##2) \
	meth(i##3) \
	meth(i##4) \
	meth(i##5) \
	meth(i##6) \
	meth(i##7) \
	meth(i##8) \
	meth(i##9)

#define meth100(i) \
	meth10(i##0) \
	meth10(i##1) \
	meth10(i##2) \
	meth10(i##3) \
	meth10(i##4) \
	meth10(i##5) \
	meth10(i##6) \
	meth10(i##7) \
	meth10(i##8) \
	meth10(i##9)


#define defineVtableMethods() \
    meth(3)         \
    meth(4)         \
    meth(5)         \
    meth(6)         \
    meth(7)         \
    meth(8)         \
    meth(9)         \
    meth10(1)       \
    meth10(2)       \
    meth10(3)       \
    meth10(4)       \
    meth10(5)       \
    meth10(6)       \
    meth10(7)       \
    meth10(8)       \
    meth10(9)       \
    meth100(1)      \
    meth100(2)      \
    meth100(3)      \
    meth100(4)      \
    meth100(5)      \
    meth100(6)      \
    meth100(7)      \
    meth100(8)      \
    meth100(9)      \
    meth10(100)     \
    meth10(101)     \
    meth(1020)      \
    meth(1021)      \
    meth(1022)      \
    meth(1023)

// 
// _LANGUAGE_ASSEMBLY is defined by the ALPHA assembler
//
#ifndef _LANGUAGE_ASSEMBLY
    #define rmeth(i) (PFN_VTABLE_ENTRY)(&methname(i)),
#else

#ifndef _WIN64
    #define rmeth(i) .long methname(i);
#else
    #define rmeth(i) .quad methname(i);
#endif

#endif

#define rmeth10(i) \
	rmeth(i##0) \
	rmeth(i##1) \
	rmeth(i##2) \
	rmeth(i##3) \
	rmeth(i##4) \
	rmeth(i##5) \
	rmeth(i##6) \
	rmeth(i##7) \
	rmeth(i##8) \
	rmeth(i##9)

#define rmeth100(i) \
	rmeth10(i##0) \
	rmeth10(i##1) \
	rmeth10(i##2) \
	rmeth10(i##3) \
	rmeth10(i##4) \
	rmeth10(i##5) \
	rmeth10(i##6) \
	rmeth10(i##7) \
	rmeth10(i##8) \
	rmeth10(i##9)


#ifndef _LANGUAGE_ASSEMBLY

#define defineVtable(name, qi, ar, rel)                             \
                                                                    \
    extern "C" const PFN_VTABLE_ENTRY name[] =                      \
        {                                                           \
        (PFN_VTABLE_ENTRY)(&qi),                                    \
        (PFN_VTABLE_ENTRY)(&ar),                                    \
        (PFN_VTABLE_ENTRY)(&rel),                                   \
	    rmeth(3)            \
	    rmeth(4)            \
	    rmeth(5)            \
	    rmeth(6)            \
	    rmeth(7)            \
	    rmeth(8)            \
	    rmeth(9)            \
	    rmeth10(1)          \
	    rmeth10(2)          \
	    rmeth10(3)          \
	    rmeth10(4)          \
	    rmeth10(5)          \
	    rmeth10(6)          \
	    rmeth10(7)          \
	    rmeth10(8)          \
	    rmeth10(9)          \
	    rmeth100(1)         \
	    rmeth100(2)         \
	    rmeth100(3)         \
	    rmeth100(4)         \
	    rmeth100(5)         \
	    rmeth100(6)         \
	    rmeth100(7)         \
	    rmeth100(8)         \
	    rmeth100(9)         \
	    rmeth10(100)        \
	    rmeth10(101)        \
	    rmeth(1020)         \
	    rmeth(1021)         \
	    rmeth(1022)         \
	    rmeth(1023)         \
        };

#else

#ifndef _WIN64
#define defineVtable(name, qi, ar, rel) \
    .extern qi;                         \
    .extern ar;                         \
    .extern rel;                        \
                                        \
    .globl name;                        \
                                        \
    name:                               \
        .long qi;           \
        .long ar;           \
        .long rel;          \
	    rmeth(3)            \
	    rmeth(4)            \
	    rmeth(5)            \
	    rmeth(6)            \
	    rmeth(7)            \
	    rmeth(8)            \
	    rmeth(9)            \
	    rmeth10(1)          \
	    rmeth10(2)          \
	    rmeth10(3)          \
	    rmeth10(4)          \
	    rmeth10(5)          \
	    rmeth10(6)          \
	    rmeth10(7)          \
	    rmeth10(8)          \
	    rmeth10(9)          \
	    rmeth100(1)         \
	    rmeth100(2)         \
	    rmeth100(3)         \
	    rmeth100(4)         \
	    rmeth100(5)         \
	    rmeth100(6)         \
	    rmeth100(7)         \
	    rmeth100(8)         \
	    rmeth100(9)         \
	    rmeth10(100)        \
	    rmeth10(101)        \
	    rmeth(1020)         \
	    rmeth(1021)         \
	    rmeth(1022)         \
	    rmeth(1023)         \
    
#else

#define defineVtable(name, qi, ar, rel) \
    .extern qi;                         \
    .extern ar;                         \
    .extern rel;                        \
                                        \
    .globl name;                        \
                                        \
    name:                               \
        .quad qi;           \
        .quad ar;           \
        .quad rel;          \
	    rmeth(3)            \
	    rmeth(4)            \
	    rmeth(5)            \
	    rmeth(6)            \
	    rmeth(7)            \
	    rmeth(8)            \
	    rmeth(9)            \
	    rmeth10(1)          \
	    rmeth10(2)          \
	    rmeth10(3)          \
	    rmeth10(4)          \
	    rmeth10(5)          \
	    rmeth10(6)          \
	    rmeth10(7)          \
	    rmeth10(8)          \
	    rmeth10(9)          \
	    rmeth100(1)         \
	    rmeth100(2)         \
	    rmeth100(3)         \
	    rmeth100(4)         \
	    rmeth100(5)         \
	    rmeth100(6)         \
	    rmeth100(7)         \
	    rmeth100(8)         \
	    rmeth100(9)         \
	    rmeth10(100)        \
	    rmeth10(101)        \
	    rmeth(1020)         \
	    rmeth(1021)         \
	    rmeth(1022)         \
	    rmeth(1023)         \
    
#endif // WIN64

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\shared\comregistration\stdpch.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.h
//

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#undef MBCS
#undef _MBCS

#include <windows.h>
#include <ole2.h>
#include <crtdbg.h>
#include <olectl.h>		// SELFREG_E_CLASS and SELFREG_E_TYPE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\txfaux\common.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// common.h
//
#include "TxfCommon.h"
#include "txfutil.h"
#include "Registry.h"

extern HINSTANCE g_hinst;
extern BOOL      g_fProcessDetach;

// Utilties for cleaning up per-process memory in order that 
// PrintMemoryLeaks can do a more reasonable job.
//
extern "C" void ShutdownTxfAux();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\txfutil.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfutil.h
//
// Miscellanous and varied support utilities
//
#ifndef __TXFUTIL_H__
#define __TXFUTIL_H__

#include <malloc.h>     // for __alloca

///////////////////////////////////////////////////////////////////////////////////
//
// Error code management
//
///////////////////////////////////////////////////////////////////////////////////
//
// A simple utility that maps NT status codes into HRESULTs
//
extern "C" HRESULT HrNt(NTSTATUS status);


///////////////////////////////////////////////////////////////////////////////////
//
// Exception management
//
///////////////////////////////////////////////////////////////////////////////////
inline void Throw(DWORD dw)
{
    RaiseException(dw, EXCEPTION_NONCONTINUABLE, 0, 0);
}

inline void Throw(DWORD dw, LPCSTR szFile, ULONG iline)
{
    TxfDebugOut((DEB_ERROR, "%s(%d): throwing exception 0x%08x", szFile, iline, dw));
    Throw(dw);
}

//////////////////

inline void ThrowNYI()
{
    Throw(STATUS_NOT_IMPLEMENTED);
}

inline void ThrowOutOfMemory()
{
    Throw(STATUS_NO_MEMORY);
}

inline void ThrowHRESULT(HRESULT hr)
{
    Throw(hr);
}

///////////////////////////////////////////////////////////////////
//
// Support for reference counting in structures
//
///////////////////////////////////////////////////////////////////
struct REF_COUNTED_STRUCT
{
private:
    
    LONG m_refs;
    
public:
    
    void AddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs);      }
    void Release()  { if (InterlockedDecrement(&m_refs) == 0) delete this;  }

    REF_COUNTED_STRUCT()
    {
        m_refs = 1;
    }
    
protected:

    virtual ~REF_COUNTED_STRUCT()
    {
    }

};


///////////////////////////////////////////////////////////////////
//
// Some functions for managing references
//
///////////////////////////////////////////////////////////////////

// Safely release pointer and NULL it
//
template <class Interface>
inline void Release(Interface*& punk)
{
    if (punk) punk->Release();
    punk = NULL;
}

template <class Interface>
inline void ReleaseConcurrent(Interface*& punk)
{
    IUnknown* punkToRelease = (IUnknown*)InterlockedExchangePointer( (void**)&punk, NULL);
    if (punkToRelease) punkToRelease->Release();
}
//
// Safely (re)set pointer
//
template <class Interface>
inline void Set(Interface*& var, Interface* value)
{
    if (value) value->AddRef();
    ::Release(var);
    var = value;
}

template <class Interface>
inline void SetConcurrent(Interface*& var, Interface* punkNew)
{
    if (punkNew)  punkNew->AddRef();
    IUnknown* punkPrev = (IUnknown*)InterlockedExchangePointer( (void **)&var, punkNew);
    if (punkPrev) punkPrev->Release();
}
//
// Type-safe QueryInterface: avoid the bug of forgetting to ptu the '&' before the out-param!
//
template <class T>
inline HRESULT QI(IUnknown*punk, T*& pt)
{
    return punk->QueryInterface(__uuidof(T), (void**)&pt);
}
//
// Reference counting for out-params on iid, ppv pairs
//
inline void AddRef(void**ppv)
{
    ASSERT(*ppv);
    (*((IUnknown**)ppv))->AddRef();
}


/////////////////////////////////////////////////////////////
//
// Process and thread inquiry
//
/////////////////////////////////////////////////////////////

//
// This is a neat little class.  It allows you to effectively
// have strongly typed "handles" (which are usually typed void * 
// or DWORD).
//
template <int i> class OPAQUE_HANDLE
{
public:
    OPAQUE_HANDLE()                                     { }
    OPAQUE_HANDLE(HANDLE_PTR h)                         { m_h = h; }
    template <class T> OPAQUE_HANDLE(const T& t)        { m_h = (HANDLE_PTR)t; }
    
    OPAQUE_HANDLE& operator=(const OPAQUE_HANDLE& him)  { m_h = him.m_h; return *this; }
    OPAQUE_HANDLE& operator=(HANDLE_PTR h)              { m_h = h;       return *this; }
    
    BOOL operator==(const OPAQUE_HANDLE& him) const     { return m_h == him.m_h; }
    BOOL operator!=(const OPAQUE_HANDLE& him) const     { return m_h != him.m_h; }
    
    ULONG Hash() const { return (ULONG)m_h * 214013L + 2531011L; }

private:
    HANDLE_PTR m_h;   
};

typedef OPAQUE_HANDLE<1> THREADID;
typedef OPAQUE_HANDLE<2> PROCESSID;

/////////////////////////////////////////////////////////////
//
// Misc
//
/////////////////////////////////////////////////////////////
template <class T> void Zero(T* pt)
{
    ZeroMemory(pt, sizeof(*pt));
}


inline void DebugInit(VOID* pv, ULONG cb)
{
#ifdef _DEBUG
    memset(pv, 0xcd, cb);
#endif
}

template <class T> void DebugInit(T* pt)
{
    DebugInit(pt, sizeof(*pt));
}

//////////////////////////////////////////////////////////////////////////////////

inline int DebuggerFriendlyExceptionFilter(DWORD dwExceptionCode)
  // An exception filter that still allows JIT debugging to work inside a server method
{
    if (dwExceptionCode == EXCEPTION_BREAKPOINT)
        return EXCEPTION_CONTINUE_SEARCH;
    else
        return EXCEPTION_EXECUTE_HANDLER;
}

/////////////////////////////////////////////////////////////
//
// Convert guids to strings. String buffers must be at least
// 39 characters characters long:
//
// {F75D63C5-14C8-11d1-97E4-00C04FB9618A}
// 123456789012345678901234567890123456789
//
void    __stdcall StringFromGuid(REFGUID guid, LPWSTR pwsz);  // unicode
void    __stdcall StringFromGuid(REFGUID guid, LPSTR psz);    // ansi

HRESULT __stdcall GuidFromString(LPCWSTR pwsz, GUID* pGuid);

//////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////
//
// Type-specific wrappers for the interlocked primitives
//
/////////////////////////////////////////////////////////////
inline
ULONG
InterlockedCompareExchange(
    ULONG volatile *Destination,
    ULONG Exchange,
    ULONG Comperand
)

{
    return InterlockedCompareExchange((LONG *)Destination,
                                      (LONG)Exchange,
                                      (LONG)Comperand);
}

inline
ULONG
InterlockedIncrement(
    ULONG* pul
)

{
    return (ULONG)InterlockedIncrement((LONG *)pul);
}

inline
ULONG
InterlockedDecrement(
    ULONG* pul
)

{
    return (ULONG)InterlockedDecrement((LONG *)pul);
}

////////////////////////////////////////////////////////////////////////////////////////
//
// CanUseCompareExchange64: Are we allowed to use the hardware support?
//
////////////////////////////////////////////////////////////////////////////////////////

#ifdef _X86_
#pragma warning (disable: 4035)     // function doesn't return value warning.
inline LONGLONG TxfInterlockedCompareExchange64 (volatile LONGLONG* pDestination, LONGLONG exchange, LONGLONG comperand)
{
    __asm
      {
          mov esi, pDestination

            mov eax, DWORD PTR comperand[0]
            mov edx, DWORD PTR comperand[4]

            mov ebx, DWORD PTR exchange[0]
            mov ecx, DWORD PTR exchange[4]

            // lock cmpxchg8b [esi] - REVIEW: would like to use new compiler that understands this
            _emit 0xf0
            _emit 0x0f
            _emit 0xc7
            _emit 0x0e

            // result is in DX,AX
            }
}
#pragma warning (default: 4035)     // function doesn't return value warning
#endif

#if defined(_WIN64)
inline LONGLONG TxfInterlockedCompareExchange64 (volatile LONGLONG* pDestination, LONGLONG exchange, LONGLONG comperand)
{
    return ((ULONGLONG)_InterlockedCompareExchangePointer( (void **)pDestination, (PULONGLONG)exchange, (PULONGLONG)comperand ));
}

#endif

////////////////////////////////////////////////////////////////////////////////////////
//
// Support for swapping 64 bits of data in an interlocked manner.
//
////////////////////////////////////////////////////////////////////////////////////////

#ifdef _X86_
#ifdef KERNELMODE
inline BOOL CanUseCompareExchange64() { return ExIsProcessorFeaturePresent(PF_COMPARE_EXCHANGE_DOUBLE); }
#else
extern "C" BOOL __stdcall CanUseCompareExchange64();
#endif
#else
inline BOOL CanUseCompareExchange64() { return TRUE; }
#endif

/////////////////////////////////////////////////////////////
//
// String utilties
//
/////////////////////////////////////////////////////////////

//
// Concatenate a list of zero-terminated wide strings together into a newly allocated string.
//
HRESULT __cdecl   StringCat(LPWSTR* pwsz,       ...);
HRESULT __cdecl   StringCat(UNICODE_STRING* pu, ...);
HRESULT __stdcall StringCat(LPWSTR* pwsz, va_list va);


inline LPWSTR StringBetween(const WCHAR* pchFirst, const WCHAR* pchMax)
{
    SIZE_T cch = pchMax - pchFirst;
    SIZE_T cb = (cch+1) * sizeof(WCHAR);
    LPWSTR wsz = (LPWSTR)CoTaskMemAlloc(cb);
    if (wsz)
    {
        memcpy(wsz, pchFirst, cch*sizeof(WCHAR));
        wsz[cch] = L'\0';
    }
    return wsz;
}

inline LPSTR StringBetween(const CHAR* pchFirst, const CHAR* pchMax)
{
    SIZE_T cch = pchMax - pchFirst;
    SIZE_T cb = (cch+1) * sizeof(CHAR);
    LPSTR sz = (LPSTR)CoTaskMemAlloc(cb);
    if (sz)
    {
        memcpy(sz, pchFirst, cch*sizeof(CHAR));
        sz[cch] = '\0';
    }
    return sz;
}

inline WCHAR& LastChar(LPWSTR wsz)
{
    ASSERT(wcslen(wsz) > 0);
    return wsz[wcslen(wsz)-1];
}

inline const WCHAR& LastChar(LPCWSTR wsz)
{
    ASSERT(wcslen(wsz) > 0);
    return wsz[wcslen(wsz)-1];
}

inline CHAR& LastChar(LPSTR sz)
{
    ASSERT(strlen(sz) > 0);
    return sz[strlen(sz)-1];
}

inline const CHAR& LastChar(LPCSTR sz)
{
    ASSERT(strlen(sz) > 0);
    return sz[strlen(sz)-1];
}

inline LPWSTR CopyString(LPCWSTR wszFrom)
{
    SIZE_T  cch = wcslen(wszFrom);
    SIZE_T  cb = (cch+1) * sizeof(WCHAR);
    LPWSTR wsz = (LPWSTR)CoTaskMemAlloc(cb);
    if (wsz)
    {
        memcpy(wsz, wszFrom, cb);
    }
    return wsz;
}

inline LPSTR CopyString(LPCSTR szFrom)
{
    SIZE_T cch = strlen(szFrom);
    SIZE_T cb = (cch+1);
    LPSTR sz = (LPSTR)CoTaskMemAlloc(cb);
    if (sz)
    {
        memcpy(sz, szFrom, cb);
    }
    return sz;
}

inline BLOB Copy(const BLOB& bFrom)
{
    BLOB bTo;
    Zero(&bTo);
    if (bFrom.cbSize > 0)
    {
        bTo.pBlobData = (BYTE*)CoTaskMemAlloc(bFrom.cbSize);
        if (bTo.pBlobData)
        {
            memcpy(bTo.pBlobData, bFrom.pBlobData, bFrom.cbSize);
            bTo.cbSize = bFrom.cbSize;
        }
    }
    return bTo;
}


//////////////////////////////////////////////////////////////
//
// Unicode conversion
//
void    ToUnicode(LPCSTR sz, LPWSTR wsz, ULONG cch);
LPWSTR  ToUnicode(LPCSTR sz);

inline LPSTR ToUtf8(LPCWSTR wsz, ULONG cch)
// String doesn't have to be zero terminated
{
    ULONG cb   = (cch+1) * 3;
    LPSTR sz   = (LPSTR)_alloca(cb);
    int cbWritten = WideCharToMultiByte(CP_UTF8, 0, wsz, cch, sz, cb, NULL, NULL);
    sz[cbWritten]=0;
    return CopyString(sz);
}

inline LPSTR ToUtf8(LPCWSTR wsz)
{
    return ToUtf8(wsz, (ULONG) wcslen(wsz));
}


#ifdef _DEBUG

inline BOOL IsValid(UNICODE_STRING& u)
  // Answer whether this is a reasonable UNICODE_STRING or not
{
    return (u.Length % 2 == 0)
      && (u.Length <= u.MaximumLength)
      && (u.MaximumLength == 0 || u.Buffer != NULL);
}

#endif

inline BOOL IsPrefixOf(LPCWSTR wszPrefix, LPCWSTR wszTarget)
{
    if (wszPrefix && wszTarget)
    {
        while (TRUE)
        {
            if (wszPrefix[0] == 0)  return TRUE;    // run out of prefix first
            if (wszTarget[0] == 0)  return FALSE;   // run out of target first
            if (wszPrefix[0] == wszTarget[0])
            {
                wszPrefix++;
                wszTarget++;
            }
            else
                return FALSE;
        }
    }
    else
        return FALSE;
}

inline BOOL IsPrefixOf(LPCSTR szPrefix, LPCSTR szTarget)
{
    if (szPrefix && szTarget)
    {
        while (TRUE)
        {
            if (szPrefix[0] == 0)  return TRUE;    // run out of prefix first
            if (szTarget[0] == 0)  return FALSE;   // run out of target first
            if (szPrefix[0] == szTarget[0])
            {
                szPrefix++;
                szTarget++;
            }
            else
                return FALSE;
        }
    }
    else
        return FALSE;
}

inline BOOL IsPrefixOfIgnoreCase(LPCWSTR wszPrefix, LPCWSTR wszTarget)
{
    if (wszPrefix && wszTarget)
    {
        while (TRUE)
        {
            if (wszPrefix[0] == 0)  return TRUE;    // run out of prefix first
            if (wszTarget[0] == 0)  return FALSE;   // run out of target first
            if (towupper(wszPrefix[0]) == towupper(wszTarget[0]))
            {
                wszPrefix++;
                wszTarget++;
            }
            else
                return FALSE;
        }
    }
    else
        return FALSE;
}

inline BOOL IsPrefixOfIgnoreCase(LPCSTR szPrefix, LPCSTR szTarget)
{
    if (szPrefix && szTarget)
    {
        while (TRUE)
        {
            if (szPrefix[0] == 0)  return TRUE;    // run out of prefix first
            if (szTarget[0] == 0)  return FALSE;   // run out of target first
            if (toupper(szPrefix[0]) == toupper(szTarget[0]))
            {
                szPrefix++;
                szTarget++;
            }
            else
                return FALSE;
        }
    }
    else
        return FALSE;
}

/////////////////////////////////////////////////////////

#ifndef __RC_STRINGIZE__
#define __RC_STRINGIZE__AUX(x)      #x
#define __RC_STRINGIZE__(x)         __RC_STRINGIZE__AUX(x)
#endif

#define MESSAGE_WARNING(file,line)   file "(" __RC_STRINGIZE__(line) ") : warning "
#define MESSAGE_ERROR(file,line)     file "(" __RC_STRINGIZE__(line) ") : error "

/////////////////////////////////////////////////////////////
//
// IStream utilities
//
/////////////////////////////////////////////////////////////

HRESULT __stdcall SeekFar(IStream* pstm, LONGLONG offset, STREAM_SEEK fromWhat = STREAM_SEEK_SET);

inline HRESULT SeekFar(IStream* pstm, ULONGLONG offset, STREAM_SEEK fromWhat = STREAM_SEEK_SET)
{
    return SeekFar(pstm, (LONGLONG)offset, fromWhat);
}

HRESULT __stdcall Seek(IStream* pstm, LONG offset, STREAM_SEEK fromWhat = STREAM_SEEK_SET);

HRESULT __stdcall Seek(IStream* pstm, ULONG offset, STREAM_SEEK fromWhat = STREAM_SEEK_SET);

HRESULT __stdcall Read(IStream* pstm, LPVOID pBuffer, ULONG cbToRead);

HRESULT __stdcall Write(IStream* pstm, const void* pBuffer, ULONG cbToWrite);

inline HRESULT Write(IStream* pstm, const BLOB& blob)
{
    return Write(pstm, blob.pBlobData, blob.cbSize);
}
inline HRESULT __stdcall WriteChar(IStream* pstm, wchar_t wch)
{
    return Write(pstm, &wch, sizeof(wchar_t));
}
inline HRESULT __stdcall WriteChar(IStream* pstm, char ch)
{
    return Write(pstm, &ch, sizeof(char));
}
inline HRESULT __stdcall WriteString(IStream* pstm, LPCWSTR wsz)
{
    if (wsz)
        return Write(pstm, wsz, (ULONG) wcslen(wsz)*sizeof(WCHAR));
    else
        return S_OK;
}
inline HRESULT __stdcall WriteString(IStream* pstm, LPCSTR sz)
{
    if (sz)
        return Write(pstm, sz, (ULONG) strlen(sz));
    else
        return S_OK;
}

inline HRESULT CurrentPosition(IStream* pstm, ULONGLONG* pCurrentPosition)
{
    LARGE_INTEGER lMove;
    lMove.QuadPart = 0;
    return pstm->Seek(lMove, STREAM_SEEK_CUR, (ULARGE_INTEGER*)pCurrentPosition);
}


/////////////////////////////////////////////////////////////
//
// Some arithmetic utilities
//
/////////////////////////////////////////////////////////////

inline ULONG RoundToNextMultiple(ULONG i, ULONG multiple)
  // Round i to the next multiple of 'multiple'
{
    return (i + multiple-1) / multiple * multiple;
}


inline void * RoundToNextMultiple(void * i, ULONG multiple)
{
    return (void *)(((ULONG_PTR)i + multiple-1) / multiple * multiple);
}
inline ULONGLONG RoundToNextMultiple(ULONGLONG i, ULONG multiple)
{
    return (i + multiple-1) / multiple * multiple;
}


/////////////////////////////////////////////////////////////
//
// Some alignment management utilities
//
/////////////////////////////////////////////////////////////

template <class T>
inline ULONG AlignmentOf(T* pt)
  // Answer 1, 2, 4, 8 etc as to the required alignement for the given type
  //
{
    switch (sizeof(*pt))
    {
    case 0:
        return 1;
    case 1:
        return 1;
    case 2:
        return 2;
    case 3: case 4:
        return 4;
    case 5: case 6: case 7: case 8: default:
        return 8;
    }
}

inline BYTE* AlignTo(PVOID pv, ULONG alignment)
{
    ASSERT(alignment == 1 || alignment == 2 || alignment == 4 || alignment == 8);
    BYTE* pb = (BYTE*)RoundToNextMultiple(pv, alignment);
    return pb;
}

template <class T>
inline BYTE* AlignedConcat(PVOID pv, T* pt)
  // Concatenate new data on the end of a buffer in an aligned way
{
    if (pt)
    {
        ULONG alignment = AlignmentOf(pt);

        ASSERT(alignment == 1 || alignment == 2 || alignment == 4 || alignment == 8);
        BYTE* pb = (BYTE*)RoundToNextMultiple(pv, alignment);

        memcpy(pb, pt, sizeof(*pt));

        return pb + sizeof(*pt);
    }
    else
        return (BYTE*)pv;
}

template <class T>
inline BYTE* AlignedConcatSize(PVOID pv, T* pt)
  // Concatenate new data on the end of a buffer in an aligned way
{
    if (pt)
    {
        ULONG alignment = AlignmentOf(pt);

        ASSERT(alignment == 1 || alignment == 2 || alignment == 4 || alignment == 8);
        BYTE* pb = (BYTE*)RoundToNextMultiple((UINT_PTR)pv, (UINT_PTR)alignment);

        return pb + sizeof(*pt);
    }
    else
        return (BYTE*)pv;
}


/////////////////////////////////////////////////////////////
//
// Reasonable arithmetic on large integers
//
/////////////////////////////////////////////////////////////

#define DEFINE_LARGE_ARITHMETIC(__LARGE_INT__, op)                                  \
                                                                                    \
inline __LARGE_INT__ operator op (const __LARGE_INT__& a1, const __LARGE_INT__& a2) \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1.QuadPart  op  a2.QuadPart;                                      \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (const __LARGE_INT__& a1, LONGLONG a2)             \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1.QuadPart  op  a2;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (const __LARGE_INT__& a1, LONG a2)                 \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1.QuadPart  op  a2;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (const __LARGE_INT__& a1, ULONGLONG a2)            \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1.QuadPart  op  a2;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (const __LARGE_INT__& a1, ULONG a2)                \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1.QuadPart  op  a2;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (LONGLONG a1, const __LARGE_INT__& a2)             \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1  op  a2.QuadPart;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (LONG a1, const __LARGE_INT__& a2)                 \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1  op  a2.QuadPart;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (ULONGLONG a1, const __LARGE_INT__& a2)            \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1  op  a2.QuadPart;                                               \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline __LARGE_INT__ operator op (ULONG a1, const __LARGE_INT__& a2)                \
    {                                                                               \
    __LARGE_INT__ l;                                                                \
    l.QuadPart = a1  op  a2.QuadPart;                                               \
    return l;                                                                       \
    }


DEFINE_LARGE_ARITHMETIC(LARGE_INTEGER, +);
DEFINE_LARGE_ARITHMETIC(LARGE_INTEGER, -);
DEFINE_LARGE_ARITHMETIC(LARGE_INTEGER, *);
DEFINE_LARGE_ARITHMETIC(LARGE_INTEGER, /);

DEFINE_LARGE_ARITHMETIC(ULARGE_INTEGER, +);
DEFINE_LARGE_ARITHMETIC(ULARGE_INTEGER, -);
DEFINE_LARGE_ARITHMETIC(ULARGE_INTEGER, *);
DEFINE_LARGE_ARITHMETIC(ULARGE_INTEGER, /);


#define DEFINE_LARGE_BOOLEAN(op)                                                                                            \
                                                                                                                            \
    inline BOOL operator op (const  LARGE_INTEGER& a1, const  LARGE_INTEGER& a2){ return a1.QuadPart op a2.QuadPart;   }    \
    inline BOOL operator op (const ULARGE_INTEGER& a1, const ULARGE_INTEGER& a2){ return a1.QuadPart op a2.QuadPart;   }    \
                                                                                                                            \
    inline BOOL operator op (const LARGE_INTEGER& a1,  LONGLONG a2)           { return a1.QuadPart op a2;              }    \
    inline BOOL operator op (const LARGE_INTEGER& a1, ULONGLONG a2)           { return (ULONGLONG)a1.QuadPart op a2;   }    \
    inline BOOL operator op ( LONGLONG a1, const LARGE_INTEGER& a2)           { return a1 op a2.QuadPart;              }    \
    inline BOOL operator op (ULONGLONG a1, const LARGE_INTEGER& a2)           { return a1 op (ULONGLONG)a2.QuadPart;   }    \
                                                                                                                            \
    inline BOOL operator op (const ULARGE_INTEGER& a1,  LONGLONG a2)           { return a1.QuadPart  op  (ULONGLONG)a2; }   \
    inline BOOL operator op (const ULARGE_INTEGER& a1, ULONGLONG a2)           { return a1.QuadPart  op  a2;            }   \
    inline BOOL operator op ( LONGLONG a1, const ULARGE_INTEGER& a2)           { return (ULONGLONG)a1  op  a2.QuadPart; }   \
    inline BOOL operator op (ULONGLONG a1, const ULARGE_INTEGER& a2)           { return a1  op  a2.QuadPart;            }   \
                                                                                                                            \
    inline BOOL operator op (const LARGE_INTEGER& a1,      LONG a2)           { return a1.QuadPart op a2;               }   \
    inline BOOL operator op (const LARGE_INTEGER& a1,     ULONG a2)           { return a1.QuadPart op a2;               }   \
    inline BOOL operator op (     LONG a1, const LARGE_INTEGER& a2)           { return a1 op a2.QuadPart;               }   \
    inline BOOL operator op (    ULONG a1, const LARGE_INTEGER& a2)           { return a1 op  a2.QuadPart;              }   \
                                                                                                                            \
    inline BOOL operator op (const ULARGE_INTEGER& a1,      LONG a2)           { return a1.QuadPart  op  a2;            }   \
    inline BOOL operator op (const ULARGE_INTEGER& a1,     ULONG a2)           { return a1.QuadPart  op  a2;            }   \
    inline BOOL operator op (     LONG a1, const ULARGE_INTEGER& a2)           { return a1  op  a2.QuadPart;            }   \
    inline BOOL operator op (    ULONG a1, const ULARGE_INTEGER& a2)           { return a1  op  a2.QuadPart;            }   \


DEFINE_LARGE_BOOLEAN(==);
DEFINE_LARGE_BOOLEAN(!=);
DEFINE_LARGE_BOOLEAN(>);
DEFINE_LARGE_BOOLEAN(>=);
DEFINE_LARGE_BOOLEAN(<);
DEFINE_LARGE_BOOLEAN(<=);


/////////////////////////////////////////////////////////////
//
// Reasonable arithmetic on FILETIMEs
//
/////////////////////////////////////////////////////////////
inline ULONGLONG& Int(FILETIME& ft)
{
    return *(ULONGLONG*)&ft;
}
inline const ULONGLONG& Int(const FILETIME& ft)
{
    return *(const ULONGLONG*)&ft;
}


#define DEFINE_FILETIME_ARITHMETIC(op)                                              \
                                                                                    \
inline FILETIME operator op (const FILETIME& a1, const FILETIME& a2)                \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = Int(a1)  op  Int(a2);                                                  \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (const FILETIME& a1, LONGLONG a2)                       \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = Int(a1)  op  a2;                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (const FILETIME& a1, LONG a2)                           \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = Int(a1)  op  a2;                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (const FILETIME& a1, ULONGLONG a2)                      \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = Int(a1)  op  a2;                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (const FILETIME& a1, ULONG a2)                          \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = Int(a1)  op  a2;                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (LONGLONG a1, const FILETIME& a2)                       \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = a1  op  Int(a2);                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (LONG a1, const FILETIME& a2)                           \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = a1  op  Int(a2);                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (ULONGLONG a1, const FILETIME& a2)                      \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = a1  op  Int(a2);                                                       \
    return l;                                                                       \
    }                                                                               \
                                                                                    \
inline FILETIME operator op (ULONG a1, const FILETIME& a2)                          \
    {                                                                               \
    FILETIME l;                                                                     \
    Int(l) = a1  op  Int(a2);                                                       \
    return l;                                                                       \
    }


DEFINE_FILETIME_ARITHMETIC(+);
DEFINE_FILETIME_ARITHMETIC(-);
DEFINE_FILETIME_ARITHMETIC(*);
DEFINE_FILETIME_ARITHMETIC(/);

#define DEFINE_FILETIME_BOOLEAN(op)                                                                                 \
                                                                                                                    \
    inline BOOL operator op (const  FILETIME& a1, const  FILETIME& a2)   { return Int(a1) op Int(a2);   }           \
                                                                                                                    \
    inline BOOL operator op (const FILETIME& a1,  LONGLONG a2)           { return (LONGLONG)Int(a1) op a2;    }     \
    inline BOOL operator op (const FILETIME& a1, ULONGLONG a2)           { return Int(a1) op a2;              }     \
    inline BOOL operator op ( LONGLONG a1, const FILETIME& a2)           { return a1 op (LONGLONG)Int(a2);    }     \
    inline BOOL operator op (ULONGLONG a1, const FILETIME& a2)           { return a1 op Int(a2);              }     \
                                                                                                                    \
    inline BOOL operator op (const FILETIME& a1,      LONG a2)           { return Int(a1) op a2;               }    \
    inline BOOL operator op (const FILETIME& a1,     ULONG a2)           { return Int(a1) op a2;               }    \
    inline BOOL operator op (     LONG a1, const FILETIME& a2)           { return a1 op Int(a2);               }    \
    inline BOOL operator op (    ULONG a1, const FILETIME& a2)           { return a1 op Int(a2);               }


DEFINE_FILETIME_BOOLEAN(==);
DEFINE_FILETIME_BOOLEAN(!=);
DEFINE_FILETIME_BOOLEAN(>);
DEFINE_FILETIME_BOOLEAN(>=);
DEFINE_FILETIME_BOOLEAN(<);
DEFINE_FILETIME_BOOLEAN(<=);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\shared\comregistration\comregistration.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
 Microsoft Transaction Server (Microsoft Confidential)

 Implementation of a simple utility class that supports registering and 
 unregistering COM classes.                      

 
-------------------------------------------------------------------------------
Revision History:

 @rev 2     | 08/05/97 | BobAtk      | Alternate server types. AppIDs.
 @rev 1     | 07/22/97 | BobAtk      | Adapted to shared code. Made fully Unicode.
                                     | Dynaload OLE Libraries.
 @rev 0     | 07/08/97 | DickD       | Created
---------------------------------------------------------------------------- */

#include "stdpch.h"
#include "ComRegistration.h"
#include <malloc.h>


// BUGBUG: I don't know why this doesn't work.
//         It refuses to find Win4AssertEx (?) so I'm just gonna
//         remove the assert completely
#ifdef Assert
#undef Assert
#endif
#define Assert(x) (0)

//////////////////////////////////////////////////////////////////////////////

static void GetGuidString(const GUID & i_rGuid, WCHAR * o_pstrGuid);
static void DeleteKey(HKEY hKey, LPCWSTR szSubKey);
static void GuardedDeleteKey(HKEY hKey, LPCWSTR szSubKey);
static void DeleteValue(HKEY hKey, LPCWSTR szSubKey, LPCWSTR szValue);
static void SetKeyAndValue
					(HKEY	i_hKey,		// input key handle (may be 0 for no-op)
					LPCWSTR	i_szKey,	// input key string (ptr may be NULL)
					LPCWSTR	i_szVal,	// input value string (ptr may be NULL)
					HKEY *	o_phkOut,   // may be NULL.  If supplied, means leave key handle open for subsequent steps.
                    BOOL fForceKeyCreation=FALSE    // if true, key is created even if no value to be set
                    );
static void SetValue
					(HKEY		i_hKey,	    // input key handle (may be 0 for no-op)
					const WCHAR *i_szName,	// input value name string (ptr may be NULL)
					const WCHAR *i_szVal);	// input value string (ptr may be NULL)
static LPWSTR GetSubkeyValue
                    (HKEY hkey, 
                    LPCWSTR szSubKeyName, 
                    LPCWSTR szValueName, 
                    WCHAR szValue[MAX_PATH]);
static HRESULT UnRegisterTypeLib               
                    (LPCWSTR szModuleName); 

///////////////////////////////////////////////////////////////////////////////

#define HKCR        HKEY_CLASSES_ROOT       // Just to make typing simpler.
#define GUID_CCH    39                      // length of a printable GUID, with braces & trailing NULL

///////////////////////////////////////////////////////////////////////////////

// A utility that accomplishes a non-local jump, giving us an HRESULT 
// to return when we catch it.
//
inline static void THROW_HRESULT(HRESULT hr)
    {
    // Ideally we'd like our own exception code, but this will work fine as
    // no one actually throws it.
    //
	DWORD_PTR newhr = hr;
    RaiseException(NOERROR,EXCEPTION_NONCONTINUABLE,1,&newhr);
    }
inline static HRESULT HRESULTFrom(EXCEPTION_POINTERS* e)
    {
        if (!e)
            return E_FAIL;
    Assert(e && e->ExceptionRecord && (e->ExceptionRecord->NumberParameters == 1));
    return (HRESULT)e->ExceptionRecord->ExceptionInformation[0];
    }
#define THROW_LAST_ERROR()  THROW_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
#define IS_THROWN_HRESULT() (GetExceptionCode() == NOERROR)
#define HError()            (HRESULT_FROM_WIN32(GetLastError()))



//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::RegisterClass>
//
//  Makes registry entries under key
//  HKCR\CLASS\{....clsid....}
//-----------------------------------------------------------------------------

HRESULT ClassRegistration::Register()
    {
    HKEY    hkCLSID     = 0;
    HKEY    hkGuid      = 0;
    HKEY    hkProgID    = 0;
    HKEY    hkInproc    = 0;
    DWORD   dwLenFileName;
    WCHAR   szClsid[GUID_CCH];  // string form of CLSID
    WCHAR   szModuleName[MAX_PATH+1];
    EXCEPTION_POINTERS* e = NULL;
    HRESULT hr = S_OK;

    __try // to get the finally block
        {
        __try // to see if it's us throwing an HRESULT that we should turn into a return
            {
            // Obtain our module's file name
            Assert(hModule);
            if (hModule == NULL)
                return E_INVALIDARG;
            dwLenFileName = GetModuleFileName(hModule, szModuleName, MAX_PATH);
            if (dwLenFileName == 0)
            {
				//_RPTF0(_CRT_ERROR, "GetModuleFileName returned 0\n");
                return E_UNEXPECTED;
            }

            if (clsid == GUID_NULL)
                return E_INVALIDARG;
            
            LONG lRet = RegOpenKeyEx(HKCR, L"CLSID", 0, KEY_ALL_ACCESS, &hkCLSID);
            if (ERROR_SUCCESS != lRet)
                return HRESULT_FROM_WIN32 (lRet);

            GetGuidString(clsid, szClsid);  // make string form of CLSID 

            // 
            // Set the class name
            //
            SetKeyAndValue(hkCLSID, szClsid, className, &hkGuid, TRUE);

            //
            // Set the appid if asked to
            //
            if (appid != GUID_NULL)
                {
                WCHAR szAppId[GUID_CCH];
                GetGuidString(appid, szAppId);
                SetValue(hkGuid, L"AppID", szAppId);
                //
                // Ensure that the APPID entry exists
                //
                AppRegistration a;
                a.appid = appid;
                hr = a.Register();
                if (!!hr) return hr;
                }

            // Set the appropriate execution information
            // 
            switch (serverType)
                {
            case INPROC_SERVER:
                SetKeyAndValue(hkGuid,   L"InprocServer32", szModuleName, &hkInproc);
                SetValue      (hkInproc, L"ThreadingModel", threadingModel);
                break;
            
            case LOCAL_SERVER:
                SetKeyAndValue(hkGuid,   L"LocalServer32", szModuleName, NULL);
                break;

            case INPROC_HANDLER:
                SetKeyAndValue(hkGuid,   L"InprocHandler32", szModuleName, NULL);
                break;

            case SERVER_TYPE_NONE:
                break;

            default:
                return E_INVALIDARG;
                }
    
            // HKCR\CLSID\{....clsid....}\ProgID = "x.y.1"
            SetKeyAndValue(hkGuid, L"ProgID", progID, NULL);

            // HKCR\CLSID\{....clsid....}\VersionIndependentProgID = "x.y"
            SetKeyAndValue(hkGuid, L"VersionIndependentProgID", versionIndependentProgID, NULL);

            RegCloseKey(hkGuid);
            hkGuid = 0;

            // HKCR\x.y.1 = "Class Name"
            SetKeyAndValue(HKCR, progID, className, &hkProgID);

            //      CLSID = {....clsid....}
            SetKeyAndValue(hkProgID, L"CLSID", szClsid, NULL);
            RegCloseKey(hkProgID);
            hkProgID = 0;

            // HKCR\x.y = "Class Name"
            SetKeyAndValue(HKCR, versionIndependentProgID, className,&hkProgID);

            //      CLSID = {....clsid....}
            SetKeyAndValue(hkProgID, L"CLSID", szClsid, NULL);

            //      CurVer = "x.y.1"
            SetKeyAndValue(hkProgID, L"CurVer", progID, NULL);
            RegCloseKey(hkProgID);
            hkProgID = 0;

            // Register the typelib that's present in this module, if any. Dynaload
            // OLEAUT32 to get there to avoid a static linkage against OLEAUT32
            //
            HINSTANCE hOleAut = LoadLibraryA("OLEAUT32");
            if (hOleAut)
                {
                __try
                    {
                    // Find LoadLibraryEx in OLEAUT32
                    //
                    typedef HRESULT (STDAPICALLTYPE *PFN_T)(LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib);
                    PFN_T MyLoadTypeLibEx = (PFN_T) GetProcAddress(hOleAut, "LoadTypeLibEx");

                    if (MyLoadTypeLibEx)
                        {
                        HRESULT hr;
                        ITypeLib * pITypeLib = 0;
                        hr = MyLoadTypeLibEx(szModuleName, REGKIND_REGISTER, &pITypeLib);
                        if (SUCCEEDED(hr))
                            {
                            Assert(pITypeLib);
                            pITypeLib->Release();
                            pITypeLib = 0;
                            }
                        else if (hr == TYPE_E_CANTLOADLIBRARY)
                            {
                            // There was no type lib in the DLL to register. So ignore
                            }
                        else
                            {
                            Assert(pITypeLib == 0);
                            return SELFREG_E_TYPELIB;
                            }
                        }
                    else
                        THROW_LAST_ERROR(); // LoadLibraryEx not found
                    }
                __finally
                    {
                    FreeLibrary(hOleAut);
                    }
                }
            else
                THROW_LAST_ERROR(); // Can't load OLEAUT32

            }

        __except(IS_THROWN_HRESULT() ? (e=GetExceptionInformation(),EXCEPTION_EXECUTE_HANDLER) : EXCEPTION_CONTINUE_SEARCH)
            {
            // If it's us throwing to ourselves, then extract the HRESULT and return
            //
            return HRESULTFrom(e);
            }
        }

    __finally
        {
        if (hkCLSID)  RegCloseKey(hkCLSID);
        if (hkGuid)   RegCloseKey(hkGuid);
        if (hkProgID) RegCloseKey(hkProgID);
        if (hkInproc) RegCloseKey(hkInproc);
        }

    return S_OK;
    }

//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::UnregisterClass>
//
//  Removes registry entries under key
//  HKCR\CLASS\{....clsid....}
//-----------------------------------------------------------------------------

HRESULT ClassRegistration::Unregister()
    {
    LONG    lRetVal;
    HKEY    hKeyCLSID   = 0;
    HKEY    hKeyGuid    = 0;
    HKEY    hKeyProgID  = 0;
    WCHAR   szClsid[GUID_CCH];
    EXCEPTION_POINTERS* e = NULL;

    __try // to get the finally block
        {
        __try // to see if it's us throwing an HRESULT that we should turn into a return
            {
            WCHAR szProgID[MAX_PATH];
            WCHAR szVersionIndependentProgID[MAX_PATH];

            // Get our string form
            //
            GetGuidString(clsid, szClsid);

            // Unregister the type library, if any.
            // 
                {
                WCHAR szModuleName[MAX_PATH+1];
                if (hModule == NULL)
                    return E_INVALIDARG;
                if (GetModuleFileName(hModule, szModuleName, MAX_PATH))
                    UnRegisterTypeLib(szModuleName); // ignore errors so as to continue with unregistration
                }

            //
            // Open the {clsid} key and remove all the gunk thereunder that we know about
            // 
            lRetVal = RegOpenKeyEx(HKCR, L"CLSID", 0, KEY_ALL_ACCESS, &hKeyCLSID);
            if (lRetVal == ERROR_SUCCESS)
                {
                Assert(hKeyCLSID);
                lRetVal = RegOpenKeyEx(hKeyCLSID, szClsid, 0, KEY_ALL_ACCESS, &hKeyGuid);
                if (lRetVal == ERROR_SUCCESS)
                    {
                    Assert(hKeyGuid);

                    // Figure out the prog id if they're not provided for us explicitly
                    // Ditto the version independent progID.
                    //
                    if (!progID) progID = 
                        GetSubkeyValue(hKeyGuid, L"ProgID",                   L"", szProgID);
                    if (!versionIndependentProgID) versionIndependentProgID = 
                        GetSubkeyValue(hKeyGuid, L"VersionIndependentProgID", L"", szProgID);

                    // Delete entries under the CLSID. We are conservative, in that
                    // if there are subkeys/values left that we don't know about, we
                    // leave a key intact. This leaks registry space in order to deal
                    // reasonably with a lack of full knowledge.
                    // 
                    // REVIEW: There's more work to do here. Such as dealing with 
                    // COM Categories, PersistentHandler, etc.
                    //
                    // Notably, we do NOT remove any extant TreatAs entry, or any
                    // AutoConvertTo entry, as these can be added by OTHERS in order
                    // to redirect legacy users of the class.
                    //
                    
                    //
                    // AppID entries
                    //
                    DeleteValue     (hKeyGuid, NULL, L"AppID");
                    //
                    // Inproc entries
                    //
                    DeleteValue     (hKeyGuid, L"InprocServer32", L"ThreadingModel");
                    GuardedDeleteKey(hKeyGuid, L"InprocServer32");
                    //
                    // Server keys
                    //
                    GuardedDeleteKey(hKeyGuid, L"LocalServer");
                    GuardedDeleteKey(hKeyGuid, L"InprocHandler");
                    GuardedDeleteKey(hKeyGuid, L"LocalServer32");
                    GuardedDeleteKey(hKeyGuid, L"InprocHandler32");
                    //
                    // Legacy COM categories
                    //
                    GuardedDeleteKey(hKeyGuid, L"Control");
                    GuardedDeleteKey(hKeyGuid, L"Programmable");
                    GuardedDeleteKey(hKeyGuid, L"DocObject");
                    GuardedDeleteKey(hKeyGuid, L"Insertable");
                    GuardedDeleteKey(hKeyGuid, L"Printable");
                    //
                    // OLE entries. We ignore possible subkeys cause we're lazy coders
                    // and because no one in their right mind would store info thereunder
                    // that should stick around after we've nuked the class itself.
                    //
                           DeleteKey(hKeyGuid, L"MiscStatus");
                           DeleteKey(hKeyGuid, L"Verb");
                           DeleteKey(hKeyGuid, L"AuxUserType");
                           DeleteKey(hKeyGuid, L"Conversion");
                           DeleteKey(hKeyGuid, L"DataFormats");
                    GuardedDeleteKey(hKeyGuid, L"ToolBoxBitmap32");
                    GuardedDeleteKey(hKeyGuid, L"DefaultIcon");
                    GuardedDeleteKey(hKeyGuid, L"Version");
                    //
                    // Prog id entries
                    //
                    GuardedDeleteKey(hKeyGuid, L"ProgID");
                    GuardedDeleteKey(hKeyGuid, L"VersionIndependentProgID");

                    RegCloseKey(hKeyGuid);
                    hKeyGuid = 0;
                    }
                //
                // Finally, delete the CLSID entry itself
                //
                GuardedDeleteKey(hKeyCLSID, szClsid);
                RegCloseKey(hKeyCLSID);
                hKeyCLSID = 0;
                }

            // HKEY_CLASSES_ROOT\MTS.Recorder.1
            // HKEY_CLASSES_ROOT\MTS.Recorder.1\CLSID

            if (progID)
                {
                lRetVal = RegOpenKeyEx(HKCR, progID, 0, KEY_ALL_ACCESS, &hKeyProgID);
                if (lRetVal == ERROR_SUCCESS)
                    {
                    Assert(hKeyProgID);
                    GuardedDeleteKey(hKeyProgID, L"CLSID");
                    RegCloseKey(hKeyProgID);
                    hKeyProgID = 0;
                    GuardedDeleteKey(HKCR, progID);
                    }
                }

            // HKEY_CLASSES_ROOT\MTS.Recorder
            // HKEY_CLASSES_ROOT\MTS.Recorder.1\CLSID
            // HKEY_CLASSES_ROOT\MTS.Recorder.1\CurVer

            if (versionIndependentProgID)
                {
                lRetVal = RegOpenKeyEx(HKCR, versionIndependentProgID, 0, KEY_ALL_ACCESS, &hKeyProgID);
                if (lRetVal == ERROR_SUCCESS)
                    {
                    Assert(hKeyProgID);
                    GuardedDeleteKey(hKeyProgID, L"CLSID");
                    GuardedDeleteKey(hKeyProgID, L"CurVer");
                    RegCloseKey(hKeyProgID);
                    hKeyProgID = 0;
                    GuardedDeleteKey(HKCR, versionIndependentProgID);
                    }
                }
            }

        __except(IS_THROWN_HRESULT() ? (e=GetExceptionInformation(),EXCEPTION_EXECUTE_HANDLER) : EXCEPTION_CONTINUE_SEARCH)
            {
            // If it's us throwing to ourselves, then extract the HRESULT and return
            //
            return HRESULTFrom(e);
            }
        }

    __finally
        {
        if (hKeyCLSID)  RegCloseKey(hKeyCLSID);
        if (hKeyGuid)   RegCloseKey(hKeyGuid);
        if (hKeyProgID) RegCloseKey(hKeyProgID);
        }

    return S_OK;
    }

//
//////////////////////////////////////////////////////////////////////////////
//
// Unregister the typelib contained in this module, if any
//

HRESULT UnRegisterTypeLib(LPCWSTR szModuleName)
    {
    HRESULT hr = S_OK;
    HINSTANCE hOleAut = LoadLibraryA("OLEAUT32");
    if (hOleAut)
        {
        __try
            {
            // Find UnRegisterTypeLib etc in OLEAUT32
            //
            typedef HRESULT (STDAPICALLTYPE *PFN_LOAD) (LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib);
            typedef HRESULT (STDAPICALLTYPE *PFN_UNREG)(REFGUID libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind);
            PFN_LOAD  MyLoadTypeLibEx     = (PFN_LOAD)  GetProcAddress(hOleAut, "LoadTypeLibEx");
            PFN_UNREG MyUnRegisterTypeLib = (PFN_UNREG) GetProcAddress(hOleAut, "UnRegisterTypeLib");

            if (MyLoadTypeLibEx && MyUnRegisterTypeLib)
                {
                // Load the typelib to see what version etc it is
                //
                ITypeLib* ptlb;
                hr = MyLoadTypeLibEx(szModuleName, REGKIND_NONE, &ptlb);
                if (hr==S_OK)
                    {
                    TLIBATTR* pa;
                    hr = ptlb->GetLibAttr(&pa);
                    if (hr==S_OK)
                        {
                        // Do the unregistration
                        //
                        hr = MyUnRegisterTypeLib(pa->guid, pa->wMajorVerNum, pa->wMinorVerNum, pa->lcid, pa->syskind);
                        ptlb->ReleaseTLibAttr(pa);
                        }
                    ptlb->Release();
                    }
                else
                    {
                    // Nothing to unregister, cause we don't have a type lib
                    }
                }
            else
                hr = HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND);  // entry points missing from OLEAUT32 
            }
        __finally
            {
            FreeLibrary(hOleAut);
            }
        }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());  // couldn't load OLEAUT32

    return hr;
    }


//
//////////////////////////////////////////////////////////////////////////////
//
// Register the indicate APPID information
//

HRESULT AppRegistration::Register()
    {
    HRESULT hr = S_OK;
    EXCEPTION_POINTERS* e = NULL;
    HKEY hkeyAllAppIds = NULL;
    HKEY hkeyAppId = NULL;

    __try // to get the finally block
        {
        __try // to see if it's us throwing an HRESULT that we should turn into a return
            {
            //
            // Ensure the root HKEY_CLASSES_ROOT\AppID key exists
            //
            SetKeyAndValue(HKEY_CLASSES_ROOT, L"AppID", NULL, &hkeyAllAppIds, TRUE);

            //
            // Ensure that our particular AppID key exists
            //
            if (appid == GUID_NULL) return E_INVALIDARG;
            WCHAR szAppId[GUID_CCH];
            GetGuidString(appid, szAppId);
            SetKeyAndValue(hkeyAllAppIds, szAppId, NULL, &hkeyAppId, TRUE);
                
            //
            // Set the appid name, if asked
            //
            if (appName)
                SetValue(hkeyAppId, NULL, appName);

            //
            // Set the DllSurrogate entry, if asked
            //
            if (dllSurrogate)
                {
                if (hModuleSurrogate)
                    {
                    WCHAR szModuleName[MAX_PATH+1];
                    if (!GetModuleFileName(hModuleSurrogate, szModuleName, MAX_PATH)) return HRESULT_FROM_WIN32(GetLastError());
                    SetValue(hkeyAppId, L"DllSurrogate", szModuleName);
                    }
                else
                    {
                    // Use the default surrogate
                    //
                    SetValue(hkeyAppId, L"DllSurrogate", L"");
                    }
                }
            }
        __except(IS_THROWN_HRESULT() ? (e=GetExceptionInformation(),EXCEPTION_EXECUTE_HANDLER) : EXCEPTION_CONTINUE_SEARCH)
            {
            // If it's us throwing to ourselves, then extract the HRESULT and return
            //
            return HRESULTFrom(e);
            }
        }

    __finally
        {
        // Cleanup on the way out
        //
        if (hkeyAllAppIds)  RegCloseKey(hkeyAllAppIds);
        if (hkeyAppId)      RegCloseKey(hkeyAppId);
        }
    return hr;
    }

//
//////////////////////////////////////////////////////////////////////////////
//
// Unregister the indicate APPID information
//

HRESULT AppRegistration::Unregister()
    {
    HRESULT hr = S_OK;
    EXCEPTION_POINTERS* e = NULL;
    HKEY hkeyAllAppIds = NULL;
    HKEY hkeyAppId = NULL;

    __try // to get the finally block
        {
        __try // to see if it's us throwing an HRESULT that we should turn into a return
            {
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, L"AppID", 0, KEY_ALL_ACCESS, &hkeyAllAppIds))
                {
                //
                // Get our AppID key, if it exists
                //
                if (appid == GUID_NULL) return E_INVALIDARG;
                WCHAR szAppId[GUID_CCH];
                GetGuidString(appid, szAppId);
                if (ERROR_SUCCESS == RegOpenKeyEx(hkeyAllAppIds, szAppId, 0, KEY_ALL_ACCESS, &hkeyAppId))
                    {
                    //
                    // Delete known values
                    //
                    DeleteValue(hkeyAppId, NULL, L"DllSurrogate");
                    DeleteValue(hkeyAppId, NULL, L"RemoteServerName");
                    DeleteValue(hkeyAppId, NULL, L"ActivateAtStorage");
                    DeleteValue(hkeyAppId, NULL, L"LocalService");
                    DeleteValue(hkeyAppId, NULL, L"ServiceParameters");
                    DeleteValue(hkeyAppId, NULL, L"RunAs");
                    DeleteValue(hkeyAppId, NULL, L"LaunchPermission");
                    DeleteValue(hkeyAppId, NULL, L"AccessPermission");
                    //
                    // Delete our APPID key
                    //
                    RegCloseKey(hkeyAppId); hkeyAppId = 0;
                    GuardedDeleteKey(hkeyAllAppIds, szAppId);
                    }
                }
            }
        __except(IS_THROWN_HRESULT() ? (e=GetExceptionInformation(),EXCEPTION_EXECUTE_HANDLER) : EXCEPTION_CONTINUE_SEARCH)
            {
            // If it's us throwing to ourselves, then extract the HRESULT and return
            //
            return HRESULTFrom(e);
            }
        }

    __finally
        {
        // Cleanup on the way out
        //
        if (hkeyAllAppIds)  RegCloseKey(hkeyAllAppIds);
        if (hkeyAppId)      RegCloseKey(hkeyAppId);
        }
    return hr;
    }


//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::GetGuidString>
//
//  Forms the string form of a GUID given its binary GUID. Dynaload OLE32.DLL
//  to avoid creating a static linkage. REVIEW: if this function is frequently
//  called then we'd want to cache the loading of OLE32.
//
//-----------------------------------------------------------------------------

static void GetGuidString(const GUID& rGuid, WCHAR * pstrGuid)
    {
    HINSTANCE hInstOle = LoadLibraryA("OLE32");
    if (hInstOle)
        {
        __try
            {
            typedef int (STDAPICALLTYPE* PFN_T)(REFGUID rguid, LPOLESTR lpsz, int cbMax);
            PFN_T MyStringFromGuid = (PFN_T) GetProcAddress(hInstOle, "StringFromGUID2");
            if (MyStringFromGuid)
                {
                int iLenGuid = MyStringFromGuid(rGuid, pstrGuid, GUID_CCH);
                Assert(iLenGuid == GUID_CCH);
                }
            else
                {
                THROW_LAST_ERROR();
                }
            }
        __finally
            {
            FreeLibrary(hInstOle);
            }
        }
    else
        {
        THROW_LAST_ERROR();
        }
    }


//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::GuardedDeleteKey>
//
//  Deletes a key if and only if it has no subkeys and no sub values.
//
//-----------------------------------------------------------------------------

static void DeleteKey(HKEY hKey, LPCWSTR szSubKey)
// Unconditionally delete a key
    {
    RegDeleteKey(hKey, szSubKey);
    }

static void GuardedDeleteKey(HKEY hKey, LPCWSTR szSubKey)
// Conditionally delete a key, only if it lacks children
    {
    HKEY  hSubkey;

    // If there's no subkey of that name, nothing to delete
    //
    if (ERROR_SUCCESS != RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubkey))
        return;

    DWORD cSubKeys;
    DWORD cValues;
    if (ERROR_SUCCESS == RegQueryInfoKeyA(hSubkey, 
            NULL,   // LPSTR lpClass,
            NULL,   // LPDWORD lpcbClass,
            0,      // LPDWORD lpReserved,
            &cSubKeys,
            NULL,   // LPDWORD lpcbMaxSubKeyLen,
            NULL,   // LPDWORD lpcbMaxClassLen,
            &cValues,
            NULL,   // LPDWORD lpcbMaxValueNameLen,
            NULL,   // LPDWORD lpcbMaxValueLen,
            NULL,   // LPDWORD lpcbSecurityDescriptor,
            NULL    // PFILETIME lpftLastWriteTime
            ))
        {
        RegCloseKey(hSubkey);

        // Don't delete if there are any child keys, or if there are any child values 
        // besides the default value, which is always there (true on Win95; assumed on NT).
        //
        if (cSubKeys > 0 || cValues > 1)
            return;

        RegDeleteKey(hKey, szSubKey);
        }
    else
        {
        RegCloseKey(hSubkey);
        }
    }

///////////////////////////////////////////////////

static void DeleteValue(HKEY hKey, LPCWSTR szSubkey, LPCWSTR szValue)
// Delete the indicated value under the indicated (optional) subkey of the indicated key.
    {
    Assert(hKey);
    if (szSubkey && lstrlenW(szSubkey)>0)
        {
        HKEY hSubKey;
        if (RegOpenKeyEx(hKey, szSubkey, 0, KEY_ALL_ACCESS, &hSubKey) == ERROR_SUCCESS)
            {
            RegDeleteValue(hSubKey, szValue);
            RegCloseKey(hSubKey);
            }
        }
    else
        RegDeleteValue(hKey, szValue);
    }

//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::SetKeyAndValue>
//
//  Stores a key and its associated value in the registry
//
//-----------------------------------------------------------------------------

static void SetKeyAndValue
        (
        HKEY        i_hKey,     // input key handle (may be 0 for no-op)
        const WCHAR *i_szKey,   // input key string (ptr may be NULL)
        const WCHAR *i_szVal,   // input value string (ptr may be NULL)
        HKEY *      o_phkOut,   // may be NULL.  If supplied, means leave key handle open for subsequent steps.
        BOOL        fForceKeyCreation
        )
    {
    long    lRet    = 0;        // output return code
    HKEY    hKey    = 0;        // new key's handle

    if (o_phkOut)               // init out params in all cases
        *o_phkOut = 0;

    if (i_hKey &&                       // have a parent key to make under
        i_szKey &&                      // got a child key to operate on
        (i_szVal || fForceKeyCreation)  // have a value to set or we really want to make the key anyway
       )                 
        {
        // Create a new key/value pair
        DWORD dwDisposition;
        lRet = RegCreateKeyEx(  i_hKey,         // open key handle 
                                i_szKey,        // subkey name
                                0,              // DWORD reserved 
                                L"",            // address of class string 
                                REG_OPTION_NON_VOLATILE,    // special options flag
                                KEY_ALL_ACCESS, // desired security access
                                NULL,           // address of key security structure
                                &hKey,          // address of buffer for opened handle
                                &dwDisposition);// address of disposition value buffer
        }
    else
        {
        // If we dont make sure the key exists, no point in trying the value
        return;
        }

    if (ERROR_SUCCESS == lRet && i_szVal)
        {
        Assert( (lRet != ERROR_SUCCESS) || hKey );  // if successful, better have got a key
        if (lRet == ERROR_SUCCESS)                  // new key's handle was opened
            {
            lRet = RegSetValueEx
                        (   
                            hKey,       // key handle
                            L"",        // value name (default)
                            0,          // reserved DWORD
                            REG_SZ,     // value type flag
                            (const BYTE *) i_szVal, // value data
                            sizeof(WCHAR) * (lstrlenW(i_szVal)+1) // byte count
                        );
            }
        }
    
    if (lRet != ERROR_SUCCESS)
        {
        if (hKey) RegCloseKey(hKey);
        THROW_LAST_ERROR();
        }
                         
    if (o_phkOut)               // caller wants output key
        {
        *o_phkOut = hKey;       // provide it (it's 0 if we failed)
        }
    else                        // caller doesn't want key
        {
        if (hKey) RegCloseKey(hKey);
        }

    } //end SetKeyAndValue

//----------------------------------------------------------------------------- 
// @mfunc <c ClassRegistration::SetValue>
//
//  Stores a name and its associated value in the registry
//  Note: this function takes an INPUT return code as well
//      as the more obvious input parameters.
//      The idea is that we can avoid a chain of return code
//      tests in the main line, we just can just keep calling
//      this function and it ceases to try to do work once the
//      return code is set to a non-zero value.
//
//-----------------------------------------------------------------------------
 
static void SetValue
        (
        HKEY        i_hKey,     // input key handle (may be 0 for no-op)
        const WCHAR *i_szName,  // input name string (ptr may be NULL)
        const WCHAR *i_szVal    // input value string (ptr may be NULL)
        )   
    {

    if (i_szVal &&              // non-null input value pointer (if NULL, we don't attempt to set)
        i_hKey)                 // non-zero input key handle
        {
        LONG lRet = RegSetValueEx
                    (
                        i_hKey,     // input key handle
                        i_szName,   // value name string (NULL for default value)
                        0,          // reserved DWORD
                        REG_SZ,
                        (const BYTE *) i_szVal, // value data
                        sizeof(WCHAR) * (lstrlenW(i_szVal)+1) // byte count
                    );
        if (lRet != ERROR_SUCCESS)
            THROW_LAST_ERROR();
        }
    
    } // end SetValue

////////////////////////////////////////////////////////////////////////////////

static LPWSTR GetSubkeyValue(HKEY hkey, LPCWSTR szSubKeyName, LPCWSTR szValueName, WCHAR szValue[MAX_PATH])
    {
    HKEY hSubkey;
    LPWSTR result = NULL;
    if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szSubKeyName, 0, KEY_READ, &hSubkey))
        {
        DWORD dwType;
        DWORD cbData = MAX_PATH * sizeof(WCHAR);
        if (ERROR_SUCCESS == RegQueryValueEx(hSubkey, szValueName, 0, &dwType, (BYTE*)szValue, &cbData))
            {
            result = &szValue[0];            
            }
        RegCloseKey(hSubkey);
        }
    return result;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\inc\vtable.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// vtable.h
//
// Generic definitions for creating vtables
//
typedef void (__stdcall * const PFN_VTABLE_ENTRY)();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\txfaux\stdpch.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.cpp
//
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\txfaux\debug.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// debug.cpp
//
#include "stdpch.h"
#include "common.h"

DECLARE_INFOLEVEL(Txf); // TXF support debug tracing

extern "C" void ShutdownCallFrame();

extern "C"
void ShutdownTxfAux()
{
    ShutdownCallFrame();
}

////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\txfaux\concurrent.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Concurrent.cpp
//
// Concurrency control support
//
#include "stdpch.h"
#include "common.h"


/////////////////////////////////////////////////////////////////////
//
// Some debug & trace support
//

// BUGBUG (JohnStra): On managing to get the magic comps.lib functionality
// working for IA64, I ran into AVs during the unwinding in the finally
// block.  For now, I'm disabling this for IA64.
#if defined(_DEBUG) && !defined(IA64) 
    #define PUBLIC_ENTRY    ASSERT(!m_lock.WeOwnExclusive()); __try {
    #define PUBLIC_EXIT(x)  } __finally { ASSERT(!m_lock.WeOwnExclusive()); x; }
#else
    #define PUBLIC_ENTRY
    #define PUBLIC_EXIT(x)
#endif

#if 0 && defined(_DEBUG)
#define TRACE0(x)  Print(x)
#define TRACE(x,y) Print(x,y)
#else
#define TRACE0(x)   0
#define TRACE(x,y)  0
#endif


////////////////////////////////////////////////////////////////////
//
// User mode implementation of XSLOCK
//
// This design was lifted from the kernel mode NT implementation of
// ERESOURCE, in ntos\ex\resource.c
//
////////////////////////////////////////////////////////////////////

XSLOCK::XSLOCK()
    {
    m_cOwner                = 0;
    m_isOwnedExclusive      = FALSE;
    m_cExclusiveWaiters     = 0;
    m_cSharedWaiters        = 0;
    m_ownerTable            = NULL;
    m_lock.FInit();
    DEBUG(fCheckInvariants  = TRUE;)
    DEBUG(CheckInvariants());
    }

XSLOCK::~XSLOCK()
    {
    if (m_ownerTable) CoTaskMemFree(m_ownerTable);
    }

////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

void XSLOCK::CheckInvariants()
    {
    ASSERT(fCheckInvariants == FALSE || fCheckInvariants == TRUE);
    if (fCheckInvariants)
        {
        if (IsSharedWaiting())
            {
            ASSERT(m_isOwnedExclusive || IsExclusiveWaiting());
            ASSERT(m_cOwner > 0);
            }

        if (IsExclusiveWaiting())
            {
            ASSERT(m_cOwner > 0);
            }
        }
    }

#endif

////////////////////////////////////////////////////////////////////

inline void XSLOCK::LockEnter() 
    { 
    ASSERT(!m_lock.WeOwnExclusive()); 
    m_lock.LockExclusive(); 
    DEBUG(CheckInvariants();)
    }

inline void XSLOCK::LockExit()
    { 
    ASSERT(m_lock.WeOwnExclusive()); 
    DEBUG(CheckInvariants();)
    m_lock.ReleaseLock(); 
    ASSERT(!m_lock.WeOwnExclusive());
    }



inline BOOL XSLOCK::IsExclusiveWaiting()
    {
    return m_cExclusiveWaiters > 0;
    }

inline BOOL XSLOCK::IsSharedWaiting()
    {
    return m_cSharedWaiters > 0;
    }

inline void XSLOCK::LetSharedRun()
// Let the shared guys run. Must be called
//      a) with shared guys waiting
//      b) with the lock held
// This function releases the lock as a side effect.
//
    {
    ASSERT(m_lock.WeOwnExclusive());

    ASSERT(IsSharedWaiting());
    m_isOwnedExclusive  = FALSE;
    ULONG cWaiters      = m_cSharedWaiters;
    m_cSharedWaiters    = 0;
    m_cOwner            = cWaiters;
    LockExit();

    ASSERT(!m_lock.WeOwnExclusive());

    m_semaphoreSharedWaiters.Release(cWaiters);
    }

inline void XSLOCK::LetExclusiveRun()
// Leth the exclusive guys run. Must be called
//      a) with exclusive guys waiting
//      b) with the lock held
// This function releases the lock as a side effect.
//
    {
    ASSERT(m_lock.WeOwnExclusive());

    ASSERT(IsExclusiveWaiting());
    m_isOwnedExclusive           = TRUE;
    m_ownerThreads[0].dwThreadId = (THREADID)1;   // will be set correctly later by the waiter who runs waiter
    m_ownerThreads[0].ownerCount = 1;
    m_cOwner                     = 1;
    m_cExclusiveWaiters         -= 1;
    LockExit();
    
    m_eventExclusiveWaiters.Set();      // an auto-reset event, so just lets one guy through
    }


static DWORD tlsIndexOwnerTableHint; // set to zero by the loader

static void AllocateTlsIndexOwnerTableHint()
// Allocate a tls index and atomically set it as our hint
{
    // Allocate a new index. Waste index zero if we happen to get it, since
    // it interferes with our ability to tell if we've initialized things yet
    // or not.
    //
    DWORD tlsIndex;
    do  
    {
        tlsIndex = TlsAlloc();
    }
    while (tlsIndex == 0);
    
    if (tlsIndex != 0xFFFFFFFF)
    {
        if (0 == InterlockedCompareExchange(&tlsIndexOwnerTableHint, tlsIndex, 0))
        {
            // We successfully set our new index
        }
        else
        {
            // Someone else got there before us; we don't need the one we just allocated.
            //
            TlsFree(tlsIndex);
        }
    }
}

inline void XSLOCK::SetOwnerTableHint(THREADID dwThreadId, XSLOCK::OWNERENTRY* pOwnerEntry)
// Set the owner table hint for the indicated thread, if we can.
{
    // Don't gratuitiously mess up other thread's hints!
    //
    if (dwThreadId == GetCurrentThreadId())
    {
        // Make sure we have a tls index to work with
        //
        if (tlsIndexOwnerTableHint == 0)
        {
            AllocateTlsIndexOwnerTableHint();
        }
        
        if (tlsIndexOwnerTableHint != 0)
        {
            //
            // Set up the hint
            //
            ASSERT(m_ownerTable);
#ifndef _WIN64
            ULONG iHint;
#else
            ULONGLONG iHint;
#endif
            iHint = (ULONG)(pOwnerEntry - m_ownerTable);
            ASSERT(1 <= iHint && iHint < m_ownerTable->tableSize);
            TlsSetValue(tlsIndexOwnerTableHint, (PVOID)iHint);
        }
    }
}

inline ULONG XSLOCK::GetOwnerTableHint(THREADID dwThreadId)
// Return a hint as to where we should look for this thread in the owner table array
{
    ASSERT(m_ownerTable);
    //
    // Don't gratuitiously mess up other thread's hints!
    //
    if (dwThreadId == GetCurrentThreadId() && tlsIndexOwnerTableHint != 0)
    {
        // iHint can come back zero if we've allocated tlsIndexOwnerTableHint but
        // have yet to ever actually set any TLS. Since it's only a hint, we just
        // ignore any bogus values.
        //
        ULONG iHint;
#ifndef _WIN64
        iHint = (ULONG)TlsGetValue(tlsIndexOwnerTableHint);
#else
        iHint = PtrToUlong(TlsGetValue(tlsIndexOwnerTableHint));
#endif
        if (iHint == 0 || iHint >= m_ownerTable->tableSize)
            iHint = 1;
        return iHint;
    }
    else
        return 1;
}

////////////////////////////////////////////////////////////////////

BOOL XSLOCK::LockShared(BOOL fWait)
{
    DEBUG(BOOL fAcquired = TRUE);
    PUBLIC_ENTRY
		
	LockEnter();
	
    THREADID dwThreadId = GetCurrentThreadId();
    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //
    if (m_cOwner == 0) 
	{
        m_ownerThreads[1].dwThreadId = dwThreadId;
        m_ownerThreads[1].ownerCount = 1;
        m_cOwner                     = 1;
        LockExit();
        return true;
	}
    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count.
    //
    if (m_isOwnedExclusive && (m_ownerThreads[0].dwThreadId == dwThreadId)) 
	{
        m_ownerThreads[0].ownerCount += 1;
		
        LockExit();
        return true;
	}
    //
    // Take the long way home
    //
    OWNERENTRY* pOwnerEntry = NULL;
    if (m_isOwnedExclusive)
	{
        // The resource is owned exclusive, but not by us.  We'll have to wait.
        // Find an empty entry in the thread array.
        //
        pOwnerEntry = FindThreadOrFree(THREADID(0));
	}
    else
	{
        // The resource is owned shared.
        //
        // If the current thread already has acquired the resource for
        // shared access, then increment the recursion count.
        //
        pOwnerEntry = FindThreadOrFree(dwThreadId);
		if (pOwnerEntry == NULL)
		{
			LockExit();
			return false;
		}
		
        if (pOwnerEntry->dwThreadId == dwThreadId) 
		{
            ASSERT(pOwnerEntry->ownerCount != 0);
            pOwnerEntry->ownerCount += 1;
            ASSERT(pOwnerEntry->ownerCount != 0);
			
            LockExit();
            return true;
		}
        //
        // This thread doesn't _already_ have shared access, so before we
        // grant it we need to see if there are any exclusive guys waiting.
        //
        // If there aren't, then we can grant. But if there are, then to avoid
        // starving them we need to defer the shared grant here until after
        // an exclusive has had its turn
        //
        if (!IsExclusiveWaiting())
		{
            pOwnerEntry->dwThreadId = dwThreadId;
            pOwnerEntry->ownerCount = 1;
            m_cOwner               += 1;
			
            LockExit();
            return true;
		}
	}
    //
    // The resource is either owned exclusive by some other thread, OR it is 
    // owned shared by some other threads, but there is an exclusive
    // waiter and the current thread does not already have shared access
    // to the resouce.
    //
    if (!fWait)
	{
        // He's not going to let us wait. So don't.
        //
        LockExit();
        DEBUG(fAcquired = FALSE);
        return false;
	}
    //
    // If the shared wait semphore has not yet been allocated, then allocate
    // and initialize it.
    //
    if (!m_semaphoreSharedWaiters.IsInitialized())
	{
        m_semaphoreSharedWaiters.Initialize();
	}
    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //
    pOwnerEntry->dwThreadId = dwThreadId;
    pOwnerEntry->ownerCount = 1;
    m_cSharedWaiters       += 1; ASSERT(IsSharedWaiting());
    
    LockExit();
	
    TRACE("XSLOCK 0x%08x:   ... waiting on shared ...\n", this);
    m_semaphoreSharedWaiters.Wait();
    TRACE("XSLOCK 0x%08x:   ... wait on shared done ...\n", this);
	
    PUBLIC_EXIT( fAcquired ? TRACE("XSLOCK 0x%08x: acquired shared\n", this) : TRACE("XSLOCK 0x%08x: couldn't wait to acquire shared\n", this) );
    return true;
}

////////////////////////////////////////////////////////////////////

inline XSLOCK::OWNERENTRY* XSLOCK::FindThread(THREADID dwThreadId)
// Find the owner entry for the indicated thread. The caller guarantees
// us that it is in there somewhere!
//
    {
    OWNERENTRY* pOwner = NULL;
    //
    // Try the likely suspects
    //
    if (m_ownerThreads[1].dwThreadId == dwThreadId) 
        {
        pOwner = &m_ownerThreads[1];
        } 
    else if (m_ownerThreads[0].dwThreadId == dwThreadId)
        {
        pOwner = &m_ownerThreads[0];
        }
    else 
        {
        // Search the owner table for a match. We know it's there somewhere!
        //
        ASSERT(m_ownerTable);
        //
        // Try first with the ownerTableHint on the current thread
        //
        ULONG iHint = GetOwnerTableHint(dwThreadId);
        ASSERT(1 <= iHint && iHint < m_ownerTable->tableSize);
        if (m_ownerTable[iHint].dwThreadId == dwThreadId)
            {
            // The hint matched!
            //
            pOwner = &m_ownerTable[iHint];
            }
        else
            {
            // Hint didn't match. Scan for the thing
            //
            pOwner = &m_ownerTable[1];
            while (true)
                {
                if (pOwner->dwThreadId == dwThreadId)
                    break;
                pOwner++;
                }
            }
        }    
    ASSERT(pOwner);
    return pOwner;
    }

////////////////////////////////////////////////////////////////////

XSLOCK::OWNERENTRY* XSLOCK::FindThreadOrFree(THREADID dwThreadId)
// This function searches for the specified thread in the resource
// thread array. If the thread is located, then a pointer to the
// array entry is returned as the fucntion value. Otherwise, a pointer
// to a free entry is returned.
//
    {
    // Search the owner threads for the specified thread and return either
    // a pointer to the found thread or a pointer to a free thread table entry.
    //
    if (m_ownerThreads[0].dwThreadId == dwThreadId)
        {
        return &m_ownerThreads[0];
        }
    else if (m_ownerThreads[1].dwThreadId == dwThreadId)
        {
        return &m_ownerThreads[1];
        }

    OWNERENTRY* pFreeEntry = NULL;
    BOOL fInOwnerTable = FALSE;
    if (m_ownerThreads[1].dwThreadId == THREADID(0))
        {
        pFreeEntry = &m_ownerThreads[1];
        }

    ULONG oldSize;
    if (m_ownerTable == NULL)
        {
        oldSize = 0;
        }
    else
        {
        // Scan the existing table, looking for the thread
        //
        oldSize = m_ownerTable->tableSize;
        OWNERENTRY* pOwnerBound = &m_ownerTable[oldSize];
        OWNERENTRY* pOwnerEntry = &m_ownerTable[1];
        do  {
            if (pOwnerEntry->dwThreadId == dwThreadId) 
                {
                // Found the thread! Set the thread's 
                // ownerTableHint and return the entry.
                //
                SetOwnerTableHint(dwThreadId, pOwnerEntry);
                return pOwnerEntry;
                }
            if ((pFreeEntry == NULL) && (pOwnerEntry->dwThreadId == THREADID(0))) 
                {
                pFreeEntry = pOwnerEntry;
                fInOwnerTable = TRUE;
                }
            pOwnerEntry++;
            } 
        while (pOwnerEntry < pOwnerBound);
        }
    //
    // We didn't find the entry. If we found a free entry, though,
    // then return it.
    //
    if (pFreeEntry != NULL)
        {
        // Set the  thread's ownerTableHint
        //
        if (fInOwnerTable) SetOwnerTableHint(dwThreadId, pFreeEntry);
        return pFreeEntry;
        }
    //
    // Allocate an expanded owner table
    //
    ULONG newSize;
    if (oldSize == 0)
        newSize = 3;
    else
        newSize = oldSize + 4;

    ULONG cbOldTable = oldSize * sizeof(OWNERENTRY);
    ULONG cbNewTable = newSize * sizeof(OWNERENTRY);

    OWNERENTRY* ownerTable = (OWNERENTRY*)CoTaskMemAlloc(cbNewTable);
    if (ownerTable)
        {
        // Init new table from old one
        //
        memset(ownerTable, 0, cbNewTable);
        memcpy(ownerTable, m_ownerTable, cbOldTable);
        ownerTable->tableSize = newSize;
        //
        // Free old table and keep the new one
        //
        if (m_ownerTable) CoTaskMemFree(m_ownerTable);
        m_ownerTable = ownerTable;
        //
        // Return one of the now available free entries
        //
        if (oldSize == 0) 
            oldSize++;                  // skip first table entry (contains tablesize)

        // Set the  thread's ownerTableHint and return the 
        // newly-created free entry.
        //
        pFreeEntry = &m_ownerTable[oldSize];
        SetOwnerTableHint(dwThreadId, pFreeEntry);
        ASSERT(pFreeEntry->dwThreadId == THREADID(0));
        return pFreeEntry;
        }
    else
        {
        // We really can't continue here.
        // 
        FATAL_ERROR();
        return 0;
        }
    }

////////////////////////////////////////////////////////////////////

BOOL XSLOCK::LockExclusive(BOOL fWait)
    {
    // Do some debugging checks to help detect deadlocks
    //
    #ifdef _DEBUG
    BOOL fAcquired = TRUE;
    if (fWait && WeOwnShared())
        {
        ASSERTMSG("Deadlock: acquiring an XSLOCK exclusive while we hold it shared\n", FALSE);
        }
    #endif

    PUBLIC_ENTRY
    LockEnter();

    THREADID dwThreadId = GetCurrentThreadId();
    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //
    if (m_cOwner != 0) 
        {
        // The resource is either owned exclusive or shared.
        //
        // If the resource is owned exclusive and the current thread is the
        // owner, then increment the recursion count.
        //
        if (m_isOwnedExclusive && m_ownerThreads[0].dwThreadId == dwThreadId)
            {
            m_ownerThreads[0].ownerCount += 1;
            }
        else
            {
            // The resource is either owned exclusive by some other thread, or owned shared.
            //
            // We need to wait.
            //
            if (!fWait)
                {
                LockExit();
                DEBUG(fAcquired = FALSE);
                return false;
                }
            //
            // If the exclusive wait event has not yet been allocated, then the
            // long path code must be taken.
            //
            if (!m_eventExclusiveWaiters.IsInitialized())
                {
                m_eventExclusiveWaiters.Initialize(/*manual reset*/ FALSE, /*initial state*/ FALSE);
                LockExit();
                //
                // Recurse
                //
                return LockExclusive(fWait);
                }
            else
                {
                // Wait for exclusive access to the resource to be granted and set the
                // owner thread.
                //
                m_cExclusiveWaiters += 1; ASSERT(IsExclusiveWaiting());
                LockExit();
                TRACE("XSLOCK 0x%08x:   ... waiting on exclusive ...\n", this);
                m_eventExclusiveWaiters.Wait();
                TRACE("XSLOCK 0x%08x:   ... wait on exclusive done ... \n", this);
                //
                // N.B. It is "safe" to store the owner thread without obtaining any
                //      locks since this thread has now been granted exclusive
                //      ownership.
                //
                m_ownerThreads[0].dwThreadId = dwThreadId;
                return true;
                }            
            NOTREACHED();
            }
        }
    else
        {
        // The resource is not owned. Grant us exclusive.
        //
        m_isOwnedExclusive           = TRUE;
        m_ownerThreads[0].dwThreadId = dwThreadId;
        m_ownerThreads[0].ownerCount = 1;
        m_cOwner                     = 1;
        }

    LockExit();
    PUBLIC_EXIT( fAcquired ? TRACE("XSLOCK 0x%08x: acquired exclusive\n", this) : TRACE("XSLOCK 0x%08x: couldn't wait to acquire exclusive\n", this) );

    return true;
    }

////////////////////////////////////////////////////////////////////

void XSLOCK::ReleaseLock()
    {
    PUBLIC_ENTRY

    LockEnter();
    //
    // If the resource is exclusively owned, then release exclusive
    // ownership. Otherwise, release shared ownership.
    //
    if (m_isOwnedExclusive)
        {
        // The lock is held exclusive. Since we're releasing the lock we
        // believe we hold the lock. Thus, that exclusive guy better be us!
        //
        ASSERT(m_ownerThreads[0].dwThreadId == GetCurrentThreadId());
        //
        // Decrement the recursion count and check if ownership can be released.
        //
        ASSERT(m_ownerThreads[0].ownerCount > 0);
        if (--m_ownerThreads[0].ownerCount != 0) 
            {
            LockExit();
            return;
            }
        //
        // Clear the owner thread.
        //
        m_ownerThreads[0].dwThreadId = 0;
        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //
        ASSERT(m_cOwner > 0); // REVIEW: Can this ever be >1? This is exclusive after all...
        if (--m_cOwner == 0) 
            {
            // If there are shared waiters, then grant shared access to the
            // resource. That is, let pending shareds go after each exclusive
            // is done so as to avoid starvation of the shareds.
            //
            if (IsSharedWaiting())
                {
                LetSharedRun();
                return;
                }
            //
            //  Otherwise, grant exclusive ownership if there are exclusive waiters.
            //
            else if (IsExclusiveWaiting())
                {
                LetExclusiveRun();
                return;
                }
            //
            // Otherwise we're just sitting pretty for the next lock request to come along
            //
            else
                m_isOwnedExclusive = FALSE;
            }
        }
    else
        {
        // The lock is held shared. Release the shared lock.
        //
        THREADID dwThreadId = GetCurrentThreadId();
        OWNERENTRY* pOwner = FindThread(dwThreadId);
        //
        // Decrement the recursion count and check if ownership can be released.
        //
        ASSERT(pOwner->dwThreadId == dwThreadId);
        ASSERT(pOwner->ownerCount > 0);
        if (--pOwner->ownerCount != 0) 
            {
            // Nope: this thread still has a lock
            //
            LockExit();
            return;
            }
        //
        // Yep. This thread now no longer has a lock. Clear the owner thread identity.
        //
        pOwner->dwThreadId = 0;
        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //
        ASSERT(m_cOwner > 0);
        if (--m_cOwner == 0) 
            {
            // If there are exclusive waiters, then grant exclusive access
            // to the resource.
            //
            if (IsExclusiveWaiting()) 
                {
                LetExclusiveRun();
                return;
                }
            }
        }

    LockExit();

    PUBLIC_EXIT(TRACE("XSLOCK 0x%08x: released\n", this));
    }


////////////////////////////////////////////////////////////////////
//
// Demote an exclusive lock to shared access. Similar in function to releasing an
// exclusive resource and then acquiring it for shared access; however the user calling 
// Demote may not necessarily relinquish access to the resource as the two step operation does.

void XSLOCK::Demote()    
    {
    PUBLIC_ENTRY
    LockEnter();

    ASSERT(m_isOwnedExclusive);
    ASSERT(m_ownerThreads[0].dwThreadId == GetCurrentThreadId());
    //
    // Convert the granted access from exclusive to shared.
    //
    m_isOwnedExclusive = FALSE;
    //
    // If there are any shared waiters, then grant them shared access.
    //
    if (IsSharedWaiting()) 
        {
        LetSharedRun();
        return;
        }
    
    LockExit();
    PUBLIC_EXIT(0);
    }

////////////////////////////////////////////////////////////////////
//

BOOL XSLOCK::WeOwnExclusive()
// This routine determines if a resource is acquired exclusive by the calling thread
//
    {
    BOOL fResult;
    LockEnter();

    fResult = m_isOwnedExclusive && (m_ownerThreads[0].dwThreadId == GetCurrentThreadId());

    LockExit();
    return fResult;
    }

BOOL XSLOCK::WeOwnShared()
// Answer as to whether this guy owns this lock shared but not exclusive. If it is owned
// shared, then it'll be a deadlock if we then try to get it exclusive.
{
    BOOL fResult = FALSE;
    LockEnter();
	
    if (m_isOwnedExclusive)
	{
        // If it's owned exclusive, then there's no way we can be owning it just-shared at the moment
        //
	}
    else
	{
        // No own owns it exclusive. If we own it all, then we must own it shared
        //
		THREADID dwThreadId = GetCurrentThreadId();
        OWNERENTRY* pOwnerEntry = FindThreadOrFree(dwThreadId);
		if (pOwnerEntry)
		{
			if (pOwnerEntry->dwThreadId == dwThreadId) 
            {
				ASSERT(pOwnerEntry->ownerCount != 0);
				fResult = TRUE;
            }
        }
	}
		
	LockExit();
	return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\txfaux\sources.inc ===
#
# Common build instructions for kernel / user mode
# COM support dll.
#
#   Bob Atkinson
#   September 1997


PRECOMPILED_INCLUDE     =..\stdpch.h
PRECOMPILED_CXX         =1
PRECOMPILED_SOURCEFILE  =..\stdpch.cpp

EXCEPTION_HANDLING      =$(SEHONLY)

INCLUDES	= $(INCLUDES); ..\..\..\..\ih

#
# SOURCES MOVED FROM HERE INTO COMPONENT DIRECTORIES
#

PASS0_HEADERDIR =..\..\inc
MIDL_UUIDDIR    =..\..\inc
VIPER_MIDL_FLAGS=$(MIDL_HEADER_AND_IID)

SOURCES_USED=$(SOURCES_USED) ..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\txfaux\stdpch.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// stdpch.h
//

//JohnDoty: Removed KERNELMODE stuff
extern "C" {
#include "crtdbg.h"
}

#include <stdio.h>
#include <stdarg.h>

extern "C" {

//JohnDoty: Removed dependancy on kernel headers
//#include "ntos.h"
//#include "zwapi.h"
//#include "fsrtl.h"

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"

#define NT_INCLUDED

#include "windows.h"
#include "objbase.h"
}

#include "math.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\txfaux\txfutil.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// txfutil.cpp
//
#include "stdpch.h"
#include "common.h"

/////////////////////////////////////////////////////////////////////////////////
//
// GUID conversion
//
/////////////////////////////////////////////////////////////////////////////////

void StringFromGuid(REFGUID guid, LPWSTR pwsz)
{
    // Example: 
    //
    // {F75D63C5-14C8-11d1-97E4-00C04FB9618A}
    _snwprintf(pwsz, 39, L"{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", 
               guid.Data1,
               guid.Data2,
               guid.Data3,
               guid.Data4[0], guid.Data4[1], 
               guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
}


void StringFromGuid(REFGUID guid, LPSTR psz)
{
    // Example:
    //
    // {F75D63C5-14C8-11d1-97E4-00C04FB9618A}
    _snprintf(psz, 39, "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", 
              guid.Data1,
              guid.Data2,
              guid.Data3,
              guid.Data4[0], guid.Data4[1], 
              guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7]);
}



BOOL HexStringToDword(LPCWSTR& lpsz, DWORD& Value, int cDigits, WCHAR chDelim)
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return FALSE;
    }

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}


HRESULT GuidFromString(LPCWSTR lpsz, GUID* pguid)
  // Convert the indicated string to a GUID. More lenient than the OLE32 version,
  // in that it works with or without the braces.
  //
{
    DWORD dw;

    if (L'{' == lpsz[0])    // skip opening brace if present
        lpsz++;

    if (!HexStringToDword(lpsz, pguid->Data1, sizeof(DWORD)*2, '-'))    return E_INVALIDARG;
    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))               return E_INVALIDARG;
    pguid->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))               return E_INVALIDARG;
    pguid->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))               return E_INVALIDARG;
    pguid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[6] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))                 return E_INVALIDARG;
    pguid->Data4[7] = (BYTE)dw;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////
//
// String concatenation functions of various flavor. All allocate a new string
// in which to put the result, which must be freed by the caller.
//
/////////////////////////////////////////////////////////////////////////////////

HRESULT __cdecl StringCat(UNICODE_STRING* pu, ...)
{
    LPWSTR wsz;
    va_list va;
    va_start(va, pu);
    HRESULT hr = StringCat(&wsz, va);
    if (!hr)
        RtlInitUnicodeString(pu, wsz);
    else
    {
        pu->Length = 0;
        pu->Buffer = NULL;
        pu->MaximumLength = 0;
    }
    return hr;
}

HRESULT __cdecl StringCat(LPWSTR* pwsz, ...)
{
    va_list va;
    va_start(va, pwsz);
    return StringCat(pwsz, va);
}

HRESULT StringCat(LPWSTR* pwsz, va_list vaIn)
{
    HRESULT hr = S_OK;

    //
    // What's the total length of the strings we need to concat?
    //
    va_list va;
    SIZE_T cchTotal = 0;
    va = vaIn;
    while(true)
    {
        LPWSTR wsz = va_arg(va, LPWSTR);
        if (NULL == wsz)
            break;
        cchTotal += wcslen(wsz);
    }
    va_end(va);

    //
    // Allocate the string
    //
    SIZE_T cbTotal = (cchTotal+1) * sizeof(WCHAR);
    if (cbTotal > 0) 
    {
        LPWSTR wszBuffer = (LPWSTR)CoTaskMemAlloc(cbTotal);
        if (wszBuffer)
        {
            wszBuffer[0] = 0;

            //
            // Concatenate everything together
            //
            va = vaIn;
            while (true)
            {
                LPWSTR wsz = va_arg(va, LPWSTR);
                if (NULL == wsz)
                    break;
                wcscat(wszBuffer, wsz);
            }
            va_end(va);

            //
            // Return the string
            //
            *pwsz = wszBuffer;
        }
        else
        {
            *pwsz = NULL;
            hr = E_OUTOFMEMORY;
        }
    }
    else
        *pwsz = NULL;

    return hr;
}

void ToUnicode(LPCSTR sz, LPWSTR wsz, ULONG cch)
  // Convert the ansi string to unicode 
{
    UNICODE_STRING u;
    ANSI_STRING    a;
        
    u.Length        = 0;
    u.MaximumLength = (USHORT)(cch * sizeof(WCHAR));
    u.Buffer        = wsz;
        
    a.Length        = (USHORT) strlen(sz);
    a.MaximumLength = a.Length;
    a.Buffer        = (LPSTR)sz;
        
    RtlAnsiStringToUnicodeString(&u, &a, FALSE);
    wsz[strlen(sz)] = 0;
}

LPWSTR ToUnicode(LPCSTR sz)
{
    SIZE_T cch = strlen(sz) + 1;
    LPWSTR wsz = (LPWSTR)CoTaskMemAlloc( cch * sizeof(WCHAR) );
    if (wsz)
    {
        ToUnicode(sz, wsz, (ULONG) cch);
    }
    return wsz;
}

//
/////////////////////////////////////////////////////////////////////////////////
//
// Stream utilities
//
/////////////////////////////////////////////////////////////////////////////////

HRESULT Read(IStream* pstm, LPVOID pBuffer, ULONG cbToRead)
{
    ASSERT(pstm); ASSERT(pBuffer);
    HRESULT_ hr = S_OK;
    ULONG cbRead;
    hr = pstm->Read(pBuffer, cbToRead, &cbRead);
    if (cbToRead == cbRead)
    {
        ASSERT(!hr);
    }
    else 
    {
        if (!FAILED(hr))
        {
            hr = STG_E_READFAULT;
        }
    }
    return hr;
}

HRESULT Write(IStream* pstm, const void *pBuffer, ULONG cbToWrite)
{
    ASSERT(pstm); ASSERT(pBuffer || cbToWrite==0);
    HRESULT_ hr = S_OK;
    if (cbToWrite > 0)  // writing zero bytes is pointless, and perhaps dangerous (can truncate stream?)
    {
        ULONG cbWritten;
        hr = pstm->Write(pBuffer, cbToWrite, &cbWritten);
        if (cbToWrite == cbWritten)
        {
            ASSERT(!hr);
        }
        else 
        {
            if (!FAILED(hr))
            {
                hr = STG_E_WRITEFAULT;
            }
        }
    }
    return hr;
}

HRESULT SeekFar(IStream* pstm, LONGLONG offset, STREAM_SEEK fromWhat)
{
    ULARGE_INTEGER ulNewPosition;
    LARGE_INTEGER  lMove;
    lMove.QuadPart = offset;
    return pstm->Seek(lMove, fromWhat, &ulNewPosition);
}

HRESULT Seek(IStream* pstm, LONG offset, STREAM_SEEK fromWhat)
{
    ULARGE_INTEGER ulNewPosition;
    LARGE_INTEGER  lMove;
    lMove.QuadPart = offset;
    return pstm->Seek(lMove, fromWhat, &ulNewPosition);
}

HRESULT Seek(IStream* pstm, ULONG offset, STREAM_SEEK fromWhat)
{
    ULARGE_INTEGER ulNewPosition;
    LARGE_INTEGER  lMove;
    lMove.QuadPart = offset;
    return pstm->Seek(lMove, fromWhat, &ulNewPosition);
}

/////////////////////////////////////////////////////////////////////////////////
//
// CanUseCompareExchange64
//
/////////////////////////////////////////////////////////////////////////////////

#if defined(_X86_)

extern "C" BOOL __stdcall CanUseCompareExchange64()
// Figure out whether we're allowed to use hardware support for 8 byte interlocked compare exchange 
{
    return IsProcessorFeaturePresent(PF_COMPARE_EXCHANGE_DOUBLE);    
}

#endif


///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Error code managment
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT HrNt(NTSTATUS status)
  // Convert an NTSTATUS code into an appropriate HRESULT
{
    if (STATUS_SUCCESS == status)
    {
        // Straitforward success maps to itself 
        //
        return S_OK;
    }
    else if (NT_SUCCESS(status))
    {
        // Policy driven by fear of distorting existing code paths:
        // success statuses map to themselves!
        //
        // This is primarily here for the set of registry APIs.
        // (See registry.cpp)
        return status;
    }
    else
    {
        switch (status)
        {
            //
            // Handle a few as mapping to equivalent first-class HRESULTs
            //
        case STATUS_NO_MEMORY:          return E_OUTOFMEMORY;
        case STATUS_NOT_IMPLEMENTED:    return E_NOTIMPL;
        case STATUS_INVALID_PARAMETER:  return E_INVALIDARG;
            //
            // The remainder we map through the RTL mapping table
            //
        default:
        {
            BOOL fFound = true;
            ULONG err = ERROR_NOT_ENOUGH_MEMORY;

            __try
              {
                  err = RtlNtStatusToDosError(status);
              }
            __except(EXCEPTION_EXECUTE_HANDLER)
              {
                  // RtlNtStatusToDosError(status) might throw an DbgBreakPoint() (maybe only on checked builds)
                  // for unmapped codes. We don't care about that, and so catch and ignore it if it happens.
                  //
                  fFound = false;
              }
                
            if (!fFound || err == ERROR_MR_MID_NOT_FOUND)
            {
                // There was no formal mapping for the status code. Do the best we can.
                //
                return HRESULT_FROM_NT(status);
            }
            else
            {
                if (err == (ULONG)status)
                {
                    // Status code mapped to itself
                    //
                    return HRESULT_FROM_NT(status);
                }
                else if (err < 65536)
                {
                    // Status code mapped to a Win32 error code
                    // 
                    return HRESULT_FROM_WIN32(err);
                }
                else
                {
                    // Status code mapped to something weird. Don't know how to HRESULT-ize
                    // the mapping, so HRESULT-ize the original status instead
                    //
                    return HRESULT_FROM_NT(status);
                }
            }
        }
        /* end switch */
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\txfaux\registry.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// registry.cpp
//
#include "stdpch.h"
#include "common.h"

////////////////////////////////////////////////////////////////////////////////////
//
// OpenRegistryKey
//
// Open or create a registry key. 
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT OpenRegistryKey(
        HREG*       phkey,                  // place to return new key
        HREG        hKeyParent OPTIONAL,    // parent key to open under. may be NULL.
        LPCWSTR     wszKeyName,             // child key name
        DWORD       dwDesiredAccess,        // read, write, etc 
        BOOL        fCreate                 // whether to force creation or not
        )
    {
    OBJECT_ATTRIBUTES objectAttributes;
    //
    // Initialize the object for the key.
    //
    UNICODE_STRING u;
    RtlInitUnicodeString(&u, wszKeyName);
    InitializeObjectAttributes( &objectAttributes,
                                &u,
                                OBJ_CASE_INSENSITIVE,
                                hKeyParent.h,
                                (PSECURITY_DESCRIPTOR)NULL);

    NTSTATUS status;
    if (fCreate)
        {
        ULONG disposition;
        status = ZwCreateKey(&phkey->h, dwDesiredAccess,&objectAttributes, 0, (PUNICODE_STRING)NULL, REG_OPTION_NON_VOLATILE, &disposition);
        }
    else
        {
        status = ZwOpenKey(&phkey->h, dwDesiredAccess, &objectAttributes );
        }
    return HrNt(status);
    }

////////////////////////////////////////////////////////////////////////////////////
//
// EnumerateRegistryKeys
//
// Return the data of a named value under a key. Free the returned information 
// with CoTaskMemFree.
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT EnumerateRegistryKeys(HREG hkey, ULONG index, LPWSTR* pwsz)
{
    HRESULT hr = S_OK;
    *pwsz = NULL;

    KEY_BASIC_INFORMATION* pInfo = NULL;
#ifdef DBG
    ULONG cbTry = 4;
#else
	ULONG cbTry = MAX_PATH;
#endif

    while (!hr)
	{
        ULONG cb = cbTry;
        pInfo = (KEY_BASIC_INFORMATION*)CoTaskMemAlloc(cb);
        if (pInfo)
		{
            ULONG cbResult;
            NTSTATUS status = ZwEnumerateKey(hkey.h, index, KeyBasicInformation, pInfo, cb, &cbResult);
            if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL)
			{
                CoTaskMemFree(pInfo); 
                cbTry *= 2;
			}
            else if (status == STATUS_NO_MORE_ENTRIES)
			{
                CoTaskMemFree(pInfo);
                pInfo = NULL;
                break;
			}
            else if (status == STATUS_SUCCESS)
			{
                break;
			}
            else
			{
                CoTaskMemFree(pInfo);
				pInfo = NULL;

                hr = HrNt(status);
			}
		}
        else
            hr = E_OUTOFMEMORY;
	}
    
    if (!hr && pInfo)
	{
        LPWSTR wsz = (LPWSTR)CoTaskMemAlloc(pInfo->NameLength + sizeof(WCHAR));
        if (wsz)
		{
            memcpy(wsz, &pInfo->Name[0], pInfo->NameLength);
            wsz[pInfo->NameLength / sizeof(WCHAR)] = 0;
            *pwsz = wsz;
		}
        else
            hr = E_OUTOFMEMORY;
	}

	if (pInfo)
		CoTaskMemFree(pInfo);
    
    return hr;
}


////////////////////////////////////////////////////////////////////////////////////
//
// GetRegistryValue
//
// Return the data of a named value under a key. Free the returned information 
// with CoTaskMemFree.
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT GetRegistryValue(HREG hkey, LPCWSTR wszValue, PKEY_VALUE_FULL_INFORMATION *ppinfo, ULONG expectedType)
    {
    UNICODE_STRING              unicodeString;
    NTSTATUS                    status;
    PKEY_VALUE_FULL_INFORMATION pinfoBuffer;
    ULONG                       keyValueLength;

    RtlInitUnicodeString(&unicodeString, wszValue);

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //
    status = ZwQueryValueKey( hkey.h,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) 
        {
        return HrNt(status);
        }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //
    pinfoBuffer = (PKEY_VALUE_FULL_INFORMATION)CoTaskMemAlloc(keyValueLength);
    if (!pinfoBuffer) 
        {
        return HrNt(STATUS_INSUFFICIENT_RESOURCES);
        }

    //
    // Query the data for the key value.
    //
    status = ZwQueryValueKey( hkey.h,
                              &unicodeString,
                              KeyValueFullInformation,
                              pinfoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (NT_SUCCESS(status)) 
        {
        if (expectedType == REG_NONE || expectedType == pinfoBuffer->Type)
            {
            //
            // Everything worked, so simply return the address of the allocated
            // buffer to the caller, who is now responsible for freeing it.
            //
            *ppinfo = pinfoBuffer;
            return S_OK;
            }
        else
            {
            CoTaskMemFree(pinfoBuffer);
            return REGDB_E_INVALIDVALUE;
            }
        }
    else
        {
        CoTaskMemFree(pinfoBuffer);
        return HrNt(status);
        }
    }


////////////////////////////////////////////////////////////////////////////////////
//
// DoesRegistryValueExist
//
// Answer S_OK or S_FALSE as to whether a given value exists under a particular registry key.
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT DoesRegistryValueExist(HREG hkey, LPCWSTR wszValue)
    {
    UNICODE_STRING              unicodeString;
    NTSTATUS                    status;
    ULONG                       keyValueLength;

    RtlInitUnicodeString(&unicodeString, wszValue);

    status = ZwQueryValueKey( hkey.h,
                              &unicodeString,
                              KeyValueFullInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );

    if (status != STATUS_BUFFER_OVERFLOW && status != STATUS_BUFFER_TOO_SMALL) 
        {
        return S_FALSE;
        }

    return S_OK;
    }


////////////////////////////////////////////////////////////////////////////////////
//
// SetRegistryValue
//
// Set the value of a named-value that lives under the given key. The value we
// set is the concatenation of a list of literal zero-terminated string values.
// The end of the list is indicated with a NULL entry.
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT __cdecl SetRegistryValue(HREG hkey, LPCWSTR wszValueName, ...)
    {
    HRESULT_ hr = S_OK;

    LPWSTR wszValue;

    //
    // Concatenate the values altogether
    //
    va_list va;
    va_start(va, wszValueName);
    hr = StringCat(&wszValue, va);
    va_end(va);

    if (!hr)
        {
        //
        // Write the value
        //
        ULONG cbValue = (ULONG) (wcslen(wszValue)+1) * sizeof(WCHAR);
        NTSTATUS status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE, (PWSTR)hkey.h, (PWSTR)wszValueName, REG_SZ, wszValue, cbValue);
        if (NT_SUCCESS(status))
            {
            // All is well; do nothing
            }
        else
            hr = HrNt(status);

        //
        // Clean up
        //
        CoTaskMemFree(wszValue);
        }

    return hr;
    }


////////////////////////////////////////////////////////////////////////////////////
//
// RegisterInterfaceName
//
// Helper routine that sets the name of a given interface IID in the registry.
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT RegisterInterfaceName(REFIID iid, LPCWSTR wszInterfaceName)
    {
    HRESULT hr = S_OK;

    #define GUID_CCH 39
    LPCWSTR wszInterface = L"\\Registry\\Machine\\Software\\Classes\\Interface";
    HREG hKeyInterface;
    hr = CreateRegistryKey(&hKeyInterface, HREG(), wszInterface);
    if (!hr)
        {
        WCHAR wszIID[GUID_CCH];
        StringFromGuid(iid, &wszIID[0]);

        HREG hKeyIID;
        hr = CreateRegistryKey(&hKeyIID, hKeyInterface, wszIID);
        if (!hr)
            {
            hr = SetRegistryValue(hKeyIID, L"", wszInterfaceName);

            CloseRegistryKey(hKeyIID);
            }

        CloseRegistryKey(hKeyInterface);
        }

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\txf\txfaux\init.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// init.cpp
//
#include "stdpch.h"
#include "common.h"
#include "callobj.h"

/////////////////////////////////////////////////////////////////////////////
//
// DllMain
//
/////////////////////////////////////////////////////////////////////////////

BOOL g_fProcessDetach = FALSE;

// The init functions scattered throughout the DLL.
BOOL InitTypeInfoCache();
BOOL InitLegacy();
BOOL InitCallFrame();
BOOL InitMetaDataCache();
BOOL InitDisabledFeatures();

// The corresponding cleanup functions.
void FreeTypeInfoCache();
void FreeMetaDataCache();

// These will be called manually, from inside ole32.dll's DllMain, 
// DllRegisterServer, etc.
#define DLLMAIN             TxfDllMain
#define DLLREGISTERSERVER   TxfDllRegisterServer
#define DLLUNREGISTERSERVER TxfDllUnregisterServer

// And this is maintained by ole32.
extern HINSTANCE g_hinst;

extern "C"
BOOL WINAPI DLLMAIN(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	BOOL fOK = TRUE;

	if (dwReason == DLL_PROCESS_ATTACH)
	{
        g_hinst = hInstance;

		// Moved the initialization work in here instead of in
		// constructor objects, since when linked with Ole32 we need
		// to control when this code is executed.
		fOK = InitTypeInfoCache ();
		
		if (fOK)
			fOK = InitLegacy();

		if (fOK)
			fOK = InitCallFrame();

		if (fOK)
			fOK = InitMetaDataCache();

		if (fOK)
			fOK = InitDisabledFeatures();
	}
	
	if (dwReason == DLL_PROCESS_DETACH || (!fOK))
	{
        g_fProcessDetach = TRUE;

		FreeTypeInfoCache();
		FreeMetaDataCache();

		ShutdownTxfAux();
	}

	return fOK;    // ok
}


/////////////////////////////////////////////////////////////////////////////
//
// DllRegisterServer
//
// Standard COM entry point that asks us to register ourselves
//
/////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT RegisterInterfaceName(REFIID iid, LPCWSTR name);

#define REGNAME(x) RegisterInterfaceName(__uuidof(x), L ## #x)


extern "C" HRESULT STDCALL RegisterCallFrameInfrastructure();
extern "C" HRESULT STDCALL UnregisterCallFrameInfrastructure();

STDAPI DLLREGISTERSERVER()
{
    REGNAME(ICallIndirect);
    REGNAME(ICallFrame);
    REGNAME(ICallInterceptor);
    REGNAME(ICallUnmarshal);
    REGNAME(ICallFrameEvents);
    REGNAME(ICallFrameWalker);
    REGNAME(IInterfaceRelated);

    return S_OK;
}


STDAPI DLLUNREGISTERSERVER()
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\util\exports.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       exports.cxx
//
//
//  History:    20-Jul-95    t-stevan    Created
//
//----------------------------------------------------------------------------

#include <ole2int.h>
#pragma hdrstop

#if DBG==1

const char *g_pscExportNames[] =
{
    "CoInitialize"
,    "CoUninitialize"
,    "CoGetClassObject"
,    "CoRegisterClassObject"
,    "CoRevokeClassObject"
,    "CoMarshalInterface"
,    "CoUnmarshalInterface"
,    "CoReleaseMarshalData"
,    "CoDisconnectObject"
,    "CoLockObjectExternal"
,    "CoGetStandardMarshal"
,    "CoIsHandlerConnected"
,    "CoFreeAllLibraries"
,    "CoFreeUnusedLibraries"
,    "CoCreateInstance"
,    "CLSIDFromString"
,    "CoIsOle1Class"
,    "ProgIDFromCLSID"
,    "CLSIDFromProgID"
,    "CoCreateGuid"
,    "CoFileTimeToDosDateTime"
,    "CoDosDateTimeToFileTime"
,    "CoFileTimeNow"
,    "CoRegisterMessageFilter"
,    "CoGetTreatAsClass"
,    "CoTreatAsClass"
,    "DllGetClassObject"
,    "StgCreateDocfile"
,    "StgCreateDocfileOnILockBytes"
,    "StgOpenStorage"
,    "StgOpenStorageOnILockBytes"
,    "StgIsStorageFile"
,    "StgIsStorageILockBytes"
,    "StgSetTimes"
,    "CreateDataAdviseHolder"
,    "CreateDataCache"
,    "BindMoniker"
,    "MkParseDisplayName"
,    "MonikerRelativePathTo"
,    "MonikerCommonPrefixWith"
,    "CreateBindCtx"
,    "CreateGenericComposite"
,    "GetClassFile"
,    "CreateFileMoniker"
,    "CreateItemMoniker"
,    "CreateAntiMoniker"
,    "CreatePointerMoniker"
,    "GetRunningObjectTable"
,    "ReadClassStg"
,    "WriteClassStg"
,    "ReadClassStm"
,    "WriteClassStm"
,    "WriteFmtUserTypeStg"
,    "ReadFmtUserTypeStg"
,    "OleInitialize"
,    "OleUninitialize"
,    "OleQueryLinkFromData"
,    "OleQueryCreateFromData"
,    "OleCreate"
,    "OleCreateFromData"
,    "OleCreateLinkFromData"
,    "OleCreateStaticFromData"
,    "OleCreateLink"
,    "OleCreateLinkToFile"
,    "OleCreateFromFile"
,    "OleLoad"
,    "OleSave"
,    "OleLoadFromStream"
,    "OleSaveToStream"
,    "OleSetContainedObject"
,    "OleNoteObjectVisible"
,    "RegisterDragDrop"
,    "RevokeDragDrop"
,    "DoDragDrop"
,    "OleSetClipboard"
,    "OleGetClipboard"
,    "OleFlushClipboard"
,    "OleIsCurrentClipboard"
,    "OleCreateMenuDescriptor"
,    "OleSetMenuDescriptor"
,    "OleDestroyMenuDescriptor"
,    "OleDraw"
,    "OleRun"
,    "OleIsRunning"
,    "OleLockRunning"
,    "CreateOleAdviseHolder"
,    "OleCreateDefaultHandler"
,    "OleCreateEmbeddingHelper"
,    "OleRegGetUserType"
,    "OleRegGetMiscStatus"
,    "OleRegEnumFormatEtc"
,    "OleRegEnumVerbs"
,    "OleConvertIStorageToOLESTREAM"
,    "OleConvertOLESTREAMToIStorage"
,    "OleConvertIStorageToOLESTREAMEx"
,    "OleConvertOLESTREAMToIStorageEx"
,    "OleDoAutoConvert"
,    "OleGetAutoConvert"
,    "OleSetAutoConvert"
,    "GetConvertStg"
,    "SetConvertStg"
,    "ReadOleStg"
,    "WriteOleStg"
,     "CoGetCallerTID"
,     "CoGetState"
,     "CoSetState"
,     "CoMarshalHresult"
,     "CoUnmarshalHresult"
,     "CoGetCurrentLogicalThreadId"
,     "CoGetPSClsid"
,     "CoMarshalInterThreadInterfaceInStream"
,     "IIDFromString"
,     "StringFromCLSID"
,     "StringFromIID"
,     "StringFromGUID2"
,     "CoBuildVersion"
,     "CoGetMalloc"
,     "CoInitializeWOW"
,     "CoUnloadingWOW"
,     "CoTaskMemAlloc"
,     "CoTaskMemFree"
,     "CoTaskMemRealloc"
,     "CoFreeLibrary"
,     "CoLoadLibrary"
,     "CoCreateFreeThreadedMarshaler"
,     "OleInitializeWOW"
,     "OleDuplicateData"
,     "OleGetIconOfFile"
,     "OleGetIconOfClass"
,     "OleMetafilePictFromIconAndLabel"
,     "OleTranslateAccelerator"
,     "ReleaseStgMedium"
,     "ReadStringStream"
,     "WriteStringStream"
,     "OpenOrCreateStream"
,     "IsAccelerator"
,     "CreateILockBytesOnHGlobal"
,     "GetHGlobalFromILockBytes"
,     "SetDocumentBitStg"
,     "GetDocumentBitStg"
,     "CreateStreamOnHGlobal"
,     "GetHGlobalFromStream"
,     "CoGetInterfaceAndReleaseStream"
,     "CoGetCurrentProcess"
,     "CoQueryReleaseObject"
,     "CoRegisterMallocSpy"
,     "CoRevokeMallocSpy"
,     "CoGetMarshalSizeMax"
,     "CoGetObject"
,     "CreateClassMoniker"
,     "OleCreateEx"
,     "OleCreateFromDataEx"
,     "OleCreateLinkFromDataEx"
,     "OleCreateLinkEx"
,     "OleCreateLinkToFileEx"
,     "OleCreateFromFileEx"
,     "CoRegisterSurrogate"
,     "CoCreateInstanceExAsync"
,     "CoGetClassObjectAsync"
};

const char *g_pscInterfaceNames[] =
{
    "API",
    "IUnknown",
    "IClassFactory",
    "IMarshal"
};

const char *g_pscIUnknownNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
};
const char *g_pscIClassFactoryNames[] =
{
     "CreateInstance"
,    "LockServer"
};
const char *g_pscIMarshalNames[] =
{
     "GetUnmarshalClass"
,    "GetMarshalSizeMax"
,    "MarshalInterface"
,    "UnmarshalInterface"
,    "ReleaseMarshalData"
,    "DisconnectObject"
};

const char *g_pscIStdMarshalInfoNames[] =
{
    "GetClassForHandler"
};

const char *g_pscIMessageFilterNames[] =
{
     "HandleInComingCall"
,    "RetryRejectedCall"
,    "MessagePending"
};

const char *g_pscIExternalConnectionNames[] =
{
     "AddConnection"
,    "ReleaseConnection"
};

const char *g_pscIEnumStringNames[] =
{
     "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIEnumUnknownNames[] =
{
     "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIEnumSTATSTGNames[] =
{
     "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscILockBytesNames[] =
{
     "ReadAt"
,    "WriteAt"
,    "Flush"
,    "SetSize"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
};

const char *g_pscIStreamNames[] =
{
     "Read"
,    "Write"
,    "Seek"
,    "SetSize"
,    "CopyTo"
,    "Commit"
,    "Revert"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
,    "Clone"
};

const char *g_pscIStorageNames[] =
{
     "CreateStream"
,    "OpenStream"
,    "CreateStorage"
,    "OpenStorage"
,    "CopyTo"
,    "MoveElementTo"
,    "Commit"
,    "Revert"
,    "EnumElements"
,    "DestroyElement"
,    "RenameElement"
,    "SetElementTimes"
,    "SetClass"
,    "SetStateBits"
,    "Stat"
};

const char *g_pscIRootStorageNames[] =
{
    "SwitchToFile"
};

const char *g_pscIEnumFORMATETCNames[] =
{
    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIEnumSTATDATANames[] =
{
    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIDataObjectNames[] =
{
    "GetData"
,    "GetDataHere"
,    "QueryGetData"
,    "GetCanonicalFormatEtc"
,    "SetData"
,    "EnumFormatEtc"
,    "DAdvise"
,    "DUnadvise"
,    "EnumDAdvise"
};

const char *g_pscIViewObjectNames[] =
{
    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
};

const char *g_pscIViewObject2Names[] =
{
    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
,    "GetExtent"
};

const char *g_pscIAdviseSinkNames[] =
{
    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
};

const char *g_pscIAdviseSink2Names[] =
{
    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
,    "OnLinkSrcChange"
};

const char *g_pscIDataAdviseHolderNames[] =
{
    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnDataChange"
};

const char *g_pscIOleCacheNames[] =
{
    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
};

const char *g_pscIOleCache2Names[] =
{
    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
,    "UpdateCache"
,    "DiscardCache"
};

const char *g_pscIOleCacheControlNames[] =
{
    "OnRun"
,    "OnStop"
};

const char *g_pscIDropTargetNames[] =
{
    "DragEnter"
,    "DragOver"
,    "DragLeave"
,    "Drop"
};

const char *g_pscIDropSourceNames[] =
{
    "QueryContinueDrag"
,    "GiveFeedback"
};

const char *g_pscIPersistNames[] =
{
    "GetClassID"
};

const char *g_pscIPersistStorageNames[] =
{
    "GetClassID"
,    "IsDirty"
,    "InitNew"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "HandsOffStorage"
};

const char *g_pscIPersistStreamNames[] =
{
    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
};

const char *g_pscIPersistFileNames[] =
{
    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "GetCurFile"
};

const char *g_pscIBindCtxNames[] =
{
    "RegisterObjectBound"
,    "RevokeObjectBound"
,    "ReleaseBoundObjects"
,    "SetBindOptions"
,    "GetBindOptions"
,    "GetRunningObjectTable"
,    "RegisterObjectParam"
,    "GetObjectParam"
,    "EnumObjectParam"
,    "RevokeObjectParam"
};

const char *g_pscIMonikerNames[] =
{
    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
,    "BindToObject"
,    "BindToStorage"
,    "Reduce"
,    "ComposeWith"
,    "Enum"
,    "IsEqual"
,    "Hash"
,    "IsRunning"
,    "GetTimeOfLastChange"
,    "Inverse"
,    "CommonPrefixWith"
,    "RelativePathTo"
,    "GetDisplayName"
,    "ParseDisplayName"
,    "IsSystemMoniker"
};

const char *g_pscIRunningObjectTableNames[] =
{
    "Register"
,    "Revoke"
,    "IsRunning"
,    "GetObject"
,    "NoteChangeTime"
,    "GetTimeOfLastChange"
,    "EnumRunning"
};

const char *g_pscIEnumMonikerNames[] =
{
    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIEnumOLEVERBNames[] =
{
    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};

const char *g_pscIOleObjectNames[] =
{
    "SetClientSite"
,    "GetClientSite"
,    "SetHostNames"
,    "Close"
,    "SetMoniker"
,    "GetMoniker"
,    "InitFromData"
,    "GetClipboardData"
,    "DoVerb"
,    "EnumVerbs"
,    "Update"
,    "IsUpToDate"
,    "GetUserClassID"
,    "GetUserType"
,    "SetExtent"
,    "GetExtent"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "GetMiscStatus"
,    "SetColorScheme"
};

const char *g_pscIOleClientSiteNames[] =
{
    "SaveObject"
,    "GetMoniker"
,    "GetContainer"
,    "ShowObject"
,    "OnShowWindow"
,    "RequestNewObjectLayout"
};

const char *g_pscIRunnableObjectNames[] =
{
    "GetRunningClass"
,    "Run"
,    "IsRunning"
,    "LockRunning"
,    "SetContainedObject"
};

const char *g_pscIParseDisplayNameNames[] =
{
    "ParseDisplayName"
};

const char *g_pscIOleContainerNames[] =
{
    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
};

const char *g_pscIOleItemContainerNames[] =
{
    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
,    "GetObject"
,    "GetObjectStorage"
,    "IsRunning"
};

const char *g_pscIOleAdviseHolderNames[] =
{
    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnRename"
,    "SendOnSave"
,    "SendOnClose"
};

const char *g_pscIOleLinkNames[] =
{
    "SetUpdateOptions"
,    "GetUpdateOptions"
,    "SetSourceMoniker"
,    "GetSourceMoniker"
,    "SetSourceDisplayName"
,    "GetSourceDisplayName"
,    "BindToSource"
,    "BindIfRunning"
,    "GetBoundSource"
,    "UnbindSource"
,    "Update"
};

const char *g_pscIOleWindowNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
};

const char *g_pscIOleInPlaceObjectNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
,    "InPlaceDeactivate"
,    "UIDeactivate"
,    "SetObjectRects"
,    "ReactivateAndUndo"
};

const char *g_pscIOleInPlaceActiveObjectNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
,    "TranslateAccelerator"
,    "OnFrameWindowActivate"
,    "OnDocWindowActivate"
,    "ResizeBorder"
,    "EnableModeless"
};

const char *g_pscIOleInPlaceUIWindowNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
};

const char *g_pscIOleInPlaceFrameNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
,    "InsertMenus"
,    "SetMenu"
,    "RemoveMenus"
,    "SetStatusText"
,    "EnableModeless"
,    "TranslateAccelerator"
};

const char *g_pscIOleInPlaceSiteNames[] =
{
    "GetWindow"
,    "ContextSensitiveHelp"
,    "CanInPlaceActivate"
,    "OnInPlaceActivate"
,    "OnUIActivate"
,    "GetWindowContext"
,    "Scroll"
,    "OnUIDeactivate"
,    "OnInPlaceDeactivate"
,    "DiscardUndoState"
,    "DeactivateAndUndo"
,    "OnPosRectChange"
};

const char *g_pscIRpcChannelBufferNames[] =
{
    "GetBuffer"
,    "SendReceive"
,    "FreeBuffer"
,    "GetDestCtx"
,    "IsConnected"
};

const char *g_pscIRpcProxyBufferNames[] =
{
    "Connect"
,    "Disconnect"
};

const char *g_pscIRpcStubBufferNames[] =
{
    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
,    "DebugServerQueryInterface"
,    "DebugServerRelease"
};

const char *g_pscIPSFactoryBufferNames[] =
{
    "CreateProxy"
,    "CreateStub"
};

const char *g_pscIRpcChannelNames[] =
{
    "GetStream"
,    "Call"
,    "GetDestCtx"
,    "IsConnected"
};

const char *g_pscIRpcProxyNames[] =
{
    "Connect"
,    "Disconnect"
};

const char *g_pscIRpcStubNames[] =
{
    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
};

const char *g_pscIPSFactoryNames[] =
{
    "CreateProxy"
,    "CreateStub"
};

const char **g_ppNameTables[] =
{
    g_pscExportNames,
    g_pscIUnknownNames,
    g_pscIClassFactoryNames,
    g_pscIMarshalNames,
    g_pscIStdMarshalInfoNames,
    g_pscIMessageFilterNames,
    g_pscIExternalConnectionNames,
    g_pscIEnumStringNames,
    g_pscIEnumUnknownNames,
    g_pscIEnumSTATSTGNames,
    g_pscILockBytesNames,
    g_pscIStreamNames,
    g_pscIStorageNames,
    g_pscIRootStorageNames,
    g_pscIEnumFORMATETCNames,
    g_pscIEnumSTATDATANames,
    g_pscIDataObjectNames,
    g_pscIViewObjectNames,
    g_pscIViewObject2Names,
    g_pscIAdviseSinkNames,
    g_pscIAdviseSink2Names,
    g_pscIDataAdviseHolderNames,
    g_pscIOleCacheNames,
    g_pscIOleCache2Names,
    g_pscIOleCacheControlNames,
    g_pscIDropTargetNames,
    g_pscIDropSourceNames,
    g_pscIPersistNames,
    g_pscIPersistStorageNames,
    g_pscIPersistStreamNames,
    g_pscIPersistFileNames,
    g_pscIBindCtxNames,
    g_pscIMonikerNames,
    g_pscIRunningObjectTableNames,
    g_pscIEnumMonikerNames,
    g_pscIEnumOLEVERBNames,
    g_pscIOleObjectNames,
    g_pscIOleClientSiteNames,
    g_pscIRunnableObjectNames,
    g_pscIParseDisplayNameNames,
    g_pscIOleContainerNames,
    g_pscIOleItemContainerNames,
    g_pscIOleAdviseHolderNames,
    g_pscIOleLinkNames,
    g_pscIOleWindowNames,
    g_pscIOleInPlaceObjectNames,
    g_pscIOleInPlaceActiveObjectNames,
    g_pscIOleInPlaceUIWindowNames,
    g_pscIOleInPlaceFrameNames,
    g_pscIOleInPlaceSiteNames,
    g_pscIRpcChannelBufferNames,
    g_pscIRpcProxyBufferNames,
    g_pscIRpcStubBufferNames,
    g_pscIPSFactoryBufferNames,
    g_pscIRpcChannelNames,
    g_pscIRpcProxyNames,
    g_pscIRpcStubNames,
    g_pscIPSFactoryNames
};

#endif // DBG==1

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\util\info.cxx ===
#include <ole2int.h>
#include <debnot.h>

DECLARE_INFOLEVEL(Cairole)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\util\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   util
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=    ..;..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc
INCLUDES=    $(INCLUDES);..\..\..\common;..\..\class;..\..\objact
INCLUDES=    $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=    $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=    $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)

C_DEFINES=    \
              $(C_DEFINES)    \
              -D_TRACKLINK_=1

SOURCES=      \
              $(SOURCES)      \
              ..\spyclnt.cxx  \
              ..\olespy.cxx   \
              ..\time.cxx     \
              ..\w32new.cxx   \
              ..\info.cxx     \
              ..\exports.cxx  \
              ..\task.cxx     \

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\util\olespy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       rpcspy.cxx
//
//  Contents:   rpcspy functions
//
//  Classes:
//
//  Functions:
//
//  History:    7-06-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#pragma hdrstop
#if DBG==1

#ifdef DCOM
#include    <activate.h>
#include    <getif.h>
#include    <objsrv.h>
#include    <remunk.h>
#include    <odeth.h>
#endif  // DCOM

#include <outfuncs.h>

#ifdef SERVER_HANDLER
#include "srvhdl.h"
#endif

#include "OleSpy.hxx"
#include "SpyClnt.hxx"

#include <trace.hxx>

void SetTraceInfoLevel(DWORD dwLevel);
int OleSpySendEntry(char * szOutBuf);


char szOutBuffer[2048];

typedef enum
{
     OleSpy_None   = 0
    ,OleSpy_Rpc    = 1
    ,OleSpy_API    = 2
    ,OleSpy_Method = 4
    ,OleSpy_OleThk = 8
} OleSpy;

// OleSpy output options
typedef  enum
{
     OleSpyOut_None     = 0
    ,OleSpyOut_Debugger = 1
    ,OleSpyOut_OleSpy   = 2
} OleSpyOut;

// interface to interface name and method mapping
typedef struct _tagIIDMethodNames
{
    IID const *piid;
    char *pszInterface;
    char **ppszMethodNames;
} IIDMethodNames;


DWORD nInCount = 0;
DWORD nOutCount = 0;

DWORD OleSpyOpt = OleSpy_None;
DWORD OleSpyOutput = OleSpyOut_None;
DWORD OleSpyBreakForUnknownCalls = 0;


// internal interfaces
IID IID_IRpcService = {0x0000001aL, 0, 0};
IID IID_IRpcSCM     = {0x0000001bL, 0, 0};
IID IID_IRpcCoAPI   = {0x0000001cL, 0, 0};
IID IID_IRpcDragDrop= {0x0000001dL, 0, 0};

CHAR   szSendBuf[OUT_BUF_SIZE] = "";   // Buffer used to modify message.
IIDMethodNames *GetIIDMethodName(REFIID riid);

//
// switch on to trace rpc calls
// by setting CairoleInfoLevel = DEB_USER1;
//
//
#define NESTING_SPACES 32
#define SPACES_PER_LEVEL 3
static char achSpaces[NESTING_SPACES+1] = "                                ";
WORD wlevel = 0;
char tabs[128];

//+---------------------------------------------------------------------------
//
//  Method:     PushLevel
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  History:    3-31-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void PushLevel()
{
    wlevel++;
}
//+---------------------------------------------------------------------------
//
//  Method:     PopLevel
//
//  Synopsis:
//
//  History:    3-31-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void PopLevel()
{
    if (wlevel)
        wlevel--;
}

//+---------------------------------------------------------------------------
//
//  Method:     NestingSpaces
//
//  Synopsis:
//
//  Arguments:  [psz] --
//
//  Returns:
//
//  History:    3-31-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void NestingSpaces(char *psz)
{
    int iSpaces, i;

    iSpaces = wlevel * SPACES_PER_LEVEL;

    while (iSpaces > 0)
    {
        i = min(iSpaces, NESTING_SPACES);
        memcpy(psz, achSpaces, i);
        psz += i;
        *psz = 0;
        iSpaces -= i;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     GetTabs
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    3-31-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR GetTabs()
{
    static char ach[256];
    char *psz;

    wsprintfA(ach, "%2d:", wlevel);
    psz = ach+strlen(ach);

    if (sizeof(ach)/SPACES_PER_LEVEL <= wlevel)
    {
        strcpy(psz, "...");
    }
    else
    {
        NestingSpaces(psz);
    }
    return ach;
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitializeOleSpy
//
//  Synopsis:
//
//  Arguments:  [dwLevel] --
//
//  Returns:
//
//  History:    11-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT UninitializeOleSpy(DWORD dwLevel)
{
    if (dwLevel == OLESPY_TRACE)
    {
        CleanupTraceInfo();
    }
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeOleSpy
//
//  Synopsis:
//
//  Arguments:  [dwReserved] --
//
//  Returns:
//
//  History:    11-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT InitializeOleSpy(DWORD dwLevel)
{
    CHAR szOleSpyInfo[] = "OleSpy";
    CHAR szServerName[SERVERNAMEMAX] = ".";
    CHAR *pszServerName = szServerName;
    CHAR    szValue[20];
    DWORD   cbValue = sizeof(szValue);
    ULONG   ulValue = 0x0003;

    if (dwLevel == OLESPY_TRACE)
    {
        InitializeTraceInfo();
        return NOERROR;
    }

    if (GetProfileStringA(szOleSpyInfo,"Output","",szServerName,SERVERNAMEMAX) )
    {
        // check if debugger was specified
        if (_stricmp(szServerName, "debugger") == 0)
        {
            // output should go to the debugger
            OleSpyOutput = OleSpyOut_Debugger;
            AddOutputFunction((StringOutFunc) OutputDebugStringA);

        }
        else
        {
            pszServerName = szServerName;
            // "." means OleSpy on local machine
            // strip of the leading backslash
            while(*pszServerName == '\\')
            {
                pszServerName++;
            }
            if (strlen(pszServerName))
            {
                OleSpyOutput = OleSpyOut_OleSpy;
                AddOutputFunction((StringOutFunc) SendEntry);

            }
        }
    }

    if (OleSpyOutput == OleSpyOut_None)
    {
        // nothing to do
        return NOERROR;
    }

    //
    if (GetProfileStringA(szOleSpyInfo, "TraceRpc", "0x0000", szValue,cbValue))
    {
        ulValue = strtoul (szValue, NULL, 16);
        if (ulValue)
        {
            OleSpyOpt |= OleSpy_Rpc;
        }
    }
    if (GetProfileStringA(szOleSpyInfo, "TraceAPI", "0x0000", szValue,cbValue))
    {
        ulValue = strtoul (szValue, NULL, 16);
        if (ulValue)
        {
            OleSpyOpt |= OleSpy_API;
            SetTraceInfoLevel(ulValue);
        }

    }
    if (GetProfileStringA(szOleSpyInfo, "TraceMethod", "0x0000", szValue,cbValue))
    {
        ulValue = strtoul (szValue, NULL, 16);
        if (ulValue)
        {
            OleSpyOpt |= OleSpy_Method;
        }
    }
    if (GetProfileStringA(szOleSpyInfo, "TraceOlethk", "0x0000", szValue,cbValue))
    {
        ulValue = strtoul (szValue, NULL, 16);
        if (ulValue)
        {
            OleSpyOpt |= OleSpy_OleThk;
        }
    }

    if (GetProfileStringA(szOleSpyInfo, "BreakForUnknownCalls", "0x0000", szValue,cbValue))
    {
        ulValue = strtoul (szValue, NULL, 16);
        if (ulValue)
        {
            OleSpyBreakForUnknownCalls = 1;
        }
    }

    if (OleSpyOutput == OleSpyOut_OleSpy)
    {
        // initialize client if output goes to OleSpy
        InitClient(pszServerName);
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   OutputToOleSpy
//
//  Synopsis:
//
//  Arguments:  [iOption] --
//              [pscFormat] --
//
//  Returns:
//
//  History:    11-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void OutputToOleSpy(int iOption, const char *pscFormat, ...)
{
    va_list args;
    va_start(args, pscFormat);
    wvsprintfA(szOutBuffer, pscFormat, args);
    va_end(args);

    switch (OleSpyOutput)
    {
    default:
    case OleSpyOut_None:
    break;
    case OleSpyOut_Debugger:
        OutputDebugStringA(szSendBuf);

    break;
    case OleSpyOut_OleSpy:
        SendEntry(szOutBuffer);
    break;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     RpcSpyOutput
//
//  Synopsis:
//
//  Arguments:  [mode] -- in or out call
//              [iid] --  interface id
//              [dwMethod] -- called method
//              [hres] -- hresult of finished call
//
//  Returns:
//
//  History:    3-31-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void RpcSpyOutput(RPCSPYMODE mode , LPVOID pv, REFIID iid, DWORD dwMethod, HRESULT hres)
{
    WCHAR wszName[100];

    if(OleSpyOutput == OleSpyOut_None)
    {
        // nothing to do
        return;
    }

    // turn of the 800xx in dwMethod
    WORD wMethod = (WORD) (dwMethod & 0x000000FF);
    char * szInterfaceName = "Unknown";
    char * szMethodName = "Unknown";
    IIDMethodNames *pIidMethName = 0;

    if (pIidMethName = GetIIDMethodName(iid) )
    {
        szInterfaceName = pIidMethName->pszInterface;
        if (wMethod > 32)
        {
            szMethodName = "InvalidMethod";
        }
        else
        {
            szMethodName = pIidMethName->ppszMethodNames[wMethod];
        }
    }
    else
    {
        if (OleSpyBreakForUnknownCalls)
        {
            DebugBreak();
        }
    }

    switch (mode)
    {
    default:
        return;

    case CALLIN_BEGIN:
        wsprintfA(szSendBuf,"%4ld,%s<<< %s (%lx), %s \n",nInCount, GetTabs(), szInterfaceName, pv, szMethodName );
        PushLevel();
        nInCount++;
    break;
    case CALLIN_END:
        PopLevel();
        wsprintfA(szSendBuf,"%4ld,%s=== %s (%lx), %s (%lx) \n", nInCount-1, GetTabs(), szInterfaceName, pv, szMethodName, hres);
    break;
    case CALLIN_TRACE:
        wsprintfA(szSendBuf,"     %s\n",(LPSTR) pv);
    break;
    case CALLIN_QI:
        {
            PopLevel();
            wsprintfA(szSendBuf,"     %s!!! QI for: %s, %s (%lx) \n",GetTabs(), szInterfaceName, dwMethod ? "S_OK" : "E_NOINTERFACE", hres);
            PushLevel();
        }
    break;
    case CALLIN_ERROR:
    break;
    case CALLOUT_BEGIN:
        wsprintfA(szSendBuf,"%4ld,%s>>> %s (%lx), %s \n",nOutCount, GetTabs(), szInterfaceName, pv, szMethodName );
        nOutCount++;
        PushLevel();
    break;
    case CALLOUT_TRACE:
    break;
    case CALLOUT_ERROR:
        wsprintfA(szSendBuf,"%s!!! %s, %s, error:%lx \n",GetTabs(), szInterfaceName, szMethodName, hres);
    break;
    case CALLOUT_END:
        PopLevel();
        wsprintfA(szSendBuf,"%4ld,%s=== %s (%lx), %s (%lx) \n",nOutCount-1,GetTabs(), szInterfaceName, pv, szMethodName, hres);
    break;
    }

    switch (OleSpyOutput)
    {
    default:
    case OleSpyOut_None:
    break;
    case OleSpyOut_Debugger:
        OutputDebugStringA(szSendBuf);
    break;
    case OleSpyOut_OleSpy:
        SendEntry(szSendBuf);
    break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSpySendEntry
//
//  Synopsis:
//
//  Arguments:  [szOutBuf] --
//
//  Returns:
//
//  History:    09-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int OleSpySendEntry(char * szOutBuf)
{
    switch (OleSpyOutput)
    {
    default:
    case OleSpyOut_None:
    break;
    case OleSpyOut_Debugger:
        OutputDebugStringA(szOutBuf);
    break;
    case OleSpyOut_OleSpy:
        SendEntry(szOutBuf);
    break;
    }

    return 1;
}

#include "ifnames.cxx"

//+---------------------------------------------------------------------------
//
//  Function:   GetIIDMethodName
//
//  Synopsis:
//
//  Arguments:  [riid] --
//
//  Returns:
//
//  History:    06-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
IIDMethodNames *GetIIDMethodName(REFIID riid)
{
    int idx;
    int cElements = sizeof(IidMethodNames) / sizeof(IidMethodNames[0]);

    for (idx = 0; idx < cElements; idx++)
    {
        if (IsEqualIID(riid, *IidMethodNames[idx].piid))
        {
            return &(IidMethodNames[idx]);
        }
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetInterfaceName
//
//  Synopsis:
//
//  Arguments:  [iid] --
//
//  Returns:
//
//  History:    06-18-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR GetInterfaceName(REFIID iid)
{
    IIDMethodNames *pIidMethName = 0;
    LPSTR szInterfaceName = NULL;

    if (pIidMethName = GetIIDMethodName(iid) )
    {
        szInterfaceName = pIidMethName->pszInterface;
    }
    if (szInterfaceName == NULL)
    {
        // look up the interface name in the registry
    }

    return szInterfaceName;
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\util\ifnames.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       IfNames.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    05-10-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

char *apszIUnknownNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
};
char *apszIClassFactoryNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateInstance"
,    "LockServer"
};
char *apszIMarshalNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetUnmarshalClass"
,    "GetMarshalSizeMax"
,    "MarshalInterface"
,    "UnmarshalInterface"
,    "ReleaseMarshalData"
,    "DisconnectObject"
};
char *apszIStdMarshalInfoNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassForHandler"
};
char *apszIMessageFilterNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "HandleInComingCall"
,    "RetryRejectedCall"
,    "MessagePending"
};
char *apszIExternalConnectionNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "AddConnection"
,    "ReleaseConnection"
};
char *apszIEnumStringNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumUnknownNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumSTATSTGNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszILockBytesNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ReadAt"
,    "WriteAt"
,    "Flush"
,    "SetSize"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
};
char *apszIStreamNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Read"
,    "Write"
,    "Seek"
,    "SetSize"
,    "CopyTo"
,    "Commit"
,    "Revert"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
,    "Clone"
};
char *apszIStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateStream"
,    "OpenStream"
,    "CreateStorage"
,    "OpenStorage"
,    "CopyTo"
,    "MoveElementTo"
,    "Commit"
,    "Revert"
,    "EnumElements"
,    "DestroyElement"
,    "RenameElement"
,    "SetElementTimes"
,    "SetClass"
,    "SetStateBits"
,    "Stat"
};
char *apszIRootStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SwitchToFile"
};
char *apszIEnumFORMATETCNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumSTATDATANames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIDataObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetData"
,    "GetDataHere"
,    "QueryGetData"
,    "GetCanonicalFormatEtc"
,    "SetData"
,    "EnumFormatEtc"
,    "DAdvise"
,    "DUnadvise"
,    "EnumDAdvise"
};
char *apszIViewObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
};
char *apszIViewObject2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
,    "GetExtent"
};
char *apszIAdviseSinkNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
};
char *apszIAdviseSink2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
,    "OnLinkSrcChange"
};
char *apszIDataAdviseHolderNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnDataChange"
};
char *apszIOleCacheNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
};
char *apszIOleCache2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
,    "UpdateCache"
,    "DiscardCache"
};
char *apszIOleCacheControlNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnRun"
,    "OnStop"
};
char *apszIDropTargetNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "DragEnter"
,    "DragOver"
,    "DragLeave"
,    "Drop"
};
char *apszIDropSourceNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "QueryContinueDrag"
,    "GiveFeedback"
};
char *apszIPersistNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
};
char *apszIPersistStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "InitNew"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "HandsOffStorage"
};
char *apszIPersistStreamNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
};
char *apszIPersistFileNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "GetCurFile"
};
char *apszIBindCtxNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "RegisterObjectBound"
,    "RevokeObjectBound"
,    "ReleaseBoundObjects"
,    "SetBindOptions"
,    "GetBindOptions"
,    "GetRunningObjectTable"
,    "RegisterObjectParam"
,    "GetObjectParam"
,    "EnumObjectParam"
,    "RevokeObjectParam"
};
char *apszIMonikerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
,    "BindToObject"
,    "BindToStorage"
,    "Reduce"
,    "ComposeWith"
,    "Enum"
,    "IsEqual"
,    "Hash"
,    "IsRunning"
,    "GetTimeOfLastChange"
,    "Inverse"
,    "CommonPrefixWith"
,    "RelativePathTo"
,    "GetDisplayName"
,    "ParseDisplayName"
,    "IsSystemMoniker"
};
char *apszIRunningObjectTableNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Register"
,    "Revoke"
,    "IsRunning"
,    "GetObject"
,    "NoteChangeTime"
,    "GetTimeOfLastChange"
,    "EnumRunning"
};
char *apszIEnumMonikerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumOLEVERBNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIOleObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SetClientSite"
,    "GetClientSite"
,    "SetHostNames"
,    "Close"
,    "SetMoniker"
,    "GetMoniker"
,    "InitFromData"
,    "GetClipboardData"
,    "DoVerb"
,    "EnumVerbs"
,    "Update"
,    "IsUpToDate"
,    "GetUserClassID"
,    "GetUserType"
,    "SetExtent"
,    "GetExtent"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "GetMiscStatus"
,    "SetColorScheme"
};
char *apszIOleClientSiteNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SaveObject"
,    "GetMoniker"
,    "GetContainer"
,    "ShowObject"
,    "OnShowWindow"
,    "RequestNewObjectLayout"
};
char *apszIRunnableObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetRunningClass"
,    "Run"
,    "IsRunning"
,    "LockRunning"
,    "SetContainedObject"
};
char *apszIParseDisplayNameNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
};
char *apszIOleContainerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
};
char *apszIOleItemContainerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
,    "GetObject"
,    "GetObjectStorage"
,    "IsRunning"
};
char *apszIOleAdviseHolderNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnRename"
,    "SendOnSave"
,    "SendOnClose"
};
char *apszIOleLinkNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SetUpdateOptions"
,    "GetUpdateOptions"
,    "SetSourceMoniker"
,    "GetSourceMoniker"
,    "SetSourceDisplayName"
,    "GetSourceDisplayName"
,    "BindToSource"
,    "BindIfRunning"
,    "GetBoundSource"
,    "UnbindSource"
,    "Update"
};
char *apszIOleWindowNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
};
char *apszIOleInPlaceObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "InPlaceDeactivate"
,    "UIDeactivate"
,    "SetObjectRects"
,    "ReactivateAndUndo"
};
char *apszIOleInPlaceActiveObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "TranslateAccelerator"
,    "OnFrameWindowActivate"
,    "OnDocWindowActivate"
,    "ResizeBorder"
,    "EnableModeless"
};
char *apszIOleInPlaceUIWindowNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
};
char *apszIOleInPlaceFrameNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
,    "InsertMenus"
,    "SetMenu"
,    "RemoveMenus"
,    "SetStatusText"
,    "EnableModeless"
,    "TranslateAccelerator"
};
char *apszIOleInPlaceSiteNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "CanInPlaceActivate"
,    "OnInPlaceActivate"
,    "OnUIActivate"
,    "GetWindowContext"
,    "Scroll"
,    "OnUIDeactivate"
,    "OnInPlaceDeactivate"
,    "DiscardUndoState"
,    "DeactivateAndUndo"
,    "OnPosRectChange"
};
char *apszIRpcChannelBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetBuffer"
,    "SendReceive"
,    "FreeBuffer"
,    "GetDestCtx"
,    "IsConnected"
};
char *apszIRpcProxyBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
};
char *apszIRpcStubBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
,    "DebugServerQueryInterface"
,    "DebugServerRelease"
};
char *apszIPSFactoryBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateProxy"
,    "CreateStub"
};
char *apszIRpcChannelNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetStream"
,    "Call"
,    "GetDestCtx"
,    "IsConnected"
};
char *apszIRpcProxyNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
};
char *apszIRpcStubNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
};
char *apszIPSFactoryNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateProxy"
,    "CreateStub"
};

char *apszIServerHandlerNames[] =
{
     "QueryInterface"
,    "AddRef"
,    "Release"
,    "RunAndInitialize"
,    "RunAndDoVerb"
,    "DoVerb"
};

char *apszIClientSiteHandlerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "PrivQueryInterface"
,    "PrivAddRef"
,    "PrivRelease"
,    "SaveObject"
,    "GetMoniker"
,    "GetContainer"
,    "ShowObject"
,    "OnShowWindow"
,    "RequestNewObjectLayout"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "CanInPlaceActivate"
,    "OnInPlaceActivate"
,    "OnUIActivate"
,    "GetWindowContext"
,    "Scroll"
,    "OnUIDeactivate"
,    "OnInPlaceDeactivate"
,    "DiscardUndoState"
,    "DeactivateAndUndo"
,    "OnPosRectChange"
,    "StartInPlaceActivation"
,    "DoInPlace"
,    "UndoInPlace"
};



char *apszIRpcServiceNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CheckContextHdl"
,    "GetChannelId"
,    "ReleaseChannel"
,    "DoChannelOperation"
,    "DoChnlOp_ADD_MARSHALCONNECTION"
,    "DoChnlOp_REMOVE_MARSHALCONNECTION"
,    "DoChnlOp_TRANSFER_MARSHALCONNECTION"
,    "DoChnlOp_LOCK_CONNECTION"
,    "DoChnlOp_UNLOCK_CONNECTION"
,    "DoChnlOp_DOESSUPPORTIID"
,    "DoChnlOp_OPERATION"
};

char *apszIRpcSCMNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassObject"
,    "CreateObject"
,    "ActivateObject"
};

char *apszIRpcCoAPINames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CoGetActiveClassObject"
,    "CoActivateObject"
,    "CoCreateObject"
};

char *apszInterfaceFromWindowProp[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetInterfaceFromWindowProp"
,    "PrivDragDrop"
};

char *apszISCMActivator[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SCMActivatorGetClassObject"
,    "SCMActivatorCreateInstance"
};
char *apszILocalSystemActivator[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassObject"
,    "CreateInstance"
,    "ObjectServerLoadDll"
,    "NotifyServerRetired"
};
char *apszIRemUnknown[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "RemQueryInterface"
,    "RemAddRef"
,    "RemRelease"
};
char *apszIRundown[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "RemQueryInterface"
,    "RemAddRef"
,    "RemRundownOid"
};




IIDMethodNames IidMethodNames[] =
{
     { &IID_IUnknown,               "IUnknown", apszIUnknownNames                                   }
    ,{ &IID_IClassFactory,          "IClassFactory", apszIClassFactoryNames                     }
    ,{ &IID_IMarshal,               "IMarshal", apszIMarshalNames                               }
    ,{ &IID_IStdMarshalInfo,        "IStdMarshalInfo", apszIStdMarshalInfoNames                 }
    ,{ &IID_IMessageFilter,         "IMessageFilter", apszIMessageFilterNames                   }
    ,{ &IID_IExternalConnection,    "IExternalConnection", apszIExternalConnectionNames         }
    ,{ &IID_IEnumString,            "IEnumString", apszIEnumStringNames                         }
    ,{ &IID_IEnumUnknown,           "IEnumUnknown", apszIEnumUnknownNames                       }
    ,{ &IID_IEnumSTATSTG,           "IEnumSTATSTG", apszIEnumSTATSTGNames                       }
    ,{ &IID_ILockBytes,             "ILockBytes", apszILockBytesNames                           }
    ,{ &IID_IStream,                "IStream", apszIStreamNames                                 }
    ,{ &IID_IStorage,               "IStorage", apszIStorageNames                               }
    ,{ &IID_IRootStorage,           "IRootStorage", apszIRootStorageNames                       }
    ,{ &IID_IEnumFORMATETC,         "IEnumFORMATETC", apszIEnumFORMATETCNames                   }
    ,{ &IID_IEnumSTATDATA,          "IEnumSTATDATA", apszIEnumSTATDATANames                     }
    ,{ &IID_IDataObject,            "IDataObject", apszIDataObjectNames                         }
    ,{ &IID_IViewObject,            "IViewObject", apszIViewObjectNames                         }
    ,{ &IID_IViewObject2,           "IViewObject2", apszIViewObject2Names                       }
    ,{ &IID_IAdviseSink,            "IAdviseSink", apszIAdviseSinkNames                         }
    ,{ &IID_IAdviseSink2,           "IAdviseSink2", apszIAdviseSink2Names                       }
    ,{ &IID_IDataAdviseHolder,      "IDataAdviseHolder", apszIDataAdviseHolderNames             }
    ,{ &IID_IOleCache,              "IOleCache", apszIOleCacheNames                             }
    ,{ &IID_IOleCache2,             "IOleCache2", apszIOleCache2Names                           }
    ,{ &IID_IOleCacheControl,       "IOleCacheControl", apszIOleCacheControlNames               }
    ,{ &IID_IDropTarget,            "IDropTarget", apszIDropTargetNames                         }
    ,{ &IID_IDropSource,            "IDropSource", apszIDropSourceNames                         }
    ,{ &IID_IPersist,               "IPersist", apszIPersistNames                               }
    ,{ &IID_IPersistStorage,        "IPersistStorage", apszIPersistStorageNames                 }
    ,{ &IID_IPersistStream,         "IPersistStream", apszIPersistStreamNames                   }
    ,{ &IID_IPersistFile,           "IPersistFile", apszIPersistFileNames                       }
    ,{ &IID_IBindCtx,               "IBindCtx", apszIBindCtxNames                               }
    ,{ &IID_IMoniker,               "IMoniker", apszIMonikerNames                               }
    ,{ &IID_IRunningObjectTable,    "IRunningObjectTable", apszIRunningObjectTableNames         }
    ,{ &IID_IEnumMoniker,           "IEnumMoniker", apszIEnumMonikerNames                       }
    ,{ &IID_IEnumOLEVERB,           "IEnumOLEVERB", apszIEnumOLEVERBNames                       }
    ,{ &IID_IOleObject,             "IOleObject", apszIOleObjectNames                           }
    ,{ &IID_IOleClientSite,         "IOleClientSite", apszIOleClientSiteNames                   }
    ,{ &IID_IRunnableObject,        "IRunnableObject", apszIRunnableObjectNames                 }
    ,{ &IID_IParseDisplayName,      "IParseDisplayName", apszIParseDisplayNameNames             }
    ,{ &IID_IOleContainer,          "IOleContainer", apszIOleContainerNames                     }
    ,{ &IID_IOleItemContainer,      "IOleItemContainer", apszIOleItemContainerNames             }
    ,{ &IID_IOleAdviseHolder,       "IOleAdviseHolder", apszIOleAdviseHolderNames               }
    ,{ &IID_IOleLink,               "IOleLink", apszIOleLinkNames                               }
    ,{ &IID_IOleWindow,             "IOleWindow", apszIOleWindowNames                           }
    ,{ &IID_IOleInPlaceObject,      "IOleInPlaceObject", apszIOleInPlaceObjectNames             }
    ,{ &IID_IOleInPlaceActiveObject,"IOleInPlaceActiveObject", apszIOleInPlaceActiveObjectNames }
    ,{ &IID_IOleInPlaceUIWindow,    "IOleInPlaceUIWindow", apszIOleInPlaceUIWindowNames         }
    ,{ &IID_IOleInPlaceFrame,       "IOleInPlaceFrame", apszIOleInPlaceFrameNames               }
    ,{ &IID_IOleInPlaceSite,        "IOleInPlaceSite", apszIOleInPlaceSiteNames                 }
    ,{ &IID_IRpcChannelBuffer,      "IRpcChannelBuffer", apszIRpcChannelBufferNames             }
    ,{ &IID_IRpcProxyBuffer,        "IRpcProxyBuffer", apszIRpcProxyBufferNames                 }
    ,{ &IID_IRpcStubBuffer,         "IRpcStubBuffer", apszIRpcStubBufferNames                   }
    ,{ &IID_IPSFactoryBuffer,       "IPSFactoryBuffer", apszIPSFactoryBufferNames               }
    ,{ &IID_IRpcChannel,            "IRpcChannel", apszIRpcChannelNames                         }
    ,{ &IID_IRpcProxy,              "IRpcProxy", apszIRpcProxyNames                             }
    ,{ &IID_IRpcStub,               "IRpcStub", apszIRpcStubNames                               }
    ,{ &IID_IPSFactory,             "IPSFactory", apszIPSFactoryNames                           }
#ifdef SERVER_HANDLER
    ,{ &IID_IServerHandler,         "IServerHandler", apszIServerHandlerNames                   }
    ,{ &IID_IClientSiteHandler,     "IClientSiteHandler", apszIClientSiteHandlerNames           }
#endif // SERVER_HANDLER
    ,{ &IID_IRpcService,            "IRpcService", apszIRpcServiceNames                         }
    ,{ &IID_IRpcSCM,                "IRpcSCM", apszIRpcSCMNames                                 }
    ,{ &IID_IRpcCoAPI,              "IRpcCoAPI", apszIRpcCoAPINames                             }
#ifdef DCOM
    ,{ &IID_IInterfaceFromWindowProp,"InterfaceFromWindowProp", apszInterfaceFromWindowProp     }
    ,{ &IID_ISystemActivator,                  "ISystemActivator", apszISCMActivator                                          }
    ,{ &IID_ILocalSystemActivator,             "ILocalSystemActivator", apszILocalSystemActivator                                }
    ,{ &IID_IRemUnknown,            "IRemUnknown", apszIRemUnknown                              }
    ,{ &IID_IRundown,               "IRundown", apszIRundown                                    }
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\util\time.cxx ===
//+------------------------------------------------------------
//
// File:        time.cxx
//
// Contents:    Component object model time utilities
//
// Functions:   CoFileTimeToDosDateTime
//              CoDosDateTimeToFileTime
//              CoFileTimeNow
//
// History:     5-Apr-94       brucema         Created
//
//-------------------------------------------------------------
#include <ole2int.h>

STDAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
{
    OLETRACEIN((API_CoFileTimeToDosDateTime, PARAMFMT("lpFileTime= %tf, lpFatDate= %p, lpFatTime= %p"),
                                lpFileTime, lpFatDate, lpFatTime));
    BOOL fRet= FALSE;

    if ((lpFileTime != NULL) &&
        IsValidPtrIn(lpFileTime, sizeof(*lpFileTime)) &&
        IsValidPtrOut(lpFatDate, sizeof(*lpFatDate)) &&
        IsValidPtrOut(lpFatTime, sizeof(*lpFatTime)))
    {
        fRet = FileTimeToDosDateTime(lpFileTime, lpFatDate, lpFatTime);
    }

    OLETRACEOUTEX((API_CoFileTimeToDosDateTime, RETURNFMT("%B"), fRet));
    return fRet;
}

STDAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime)
{
    OLETRACEIN((API_CoDosDateTimeToFileTime, PARAMFMT("nDosDate=%x, nDosTime=%x, lpFileTime=%p"),
                                nDosDate, nDosTime, lpFileTime));

    BOOL fRet= FALSE;

    if (IsValidPtrOut(lpFileTime, sizeof(*lpFileTime)))
    {
        fRet = DosDateTimeToFileTime(nDosDate, nDosTime, lpFileTime);
    }

    OLETRACEOUTEX((API_CoDosDateTimeToFileTime, RETURNFMT("%B"), fRet));
    return fRet;
}


#pragma SEG(CoFileTimeNow)

//
// Get the current UTC time, in the FILETIME format.
//

STDAPI  CoFileTimeNow(FILETIME *pfiletime )
{

    // Validate the input

    if (!IsValidPtrOut(pfiletime, sizeof(*pfiletime)))
    {
        return(E_INVALIDARG);
    }

    // Get the time in SYSTEMTIME format.

    SYSTEMTIME stNow;
    GetSystemTime(&stNow);

    // Convert it to FILETIME format.

    if( !SystemTimeToFileTime(&stNow, pfiletime) )
    {
        pfiletime->dwLowDateTime = 0;
        pfiletime->dwHighDateTime = 0;
        return( HRESULT_FROM_WIN32( GetLastError() ));
    }
    else
        return( NOERROR );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\util\task.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	Task.cxx
//
//  Contents:	Helper function to determine the current task
//
//  Functions:	IsTaskName
//
//  History:	28-Mar-95 scottsk	Created
//              12-Feb-97 ronans	Added utGetModuleName, utGetAppIdForModule
//              12-Feb-97 ronans	Added utGetTowerId, utGetProtseqFromTowerId
//
//  CODEWORK:   - list of protocols and towerids should come from 
//              the Resolver, along with a list of protocols that 
//              the Admin is willing to use for DCOM.
//
//              - change 
//
//--------------------------------------------------------------------------

#include <ole2int.h>

WCHAR gawszImagePath[MAX_PATH];
DWORD gcImagePath = 0;

// Helper function for IsTaskName
inline BOOL IsPathSeparator( WCHAR ch )
{
    return (ch == L'\\' || ch == L'/' || ch == L':');
}

//+-------------------------------------------------------------------------
//
//  Function:  	IsTaskName
//
//  Synopsis: 	Determines if the passed name is the current task
//
//  Effects:
//
//  Arguments: 	[lpszIn]        -- Task name
//
//  Returns:	TRUE, FALSE
//
//  History:    dd-mmm-yy Author    Comment
//              03-Mar-95 Scottsk    Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
FARINTERNAL_(BOOL) IsTaskName(LPCWSTR lpszIn)
{
    BOOL retval = FALSE;

    if (IsWOWThread()) 
    {    

        //we cannot use the single global var for WOW as each thread is 
        //a different 16-bit task!
        //Since, in the case of WOW, this is thread specific info -- 
        //the loader lock is not taken. So no deadlocks(ref: NT 197603).

        WCHAR awszImagePath[MAX_PATH];
        if (GetModuleFileName(NULL, awszImagePath, MAX_PATH))
        {
        	awszImagePath[MAX_PATH-1] = 0;		// null terminate it just in case
        	
            WCHAR * pch;

            // Get last component of path

            //
            // Find the end of the string and determine the string length.
            //
            for (pch=awszImagePath; *pch; pch++);

            DecLpch (awszImagePath, pch);   // pch now points to the last real charater

            while (!IsPathSeparator(*pch))
                DecLpch (awszImagePath, pch);

            // we're at the last separator.  does the name match?
            if (!lstrcmpiW(pch+1, lpszIn))
                retval = TRUE;
        }

    }
    else if (gcImagePath)
    {
        WCHAR * pch;

        // Get last component of path

        //
        // Find the end of the string and determine the string length.
        //
        for (pch=gawszImagePath; *pch; pch++);

        DecLpch (gawszImagePath, pch);   // pch now points to the last real character

        while (!IsPathSeparator(*pch))
           DecLpch (gawszImagePath, pch);

        // we're at the last separator.  does the name match?
        if (!lstrcmpiW(pch+1, lpszIn))
	        retval = TRUE;
    }

    return retval;
}


//+-------------------------------------------------------------------------
//
//  Function:  	utGetModuleName
//
//  Synopsis: 	Get Module Name for current module
//
//  Effects:
//
//  Arguments: 	[lpszModuleName]	-- Buffer to hold module name
//				[dwLength]			-- length in characters
//
//  Returns:	S_OK, E_UNEXPECTED, E_OUTOFMEMORY
//
//  History:    dd-mmm-yy Author    Comment
//	            06-Feb-97 Ronans	Created
//
//
//--------------------------------------------------------------------------
FARINTERNAL utGetModuleName(LPWSTR lpszModuleName, DWORD dwLength)
{
    WCHAR* pModule = gawszImagePath;
    DWORD cModule = gcImagePath;
    int i = cModule;
    HRESULT hr;

    // check arguments
    if ((!lpszModuleName) ||  
        (!dwLength) || 
        !IsValidPtrOut(lpszModuleName, dwLength * sizeof(WCHAR)))
    {
        ComDebOut((DEB_ERROR, "utGetModuleName - invalid arguments\n"));
        return E_INVALIDARG;
    }

    // skip back to start of filename
    while(i && !IsPathSeparator(pModule[i-1]))
        i--;

    // i is now index of start of module name
    DWORD nNameLen = (DWORD)((cModule - i) + 1);

    if (nNameLen <= dwLength)
        lstrcpyW(lpszModuleName, &pModule[i]);
    else
    {
        ComDebOut((DEB_ERROR, "utGetModuleName - supplied buffer is too small\n"));
        return HRESULT_FROM_WIN32(ERROR_MORE_DATA); // supplied buffer is too small
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:  	utGetAppIdForModule
//
//  Synopsis: 	Get AppID for the current module in string form
//
//  Effects:
//
//  Arguments: 	[lpszAppId]	-- Buffer to hold string represntation of AppId
//				[dwLength]	-- length of buffer in bytes
//
//  Returns:	S_OK, E_FAIL, E_UNEXPECTED, E_OUTOFMEMORY or error value from 
//              registry functions.
//
//  Notes:      E_FAIL indicates that AppId key was not found or other
//              "regular" error as opposed to out of memory or something
//
//  History:    dd-mmm-yy Author    Comment
//	            06-Feb-97 Ronans	Created
//
//--------------------------------------------------------------------------
FARINTERNAL utGetAppIdForModule(LPWSTR lpszAppId, DWORD dwLength)
{
    HRESULT hr;
    LONG lErr;
    WCHAR aModule[MAX_PATH];
    WCHAR aKeyName[MAX_PATH];
    DWORD dwModuleLen = MAX_PATH;
    HKEY hKey;
    int i;

    // check arguments
    if ((!lpszAppId) || (!dwLength) || (dwLength < 39 ))
    {
        ComDebOut((DEB_ERROR, 
            "utGetAppIdForModule - invalid arguments\n"));
        return E_INVALIDARG;
    }

    hr = utGetModuleName(aModule, dwModuleLen);


    if (SUCCEEDED(hr))
    {
        dwModuleLen = lstrlenW(aModule);

        if ((dwModuleLen + 7) > MAX_PATH)
        {
            ComDebOut((DEB_ERROR, 
                "utGetAppIdForModule - module name too large for buffer\n"));
            return E_OUTOFMEMORY;
        }

        // Open the key for the EXE's module name.
        lstrcpyW( aKeyName, L"AppID\\");
        lstrcpyW( &aKeyName[6], aModule);

        lErr = OpenClassesRootKeyEx(aKeyName, KEY_READ, &hKey );

        // Look for an application id.
        if (lErr == ERROR_SUCCESS)
        {
            DWORD dwType;
            lErr = RegQueryValueEx( hKey, L"AppId", NULL, &dwType,
                                  (unsigned char *) lpszAppId, &dwLength );
            RegCloseKey( hKey );

            if ((lErr == ERROR_SUCCESS) && dwType == REG_SZ)
            {
				lpszAppId[dwLength-1] = 0;	// null terminate just in case
                ComDebOut((DEB_WARN, 
                    "utGetAppIdForModule - got appid [%ws]\n", lpszAppId));
                return S_OK;
            }
            else
            {
                ComDebOut((DEB_ERROR, 
                    "utGetAppIdForModule - couldn't open AppId subkey for key [%ws]\n", aKeyName));
                hr = E_FAIL;
            }
        }
        else
        {
            ComDebOut((DEB_WARN, 
                "utGetAppIdForModule - couldn't open appid key[%ws]\n", aKeyName));
            hr = E_FAIL;
        }
    }

    return hr;
}

// tower id to string mapping table - index is TowerId

// CODEWORK: this should come from the Resolver, along with a list of
// protocols that the Admin is willing to use for DCOM.


PWSTR   utProtseqInfo[] =
    {
    /* 0x00 */ { 0 },
    /* 0x01 */ { 0 },
    /* 0x02 */ { 0 },
    /* 0x03 */ { 0 },
    /* 0x04 */ { L"ncacn_dnet_dsp" },
    /* 0x05 */ { 0 },
    /* 0x06 */ { 0 },
    /* 0x07 */ { L"ncacn_ip_tcp" },
    /* 0x08 */ { L"ncadg_ip_udp" },
    /* 0x09 */ { L"ncacn_nb_tcp" },
    /* 0x0a */ { 0 },
    /* 0x0b */ { 0 },
    /* 0x0c */ { L"ncacn_spx" },
    /* 0x0d */ { L"ncacn_nb_ipx" },
    /* 0x0e */ { L"ncadg_ipx" },
    /* 0x0f */ { L"ncacn_np" },
    /* 0x10 */ { L"ncalrpc" },
    /* 0x11 */ { 0 },
    /* 0x12 */ { 0 },
    /* 0x13 */ { L"ncacn_nb_nb" },
    /* 0x14 */ { 0 },
    /* 0x15 */ { 0 }, // was ncacn_nb_xns - unsupported.
    /* 0x16 */ { L"ncacn_at_dsp" },
    /* 0x17 */ { L"ncadg_at_ddp" },
    /* 0x18 */ { 0 },
    /* 0x19 */ { 0 },
    /* 0x1A */ { L"ncacn_vns_spp"},
    /* 0x1B */ { 0 },
    /* 0x1C */ { 0 },
    /* 0x1D */ { L"ncadg_mq"}, /* NCADG_MQ */
    /* 0x1E */ { 0 },          
    /* 0x1F */ { L"ncacn_http"} /* ronans - DCOMHTTP */
};

const ULONG utcProtSeqs = sizeof(utProtseqInfo) / sizeof(PWSTR);

//+-------------------------------------------------------------------------
//
//  Function:  	utGetProtseqFromTowerId
//
//  Synopsis: 	Get protseq string from DCE TowerID 
//
//  Effects:
//
//  Arguments: 	[wTowerId]	-- TowerID to retrieve
//
//  Returns:	protseq string - NULL if not found
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-96   t-KevinH	Created as findProtseq
//	            06-Feb-97   Ronans	    Converted to utility fn and 
//                                      changed array format
//
//--------------------------------------------------------------------------
FARINTERNAL_(LPCWSTR) utGetProtseqFromTowerId(USHORT wTowerId)
{
    Win4Assert(wTowerId < utcProtSeqs);
	
    // Do not look at memory outside of the table
    if (wTowerId < utcProtSeqs)
        return utProtseqInfo[wTowerId];
    else
        return NULL;
} 

//+-------------------------------------------------------------------------
//
//  Function:  	utGetTowerId
//
//  Synopsis: 	Get DCE TowerId for protseq string
//
//  Effects:
//
//  Arguments: 	[pwszProtseq]	-- string to look up
//
//  Returns:	protseq string - NULL if not found
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-96   t-KevinH	Created as findProtseq
//	            06-Feb-97   Ronans	    Converted to utility fn
//
//--------------------------------------------------------------------------
FARINTERNAL_(USHORT) utGetTowerId(LPCWSTR pwszProtseq)
{
    int idx;

    for (idx = 0; idx < sizeof(utProtseqInfo) / sizeof(*utProtseqInfo); ++idx)
    {
        if (lstrcmpW(utProtseqInfo[idx], pwszProtseq) == 0)
	        return (USHORT) idx;
    }

    ComDebOut((DEB_ERROR, "utGetTowerId - Can't get towerId for protseq[%ws]\n", pwszProtseq));
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\util\w32new.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       w32new.cxx
//
//  Contents:   memory management
//
//  Functions: operator new
//             operator delete
//--------------------------------------------------------------------------
#include <ole2int.h>
#include <memapi.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   operator new, public
//
//  Synopsis:   Global operator new which does not throw exceptions.
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:	A pointer to the allocated memory.  Is *NOT* initialized to 0!
//
//----------------------------------------------------------------------------
void* __cdecl
operator new (size_t size)
{
    return(PrivMemAlloc(size));
}

//+-------------------------------------------------------------------------
//
//  Function:	::operator delete
//
//  Synopsis:	Free a block of memory
//
//  Arguments:	[lpv] - block to free.
//
//--------------------------------------------------------------------------

void __cdecl operator delete(void FAR* lpv)
{
    PrivMemFree(lpv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\util\spyclnt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       spyclnt.cxx
//
//  Contents:   Funktionality for OleSpy client.
//
//  Classes:
//
//  Functions:
//
//  History:    8-16-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#pragma hdrstop
#if DBG==1
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "SpyClnt.hxx"

#define APPMAXLEN 512


static HANDLE       hPipe = INVALID_HANDLE_VALUE;             // File or Pipe handle.
static OVERLAPPED   OverLapWrt;        // Overlapped structure
static HANDLE       hEventWrt = INVALID_HANDLE_VALUE;         // Event handle for overlapped writes.


#undef wsprintf
#undef wsprintfA
#define wsprintf wsprintfA
#undef MessageBoxA
#undef MessageBox
#define MessageBox MessageBoxA

#undef CreateFileA
#undef CreateFile
#define CreateFile CreateFileA
#define GetModuleName GetModuleNameA

LPSTR GetAppName();


//+---------------------------------------------------------------------------
//
//  Function:   GetAppName
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-16-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR GetAppName()
{
    static CHAR szAppName[APPMAXLEN];
    LPSTR psz, psz1;
    GetModuleFileNameA(NULL, szAppName, APPMAXLEN);
    psz = strrchr(szAppName, '\\');
    psz++;
    psz1 = strchr(psz,'.');
    *psz1 = '\0';
    return psz;
}

//+---------------------------------------------------------------------------
//
//  Function:   SendEntry
//
//  Synopsis:
//
//  Arguments:  [szOutBuf] --
//
//  Returns:
//
//  History:    9-29-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int SendEntry(char * szOutBuf)
{
    DWORD  dwRet;
    char   szSendBuf[OUT_BUF_SIZE] = "";
    DWORD  cbWritten;

    wsprintf (szSendBuf, "%s: %s\n", GetAppName(), szOutBuf);
    dwRet = WriteFile (hPipe, szSendBuf, (DWORD) strlen(szSendBuf), &cbWritten, &OverLapWrt);

    if (!dwRet)
    {
        DWORD  dwLastError;
        dwLastError = GetLastError();

        // If Error = IO_PENDING, wait until the event signals success.
        if (dwLastError == ERROR_IO_PENDING)
        {
            WaitForSingleObject (hEventWrt, (DWORD)-1);
        }
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitClient
//
//  Synopsis:
//
//  Arguments:  [pszShrName] --
//
//  Returns:
//
//  History:    9-29-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int InitClient(char *pszShrName)
{
    CHAR   szSendBuf[OUT_BUF_SIZE] = "";
    CHAR   szFileName[LINE_LEN+NAME_SIZE+2];
    DWORD  dwRet;
    DWORD  dwLastError;
    DWORD  dwThreadID;
    DWORD  cbWritten;

    if (pszShrName == NULL)
    {
        return -1;
    }

    // Construct file/pipe name.
    _snprintf (szFileName, sizeof(szFileName)/sizeof(CHAR), "%s%s%s", "\\\\", pszShrName, "\\PIPE\\OleSpy");
    szFileName[(sizeof(szFileName)/sizeof(CHAR)) -1] = 0;

    // CreateFile() to connect to the named pipe. Generic access, read/write.
    hPipe = CreateFile(szFileName, GENERIC_WRITE | GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE ,
                        NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);


    // Do some error checking.
    if (hPipe == INVALID_HANDLE_VALUE)
    {
        dwRet = GetLastError();

         // This error means pipe wasn't found.
        if ((dwRet == ERROR_SEEK_ON_DEVICE) || (dwRet == ERROR_FILE_NOT_FOUND))
        {
            MessageBox(NULL,"CANNOT FIND PIPE: Assure OleSpy is started on server.",
                   "", MB_OK);
        }
        else
        {
            CHAR   szErrorBuf[LINE_LEN] = "";
            // Flagging unknown errors.
            wsprintf (szErrorBuf,"CreateFile() on pipe failed, see winerror.h error #%d.",dwRet);
            MessageBox (NULL, szErrorBuf, "", MB_ICONINFORMATION | MB_OK | MB_APPLMODAL);
        }
        return -1;
    }

    // Create and init overlapped structure for writes.
    hEventWrt = CreateEvent (NULL, TRUE, FALSE, NULL);
    OverLapWrt.hEvent = hEventWrt;

    {
        LPSTR szStr = GetAppName();

        // Write the client name to server.
        dwRet = WriteFile(hPipe, szStr, (DWORD) strlen(szStr), &cbWritten, &OverLapWrt);
    }

    if (!dwRet)
    {
        dwLastError = GetLastError();

        // Wait on overlapped if need be.
        if (dwLastError == ERROR_IO_PENDING)
        {
            WaitForSingleObject(hEventWrt, (DWORD)-1);
        }
     }

    // Create a thread to read the pipe.
    CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)ReadPipe,
                 (LPVOID)&hPipe, 0, &dwThreadID);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitClient
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-29-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void UninitClient()
{
	if (hPipe != INVALID_HANDLE_VALUE)
	    CloseHandle (hPipe);
	
	if (hEventWrt != INVALID_HANDLE_VALUE)
	    CloseHandle (hEventWrt);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadPipe
//
//  Synopsis:
//
//  Arguments:  [hPipe] --
//
//  Returns:
//
//  History:    9-29-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID ReadPipe (HANDLE *hPipe)
{
    CHAR       inBuf[IN_BUF_SIZE] = "";// Input buffer.
    DWORD      bytesRead;              // Used for ReadFile()
    DWORD      dwRet;                  // Used to trap return codes.
    DWORD      dwLastError;            // Used to trap returns from GetLastError.

    HANDLE     hEventRd;               // Event handle for overlapped reads.
    OVERLAPPED OverLapRd;              // Overlapped structure.
    DWORD      bytesTrans;             // Bytes transferred in read.

                                       // Create and init overlap structure.
    hEventRd = CreateEvent (NULL, TRUE, FALSE, NULL);
    memset (&OverLapRd, 0, sizeof(OVERLAPPED));
    OverLapRd.hEvent = hEventRd;

    // Loop, reading the named pipe until it is broken.  The ReadFile() uses
    // an overlapped structure.  When the event handle signals a completed
    // read, this loop writes the message to the larger edit field.

    do {
        dwRet = ReadFile (*hPipe, inBuf, IN_BUF_SIZE, &bytesRead, &OverLapRd);
        // Do some error checking.
        if (!dwRet)
        {
            dwLastError = GetLastError();

            if (dwLastError == ERROR_IO_PENDING)
            {
                // If Error = IO_PENDING, wait for event
                // handle to signal success.
                WaitForSingleObject (hEventRd, (DWORD)-1);
            }
            else
            {
                // If pipe is broken, tell user and break.
                if (dwLastError == (DWORD)ERROR_BROKEN_PIPE)
                {
                    MessageBox (NULL,
                        "The connection to this client has been broken.", "", MB_OK);
                }
                else
                {
                    // Or flag unknown errors, and break.
                    CHAR       szErrorBuf[80];
                    wsprintf (szErrorBuf,
                              "ReadFile() on pipe failed, see winerror.h error #%d",GetLastError());
                    MessageBox (NULL, szErrorBuf, "", MB_OK);
                }
                break;
            }
        }
        // NULL terminate string.
        GetOverlappedResult (*hPipe, &OverLapRd, &bytesTrans, FALSE);
        inBuf[bytesTrans] = '\0';

     } while(1);

    ExitThread(0);
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\verifier\tracking.cxx ===
//+---------------------------------------------------------------------------
//
//  File:       tracking.cxx
//
//  Contents:   Implementation of the tracking-type verifier tests, including 
//              object tracking and VTBL tracking.  These tests hook memory 
//              frees, so that we can break when somebody frees an object that 
//              we still have a reference to.
//
//  Functions:  CoVrfTrackObject           - start tracking an object 
//              CoVrfStopTrackingObject    - stop tracking an object.
//              CoVrfFreeMemObjectChecks   - break if the block being freed
//                                           contains an object.
//              CoVrfTrackVtbl             - start tracking a VTBL
//              CoVrfStopTrackingVtbl      - stop tracking a VTBL
//              CoVrfFreeMemVtblChecks     - break if the block being freed
//                                           contains a VTBL
//              CoVrfFreeMemoryChecks      - top-level memory verifier function
//
//  History:    27-Apr-02   JohnDoty    Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>


// This lock protects all tracking data structures.
COleStaticMutexSem gObjectTrackingLock;

//
// VTBL TRACKING
//
// Track object VTBLs that we know about in memory.  This is so we can
// do verifier stops when detect somebody unloading a DLL that contains
// the implementation for a COM object we know about.
//
// This is be implemented almost exactly like the object tracking, above.
//
struct VtblSplayNode
{
    RTL_SPLAY_LINKS SplayLinks; // The pointers for the object splay node.
    void           *pvVtbl;     // VTBL we're talking about.
    ULONG           cRefs;      // Number of references on this object.

    VtblSplayNode(void *pv)
    {
        RtlInitializeSplayLinks(&SplayLinks);        
        pvVtbl = pv;
        cRefs  = 1;
    }
};

VtblSplayNode *gpVtblRoot = NULL;  // Root of the Vtbl tracking tree.


void *
CoVrfTrackVtbl(
    void *pvVtbl)
/*++

Routine Description:

   Track a VTBL.  This either adds a node to the tree, or simply 
   increments the reference count on an existing node.

   ASSUMPTION: We should already be protected by gObjectTrackingLock.

Return Value:

   The new node in the tree, or the existing node in the tree, or
   NULL if tracking is disabled, or NULL if we could not allocate 
   memory for the node.

--*/
{
    if (!ComVerifierSettings::VTBLTrackingEnabled())
        return NULL;

    ASSERT_LOCK_HELD(gObjectTrackingLock);

    VtblSplayNode *pNode = NULL;

    // Now insert the new node.
    if (gpVtblRoot == NULL)
    {
        // If the allocation fails, we don't care-- we just won't be
        // tracking this VTBL.
        gpVtblRoot = new VtblSplayNode(pvVtbl);
        pNode = gpVtblRoot;
    }
    else
    {
        VtblSplayNode *pCurrent = gpVtblRoot;
        while (TRUE)
        {
            if (pCurrent->pvVtbl == pvVtbl)
            {
                // Already got it!  Just increment the ref count
                // and return.
                pNode = pCurrent;  
                pNode->cRefs++;
                break;
            }
            else if (pvVtbl < pCurrent->pvVtbl)
            {
                if (pCurrent->SplayLinks.LeftChild)
                {
                    pCurrent = (VtblSplayNode *)(pCurrent->SplayLinks.LeftChild);
                }
                else
                {
                    // New node.  Again, don't care if the allocation fails or not.
                    pNode = new VtblSplayNode(pvVtbl);
                    if (pNode)
                        RtlInsertAsLeftChild(pCurrent, pNode);
                    break;
                }
            }
            else
            {
                if (pCurrent->SplayLinks.RightChild)
                {
                    pCurrent = (VtblSplayNode *)(pCurrent->SplayLinks.RightChild);
                }
                else
                {
                    // New node.  Again, don't care if the allocation fails or not.
                    pNode = new VtblSplayNode(pvVtbl);
                    if (pNode)
                        RtlInsertAsRightChild(pCurrent, pNode);
                    break;
                }
            }
        }

        //FIX: COM 33174 - Shouldn't splay tree if node is NULL.
        if(pNode)
        {
            // 'splay' the tree.
            gpVtblRoot = (VtblSplayNode*)RtlSplay((PRTL_SPLAY_LINKS)pNode);
        }
    }

    ASSERT_LOCK_HELD(gObjectTrackingLock);

    return pNode;
}


//-----------------------------------------------------------------------------



void 
CoVrfStopTrackingVtbl(void *pvNode)
/*++

Routine Description:

   Stop tracking a VTBL.

   Decrement the reference count on this VTBL node.  If it goes to 0, remove
   the VTBL from the tree.

   ASSUMPTION: We should already be protected by gObjectTrackingLock.

Return Value:

   None.

--*/
{
    // If the node is NULL, either we're not tracking or we failed an allocation.
    // But there's nothing to search for and remove.
    if (pvNode == NULL)
        return;

    ASSERT_LOCK_HELD(gObjectTrackingLock);

    VtblSplayNode *pNode = (VtblSplayNode *)pvNode;

    pNode->cRefs--;
    if (pNode->cRefs == 0)
    {
        gpVtblRoot = (VtblSplayNode *)RtlDelete((PRTL_SPLAY_LINKS)pNode);
        delete pNode;
    }
}


//-----------------------------------------------------------------------------


void
CoVrfFreeMemVtblChecks(
    void *pvMem, 
    SIZE_T cbMem, 
    PVOID pvContext)
/*++

Routine Description:

   See if there are any VTBLs in the specified block of memory,
   and break if there are.

Return Value:

   None.

--*/
{
    // If not tracking objects, no work to do!
    if (ComVerifierSettings::VTBLTrackingEnabled())
    {
        ASSERT_LOCK_HELD(gObjectTrackingLock);

        VtblSplayNode *pCurrent = gpVtblRoot;
        while (pCurrent)
        {
            if ((LPBYTE)pCurrent->pvVtbl >= pvMem &&
                (LPBYTE)pCurrent->pvVtbl < (LPBYTE)pvMem + cbMem)
            {
                if (pvContext)
                {
                    VERIFIER_STOP(APPLICATION_VERIFIER_COM_VTBL_IN_UNLOADED_DLL,
                                  "Unloading DLL containing implmentation of marshalled COM object",
                                  pCurrent->pvVtbl, "Object VTBL",
                                  pvContext,        "DLL name address.  Use du to dump it.",
                                  pvMem,            "DLL base address",
                                  NULL,             "");
                }
                else
                {
                    VERIFIER_STOP(APPLICATION_VERIFIER_COM_VTBL_IN_FREED_MEMORY,
                                  "Freeing memory containing implementation of marshalled COM object",
                                  pCurrent->pvVtbl, "Object VTBL",
                                  pvMem,            "Pointer to start of memory block",
                                  cbMem,            "Size of memory block",
                                  NULL,             "");
                }
                
                // Keep searching, to the right only.
                // This might miss some objects, but we've already caught one.  One is
                // bad enough.  And this way we don't have to recurse.
                pCurrent = (VtblSplayNode *)(pCurrent->SplayLinks.RightChild);
            }       
            else if (pCurrent->pvVtbl < pvMem)
            {
                pCurrent = (VtblSplayNode *)(pCurrent->SplayLinks.LeftChild);
            }
            else
            {
                pCurrent = (VtblSplayNode *)(pCurrent->SplayLinks.RightChild);
            }
        }
        
        // Done!
        ASSERT_LOCK_HELD(gObjectTrackingLock);
    }    
}

//-----------------------------------------------------------------------------


//
// OBJECT TRACKING
//
// Track objects that we know about in memory.  This is so we can
// do verifier stops when detect somebody freeing memory that contains
// a COM object.
//
// This is be implemented with a splay tree.  Thankfully, splay tree
// functions are exported from ntdll so I don't have to write my own.
// The tree has it's root at gpObjectRoot, and it is protected with
// gObjectTrackingLock.
//
struct ObjectSplayNode
{
    RTL_SPLAY_LINKS SplayLinks;     // The pointers for the object splay node.
    void           *pvObject;       // Object we're talking about.
    void           *pvVtblTracking; // Cookie for tracking the object's VTBL. 

    ObjectSplayNode(void *pvObj)
    {
        RtlInitializeSplayLinks(&SplayLinks);
        pvObject = pvObj;
        pvVtblTracking = NULL;
    }
};

ObjectSplayNode *gpObjectRoot = NULL; // Root of the object tracking tree.


void *
CoVrfTrackObject(
    void *pvObject)
/*++

Routine Description:

   Begin tracking an object.

   This involves allocating an ObjectSplayNode and inserting it into
   gpObjectRoot.

Return Value:

   The new node in the tree, or NULL if object tracking is disabled or
   we could not allocate memory for the node.

--*/
{
    if (!(ComVerifierSettings::ObjectTrackingEnabled() ||
          ComVerifierSettings::VTBLTrackingEnabled()))
        return NULL;

    if (pvObject == NULL)
        return NULL;
    
    ObjectSplayNode *pNode = new ObjectSplayNode(pvObject);
    if (pNode == NULL)
    {
        // We're out of memory.  Oh well.  Don't track
        // this object.
        return NULL;
    }

    // Take the writer lock for the tree.
    LOCK(gObjectTrackingLock);

    // First, track the object's VTBL.
    void *pvVtbl = *((void **)pvObject);
    pNode->pvVtblTracking = CoVrfTrackVtbl(pvVtbl);

    // Now track the object.
    if (ComVerifierSettings::ObjectTrackingEnabled())
    {
        if (gpObjectRoot == NULL)
        {
            gpObjectRoot = pNode;
        }
        else
        {
            ObjectSplayNode *pCurrent = gpObjectRoot;
            while (TRUE)
            {
                if (pNode->pvObject < pCurrent->pvObject)
                {
                    if (pCurrent->SplayLinks.LeftChild)
                    {
                        pCurrent = (ObjectSplayNode *)(pCurrent->SplayLinks.LeftChild);
                    }
                    else
                    {
                        RtlInsertAsLeftChild(pCurrent, pNode);
                        break;
                    }
                }
                else
                {
                    if (pCurrent->SplayLinks.RightChild)
                    {
                        pCurrent = (ObjectSplayNode *)(pCurrent->SplayLinks.RightChild);
                    }
                    else
                    {
                        RtlInsertAsRightChild(pCurrent, pNode);
                        break;
                    }
                }
            }

            if(pNode)
            {
                // 'splay' tree.
                gpObjectRoot = (ObjectSplayNode*)RtlSplay((PRTL_SPLAY_LINKS)pNode);
            }
        }
    }

    UNLOCK(gObjectTrackingLock);

    return pNode;
}


//-----------------------------------------------------------------------------



void 
CoVrfStopTrackingObject(void *pvNode)
/*++

Routine Description:

   Stop tracking an object.

   We do this by simply removing the object from the splay tree, and freeing
   the node we allocated.

Return Value:

   None.

--*/
{
    // If the node is NULL, either we're not tracking or we failed an allocation.
    // But there's nothing to search for and remove.
    if (pvNode == NULL)
        return;

    ObjectSplayNode *pNode = (ObjectSplayNode *)pvNode;
    
    // Take the writer lock for the tree.
    LOCK(gObjectTrackingLock);

    // Stop tracking the object's VTBL.
    CoVrfStopTrackingVtbl(pNode->pvVtblTracking);

    // Stop tracking the object, if ever we started.
    if (ComVerifierSettings::ObjectTrackingEnabled())
    {
        gpObjectRoot = (ObjectSplayNode *)RtlDelete((PRTL_SPLAY_LINKS)pNode);
    }

    delete pNode;

    // Done!
    UNLOCK(gObjectTrackingLock);
}


//-----------------------------------------------------------------------------


void
CoVrfFreeMemObjectChecks(
    void *pvMem, 
    SIZE_T cbMem, 
    PVOID pvContext)
/*++

Routine Description:

   See if there are any COM objects in the specified block of memory,
   and break if there are.

Return Value:

   None.

--*/
{
    // If not tracking objects, no work to do!
    if (ComVerifierSettings::ObjectTrackingEnabled())
    {
        ASSERT_LOCK_HELD(gObjectTrackingLock);

        ObjectSplayNode *pCurrent = gpObjectRoot;
        while (pCurrent)
        {
            if ((LPBYTE)pCurrent->pvObject >= pvMem &&
                (LPBYTE)pCurrent->pvObject < (LPBYTE)pvMem + cbMem)
            {
                if (pvContext)
                {
                    VERIFIER_STOP(APPLICATION_VERIFIER_COM_OBJECT_IN_UNLOADED_DLL,
                                  "Unloading DLL containing marshalled COM object",
                                  pCurrent->pvObject, "Pointer to COM object",
                                  pvContext,          "DLL name address.  Use du to dump it.",
                                  pvMem,              "DLL base address",
                                  NULL,               "");
                }
                else
                {
                    VERIFIER_STOP(APPLICATION_VERIFIER_COM_OBJECT_IN_FREED_MEMORY,
                                  "Freeing memory containing marshalled COM object",
                                  pCurrent->pvObject, "Pointer to COM object",
                                  pvMem,              "Pointer to start of memory block",
                                  cbMem,              "Size of memory block",
                                  NULL,               "");
                }
                
                // Keep searching, to the right only.
                // This might miss some objects, but we've already caught one.  One is
                // bad enough.  And this way we don't have to recurse.
                pCurrent = (ObjectSplayNode *)(pCurrent->SplayLinks.RightChild);
            }       
            else if (pCurrent->pvObject < pvMem)
            {
                pCurrent = (ObjectSplayNode *)(pCurrent->SplayLinks.LeftChild);
            }
            else
            {
                pCurrent = (ObjectSplayNode *)(pCurrent->SplayLinks.RightChild);
            }
        }

        // Done!
        ASSERT_LOCK_HELD(gObjectTrackingLock);
    }
}


//-----------------------------------------------------------------------------


NTSTATUS
CoVrfFreeMemoryChecks(
    void *pvMem, 
    SIZE_T cbMem, 
    PVOID pvContext)
/*++

Routine Description:

   Check to see if we're tracking anything in this block of memory.

Return Value:

   None.

--*/
{
    // We'd better be tracking SOMETHING!
    Win4Assert(ComVerifierSettings::ObjectTrackingEnabled() || 
               ComVerifierSettings::VTBLTrackingEnabled());

    // Don't bother if the process isn't initialized.
    if (g_cProcessInits > 0)
    {
        // Take a lock for the tree.
        LOCK(gObjectTrackingLock);
    
        // Check object tracking.
        CoVrfFreeMemObjectChecks(pvMem, cbMem, pvContext);
        
        // Check VTBL tracking.
        CoVrfFreeMemVtblChecks(pvMem, cbMem, pvContext);
        
        // Done!
        UNLOCK(gObjectTrackingLock);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\verifier\threadstate.cxx ===
//+---------------------------------------------------------------------------
//
//  File:       threadstate.cxx
//
//  Contents:   Externally usable functions for getting a snapshot of the 
//              current COM state.  Also, tests to catch unbalanced uses 
//              of CoInitialize, CoUninitialize, CoEnterServiceDomain, and
//              CoLeaveServiceDomain.
//
//  Functions:  CoVrfGetThreadState        - Get a copy of TLS
//              CoVrfCheckThreadState      - Compare current TLS to stored TLS, 
//                                           make sure they are the same.
//              CoVrfReleaseThreadState    - Release resources used by 
//                                           CoVrfGetThreadState.
//              CoVrfNotifyCoInit          - log a CoInitialize 
//              CoVrfNotifyCoUninit        - log a CoUninitialize
//              CoVrfNotifyLeakedInit      - break because of a leaked CoInit
//              CoVrfNotifyExtraUninit     - break because of an extra CoUninitialize
//              CoVrfNotifyOleInit         - log an OleInitialize 
//              CoVrfNotifyOleUninit       - log an OleUninitialize
//              CoVrfNotifyLeakedOleInit   - break because of a leaked OleInit
//              CoVrfNotifyExtraOleUninit  - break because of a leaked OleUninit
//              CoVrfNotifyEnterServiceDomain      - log a CoPushServiceDomain
//              CoVrfNotifyLeaveServiceDomain      - log a CoPopServiceDomain
//              CoVrfNotifyLeakedServiceDomain     - break because of a leaked Service Domain
//              CoVrfNotifyExtraLeaveServiceDomain - break because of an extra CoPopServiceDomain
//
//  History:    29-Jan-02   JohnDoty    Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#include <context.hxx>

struct VerifierThreadState
{
    DWORD cComInits;
    DWORD cOleInits;
    GUID  guidContext;
    void *pvTopSWCNode;
};

HRESULT
CoVrfGetThreadState(void **ppvThreadState)
/*++

Routine Description:

    Return a pointer that represents the current COM state.  This
    pointer must be free'd with CoVrfReleaseThreadState.  It can
    be compared against the current thread state with 
    CoVrfCheckThreadState.

Return Value:

    S_OK if successful, or checks are disabled.

    E_OUTOFMEMORY if there is not enough memory to allocate
    the block to hold the thread state.    

--*/
{
    HRESULT hr = S_OK;

    // First priority, check the parameters.
    if (ppvThreadState == NULL)
        return E_INVALIDARG;
    *ppvThreadState = NULL;

    // Now try to avoid doing any work wherever possible.
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return S_OK;
    
    // Make sure we have TLS.
    COleTls tls(hr);
    if (FAILED(hr))
        return E_OUTOFMEMORY;

    VerifierThreadState *pRet = new VerifierThreadState;
    if (pRet == NULL)
        return E_OUTOFMEMORY;
    
    pRet->cComInits = tls->cComInits;
    pRet->cOleInits = tls->cOleInits;
    if (tls->pCurrentCtx)
    {
        tls->pCurrentCtx->GetContextId(&pRet->guidContext);
    }
    else
    {
        pRet->guidContext = GUID_NULL;
    }
    pRet->pvTopSWCNode = tls->pContextStack;
    
    *ppvThreadState = pRet;
    
    return S_OK;
}


//-----------------------------------------------------------------------------


HRESULT
CoVrfCheckThreadState(void *pvThreadState)
/*++

Routine Description:

    This function checks the current state of TLS against the state contained
    in pvThreadState.  It does a verifier stop if anything has changed.

Return Value:

    S_OK     Everything's fine, or the test is disabled.

    S_FALSE  A verifier stop has happened.

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return S_OK;

    VerifierThreadState *pState = (VerifierThreadState *)pvThreadState;  
    if (pState == NULL)
        return S_OK;       

    COleTls Tls;
    BOOL fStopped = FALSE;

    if (!Tls.IsNULL())
    {
        LPVOID *pvInitStack   = NULL;
        LPVOID *pvUninitStack = NULL;

        if (Tls->cComInits != pState->cComInits)
        {
            if (Tls->pVerifierData)
            {
                pvInitStack = Tls->pVerifierData->rgpvLastInitStack;
                pvUninitStack = Tls->pVerifierData->rgpvLastUninitStack;
            }

            VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_COINIT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                          "The number of CoInits on this thread has changed",
                          Tls->cComInits,    "Current number of CoInits",
                          pState->cComInits, "Old number of CoInits",
                          pvInitStack,       "Last CoInitialize stack (dump with dps)",
                          pvUninitStack,     "Last CoUninitialize stack (dump with dps)");

            fStopped = TRUE;
        }

        if (Tls->cOleInits != pState->cOleInits)
        {
            if (Tls->pVerifierData)
            {
                pvInitStack = Tls->pVerifierData->rgpvLastOleInitStack;
                pvUninitStack = Tls->pVerifierData->rgpvLastOleUninitStack;
            }

            VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_OLEINIT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                          "The number of OleInits on this thread has changed",
                          Tls->cOleInits,    "Current number of OleInits",
                          pState->cOleInits, "Old number of OleInits",
                          pvInitStack,       "Last OleInitialize stack (dump with dps)",
                          pvUninitStack,     "Last OleUninitialize stack (dump with dps)");

            fStopped = TRUE;            
        }

        GUID guidContext = GUID_NULL;
        if (Tls->pCurrentCtx)
            Tls->pCurrentCtx->GetContextId(&guidContext);

        if (guidContext != pState->guidContext)
        {
            // Context GUIDs no longer match, context IDs must have changed.
            //
            if (pState->pvTopSWCNode != NULL)
            {
                // They were in SWC when this happened.
                if (Tls->pVerifierData)
                {
                    pvInitStack = Tls->pVerifierData->rgpvLastEnterSWC;
                    pvUninitStack = Tls->pVerifierData->rgpvLastLeaveSWC;
                }

                if (Tls->pContextStack == NULL)
                {
                    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_SWC | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                  "Unbalanced call to CoLeaveServiceDomain detected",
                                  Tls->pCurrentCtx, "Current object context (ole32!CObjectContext)",
                                  pvInitStack,      "Last CoEnterServiceDomain stack (dump with dps)",
                                  pvUninitStack,    "Last CoLeaveServiceDomain stack (dump with dps)",
                                  NULL,             "");
                }
                else
                {
                    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_SWC | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                  "Unbalanced call to CoEnterServiceDomain detected",
                                  Tls->pCurrentCtx, "Current object context (ole32!CObjectContext)",
                                  pvInitStack,      "Last CoEnterServiceDomain stack (dump with dps)",
                                  pvUninitStack,    "Last CoLeaveServiceDomain stack (dump with dps)",
                                  NULL,             "");                    
                }
            }
            else
            {
                if (Tls->pContextStack != NULL)
                {
                    if (Tls->pVerifierData)
                    {
                        pvInitStack = Tls->pVerifierData->rgpvLastEnterSWC;
                        pvUninitStack = Tls->pVerifierData->rgpvLastLeaveSWC;
                    }

                    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_SWC | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                  "Unbalanced call to CoEnterServiceDomain detected",
                                  Tls->pCurrentCtx, "Current object context (ole32!CObjectContext)",
                                  pvInitStack,      "Last CoEnterServiceDomain stack (dump with dps)",
                                  pvUninitStack,    "Last CoLeaveServiceDomain stack (dump with dps)",
                                  NULL,             "");
                }
                else
                {                    
                    if (Tls->pVerifierData)
                    {
                        pvInitStack = Tls->pVerifierData->rgpvLastInitStack;
                        pvUninitStack = Tls->pVerifierData->rgpvLastUninitStack;
                    }
                    
                    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_COINIT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                                  "This thread has been uninitialized and re-initialized",
                                  Tls->cComInits,    "Current number of CoInits",
                                  0,                "",
                                  pvInitStack,      "Last CoInitialize stack (dump with dps)",
                                  pvUninitStack,    "Last CoUninitialize stack (dump with dps)");
                }
            }

            fStopped = TRUE;
        }
    }
    else
    {
        VERIFIER_STOP(APPLICATION_VERIFIER_COM_ERROR | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                      "ole32 has been unloaded and re-loaded",
                      NULL, "",
                      NULL, "",
                      NULL, "",
                      NULL, "");
        
        fStopped = TRUE;
    }

    return (fStopped ? S_FALSE : S_OK);
}

//-----------------------------------------------------------------------------


void
CoVrfReleaseThreadState(void *pvThreadState)
/*++

Routine Description:

    Release resources used by pvThreadState.

Return Value:

    none

--*/
{
    if (pvThreadState == NULL)
        return;
    
    VerifierThreadState *pState = (VerifierThreadState *)pvThreadState;  
    delete pvThreadState;
}

//-----------------------------------------------------------------------------


void 
CoVrfNotifyCoInit()
/*++

Routine Description:

    Log a CoInitialize on this thread, if initialization detection is enabled.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    HRESULT hr = S_OK;
    COleTls Tls(hr);
    if (FAILED(hr))
        return;

    if (Tls->pVerifierData)
    {
        CoVrfCaptureStackTrace(1, MAX_STACK_DEPTH, 
                               Tls->pVerifierData->rgpvLastInitStack);
    }
}

//-----------------------------------------------------------------------------


void 
CoVrfNotifyCoUninit()
/*++

Routine Description:

    Log a CoUninitialize on this thread, if initialization detection is enabled.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    HRESULT hr = S_OK;
    COleTls Tls(hr);
    if (FAILED(hr))
        return;

    if (Tls->pVerifierData)
    {
        CoVrfCaptureStackTrace(1, MAX_STACK_DEPTH, 
                               Tls->pVerifierData->rgpvLastUninitStack);
    }
}

//-----------------------------------------------------------------------------


void 
CoVrfNotifyLeakedInits()
/*++

Routine Description:

    If enabled, issue a verifier stop indicating that this thread has leaked a CoInitialize.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    LPVOID *pvInitStack   = NULL;
    LPVOID *pvUninitStack = NULL;
    ULONG   cInits        = 0;

    COleTls Tls;
    if (!Tls.IsNULL())
    {
        if (Tls->pVerifierData)
        {
            pvInitStack = Tls->pVerifierData->rgpvLastInitStack;
            pvUninitStack = Tls->pVerifierData->rgpvLastUninitStack;
        }

        cInits = Tls->cComInits;
    }
    
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_COINIT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                  "This thread has leaked a CoInitialize call",
                  cInits,         "Current number of CoInits",
                  0,              "",
                  pvInitStack,    "Stack trace for last CoInitialize (dump with dps)",
                  pvUninitStack,  "Stack trace for last CoUninitialize (dump with dps)");
}

//-----------------------------------------------------------------------------


void 
CoVrfNotifyExtraUninit()
/*++

Routine Description:

    If enabled, issue a verifier stop indicating that this thread has called CoUninitialize
    too many times.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    LPVOID *pvInitStack   = NULL;
    LPVOID *pvUninitStack = NULL;
    ULONG   cInits        = 0;

    COleTls Tls;    
    if (!Tls.IsNULL())
    {
        if (Tls->pVerifierData)
        {
            pvInitStack = Tls->pVerifierData->rgpvLastInitStack;
            pvUninitStack = Tls->pVerifierData->rgpvLastUninitStack;
        }

        cInits = Tls->cComInits;
    }
    
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_COINIT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                  "Unbalanced call to CoUninitialize on this thread",
                  cInits,         "Number of remaining CoInits",
                  0,              "",
                  pvInitStack,    "Stack trace for last CoInitialize (dump with dps)",
                  pvUninitStack,  "Stack trace for last CoUninitialize (dump with dps)");
}

//-----------------------------------------------------------------------------


void 
CoVrfNotifyOleInit()
/*++

Routine Description:

    Log an OleInitialize on this thread, if initialization detection is enabled.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    HRESULT hr = S_OK;
    COleTls Tls(hr);
    if (FAILED(hr))
        return;

    if (Tls->pVerifierData)
    {
        CoVrfCaptureStackTrace(1, MAX_STACK_DEPTH, 
                               Tls->pVerifierData->rgpvLastOleInitStack);
    }
}

//-----------------------------------------------------------------------------


void 
CoVrfNotifyOleUninit()
/*++

Routine Description:

    Log an OleUninitialize on this thread, if initialization detection is enabled.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    HRESULT hr = S_OK;
    COleTls Tls(hr);
    if (FAILED(hr))
        return;

    if (Tls->pVerifierData)
    {
        CoVrfCaptureStackTrace(1, MAX_STACK_DEPTH, 
                               Tls->pVerifierData->rgpvLastOleUninitStack);
    }
}

//-----------------------------------------------------------------------------


void 
CoVrfNotifyLeakedOleInits()
/*++

Routine Description:

    If enabled, issue a verifier stop indicating that this thread has leaked an OleInitialize.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    LPVOID *pvInitStack   = NULL;
    LPVOID *pvUninitStack = NULL;
    ULONG   cInits        = 0;

    COleTls Tls;
    if (!Tls.IsNULL())
    {
        if (Tls->pVerifierData)
        {
            pvInitStack = Tls->pVerifierData->rgpvLastOleInitStack;
            pvUninitStack = Tls->pVerifierData->rgpvLastOleUninitStack;
        }

        cInits = Tls->cOleInits;
    }
    
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_OLEINIT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                  "Unbalanced call to OleInitialize on this thread",
                  cInits,         "Number of remaining OleInits",
                  0,              "",
                  pvInitStack,    "Stack trace for last OleInitialize (dump with dps)",
                  pvUninitStack,  "Stack trace for last OleUninitialize (dump with dps)");
}

//-----------------------------------------------------------------------------


void 
CoVrfNotifyExtraOleUninit()
/*++

Routine Description:

    If enabled, issue a verifier stop indicating that this thread has called OleUninitialize
    too many times.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    LPVOID *pvInitStack   = NULL;
    LPVOID *pvUninitStack = NULL;
    ULONG   cInits        = 0;

    COleTls Tls;
    if (!Tls.IsNULL())
    {
        if (Tls->pVerifierData)
        {
            pvInitStack = Tls->pVerifierData->rgpvLastOleInitStack;
            pvUninitStack = Tls->pVerifierData->rgpvLastOleUninitStack;
        }

        cInits = Tls->cOleInits;
    }
    
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_OLEINIT | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                  "Unbalanced call to OleUninitialize on this thread",
                  cInits,         "Number of remaining OleInits",
                  0,              "",
                  pvInitStack,    "Stack trace for last OleInitialize (dump with dps)",
                  pvUninitStack,  "Stack trace for last OleUninitialize (dump with dps)");
}

//-----------------------------------------------------------------------------


void 
CoVrfNotifyEnterServiceDomain()
/*++

Routine Description:

    Log a CoPushServiceDomain on this thread, if enabled.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    HRESULT hr = S_OK;
    COleTls Tls(hr);
    if (FAILED(hr))
        return;

    if (Tls->pVerifierData)
    {
        CoVrfCaptureStackTrace(1, MAX_STACK_DEPTH, 
                               Tls->pVerifierData->rgpvLastEnterSWC);
    }
}


//-----------------------------------------------------------------------------


void 
CoVrfNotifyLeaveServiceDomain()
/*++

Routine Description:

    Log a CoPopServiceDomain on this thread, if enabled.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    HRESULT hr = S_OK;
    COleTls Tls(hr);
    if (FAILED(hr))
        return;

    if (Tls->pVerifierData)
    {
        CoVrfCaptureStackTrace(1, MAX_STACK_DEPTH, 
                               Tls->pVerifierData->rgpvLastLeaveSWC);
    }
}


//-----------------------------------------------------------------------------


void 
CoVrfNotifyLeakedServiceDomain()
/*++

Routine Description:

    If enabled, issue a verifier stop indicating that this thread has leaked a CoEnterServiceDomain.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    LPVOID *pvInitStack   = NULL;
    LPVOID *pvUninitStack = NULL;
    LPVOID  pvCurrCtx     = NULL;

    COleTls Tls;
    if (!Tls.IsNULL())
    {
        pvCurrCtx = Tls->pCurrentCtx;

        if (Tls->pVerifierData)
        {
            pvInitStack = Tls->pVerifierData->rgpvLastEnterSWC;
            pvUninitStack = Tls->pVerifierData->rgpvLastLeaveSWC;
        }
    }
    
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_SWC | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                  "Unbalanced call to CoEnterServiceDomain on this thread",
                  pvCurrCtx,      "Current object context (ole32!CObjectContext)",
                  pvInitStack,    "Stack trace for last CoEnterServiceDomain (dump with dps)",
                  pvUninitStack,  "Stack trace for last CoLeaveServiceDomain (dump with dps)",
                  0,              "");
}



//-----------------------------------------------------------------------------


void 
CoVrfNotifyExtraLeaveServiceDomain()
/*++

Routine Description:

    If enabled, issue a verifier stop indicating that this thread has called
    CoLeaveServiceDomain one too many times.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyThreadStateEnabled())
        return;
    
    LPVOID *pvInitStack   = NULL;
    LPVOID *pvUninitStack = NULL;
    LPVOID  pvCurrCtx     = NULL;

    COleTls Tls;
    if (!Tls.IsNULL())
    {
        pvCurrCtx = Tls->pCurrentCtx;

        if (Tls->pVerifierData)
        {
            pvInitStack = Tls->pVerifierData->rgpvLastEnterSWC;
            pvUninitStack = Tls->pVerifierData->rgpvLastLeaveSWC;
        }        
    }
    
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNBALANCED_SWC | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                  "Unbalanced call to CoLeaveServiceDomain on this thread",
                  pvCurrCtx,      "Current object context (ole32!CObjectContext)",
                  pvInitStack,    "Stack trace for last CoEnterServiceDomain (dump with dps)",
                  pvUninitStack,  "Stack trace for last CoLeaveServiceDomain (dump with dps)",
                  0,              "");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\verifier\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   verifier
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     $(INCLUDES);..\..\..\idl\public\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona
INCLUDES=     $(INCLUDES);..\..\..\idl\private\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\daytona\$(O)
INCLUDES=     $(INCLUDES);..\..\..\ih
INCLUDES=     $(INCLUDES);..\..\dcomrem
INCLUDES=     $(INCLUDES);..\..\inc
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

SOURCES=	  ..\verify.cxx      \
			  ..\threadstate.cxx \
			  ..\secure.cxx		 \
			  ..\tracking.cxx

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\verifier\secure.cxx ===
//+---------------------------------------------------------------------------
//
//  File:       secure.cxx
//
//  Contents:   Security COM AppVerifier tests.
//
//  Functions:  CoVrfCheckSecurityParameters  - check to make sure parameters
//                                              to CoInitializeSecurity aren't
//                                              dumb.
//
//  History:    08-Feb-02   JohnDoty    Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#include <security.hxx>

const SID LOCAL_SYSTEM_SID = {SID_REVISION, 1, {0,0,0,0,0,5},
                              SECURITY_LOCAL_SYSTEM_RID };

void 
CoVrfCheckSecuritySettings()
/*++

Routine Description:

    This function checks the parameters for CoInitializeSecurity
    to make sure they're "reasonable".

    Our definition of reasonable is:
       - No NULL DACL.
       - No implicit impersonation for LocalSystem.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifySecurityEnabled())
        return;

    BOOL fRet;
    if (gSecDesc != NULL)
    {
        BOOL fPresent = FALSE;
        BOOL fDefault = FALSE;
        PACL pACL     = FALSE;
        
        fRet = GetSecurityDescriptorDacl(gSecDesc, &fPresent, &pACL, &fDefault);
        Win4Assert(fRet && "GetSecurityDescriptorDacl failed?");

        if ((!fPresent) || (pACL == NULL))
        {
            // Uh oh!  NULL DACL! For shame!
            VERIFIER_STOP(APPLICATION_VERIFIER_COM_NULL_DACL | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                          "Calling CoInitializeSecurity with NULL DACL",
                          gSecDesc,  "Security Descriptor",
                          NULL,      "",
                          NULL,      "",
                          NULL,      "");
        }
    }
    
    HANDLE hToken;
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hToken))
    {
        HANDLE hImpToken;
        if (DuplicateToken(hToken, SecurityImpersonation, &hImpToken))
        {
            BOOL fIsLocalSystem = FALSE;
            CheckTokenMembership(hImpToken, (PSID)&LOCAL_SYSTEM_SID, &fIsLocalSystem);
            if (fIsLocalSystem && (gImpLevel >= RPC_C_IMP_LEVEL_IMPERSONATE))
            {
                // You're SYSTEM, yet by default you allow impersonation?
                // Bad you!
                VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNSAFE_IMPERSONATION | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                              "SYSTEM process allowing impersonation by default",
                              hToken,     "Process token",
                              gImpLevel,  "Default impersonation level",
                              NULL,       "",
                              NULL,       "");
            }

            CloseHandle(hImpToken);
        }

        CloseHandle(hToken);
    }
}

//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\fwd\catfact.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       d:\nt\private\ole32\comcat\src\catfact.cpp
//
//  Contents:   This is a stub for comcat.dll after it's merged into
//              ole32.dll. It will forward DllGetRegisterServer and
//              DllGetClassObject to ole32.dll, local version of
//              DllCanUnloadNow and DllUnregisterServer is provided.
//
//  Classes:
//
//  Functions:  DllUnregisterServer
//              DllCanUnloadNow
//              DllRegisterServer
//
//  History:    10-Mar-97   YongQu  Created
//+---------------------------------------------------------------------

#include <windows.h>
#include <ole2.h>
#include <tchar.h>

#pragma comment(linker, "/export:DllGetClassObject=Ole32.DllGetClassObject,PRIVATE")

// Due to NT bug #314014, we no longer explicitly forward DllRegisterServer
// to ole32.  The reason: ole32 also registers other components (namely storage)
// which access reg keys that cannot be written by non-admin accounts.  Since
// ole32, and by extension comcat, is already registered on the system,
// comcat's DllRegisterServer can be a no-op.

//#pragma comment(linker, "/export:DllRegisterServer=Ole32.DllRegisterServer,PRIVATE")
STDAPI DllRegisterServer()
{
    return S_OK;
}

// can never unload
STDAPI DllCanUnloadNow()
{
    return S_FALSE;
}

// still provide this, but seems to be unnecessary
STDAPI DllUnregisterServer(void)
{
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\fwd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by comcat.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\verifier\verify.cxx ===
//+---------------------------------------------------------------------------
//
//  File:       verify.cxx
//
//  Contents:   Definitions for the COM AppVerifier tests
//
//  Classes:    ComVerifierSettings        - handles the settings for enabling and
//                                           disabling the COM verifier tests.
//
//  Functions:  CoVrfDllMainCheck          - check if the loader lock is held
//              CoVrfBreakOnException      - break on a caught exception
//              CoVrfHoldingNoLocks        - check if any locks are held
//              CoVrfNotifySmuggledWrapper - break on a smuggled cross-context proxy
//              CoVrfNotifySmuggledProxy   - break on a smuggled cross-apt proxy
//              CoVrfCaptureStackTrace     - capture a stack trace, for any of the
//                                           functions that need one
//
//  History:    29-Jan-02   JohnDoty    Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>

COleStaticMutexSem gVerifierLock;

//
// Yes, I know, we're supposed to be using delay-load now.  I don't want to
// delay-load verifier.dll.
//
typedef NTSTATUS (*VERIFIER_FREE_MEMORY_CALLBACK)(PVOID Address, SIZE_T Size, PVOID Context);
typedef LOGICAL  (*PFN_VerifierIsDllEntryActive)(OUT PVOID *pvReserved);
typedef LOGICAL  (*PFN_VerifierIsCurrentThreadHoldingLocks)(VOID);
typedef NTSTATUS (*PFN_VerifierAddFreeMemoryCallback)(VERIFIER_FREE_MEMORY_CALLBACK Callback);
typedef NTSTATUS (*PFN_VerifierDeleteFreeMemoryCallback)(VERIFIER_FREE_MEMORY_CALLBACK Callback);

PFN_VerifierIsDllEntryActive            VerifierIsDllEntryActive = NULL;
PFN_VerifierIsCurrentThreadHoldingLocks VerifierIsCurrentThreadHoldingLocks = NULL;
PFN_VerifierAddFreeMemoryCallback       VerifierAddFreeMemoryCallback = NULL;
PFN_VerifierDeleteFreeMemoryCallback    VerifierDeleteFreeMemoryCallback = NULL;

NTSTATUS
CoVrfFreeMemoryChecks(
    void *pvMem,
    SIZE_T cbMem,
    PVOID pvContext);

//
// The COM verifier tests.
//

void 
CoVrfDllMainCheck()
/*++

Routine Description:

    If enabled, check to see if the loader lock is being held by this thread.  
    If it is, do a verifier stop.

Return Value:

    None

--*/
{
    // Only do this if DllMain checks are enabled.
    if (!ComVerifierSettings::DllMainChecksEnabled())
        return;

    if (VerifierIsDllEntryActive(NULL))
    {
        // We ARE holding the loader lock!  Shame on us!
        VERIFIER_STOP(APPLICATION_VERIFIER_COM_API_IN_DLLMAIN | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                      "COM API or Proxy called from DllMain",
                      0, "",
                      0, "",
                      0, "",
                      0, "");
    }
}

//-----------------------------------------------------------------------------


BOOL 
CoVrfBreakOnException(
    LPEXCEPTION_POINTERS pExcpn,
    LPVOID pvObject,
    const IID *pIID, 
    ULONG ulMethod)
/*++

Routine Description:

    If enabled, issue a verifier stop for the thrown exception.

Return Value:

    TRUE if a verifier stop was issued, FALSE if not.

--*/
{
    // Only do this if DllMain checks are enabled.
    if (!ComVerifierSettings::BreakOnExceptionEnabled())
        return FALSE;
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_UNHANDLED_EXCEPTION | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                  "Unhandled exception in COM call",
                  pExcpn,                  "Exception pointers (use .exr, .cxr, kb to dump)",
                  pvObject,                "Pointer to stub or object that was called",
                  pIID,                    "Pointer to IID that call was made on",
                  ulMethod,                "Method that call was made on");

    return TRUE;
}

//-----------------------------------------------------------------------------


void 
CoVrfHoldingNoLocks()
/*++

Routine Description:

    If enabled, issue a verifier stop if this thread is holding any locks.

    Also implicitly calls CoVrfDllMainCheck, since any time you can't be
    holding locks goes double for the loader lock.

Return Value:

    None

--*/
{
    CoVrfDllMainCheck();

    if (!ComVerifierSettings::VerifyLocksEnabled())
        return;

    if (VerifierIsCurrentThreadHoldingLocks())
    {
        VERIFIER_STOP(APPLICATION_VERIFIER_COM_HOLDING_LOCKS_ON_CALL | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                      "A lock is being held across a COM call (examine current stack)",
                      NULL, "",
                      NULL, "", 
                      NULL, "",
                      NULL, "");
    }
}

//-----------------------------------------------------------------------------


void 
CoVrfNotifySmuggledWrapper(
    REFIID          riid,
    DWORD           dwMethod,
    CStdWrapper    *pWrapper)
/*++

Routine Description:

    If enabled, issue a verifier stop, since this proxy has been smuggled.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyProxiesEnabled())
        return;
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_SMUGGLED_WRAPPER | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                  "A COM+ proxy was called from the wrong context",
                  &riid,    "Pointer to IID of the proxy",
                  dwMethod, "The method called on the proxy",
                  NULL,     "",
                  pWrapper, "The actual proxy (ole32!CStdWrapper)");
}


//-----------------------------------------------------------------------------


void 
CoVrfNotifySmuggledProxy(
    REFIID          riid,
    DWORD           dwMethod,
    DWORD           dwValidApt)
/*++

Routine Description:

    If enabled, issue a verifier stop, since this proxy has been smuggled.

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyProxiesEnabled())
        return;
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_SMUGGLED_PROXY | APPLICATION_VERIFIER_CONTINUABLE_BREAK,
                  "A COM proxy was called from the wrong context",
                  &riid,                   "Pointer to IID of the proxy",
                  dwMethod,                "The method called on the proxy",
                  dwValidApt,              "Apartment this proxy is valid in",
                  GetCurrentApartmentId(), "Current Apartment\n"
                  "(For apartments, 0 == MTA, FFFFFFFF == NA, otherwise tid of STA)");
}


//-----------------------------------------------------------------------------


void 
CoVrfNotifyCFSuccessWithNULL(
    IClassFactory *pCF,
    REFCLSID       rclsid,
    REFIID         riid,
    HRESULT        hr)
/*++

Routine Description:

    If enabled, issue a verifier stop indicating that this class factory has
    returned a success error code, with a NULL object.  (Thus confusing us 
    terribly.)

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyClassFactoriesEnabled())
        return;
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_CF_SUCCESS_WITH_NULL,
                  "A class factory has returned success, but a NULL object",
                  pCF,     "Pointer to class factory",
                  &rclsid, "Pointer to CLSID being created",
                  &riid,   "Pointer to IID being requested",
                  hr,      "The HRESULT returned")
}


//-----------------------------------------------------------------------------


void 
CoVrfNotifyGCOSuccessWithNULL(
    LPCWSTR   wszFileName,
    REFCLSID  rclsid,
    REFIID    riid,
    HRESULT   hr)
/*++

Routine Description:

    If enabled, issue a verifier stop indicating that we called DllGetClassObject,
    it returned a success error code, with a NULL class factory.  (Thus confusing 
    us terribly.)

Return Value:

    None

--*/
{
    if (!ComVerifierSettings::VerifyClassFactoriesEnabled())
        return;
    
    VERIFIER_STOP(APPLICATION_VERIFIER_COM_GCO_SUCCESS_WITH_NULL,
                  "A call to DllGetClassObject has returned success, but a NULL object",
                  wszFileName, "DLL that was called",
                  &rclsid,     "Pointer to CLSID being requested",
                  &riid,       "Pointer to IID being requested",
                  hr,          "The HRESULT returned");
}


//-----------------------------------------------------------------------------

#pragma optimize ("", off)
void 
CoVrfCaptureStackTrace(
    int     cFramesToSkip,
    int     cFramesToGet,
    LPVOID *ppvStack)
/*++

Routine Description:

    Capture a stack trace.  If we are using slow stack traces,
    then use the built-in stack walker.  Otherwise, use
    RtlCaptureStackBackTrace().

Return Value:

    None

--*/
{
    ZeroMemory(ppvStack, sizeof(LPVOID) * cFramesToGet);

    BOOL fCapturedStackTrace = FALSE;

    // Increment cFramesToSkip so that we skip this particular function.
    cFramesToSkip++;

    if (ComVerifierSettings::UseSlowStackTraces())
    {
        // Try to use slow stack traces.
        //
        IStackWalker *pStackWalker = ComVerifierSettings::GetStackWalker();
        if (pStackWalker)
        {
            CONTEXT ctx;
            ZeroMemory(&ctx, sizeof ctx);
            ctx.ContextFlags = CONTEXT_CONTROL;
            GetThreadContext(GetCurrentThread(), &ctx);
            
            IStackWalkerStack *pStack = pStackWalker->CreateStackTrace(&ctx,
                                                                       GetCurrentThread(),
                                                                       CREATESTACKTRACE_ONLYADDRESSES);
            if (pStack)
            {         
                int i = 0;
                IStackWalkerSymbol *pSymbol = pStack->TopSymbol();

                while (pSymbol)
                {
                    IStackWalkerSymbol *pTemp;
                    
                    if ((i - cFramesToSkip) >= cFramesToGet)
                    {
                        break;                                       
                    }
 
                    if (i >= cFramesToSkip)
                    {
                        ppvStack[(i-cFramesToSkip)] = (void *)pSymbol->Address();
                    }
                    
                    pTemp = pSymbol;
                    pSymbol = pSymbol->Next();
                    pTemp->Release();
                    
                    i++;
                }
                
                if (pSymbol)
                    pSymbol->Release();
                pStack->Release();

                fCapturedStackTrace = TRUE;
            }

            pStackWalker->Release();
        }
    }

    if (!fCapturedStackTrace)
    {
        RtlCaptureStackBackTrace(cFramesToSkip,
                                 cFramesToGet,
                                 ppvStack,
                                 NULL);        
    }
}
#pragma optimize ("", on)

//-----------------------------------------------------------------------------


//
// Implementation for the ComVerifierSettings class, which reads the registry
// and initializes the flags.
//
BOOL ComVerifierSettings::s_fComVerifierEnabled       = FALSE;

BOOL ComVerifierSettings::s_fEnableDllMainChecks      = FALSE;
BOOL ComVerifierSettings::s_fEnableBreakOnException   = FALSE;
BOOL ComVerifierSettings::s_fEnableVerifyLocks        = FALSE;
BOOL ComVerifierSettings::s_fEnableVerifyThreadState  = FALSE;
BOOL ComVerifierSettings::s_fEnableVerifySecurity     = FALSE;
BOOL ComVerifierSettings::s_fEnableVerifyProxies      = FALSE;
BOOL ComVerifierSettings::s_fEnableVerifyClassFactory = FALSE;
BOOL ComVerifierSettings::s_fEnableObjectTracking     = FALSE;
BOOL ComVerifierSettings::s_fEnableVTBLTracking       = FALSE;

BOOL ComVerifierSettings::s_fUseSlowStackTraces       = FALSE;

BOOL ComVerifierSettings::s_fPgAllocUseSystemHeap     = FALSE;
BOOL ComVerifierSettings::s_fPgAllocHeapIsPrivate     = FALSE;

IStackWalker *ComVerifierSettings::s_pStackWalker     = NULL;


ComVerifierSettings ComVerifierSettings::s_singleton;


//-----------------------------------------------------------------------------


typedef NTSTATUS (*PFN_VerifierQueryRuntimeFlags)(OUT PLOGICAL VerifierEnabled,
                                                  OUT PULONG   VerifierFlags);

HRESULT CStackWalkerCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv);

ComVerifierSettings::ComVerifierSettings()
/*++

Routine Description:

   Constructor.  Check verifier flags, read registry if necessary.

Return Value:

    None

--*/
{
    // First, check gflags to see if the app verifier is enabled in this process.
    if (NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) 
    {
        // It is, so we should be able to get the handle to verifier.dll
        // (but check just in case)
        HMODULE hVerifier = GetModuleHandle(L"verifier.dll");
        if (hVerifier)
        {
            // Great.  Ask it for the specific configured verifier flags.
            PFN_VerifierQueryRuntimeFlags VerifierQueryRuntimeFlags;
            VerifierQueryRuntimeFlags = (PFN_VerifierQueryRuntimeFlags)GetProcAddress(hVerifier,
                                                                                      "VerifierQueryRuntimeFlags");
            if (VerifierQueryRuntimeFlags)
            {
                LOGICAL fEnabled = FALSE;
                ULONG   ulFlags  = 0;

                NTSTATUS status = VerifierQueryRuntimeFlags(&fEnabled, &ulFlags);
                if ((status == STATUS_SUCCESS) && (fEnabled) &&
                    (ulFlags & RTL_VRF_FLG_COM_CHECKS))
                {
                    // Good grief, that was a lot to check.
                    //
                    // But yes, we should be reading the registry to enable tests.
                    s_fComVerifierEnabled = TRUE;

                    // Get pointers to the various Verifier APIs now.
                    VerifierIsDllEntryActive = (PFN_VerifierIsDllEntryActive)GetProcAddress(hVerifier, "VerifierIsDllEntryActive");
                    VerifierIsCurrentThreadHoldingLocks = (PFN_VerifierIsCurrentThreadHoldingLocks)GetProcAddress(hVerifier, "VerifierIsCurrentThreadHoldingLocks");
                    VerifierAddFreeMemoryCallback = (PFN_VerifierAddFreeMemoryCallback)GetProcAddress(hVerifier, "VerifierAddFreeMemoryCallback");
                    VerifierDeleteFreeMemoryCallback = (PFN_VerifierDeleteFreeMemoryCallback)GetProcAddress(hVerifier, "VerifierDeleteFreeMemoryCallback");
                }
            }
        }
    }
    
    if (s_fComVerifierEnabled)
    {
        // Ok, dig through the registry to figure out which tests to actually run.
        s_fEnableDllMainChecks      = ReadKey(L"ComEnableDllMainChecks",     TRUE);
        s_fEnableBreakOnException   = ReadKey(L"ComBreakOnAllExceptions",    TRUE);
        s_fEnableVerifyLocks        = ReadKey(L"ComVerifyLocksOnCall",       FALSE);
        s_fEnableVerifyThreadState  = ReadKey(L"ComVerifyThreadState",       TRUE);
        s_fEnableVerifySecurity     = ReadKey(L"ComVerifySecurity",          TRUE);
        s_fEnableVerifyProxies      = ReadKey(L"ComVerifyProxies",           TRUE);
        s_fEnableVerifyClassFactory = ReadKey(L"ComVerifyClassFactory",      TRUE);
        s_fEnableObjectTracking     = ReadKey(L"ComEnableObjectTracking",    TRUE);
        s_fEnableVTBLTracking       = ReadKey(L"ComEnableVTBLTracking",      TRUE);

        s_fUseSlowStackTraces       = ReadKey(L"ComVerifyGetSlowStacks",           FALSE);

        s_fPgAllocUseSystemHeap     = ReadKey(L"PageAllocatorUseSystemHeap",       TRUE);
        s_fPgAllocHeapIsPrivate     = ReadKey(L"PageAllocatorSystemHeapIsPrivate", TRUE);        

        if (s_fEnableObjectTracking || s_fEnableVTBLTracking)
        {
            // Object tracking is enabled, add our callback for free memory.
            VerifierAddFreeMemoryCallback(CoVrfFreeMemoryChecks);
        }
    }
    else
    {
        // Everything else is disabled, but we still want to get global settings
        // for these values.
        s_fPgAllocUseSystemHeap = ReadOleKey(L"PageAllocatorUseSystemHeap",       FALSE);
        s_fPgAllocHeapIsPrivate = ReadOleKey(L"PageAllocatorSystemHeapIsPrivate", FALSE);
    }
}

//-----------------------------------------------------------------------------


ComVerifierSettings::~ComVerifierSettings()
/*++

Routine Description:

    Destructor

Return Value:

    None

--*/
{
    if (s_pStackWalker)
    {
        s_pStackWalker->Release();
        s_pStackWalker = NULL;
    }

    if (s_fEnableObjectTracking)
    {
        VerifierDeleteFreeMemoryCallback(CoVrfFreeMemoryChecks);
    }
}

//-----------------------------------------------------------------------------


BOOL 
ComVerifierSettings::ReadKey(
    LPCWSTR wszKeyName, 
    BOOL fDefault)
/*++

Routine Description:

    Read the specified registry value from 
    HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\<image.exe>

    If the value does not exist, return fDefault.  
    If the value is 'Y', 'y', or '1', return TRUE.
    Otherwise, return FALSE.

Return Value:

    The value read, or fDefault.

--*/
{
    BOOL fRet = fDefault;
    
    WCHAR wszFilePath[512];        
    if (GetModuleFileName(GetModuleHandle(NULL), wszFilePath, sizeof(wszFilePath) / sizeof(WCHAR)))
    {
        DWORD dwError;

        wszFilePath[sizeof(wszFilePath)/sizeof(wszFilePath[0])-1] = L'\0';

        // Great, got the file name.  Pull out the .EXE name by looking backwards for a backslash.
        WCHAR *wszFileName = wcsrchr(wszFilePath, L'\\');
        if (wszFileName)
        {
            wszFileName++;
        }
        else
        {
            wszFileName = wszFilePath;
        }
        
        // Now look for the ImageFileExecutionOptions thing.
        HKEY hkImageOptions = NULL;
        dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options",
                               NULL,
                               KEY_READ,
                               &hkImageOptions);
        if (dwError == ERROR_SUCCESS)
        {
            // Now look for the image name specifically...
            HKEY hkImage = NULL;
            dwError = RegOpenKeyEx(hkImageOptions,
                                   wszFileName,
                                   NULL,
                                   KEY_READ,
                                   &hkImage);
            if (dwError == ERROR_SUCCESS)
            {
                
                DWORD dwType;
                WCHAR wszYN[5] = {0};
                DWORD dwSize = sizeof(wszYN);
                
                dwError = RegQueryValueEx(hkImage,
                                          wszKeyName,
                                          NULL,
                                          &dwType,
                                          (BYTE*)wszYN,
                                          &dwSize);
                if ((dwError == ERROR_SUCCESS) && (dwType == REG_SZ))
                {
                    if ((wszYN[0] == L'y') || 
                        (wszYN[0] == L'Y') || 
                        (wszYN[0] == L'1'))
                    {
                        // Explicitly enabled
                        fRet = TRUE;
                    }
                    else
                    {
                        // Explicitly disabled
                        fRet = FALSE;
                    }
                }
                
                RegCloseKey(hkImage);
            }
            
            RegCloseKey(hkImageOptions);
        }
    }

    return fRet;    
}


//-----------------------------------------------------------------------------



IStackWalker *
ComVerifierSettings::GetStackWalker()
/*++

Routine Description:

   Get the stack walker we'll use for slow stack traces.

   If we don't have one, create one, and attach it to this process.  
   We're synchronized on gVerifierLock.  If we fail at anything, go
   back to 'fast' stack traces (RtlCaptureStackBackTrace).   

   It would be very bad if calling SymInit caused a CoInitialize call.

Return Value:

   The IStackWalker to use, or NULL if initialization failed.

--*/
{
    if (s_pStackWalker == NULL)
    {
        LOCK(gVerifierLock);
        if ((s_pStackWalker == NULL) && (s_fUseSlowStackTraces))
        {
            IStackWalker *pStackWalker = NULL;
            HRESULT hr = CStackWalkerCF_CreateInstance(NULL, 
                                                       IID_IStackWalker, 
                                                       (void **)(&pStackWalker));
            if (SUCCEEDED(hr))
            {
                hr = pStackWalker->Attach(NULL);
                if (FAILED(hr))
                {
                    pStackWalker->Release();
                }
                else
                {
                    s_pStackWalker = pStackWalker;
                }
            }

            if (FAILED(hr))
            {
                // Failed.  Fall back to fast stack traces.
                //
                s_fUseSlowStackTraces = FALSE;
            }
        }
        UNLOCK(gVerifierLock);
    }

    if (s_pStackWalker)
    {
        // AddRef once for the people.
        s_pStackWalker->AddRef();
    }

    return s_pStackWalker;
}


//-----------------------------------------------------------------------------



BOOL 
ComVerifierSettings::ReadOleKey(
    LPCWSTR pwszValue,
    BOOL    fDefault)
/*++

Routine Description:

   Read a yes-no value from a key under HKLM\Software\Microsoft\Ole.

   This is used for process-wide settings.

Return Value:

   The value of the key, or fDefault if the value did not exist.

--*/
{
    BOOL fRetVal = fDefault;
    HKEY hKey = NULL;
    
    if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, 
                       L"SOFTWARE\\Microsoft\\OLE", 
                       0, 
                       KEY_READ, 
                       &hKey) == ERROR_SUCCESS)
    {
        WCHAR wszYN[4] = L"N";
        DWORD cbValue = sizeof (wszYN);
        if (RegQueryValueExW (hKey, pwszValue, NULL, NULL, (BYTE*) &wszYN, &cbValue) == ERROR_SUCCESS)
        {
            if ((wszYN[0] == L'y') || 
                (wszYN[0] == L'Y') || 
                (wszYN[0] == L'1'))
            {
                // Explicitly enabled
                fRetVal = TRUE;
            }
            else
            {
                // Explicitly disabled
                fRetVal = FALSE;
            }
        }

        RegCloseKey (hKey);
    }

    return fRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\src\catenum.cpp ===
#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <malloc.h>
#include <sddl.h>
#include <ole2sp.h>
#include <reghelp.hxx>
#include <impersonate.hxx>
#include "catenum.h"

#include "catobj.h"

extern const WCHAR *WSZ_CLSID;
extern const TCHAR *SZ_COMCAT;

// CEnumAllCatInfo:
// IUnknown methods
HRESULT CEnumCategories::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumCATEGORYINFO)
    {
        *ppObject=(IEnumCATEGORYINFO*) this;
        AddRef();
        return S_OK;
    }

    *ppObject = NULL;
    return E_NOINTERFACE;
}

ULONG CEnumCategories::AddRef()
{
    return InterlockedIncrement((long*) &m_dwRefCount);
}

ULONG CEnumCategories::Release()
{
    ULONG dwRefCount= InterlockedDecrement((long*) &m_dwRefCount);
    if (dwRefCount==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumCATEGORYINFO methods
HRESULT CEnumCategories::Next(ULONG celt, CATEGORYINFO *rgelt, ULONG *pceltFetched) {

        if (pceltFetched)
        {
                *pceltFetched=0;
        }
        else    // pceltFetched can be NULL when celt == 1) yq
        {
            if (celt > 1)
                return E_INVALIDARG;
        }

        if (!m_hKey)
        {
                return S_FALSE;
        }
        HRESULT hr;
        DWORD dwCount, dwError, dwIndex = 0;
        char szCatID[MAX_PATH+1];
        HKEY hKeyCat = NULL;

        dwCount = 0;
        if (!m_fromcs)
        {
                for (dwCount=0; dwCount<celt; dwCount++)
                {
                        dwError=RegEnumKeyA(m_hKey, m_dwIndex, szCatID, sizeof(szCatID));
                        if (dwError && dwError!=ERROR_NO_MORE_ITEMS)
                        {
                                // need to free strings?
                                return HRESULT_FROM_WIN32(dwError);
                        }
                        if (dwError ==ERROR_NO_MORE_ITEMS)
                        {
                        //----------------------forwarding to class store.
                                m_fromcs = 1;
                                break;
                        }
                        dwError=RegOpenKeyExA(m_hKey, szCatID, 0, KEY_READ, &hKeyCat);
                        if (dwError)
                        {
                                // need to free strings?
                                return HRESULT_FROM_WIN32(dwError);
                        }
                        WCHAR wszCatID[MAX_PATH+1];
                        MultiByteToWideChar(CP_ACP, 0, szCatID, -1, wszCatID, MAX_PATH+1);

                        if (FALSE == GUIDFromString(wszCatID, &rgelt[dwCount].catid))
                        {
                                RegCloseKey(hKeyCat);
                                // need to free strings?
                                return E_OUTOFMEMORY;
                        }
                        LCID newlcid;
                        LPOLESTR pszDesc = NULL;
                        hr = CComCat::GetCategoryDesc(hKeyCat, m_lcid, &pszDesc, &newlcid);
                        if(SUCCEEDED(hr))
                                wcscpy(rgelt[dwCount].szDescription, pszDesc);
                        else
                                rgelt[dwCount].szDescription[0] = _T('\0'); //fix #69883
                        if(pszDesc)
                                CoTaskMemFree(pszDesc);
                        RegCloseKey(hKeyCat);
                        if (pceltFetched)
                        {
                                (*pceltFetched)++; //gd
                        }
                        m_dwIndex++;
                        rgelt[dwCount].lcid = newlcid; // return locale actually found
                }
        }
        // class store failure is not shown to the outside implementation.
        if (m_fromcs) {
                HRESULT hr;
                ULONG   count;

                if (!m_pcsIEnumCat)
                        return S_FALSE;
                hr = m_pcsIEnumCat->Next(celt-dwCount, rgelt+dwCount, &count);
                if (pceltFetched)
                        *pceltFetched += count;
                if ((FAILED(hr)) || (hr == S_FALSE)) {
                        return S_FALSE;
                }
        }
        return S_OK;
}

HRESULT CEnumCategories::Skip(ULONG celt) {
        //m_dwIndex+=celt;
        DWORD dwCount, dwError;
        char szCatID[MAX_PATH];
        dwCount = 0;
        if (!m_fromcs)
        {
                for (dwCount=0; dwCount<celt; dwCount++)
                {
                        dwError = RegEnumKeyA(m_hKey, m_dwIndex, szCatID, sizeof(szCatID));
                        if (dwError)
                        {
                                        m_fromcs = 1;
                                        break;
                        }
                        else
                        {
                                ++m_dwIndex;
                        }
                }
        }
        if (m_fromcs) {
                HRESULT hr;
                if (!m_pcsIEnumCat)
                        return S_FALSE;
                hr = m_pcsIEnumCat->Skip(celt-dwCount);
                if (FAILED(hr) || (hr == S_FALSE)) {
                        return S_FALSE;
                }
        }
        return S_OK;
}

HRESULT CEnumCategories::Reset(void) {
        m_dwIndex=0;
        m_fromcs = 0;
        if (m_pcsIEnumCat)
                m_pcsIEnumCat->Reset();
        return S_OK;
}

HRESULT CEnumCategories::Clone(IEnumCATEGORYINFO **ppenum)
{
        CEnumCategories*                pClone=NULL;
        IEnumCATEGORYINFO*              pcsIEnumCat;
        HRESULT                                 hr;

        pClone=new CEnumCategories();

        if (!pClone)
        {
                return E_OUTOFMEMORY;
        }
        if (m_pcsIEnumCat)
                if (FAILED(hr = m_pcsIEnumCat->Clone(&pcsIEnumCat)))
		{
                   pcsIEnumCat = NULL;
                }
		else
		{
		   // Make sure SCM can impersonate this
		   hr = CoSetProxyBlanket((IUnknown *)(pcsIEnumCat),
			  RPC_C_AUTHN_WINNT,
			  RPC_C_AUTHZ_NONE, NULL,
			  RPC_C_AUTHN_LEVEL_CONNECT,
			  RPC_C_IMP_LEVEL_DELEGATE,
			  NULL, EOAC_NONE );
		}
        else
                pcsIEnumCat = NULL;

        if (FAILED(pClone->Initialize(m_lcid, pcsIEnumCat)))
        {
                delete pClone;
                return E_UNEXPECTED;
        }

        pClone->m_dwIndex=m_dwIndex;
        pClone->m_fromcs = m_fromcs;

        if (SUCCEEDED(pClone->QueryInterface(IID_IEnumCATEGORYINFO, (void**) ppenum)))
        {
                return S_OK;
        }
        delete pClone;
        return E_UNEXPECTED;
}

CEnumCategories::CEnumCategories()
{
        m_dwRefCount=0;
        m_hKey=NULL;
        m_dwIndex=0;
//      m_szlcid[0]=0;
        m_lcid=0;
        m_pcsIEnumCat = NULL;
        m_fromcs = 0;
}

HRESULT CEnumCategories::Initialize(LCID lcid, IEnumCATEGORYINFO *pcsEnumCat)
{
        m_lcid=lcid;
//      wsprintfA(m_szlcid, "%X", lcid);
        DWORD dwError;
        dwError=OpenClassesRootKey(_T("Component Categories"), &m_hKey);
        if (dwError)
        {
                m_hKey=NULL;
        }
        m_dwIndex=0;
        m_pcsIEnumCat = pcsEnumCat;
        return S_OK;
}

CEnumCategories::~CEnumCategories()
{
        if (m_hKey)
        {
                RegCloseKey(m_hKey);
                m_hKey=NULL;
        }
        if (m_pcsIEnumCat)
                m_pcsIEnumCat->Release();
}

// CEnumCategoriesOfClass:
// IUnknown methods
HRESULT CEnumCategoriesOfClass::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumCATID)
    {
        *ppObject=(IEnumCATID*) this;
        AddRef();
        return S_OK;
    }
    *ppObject = NULL;
    return E_NOINTERFACE;
}

ULONG CEnumCategoriesOfClass::AddRef()
{
    return InterlockedIncrement((long*) &m_dwRefCount);
}

ULONG CEnumCategoriesOfClass::Release()
{
    ULONG dwRefCount= InterlockedDecrement((long*) &m_dwRefCount);
    if (dwRefCount==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumCATID methods
HRESULT CEnumCategoriesOfClass::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
        if (pceltFetched)
        {
                *pceltFetched=0;
        }
        else    // pceltFetched can be NULL when celt = 1) yq
        {
            if (celt > 1)
                return E_INVALIDARG;
        }

        if (!m_hKey)
        {
                return S_FALSE;
        }

        DWORD dwCount;
        DWORD dwError;
        char szCatID[40];
        WCHAR uszCatID[40];

        for     (dwCount=0; dwCount<celt; )
        {
                dwError=RegEnumKeyA(m_hKey, m_dwIndex, szCatID, 40);
                if (dwError && dwError!=ERROR_NO_MORE_ITEMS)
                {
                        return HRESULT_FROM_WIN32(dwError);
                }
                if (dwError==ERROR_NO_MORE_ITEMS)
                {
                    if (!m_bMapOldKeys)
            {
                return S_FALSE;
            }
            if (!m_hKeyCats)
            {
            	if (!OpenClassesRootKey(SZ_COMCAT, &m_hKeyCats))
                {
                	return S_FALSE;
                }
            }
            dwError=RegEnumKeyA(m_hKeyCats, m_dwOldKeyIndex, szCatID, sizeof(szCatID)/sizeof(TCHAR));
            if (dwError==ERROR_NO_MORE_ITEMS)
            {
                return S_FALSE;
            }
            if (dwError)
            {
                return HRESULT_FROM_WIN32(dwError);
            }
            m_dwOldKeyIndex++;
                }
                MultiByteToWideChar(CP_ACP, 0, szCatID, -1, uszCatID, 40);
                if (GUIDFromString(uszCatID, &rgelt[dwCount]))
                {
                        if (pceltFetched)
                        {
                                (*pceltFetched)++; //gd
                        }
                        dwCount++;
                }
                m_dwIndex++;
        }
        return S_OK;
}

HRESULT CEnumCategoriesOfClass::Skip(ULONG celt)
{
        CATID* pcatid=(CATID*) CoTaskMemAlloc(sizeof(CATID)*celt);
        if (!pcatid)
        {
                return E_OUTOFMEMORY;
        }
        ULONG nFetched=0;
        Next(celt, pcatid, &nFetched);
        CoTaskMemFree(pcatid);
        if (nFetched<celt)
        {
                // redundant MH/GD 8/2/96: CoTaskMemFree(pcatid); // gd
                return S_FALSE;
        }
        return S_OK;
}

HRESULT CEnumCategoriesOfClass::Reset(void)
{
        m_dwIndex=0;
        m_dwOldKeyIndex=0;
        return S_OK;
}

HRESULT CEnumCategoriesOfClass::Clone(IEnumGUID **ppenum)
{
        CEnumCategoriesOfClass* pClone=NULL;
        pClone=new CEnumCategoriesOfClass();

        if (!pClone)
        {
                return E_OUTOFMEMORY;
        }
        if (FAILED(pClone->Initialize(m_hKey, m_bMapOldKeys)))
        {
                delete pClone;
                return E_UNEXPECTED;
        }
        pClone->m_dwIndex=m_dwIndex;
        pClone->m_dwOldKeyIndex=m_dwOldKeyIndex;
        pClone->m_hKeyCats=m_hKeyCats;
        pClone->m_pCloned=(IUnknown*) this;
        pClone->m_pCloned->AddRef(); // yq: missing code here.
        if (SUCCEEDED(pClone->QueryInterface(IID_IEnumGUID, (void**) ppenum)))
        {
                return S_OK;
        }
                delete pClone;

        return E_UNEXPECTED;
}


CEnumCategoriesOfClass::CEnumCategoriesOfClass()
{
        m_dwRefCount=0;

        m_hKey=NULL;
    m_hKeyCats=NULL;
        m_bMapOldKeys=FALSE;
    m_dwIndex=0;
    m_dwOldKeyIndex=0;
        m_pCloned=NULL;
}

HRESULT CEnumCategoriesOfClass::Initialize(HKEY hKey, BOOL bMapOldKeys)
{
        m_hKey=hKey;
        m_bMapOldKeys=bMapOldKeys;
        return S_OK;
}

CEnumCategoriesOfClass::~CEnumCategoriesOfClass()
{
    if (m_pCloned)
    {
        IUnknown* pUnk=m_pCloned;
        m_pCloned=NULL;
        pUnk->Release();
    }
    else
    {
        if (m_hKey)
        {
            RegCloseKey(m_hKey);
            m_hKey=NULL;
        }
        if (m_hKeyCats)
        {
            RegCloseKey(m_hKeyCats);
            m_hKeyCats=NULL;
        }
    }
}

// CEnumClassesOfCategories:
// IUnknown methods
HRESULT CEnumClassesOfCategories::QueryInterface(REFIID riid, void** ppObject)
{
    if (riid==IID_IUnknown || riid==IID_IEnumCLSID)
    {
        *ppObject=(IEnumCLSID*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

ULONG CEnumClassesOfCategories::AddRef()
{
    return InterlockedIncrement((long*) &m_dwRefCount);
}

ULONG CEnumClassesOfCategories::Release()
{
    ULONG dwRefCount= InterlockedDecrement((long*) &m_dwRefCount);
    if (dwRefCount==0)
    {
        delete this;
        return 0;
    }
    return dwRefCount;
}

// IEnumGUID methods
HRESULT CEnumClassesOfCategories::Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched)
{
    if (pceltFetched)
    {
        *pceltFetched=0;
    }
    else    // pceltFetched can be NULL when celt = 1) yq
    {
        if (celt > 1)
            return E_INVALIDARG;
    }

    if (!m_hClassKey)
    {
        return S_FALSE;
    }

    DWORD dwCount;
    DWORD dwError;
    TCHAR szCLSID[MAX_PATH+1];
    HRESULT hRes=S_OK;

    szCLSID[0]= 0;
    dwCount = 0;

    if (!m_fromcs)
    {
        for (dwCount=0; dwCount<celt; )
        {
            dwError=RegEnumKey(m_hClassKey, m_dwIndex, szCLSID, sizeof(szCLSID)/sizeof(TCHAR));
            if (dwError==ERROR_NO_MORE_ITEMS)
            {
                //--------------------------forwarding to class store
                m_fromcs = 1;
                break;
            }

            if (dwError)
            {
                // need to free strings?
                return HRESULT_FROM_WIN32(dwError);
            }
            hRes=CComCat::IsClassOfCategoriesEx(m_hClassKey, szCLSID, m_cImplemented, m_rgcatidImpl, m_cRequired, m_rgcatidReq);
            if (FAILED(hRes))
            {
                // need to free strings?
                return hRes;
            }
            if (hRes==S_OK)
            {
                CLSID clsid;
                if (GUIDFromString(szCLSID, &clsid))
                {
                    rgelt[dwCount]=clsid;
                    if (pceltFetched)
                    {
                        (*pceltFetched)++;  //gd
                    }
                    dwCount++;
                }
            }
            m_dwIndex++;
        }
    }

    if (m_fromcs) 
    {
        ULONG  count;
        HRESULT  hr;

        if (!m_pcsIEnumClsid)
            return S_FALSE;

        hr = m_pcsIEnumClsid->Next(celt-dwCount, rgelt+dwCount, &count);
        if (pceltFetched)
            *pceltFetched += count;
        if ((FAILED(hr)) || (hr == S_FALSE)) 
        {
            return S_FALSE;
        }
    }
    return S_OK;
}

HRESULT CEnumClassesOfCategories::Skip(ULONG celt)
{
    HRESULT hr;
    CATID* pDummy=(CATID*) CoTaskMemAlloc(sizeof(CATID)*celt);
    if (!pDummy)
    {
        return E_OUTOFMEMORY;
    }
    ULONG nFetched=0;
    hr = Next(celt, pDummy, &nFetched);
    CoTaskMemFree(pDummy); // gd
    return hr;
}

HRESULT CEnumClassesOfCategories::Reset(void)
{
    m_dwIndex=0;
    m_fromcs = 0;
    if (m_pcsIEnumClsid)
        m_pcsIEnumClsid->Reset();
    return S_OK;
}

HRESULT CEnumClassesOfCategories::Clone(IEnumGUID **ppenum)
{
    CEnumClassesOfCategories* pClone=NULL;
    HRESULT         hr;

    pClone=new CEnumClassesOfCategories();

    if (!pClone)
    {
        return E_OUTOFMEMORY;
    }
    if (m_pcsIEnumClsid)
    {
        if (FAILED(m_pcsIEnumClsid->Clone(&(pClone->m_pcsIEnumClsid))))
            pClone->m_pcsIEnumClsid = NULL;
        else
            // Make sure SCM can impersonate this
            hr = CoSetProxyBlanket((IUnknown *)(pClone->m_pcsIEnumClsid),
                       RPC_C_AUTHN_WINNT,
                       RPC_C_AUTHZ_NONE, NULL,
                       RPC_C_AUTHN_LEVEL_CONNECT,
                       RPC_C_IMP_LEVEL_DELEGATE,
                       NULL, EOAC_NONE );
    }
    else
        pClone->m_pcsIEnumClsid = NULL;

    pClone->m_cImplemented=m_cImplemented;
    pClone->m_cRequired=m_cRequired;
    pClone->m_rgcatidImpl=m_rgcatidImpl;
    pClone->m_rgcatidReq=m_rgcatidReq;
    pClone->m_hClassKey = m_hClassKey; // gd
    pClone->m_dwIndex=m_dwIndex;
    pClone->m_pCloned=(IUnknown*) this;
    pClone->m_pCloned->AddRef(); // gd

    if (SUCCEEDED(pClone->QueryInterface(IID_IEnumGUID, (void**) ppenum)))
    {
        return S_OK;
    }
    delete pClone;
    return E_UNEXPECTED;
}

CEnumClassesOfCategories::CEnumClassesOfCategories()
{
    m_dwRefCount=NULL;
    m_hClassKey=NULL;
    m_dwIndex=0;

    m_cImplemented=0;
    m_rgcatidImpl=NULL;
    m_cRequired=0;
    m_rgcatidReq=NULL;
    m_pcsIEnumClsid = NULL;
    m_pCloned=NULL;
    m_fromcs = 0;
}

HRESULT CEnumClassesOfCategories::Initialize(ULONG cImplemented, CATID rgcatidImpl[], ULONG cRequired,
                                                                                         CATID rgcatidReq[], IEnumGUID *pcsIEnumClsid)
{
    if(cImplemented != -1)
    {
        m_rgcatidImpl=(CATID*) CoTaskMemAlloc(cImplemented*sizeof(CATID));
        if (!m_rgcatidImpl)
        {
            return E_OUTOFMEMORY;
        }
        CopyMemory(m_rgcatidImpl, rgcatidImpl, cImplemented*sizeof(CATID));
    }
    else
        m_rgcatidImpl = NULL;

    if(cRequired != -1)
    {
        m_rgcatidReq=(CATID*) CoTaskMemAlloc(cRequired*sizeof(CATID));
        if (!m_rgcatidReq)
        {
            return E_OUTOFMEMORY;
        }
        CopyMemory(m_rgcatidReq, rgcatidReq, cRequired*sizeof(CATID));
    }
    else
        m_rgcatidReq = NULL;
    
    m_cImplemented=cImplemented;
    m_cRequired=cRequired;

    m_pcsIEnumClsid = pcsIEnumClsid;

    // Use special version of OpenClassesRootKeyExOpt
    if (OpenClassesRootSpecial(KEY_READ, &m_hClassKey))
    {
        return E_UNEXPECTED;
    }
    
    return S_OK;
}

CEnumClassesOfCategories::~CEnumClassesOfCategories()
{
     if (m_pCloned)
     {
         IUnknown* pUnk=m_pCloned;
         m_pCloned=NULL;
         pUnk->Release();
     }
     else
     {
         if (m_hClassKey)
         {
             RegCloseKey(m_hClassKey);
             m_hClassKey=NULL;
         }

         if (m_rgcatidImpl)
         {
             CoTaskMemFree(m_rgcatidImpl);
             m_rgcatidImpl=NULL;
         }
         if (m_rgcatidReq)
         {
             CoTaskMemFree(m_rgcatidReq);
             m_rgcatidReq=NULL;
         }
    }
     
    //--------------------------------cs Enum interface
    if (m_pcsIEnumClsid)
        m_pcsIEnumClsid->Release();
}

//+-------------------------------------------------------------------
//
//  Function:   OpenKeyFromUserHive, private
//
//  Synopsis:   Tries to open and return specified subkey under 
//       \Software\Classes in the user hive for the specified token.   
//       Explicitly looks in the per-user hive, not the merged user\system 
//       hive.
//
//--------------------------------------------------------------------
LONG CEnumClassesOfCategories::OpenKeyFromUserHive(HANDLE hToken, 
                                   LPCWSTR pszSubKey, 
                                   REGSAM samDesired,
                                   HKEY* phKeyInUserHive)
{
    // Retrieve the SID from the token.  Need this so we can open
    // up HKEY_USERS\<sid>\Software\Classes directly.
    BOOL fSuccess = FALSE;
    DWORD dwNeeded = 0;
    PTOKEN_USER ptu = NULL;
    LPWSTR pszSid = NULL;
    HKEY hkey = NULL;
    LONG lResult = 0;

    *phKeyInUserHive = NULL;
	
    fSuccess = GetTokenInformation(hToken,
                                   TokenUser,
                                   (PBYTE)NULL,
                                   dwNeeded,
                                   &dwNeeded);
    lResult = GetLastError();
    if (!fSuccess && lResult == ERROR_INSUFFICIENT_BUFFER)
    {
        ptu = (PTOKEN_USER)_alloca(dwNeeded);
        if (ptu)
        {
            fSuccess = GetTokenInformation(hToken,
                                           TokenUser,
                                           (PBYTE)ptu,
                                           dwNeeded,
                                           &dwNeeded);
            if (!fSuccess)
            {
                return GetLastError();	    
            }
        }
        else
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        } 
    }
    else
    {
        return lResult;
    }

    if (!ConvertSidToStringSid(ptu->User.Sid, &pszSid))
    {
        return GetLastError();
    }

    // Construct path to requested key in only the user-specific hive. 
    const LPCWSTR SOFTWARE_CLASSES = L"\\Software\\Classes\\";
    LPWSTR pszKeyPath = NULL;
    size_t dwPathSize = 0;

    dwPathSize += wcslen(pszSid);
    dwPathSize += wcslen(SOFTWARE_CLASSES);			
    if (pszSubKey != NULL && (pszSubKey[0]) )
    {
        dwPathSize += wcslen(pszSubKey);
    }
    dwPathSize++;  

    pszKeyPath = (LPWSTR)_alloca(dwPathSize * sizeof(WCHAR));

    wcscpy(pszKeyPath, pszSid);    
    LocalFree(pszSid); pszSid = NULL;
    wcscat(pszKeyPath, SOFTWARE_CLASSES);
    if (pszSubKey != NULL && (pszSubKey[0]) )
    {
        wcscat(pszKeyPath, pszSubKey);	
    }
    		
    lResult = RegOpenKeyEx(HKEY_USERS, pszKeyPath, 0, samDesired, &hkey);
    if (lResult == ERROR_SUCCESS)
    {
        *phKeyInUserHive = hkey;
    }
    else if (lResult == ERROR_FILE_NOT_FOUND)
    {
        // *phKeyInUserHive already NULL
        lResult = ERROR_SUCCESS;
    }
    return lResult;
}

//+-------------------------------------------------------------------
//
//  Function:   DecideToUseMergedHive, private
//
//  Synopsis:   One more possible optimization to check for:  if there 
//    are a small number of registered CLSIDs in the user hive, we can 
//    enumerate them quickly right now to see if any have Implemented 
//    Categories that apply to the criteria we're searching for.
//    If there are none, we can fall back in that case to just using the 
//    system hive, which will save a lot of time enumerating later on.
//
//--------------------------------------------------------------------
LONG CEnumClassesOfCategories::DecideToUseMergedHive(
                                        HKEY hkeyUserHiveCLSID, 
                                        REGSAM samDesired,
                                        BOOL* pfUseMergedHive)
{
    LONG lResult = 0;
    DWORD dwcSubKeys = 0;
    DWORD dwMaxSubKeyLen = 0;
    const DWORD MAX_CLSID_SUBKEY_THRESHOLD = 50;
	
    lResult = RegQueryInfoKey(hkeyUserHiveCLSID,
                              NULL,
                              NULL,
                              NULL,
                              &dwcSubKeys,
                              &dwMaxSubKeyLen,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
    if (lResult == ERROR_SUCCESS)
    {
    	if (dwcSubKeys >= MAX_CLSID_SUBKEY_THRESHOLD)
        {
            // Too many to bother enumerating, just use the merged user hive
            *pfUseMergedHive = TRUE;
            return ERROR_SUCCESS;
        }

    	// Check each clsid to see 
        DWORD i = 0;
    	DWORD dwKeyNameBufSize = dwMaxSubKeyLen+1;
    	LPWSTR pszSubKey = (LPWSTR)_alloca(sizeof(WCHAR) * (dwKeyNameBufSize+1));

    	for (i = 0; i < dwcSubKeys; i++)
    	{
            HRESULT hr;

            // Reset buf size before every call to RegEnumKeyEx
            dwKeyNameBufSize = dwMaxSubKeyLen+1;
    		
            lResult = RegEnumKeyEx(hkeyUserHiveCLSID,
                                   i,
                                   pszSubKey,
                                   &dwKeyNameBufSize,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);
            if (lResult != ERROR_SUCCESS)
            	return lResult;

            // Defer actual checks to helper function
            hr = CComCat::IsClassOfCategoriesEx(
                                hkeyUserHiveCLSID, 
                                pszSubKey, 
                                m_cImplemented, 
                                m_rgcatidImpl, 
                                m_cRequired, 
                                m_rgcatidReq);
            if ((hr == S_OK) || FAILED(hr))
            {
                // Found a clsid in the user-specific hive that meets the 
                // criteria, or an unexpected error occurred.   Play it 
                // safe and just use the merged hive.
                *pfUseMergedHive = TRUE;
                return ERROR_SUCCESS;
            }
            else
            {
                // The clsid did not meet the user criteria.  Just keep going.
            }
    	}

        //
        // If we made it here, it means that none of the clsids in the user-specific
        // hive meet the criteria specified by the user.  Hence, we don't need to
        // use the merged hive at all.
        //
        *pfUseMergedHive = FALSE;
    }

    return lResult;
}

//+-------------------------------------------------------------------
//
//  Function:   OpenClassesRootSpecial, private
//
//  Synopsis:   This function is basically the same as OpenClassesRootKeyExW
//    but adds some optimization in the case where the requested subkey does not
//    exist in the user hive (basically we fall back on the system hive in that
//    case).   Otherwise the caller may end up thrashing the registry code with 
//    requests to enumerate\open keys that will never, ever, exist in the user
//    hive.   There is also an optimization for the case where the user has
//    a Software\Classes\CLSID subkey in their hive, but none of the contents apply
//    to what we're looking for.  So we fall back on the system hive in that
//    case too.
//
//--------------------------------------------------------------------
LONG CEnumClassesOfCategories::OpenClassesRootSpecial(REGSAM samDesired, HKEY* phkResult)
{
    LONG lResult = ERROR_SUCCESS;
    HANDLE hImpToken = NULL;
    HANDLE hProcToken = NULL;
    HKEY hkcr = NULL;
    BOOL fUserHiveExists = FALSE;

    if(phkResult == NULL)
        return ERROR_INVALID_PARAMETER;

    *phkResult = NULL;
	
    SuspendImpersonate(&hImpToken);

    BOOL fRet = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcToken);
    if (fRet)
    {
        // If the key exists in the user's hive, then we will call RegOpenUserClassesRoot
        // to get a merged view of the user\system hives.  Otherwise we will use
        // just the system hive.
        HKEY hkeyUserHiveCLSID = NULL;
        lResult = OpenKeyFromUserHive(hProcToken, WSZ_CLSID, samDesired, &hkeyUserHiveCLSID);		
        if (lResult != ERROR_SUCCESS)
        {
            CloseHandle(hProcToken);
            ResumeImpersonate(hImpToken);
            return lResult;
        }

      	if (hkeyUserHiveCLSID)
      	{
            // The CLSID key exists in the user hive.  See if we care.
            BOOL fUseMergedHive = TRUE;
            
            lResult = DecideToUseMergedHive(hkeyUserHiveCLSID, samDesired, &fUseMergedHive);

            // We are all done with the user-specific hive key now.
      	    RegCloseKey(hkeyUserHiveCLSID);
      	    hkeyUserHiveCLSID = NULL;
      		
            if (lResult == ERROR_SUCCESS)
            {
                if (fUseMergedHive)
                {
                    // We are going to use the merged hive
                    lResult = RegOpenUserClassesRoot(hProcToken, 0, samDesired, &hkcr);
                    if (lResult == ERROR_SUCCESS)
                    {
                        lResult = RegOpenKeyEx(hkcr,WSZ_CLSID,0,samDesired,phkResult);			
                        RegCloseKey(hkcr);
                        CloseHandle(hProcToken);
                        ResumeImpersonate(hImpToken);
                        return lResult;
                    }
                }
                else
                {
                    // Will continue on to open system hive below
                    CloseHandle(hProcToken);
                }
            }
            else
            {
                CloseHandle(hProcToken);
                ResumeImpersonate(hImpToken);
                return lResult;
            }
        }
    }	
    else
    {
        lResult = GetLastError();
        ResumeImpersonate(hImpToken);
        return lResult;
    }

    //
    // The requested subkey did not exist under the user hive, or does exist
    // but doesn't contain any CLSIDs of interest  (see comments above). Fall 
    // back on the system hive.
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           L"Software\\Classes\\CLSID",
                           0,
                           samDesired,
                           phkResult);

    ResumeImpersonate(hImpToken);

    return lResult;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\src\catfact.cpp ===
#include "windows.h"
#include "ole2.h"
#include "tchar.h"
#include "catobj.h"

CATEGORYINFO g_catids[NUM_OLDKEYS_SUPPORTED] =
{
    {{0x40FC6ED3,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409, L"Embeddable Objects"},
    {{0x40FC6ED4,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409, L"Controls"},
    {{0x40FC6ED5,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"Automation Objects"},
    {{0x40FC6ED8,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"Document Objects"},
    {{0x40FC6ED9,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"_Printable Objects"}
};

extern "C" {
STDAPI ComcatDllRegisterServer(void);
STDAPI ComcatDllUnRegisterServer(void);
}


// Create a new object and return a pointer to it
HRESULT CComCatCF_CreateInstance(IUnknown *pUnkOuter,
                                 REFIID riid, void** ppObject)
{
    HRESULT hr = E_OUTOFMEMORY;

    CComCat* pObj= new CComCat(FALSE);
    if(NULL != pObj)
    {
        hr = pObj->Initialize(pUnkOuter);
        if (SUCCEEDED(hr))
        {
            if (pUnkOuter)
            {
                *ppObject = (LPUNKNOWN)(pObj->m_punkInner);
                pObj->m_punkInner->AddRef();
            }
            else
            {
                hr = pObj->QueryInterface(riid, ppObject);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    return hr;
}

// Create a new object and return a pointer to it, class store
HRESULT CComCatCSCF_CreateInstance(IUnknown *pUnkOuter,
                                 REFIID riid, void** ppObject)
{
    HRESULT hr = E_OUTOFMEMORY;

    CComCat* pObj= new CComCat(TRUE);
    if(NULL != pObj)
    {
        hr = pObj->Initialize(pUnkOuter);
        if (SUCCEEDED(hr))
        {
            if (pUnkOuter)
            {
                *ppObject = (LPUNKNOWN)(pObj->m_punkInner);
                pObj->m_punkInner->AddRef();
            }
            else
            {
                hr = pObj->QueryInterface(riid, ppObject);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    return hr;
}

STDAPI ComcatDllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32,  hKeyComCat;
    DWORD dwDisposition;
    HRESULT hr;
    IClassFactory *pcf = NULL;
    ICatRegister *preg = NULL;

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    _T("CLSID\\{0002E005-0000-0000-C000-000000000046}"),
                    NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS)
    {
            return E_UNEXPECTED;
    }

    if (RegSetValueEx(hKeyCLSID, _T(""), NULL, REG_SZ, (BYTE*) _T("Component Categories Manager"), sizeof(_T("Component Categories Manager")))!=ERROR_SUCCESS)
    {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
    }

    if (RegCreateKeyEx(hKeyCLSID,
                    _T("InprocServer32"),
                    NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS)
    {
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
    }

    TCHAR szName[] = _T("OLE32.DLL");
    if (RegSetValueEx(hKeyInproc32, _T(""), NULL, REG_SZ, (BYTE*) szName, sizeof(TCHAR)*(lstrlen(szName)+1))!=ERROR_SUCCESS)
    {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
    }
    if (RegSetValueEx(hKeyInproc32, _T("ThreadingModel"), NULL, REG_SZ, (BYTE*) _T("Both"), sizeof(_T("Both")))!=ERROR_SUCCESS)
    {
            RegCloseKey(hKeyInproc32);
            RegCloseKey(hKeyCLSID);
            return E_UNEXPECTED;
    }
    RegCloseKey(hKeyInproc32);
    RegCloseKey(hKeyCLSID);

    // RegCreateKeyEx will open the key if it exists
    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                    SZ_COMCAT,
                    NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hKeyComCat, &dwDisposition)!=ERROR_SUCCESS)
    {
            return E_UNEXPECTED;
    }
    RegCloseKey(hKeyComCat);
    hr = DllGetClassObject(CLSID_StdComponentCategoriesMgr, IID_IClassFactory, (void**)&pcf);
    if(FAILED(hr))
            return hr;
    hr = pcf->CreateInstance(NULL, IID_ICatRegister, (void**)&preg);
    pcf->Release();
    if(FAILED(hr))
            return hr;

    hr = preg->RegisterCategories(NUM_OLDKEYS_SUPPORTED, g_catids);
    preg->Release();

    // Adding the WithCS clsid.
    //-----------------------------
	if (RegCreateKeyEx(HKEY_CLASSES_ROOT, 
			_T("CLSID\\{0002E006-0000-0000-C000-000000000046}"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, 
			&hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

	if (RegSetValueEx(hKeyCLSID, _T(""), NULL, REG_SZ, (BYTE*) _T("Component Categories Manager With Class Store"), sizeof(_T("Component Categories Manager With Class Store")))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}

	if (RegCreateKeyEx(hKeyCLSID, 
			_T("InprocServer32"), 
			NULL, _T(""), REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, 
			&hKeyInproc32, &dwDisposition)!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}

    if (RegSetValueEx(hKeyInproc32, _T(""), NULL, REG_SZ, (BYTE*) szName, sizeof(TCHAR)*(lstrlen(szName)+1))!=ERROR_SUCCESS) 
	{
		RegCloseKey(hKeyInproc32);
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}
    if (RegSetValueEx(hKeyInproc32, _T("ThreadingModel"), NULL, REG_SZ, (BYTE*) _T("Both"), sizeof(_T("Both")))!=ERROR_SUCCESS) 
    {
		RegCloseKey(hKeyInproc32);
		RegCloseKey(hKeyCLSID);
		return E_UNEXPECTED;
	}
	RegCloseKey(hKeyInproc32);
	RegCloseKey(hKeyCLSID);

    return hr;
}

STDAPI ComcatDllUnregisterServer(void)
{
    if (RegDeleteKey(HKEY_CLASSES_ROOT,
           _T("CLSID\\{0002E005-0000-0000-C000-000000000046}\\InprocServer32"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }
    if (RegDeleteKey(HKEY_CLASSES_ROOT,
           _T("CLSID\\{0002E005-0000-0000-C000-000000000046}"))!=ERROR_SUCCESS)
    {
        return E_UNEXPECTED;
    }

    // removing clsid withcs

    if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("CLSID\\{0002E006-0000-0000-C000-000000000046}\\InprocServer32"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}
	if (RegDeleteKey(HKEY_CLASSES_ROOT, 
			_T("CLSID\\{0002E006-0000-0000-C000-000000000046}"))!=ERROR_SUCCESS) 
	{
		return E_UNEXPECTED;
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\src\catenum.h ===
#ifndef _COMCATMANAGERENUMS_INCLUDE
#define _COMCATMANAGERENUMS_INCLUDE

#include "comcat.h"

class CEnumCategories : public IEnumCATEGORYINFO
{
public:
	// IUnknown methods
	HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
	ULONG	_stdcall AddRef();
	ULONG	_stdcall Release();

	// IEnumCATEGORYINFO methods
    HRESULT __stdcall Next(ULONG celt, CATEGORYINFO *rgelt, ULONG *pceltFetched);
	HRESULT __stdcall Skip(ULONG celt);
	HRESULT __stdcall Reset(void);
	HRESULT __stdcall Clone(IEnumCATEGORYINFO **ppenum);


	CEnumCategories();
	HRESULT Initialize(LCID lcid, IEnumCATEGORYINFO *pcsIEnumCat);
	~CEnumCategories();
private:

	HKEY m_hKey;
	DWORD m_dwIndex;
	LCID m_lcid;
	IEnumCATEGORYINFO *m_pcsIEnumCat;
	int    m_fromcs;
//	char m_szlcid[10];

	ULONG m_dwRefCount;
};

class CEnumCategoriesOfClass : public IEnumCATID
{
public:
	// IUnknown methods
	HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
	ULONG	_stdcall AddRef();
	ULONG	_stdcall Release();

	// IEnumGUID methods
    HRESULT __stdcall Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched);
	HRESULT __stdcall Skip(ULONG celt);
	HRESULT __stdcall Reset(void);
	HRESULT __stdcall Clone(IEnumGUID **ppenum);


	CEnumCategoriesOfClass();
	HRESULT Initialize(HKEY hKey, BOOL bMapOldKeys);
	~CEnumCategoriesOfClass();

private:
	ULONG m_dwRefCount;

	BOOL	m_bMapOldKeys; // indicates if old keys are mapped

	HKEY	m_hKey;			// HKEY containing the catids ("Implemented" or "Required")
	DWORD	m_dwIndex;		// Index to the current subkey within m_hKey

    HKEY    m_hKeyCats;     // HKEY to Ole Keys in SZ_COMCAT
    DWORD   m_dwOldKeyIndex; // Index into mhKeyCats for old categories

	IUnknown* m_pCloned;	// if cloned: keeps original alive (need m_hkey!)
};

class CEnumClassesOfCategories : public IEnumCATID
{
public:
	// IUnknown methods
	HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
	ULONG	_stdcall AddRef();
	ULONG	_stdcall Release();

	// IEnumGUID methods
    HRESULT __stdcall Next(ULONG celt, GUID *rgelt, ULONG *pceltFetched);
	HRESULT __stdcall Skip(ULONG celt);
	HRESULT __stdcall Reset(void);
	HRESULT __stdcall Clone(IEnumGUID **ppenum);

	CEnumClassesOfCategories();
	HRESULT Initialize(ULONG cImplemented, CATID rgcatidImpl[], ULONG cRequired, 
						CATID rgcatidReq[], IEnumCLSID *pcsIEnumClsid);
	~CEnumClassesOfCategories();

private:
	ULONG m_dwRefCount;

	HKEY	m_hClassKey;	// HKEY to CLSID
	DWORD	m_dwIndex;		// Index to the current CLSID within m_hKey

	ULONG m_cImplemented;
	CATID *m_rgcatidImpl;
	ULONG m_cRequired;
	CATID *m_rgcatidReq;

	IEnumCLSID *m_pcsIEnumClsid;
	int         m_fromcs;

	IUnknown* m_pCloned;	// if cloned: keeps original alive (need m_hkey!)

	LONG DecideToUseMergedHive(HKEY hkeyUserHiveCLSID, 
                               REGSAM samDesired,
                               BOOL* pfUseMergedHive);

	LONG OpenKeyFromUserHive(HANDLE hToken, 
                                   LPCWSTR pszSubKey, 
                                   REGSAM samDesired,
                                   HKEY* phKeyInUserHive);

	LONG OpenClassesRootSpecial(REGSAM samDesired, HKEY* phkResult);

};

extern ULONG g_dwRefCount;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by comcat.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\src\cscatinf.cpp ===
#include <windows.h>
#include <ole2.h>
#include <malloc.h>
#include <ole2sp.h>

#include "catobj.h"

#define MAXCLASSSTORES  1

CsCatInfo::CsCatInfo()
{
   m_uRefs = 1; // no addref required after new
   m_cCalls = 0;
   m_cICatInfo = 0;
   m_pICatInfo = 0;
   m_hInstCstore = NULL;
}

CsCatInfo::~CsCatInfo()
{
   DWORD i;

   for (i = 0; i < m_cICatInfo; i++) {
      m_pICatInfo[i]->Release();
   }

   if (m_hInstCstore)
      FreeLibrary (m_hInstCstore);

   CoTaskMemFree(m_pICatInfo);
}

HRESULT CsCatInfo::QueryInterface(REFIID iid, void **ppv)
{
   if (iid==IID_ICatInformation) {
      *ppv = (ICatInformation *)this;
   }
   else {
      *ppv = NULL;
      return E_NOINTERFACE;
   }
   AddRef();
   return S_OK;
}

ULONG CsCatInfo::AddRef()
{
   return InterlockedIncrement((long *)&m_uRefs);
}

ULONG CsCatInfo::Release()
{
   ULONG dwRefCount = InterlockedDecrement((long *)&m_uRefs);
   if (dwRefCount==0) {
      delete this;
   }
   return dwRefCount;
}

//-----------------------------------------------------------
// This code is repeated in all the following functions.
// Be very careful when modifying this and when changing any of the functions
// below. NOTICE that there is impersonation being done in this MACRO*****
//
#define MACAvailCStoreLOOP                                                      \
    for (i=0; i < m_cICatInfo; i++)                                                     \
    {

//-------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CsCatInfo::EnumCategories(
         LCID lcid,
         IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT                              hr=S_OK;
    ULONG                                i;
    IEnumCATEGORYINFO                   *Enum[MAXCLASSSTORES];
    ULONG                                cEnum = 0;
    CSCMergedEnum<IEnumCATEGORYINFO, CATEGORYINFO> *EnumMerged = NULL;

    *ppenumCategoryInfo = NULL;

    //
    // Get the list of Class Stores for this user
    //

    MACAvailCStoreLOOP
        //
        // Call method on this store
        //
        hr = m_pICatInfo[i]->EnumCategories(lcid, &(Enum[cEnum]));

        if (hr == E_INVALIDARG)
        {
            return hr;
        }

        if (SUCCEEDED(hr))
            cEnum++;
    }

    hr = E_OUTOFMEMORY;
    EnumMerged = new CSCMergedEnum<IEnumCATEGORYINFO, CATEGORYINFO>(IID_IEnumCATEGORYINFO);    
    if (EnumMerged)
    {
        hr = EnumMerged->Initialize(Enum, cEnum);
    }

    if (FAILED(hr))
    {
        for (i = 0; i < cEnum; i++)
            Enum[i]->Release();

        if (EnumMerged)
            delete EnumMerged;
    }
    else
    {
        hr = EnumMerged->QueryInterface(IID_IEnumCATEGORYINFO, (void **)ppenumCategoryInfo);
        if (FAILED(hr))
            delete EnumMerged;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CsCatInfo::EnumClassesOfCategories(
         ULONG                           cImplemented,
         CATID __RPC_FAR                 rgcatidImpl[  ],
         ULONG                           cRequired,
         CATID __RPC_FAR                 rgcatidReq[  ],
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT              hr;
    ULONG                i;
    IEnumGUID           *Enum[MAXCLASSSTORES];
    ULONG                cEnum = 0;
    CSCMergedEnum<IEnumGUID, CLSID>  *EnumMerged=NULL;

    MACAvailCStoreLOOP
        hr = m_pICatInfo[i]->EnumClassesOfCategories(
                                    cImplemented, rgcatidImpl, cRequired,
                                    rgcatidReq, &(Enum[cEnum]));

        if (hr == E_INVALIDARG)
        {
            return hr;
        }

        if (SUCCEEDED(hr))
            cEnum++;
    }

	hr = E_OUTOFMEMORY;
    EnumMerged = new CSCMergedEnum<IEnumGUID, CLSID>(IID_IEnumCLSID);
    if (EnumMerged)
    {
	    hr = EnumMerged->Initialize(Enum, cEnum);
    }

    if (FAILED(hr))
    {
        for (i = 0; i < cEnum; i++)
            Enum[i]->Release();

        if (EnumMerged)
            delete EnumMerged;
    }
    else
    {
        hr = EnumMerged->QueryInterface(IID_IEnumCLSID, (void **)ppenumClsid);
        if (FAILED(hr))
            delete EnumMerged;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CsCatInfo::GetCategoryDesc(
         REFCATID rcatid,
         LCID lcid,
         LPWSTR __RPC_FAR *pszDesc)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT    hr, return_hr=CAT_E_CATIDNOEXIST;
    ULONG      i;

    //
    // Get the list of Class Stores for this user
    //

    MACAvailCStoreLOOP
        hr = m_pICatInfo[i]->GetCategoryDesc(rcatid, lcid, pszDesc);

        if ((hr == E_INVALIDARG) || (SUCCEEDED(hr)))
        {
            return hr;
        }

        if (hr == CAT_E_NODESCRIPTION)
            return_hr = CAT_E_NODESCRIPTION;
    }
    return return_hr;
}


HRESULT STDMETHODCALLTYPE CsCatInfo::IsClassOfCategories(
         REFCLSID rclsid,
         ULONG cImplemented,
         CATID __RPC_FAR rgcatidImpl[  ],
         ULONG cRequired,
         CATID __RPC_FAR rgcatidReq[  ])
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr;
    ULONG               i;

    MACAvailCStoreLOOP
        hr = m_pICatInfo[i]->IsClassOfCategories(
                        rclsid, cImplemented, rgcatidImpl, cRequired,
                        rgcatidReq);

        if ((hr == E_INVALIDARG) || (SUCCEEDED(hr)))
        {
            return hr;
        }
    }

    return CS_E_CLASS_NOTFOUND;
}


HRESULT STDMETHODCALLTYPE CsCatInfo::EnumImplCategoriesOfClass(
         REFCLSID rclsid,
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr;
    ULONG               i;

    MACAvailCStoreLOOP
        hr = m_pICatInfo[i]->EnumImplCategoriesOfClass(
                            rclsid, ppenumCatid);

        if ((hr == E_INVALIDARG) || (SUCCEEDED(hr)))
        {
            return hr;
        }
    }

    return CS_E_CLASS_NOTFOUND;
}

HRESULT STDMETHODCALLTYPE CsCatInfo::EnumReqCategoriesOfClass(
         REFCLSID rclsid,
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid)
{
    //
    // Assume that this method is called in the security context
    // of the user process. Hence there is no need to impersonate.
    //

    //
    // Get the list of Class Stores for this user
    //
    HRESULT             hr;
    ULONG               i;

    MACAvailCStoreLOOP
        hr = m_pICatInfo[i]->EnumReqCategoriesOfClass(
                            rclsid, ppenumCatid);

        if ((hr == E_INVALIDARG) || (SUCCEEDED(hr)))
        {
            return hr;
        }
    }

    return CS_E_CLASS_NOTFOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\src\cscatinf.h ===
class CsCatInfo :
        public ICatInformation
{
public:
  CsCatInfo(void);
  ~CsCatInfo(void);

  // IUnknown
  HRESULT __stdcall QueryInterface(
            REFIID  iid,
            void ** ppv );
  ULONG __stdcall AddRef();
  ULONG __stdcall Release();

// ICatInformation interfaces.---------------------------------------
  HRESULT STDMETHODCALLTYPE EnumCategories(
         LCID lcid,
         IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);

  HRESULT STDMETHODCALLTYPE GetCategoryDesc(
         REFCATID rcatid,
         LCID lcid,
         LPWSTR __RPC_FAR *pszDesc);

  HRESULT STDMETHODCALLTYPE EnumClassesOfCategories(
         ULONG cImplemented,
         CATID __RPC_FAR rgcatidImpl[  ],
         ULONG cRequired,
         CATID __RPC_FAR rgcatidReq[  ],
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);

  HRESULT STDMETHODCALLTYPE IsClassOfCategories(
         REFCLSID rclsid,
         ULONG cImplemented,
         CATID __RPC_FAR rgcatidImpl[  ],
         ULONG cRequired,
         CATID __RPC_FAR rgcatidReq[  ]);

  HRESULT STDMETHODCALLTYPE EnumImplCategoriesOfClass(
         REFCLSID rclsid,
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);

  HRESULT STDMETHODCALLTYPE EnumReqCategoriesOfClass(
         REFCLSID rclsid,
         IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);

//---------------------------------------------------------------------

protected:
     unsigned long     m_uRefs;
     unsigned long     m_cCalls;
     ICatInformation ** m_pICatInfo;
     unsigned long    m_cICatInfo;
     HINSTANCE          m_hInstCstore;
};


// enumerator classes for the merged enumerators.

template<class ENUM, class RetType>
class CSCMergedEnum : public ENUM
{
private:
    ENUM               **m_pcsEnum;
    ULONG                m_cTotalEnum;
    ULONG                m_dwRefCount;
    ULONG                m_CurrentEnum;
    IID                  m_myiid;

public:
    CSCMergedEnum(IID myIID)
       :m_myiid(myIID)
    {
        m_pcsEnum = NULL;
        m_cTotalEnum = 0;
        m_CurrentEnum = 0;
        m_dwRefCount = 0;
    }
    
    ~CSCMergedEnum()
    {
        ULONG    i;
        for (i = 0; i < m_cTotalEnum; i++)
            m_pcsEnum[i]->Release();
        CoTaskMemFree(m_pcsEnum);
    }
    
    HRESULT  __stdcall  QueryInterface(REFIID riid,
                            void  * * ppObject)
    {
        *ppObject = NULL;
        if ((riid==IID_IUnknown) || (riid==m_myiid))
        {
            *ppObject=(ENUM *) this;
        }
        else
        {
            return E_NOINTERFACE;
        }
        AddRef();
        return S_OK;
    }
    
    ULONG  __stdcall  AddRef()
    {
        InterlockedIncrement((long*) &m_dwRefCount);
        return m_dwRefCount;
    }
    
    ULONG  __stdcall Release()
    {
        ULONG dwRefCount;
        if ((dwRefCount = InterlockedDecrement((long*) &m_dwRefCount))==0)
        {
            delete this;
            return 0;
        }
        return dwRefCount;
    }
    
    HRESULT  __stdcall Next(
            ULONG             celt,
            RetType          *rgelt,
            ULONG            *pceltFetched)
    {
        ULONG count=0, total = 0;
        HRESULT hr;
        BOOL fImpersonating;
            
        fImpersonating = (RpcImpersonateClient( NULL ) == RPC_S_OK);

        for (; m_CurrentEnum < m_cTotalEnum; m_CurrentEnum++)
        {
	        count = 0;
	        hr = m_pcsEnum[m_CurrentEnum]->Next(celt, rgelt+total, &count);	    
	        if (hr == E_INVALIDARG)
	        {
	            if (fImpersonating) 
	                RevertToSelf();
	            return hr;
	        }
	    
	        total += count;
	        celt -= count;
	    
	        if (!celt)
	            break;
        }

        if (pceltFetched)
            *pceltFetched = total;

        if (fImpersonating)
            RevertToSelf();
            
        if (!celt)
            return S_OK;
        return S_FALSE;
    }
    
    HRESULT  __stdcall Skip(
            ULONG             celt)
    {
        RetType *dummy;
        ULONG count=0, total = 0;
        HRESULT    hr = S_OK;
            BOOL fImpersonating;

        dummy = new RetType[celt];
        if (!dummy)
            return E_OUTOFMEMORY;
    
        fImpersonating = (RpcImpersonateClient( NULL ) == RPC_S_OK);

        for (; m_CurrentEnum < m_cTotalEnum; m_CurrentEnum++)
        {
	        count = 0;
	        hr = m_pcsEnum[m_CurrentEnum]->Next(celt, dummy+total, &count);	    
	        if (hr == E_INVALIDARG)
	        {
	            delete[] dummy;
	            if (fImpersonating) 
	                RevertToSelf();
	            return hr;
	        }
	    
	        total += count;
	        celt -= count;
	    
	        if (!celt)
	            break;
        }

        delete[] dummy;

        if (fImpersonating) 
            RevertToSelf();

        if (!celt)
            return S_OK;

        return S_FALSE;
    }
    
    HRESULT  __stdcall Reset()
    {
        ULONG i;
        BOOL fImpersonating;

        fImpersonating = (RpcImpersonateClient( NULL ) == RPC_S_OK);
            
        for (i = 0; ((i <= m_CurrentEnum) && (i < m_cTotalEnum)); i++)
        	m_pcsEnum[i]->Reset(); // ignoring all error values
        	
        m_CurrentEnum = 0;

        if (fImpersonating) 
            RevertToSelf();

        return S_OK;
    }
    
    HRESULT  __stdcall Clone(ENUM **ppenum)
    {
        ULONG i;
        CSCMergedEnum<ENUM, RetType> *pClone;
        ENUM **pcsEnumCloned = (ENUM **)CoTaskMemAlloc(sizeof(ENUM *)*m_cTotalEnum);
        BOOL fImpersonating;

        if (!pcsEnumCloned)
            return E_OUTOFMEMORY;
        
        pClone = new CSCMergedEnum<ENUM, RetType>(m_myiid);
        if (!pClone)
        {
            CoTaskMemFree(pcsEnumCloned);
            return E_OUTOFMEMORY;
        }

        fImpersonating = (RpcImpersonateClient( NULL ) == RPC_S_OK);

        for ( i = 0; i < m_cTotalEnum; i++)
            m_pcsEnum[i]->Clone(pcsEnumCloned+i);
    
        pClone->Initialize(pcsEnumCloned, m_cTotalEnum);
        pClone->m_CurrentEnum = m_CurrentEnum;

        *ppenum = (ENUM *)pClone;
        pClone->AddRef();

        if (fImpersonating)
            RevertToSelf();

        CoTaskMemFree(pcsEnumCloned);
        return S_OK;
    }
    
    HRESULT  Initialize(ENUM **pcsEnum, ULONG cEnum)
    {
        ULONG i;

        m_CurrentEnum = 0;
        m_pcsEnum = (ENUM **)CoTaskMemAlloc(sizeof(ENUM *)*cEnum);
        if (!m_pcsEnum)
            return E_OUTOFMEMORY;

        for (i = 0; i < cEnum; i++)
        {
            m_pcsEnum[i] = pcsEnum[i];
        }
        m_cTotalEnum = cEnum;
        return S_OK;
	}			     	
};



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\src\guids.cpp ===
#define INITGUID
#include "objbase.h"

#include "comcat.h"

#if 0
const IID IID_IEnumGUID = {0x0002E000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const IID IID_IEnumCATEGORYINFO = {0x0002E011,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const IID IID_ICatRegister = {0x0002E012,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const IID IID_ICatInformation = {0x0002E013,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
#endif

const CLSID CLSID_StdComponentCategoriesMgr = {0x0002E005,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const CLSID CLSID_GblComponentCategoriesMgr = {0x0002E006,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const CATID CATID_Insertable            = {0x40FC6ED3,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_Control               = {0x40FC6ED4,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_Programmable          = {0x40FC6ED5,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_DocObject             = {0x40FC6ED8,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_Printable             = {0x40FC6ED9,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};

/*
const CATID CATID_IsShortcut            = {0x40FC6ED6,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_NeverShowExt          = {0x40FC6ED7,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}};
const CATID CATID_RequiresDataPathHost  = {0x0de86a50,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToMoniker     = {0x0de86a51,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToStorage     = {0x0de86a52,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToStreamInit  = {0x0de86a53,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToStream      = {0x0de86a54,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToMemory      = {0x0de86a55,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToFile        = {0x0de86a56,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
const CATID CATID_PersistsToPropertyBag = {0x0de86a57,0x2baa,0x11cf,{0xa2,0x29,0x00,0xaa,0x00,0x3d,0x73,0x52}};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\src\catobj.h ===
#ifndef _COMCATMANAGER_INCLUDE
#define _COMCATMANAGER_INCLUDE

#include "comcat.h"
#include "cscatinf.h"

#define NUM_OLDKEYS_SUPPORTED 5 // gd

class CComCat : public ICatRegister, public ICatInformation
{
public:
    // IUnknown methods
    HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    // ICatRegister methods
    HRESULT __stdcall RegisterCategories(ULONG cCategories, CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);
    HRESULT __stdcall UnRegisterCategories(ULONG cCategories, CATID __RPC_FAR rgcatid[  ]);
    HRESULT __stdcall RegisterClassImplCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ]);
    HRESULT __stdcall UnRegisterClassImplCategories(REFCLSID rclsid, ULONG cCategories, CATID rgcatid[  ]);
    HRESULT __stdcall RegisterClassReqCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ]);
    HRESULT __stdcall UnRegisterClassReqCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ]);

    // ICatInformation methods
    HRESULT __stdcall EnumCategories(LCID lcid, IEnumCATEGORYINFO **ppenumCategoryInfo);
    HRESULT __stdcall GetCategoryDesc(REFCATID rcatid, LCID lcid, LPOLESTR *ppszDesc);
    HRESULT __stdcall EnumClassesOfCategories(ULONG cImplemented, CATID rgcatidImpl[], ULONG cRequired, CATID rgcatidReq[], IEnumGUID **ppenumClsid);
    HRESULT __stdcall IsClassOfCategories(REFCLSID rclsid, ULONG cImplemented, CATID __RPC_FAR rgcatidImpl[  ], ULONG cRequired, CATID __RPC_FAR rgcatidReq[  ]);
    HRESULT __stdcall EnumImplCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid);
    HRESULT __stdcall EnumReqCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid);

    static HRESULT IsClassOfCategoriesEx(HKEY hkeyHKCRClsid, WCHAR *pwszCLSID, ULONG cImplemented, CATID __RPC_FAR rgcatidImpl[  ], ULONG cRequired, CATID __RPC_FAR rgcatidReq[  ]);

    static HRESULT GetCategoryDesc(HKEY hKey, LCID lcid, LPOLESTR *ppszDesc, PLCID plcid);

    friend HRESULT CComCatCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppObject);
    friend HRESULT CComCatCSCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppObject);

private:

    // Helper methods
    static HRESULT GetKeyForReading(REFCLSID rclsid, HKEY* phKey);
    static HRESULT EnumCategoriesOfClass(REFCLSID rclsid, LPCTSTR lpszSubKey, BOOL bMapOldKeys, IEnumGUID **ppenumCatid);

    HRESULT RegisterClassXXXCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ], LPCWSTR szImplReq);
    HRESULT UnRegisterClassXXXCategories(REFCLSID rclsid, ULONG cCategories, CATID rgcatid[  ],LPCWSTR szImplReq);
    HRESULT StringConvert(LPTSTR, LPCWSTR, LPCWSTR);
    static HRESULT ConvertStringToLCID(LCID* newlcid,LPTSTR szLCID);

    HRESULT GetCsCatInfo();

    CComCat(BOOL CsFlag);
    HRESULT Initialize(IUnknown* punkOuter);
    ~CComCat();

    class CInnerUnk : public IUnknown
    {
    public:
        // IUnknown methods
        HRESULT _stdcall QueryInterface(REFIID riid, void** ppObject);
        ULONG   _stdcall AddRef();
        ULONG   _stdcall Release();

        CInnerUnk(CComCat* pObj);

        CComCat* m_pObj;
    } *m_punkInner;


    friend CInnerUnk;

    IUnknown        *m_punkOuter;
    ICatInformation *m_pcsICatInfo;
                    // CS ICatinfo pointer

    CRITICAL_SECTION m_csCatInfoInit;
    ULONG m_dwRefCount;
    BOOL  m_fCsFlag;
    BOOL  m_bLockValid;
};

extern const WCHAR* WSZ_CLSID;
extern const TCHAR* SZ_COMCAT;
extern const WCHAR* WSZ_IMPLCAT;
extern const WCHAR* WSZ_REQCAT;
extern const TCHAR* SZ_OLDKEY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\comcat\src\comcat.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <malloc.h>
#include <ole2sp.h>
#include <reghelp.hxx>

#include "catobj.h"
#include "tchar.h"

#include "catenum.h"
#include "valid.h"

#define CATID_SIZE 40

#define KEY_STRING_IMPL_CHARS (sizeof("Implemented Categories\\")-1)
#define KEY_STRING_REQ_CHARS (sizeof("Required Categories\\")-1)

#define KEY_STRING_IMPL_CHARS_2 (sizeof("{00000000-0000-0000-0000-000000000000}\\Implemented Categories\\")-1)
#define KEY_STRING_CLSID_CHARS  (sizeof("{00000000-0000-0000-0000-000000000000}\\")-1)

const WCHAR *WSZ_CLSID = L"CLSID";
const TCHAR *SZ_COMCAT = _T("Component Categories");
const WCHAR *WSZ_IMPLCAT = L"Implemented Categories";
const WCHAR *WSZ_REQCAT = L"Required Categories";
const TCHAR *SZ_OLDKEY = _T("OldKey");

CATEGORYINFO g_oldkeyinfo[NUM_OLDKEYS_SUPPORTED] =
                {
                        {{0x40FC6ED3,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409, L"Insertable"},
                        {{0x40FC6ED4,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409, L"Control"},
                        {{0x40FC6ED5,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"Programmable"},
                        {{0x40FC6ED8,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"DocObject"},
                        {{0x40FC6ED9,0x2438,0x11cf,{0xA3,0xDB,0x08,0x00,0x36,0xF1,0x25,0x02}},0x409,L"Printable"}
                };

CComCat::CComCat(BOOL CsFlag)
{
    m_dwRefCount=0;
    m_punkInner=NULL;
    m_punkOuter=NULL;
    m_pcsICatInfo = NULL;
    m_fCsFlag = CsFlag;
    m_bLockValid = FALSE;
}

HRESULT CComCat::Initialize(IUnknown* punkOuter)
{
    if (m_fCsFlag)
    {
        LONG status = RtlInitializeCriticalSection(&m_csCatInfoInit);
        if (!NT_SUCCESS(status))
            return E_OUTOFMEMORY;
        m_bLockValid = TRUE;
    }
    
    m_punkInner = new CInnerUnk(this);
    //m_punkInner = pObj;
    if (NULL == m_punkInner)
    {
        return E_OUTOFMEMORY;
    }
    
    if (punkOuter)
    {
        m_punkOuter=punkOuter;
    }
    else
    {
        m_punkOuter= m_punkInner;
    }
    
    return S_OK;
}

CComCat::~CComCat()
{
    if (NULL != m_punkInner)
    {
        delete m_punkInner;
    }
    
    if (m_fCsFlag && m_bLockValid)
        DeleteCriticalSection(&m_csCatInfoInit);
    
    if (m_pcsICatInfo)
        m_pcsICatInfo->Release();
}

HRESULT CComCat::QueryInterface(REFIID riid, void** ppObject) {
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        return m_punkOuter->QueryInterface(riid, ppObject);
}

ULONG CComCat::AddRef()
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return 0;
        }
        return m_punkOuter->AddRef();
}

ULONG CComCat::Release()
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return 0;
        }
        return m_punkOuter->Release();
}

CComCat::CInnerUnk::CInnerUnk(CComCat* pObj)
{
        m_pObj=pObj;
}

STDMETHODIMP CComCat::CInnerUnk::QueryInterface(REFIID riid, void** ppObject)
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (riid==IID_IUnknown)
        {
                *ppObject=m_pObj->m_punkInner;
                m_pObj->m_punkInner->AddRef(); // So that when called by run time (QI, then Release) we don't die
                return S_OK;
        }
        else if(riid==IID_ICatRegister)
        {
                *ppObject=(ICatRegister*) m_pObj;
        }
        else if (riid==IID_ICatInformation)
        {
                *ppObject=(ICatInformation*) m_pObj;
        }
        else
        {
                *ppObject = NULL;
                return E_NOINTERFACE;
        }
        m_pObj->AddRef();
        return S_OK;
}

STDMETHODIMP_(ULONG) CComCat::CInnerUnk::AddRef()
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return 0;
        }
        return InterlockedIncrement((long*) &m_pObj->m_dwRefCount);
}

STDMETHODIMP_(ULONG) CComCat::CInnerUnk::Release()
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return 0;
        }
        ULONG dwRefCount= InterlockedDecrement((long*) &m_pObj->m_dwRefCount);
        if (dwRefCount==0)
        {
                delete m_pObj;
                return 0;
        }
        return dwRefCount;
}

// ICatRegister methods
HRESULT CComCat::RegisterCategories(ULONG cCategories, CATEGORYINFO __RPC_FAR rgCategoryInfo[  ])
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(rgCategoryInfo, sizeof(rgCategoryInfo[0])*cCategories))
        {
                return E_INVALIDARG; // gd
        }

    HRESULT hr = S_OK;
    char szlcid[16];
    WCHAR wszcatid[CATID_SIZE];
    HKEY hkey, hkeyCat;
    LONG        lRet;

        // RegCreateKeyEx will open the key if it exists
        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CLASSES_ROOT, SZ_COMCAT, 0, 0, 0, KEY_WRITE, NULL, &hkey, NULL))
        {
                return S_FALSE;
        }

        for (ULONG nIndex=0; nIndex<cCategories; nIndex++)
        {
                // Stringize lcid
                wsprintfA(szlcid, "%lX", rgCategoryInfo[nIndex].lcid);

                // Stringize catid
                if (0 == StringFromGUID2(rgCategoryInfo[nIndex].catid, wszcatid, CATID_SIZE))
                {
                        hr = E_OUTOFMEMORY;
                break;
            }

#ifdef UNICODE
//              if (g_bUnicodeAPIs)
                        lRet = RegCreateKeyExW(hkey, wszcatid, 0,0,0, KEY_WRITE, NULL, &hkeyCat, NULL);
#else
//              else
                {
                        char *pszcatid = NULL;
                        int cch = WideCharToMultiByte(CP_ACP, 0, wszcatid, -1, NULL, 0, NULL, NULL);
                        if(cch)
                        {
//                              pszcatid = new char[cch+1];
                                pszcatid = (char *)alloca(cch+1);
//                              if(NULL == pszcatid)
//                              {
//                                      RegCloseKey(hkey);
//                                      hr = E_OUTOFMEMORY;
//                                      break;
//                              }

                                WideCharToMultiByte(CP_ACP, 0, wszcatid, -1, pszcatid, cch+1, NULL, NULL);
                                lRet = RegCreateKeyExA(hkey, pszcatid, 0,0,0, KEY_WRITE, NULL, &hkeyCat, NULL);
//                              delete [] pszcatid;
                        }
                }
#endif
                if (lRet != ERROR_SUCCESS)
                {
                        hr = S_FALSE;
                break;
            }

                // RegSetValueEx overwrites only the value specified.
#ifdef UNICODE
//              if (g_bUnicodeAPIs)
//              {
                        WCHAR wszlcid[50];
                        MultiByteToWideChar(CP_ACP, 0, szlcid, -1, wszlcid, sizeof(wszlcid) / sizeof(WCHAR));
                lRet = RegSetValueExW(hkeyCat, wszlcid, 0, REG_SZ, (LPBYTE) rgCategoryInfo[nIndex].szDescription, (lstrlenW(rgCategoryInfo[nIndex].szDescription)+1)*2);
//              }
#else
//              else
//              {
                    int cch = WideCharToMultiByte(CP_ACP, 0, rgCategoryInfo[nIndex].szDescription, -1, NULL, 0, NULL, NULL);
//                      char *pszDesc = new char[cch+1];
                        char *pszDesc = (char *)alloca(cch+1);
                if (pszDesc != NULL)
                    {
                                WideCharToMultiByte(CP_ACP, 0, rgCategoryInfo[nIndex].szDescription, -1, pszDesc, cch+1, NULL, NULL);
                                lRet = RegSetValueExA(hkeyCat, szlcid, 0, REG_SZ, (LPBYTE) pszDesc, lstrlenA(pszDesc)+1);
//                              delete []pszDesc;
                }
//                  else
//                  {
//                              hr = E_OUTOFMEMORY;
//                              break;
//                      }
//              }
#endif
                RegCloseKey(hkeyCat);
                if (lRet != ERROR_SUCCESS)
                {
                        hr = S_FALSE;
                    break;
                }
        }
        RegCloseKey(hkey);
        return hr;
}

LONG RecursiveRegDeleteKey(HKEY hParentKey, LPSTR szKeyName)
{
    DWORD   dwIndex = 0L;
    char    szSubKeyName[256];
    HKEY    hCurrentKey = NULL;
    DWORD   dwResult;

    if ((dwResult = RegOpenKeyExA(hParentKey, szKeyName, 0, KEY_ALL_ACCESS, &hCurrentKey)) ==
            ERROR_SUCCESS)
    {
        // Remove all subkeys of the key to delete
        while ((dwResult = RegEnumKeyA(hCurrentKey, 0, szSubKeyName, 255)) ==
                ERROR_SUCCESS)
        {
            if ((dwResult = RecursiveRegDeleteKey(hCurrentKey,
                szSubKeyName)) != ERROR_SUCCESS)
                break;
        }

        // If all went well, we should now be able to delete the requested key
        if ((dwResult == ERROR_NO_MORE_ITEMS) || (dwResult == ERROR_BADKEY))
        {
            dwResult = RegDeleteKeyA(hParentKey, szKeyName);
        }
        RegCloseKey(hCurrentKey);
    }

    return ERROR_SUCCESS;
}

HRESULT CComCat::UnRegisterCategories(ULONG cCategories, CATID __RPC_FAR rgcatid[  ])
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories))
        {
                return E_INVALIDARG;
        }

    ULONG nIndex;
    DWORD rc  = NOERROR;
    WCHAR wszcatid[CATID_SIZE];
    char szKey[_MAX_PATH];
        for (nIndex=0; nIndex<cCategories; nIndex++)
        {
        // Stringize catid. not a good return value, but this error will
    // never happen.
        if (0 == StringFromGUID2(rgcatid[nIndex], wszcatid, CATID_SIZE))        //yq
            return E_OUTOFMEMORY;
#ifdef UNICODE
        wsprintfA(szKey, "%S\\%S", SZ_COMCAT, wszcatid);
#else
                wsprintfA(szKey, "%s\\%S", SZ_COMCAT, wszcatid);
#endif
        // RegDeleteKey is not recursive (on NT)
        rc = RecursiveRegDeleteKey(HKEY_CLASSES_ROOT, szKey);
        if (rc != ERROR_SUCCESS)
           break;
        }
        return HRESULT_FROM_WIN32(rc);
}

// convert between ANSI and UNICODE
HRESULT CComCat::StringConvert(LPTSTR szKey, LPCWSTR wszguid, LPCWSTR szImplReq)
{
#ifdef UNICODE   //gd
        wsprintf(szKey, _T("%s\\%s\\%s"), WSZ_CLSID, wszguid, szImplReq); //gd
#else
        // %S converts from unicode
    wsprintf(szKey, _T("%S\\%S\\%S"), WSZ_CLSID, wszguid, szImplReq);
#endif

        return S_OK;
}

// Internal method to handle both Impl and Req variations.
HRESULT CComCat::RegisterClassXXXCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ], LPCWSTR szImplReq)
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(&rclsid, sizeof(rclsid)))
        {
                return E_INVALIDARG;
        }
        if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories))
        {
                return E_INVALIDARG;
        }

    WCHAR wszclsid[CATID_SIZE];
    WCHAR wszguid[CATID_SIZE];
    TCHAR szCatKey[_MAX_PATH];
    DWORD rc ;
    HRESULT hr = S_OK;
    HKEY  hkCatKey;
    HKEY  hKey;
        ULONG nIndex;

        if(0 == cCategories)            //gd
                return S_OK;
    // Stringize clsid
    if (0 == StringFromGUID2(rclsid, wszclsid, CATID_SIZE))     //yq
        return E_OUTOFMEMORY;

#ifdef UNICODE
                wsprintf(szCatKey, _T("%s\\%s"), WSZ_CLSID, wszclsid);
#else
                wsprintf(szCatKey, _T("%S\\%S"), WSZ_CLSID, wszclsid);
#endif

        // HKCR\CLSID\{rclsid} need to exist first.
    if (ERROR_SUCCESS != (rc = RegCreateKeyEx(HKEY_CLASSES_ROOT, szCatKey, 0, NULL, 0, KEY_WRITE,NULL, &hkCatKey, NULL)))
    {
        return HRESULT_FROM_WIN32(rc) ;
    }
    RegCloseKey(hkCatKey);



        StringConvert((LPTSTR)szCatKey,wszclsid,szImplReq);

    // HKCR\CLSID\{...rclsid...}\Impl/Required Categories =
    // RegCreateKeyEx will open the key if it exists
    if (ERROR_SUCCESS != (rc = RegCreateKeyEx(HKEY_CLASSES_ROOT, szCatKey, 0, NULL, 0, KEY_WRITE, NULL, &hkCatKey, NULL)))
    {
        return HRESULT_FROM_WIN32(rc) ;
    }

        for (nIndex=0; nIndex<cCategories; nIndex++)
        {
        // check for oldkey type
                for(int i=0;i<NUM_OLDKEYS_SUPPORTED;i++)
                {
                        if(IsEqualGUID(rgcatid[nIndex], g_oldkeyinfo[i].catid))
                        {
                                // we're dealing with oldkey
                                TCHAR szCatKeyOld[_MAX_PATH];
                                StringConvert((LPTSTR)szCatKeyOld,wszclsid,g_oldkeyinfo[i].szDescription);
                                if (ERROR_SUCCESS != (rc = RegCreateKeyEx(HKEY_CLASSES_ROOT, szCatKeyOld, 0, NULL, 0, KEY_READ, NULL, &hKey, NULL)))
                                {
                                        hr= HRESULT_FROM_WIN32(rc);
                                        break;
                                }
                                RegCloseKey(hKey);
                                break;
                        }
                }
                // Stringize rgcatid[nIndex]
        if (0 == StringFromGUID2(rgcatid[nIndex], wszguid, sizeof(wszguid)/sizeof(TCHAR))) //yq
        {
            hr = E_OUTOFMEMORY;
                        break ; // throw
        }
                TCHAR szCat[_MAX_PATH];
#ifdef UNICODE
                wsprintf(szCat, _T("%s\\%s"), szCatKey, wszguid);
#else
                wsprintf(szCat, _T("%s\\%S"), szCatKey, wszguid);
#endif
        // HKCR\CLSID\{...rclsid...}\Impl/Required Categories\{...rgcatid[nIndex]...} =
        if (ERROR_SUCCESS != (rc = RegCreateKeyEx(HKEY_CLASSES_ROOT, szCat, 0, NULL, 0, KEY_WRITE, NULL, &hKey, NULL)))
        {
                hr = HRESULT_FROM_WIN32(rc);
            break;
        }
        RegCloseKey(hKey);
        }

    RegCloseKey(hkCatKey);
        return hr;
}

HRESULT CComCat::RegisterClassImplCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ])
{
    return RegisterClassXXXCategories(rclsid, cCategories, rgcatid, WSZ_IMPLCAT);
}

HRESULT CComCat::UnRegisterClassXXXCategories(REFCLSID rclsid, ULONG cCategories, CATID rgcatid[  ],LPCWSTR szImplReq)
{
        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(&rclsid, sizeof(rclsid)))
        {
                return E_INVALIDARG;
        }
        if (!IsValidReadPtrIn(rgcatid, sizeof(rgcatid[0])*cCategories))
        {
                return E_INVALIDARG;
        }

    WCHAR wszclsid[CATID_SIZE];
    WCHAR wszguid[CATID_SIZE];
    TCHAR szCatKey[_MAX_PATH];
    DWORD rc;
    HKEY  hkCatKey;

    // Stringize clsid
    if (0 == StringFromGUID2(rclsid, wszclsid, CATID_SIZE)) //yq
        return E_OUTOFMEMORY;
    StringConvert((LPTSTR)szCatKey,wszclsid,szImplReq);

    // HKCR\CLSID\{...rclsid...}\Impl/Required Categories =
    // RegOpenKeyEx will open the key if it exists
    rc = RegOpenKeyEx(HKEY_CLASSES_ROOT, szCatKey, 0, KEY_ALL_ACCESS, &hkCatKey);
    if (ERROR_SUCCESS != rc)
    {
        return HRESULT_FROM_WIN32(rc);
    }

        ULONG nIndex;
        for (nIndex=0; nIndex<cCategories; nIndex++)
        {
        // check for oldkey type
                for(int i=0;i<NUM_OLDKEYS_SUPPORTED;i++) {
                        if(IsEqualGUID(rgcatid[nIndex], g_oldkeyinfo[i].catid))
                        {
                        // we're deling with oldkey
                                StringConvert((LPTSTR)szCatKey,wszclsid,g_oldkeyinfo[i].szDescription);
                                rc = RegDeleteKey(HKEY_CLASSES_ROOT, szCatKey);
//                              if (ERROR_SUCCESS != rc) //bogus
//                              {
//                                      break;
//                              }
                                break;
                        }
                }
                // Stringize rgcatid[nIndex]
        if (0 == StringFromGUID2(rgcatid[nIndex], wszguid, sizeof(wszguid)/sizeof(TCHAR))) //yq
        {
            return E_OUTOFMEMORY;
        }
                int cch = WideCharToMultiByte(CP_ACP, 0, wszguid, -1, NULL, 0, NULL, NULL);
                char *pszguid = (char *)alloca(cch+1);
//              char *pszguid = new char[cch+1];
//        if (pszguid == NULL)
//                      break;
        WideCharToMultiByte(CP_ACP, 0, wszguid, -1, pszguid, cch+1, NULL, NULL);

        // Delete
        // HKCR\CLSID\{...rclsid...}\Impl/Required Categories\{...rgcatid[nIndex]...}
        rc = RecursiveRegDeleteKey(hkCatKey, pszguid);
//              delete [] pszguid;
        if (rc != ERROR_SUCCESS)
           break;
        }

    RegCloseKey(hkCatKey);
        return HRESULT_FROM_WIN32(rc);
}

HRESULT CComCat::UnRegisterClassImplCategories(REFCLSID rclsid, ULONG cCategories, CATID rgcatid[  ])
{
    return UnRegisterClassXXXCategories(rclsid, cCategories, rgcatid, WSZ_IMPLCAT);
}

HRESULT CComCat::RegisterClassReqCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ])
{
    return RegisterClassXXXCategories(rclsid, cCategories, rgcatid, WSZ_REQCAT);
}

HRESULT CComCat::UnRegisterClassReqCategories(REFCLSID rclsid, ULONG cCategories, CATID __RPC_FAR rgcatid[  ])
{
    return UnRegisterClassXXXCategories(rclsid, cCategories, rgcatid, WSZ_REQCAT);
}


// ICatInformation methods
HRESULT CComCat::EnumCategories(LCID lcid, IEnumCATEGORYINFO **ppenumCategoryInfo)
{
        HRESULT hr;
        IEnumCATEGORYINFO  *pcsIEnumCat = NULL;

        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_INVALIDARG;
        }
        if (!IsValidPtrOut(ppenumCategoryInfo, sizeof(*ppenumCategoryInfo)))
        {
                return E_INVALIDARG;
        }
        *ppenumCategoryInfo=NULL;
        CEnumCategories* pEnum=new CEnumCategories;
        if(NULL == pEnum)
                return E_OUTOFMEMORY;

        if ((m_fCsFlag) && (!m_pcsICatInfo))
            GetCsCatInfo();

        // Adding the intialization of CS.-ushaji

        if (m_pcsICatInfo)
        {
                hr = m_pcsICatInfo->EnumCategories(lcid, &pcsIEnumCat);

                if (FAILED(hr))
                {
                        hr = pEnum->Initialize(lcid, NULL);
                }
                else
                {
           // Make sure SCM can impersonate this
           hr = CoSetProxyBlanket((IUnknown *)(pcsIEnumCat),
              RPC_C_AUTHN_WINNT,
              RPC_C_AUTHZ_NONE, NULL,
              RPC_C_AUTHN_LEVEL_CONNECT,
              RPC_C_IMP_LEVEL_DELEGATE,
              NULL, EOAC_NONE );

                        hr = pEnum->Initialize(lcid, pcsIEnumCat);
                }
        }
        else
        {
                        hr = pEnum->Initialize(lcid, NULL);
        }

        if (FAILED(hr))
                return E_OUTOFMEMORY;
        // Gets the cs enumerators. if it fails even after that, return E_OUTOFMEMORY;

        if (FAILED(pEnum->QueryInterface(IID_IEnumCATEGORYINFO, (void**) ppenumCategoryInfo)))
        {
                return E_UNEXPECTED;
        }
        return S_OK;
}

HRESULT CComCat::GetCategoryDesc(REFCATID rcatid, LCID lcid, LPOLESTR *ppszDesc)
{
    if (!IsValidPtrOut(this, sizeof(*this)))
    {
        return E_POINTER;
    }
    if (!IsValidReadPtrIn(&rcatid, sizeof(rcatid)))
    {
        return E_INVALIDARG;
    }
    LPOLESTR pCLSID;
    if (FAILED(StringFromCLSID(rcatid, &pCLSID)))
    {
        return E_OUTOFMEMORY;
    }
if (NULL == ppszDesc)
    return E_INVALIDARG;

    HKEY hKey1, hKey2;
    DWORD dwError;
    dwError=OpenClassesRootKey(_T("Component Categories"), &hKey1);
    if (dwError!=ERROR_SUCCESS)
    {
        CoTaskMemFree(pCLSID); // gd
        return HRESULT_FROM_WIN32(dwError);
    }

    int cch = WideCharToMultiByte(CP_ACP, 0, pCLSID, -1, NULL, 0, NULL, NULL);
    char *pszCLSID = (char *)alloca(cch+1);
//      char *pszCLSID = new char[cch+1];
//    if (pszCLSID == NULL)
//      {
//              RegCloseKey(hKey1);
//              CoTaskMemFree(pCLSID);
//              return E_OUTOFMEMORY;
//      }
    WideCharToMultiByte(CP_ACP, 0, pCLSID, -1, pszCLSID, cch+1, NULL, NULL);

    dwError=RegOpenKeyExA(hKey1, pszCLSID, 0, KEY_READ, &hKey2);
//      delete [] pszCLSID;
    if (dwError!=ERROR_SUCCESS)
    {
        HRESULT         hr;
        RegCloseKey(hKey1);
        CoTaskMemFree(pCLSID);

        // if the category is not found locally, search in class store
        if ((m_fCsFlag) && (!m_pcsICatInfo))
            GetCsCatInfo();

        if (m_pcsICatInfo)
        {
            hr = m_pcsICatInfo->GetCategoryDesc(rcatid, lcid, ppszDesc);
            if (FAILED(hr))
            {
                return CAT_E_CATIDNOEXIST;
            }
            else
                return S_OK;
        }
        else
            return CAT_E_CATIDNOEXIST;
    }
    RegCloseKey(hKey1);
    CoTaskMemFree(pCLSID);
    HRESULT hRes=CComCat::GetCategoryDesc(hKey2, lcid, ppszDesc, NULL);
    RegCloseKey(hKey2);
    if (FAILED(hRes))
    {
        HRESULT         hr;
        // if this call fails, it gets forwarded to cs and in case of error the old
        // error is returned.

        if ((m_fCsFlag) && (!m_pcsICatInfo))
            GetCsCatInfo();

        if (m_pcsICatInfo)
        {
            hr = m_pcsICatInfo->GetCategoryDesc(rcatid, lcid, ppszDesc);
            if (FAILED(hr))
            {
                return hRes;
            }
            else
                return S_OK;
        }
        else
            return hRes;
    }
    return hRes;
}

HRESULT CComCat::EnumClassesOfCategories(ULONG cImplemented, CATID rgcatidImpl[], ULONG cRequired, CATID rgcatidReq[], IEnumGUID **ppenumClsid)
{

        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if(-1 == cImplemented)
        {
                if(NULL != rgcatidImpl)
                        return E_POINTER;
        }
        else if (!IsValidReadPtrIn(rgcatidImpl, sizeof(rgcatidImpl[0])*cImplemented))
        {
                return E_POINTER;
        }
        if(-1 == cRequired)
        {
                if(NULL != rgcatidReq)
                        return E_POINTER;
        }
        else if (cRequired != 0 && !IsValidReadPtrIn(rgcatidReq, sizeof(rgcatidReq[0])*cRequired))
        {
                return E_POINTER;
        }
        if (!IsValidPtrOut(ppenumClsid, sizeof(*ppenumClsid)))
        {
                return E_INVALIDARG;
        }
        *ppenumClsid=NULL;
        IEnumGUID   *pcsIEnumGuid = NULL;
        HRESULT      hr = S_OK;

        if(0 == cImplemented)   // gd
                return E_INVALIDARG;

        if ((m_fCsFlag) && (!m_pcsICatInfo))
            GetCsCatInfo();

        if (m_pcsICatInfo)
        {
                hr = m_pcsICatInfo->EnumClassesOfCategories(cImplemented, rgcatidImpl,
                                        cRequired, rgcatidReq, &pcsIEnumGuid);
                if (FAILED(hr))
        {
                        pcsIEnumGuid = NULL;
        }
                else
        {
            // Make sure SCM can impersonate this
            hr = CoSetProxyBlanket((IUnknown *)(pcsIEnumGuid),
                               RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE, NULL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_DELEGATE,
                               NULL, EOAC_NONE );
        }           
        }
        else
        {
                pcsIEnumGuid = NULL;
        }

        CEnumClassesOfCategories* pEnum = new CEnumClassesOfCategories;

        if (!pEnum)
        {
                return E_OUTOFMEMORY;
        }

        hr = pEnum->Initialize(cImplemented, rgcatidImpl, cRequired, rgcatidReq, pcsIEnumGuid);

        if(SUCCEEDED(hr))
        {
                hr = pEnum->QueryInterface(IID_IEnumGUID, (void**) ppenumClsid);
        }

        if(FAILED(hr))
        {
                delete pEnum;
        }

        return hr;
}

HRESULT CComCat::IsClassOfCategories(REFCLSID rclsid, ULONG cImplemented, CATID __RPC_FAR rgcatidImpl[  ], ULONG cRequired, CATID __RPC_FAR rgcatidReq[  ])
{
        HRESULT   hr, hr1;

        if(0 == cImplemented) // gd
        {
                return E_INVALIDARG;
        }

        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(&rclsid, sizeof(rclsid)))
        {
                return E_INVALIDARG;
        }
        if (-1 == cImplemented)
        {
                if(rgcatidImpl != NULL)
                        return E_POINTER;
        }
        else if(!IsValidReadPtrIn(rgcatidImpl, sizeof(rgcatidImpl[0])*cImplemented))
        {
                return E_POINTER;
        }
        if (-1 == cRequired)
        {
                if(rgcatidReq != NULL)
                        return E_POINTER;
        }
        else if(!IsValidReadPtrIn(rgcatidReq, sizeof(rgcatidReq[0])*cRequired))
        {
                return E_POINTER;
        }
        WCHAR wszCLSID[CATID_SIZE];
        if(0 == StringFromGUID2(rclsid, wszCLSID, CATID_SIZE))  //yq
        {
                return E_OUTOFMEMORY;
        }

        HKEY hkeyCLSID = NULL;

        if (OpenClassesRootKeyEx(WSZ_CLSID, KEY_READ, &hkeyCLSID))
        {
            return E_FAIL;
    	}
      
        hr = IsClassOfCategoriesEx(hkeyCLSID, wszCLSID, cImplemented, rgcatidImpl, cRequired, rgcatidReq);
        RegCloseKey(hkeyCLSID);

        // if the local call fails then it is sent to the class store.
        // think this has to be changed to call only if class is not available
        // locally.

        if ((FAILED(hr)) || (hr == S_FALSE))
        {
            if ((m_fCsFlag) && (!m_pcsICatInfo))
                GetCsCatInfo();

            if (m_pcsICatInfo)
            {
                hr1 = m_pcsICatInfo->IsClassOfCategories(rclsid, cImplemented,
                                                         rgcatidImpl, cRequired, rgcatidReq);
                if (FAILED(hr1))
                    return hr;
                return hr1;
            }
        }
        return hr;
}


HRESULT CComCat::IsClassOfCategoriesEx(HKEY hkeyHKCRClsid, WCHAR *wszCLSID, ULONG cImplemented, CATID __RPC_FAR rgcatidImpl[  ], ULONG cRequired, CATID __RPC_FAR rgcatidReq[  ])
{
    DWORD dwError;
    WCHAR wszKey[MAX_PATH];
    HRESULT hr = S_OK;

    if ((cImplemented>0) && (cImplemented != -1) )
    {
        BOOL bImplemented = FALSE;
        BOOL bHasImpCatKey = TRUE;
        HKEY hKeyImpl;

        wcscpy(wszKey, wszCLSID);
        wcscat(wszKey, L"\\");
        wcscat(wszKey, WSZ_IMPLCAT);
        wcscat(wszKey, L"\\");
	
        // First see if there is an "Implemented Categories" key for this CLSID at all 
        // anyway.  If not, then there is no need to enumerate looking for each 
        // individual category.   If there is, then we've wasted a registry open/close,
        // but overall this should be a win when somebody is calling us repeatedly for
        // every clsid in the registry (which is often the case).
        if (cImplemented > 1)
        {
            HKEY hkeyImpCat = NULL;
            dwError = RegOpenKeyEx(hkeyHKCRClsid, wszKey, 0, KEY_READ, &hkeyImpCat);
            if (dwError == ERROR_SUCCESS)
            {
                // fine, this clsid seems to have some.  just continue onwards to the 
                // loop below
                RegCloseKey(hkeyImpCat);
                bHasImpCatKey = TRUE;   
            }
            else
            {
                // no impcat key.  No need to do the loop below.
                bHasImpCatKey = FALSE;   
            }
        }

        DWORD dwCatImpl;
        if (bHasImpCatKey)
        {
	        for (dwCatImpl=0; dwCatImpl<cImplemented; dwCatImpl++)
	        {
	            WCHAR wszCat[MAX_PATH+1];
	            StringFromGUID2(rgcatidImpl[dwCatImpl], wszCat, sizeof(wszCat)/sizeof(TCHAR));
	            wcscpy(&wszKey[KEY_STRING_IMPL_CHARS_2], wszCat);

	            dwError=RegOpenKeyEx(hkeyHKCRClsid, wszKey, 0, KEY_READ, &hKeyImpl);
	            if(ERROR_SUCCESS == dwError)
	            {
	                // we got what we came for, blow
	                RegCloseKey(hKeyImpl);
	                bImplemented=TRUE;
	                break;
	            }
	        }
        }
        
        if (!bImplemented)
        {
            // Check for old keys    gd
            DWORD dwCatImpl;

            for (dwCatImpl=0; dwCatImpl<cImplemented; dwCatImpl++)
            {
                // loop through oldkey hardcoded info and see if match
                DWORD dwNumOldKeys;
                for(dwNumOldKeys = 0;dwNumOldKeys<NUM_OLDKEYS_SUPPORTED;dwNumOldKeys++)
                {
                    if(IsEqualGUID(rgcatidImpl[dwCatImpl], g_oldkeyinfo[dwNumOldKeys].catid))
                    {
                        // We have a match, look for name under HKCR\CLSID\{clsid}
                        wcscpy(&wszKey[KEY_STRING_CLSID_CHARS], g_oldkeyinfo[dwNumOldKeys].szDescription);
                        dwError = RegOpenKeyEx(hkeyHKCRClsid, wszKey, 0, KEY_READ, &hKeyImpl);
                        if(ERROR_SUCCESS == dwError)
                        {
                            // we found an old key
                            RegCloseKey(hKeyImpl);
                            bImplemented=TRUE;
                            break;
                        }
                    }
                }
            }
    
            if (!bImplemented)
            {
                hr = S_FALSE;
                goto BAILOUT;
            }
        }
    }

    if (cRequired != -1)
    {
        HKEY hKeyReq;
        BOOL bRequired=FALSE;

        wcscpy(wszKey, L"\\");
        wcscat(wszKey, wszCLSID);
        wcscat(wszKey, L"\\");
        wcscat(wszKey, WSZ_REQCAT);
        wcscat(wszKey, L"\\");

        dwError=RegOpenKeyEx (hkeyHKCRClsid, wszKey, 0, KEY_READ, &hKeyReq);
        if(dwError != ERROR_SUCCESS)
        {
            hr = S_OK;
            goto BAILOUT;
        }
        else
            RegCloseKey(hKeyReq);

        // Get catid Enum
        IEnumCATID * ppenumCatid = NULL;
        CLSID clsid;
        if (GUIDFromString(wszCLSID, &clsid))
            hr = EnumCategoriesOfClass(clsid, _T("Required Categories"), FALSE, &ppenumCatid);
        else
            hr = E_FAIL;
        if(FAILED(hr))
        {
            goto BAILOUT;
        }
        DWORD celtFetched;
        CATID guid[1];
        DWORD dwCatReq;
        // loop through Enum req catids and see if passed in with rgcatidReq
        do
        {
            bRequired = FALSE;
            hr = ppenumCatid->Next(1, guid, &celtFetched);
            if(hr != S_OK)
            {
                bRequired = TRUE;
                break;
            }
            // Find match in rgcatidReq
            for(dwCatReq=0;dwCatReq<cRequired;dwCatReq++)
            {
                if(IsEqualGUID(guid[0], rgcatidReq[dwCatReq]))
                {
                    bRequired = TRUE;
                    break;
                }
            }
        }while((hr ==S_OK) && bRequired);
            
        ppenumCatid->Release();
        if (!bRequired)
        {
            hr = S_FALSE;
            goto BAILOUT;
        }
    }

    hr = S_OK;

BAILOUT:
    return hr;
}


HRESULT CComCat::EnumImplCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid)
{
    HRESULT hr, hr1;
    if (!IsValidPtrOut(this, sizeof(*this)))
    {
            return E_POINTER;
    }
    if (!IsValidReadPtrIn(&rclsid, sizeof(rclsid)))
    {
            return E_INVALIDARG;
    }
    if (!IsValidPtrOut(ppenumCatid, sizeof(*ppenumCatid)))
    {
            return E_INVALIDARG;
    }

    hr = EnumCategoriesOfClass(rclsid, _T("Implemented Categories"), FALSE, ppenumCatid);
    if (FAILED(hr))
    {
        if ((m_fCsFlag) && (!m_pcsICatInfo))
            GetCsCatInfo();

        if (m_pcsICatInfo)
        {
            hr1 = m_pcsICatInfo->EnumImplCategoriesOfClass(rclsid, ppenumCatid);
            if (FAILED(hr1))
                return hr;
            else
            {
                // Make sure SCM can impersonate    
                hr = CoSetProxyBlanket((IUnknown *)(*ppenumCatid),
                                       RPC_C_AUTHN_WINNT,
                                       RPC_C_AUTHZ_NONE, NULL,
                                       RPC_C_AUTHN_LEVEL_CONNECT,
                                       RPC_C_IMP_LEVEL_DELEGATE,
                                       NULL, EOAC_NONE );
                return hr1;
            }
        }
    }
    return hr;
}

HRESULT CComCat::EnumReqCategoriesOfClass(REFCLSID rclsid, IEnumGUID **ppenumCatid)
{
        HRESULT hr, hr1;

        if (!IsValidPtrOut(this, sizeof(*this)))
        {
                return E_POINTER;
        }
        if (!IsValidReadPtrIn(&rclsid, sizeof(rclsid)))
        {
                return E_INVALIDARG;
        }
        if (!IsValidPtrOut(ppenumCatid, sizeof(*ppenumCatid)))
        {
                return E_INVALIDARG;
        }
        hr = EnumCategoriesOfClass(rclsid, _T("Required Categories"), FALSE, ppenumCatid);
        // if the class is not found locally.

        if (FAILED(hr))
        {
            if ((m_fCsFlag) && (!m_pcsICatInfo))
                GetCsCatInfo();
            
            if (m_pcsICatInfo)
            {
                hr1 = m_pcsICatInfo->EnumReqCategoriesOfClass(rclsid, ppenumCatid);
                if (FAILED(hr1))
                    return hr;
                else
                {
                    // Make sure SCM can impersonate    
                    hr = CoSetProxyBlanket((IUnknown *)(*ppenumCatid),
                                           RPC_C_AUTHN_WINNT,
                                           RPC_C_AUTHZ_NONE, NULL,
                                           RPC_C_AUTHN_LEVEL_CONNECT,
                                           RPC_C_IMP_LEVEL_DELEGATE,
                                           NULL, EOAC_NONE );
                    return hr1;
                }
            }
        }
        return hr;
}

HRESULT CComCat::EnumCategoriesOfClass(REFCLSID rclsid, LPCTSTR lpszSubKey, BOOL bMapOldKeys, IEnumGUID **ppenumCatid)
{
    HKEY hKey, hKey1;

    hKey = NULL; 
    hKey1 = NULL;

    HRESULT hRes=GetKeyForReading(rclsid, &hKey1);
    if(FAILED(hRes))
        return hRes;

    DWORD dwError;
    dwError=RegOpenKeyEx(hKey1, lpszSubKey, 0, KEY_READ, &hKey);
    if (dwError!=ERROR_SUCCESS)
    {
        RegCloseKey(hKey1);
        return HRESULT_FROM_WIN32(dwError);
    }
    RegCloseKey(hKey1);

    *ppenumCatid=NULL;
    CEnumCategoriesOfClass* pEnum=NULL;
    pEnum=new CEnumCategoriesOfClass;
    if (!pEnum || FAILED(pEnum->Initialize(hKey, bMapOldKeys)))
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(pEnum->QueryInterface(IID_IEnumGUID, (void**) ppenumCatid)))
    {
        delete pEnum;
        return E_UNEXPECTED;
    }
    return S_OK;
}

HRESULT CComCat::GetKeyForReading(REFCLSID rclsid, HKEY* phKey)
{
    LPOLESTR pCLSID;
    if (FAILED(StringFromCLSID(rclsid, &pCLSID)))
    {
        return E_OUTOFMEMORY;
    }

    HKEY hKey, hKey1;
    DWORD dwError;
    dwError=OpenClassesRootKey(_T("CLSID"), &hKey);
    if (dwError!=ERROR_SUCCESS)
    {
        CoTaskMemFree(pCLSID); // gd
        return HRESULT_FROM_WIN32(dwError);
    }

    int cch = WideCharToMultiByte(CP_ACP, 0, pCLSID, -1, NULL, 0, NULL, NULL);
    char *pszCLSID = (char *)alloca(cch+1);

    WideCharToMultiByte(CP_ACP, 0, pCLSID, -1, pszCLSID, cch+1, NULL, NULL);

    dwError=RegOpenKeyExA(hKey, pszCLSID, 0, KEY_READ, &hKey1);
    if (dwError!=ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        CoTaskMemFree(pCLSID);
        return HRESULT_FROM_WIN32(dwError);
    }

    RegCloseKey(hKey);
    CoTaskMemFree(pCLSID);
    *phKey=hKey1;
    return S_OK;
}


HRESULT CComCat::ConvertStringToLCID(LCID* newlcid,LPTSTR szLCID)
{
        LPWSTR  temp = NULL;
        WCHAR wszLCID[30];
#ifdef _UNICODE
                *newlcid = wcstoul(szLCID, &temp, 16);
#else
                MultiByteToWideChar(CP_ACP, 0, szLCID, -1, wszLCID, 40);
                *newlcid = wcstoul(wszLCID, &temp, 16);
#endif
        return S_OK;

}
// Will attempt to use locale specified
// if not found tries default sublang
// if not found tries any matching pri lang
// if not found tries default user locale
// if not found tries default system locale

//  ppszDesc returns Desc found
//  plcid returns lcid found if not NULL
HRESULT CComCat::GetCategoryDesc(HKEY hKey, LCID lcid, LPOLESTR *ppszDesc, LCID *plcid)
{
        TCHAR szLCID[30];
        DWORD dwError;
        LCID newlcid;
        WORD plgid;
        DWORD cb=0;
        DWORD dwNumValues;
        BOOL bSysDefault = FALSE;
        BOOL bUserDefault = FALSE;
        DWORD dwIndex = 0;
        DWORD dwSizeNameBuf = 16;


        newlcid = lcid;
        // How many values?
        dwError = RegQueryInfoKey (
                hKey, NULL, NULL, NULL, NULL, NULL, NULL,
                &dwNumValues,   // address of buffer for number of value entries
                NULL, NULL, NULL, NULL);
        if (dwError)
                {
                        return CAT_E_NODESCRIPTION;
                }
        if(0 == dwNumValues)
                return CAT_E_NODESCRIPTION;

        // if only one, return it
        if(1 == dwNumValues)
        {
                dwError = RegEnumValue(hKey, 0,
                        szLCID,&dwSizeNameBuf,NULL,NULL,NULL,&cb);
                ConvertStringToLCID(&newlcid,(LPTSTR)szLCID);
                goto process;
        }
        wsprintf(szLCID,_T("%X"),lcid);
        // Try locale passed in
        dwError = RegQueryValueEx(hKey, szLCID, NULL, NULL, NULL, &cb);
        if(dwError)
        {
                // Get default sublang local
                plgid = PRIMARYLANGID((WORD)lcid);
                newlcid = MAKELCID(MAKELANGID(plgid, SUBLANG_DEFAULT), SORT_DEFAULT);
                wsprintf(szLCID,_T("%X"),newlcid);
                dwError=RegQueryValueEx(hKey, szLCID, NULL, NULL, NULL, &cb);
        }
        else
                goto process;

        if (dwError)
        {
                // Enum through to find at least same primary lang
                do{
                        dwSizeNameBuf = 16;
                        dwError = RegEnumValue(hKey, dwIndex,
                                szLCID,&dwSizeNameBuf,NULL,NULL,NULL,&cb);
                        if(ERROR_SUCCESS != dwError)
                                break;
                        ConvertStringToLCID(&newlcid,szLCID);
                        WORD w = PRIMARYLANGID(LANGIDFROMLCID(newlcid));
                        if(w == plgid)
                        {
                                break;
                        }
                        dwIndex++;
                }while(ERROR_NO_MORE_ITEMS != dwError);
        }
        else
                goto process;

        if (dwError)
        {
                // Get User Default
                newlcid = GetUserDefaultLCID();
                wsprintf(szLCID,_T("%X"),newlcid);
                dwError=RegQueryValueEx(hKey, szLCID, NULL, NULL, NULL, &cb);
        }
        else
                goto process;

        if (dwError)
        {
                // Get System Default
                newlcid = GetSystemDefaultLCID();
                wsprintf(szLCID,_T("%X"),newlcid);
                dwError=RegQueryValueEx(hKey, szLCID, NULL, NULL, NULL, &cb);
        }
        else
                goto process;

        // Get first enum
        if (dwError)
        {
                dwError = RegEnumValue(hKey, 0,
                        szLCID, &dwSizeNameBuf, NULL, NULL, NULL, &cb);

        }
        else
                goto process;

        if (dwError)
        {
                return CAT_E_NODESCRIPTION;
        }
        ConvertStringToLCID(&newlcid,szLCID);   // fix #70030

process:
        *ppszDesc=(LPOLESTR) CoTaskMemAlloc(cb*2);
        if (NULL==*ppszDesc)
        {
                return E_OUTOFMEMORY;
        }

#ifdef UNICODE
                dwError=RegQueryValueExW(hKey, szLCID, NULL, NULL, (LPBYTE)*ppszDesc, &cb);
#else
                LPSTR pTemp=(LPSTR) LocalAlloc(LPTR,cb);
                if (NULL==pTemp)
                {
                        CoTaskMemFree(*ppszDesc);
                        return E_OUTOFMEMORY;
                }
                dwError=RegQueryValueExA(hKey, szLCID, NULL, NULL, (LPBYTE)pTemp, &cb);
                MultiByteToWideChar(CP_ACP, 0, pTemp, -1, *ppszDesc, cb);
//              CoTaskMemFree(pTemp); //gd
                LocalFree(pTemp);
#endif

        if (dwError)
        {
                CoTaskMemFree(*ppszDesc);
                *ppszDesc=NULL;
                return CAT_E_NODESCRIPTION;
        }
        if(plcid)
                *plcid = newlcid;
        return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetCsCatInfo
//
//  Synopsis:   Returns an instantiated ICatInformation interface pointer
//              to the Class Store Co-ordinator object.
//
//
//  Returns:    S_OK - Got a pointer Successfully
//              E_FAIL
//
//--------------------------------------------------------------------------
HRESULT CComCat::GetCsCatInfo()
{
        HRESULT hr = S_OK;
        CsCatInfo  *pCsCatInfObj = NULL;

        if (m_pcsICatInfo)
            return hr;

        pCsCatInfObj = new CsCatInfo();

        if (!pCsCatInfObj)
        {
            return E_OUTOFMEMORY;
        }

        EnterCriticalSection(&m_csCatInfoInit);

        if (!m_pcsICatInfo)
            hr = pCsCatInfObj->QueryInterface(IID_ICatInformation,
                                             (void **)&m_pcsICatInfo);
        pCsCatInfObj->Release();

        LeaveCriticalSection(&m_csCatInfoInit);

        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\catinit.cxx ===
#include <ole2int.h>

STDAPI GetCatalogHelper ( REFIID riid, void** ppv );

// Global catalog reference used in all activation
IComCatalog *gpCatalog = NULL;
IComCatalogSCM *gpCatalogSCM = NULL;

//+-------------------------------------------------------------------------
//
//  Function:   InitializeCatalogIfNecessary
//
//  Synopsis:   Load the catalog DLL and initialize the catalog interface
//              if it hasn't already been done
//
//  Arguments:   none
//
//  Returns:    S_OK            - no errors or inconsistencies found
//              E_OUTOFMEMORY   - couldn't create catalog object
//              FAILED(hr)      - return from CCI() of catalog or
//                                from QI() of catalog for IComCatalogSCM
//
//--------------------------------------------------------------------------

HRESULT InitializeCatalogIfNecessary()
{
    if (gpCatalog != NULL && gpCatalogSCM != NULL)
    {
        return S_OK;
    }

    HRESULT hr = S_OK;
    IComCatalog *pCatalog = NULL;
    IComCatalogSCM *pCatalogSCM = NULL;
    void* pICEPRet = NULL;

    // get the actual catalog object - abort on failure
    hr = GetCatalogHelper (IID_IComCatalog, (void**) &pCatalog);
    if ( FAILED(hr) || pCatalog == NULL)
    {
        ComDebOut((DEB_WARN,
                   "CCI of Catalog failed, hr=0x%x, pCatalog=0x%x",
                    hr, pCatalog));
    }    
    if ( FAILED(hr) )
    {
        return hr;
    }
    if ( pCatalog == NULL )
    {
        return E_OUTOFMEMORY;
    }

    // store the catalog object. guard against races by
    //  releasing if we didn't find a NULL in the variable
    pICEPRet = InterlockedCompareExchangePointer ( (void **) &gpCatalog, (void *) pCatalog, NULL);
    if ( pICEPRet != NULL )
    {
        pCatalog->Release();
    }

    // create the SCM object -- again, abort on failure
    hr = GetCatalogHelper (IID_IComCatalogSCM, (void**) &pCatalogSCM);
    if ( FAILED(hr) || pCatalog == NULL)
    {
        ComDebOut((DEB_WARN,
                   "CCI of Catalog failed, hr=0x%x, pCatalog=0x%x",
                    hr, pCatalog));
    }    
    if ( FAILED(hr) )
    {
        return hr;
    }
    if ( pCatalogSCM == NULL )
    {
        return E_OUTOFMEMORY;
    }

    // store the SCM catalog. Again, if it was already non-NULL, the exchange
    //  didn't happen, and you release the thing you just created.
    pICEPRet = InterlockedCompareExchangePointer ( (void **) &gpCatalogSCM, (void *) pCatalogSCM, NULL );
    if ( pICEPRet != NULL )
    {
        pCatalogSCM->Release();
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   UninitializeCatalog
//
//  Synopsis:   Load the catalog DLL and initialize the catalog interface
//              if it hasn't already been done
//
//  Arguments:   none
//
//  Returns:    S_OK   - no errors or inconsistencies observed here
//
//  Note:        This can only be called from a place like wCoUninitialize(),
//                where you're sure that nobody's using the catalog or doing
//                anything out in the process.
//
//--------------------------------------------------------------------------

HRESULT UninitializeCatalog()
{
    IComCatalog *pCatalog = NULL;
    IComCatalogSCM *pCatalogSCM = NULL;

    pCatalogSCM = (IComCatalogSCM *) InterlockedExchangePointer ((PVOID*)&gpCatalogSCM, NULL);
    if ( pCatalogSCM != NULL )
    {
        pCatalogSCM->Release();
    }

    pCatalog = (IComCatalog *) InterlockedExchangePointer ((PVOID*)&gpCatalog, NULL);
    if ( pCatalog != NULL )
    {
        pCatalog->FlushCache();
        pCatalog->Release();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#pragma hdrstop

//
// This one file **always** uses debugging options
//

#if DBG == 1
#include <stdarg.h>
#include <stdio.h>
#include <dprintf.h>            // w4printf, w4dprintf prototypes
#include <debnot.h>
#include <olesem.hxx>
#include <windows.h>
#include <netevent.h>
#include <stackwalk.h>
#include <asrtcfg.h>
#include <privguid.h>
#include <memapi.hxx>

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
BOOL gAssertOnCreate = TRUE;
int ForceAV();

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
          char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}
typedef enum 
    {
    ASSRTCFG_BREAK        = 0x01,
    ASSRTCFG_POPUP        = 0x02,
    ASSRTCFG_DEBUGMESSAGE = 0x04,
    ASSRTCFG_PRINTSTACK   = 0x08,
    ASSRTCFG_USEAV        = 0x10
    } ASSRTCFG;




//+---------------------------------------------------------------------
//
// Class:      CAssertInfo
//
// Synopsis:   Data type to trake assertion and logging parameters
//
// History:    27-Jan-99  MattSmit Created
//
//----------------------------------------------------------------------
class CAssertInfo : public IAssertConfig
{
public:
    CAssertInfo() : _dwFlags(ASSRTCFG_POPUP | ASSRTCFG_DEBUGMESSAGE) {}

    //
    // IUnknown
    //

    STDMETHOD(QueryInterface)(REFIID riid, PVOID * ppv)
    {
        if ((IsEqualIID(riid, IID_IUnknown)) || 
            (IsEqualIID(riid, IID_IAssertConfig)))
        {
            *ppv = this;
            AddRef();
            return S_OK;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }

    STDMETHOD_(ULONG, AddRef)()  { return 1;}
    STDMETHOD_(ULONG, Release)() { return 1;}


    //
    // IConfigAssert
    //

    STDMETHOD(SetBreak)(BOOL f)            { SetFlag(f, ASSRTCFG_BREAK); return S_OK;}
    STDMETHOD(SetPopup)(BOOL f)            { SetFlag(f, ASSRTCFG_POPUP); return S_OK;}
    STDMETHOD(SetDebuggerMessage)(BOOL f)  { SetFlag(f, ASSRTCFG_DEBUGMESSAGE); return S_OK;}
    STDMETHOD(SetPrintStack)(BOOL f)       { SetFlag(f, ASSRTCFG_PRINTSTACK); return S_OK;}
    STDMETHOD(SetUseAV)(BOOL f)            { SetFlag(f, ASSRTCFG_USEAV); return S_OK;}
    STDMETHOD(SetLog)(ASSRTLOGINFO *pLogInfo) { _logInfo = *pLogInfo;  return S_OK;}
    STDMETHOD(SetContextString)(char *psz){ _pszContext = psz; return S_OK;}
    STDMETHOD(SetThreshold)(ULONG cTh)     { _cThreshold = cTh; return S_OK;}

    //
    // helpers
    //
    
    void Win4AssertEx(char const * szFile, int iLine, char const * szMessage);
    int  PopUpError(char const *szMsg, int iLine, char const *szFile);
    void ComposeErrorMessage(char const *szMsg, int iLine, char const *szFile);
    void AppendToFile(char *pszFileName, char const *pwszData);
    void FatalErrorHandler(char *errmsg);
    void LogAssertionFailure(char const * szMessage);
private:

    void SetFlag(BOOL f, DWORD bit)
    {
        _dwFlags = f ? _dwFlags | bit : _dwFlags & ~bit;
    }
    char *GetStack();
    BOOL GetBreak()        {return _dwFlags | ASSRTCFG_BREAK;}
    BOOL GetPopup()        {return _dwFlags | ASSRTCFG_POPUP;}
    BOOL GetDebugMessage() {return _dwFlags | ASSRTCFG_DEBUGMESSAGE;}
    void BreakIntoDebugger()
    {
        if (_dwFlags & ASSRTCFG_USEAV)
            ForceAV();
        else
            DebugBreak();
    }


    DWORD                 _dwFlags;          // what to do when an assertion fails
    ASSRTLOGINFO          _logInfo;          // if/where to write a log entry
    char                 *_pszContext;       // user supplied context string for the log
    char                  _errMessage[128];  // generated error string
    ULONG                 _cThreshold;       // number of assertion to ignore
    ULONG                 _cAssrtFail;       // number of assertion failures so far
};

CAssertInfo gAssertInfo;

//+---------------------------------------------------------------------------
//
//  Method:     Win4AssertEx
//
//  Synopsis:   Called on assertion failure.  Takes appropriate action based 
//              on member variables
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void CAssertInfo::Win4AssertEx(
                              char const * szFile,
                              int iLine,
                              char const * szMessage)
{
    _cAssrtFail++;
    if (_cAssrtFail < _cThreshold)
    {
        return;
    }
    ComposeErrorMessage(szMessage, iLine, szFile);

    BOOL fBrokeAlready = FALSE;

    if (_dwFlags & ASSRTCFG_DEBUGMESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s\n%s\n", _errMessage, szMessage);
    }

    if (_logInfo.dwDest & ASSRTLOG_FILE)
    {
        AppendToFile(_logInfo.pszFileName, szMessage);
    }

    if (_logInfo.dwDest & ASSRTLOG_NTEVENTLOG)
    {
        LogAssertionFailure(szMessage);
    }

    if (_dwFlags & ASSRTCFG_POPUP)
    {
        int id = PopUpError(szMessage, iLine, szFile);

        if (id == IDCANCEL)
        {
            fBrokeAlready = TRUE;
            BreakIntoDebugger();
        }
    }

    if ((_dwFlags & ASSRTCFG_BREAK) && !fBrokeAlready)
    {
        BreakIntoDebugger();
    }

}

//+------------------------------------------------------------
// Method:      PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int CAssertInfo::PopUpError(char const *szMsg, int iLine, char const *szFile)
{

    int id;
    WCHAR   wszWinsta[64];
    HWINSTA hWinsta;
    DWORD   Size;

    DWORD dwMessageFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                           MB_ICONEXCLAMATION | MB_OKCANCEL;

    hWinsta = GetProcessWindowStation();
    Size = sizeof(wszWinsta);
    wszWinsta[0] = 0;

    if ( hWinsta )
    {
        (void) GetUserObjectInformation(
                                       hWinsta,
                                       UOI_NAME,
                                       wszWinsta,
                                       Size,
                                       &Size );
    }


    //
    // This makes popups from non-interactive servers/services (including
    // rpcss) visible.
    //
    if ( wszWinsta[0] && (lstrcmpiW(wszWinsta,L"Winsta0") != 0) )
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;

    id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) _errMessage,
                     dwMessageFlags);

    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).  Oh well.

    return id;
}

//+---------------------------------------------------------------------------
//
//  Method:     ComposeErrorMessage
//
//  Synopsis:   Put together a message that contains useful info about the 
//              context of the error
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void CAssertInfo::ComposeErrorMessage(
                                     char const *szMsg,
                                     int iLine,
                                     char const *szFile)
{

    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char *  pszModuleName;

    BOOL    bStatus;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    wsprintfA(_errMessage,"Process: %s File: %s line %u, thread id %d.%d",
              pszModuleName, szFile, iLine, pid, tid);
}


//+---------------------------------------------------------------------------
//
//  Method:     AppendToFile
//
//  Synopsis:   Write assertion failures to a log file.
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void CAssertInfo::AppendToFile(char *pszFileName, char const *pwszData)
{
    HANDLE hFile = CreateFileA(pszFileName,
                               GENERIC_WRITE,
                               0, 
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        FatalErrorHandler("Could not open log File.");
    }

    
    DWORD ret = SetFilePointer(hFile, 0, 0, FILE_END);
    if (ret == -1)
    {
        FatalErrorHandler("Could not set file pointer.");
    }
    
    DWORD dwBytesWritten;
    BOOL ok = WriteFile(hFile, _errMessage, 
                        lstrlenA(_errMessage),
                        &dwBytesWritten, NULL); 

    if (!ok)
    {
        FatalErrorHandler("Could not write to log File.");
    }
    
    ok = WriteFile(hFile, "\n", 1,
                        &dwBytesWritten, NULL); 

    if (!ok)
    {
        FatalErrorHandler("Could not write to log File.");
    }

    ok = WriteFile(hFile, pwszData, 
                   lstrlenA(pwszData),
                   &dwBytesWritten, NULL); 

    if (!ok)
    {
        FatalErrorHandler("Could not write to log File.");
    }

    ok = WriteFile(hFile, "\n", 1,
                        &dwBytesWritten, NULL); 

    if (!ok)
    {
        FatalErrorHandler("Could not write to log File.");
    }


    if (_dwFlags & ASSRTCFG_PRINTSTACK)
    {
        char *psz = GetStack();
        if (psz)
        {
            ok = WriteFile(hFile, psz,
                           lstrlenA(psz),
                           &dwBytesWritten, NULL); 

            if (!ok)
            {
                FatalErrorHandler("Could not write to log File.");
            }
            PrivMemFree(psz);
        }
        
    }
    if (_pszContext)
    {
        ok = WriteFile(hFile, pwszData, 
                       lstrlenA(pwszData),
                       &dwBytesWritten, NULL); 

        if (!ok)
        {
            FatalErrorHandler("Could not write to log File.");
        }
        ok = WriteFile(hFile, "\n", 1,
                            &dwBytesWritten, NULL); 

        if (!ok)
        {
            FatalErrorHandler("Could not write to log File.");
        }


    }
    CloseHandle(hFile);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStackExceptionFilter
//
//  Synopsis:   Walk stack and store in a string variable
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------

extern HRESULT CStackWalkerCF_CreateInstance (IUnknown *pUnkOuter, REFIID riid, void** ppv);

LONG GetStackExceptionFilter(LPEXCEPTION_POINTERS lpep, char **ppStack)
{
    HRESULT hr;
    LONG lRet = EXCEPTION_EXECUTE_HANDLER;
    
    IStackWalker* pIStackWalker = NULL;
    IStackWalkerStack* pIStack = NULL;

    *ppStack = NULL;
    DWORD dwFault = lpep->ExceptionRecord->ExceptionCode;
    if (dwFault != 0xceadbeef)
    {
        lRet = EXCEPTION_CONTINUE_SEARCH;
        goto Cleanup;
    }

    hr = CStackWalkerCF_CreateInstance (NULL, IID_IStackWalker, (void**) &pIStackWalker);
    if (FAILED (hr))
        goto Cleanup;

    hr = pIStackWalker->Attach (NULL);
    if (FAILED (hr))
        goto Cleanup;

    pIStack = pIStackWalker->CreateStackTrace (lpep->ContextRecord, NULL, 0);
    if (!pIStack)
        goto Cleanup;

    SIZE_T nLen = pIStack->Size (20);

    WCHAR * szStack = new WCHAR[nLen];
    if (szStack)
    {        
        if (pIStack->GetStack (nLen, szStack, 20))
        {
            *ppStack = (char *) PrivMemAlloc(nLen);
            if (*ppStack)
            {
                wcstombs(*ppStack, szStack, lstrlenW(szStack));
            }
        }

        delete [] szStack;
    }

Cleanup:

    if (pIStackWalker)
        pIStackWalker->Release();

    if (pIStack)
        pIStack->Release();
    
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     GetStack
//
//  Synopsis:   Throws and exception so the filter can get stack info
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
char *CAssertInfo::GetStack()
{
    char *pStack = NULL;
    __try
    {
        RaiseException(0xceadbeef, 0, 0, NULL);
    }
    __except(GetStackExceptionFilter(GetExceptionInformation(), &pStack))
    {
    }
    return pStack;
}

//+---------------------------------------------------------------------------
//
//  Method:     FatalErrorHandler
//
//  Synopsis:   Called when the assertion code itself cannot allocate 
//              enough resources to log the assertion failure.
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void CAssertInfo::FatalErrorHandler(char *szMessage)
{
    BOOL fBrokeAlready = FALSE;

    lstrcpyA(_errMessage, "Fatal error while processing assertion failure");
    _asdprintf("%s\n%s\n", _errMessage, szMessage);

    if (_dwFlags & ASSRTCFG_POPUP)
    {
        int id = PopUpError(szMessage, __LINE__, __FILE__);

        if (id == IDCANCEL)
        {
            fBrokeAlready = TRUE;
            BreakIntoDebugger();
        }
    }

    if (_dwFlags & ASSRTCFG_BREAK && !fBrokeAlready)
    {
        BreakIntoDebugger();
    }

}

//+---------------------------------------------------------------------------
//
//  Method:     LogAssertionFailure
//
//  Synopsis:   Write and assertion failure to the NT event log
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void CAssertInfo::LogAssertionFailure(char const * szMessage)
{
    HANDLE  LogHandle;
    char const *  Strings[3]; // array of message strings.

    Strings[0] = _errMessage;
    Strings[1] = szMessage;
    Strings[2] = _pszContext ? _pszContext : "";

    // Get the log handle, then report the event.
    LogHandle = RegisterEventSource( NULL, L"DCOM" );

    if ( LogHandle )
    {
        ReportEventA( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_DCOM_ASSERTION_FAILURE,
                     NULL,
                     3,             // 3 strings passed
                     0,             // 0 bytes of binary
                     Strings,       // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }
    else
    {
        FatalErrorHandler("Could not register as event source");
    }
}





//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//


COleStaticMutexSem g_mxsVdprintf;
BOOL g_mxsVdprintfInitialized = TRUE;

STDAPI_(void) vdprintf(
                      unsigned long ulCompMask,
                      char const   *pszComp,
                      char const   *ppszfmt,
                      va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                DWORD tid = GetCurrentThreadId();
                DWORD pid = GetCurrentProcessId();

                if (g_mxsVdprintfInitialized)
                    LOCK (g_mxsVdprintf);
                
                w4dprintf( "%d.%03dp> ", pid, tid );
                w4dprintf("%s: ", pszComp);
                w4vdprintf(ppszfmt, pargs);

                if (g_mxsVdprintfInitialized)
                    UNLOCK (g_mxsVdprintf);
            }
        }        
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ForceAV
//
//  Synopsis:   Cause and Access Violation
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
int ForceAV()
{
    return *((int *) 0);
}



//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


STDAPI_(void) Win4AssertEx(
                          char const * szFile,
                          int iLine,
                          char const * szMessage)
{
    gAssertInfo.Win4AssertEx(szFile, iLine, szMessage);
}




//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
                unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
               unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadINIFile
//
//  Synopsis:   Get a paremeter value from the win.ini file
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
BOOL ReadINIFile(char * pszKey, BOOL * pVal)
{
    static char szValue[128];
    
    if (GetProfileStringA("CairOLE Assertions", // section
                          pszKey,               // key
                          "",             // default value
                          szValue,              // return buffer
                          128))
    {
        *pVal = (lstrcmpiA(szValue, "yes") == 0) ;
        return TRUE;
    }
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   AssertDebugInit
//
//  Synopsis:   Initialize the assertion data structure using the win.ini file
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
void AssertDebugInit()
{

#define ASSERT_SET(key) \
{ \
    BOOL val; \
    if (ReadINIFile(#key, &val)) \
    { \
       gAssertInfo.Set##key(val); \
    } \
} \

    static char szValue[128];
    ASSERT_SET(Break);
    ASSERT_SET(Popup);
    ASSERT_SET(DebuggerMessage);
    ASSERT_SET(PrintStack);
    ASSERT_SET(UseAV);
    
    ASSRTLOGINFO logInfo;
    memset(&logInfo, 0, sizeof(logInfo));
    
    if (GetProfileStringA("CairOLE Assertions", // section
                          "Log_File",               // key
                          "",             // default value
                          logInfo.pszFileName,              // return buffer
                          MAX_PATH))
    {
        if (lstrcmpA("", logInfo.pszFileName) != 0)
        {
            logInfo.dwDest |= ASSRTLOG_FILE;
        }
    }
    
    if (GetProfileStringA("CairOLE Assertions", // section
                          "Log_NtEventLog",              // key
                          "",             // default value
                          szValue,              // return buffer
                          128))
    {

        logInfo.dwDest |= (lstrcmpiA(szValue, "yes") == 0 )? ASSRTLOG_NTEVENTLOG : 0;
    }
    
    if (logInfo.dwDest)
    {
        gAssertInfo.SetLog(&logInfo);
    }
    
    if (GetProfileStringA("CairOLE Assertions", // section
                          "AssertOnCreate",               // key
                          "",             // default value
                          szValue,              // return   buffer
                          128))
    {
        gAssertOnCreate = FALSE;
    }
    
    
}
//+---------------------------------------------------------------------------
//
//  Function:   CoGetAssertConfig
//
//  Synopsis:   CI for CAssertInfo.  gAssertInfo is a singleton,
//              so just to a QI
//
//  History:    27-Jan-99  MattSmit  Created
//
//----------------------------------------------------------------------------
HRESULT CoGetAssertConfig(REFIID riid, PVOID *ppv)
{
    return gAssertInfo.QueryInterface(riid, ppv);
}

#else

int assertDontUseThisName(void)
{
    return 1;
}

 #endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\buffer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       buffer.cxx
//
//  Contents:   An ASCII text-buffer for outputting to a debug stream
//
//  Classes:	CTextBufferA
//
//  History:    11-Jul-95   t-stevan    Created
//
//
//----------------------------------------------------------------------------
#include <windows.h>
#include "buffer.hxx"

// *** CTextBufferA ***
//+-------------------------------------------------------------------------
//
//  Member:	CTextBufferA::operator<< (const char *)
//
//  Synopsis:	String Insertion operator
//
//  Arguments:	[pStr]  - string to insert into stream
//
//  Returns:	reference to this stream
//
//	Algorithm: 	inserts pStr into buffer, if not enough room, flushes buffer
//
//  History:	11-Jul-95 t-stevan    Created
//
//--------------------------------------------------------------------------
CTextBufferA &CTextBufferA::operator<<(const char *pStr)
{
	char *pszEnd;

	pszEnd = m_szBuffer+cBufferSize;
	
	// copy until we hit a null byte, flushing the buffer as we go if we fill up
	while((*m_pszPos++ = *pStr++) != '\0')
	{
		if(m_pszPos == pszEnd)
		{
			Flush(); // resets m_pszPos
		}
	}

	// we subtract one from m_pszPos because we don't want the null byte
	// to be printed out!
	m_pszPos--;

	return *this;
}

//+-------------------------------------------------------------------------
//
//  Member:	CTextBufferA::Insert
//
//  Synopsis:	Counted String Insertion operator
//
//  Arguments:	[pStr]  - string to insert into stream
//				[nCount] - number of characters  to insert into stream
//
//
//	Algorithm: 	inserts pStr into buffer, if not enough room, flushes buffer
//
//  History:	11-Jul-95 t-stevan    Created
//
//--------------------------------------------------------------------------
void CTextBufferA::Insert(const char *pStr, size_t nCount)
{
	char *pszEnd;

	pszEnd = m_szBuffer+cBufferSize;
	
	// copy until we hit a null byte, flushing the buffer as we go if we fill up
	while(nCount > 0)
	{
		*m_pszPos++ = *pStr++;
		nCount--;

		if(m_pszPos == pszEnd)
		{
			Flush(); // resets m_pszPos
		}
	}
}

//+-------------------------------------------------------------------------
//
//  Member:	CTextBufferA::Revert
//
//  Synopsis:	Revert to a previous state of the buffer, if there have
//				been no flushes since then
//
//	Arguments:  [bc] - a buffer context to retrieve the previous state from
//
//  History:	11-Jul-95 t-stevan    Created
//
//--------------------------------------------------------------------------
BOOL CTextBufferA::Revert(const BufferContext &bc)
{
	if(bc.wRef == m_wFlushes)
	{
		// we haven't flushed since this snapshot, we can revert
		if(((char *) bc.dwContext) < m_szBuffer || ((char *) bc.dwContext) >= (m_szBuffer+cBufferSize))
		{
			return FALSE; // still can't revert, because the pointer is not correct!
		}

		m_pszPos = (char *) bc.dwContext;

		*(m_pszPos+1) = '\0';

		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//              w4vprintf
//              w4dprintf
//              w4vdprintf
//              
//  History:    18-Oct-91   vich        Created
//      
//----------------------------------------------------------------------------

#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN32
int _cdecl w4printf(const char *format, ...);
int _cdecl w4vprintf(const char *format, va_list arglist);
#endif

int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\ccompapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       ccompapi.cxx
//
//  Contents:   common compobj API Worker routines used by com, stg, scm etc
//
//  Classes:
//
//  Functions:
//
//  History:    31-Dec-93   ErikGav     Chicago port
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <ole2sp.h>
#include <ole2com.h>
#include <olesem.hxx>

NAME_SEG(CompApi)
ASSERTDATA

static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
    8, 9, '-', 10, 11, 12, 13, 14, 15};

static const WCHAR wszDigits[] = L"0123456789ABCDEF";

LPVOID WINAPI PrivHeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
BOOL   WINAPI PrivHeapFree (HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);

HANDLE g_hHeap = 0;
HEAP_ALLOC_ROUTINE *pfnHeapAlloc = PrivHeapAlloc;
HEAP_FREE_ROUTINE  *pfnHeapFree  = PrivHeapFree;

//+-------------------------------------------------------------------------
//
//  Function:   PrivHeapAlloc     (internal)
//
//  Synopsis:   Allocate memory from the heap.
//
//  Notes:      This function handles the first call to PrivMemAlloc.
//              This function changes pfnHeapAlloc so that subsequent calls
//              to PrivMemAlloc will go directly to HeapAlloc.
//
//--------------------------------------------------------------------------
LPVOID WINAPI PrivHeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
{
    // Fault in g_hHeap if it's not initialized already via MallocInitialize
    if (g_hHeap == NULL)
    {
        g_hHeap = GetProcessHeap();
        if (g_hHeap == NULL)
        {
            return NULL;
        }
    }

    pfnHeapFree  = HeapFree;
    pfnHeapAlloc = HeapAlloc;
    return HeapAlloc(g_hHeap, dwFlags, dwBytes);
}


//+-------------------------------------------------------------------------
//
//  Function:   PrivHeapFree     (internal)
//
//  Synopsis:   Free memory from the heap.
//
//  Notes:      lpMem should always be zero.  We assume that memory
//              freed via PrivMemFree has been allocated via PrivMemAlloc.
//              The first call to PrivMemAlloc changes pfnHeapFree.
//              Subsequent calls to PrivMemFree go directly to HeapFree.
//              Therefore PrivHeapFree should never be called with a
//              non-zero lpMem.
//
//--------------------------------------------------------------------------
BOOL WINAPI PrivHeapFree (HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
{
    Win4Assert(lpMem == 0 && "PrivMemFree requires PrivMemAlloc.");
    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   wStringFromUUID     (internal)
//
//  Synopsis:   converts UUID into xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//
//  Returns:    Number of characters copied to the buffer.
//
//--------------------------------------------------------------------------
INTERNAL wStringFromUUID(REFGUID rguid, LPWSTR lpsz)
{
    int i;
    LPWSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    for (i = 0; i < sizeof(GuidMap); i++)
    {
	if (GuidMap[i] == '-')
	{
	    *p++ = L'-';
	}
	else
	{
	    *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
	    *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
	}
    }

    *p   = L'\0';

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
static BOOL HexStringToDword(LPCWSTR FAR& lpsz, DWORD FAR& Value,
			     int cDigits, WCHAR chDelim)
{
    int Count;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
	if (*lpsz >= '0' && *lpsz <= '9')
	    Value = (Value << 4) + *lpsz - '0';
	else if (*lpsz >= 'A' && *lpsz <= 'F')
	    Value = (Value << 4) + *lpsz - 'A' + 10;
	else if (*lpsz >= 'a' && *lpsz <= 'f')
	    Value = (Value << 4) + *lpsz - 'a' + 10;
	else
	    return(FALSE);
    }

    if (chDelim != 0)
	return *lpsz++ == chDelim;
    else
	return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) wUUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (!HexStringToDword(lpsz, pguid->Data1, sizeof(DWORD)*2, '-'))
	return FALSE;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
	return FALSE;

    pguid->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
	return FALSE;

    pguid->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))
	return FALSE;

    pguid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[6] = (BYTE)dw;
    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
	return FALSE;

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//  CODEWORK:  these are common with com\class\compapi.cxx ..
//
//--------------------------------------------------------------------------
INTERNAL_(BOOL) wGUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz++ != '{' )
	return FALSE;

    if (wUUIDFromString(lpsz, pguid) != TRUE)
	return FALSE;

    lpsz +=36;

    if (*lpsz++ != '}' )
	return FALSE;

    if (*lpsz != '\0')	 // check for zero terminated string - test bug #18307
    {
	return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wStringFromGUID2     (internal)
//
//  Synopsis:   converts GUID into {...} form without leading identifier;
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------
INTERNAL_(int)  wStringFromGUID2(REFGUID rguid, LPWSTR lpsz, int cbMax)
{
    int i;
    LPWSTR p = lpsz;

    if (cbMax < GUIDSTR_MAX)
	return 0;

    *p++ = L'{';

    wStringFromUUID(rguid, p);

    p += 36;

    *p++ = L'}';
    *p   = L'\0';

    return GUIDSTR_MAX;
}

static const CHAR szDigits[] = "0123456789ABCDEF";
//+-------------------------------------------------------------------------
//
//  Function:   wStringFromGUID2A     (internal)
//
//  Synopsis:   Ansi version of wStringFromGUID2 (for Win95 Optimizations)
//
//  Arguments:  [rguid] - the guid to convert
//              [lpszy] - buffer to hold the results
//              [cbMax] - sizeof the buffer
//
//  Returns:    amount of data copied to lpsz if successful
//              0 if buffer too small.
//
//--------------------------------------------------------------------------

INTERNAL_(int) wStringFromGUID2A(REFGUID rguid, LPSTR lpsz, int cbMax)	// internal
{
    int i;
    LPSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    *p++ = '{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
	if (GuidMap[i] == '-')
	{
	    *p++ = '-';
	}
	else
	{
	    *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
	    *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
	}
    }
    *p++ = '}';
    *p   = '\0';

    return GUIDSTR_MAX;
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatHexNumA
//
//  Synopsis:   Given a value, and a count of characters, translate
//              the value into a hex string. This is the ANSI version
//
//  Arguments:  [ulValue] -- Value to convert
//              [chChars] -- Number of characters to format
//              [pchStr] -- Pointer to output buffer
//
//  Requires:   pwcStr must be valid for chChars
//
//  History:    12-Dec-95 KevinRo Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void FormatHexNumA( unsigned long ulValue, unsigned long chChars, char *pchStr)
{
    while (chChars--)
    {
	pchStr[chChars] = (char) szDigits[ulValue & 0xF];
	ulValue = ulValue >> 4;
    }
}
//+---------------------------------------------------------------------------
//
//  Function:   FormatHexNumW
//
//  Synopsis:   Given a value, and a count of characters, translate
//              the value into a hex string. This is the WCHAR version
//
//  Arguments:  [ulValue] -- Value to convert
//              [chChars] -- Number of characters to format
//              [pwcStr] -- Pointer to output buffer
//
//  Requires:   pwcStr must be valid for chChars
//
//  History:    12-Dec-95 KevinRo Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void FormatHexNumW( unsigned long ulValue, unsigned long chChars, WCHAR *pwcStr)
{
    while (chChars--)
    {
	pwcStr[chChars] = (char) wszDigits[ulValue & 0xF];
	ulValue = ulValue >> 4;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\comsrgt.cxx ===
///+---------------------------------------------------------------------------
//
//  File:       comsrgt.cxx
//
//  Contents:   Implementation of CCOMSurrogate class for synchronizing access
//              to this process's ISurrogate 
//
//  Functions:  all inline -- see the header file
// 
//  History:    21-Oct-96  t-adame        
//
//----------------------------------------------------------------------------

#include <comsrgt.hxx>

LPSURROGATE CCOMSurrogate::_pSurrogate = NULL;
BOOL CCOMSurrogate::_fNewStyleSurrogate = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\dynload.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dynload.cxx
//
//  Contents:   APIs from dynamically loaded system dlls. These APIs
//              are rarely used and there are only 1 or 2 per system
//              Dll so we dynamically load the Dll so that we improve
//              the load time of OLE32.DLL
//
//  Functions:  OleWNetGetConnection
//              OleWNetGetUniversalName
//              OleExtractIcon
//              OleGetShellLink
//              OleSymInitialize
//              OleSymCleanup
//              OleSymGetSymFromAddr
//              OleSymUnDName
//
//  History:    10-Jan-95 Rickhi    Created
//              10-Mar-95 BillMo    Added OleGetShellLink-creates a shortcut object.
//              12-Jul-95 t-stevan  Added OleSym* routines
//              22-Nov-95 MikeHill  Use Unicode IShellLink object in NT.
//
//--------------------------------------------------------------------------
#include    <windows.h>
#include    <shellapi.h>
#include    <imagehlp.h>
#include    <ole2sp.h>
#include    <ole2com.h>

// Entry Points from IMAGEHLP.DLL
HINSTANCE                       hInstIMAGEHLP = NULL;

typedef BOOL (*PFN_SYMINITIALIZE)(HANDLE hProcess, LPSTR UserSearchPath,
                                BOOL fInvadeProcess);
PFN_SYMINITIALIZE pfnSymInitialize = NULL;

#define SYMINITIALIZE_NAME "SymInitialize"

typedef BOOL (*PFN_SYMCLEANUP)(HANDLE hProcess);
PFN_SYMCLEANUP pfnSymCleanup = NULL;

#define SYMCLEANUP_NAME "SymCleanup"

typedef BOOL (*PFN_SYMGETSYMFROMADDR)(HANDLE hProcess,
                                DWORD64 dwAddr, PDWORD64 pdwDisplacement, PIMAGEHLP_SYMBOL64 pSym);
PFN_SYMGETSYMFROMADDR pfnSymGetSymFromAddr64 = NULL;

#define SYMGETSYMFROMADDR_NAME "SymGetSymFromAddr64"

typedef BOOL (*PFN_SYMUNDNAME)(PIMAGEHLP_SYMBOL64 sym, LPSTR lpname, DWORD dwmaxLength);
PFN_SYMUNDNAME pfnSymUnDName64 = NULL;

#define SYMUNDNAME_NAME "SymUnDName64"

//+---------------------------------------------------------------------------
//
//  Function:   LoadSystemProc
//
//  Synopsis:   Loads the specified DLL if necessary and finds the specified
//              entry point.
//
//  Returns:    0: the entry point function ptr is valid
//              !0: the entry point function ptr is not valid
//
//  History:    10-Jan-95   Rickhi      Created
//
//----------------------------------------------------------------------------
BOOL LoadSystemProc(LPSTR szDll, LPCSTR szProc,
                    HINSTANCE *phInst, FARPROC *ppfnProc)
{
    if (*phInst == NULL)
    {

        // Dll not loaded yet, load it now.
        if ((*phInst = LoadLibraryA(szDll)) == NULL)
            return GetLastError();
    }

    // load the entry point
    if ((*ppfnProc = GetProcAddress(*phInst, szProc)) == NULL)
        return GetLastError();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeSystemDLLs
//
//  Synopsis:   Frees any system Dlls that we dynamically loaded.
//
//  History:    10-Jan-95   Rickhi      Created
//
//----------------------------------------------------------------------------
void FreeSystemDLLs()
{
        if(hInstIMAGEHLP != NULL && hInstIMAGEHLP != INVALID_HANDLE_VALUE)
        {
                FreeLibrary(hInstIMAGEHLP);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSymInitialize
//
//  Synopsis:   OLE internal implementation of SymInitialize
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
BOOL OleSymInitialize(HANDLE hProcess,  LPSTR UserSearchPath,
                                                                BOOL fInvadeProcess)
{
    if(hInstIMAGEHLP == (HINSTANCE) -1)
        {
                // we already tried loading the DLL, give up
                return FALSE;
        }

    if (pfnSymInitialize == NULL)
    {
                DWORD rc;

                rc = LoadSystemProc("IMAGEHLP.DLL", SYMINITIALIZE_NAME,
                                  &hInstIMAGEHLP, (FARPROC *)&pfnSymInitialize);
                if (rc != 0)
            {
                hInstIMAGEHLP = (HINSTANCE) -1;
                return FALSE;
                }
    }

    return (pfnSymInitialize)(hProcess, UserSearchPath, fInvadeProcess);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSymCleanup
//
//  Synopsis:   OLE internal implementation of SymCleanup
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
BOOL OleSymCleanup(HANDLE hProcess)
{
    if(hInstIMAGEHLP == (HINSTANCE) -1)
        {
                // we already tried loading the DLL, give up
                return FALSE;
        }

    if (pfnSymCleanup == NULL)
    {
                DWORD rc;

                rc = LoadSystemProc("IMAGEHLP.DLL", SYMCLEANUP_NAME,
                                  &hInstIMAGEHLP, (FARPROC *)&pfnSymCleanup);
                if (rc != 0)
            {
                hInstIMAGEHLP = (HINSTANCE) -1;
                return FALSE;
                }
    }

    return (pfnSymCleanup)(hProcess);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSymGetSymFromAddr
//
//  Synopsis:   OLE internal implementation of SymGetSymFromAddr
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
BOOL OleSymGetSymFromAddr(HANDLE hProcess, DWORD64 dwAddr, PDWORD64 pdwDisplacement, PIMAGEHLP_SYMBOL64 pSym)
{
    if(hInstIMAGEHLP == (HINSTANCE) -1)
        {
                // we already tried loading the DLL, give up
                return NULL;
        }

    if (pfnSymGetSymFromAddr64 == NULL)
    {
                DWORD rc;

                rc = LoadSystemProc("IMAGEHLP.DLL", SYMGETSYMFROMADDR_NAME,
                                  &hInstIMAGEHLP, (FARPROC *)&pfnSymGetSymFromAddr64);
                if (rc != 0)
            {
                hInstIMAGEHLP = (HINSTANCE) -1;
                return NULL;
                }
    }

    return (pfnSymGetSymFromAddr64)(hProcess, dwAddr, pdwDisplacement, pSym);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSymUnDName
//
//  Synopsis:   OLE internal implementation of SymUnDName
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
BOOL OleSymUnDName(PIMAGEHLP_SYMBOL64 pSym, LPSTR lpname, DWORD dwmaxLength)
{
    if(hInstIMAGEHLP == (HINSTANCE) -1)
        {
                // we already tried loading the DLL, give up
                return FALSE;
        }

    if (pfnSymUnDName64 == NULL)
    {
                DWORD rc;

                rc = LoadSystemProc("IMAGEHLP.DLL", SYMUNDNAME_NAME,
                                  &hInstIMAGEHLP, (FARPROC *)&pfnSymUnDName64);
                if (rc != 0)
            {
                hInstIMAGEHLP = (HINSTANCE) -1;
                return FALSE;
            }
    }

    return (pfnSymUnDName64)(pSym, lpname, dwmaxLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\makefile.inc ===
DEST_DIR=$(MAKEDIR)\$(O)

$(DEST_DIR)\rwlock_rpcss.obj:   ..\rwlock.cxx
    $(CXX_COMPILER_NAME)  -Fo"$(DEST_DIR)\rwlock_rpcss.obj" $(USE_FC) $(CXX_COMPILER_FLAGS) -D__NOOLETLS__ ..\rwlock.cxx

$(DEST_DIR)\rwlock_ole32.obj:   ..\rwlock.cxx
    $(CXX_COMPILER_NAME)  -Fo"$(DEST_DIR)\rwlock_ole32.obj" $(USE_FC) $(CXX_COMPILER_FLAGS) ..\rwlock.cxx

$(DEST_DIR)\cmrpcss.lib: $(DEST_DIR)\rwlock_rpcss.obj $(DEST_DIR)\common.lib
        $(LIB_NAME) $(LIBRARIAN_FLAGS)  /out:$@ $**

$(DEST_DIR)\cmole32.lib: $(DEST_DIR)\rwlock_ole32.obj $(DEST_DIR)\common.lib
        $(LIB_NAME) $(LIBRARIAN_FLAGS)  /out:$@ $**

all_common: $(DEST_DIR)\cmrpcss.lib $(DEST_DIR)\cmole32.lib

clean:
          -erase $(DEST_DIR)\rwlock_?????.obj  >NUL 2>NUL
          -erase $(DEST_DIR)\cm?????.lib       >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\oleprint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       oleprint.cxx
//
//  Contents:   printf for API/Method trace
//
//  Functions:  oleprintf
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <stdarg.h>
#include <ole2sp.h>
#include <ole2com.h>
#if DBG==1
#include "outfuncs.h"
#include "oleprint.hxx"

// *** Constants ***
const char *pscTabString = "   "; // 3 space tabs

// *** Types and Enums ***
// Enumeration of basic types
enum
{
    TYP_INT = 0,
    TYP_UNSIGNED,
    TYP_HEX,
    TYP_HEXCAPS,
    TYP_LARGE,
    TYP_BOOL,
    TYP_BOOLCAPS,
    TYP_POINTER,
    TYP_POINTERCAPS,
    TYP_HANDLE,
    TYP_HANDLECAPS,
    TYP_STR,
    TYP_WIDESTR,
    TYP_GUID,
    TYP_STRUCT,
    NO_TYPE
};

// Type of parameter printing functions
typedef void (*ParamFunc) (CTextBufferA &buf, va_list &param,  char *&ppstr);

// Enumeration of Structure types
enum
{
    STRUCT_BIND_OPTS=0,
    STRUCT_DVTARGETDEVICE,
    STRUCT_FORMATETC,
    STRUCT_FILETIME,
    STRUCT_INTERFACEINFO,
    STRUCT_LOGPALETTE,
    STRUCT_MSG,
    STRUCT_OLEINPLACEFRAMEINFO,
    STRUCT_OLEMENUGROUPWIDTHS,
    STRUCT_POINT,
    STRUCT_RECT,
    STRUCT_STGMEDIUM,
    STRUCT_STATSTG,
    STRUCT_SIZE,
    NO_STRUCT
};

// Type of structure printing functions
typedef void (*WriteFunc) (CTextBufferA &buf, void *pParam);

// *** Prototypes ***
// Functions to handle writing out parameters
static void WriteInt(CTextBufferA &buf, va_list &,  char *&);
static void WriteUnsigned(CTextBufferA &buf, va_list &, char *&);
static void WriteHex(CTextBufferA &buf, va_list &, char *&);
static void WriteHexCaps(CTextBufferA &buf, va_list &, char *&);
static void WriteLarge(CTextBufferA &buf, va_list &, char *&);
static void WriteBool(CTextBufferA &buf, va_list &, char *&);
static void WriteBoolCaps(CTextBufferA &buf, va_list &, char *&);
static void WritePointer(CTextBufferA &buf, va_list &, char *&);
static void WritePointerCaps(CTextBufferA &buf, va_list &, char *&);
static void WriteString(CTextBufferA &buf, va_list &, char *&);
static void WriteWideString(CTextBufferA &buf, va_list &, char *&);
static void WriteGUID(CTextBufferA &buf, va_list &, char *&);
static void WriteStruct(CTextBufferA &buf, va_list &, char *&);

// *** Global Data ***
char gPidString[20];

// this table holds the functions for writing base types
static ParamFunc g_pFuncs[] = {WriteInt, WriteUnsigned, WriteHex,
                        WriteHexCaps, WriteLarge, WriteBool,
                        WriteBoolCaps,WritePointer,WritePointerCaps,
                        WriteHex,WriteHexCaps,WriteString,
                        WriteWideString, WriteGUID, WriteStruct,
                        NULL};

// this table starts at 'A' == 65
// This is the base type lookup table -> tells what kind of base type to print out
static const BYTE g_tcLookup[] = {NO_TYPE, TYP_BOOLCAPS, NO_TYPE, TYP_INT, NO_TYPE, // 'A' - 'E'
                            NO_TYPE, NO_TYPE, NO_TYPE, TYP_GUID, NO_TYPE, // 'F' - 'J'
                            NO_TYPE, NO_TYPE, NO_TYPE, NO_TYPE, NO_TYPE, // 'K' - 'O'
                            TYP_POINTERCAPS, NO_TYPE, NO_TYPE, NO_TYPE, NO_TYPE, // 'P' - 'T'
                            TYP_UNSIGNED, NO_TYPE, NO_TYPE, TYP_HEXCAPS, NO_TYPE, // 'U' - 'Y'
                            NO_TYPE, NO_TYPE, NO_TYPE, NO_TYPE, NO_TYPE, // 'Z' - '^'
                            NO_TYPE, NO_TYPE, NO_TYPE, TYP_BOOL, NO_TYPE, // '_' - 'c'
                            TYP_INT, NO_TYPE, NO_TYPE, NO_TYPE, TYP_HANDLE, // 'd' - 'h'
                            NO_TYPE, NO_TYPE, NO_TYPE, TYP_LARGE, NO_TYPE, // 'i' - 'm'
                            NO_TYPE, NO_TYPE, TYP_POINTER, NO_TYPE, NO_TYPE, // 'n' - 'r'
                            TYP_STR, TYP_STRUCT, TYP_UNSIGNED, NO_TYPE, TYP_WIDESTR, // 's' - 'w'
                            TYP_HEX, NO_TYPE, NO_TYPE};                    // 'x' - 'z'

// This holds the functions for writing out structures
static WriteFunc g_pStructFuncs[] = {(WriteFunc) WriteBIND_OPTS, (WriteFunc) WriteDVTARGETDEVICE,
                    (WriteFunc) WriteFORMATETC, (WriteFunc) WriteFILETIME,
                    (WriteFunc) WriteINTERFACEINFO, (WriteFunc) WriteLOGPALETTE,
                    (WriteFunc) WriteMSG, (WriteFunc) WriteOLEINPLACEFRAMEINFO,
                    (WriteFunc) WriteOLEMENUGROUPWIDTHS, (WriteFunc) WritePOINT,
                    (WriteFunc) WriteRECT, (WriteFunc) WriteSTGMEDIUM, (WriteFunc) WriteSTATSTG,
                    (WriteFunc) WriteSIZE, NULL };

// this table starts at 'a' == 97
// this table holds what type of structure to print out
static const BYTE g_structLookup[] = {NO_STRUCT, STRUCT_BIND_OPTS, NO_STRUCT, STRUCT_DVTARGETDEVICE,    // 'a' - 'd'
                                        STRUCT_FORMATETC, STRUCT_FILETIME, NO_STRUCT, NO_STRUCT,        // 'e' - 'h'
                                        STRUCT_INTERFACEINFO, NO_STRUCT, NO_STRUCT, STRUCT_LOGPALETTE,  // 'i' - 'l'
                                        STRUCT_MSG, NO_STRUCT, STRUCT_OLEINPLACEFRAMEINFO, STRUCT_POINT,// 'm' - 'p'
                                        NO_STRUCT, STRUCT_RECT, STRUCT_STGMEDIUM, STRUCT_STATSTG ,     // 'q' - 't'
                                        NO_STRUCT, NO_STRUCT, STRUCT_OLEMENUGROUPWIDTHS, NO_STRUCT,     // 'u' - 'x'
                                        NO_STRUCT, STRUCT_SIZE };                                              // 'y' - 'z'

//+---------------------------------------------------------------------------
//
//  Function:   oleprintf
//
//  Synopsis:  Prints out trace information using a given function, given a
//                 nesting depth (for indenting), an API/Method name, a format string,
//             and a variable number of arguments
//
//  Arguments:     [depth]        - nesting/indentation level
//                 [pscApiName]    - name of API/Method traced
//                 [pscFormat]        - format string
//                 [argptr]        - variable argument list
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void __cdecl oleprintf(int depth, const char *pscApiName, const char *pscFormat, va_list argptr)
{
    // buffer all output so that multithreaded traces look right
    CTextBufferA buf;
    char temp[20];
    char *pscPos;

    // first print out the process id
    buf << gPidString;

    buf << '.';

    // now print out the thread id
    _itoa(GetCurrentThreadId(), temp, 10);

    buf << temp;
    buf << "> ";

    // tab to nesting/indent depth
    while(depth-- > 0)
    {
        buf << pscTabString;
    }

    // now print out API name
    buf << pscApiName;

    // now we are ready to print out what was passed
    pscPos = strchr(pscFormat, '%');

    while(pscPos != NULL)
    {
        // insert the text up to the found '%' character into the buffer
        buf.Insert(pscFormat, (int)(pscPos-pscFormat));

        if(*(pscPos+1) == '%') // this is '%%', we only print one '%' and don't print an argument
        {
            buf << *pscPos;
            pscFormat = pscPos+2;
        }
        else
        {
            BYTE argType = NO_TYPE;

            // advance pscPos to type specifier
            pscPos++;

            // we need to take an argument and handle it
            if(*pscPos >= 'A' && *pscPos <= 'z')
            {
                argType = g_tcLookup[*pscPos- 'A'];
            }

            if(argType != NO_TYPE)
            {
                // handle argument
                // function will advance pscPos past format specifier
                g_pFuncs[argType](buf, argptr, pscPos);
            }
            else
            {
                // assume we've got a one character format specifier
                pscPos++;
                // unknown type, assume size of int
                va_arg(argptr, int);
            }

            // advance search pointer past type specifier
            pscFormat = pscPos;
        }

        pscPos = strchr(pscFormat, '%');
    }

    // print out remainder of string
    buf << pscFormat;

    // destructor will flush buffer for us
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteHex
//
//  Synopsis:  Prints out a lower case hex value
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteHex(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteHexCommon(buf, va_arg(param, unsigned long), FALSE);

    //advance format pointer
    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteHexCaps
//
//  Synopsis:  Prints out an upper case hex value
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteHexCaps(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteHexCommon(buf, va_arg(param, unsigned long), TRUE);

    //advance format pointer
    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteInt
//
//  Synopsis:  Prints out a signed integer value
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteInt(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteIntCommon(buf, va_arg(param, unsigned int), FALSE);

    // advance pointer
    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteUnsigned
//
//  Synopsis:  Prints out a unsigned value, may be 64 bit or 32 bit
//                 depending on next character in format specifier
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteUnsigned(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    switch(*(pFormat+1)) // next character determines type
    {
        case 'd': // 32-bit
        case 'D':
            WriteIntCommon(buf, va_arg(param, unsigned long), TRUE);

            // Advance format pointer
            pFormat+=2;
            break;

        case 'l':  // 64-bit
        case 'L':
            WriteLargeCommon(buf, va_arg(param, __int64 *), TRUE);

            // advance format pointer
            if(*(pFormat+2) == 'd' || *(pFormat+2) == 'D')
            {
                pFormat+=3;
            }
            else
            {
                pFormat+=2;
            }
            break;

        default:
            pFormat++; // assume it's just one char-type specifier
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WritePointer
//
//  Synopsis:  Prints out a lower case pointer value,
//                 checks to make sure pointer is good value
//                 prints out symbol if a symbol maps to pointer
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WritePointer(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    if(*(pFormat+1) != 'p')
    {
        WritePointerCommon(buf, va_arg(param, void *), FALSE, FALSE, FALSE);
        pFormat++;
    }
    else
    {
        void **pPointer = NULL;
        BufferContext bc;

        // take snapshot of buffer
        buf.SnapShot(bc);

        // write pointer to pointer
        // first validate this pointer
        __try
        {
            pPointer = va_arg(param, void **);

            WritePointerCommon(buf, *pPointer, FALSE, FALSE, FALSE);
        }
        __except(ExceptionFilter(_exception_code()))
        {
            // try to revert buffer
            buf.Revert(bc);

            WritePointerCommon(buf, pPointer, FALSE, TRUE, FALSE);
        }

        pFormat +=2;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WritePointerCaps
//
//  Synopsis:  Prints out an upper case pointer value,
//                 checks to make sure pointer is good value
//                 prints out symbol if a symbol maps to pointer
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WritePointerCaps(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WritePointerCommon(buf, va_arg(param, void *), TRUE, FALSE, FALSE);

    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteLarge
//
//  Synopsis:  Prints out a 64-bit integer
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteLarge(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteLargeCommon(buf, va_arg(param, __int64 *), FALSE);

    if(*(pFormat+1) == 'd' || *(pFormat+1) == 'D')
    {
        pFormat+=2;
    }
    else
    {
        pFormat++;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteBool
//
//  Synopsis:  Prints out a lower case boolean value
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteBool(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteBoolCommon(buf, va_arg(param, BOOL), FALSE);

    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteBoolCaps
//
//  Synopsis:  Prints out an upper case boolean value
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteBoolCaps(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteBoolCommon(buf, va_arg(param, BOOL), TRUE);

    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteString
//
//  Synopsis:  Prints out an ASCII string
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteString(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteStringCommon(buf, va_arg(param, const char *));

    // Advance format pointer
    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteWideString
//
//  Synopsis:  Prints out a UNICODE string, but only supports ASCII characters
//                 if character > 256 is encountered, an "unprintable character" char
//                 is printed
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteWideString(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteWideStringCommon(buf, va_arg(param, const WCHAR *));

    // Advance format pointer
    if(*(pFormat+1) == 's')
    {
        pFormat+=2;
    }
    else
    {
        pFormat++;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteGUID
//
//  Synopsis:  Prints out a GUID
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteGUID(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    WriteGUIDCommon(buf, va_arg(param, GUID *));

    // Advance format pointer
    pFormat++;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteStuct
//
//  Synopsis:  Prints out a structure. If structure expansion is enabled
//                 expands the structure depending on it's type
//
//  Arguments:  [buf]      - reference to text buffer to write text to
//                 [param]    - reference to variable argument list
//                 [pFormat]       - reference to a char * to the format string,
//                                 used to advance string past specifier string
//
//      Returns:    nothing
//
//  History:    11-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteStruct(CTextBufferA &buf, va_list &param, char *&pFormat)
{
    void *pArg;
    BYTE bType = NO_STRUCT;

    pArg = va_arg(param, void *);

    if(*(pFormat+1) >= 'a' && *(pFormat+1) <= 'z')
    {
        bType = g_structLookup[*(pFormat+1) - 'a'];
    }

    if(bType != NO_STRUCT) // only print out known structures
    {
        BufferContext bc;

        buf.SnapShot(bc); // take a snapshot of the buffer

        __try
        {
            g_pStructFuncs[bType](buf, pArg);
        }
        __except (ExceptionFilter(_exception_code()))
        {
            buf.Revert(bc);                // try to revert to the old buffer

            // bad pointer
            WritePointerCommon(buf, pArg, FALSE, TRUE, FALSE);
        }
    }
    else
    {
        // write out the pointer
        WritePointerCommon(buf, pArg, FALSE, FALSE, FALSE);
    }

    // increment format pointer
    pFormat += 2;
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\eqguid.cxx ===
#define _SYS_GUID_OPERATORS_
#include  <windows.h>
#include  <ole2.h>
#include  <stdlib.h>

//+-------------------------------------------------------------------------
//
//  Function:	IsEqualGUID  (public)
//
//  Synopsis:	compares two guids for equality
//
//  Arguments:	[guid1]	- the first guid
//		[guid2] - the second guid to compare the first one with
//
//  Returns:	TRUE if equal, FALSE if not.
//
//  Note:
//      Only reason we have this function is because we exported it originally
//      from OLE32.DLL and forgot to take it out when we made it an inline
//      function in objbase.h.  Somebody out there may be relying on it being
//      available.  Internally we must use wIsEqualGUID.
//
//--------------------------------------------------------------------------
#if _MSC_VER < 1200
#undef IsEqualGUID  // undo the #define in objbase.h
extern "C" BOOL  __stdcall IsEqualGUID(GUID &guid1, GUID &guid2)
{
   return (
      ((PLONG) &guid1)[0] == ((PLONG) &guid2)[0] &&
      ((PLONG) &guid1)[1] == ((PLONG) &guid2)[1] &&
      ((PLONG) &guid1)[2] == ((PLONG) &guid2)[2] &&
      ((PLONG) &guid1)[3] == ((PLONG) &guid2)[3]);
}
#endif

#if 0
//+-------------------------------------------------------------------------
//
//  Function:	wIsEqualGUID  (internal)
//
//  Synopsis:	compares two guids for equality
//
//  Arguments:	[guid1]	- the first guid
//		[guid2] - the second guid to compare the first one with
//
//  Returns:	TRUE if equal, FALSE if not.
//
//--------------------------------------------------------------------------

BOOL  __fastcall wIsEqualGUID(REFGUID guid1, REFGUID guid2)
{
   return (
      ((PLONG) &guid1)[0] == ((PLONG) &guid2)[0] &&
      ((PLONG) &guid1)[1] == ((PLONG) &guid2)[1] &&
      ((PLONG) &guid1)[2] == ((PLONG) &guid2)[2] &&
      ((PLONG) &guid1)[3] == ((PLONG) &guid2)[3]);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\outfuncs.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       outfuncs.cxx
//
//  Contents:   functions for log/trace output
//
//  Functions:  AddOutputFunction
//              DelOutputFunction
//              CallOutputFunctions
//
//  History:    09-Jan-96   murthys    Created
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdarg.h>
#include <tchar.h>
#if DBG==1
#include "outfuncs.h"

// *** Global Data ***
static StringOutFunc debugscrfn = (StringOutFunc)OutputDebugStringA;
StringOutFunc gpfunc[BUFFER_MAX_FUNCTIONS] = {
                                                (StringOutFunc)OutputDebugStringA,
                                                NULL
                                             };
HANDLE ghLogFile = INVALID_HANDLE_VALUE;
CRITICAL_SECTION g_LogFileCS;
BOOL g_LogFileLockValid = FALSE;

//+---------------------------------------------------------------------------
//
//  Function:   AddOutputFunction
//
//  Synopsis:
//
//  Arguments:  [pfunc] --
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void AddOutputFunction(StringOutFunc pfunc)
{
    int i, at = -1;

    for (i = 0; i < BUFFER_MAX_FUNCTIONS; i++)
    {
        if ((at == -1) && (gpfunc[i] == NULL))
        {
            at = i; // Insert it here
        }
        else
        {
            if (gpfunc[i] == pfunc) // check for dups
            {
                return;
            }
        }
    }
    if (at != -1)
    {
        gpfunc[at] = pfunc;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DelOutputFunction
//
//  Synopsis:
//
//  Arguments:  [pfunc]
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DelOutputFunction(StringOutFunc pfunc)
{
    int i;

    for (i = 0; i < BUFFER_MAX_FUNCTIONS; i++)
    {
        if (gpfunc[i] == pfunc)
        {
            gpfunc[i] = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CallOutputFunctions
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CallOutputFunctions(const char *buffer)
{
    int i;

    for (i = 0; i < BUFFER_MAX_FUNCTIONS; i++)
    {
        if (gpfunc[i] != NULL)
        {
            gpfunc[i](buffer);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteToDebugScreen
//
//  Synopsis:
//
//  Arguments:  [flag] - TRUE/FALSE to turn ON/OFF
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void WriteToDebugScreen(BOOL flag)
{
    if (flag)
    {
        AddOutputFunction(debugscrfn);
    }
    else
    {
        DelOutputFunction(debugscrfn);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteToLogFile
//
//  Synopsis:
//
//  Arguments:  [logfile] - path of file to write to
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void WriteToLogFile(LPCTSTR lpfn)
{
    if (!g_LogFileLockValid)
        return;

    EnterCriticalSection(&g_LogFileCS);

    if (ghLogFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(ghLogFile);
        DelOutputFunction(OutputLogFileA);
        ghLogFile = INVALID_HANDLE_VALUE;
    }
    if ((lpfn) && (lpfn[0] != _TEXT('\0')))
    {
        SECURITY_ATTRIBUTES sattr;

        sattr.nLength = sizeof(sattr);
        sattr.lpSecurityDescriptor = NULL;
        sattr.bInheritHandle = FALSE;

        ghLogFile = CreateFile(lpfn, GENERIC_READ|GENERIC_WRITE,
                               FILE_SHARE_READ|FILE_SHARE_WRITE,
                               &sattr, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (ghLogFile == INVALID_HANDLE_VALUE)
        {
            OutputDebugStringA("OLE (WriteToLogFile):Unable to open log file!\n");
        }
        else
        {
            AddOutputFunction(OutputLogFileA);
        }
    }

    LeaveCriticalSection(&g_LogFileCS);
}

//+---------------------------------------------------------------------------
//
//  Function:   OutputLogFileA
//
//  Synopsis:
//
//  Arguments:  [buf] - NULL terminated ANSI string to write
//
//  Returns:
//
//  History:    09-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void OutputLogFileA(const char *buf)
{
    DWORD dwtowrite = (DWORD) strlen(buf);
    DWORD dwwritten;
    LONG loffhigh = 0, lofflow;

    if (!g_LogFileLockValid)
        return;

    EnterCriticalSection(&g_LogFileCS);
    // Goto EOF, Lock, Write and Unlock
    lofflow = (LONG) SetFilePointer(ghLogFile, 0, &loffhigh, FILE_END);
    LockFile(ghLogFile, lofflow, loffhigh, dwtowrite, 0);
    WriteFile(ghLogFile, buf, dwtowrite, &dwwritten, NULL);
    UnlockFile(ghLogFile, lofflow, loffhigh, dwtowrite, 0);
    LeaveCriticalSection(&g_LogFileCS);
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenDebugSinks()
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    26-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void OpenDebugSinks()
{
        // Get LogFile name
        char tmpstr[MAX_PATH];
        DWORD cbtmpstr = sizeof(tmpstr);
        LPTSTR lptstr;

        NTSTATUS status = RtlInitializeCriticalSection(&g_LogFileCS);
        g_LogFileLockValid = NT_SUCCESS(status);
        if (!g_LogFileLockValid)
            return;

        GetProfileStringA("CairOLE InfoLevels", // section
                          "LogFile",               // key
                          "",             // default value
                          tmpstr,              // return buffer
                          cbtmpstr);
        if (tmpstr[0] != '\0')
        {
            // convert ansi to unicode
            WCHAR wtmpstr[MAX_PATH];

            lptstr = wtmpstr;
            if (MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, tmpstr, -1, wtmpstr, MAX_PATH))
            {
                WriteToLogFile(lptstr);
            }
            else
            {
                OutputDebugStringA("OLE32: MultiByteToWideChar failed for logfile!\n");
            }
        }

        // See if Debug Screen should be turned off
        GetProfileStringA("CairOLE InfoLevels", // section
                          "DebugScreen",               // key
                          "Yes",             // default value
                          tmpstr,              // return buffer
                          cbtmpstr);
        if ((tmpstr[0] == 'n') || (tmpstr[0] == 'N'))
        {
            WriteToDebugScreen(FALSE);  // turn off output to debugger screen
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   CloseDebugSinks()
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    26-Jan-96   murthys   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CloseDebugSinks()
{
        // close log file (if any)
        WriteToLogFile(NULL);
		
        if (g_LogFileLockValid)
        {
            DeleteCriticalSection(&g_LogFileCS);
        }
}
#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\lockperf.cxx ===
//+-----------------------------------------------------------------------------
//
//  File:       lockperf.cxx
//
//  Contents:   Implementation of lock monitoring for locks used by ole32.dll
//
//  Classes:    CLockPerfTracker
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
#if LOCK_PERF==1

#include <ole2int.h>
#include <lockperf.hxx>

// gbLockPerf == (Is lock monitoring ON?) 
// (It is possible to turn this on & off multiple times during a single test run.)
// Ideally, it would be good to turn it OFF after proc-attach, let the test
// run for a while and then turn it ON. This will get the startup skew out of
// the way.
BOOL gbLockPerf = TRUE;

// Lock perf tracker. Gathers perf measurements for all locks.
CLockPerfTracker gLockTracker;    

// static member table of the global tracker class.
CFileLineEntry CLockPerfTracker::_FileLineData[MAX_LOCKPERF_FILEENTRY];

// static member table of the global tracker: this keeps a track of shared time.
CLockEntry CLockPerfTracker::_LockData[MAX_LOCKS];

// counts of locks & {file,line} instances tracked.
ULONG CLockPerfTracker::_numLocks;
ULONG CLockPerfTracker::_numCritSecs;

// perf frequency on the system
LARGE_INTEGER CLockPerfTracker::_liFreq;

//Flagged if tables get full
BOOL    gbLockPerfOverflow=FALSE;

//Count of entries in the shared table (code critical sections)
LONG    glFileLine = 0;

//Strings to used to print report
LPSTR   gszLockPerfErr = "##### Error: LockPerfOverFlow!!";
char    gszLockPerfBuf[256];

//Used to debug the perf monitoring code.
#define perfPrint(x)
#if DBG==1
#define LockAssert(X)   if (!(X)) wsprintfA(gszLockPerfBuf,#X ## "\n"),OutputDebugStringA(gszLockPerfBuf);
#else
#define LockAssert(X)
#endif




// **** Functions to manage the Private TLS used by LockPerf *********

// Heap Handle (copied from tls.cxx)
extern  HANDLE    g_hHeap;
#define HEAP_SERIALIZE 0

DWORD gTlsLockPerfIndex = 0xFFFFFFFF;

//345678901234567890123456789012345678901234567890123456789012345678901234567890
//+-----------------------------------------------------------------------------
//
//  Function:   AllocLockPerfPvtTlsData
//
//  Synopsis:   Allocates the Tls data for a thread (at Thread_Attach)
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------

HRESULT AllocLockPerfPvtTlsData()
{
    void *pMem =  HeapAlloc(g_hHeap, 
                            HEAP_SERIALIZE, 
                            TLS_LOCKPERF_MAX*sizeof(CTlsLockPerf));
    if (!pMem)
    {
        LockAssert(!"Could not alloc private Tls data for LockPerf");
        return E_OUTOFMEMORY;
    }
    LockAssert(gTlsLockPerfIndex!=0xFFFFFFFF);
    memset(pMem, 0, TLS_LOCKPERF_MAX*sizeof(CTlsLockPerf));
    
    TlsSetValue(gTlsLockPerfIndex, pMem);
    return S_OK;
}

//+-----------------------------------------------------------------------------
//
//  Function:   FreeLockPerfPvtTlsData
//
//  Synopsis:   Frees the Tls data for a thread (at Thread_Detach)
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
//  REVIEW: What about cases when DllMain is not called with Thread_Detach?

void FreeLockPerfPvtTlsData()
{
    LockAssert(gTlsLockPerfIndex!=0xFFFFFFFF);
    void *pMem = TlsGetValue(gTlsLockPerfIndex); 
    if (pMem) 
    {
        HeapFree(g_hHeap, HEAP_SERIALIZE, pMem);
    }
}

//**** End: TLS functions ********************************************

//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::Init(), public
//
//  Synopsis:   Initializes lock perf data, marking entries as unused.
//              Called during Proc_Attach
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------

HRESULT CLockPerfTracker::Init()
{
    QueryPerformanceFrequency(&_liFreq);
    
    // We use lpLockPtr to tell if an entry in these tables is in-use.
    for (int i=0;i<MAX_LOCKPERF_FILEENTRY;i++)
    {
        _FileLineData[i].lpLockPtr = NULL;
    }
    for (i=0; i<MAX_LOCKS; i++)
    {
        _LockData[i].lpLockPtr = NULL;
    }
    _numLocks = 0;
    _numCritSecs = 0;
    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::RegisterLock(), public
//
//  Synopsis:   Must be called by the lock creation function. 
//                  lpLockPtr   == this-ptr of the lock (or unique ptr)
//                  bReadWrite  == TRUE for Reader-Writer Locks.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------

void CLockPerfTracker::RegisterLock(void *lpLockPtr, BOOL bReadWrite)
{
    BOOL bDone = FALSE;
    int i=0;
    
    while (!bDone)
    {
        while (_LockData[i].lpLockPtr)
        {
            i++;
        }
        LockAssert(i < MAX_LOCKS);
        
        // REVIEW: 64-bit implications of this cast?
        bDone = !(InterlockedCompareExchange((LONG *)&_LockData[i].lpLockPtr, 
                                             (LONG)lpLockPtr, 
                                             NULL));
    }

    _LockData[i].dwTotalWriteWaitTime = 0;
    _LockData[i].dwTotalWriteEntrys = 0;       
    _LockData[i].dwTotalWriteLockTime = 0;
    _LockData[i].pszLockName = NULL;
    
    // REVIEW: These 5 could be skipped for non reader-writer locks?
   _LockData[i].dwSharedTime = 0;
   _LockData[i].dwNumReaders = 0;

   _LockData[i].dwTotalReadWaitTime = 0;
   _LockData[i].dwTotalReadLockTime = 0;
   _LockData[i].dwTotalReadEntrys = 0; 
        
}

//+-----------------------------------------------------------------------------
//
//  Function:   Hash
//
//  Synopsis:   Maps line #s to index in the perf data table.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
ULONG Hash (ULONG line)
{
    //  buckets of 256, 128, 64, 64 totaling to MAX_LOCKPERF_FILEENTRY
    //  this was based on a grep in Ole32 tree for LOCK macro (Sep98):
    //  Call counts: 
    //                              137 from   1 - 1024
    //                              92 from 1024 - 2048
    //                              45 from 2048 - 3072
    //                              28 from 3072 - 4096
    //                              10 from 4096 - 5120
    //                              11 from 5124 - 6144
    //                               8 from 6148 - 7168
    //  highest lineNum was 6872 in marshal.cxx
    //  The Hash function & array size may need updating if the highest lineNum
    //  goes beyond 7176 or if any bucket gets maxed out.

    ULONG base, offset;
    if (line < 1024)
    {
        base = 0;
        offset = line>>2;           //0 to 255
    }
    else if (line < 2048)
    {
        base = 256;
        offset = (line-1024)>>3;    //0 to 127
    }
    else if (line < 3072)
    {
        base = 384;
        offset = (line-2048)>>4;    //0 to 63
    }
    else
    {      //this covers lines from 3072 to 7168
        base = 448;
        offset = (line-3072)>>6;    //0 to 63
    }
    return base+offset;
}



//+-----------------------------------------------------------------------------
//
//  Function:   GetTlsLockPerfEntry
//
//  Synopsis:   Finds the entry in Tls for a lock or returns a free entry
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
CTlsLockPerf *GetTlsLockPerfEntry(void *lpLockPtr)
{
    CTlsLockPerf *lpEntry = NULL, *lpFree = NULL;
    
    CTlsLockPerf *lpCurrent = (CTlsLockPerf *)TlsGetValue(gTlsLockPerfIndex);
    for (int i=0; i<TLS_LOCKPERF_MAX; i++)
    {
        if (lpCurrent->_dwFlags & TLS_LOCKPERF_INUSE)
        {
            if (lpCurrent->_lpLockPtr == lpLockPtr)
            {
                lpEntry = lpCurrent;
                break;
            }
        }
        else if (!lpFree)
        {
            // Remember the first free entry in case we need it.
            lpFree = lpCurrent;
        }
        lpCurrent++;
    }
    return (lpEntry!=NULL) ? lpEntry : lpFree;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::ReaderWaiting(), public
//
//  Synopsis:   Called by the lock code when a thread attempts to enter
//              a critical section for reading.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::ReaderWaiting(const char*pszFile, 
                                     DWORD dwLine, 
                                     const char* pszLockName, 
                                     void *lpLockPtr)
{
    if (gbLockPerf)
    {
        // Just call WriterWaiting till we need different semantics...
        WriterWaiting(pszFile, 
                      dwLine, 
                      pszLockName, 
                      lpLockPtr, FALSE /*bWriter*/);
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::WriterWaiting(), public
//
//  Synopsis:   Called by the lock code when a thread attempts to enter
//              a critical section for writing.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::WriterWaiting(const char*pszFile, 
                                     DWORD dwLine, 
                                     const char* pszLockName, 
                                     void *lpLockPtr, 
                                     BOOL bWriter /*default TRUE*/)
{
    if (gbLockPerf)
    {  
        CTlsLockPerf *pTlsLP = GetTlsLockPerfEntry(lpLockPtr);

        // Will assert if we are getting more than TLS_LOCKPERF_MAX
        // locks one after another without releasing any.
        LockAssert(pTlsLP);    
    
        if (pTlsLP->_dwFlags & TLS_LOCKPERF_INUSE)         
        {   
            // Recursion on the lock. Request for the lock while holding it.
            // Can't be waiting recursively!
            LockAssert(pTlsLP->_dwFlags & TLS_LOCKPERF_ENTERED); 
        }
        else
        {
            ULONG idx;
            ULONG loc = FindOrCreateFileTableEntry(pszFile, 
                                                   dwLine, 
                                                   pszLockName, 
                                                   lpLockPtr, 
                                                   bWriter, 
                                                   &idx);

            LockAssert(loc <  MAX_LOCKPERF_FILEENTRY);
    
            //save table indices in TLS, for quick access later.
            pTlsLP->_loc = loc;
            pTlsLP->_idx = idx;
            pTlsLP->_lpLockPtr = lpLockPtr;
            pTlsLP->_dwFlags = TLS_LOCKPERF_WAITING | TLS_LOCKPERF_INUSE; //new Tls entry!
            pTlsLP->_dwRecursion = 0;   //we set this to 1 upon the first xxxEntered
    
            //store request time in TLS (last thing done to not skew lock wait/use times)
            QueryPerformanceCounter(&pTlsLP->_liRequest);
        }
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::ReaderEntered(), public
//
//  Synopsis:   Called by lock code when a thread is granted access to 
//              a critical section for reading. 
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
//  REVIEW: Life will be easier for us if we enforce that the lock code 
//  must detect and inform if this is the first reader in the critical 
//  section. (Similarly for the last reader leaving.)
//------------------------------------------------------------------------------
void CLockPerfTracker::ReaderEntered(const char*pszFile, 
                                     DWORD dwLine, 
                                     const char* pszLockName, 
                                     void *lpLockPtr)
{  
    if (gbLockPerf)
    {
        ULONG idx = FindLockTableEntry(lpLockPtr);    
        if (InterlockedIncrement((LONG*)&_LockData[idx].dwNumReaders)==1)
        {
            QueryPerformanceCounter(&_LockData[idx].liEntered);
        }
        // rest of the work is done by WriterEntered
        WriterEntered(pszFile, dwLine, pszLockName, lpLockPtr, /*bWriter*/ FALSE);
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::WriterEntered(), public
//
//  Synopsis:   Called by lock code when a thread is granted access to 
//              a critical section for writing.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::WriterEntered(const char*pszFile, 
                                     DWORD dwLine, 
                                     const char* pszLockName, 
                                     void *lpLockPtr, 
                                     BOOL bWriter /*default TRUE*/)
{
    if (gbLockPerf)
    {
        CTlsLockPerf *pTlsLP = GetTlsLockPerfEntry(lpLockPtr);
    
        /*
        // REVIEW: Should we force lock implementation to call ReaderWaiting/WriterWaiting
        // even if there is no reason to wait? In that case the following assertion is true.
        
        // There has to be an entry, either marked waiting or entered (recursive lock)
        LockAssert( pTlsLP && ((pTlsLP->_dwFlags & TLS_LOCKPERF_WAITING) ||  (pTlsLP->_dwFlags & TLS_LOCKPERF_ENTERED)) );
        */

        if (!(pTlsLP->_dwFlags & TLS_LOCKPERF_INUSE))
        {
            // Someone called xxxEntered directly (without calling xxxWaiting)
            ULONG idx;
            ULONG loc = FindOrCreateFileTableEntry(pszFile, 
                                                   dwLine, 
                                                   pszLockName, 
                                                   lpLockPtr, 
                                                   bWriter, 
                                                   &idx);
            LockAssert(loc <  MAX_LOCKPERF_FILEENTRY);
    
            // save the table indices in TLS, for quick access later.
            pTlsLP->_loc = loc;
            pTlsLP->_idx = idx;
            pTlsLP->_lpLockPtr = lpLockPtr;
            pTlsLP->_dwFlags = TLS_LOCKPERF_ENTERED | TLS_LOCKPERF_INUSE;
            pTlsLP->_dwRecursion = 0;
    
            QueryPerformanceCounter(&pTlsLP->_liEntered);
            pTlsLP->_liRequest = pTlsLP->_liEntered;
        }
        else if (pTlsLP->_dwFlags & TLS_LOCKPERF_WAITING)
        {
            QueryPerformanceCounter(&pTlsLP->_liEntered);
            // Not waiting any more.
            pTlsLP->_dwFlags |= TLS_LOCKPERF_ENTERED;
            pTlsLP->_dwFlags &= ~TLS_LOCKPERF_WAITING;
        }
        pTlsLP->_dwRecursion++; // 1 means first level entry (i.e. no recursion)
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::ReaderLeaving(), public
//
//  Synopsis:   Called by the lock code when a reader is leaving a critical
//              section.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::ReaderLeaving(void *lpLockPtr)
{
    if (gbLockPerf)
    {
        ULONG idx = FindLockTableEntry(lpLockPtr);
    
        LARGE_INTEGER liEntered = _LockData[idx].liEntered;
        if (InterlockedDecrement((LONG*)&_LockData[idx].dwNumReaders) == 0)
        {   
            // Last reader leaving 
            LARGE_INTEGER liDelta, liRem;
            QueryPerformanceCounter(&liDelta);
        
            liDelta = RtlLargeIntegerSubtract(liDelta, liEntered);
            liDelta = RtlExtendedIntegerMultiply(liDelta,1000000);
            liDelta = RtlLargeIntegerDivide(liDelta, _liFreq, &liRem);
        
            LockAssert(liDelta.HighPart == 0); // no one must hold a lock for so long!
            
            // This must be done inter-locked in case someother thread does 
            // a 0->1, 1->0 transition while one thread is in this block.
            InterlockedExchangeAdd((LONG*)&_LockData[idx].dwSharedTime, 
                                   liDelta.LowPart);
        }
    
        //Call WriterLeaving to do the rest.
        WriterLeaving(lpLockPtr);
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::WriterLeaving(), public
//
//  Synopsis:   Called by the lock code when a writer is leaving a critical
//              section.  
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::WriterLeaving(void *lpLockPtr)
{
    if (gbLockPerf)
    {    
        CTlsLockPerf *pTlsLP = GetTlsLockPerfEntry(lpLockPtr); 
    
        // There has be to an entry marked entered!
        LockAssert(pTlsLP && (pTlsLP->_dwFlags & TLS_LOCKPERF_ENTERED));
    
        pTlsLP->_dwRecursion--;
    
        if (pTlsLP->_dwRecursion == 0)
        {   
            // The thread is *really* leaving the lock. Do the math!
            LARGE_INTEGER liUnlockTime;
            QueryPerformanceCounter(&liUnlockTime);
            UpdateFileTableEntry(pTlsLP, &liUnlockTime);
            
            // Mark the Tls entry as free.
            pTlsLP->_dwFlags &= ~TLS_LOCKPERF_INUSE;
        }
        else
        {
            // The thread is still in the lock!
            LockAssert(pTlsLP->_dwFlags & TLS_LOCKPERF_ENTERED);
        }
    }
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::ReportContention(), public
//
//  Synopsis:   Must be called by the lock destroy/cleanup function.
//              This is single threaded by definition.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------

void CLockPerfTracker::ReportContention(void *lpLockPtr, 
                                        DWORD dwWriteEntrys, 
                                        DWORD dwWriterContention, 
                                        DWORD dwReadEntrys, 
                                        DWORD dwReaderContention)
{
    // This happens during DLL_PROCESS_DETACH hence single-threaded
    for (int i=0; i<MAX_LOCKS; i++)
    {
        if (_LockData[i].lpLockPtr == lpLockPtr)
        {
            _LockData[i].dwWriterContentionCount = dwWriterContention;
            _LockData[i].dwReaderContentionCount = dwReaderContention;

            // These asserts may not be very useful since some locks are entered 
            // before lock monitoring can be started! Also, monitoring can be
            // turned OFF and ON in windows.

            // LockAssert( _LockData[i].dwTotalWriteEntrys ==  dwWriteEntrys);
            // LockAssert( _LockData[i].dwTotalReadEntrys ==  dwReadEntrys);
            break;
        }
    }
    LockAssert( i<MAX_LOCKS );
}

//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::FindLockTableEntry(), private
//
//  Synopsis:   Finds the entry for a critical section in the lock table.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
ULONG CLockPerfTracker::FindLockTableEntry(void *lpLockPtr)
{
    for (int idx=0; idx<MAX_LOCKS; idx++)
    {
        if (_LockData[idx].lpLockPtr == lpLockPtr)
        {
            return idx;
        }
    }
    LockAssert(!"Lock not registered for monitoring!");
    return MAX_LOCKS-1; // just to avoid AVs
}

//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::FindOrCreateFileTableEntry(), private
//
//  Synopsis:   Finds the entry (or creates one) for a critical section guarded
//              by a lock at a {file, line}.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
ULONG CLockPerfTracker::FindOrCreateFileTableEntry(const char*pszFile, 
                                                   DWORD dwLine, 
                                                   const char* pszLockName, 
                                                   void *lpLockPtr, 
                                                   BOOL bWriter, 
                                                   DWORD *lpLockTableIndex)
{
    BOOL bFoundEntry = FALSE;
    CFileLineEntry *pNewTableEntry  = NULL;
    ULONG loc = Hash(dwLine);

    if (loc >= MAX_LOCKPERF_FILEENTRY)
    {
        LockAssert(!"Lock PerfTable full! Increase size.");
        gbLockPerfOverflow = TRUE;
        loc = MAX_LOCKPERF_FILEENTRY-1;
        goto errRet;
    }

    // If hashing works well this should not take too much time.

    while (!bFoundEntry)
    {
        while (_FileLineData[loc].lpLockPtr && loc<MAX_LOCKPERF_FILEENTRY)
        {
            if ( (_FileLineData[loc].dwLine==dwLine)
                 &&(_FileLineData[loc].pszFile==pszFile) )
            {
                bFoundEntry = TRUE;
                break;  //done
            }
            loc++;
        }
    
        if (loc >= MAX_LOCKPERF_FILEENTRY)
        {
            gbLockPerfOverflow = TRUE;
            loc = MAX_LOCKPERF_FILEENTRY-1;
            goto errRet;
        }
    
        if (!bFoundEntry && !( InterlockedCompareExchange(
                                    (LONG*)&_FileLineData[loc].lpLockPtr, 
                                    (LONG)lpLockPtr, 
                                    NULL) )
           )
        {
            // We are seeing a new critical section in the code base
            bFoundEntry = TRUE;
            pNewTableEntry = &_FileLineData[loc];
            InterlockedIncrement(&glFileLine); // Global count of code CritSec locations
        }
    }

    if (pNewTableEntry)
    {  // finish rest of initialization the entry is secured for this code location.
        // REVIEW: Ignoring races here.
        pNewTableEntry->bWriteCritSec   = bWriter;
        pNewTableEntry->dwNumEntrys     = 0;
        pNewTableEntry->pszLockName     = pszLockName;
        pNewTableEntry->pszFile         = pszFile;
        pNewTableEntry->dwLine          = dwLine;
        pNewTableEntry->dwWaitTime      = 0;
        pNewTableEntry->dwLockedTime    = 0;
        pNewTableEntry->ulLockTableIdx = FindLockTableEntry(lpLockPtr);
    }
errRet:
    *lpLockTableIndex = _FileLineData[loc].ulLockTableIdx;
    return loc;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::UpdateFileTableEntry(), private
//
//  Synopsis:   Adds the waiting time and the locked time for this visit
//              to the cumulative data for the {file,line} entry.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::UpdateFileTableEntry(CTlsLockPerf *pTlsEntry, 
                                            LARGE_INTEGER *pliUnlockTime)
{
    LockAssert( (pTlsEntry->_dwFlags & TLS_LOCKPERF_INUSE)
                && (pTlsEntry->_dwFlags & TLS_LOCKPERF_ENTERED) );

    ULONG idx = pTlsEntry->_idx;
    ULONG loc = pTlsEntry->_loc;

    LockAssert(loc>=0 && loc < MAX_LOCKPERF_FILEENTRY);

    LARGE_INTEGER liRem;

    LARGE_INTEGER liWait = RtlLargeIntegerSubtract(pTlsEntry->_liEntered, 
                                                   pTlsEntry->_liRequest);
    liWait = RtlExtendedIntegerMultiply(liWait,1000000);        
    liWait = RtlLargeIntegerDivide(liWait,_liFreq,&liRem); // liWait is now in micro-seconds

    LockAssert(liWait.HighPart == 0);  // hopefully no one waits for so long!!

    LARGE_INTEGER liLocked = RtlLargeIntegerSubtract(*pliUnlockTime, 
                                                     pTlsEntry->_liEntered);
    liLocked = RtlExtendedIntegerMultiply(liLocked,1000000);
    liLocked = RtlLargeIntegerDivide(liLocked, _liFreq, &liRem);

    LockAssert(liLocked.HighPart == 0); // no one must hold a lock for so long!

    if (_FileLineData[loc].bWriteCritSec)
    {   // Since this is a write location, the lock itself guarantees exclusion
        _FileLineData[loc].dwNumEntrys++;
        _FileLineData[loc].dwWaitTime += liWait.LowPart;  
        _FileLineData[loc].dwLockedTime += liLocked.LowPart;

        /*
        This needs to be here if we wish to compare entry counts reported by
        the lock with our own. For now this is in ProcessPerfData
        _LockData[idx].dwTotalWriteEntrys++;
        _LockData[idx].dwTotalWriteWaitTime += liWait.LowPart;
        _LockData[idx].dwTotalWriteLockTime += liLocked.LowPart;
        */
    }
    else
    {   // This is a read location. 
        // Hence we have to exclude other readers from updating data 
        InterlockedIncrement( (LONG*) &_FileLineData[loc].dwNumEntrys );
        InterlockedExchangeAdd( (LONG*) &_FileLineData[loc].dwWaitTime, liWait.LowPart );  
        InterlockedExchangeAdd( (LONG*) &_FileLineData[loc].dwLockedTime, liLocked.LowPart );

        /*
        This needs to be here if we wish to compare entry counts reported by
        the lock with our own. For now this is in ProcessPerfData
        InterlockedIncrement( (LONG*) &_LockData[idx].dwTotalReadEntrys );
        InterlockedExchangeAdd( (LONG*) &_LockData[idx].dwTotalReadWaitTime, liWait.LowPart );
        InterlockedExchangeAdd( (LONG*) &_LockData[idx].dwTotalReadLockTime, liLocked.LowPart );
        */
    }

#if 0
    // Turn this ON, if you want a live log of every Update.
    wsprintfA(gszLockPerfBuf,"\n Lock at %-25s : line %u : Entry # %u",
                (pTableEntry->pszFile[1]==':') ? pTableEntry->pszFile+24
                                                : pTableEntry->pszFile,
                pTableEntry->dwLine,
                pTableEntry->dwNumEntrys);
    OutputDebugStringA(gszLockPerfBuf);

    wsprintfA(gszLockPerfBuf," Held for: %u mic-sec.",liLockHeld.LowPart);
    OutputDebugStringA(gszLockPerfBuf);
#endif
}

#define HOGLIST_TIME    0
#define HOGLIST_ENTRY   1
#define HOGLIST_AVGTIME 2


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::UpdateHoggers(), private
//
//  Synopsis:   Manages top ten lists. 
//                  This is done only during Proc_detach (hence thread safe!)
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::UpdateHoggers(ULONG* hogList, ULONG index, ULONG listType)
{
    int i,j;

    switch (listType)         
    {
    case HOGLIST_TIME:
        for (i=0; i<10; i++)
        {
            if (hogList[i]==-1)
            {
                break;
            }
            else if (_FileLineData[hogList[i]].dwLockedTime 
                        < _FileLineData[index].dwLockedTime)
            {
                break;
            }
        }
        break;

    case HOGLIST_ENTRY:
        for (i=0; i<10; i++)
        {
            if (hogList[i]==-1)
            {
                break;
            }
            else if (_FileLineData[hogList[i]].dwNumEntrys 
                        < _FileLineData[index].dwNumEntrys)
            {
                break;
            }
        }
        break;
    
    case HOGLIST_AVGTIME:
        for (i=0; i<10; i++)
        {
            if (hogList[i]==-1)
            {
                break;
            }
            else if (_FileLineData[hogList[i]].dwAvgTime 
                        < _FileLineData[index].dwAvgTime)
            {
                break;
            }
        }
        break;

    default:
        break;
    }

    if (i<10)
    {
        for (j=9; j>i;j--)
        {
            hogList[j] = hogList[j-1] ;
        }
        hogList[i] = index;
    }
}



//+-----------------------------------------------------------------------------
//
//  Function:   PercentToString
//
//  Synopsis:   Converts numbers like 74326 to "74.33".
//              We do not have float printing support in retail builds.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------

//  The percent argument is passed in 1000 times magnified.
char gPerc[7];
inline char *PercentToString(long percent)
{
    //round-off
    percent = percent/10 + ((percent%10 >= 5)?1:0);

    //set to fixed length
    percent+=10000;

    //create room for decimal point (4th char)
    percent = (percent/100)*1000 + (percent%100);

    _itoa(percent,gPerc,10);
    
    gPerc[0] = gPerc[0]-1;  //remove the 10000 we added.
    gPerc[3] = '.';

    return gPerc + (gPerc[0]=='0'? (gPerc[1]=='0'?2:1):0) ;
}



//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::OutputFileTableEntry, private
//
//  Synopsis:   Prints out cumulative data for a {file,line} entry
//              We are doing this during Process_Detach, hence thread-safe.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::OutputFileTableEntry(ULONG index, 
                                            ULONG bByName, 
                                            ULONG percent)
{
    ULONG trimFileName;
    CFileLineEntry *pTableEntry = &_FileLineData[index]; 

    if (pTableEntry->pszFile[1]==':')
    {
        trimFileName = 24;
    }
    else
    {
        trimFileName = 0;
    }
    if (bByName)
    {
        wsprintfA(gszLockPerfBuf,"\n %20s  %4d   %s %6d  %7u  %6s %% ",
                    pTableEntry->pszFile+trimFileName,
                    pTableEntry->dwLine,
                    pTableEntry->bWriteCritSec ? "Write" : " Read", 
                    pTableEntry->dwNumEntrys,
                    pTableEntry->dwLockedTime,
                    PercentToString(percent));

        OutputDebugStringA(gszLockPerfBuf);
    }
    else
    {
        wsprintfA(gszLockPerfBuf,"\n %20s  %4d   %-14.14s %s   %5d   %8u  %8u",
                    pTableEntry->pszFile+trimFileName,
                    pTableEntry->dwLine,
                    pTableEntry->pszLockName,
                    pTableEntry->bWriteCritSec?"Write":" Read", 
                    pTableEntry->dwNumEntrys,
                    pTableEntry->dwLockedTime,
                    pTableEntry->dwAvgTime);
        OutputDebugStringA(gszLockPerfBuf);
    }
}

#define TITLES_1      \
    wsprintfA(gszLockPerfBuf,"\n          File        Line    LockName       Type   Entrys  TotalTime  Avg/Entry"); OutputDebugStringA(gszLockPerfBuf)

#define TITLES_2      \
    wsprintfA(gszLockPerfBuf,"\n          File        Line    Type   Entrys TotalTime  %%-Time "); OutputDebugStringA(gszLockPerfBuf)

#define SEPARATOR_1   \
    wsprintfA(gszLockPerfBuf,"\n ==================== =====   ============   =====  ======  =========  ========="); OutputDebugStringA(gszLockPerfBuf)

#define SEPARATOR_2   \
    wsprintfA(gszLockPerfBuf,"\n ==================== =====   ====== ====== =========  ======"); OutputDebugStringA(gszLockPerfBuf)


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::OutputHoggers(), private
//
//  Synopsis:   Prints out a top ten list given an array of indices for the same.
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::OutputHoggers(ULONG *hogList)
{
    TITLES_1;
    SEPARATOR_1;

    for (int i=0; i<10; i++)
    {
        if (hogList[i]!=-1)
        {
            OutputFileTableEntry(hogList[i],0,0);
        }
    }
    SEPARATOR_1;
}


//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::ProcessPerfData(), public
//
//  Synopsis:   Organizes the perf table data by lockName. 
//              Prints lock summary data, top-ten lists.
//              This is done only during Proc_detach (hence thread safe!)
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::ProcessPerfData()
{
    // #### Begin : organize data
    CFileLineEntry  *pTableEntry;

    ULONG hogListTime[10];
    ULONG hogListEntry[10];
    ULONG hogListAvgTime[10];
    
    ULONG iName;
    DWORD totalLockTime = 0;        // lock sharing not reflected!
    DWORD totalRealLockTime = 0;    // takes lock sharing into account!
    DWORD totalLocksCreated = 0;    // some locks may never get used!


    for (int i=0; i<10; i++)
    {
        hogListTime[i] = -1;
        hogListEntry[i] = -1;
        hogListAvgTime[i] = -1;
    }
    
    for (i=0; i<MAX_LOCKPERF_FILEENTRY; i++)
    {
        if (_FileLineData[i].lpLockPtr)
        {
            pTableEntry = &_FileLineData[i];
            if (pTableEntry->dwNumEntrys)
            {
                pTableEntry->dwAvgTime = 
                        pTableEntry->dwLockedTime/pTableEntry->dwNumEntrys;
            }
            else
            {
                pTableEntry->dwAvgTime = 0;
            }
            UpdateHoggers(hogListTime,i, 0);
            UpdateHoggers(hogListEntry,i, 1);
            UpdateHoggers(hogListAvgTime,i, 2);
            _numCritSecs++;

            //REVIEW: how should we take shared time into account?
            totalLockTime = totalLockTime + pTableEntry->dwLockedTime;

            iName = FindLockTableEntry(_FileLineData[i].lpLockPtr);
            if (_LockData[iName].pszLockName==NULL)
            {   
                // First file table entry for this lock
                // We use pszLockName==NULL to tell if a lock got used!
                _LockData[iName].pszLockName = pTableEntry->pszLockName;
                _LockData[iName].dwHead = i;
                _LockData[iName].dwTail = i;

                _numLocks++;
            }
            else
            {   //CritSec is already in our list.
                _FileLineData[_LockData[iName].dwTail].dwNext = i;
                _LockData[iName].dwTail = i;
            }

            if (pTableEntry->bWriteCritSec)
            {
                _LockData[iName].dwTotalWriteLockTime += pTableEntry->dwLockedTime;
                _LockData[iName].dwTotalWriteEntrys += pTableEntry->dwNumEntrys;
                _LockData[iName].dwTotalWriteWaitTime += pTableEntry->dwWaitTime;
            }
            else
            {
                _LockData[iName].dwTotalReadLockTime += pTableEntry->dwLockedTime;
                _LockData[iName].dwTotalReadEntrys += pTableEntry->dwNumEntrys;
                _LockData[iName].dwTotalReadWaitTime += pTableEntry->dwWaitTime;
            }
        }   // if In Use
    }   // for each table entry
    // #### End : organize data

    wsprintfA(gszLockPerfBuf,
              "\n\n ============= LOCK_PERF: TOP TEN LISTS ===========\n");
    OutputDebugStringA(gszLockPerfBuf);

    wsprintfA(gszLockPerfBuf,
              "\n\n ============= Top Ten Hoggers by total time ===========\n");
    OutputDebugStringA(gszLockPerfBuf);
    OutputHoggers(hogListTime);

    wsprintfA(gszLockPerfBuf,
              "\n\n ============= Top Ten Hoggers by crit-sec Entrys ===========\n");
    OutputDebugStringA(gszLockPerfBuf);
    OutputHoggers(hogListEntry);

    wsprintfA(gszLockPerfBuf,
              "\n\n ============= Top Ten Hoggers by avg time per Entry ===========\n");
    OutputDebugStringA(gszLockPerfBuf);
    OutputHoggers(hogListAvgTime);

    SEPARATOR_1;
    wsprintfA(gszLockPerfBuf,
              "\n\n ============= LOCK_PERF: OVERALL LOCK STATS ===========\n");
    OutputDebugStringA(gszLockPerfBuf);

    for (i=0; i<MAX_LOCKS; i++)
    {
        if (_LockData[i].lpLockPtr)
        {
            totalLocksCreated++;
            if (_LockData[i].pszLockName)
            {
                // lock got used!
                totalRealLockTime += _LockData[i].dwTotalWriteLockTime;
                if (_LockData[i].dwTotalReadEntrys)
                {
                    totalRealLockTime += _LockData[i].dwSharedTime;
                }
            }
        }
    }

    wsprintfA(gszLockPerfBuf,
              "\n\n TOTAL locks created = %u",
              totalLocksCreated);
    OutputDebugStringA(gszLockPerfBuf);

    wsprintfA(gszLockPerfBuf,
              "\n TOTAL locks used    = %u",
              _numLocks);
    OutputDebugStringA(gszLockPerfBuf);
    wsprintfA(gszLockPerfBuf,
              "\n\n TOTAL code critSec areas covered = %u",
              _numCritSecs);
    OutputDebugStringA(gszLockPerfBuf);

    wsprintfA(gszLockPerfBuf,
              "\n\n\n TOTAL time spent in all critSecs = %u micro-sec\n\n",
              totalLockTime);
    OutputDebugStringA(gszLockPerfBuf);
    wsprintfA(gszLockPerfBuf,
              " [This is the sum of individual thread times.\n This does not take overlaps (shared work) into account.]");
    OutputDebugStringA(gszLockPerfBuf);
    
    wsprintfA(gszLockPerfBuf,
              "\n\n\n TOTAL real time spent in all critSecs = %u micro-sec\n\n",
              totalRealLockTime);
    OutputDebugStringA(gszLockPerfBuf);
    wsprintfA(gszLockPerfBuf," [This takes shared time into account.]");
    OutputDebugStringA(gszLockPerfBuf);
        
    wsprintfA(gszLockPerfBuf,
              "\n\n ## Warning ##: The total time counters overflow in about 70 minutes!\n\n");
    OutputDebugStringA(gszLockPerfBuf);
}

//+-----------------------------------------------------------------------------
//
//  Member:     CLockPerfTracker::OutputPerfData(), public
//
//  Synopsis:   Prints out the {file,line} table.
//              This is done only during Proc_detach (hence thread safe!)
//
//  History:    20-Dec-98   mprabhu     Created
//
//------------------------------------------------------------------------------
void CLockPerfTracker::OutputPerfData()
{
    if (glFileLine) //if monitoring was ON at any time!
    {
        if (gbLockPerfOverflow)
        {
            wsprintfA(gszLockPerfBuf,
                      "\n ### Warning: Overflow in lock perf data buffers!\n \
                      ### Increase array sizes and recompile!!\n");
            OutputDebugStringA(gszLockPerfBuf);
        }

        ULONG iStart, iNext, iEnd;
        const char *pszThisFile;
        
        ULONG iName;
        LARGE_INTEGER liPerc, liDiv, liRem ;


        //TITLES_1;
        //SEPARATOR_1;
        ProcessPerfData();


        // #### Begin: output by LockName:
        SEPARATOR_2;

        wsprintfA(gszLockPerfBuf,
                  "\n\n ============= LOCK_PERF: PER LOCK STATS ===========\n");
        OutputDebugStringA(gszLockPerfBuf);
        BOOL bShared;
        int iShared;
        for (iName=0; iName<_numLocks; iName++)
        {
            if (_LockData[iName].pszLockName) { //if the lock got used
            SEPARATOR_2;
            wsprintfA(gszLockPerfBuf,
                      "\n\n\n  #### ++++++++ Summary for %14s , this = %lx ++++++++ ####",
                      _LockData[iName].pszLockName, 
                      (DWORD)_LockData[iName].lpLockPtr);
            OutputDebugStringA(gszLockPerfBuf);

            wsprintfA(gszLockPerfBuf,
                      "\n\n      WrtLockTime:%12u      WrtEntrys:%14u\n      WrtWait:%16u      WrtContention:%10u \n",
                      _LockData[iName].dwTotalWriteLockTime,
                      _LockData[iName].dwTotalWriteEntrys,
                      _LockData[iName].dwTotalWriteWaitTime,
                      _LockData[iName].dwWriterContentionCount);
            OutputDebugStringA(gszLockPerfBuf);

            wsprintfA(gszLockPerfBuf,
                      "\n      RdLockTime:%13u      RdEntrys:%15u\n      RdWait:%17u      RdContention:%11u \n",
                      _LockData[iName].dwTotalReadLockTime,
                      _LockData[iName].dwTotalReadEntrys,
                      _LockData[iName].dwTotalReadWaitTime,
                      _LockData[iName].dwReaderContentionCount);
            OutputDebugStringA(gszLockPerfBuf);
            
            wsprintfA(gszLockPerfBuf,"\n      Shared Read Time:     %10u\n",
                      _LockData[iName].dwSharedTime);
            OutputDebugStringA(gszLockPerfBuf);
            

            TITLES_2;
            SEPARATOR_2;
            iNext = _LockData[iName].dwHead;
            iEnd = _LockData[iName].dwTail;
            while (1)
            {
                liPerc.HighPart = 0;
                liPerc.LowPart = _FileLineData[iNext].dwLockedTime;
                liPerc = RtlExtendedIntegerMultiply(liPerc,100000);
                liDiv.HighPart = 0;
                if (_FileLineData[iNext].bWriteCritSec)
                {
                    liDiv.LowPart = _LockData[iName].dwTotalWriteLockTime;
                }
                else
                {
                    liDiv.LowPart = _LockData[iName].dwTotalReadLockTime;
                }

                liPerc = RtlLargeIntegerDivide(liPerc, liDiv, &liRem);

                OutputFileTableEntry(iNext,1, liPerc.LowPart);
                if (iNext == iEnd)
                    break;
                iNext = _FileLineData[iNext].dwNext;
            }

            SEPARATOR_2;
            wsprintfA(gszLockPerfBuf,
                      "\n ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ \n");
            OutputDebugStringA(gszLockPerfBuf);
            }   //if the lock got used!
        }

        SEPARATOR_2;
        // #### End: output by LockName:

        SEPARATOR_1;


#if 0   //This lists lock data by fileNames
        // #### Begin: output by fileName : location:
        wsprintfA(gszLockPerfBuf,
                  "\n\n\n ======= CritSec data listed by FileName: =======\n");
        OutputDebugStringA(gszLockPerfBuf);

        TITLES_1;
        SEPARATOR_1;

        pszThisFile = NULL;
        i=0;
        while (!_FileLineData[i].bInUse)
            i++;
        iNext = i;

        while (iNext < MAX_LOCKPERF_FILEENTRY)
        {
            iStart = iNext;
            iNext = MAX_LOCKPERF_FILEENTRY;
            pszThisFile= _FileLineData[iStart].pszFile;
            for (i=iStart;i<MAX_LOCKPERF_FILEENTRY;i++)
            {
                if (_FileLineData[i].bInUse)
                {
                    if (pszThisFile==_FileLineData[i].pszFile)
                    {
                        OutputFileTableEntry(i,0,0);
                        _FileLineData[i].bInUse = FALSE;
                    }
                    else if (iNext==MAX_LOCKPERF_FILEENTRY)
                    {
                        iNext=i;
                    }
                }
            }
        }
        // #### End: output by fileName : location:
#endif  //0 This lists lock data by fileNames

    }   //if glFileLine  
}

#endif //LOCK_PERF==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\olesem.cxx ===
//+---------------------------------------------------------------------------
//
//  File:       olesem.cxx
//
//  Contents:   Implementation of semaphore classes for use in OLE code
//
//  Functions:  COleStaticMutexSem::Destroy
//              COleStaticMutexSem::Request
//              COleStaticMutexSem::Init
//              COleDebugMutexSem::COleDebugMutexSem
//
//  History:    14-Dec-95       Jeffe   Initial entry, derived from
//                                      sem32.hxx by AlexT.
//
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>
#include <debnot.h>
#include <olesem.hxx>



//
//      Global state for the mutex package
//

//
//      List of initialized static mutexes (which must be destroyed
//      during DLL exit). We know that PROCESS_ATTACH and PROCESS_DETACH
//      are thread-safe, so we don't protect this list with a critical section.
//

COleStaticMutexSem * g_pInitializedStaticMutexList = NULL;

#if DBG

//
//      Flag used to indicate if we're past executing the C++ constructors
//      during DLL initialization
//

DLL_STATE g_fDllState = DLL_STATE_STATIC_CONSTRUCTING;

#endif

//
//      Semaphore used to protect the creation of other semaphores
//

BOOL gfOleMutexCreationSemOkay = FALSE;
CRITICAL_SECTION g_OleMutexCreationSem;

//
//      Critical section used as the backup lock when a COleStaticMutexSem
//      cannot be faulted in.
//
BOOL gfOleGlobalLockOkay = FALSE;
CRITICAL_SECTION g_OleGlobalLock;

//
// Just cache the calculated spin count.  Keep from calling NtQuerySystemInformation
// a lot.
//
DWORD g_dwComSpinCount = -1;

//+---------------------------------------------------------------------------
//
//  Function:   CalculateSpinCount()
//
//  Synopsis:   Calculate the spin count to use in a critical section.
//              We use 500 * the number of processors on the system.  Note
//              that spin counts are ignored on single proc systems, since
//              it just don't help.
//
//  History:    28-Feb-02   JohnDoty       Created.
//
//----------------------------------------------------------------------------
DWORD CalculateSpinCount()
{
    if (g_dwComSpinCount == -1)
    {
        DWORD dwSpinCount = 500;
        SYSTEM_BASIC_INFORMATION si = {0};
        NTSTATUS status = NtQuerySystemInformation(SystemBasicInformation,&si,sizeof(si),NULL);
        if (NT_SUCCESS(status))
            dwSpinCount = 500 * si.NumberOfProcessors; 

        g_dwComSpinCount = dwSpinCount;
    }

    return g_dwComSpinCount;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleStaticMutexSem::Destroy
//
//  Synopsis:   Releases a semaphore's critical section.
//
//  History:    14-Dec-1995     Jeffe
//
//----------------------------------------------------------------------------
void COleStaticMutexSem::Destroy()
{
#if LOCK_PERF==1
    gLockTracker.ReportContention(this, _cs.LockCount, _cs.DebugInfo->ContentionCount, 0 , 0);  //entry,contention counts for writes & reads.
#endif
    if (_fInitialized)
    {
        DeleteCriticalSection (&_cs);
        _fInitialized = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COleStaticMutexSem::Request
//
//  Synopsis:   Acquire the semaphore. If another thread already has it,
//              wait until it is released. Initialize the semaphore if it
//              isn't already initialized.
//
//  History:    14-Dec-1995     Jeffe
//
//----------------------------------------------------------------------------

void COleStaticMutexSem::Request(const char *pszFile, DWORD dwLine, const char *pszLockName)
{
    if (!_fInitialized && !_fUsingGlobal)
    {
        EnterCriticalSection (&g_OleMutexCreationSem);
        if (!_fInitialized && !_fUsingGlobal) {
            Init();
            if (!_fInitialized) _fUsingGlobal = TRUE;
        }
        LeaveCriticalSection (&g_OleMutexCreationSem);
    }

#if LOCK_PERF==1
    gLockTracker.WriterWaiting(pszFile, dwLine, pszLockName, this);
#endif

    // What do we do if either of these fail?
    if (!_fUsingGlobal)
        EnterCriticalSection (&_cs);
    else
        EnterCriticalSection (&g_OleGlobalLock);

#if LOCK_PERF==1
    gLockTracker.WriterEntered(pszFile, dwLine, pszLockName, this); //the tracker takes cares of recursive Lock calls.
#endif

    Win4Assert((((_dwTid == 0 && _cLocks == 0) || (_dwTid == GetCurrentThreadId() && _cLocks > 0)) ||
                (g_fDllState == DLL_STATE_PROCESS_DETACH)) &&
               "Inconsistent State!");
    Win4Assert(!(_fTakeOnce && _cLocks > 1) && "Lock taken more than once on same thread.");

#if DBG==1 || LOCK_PERF==1
    if(_dwTid != GetCurrentThreadId())
    {
        if (g_fDllState != DLL_STATE_PROCESS_DETACH)
        {
            Win4Assert (_cLocks == 0);
        }
        else
        {
            _cLocks = 0;
        }
        _dwTid = GetCurrentThreadId();
    }
#endif

    // only stamp the file on the
    // 0 -> 1 transition
    if (++_cLocks == 1)
    {
        _pszFile = pszFile;
        _dwLine  = dwLine;
    }
}


//+---------------------------------------------------------------------------
//
// Member:      COleStaticMutexSem::AssertHeld
//
// Synopsis:    Check to see if this thread owns the lock, and optionally owns
//              cLocks amount of locks. If not raise an assertion warning.
//
// History:     16-Aug-1996     mattsmit
//
// Notes:       Debug builds only
//----------------------------------------------------------------------------
#if DBG==1
void COleStaticMutexSem::AssertHeld(DWORD cLocks)
{
    Win4Assert(_dwTid == GetCurrentThreadId() && "Lock not held by current thread.");

    if (cLocks == 0)
    {
        Win4Assert(_cLocks > 0 && "Lock held by thread with a nonpositive lock count");
    }
    else
    {
        Win4Assert(_cLocks == cLocks && "Incorrect amount of locks");
    }
}
#endif


//+---------------------------------------------------------------------------
//
// Member:      COleStaticMutexSem::AssertNotHeld
//
// Synopsis:    Check to see if this does not thread own the lock. If it does,
//              raise an assertion warning.
//
// History:     16-Aug-1996     mattsmit
//
// Notes:       Debug builds only
//----------------------------------------------------------------------------
#if DBG==1
void COleStaticMutexSem::AssertNotHeld()
{
    Win4Assert(_dwTid != GetCurrentThreadId() && "Lock held by current thread.");
}
#endif


//+---------------------------------------------------------------------------
//
// Member:      COleStaticMutexSem::AssertTakenOnlyOnce
//
// Synopsis:    Turn on flag to insure this lock is taken only once
//
// History:     16-Aug-1996     mattsmit
//
// Notes:       Debug builds only
//----------------------------------------------------------------------------
#if DBG==1
void COleStaticMutexSem::AssertTakenOnlyOnce()
{
    _fTakeOnce = TRUE;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     COleStaticMutexSem::Init
//
//  Synopsis:   Initialize semaphore's critical section
//
//  History:    14-Dec-1995     Jeffe
//
//----------------------------------------------------------------------------
HRESULT COleStaticMutexSem::Init()
{
    NTSTATUS status;

    if (_fInitialized)
        return S_OK;

    if (_fUseSpincount)
    {
        DWORD dwSpinCount = CalculateSpinCount();

        status = RtlInitializeCriticalSectionAndSpinCount(&_cs, dwSpinCount);
    }
    else
    {
        status = RtlInitializeCriticalSection (&_cs);
    }

    _fInitialized = NT_SUCCESS(status);
    if (!_fAutoDestruct)
    {
        //
        //  We don't need to protect this list with a mutex, since it's only
        //  manipulated during DLL attach/detach, which is single threaded by
        //  the platform.
        //

        pNextMutex = g_pInitializedStaticMutexList;
        g_pInitializedStaticMutexList = this;
    }
#if LOCK_PERF==1
    gLockTracker.RegisterLock(this, FALSE /*bReadWrite*/);
#endif

    if (NT_SUCCESS(status))
        return S_OK;
    else
        return HRESULT_FROM_WIN32(status);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleStaticMutexSem::Release
//
//  Synopsis:   Release the semaphore.
//
//  History:    14-Dec-1995     Jeffe
//
//----------------------------------------------------------------------------

void COleStaticMutexSem::Release()
{
    AssertHeld();

    if (--_cLocks == 0)
    {
        Win4Assert((_cContinuous == 0) ||
                   (g_fDllState == DLL_STATE_PROCESS_DETACH));

#if DBG==1 || LOCK_PERF==1
        _dwTid = 0;
#endif
        Win4Assert(_cContinuous==0);
    }
 
#if LOCK_PERF==1
    gLockTracker.WriterLeaving(this);
#endif

    if (!_fUsingGlobal)
        LeaveCriticalSection (&_cs);
    else
        LeaveCriticalSection (&g_OleGlobalLock);
}


//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem2::CMutexSem2
//
//  Synopsis:   Mutex semaphore constructor. This is a 2-phase constructed object.
//             You must call CMutexSem2::Init to fully initialize the object.
//
//  Effects:    Initializes the semaphores data
//
//  History:    19-Mar-01    danroth    Created.
//
//----------------------------------------------------------------------------

CMutexSem2::CMutexSem2(void) : m_fCsInitialized(FALSE)
{
}

BOOL CMutexSem2::FInit()
{
    if (m_fCsInitialized == FALSE) // guard against re-entry
    {
        NTSTATUS status = RtlInitializeCriticalSection(&m_cs);
        if (NT_SUCCESS(status))
        {
    	    m_fCsInitialized = TRUE;
        }
    }
    return m_fCsInitialized;
};

//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem2::~CMutexSem2, public
//
//  Synopsis:   Mutex semaphore destructor
//
//  Effects:    Releases semaphore data
//
//  History:    19-Mar-01    danroth    Created.
//
//----------------------------------------------------------------------------

CMutexSem2::~CMutexSem2(void)
{
    if (m_fCsInitialized == TRUE)
    {
#ifdef _DEBUG
        NTSTATUS status =
#endif
        RtlDeleteCriticalSection(&m_cs); // if RtlDeleteCriticalSection fails, tough luck--we leak. 
#ifdef _DEBUG                       // But I'm asserting for it to see if we ever really hit it.
        Win4Assert(NT_SUCCESS(status));
#endif
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem2::Request, public
//
//  Synopsis:  Enter critical section
//
//  Effects:    Asserts correct owner
//
//  History:    19-Mar-01    danroth    Created.
//
//
//----------------------------------------------------------------------------

void CMutexSem2::Request(void)
{
    Win4Assert(m_fCsInitialized == TRUE);
    if (m_fCsInitialized == TRUE)
	EnterCriticalSection(&m_cs);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMutexSem2::Release, public
//
//  Synopsis:   Release semaphore
//
//  Effects:    Leave critical section
//
//  History:    19-Mar-01    danroth    Created.
//
//----------------------------------------------------------------------------

void CMutexSem2::Release(void)
{
    Win4Assert(m_fCsInitialized == TRUE);
    if (m_fCsInitialized == TRUE)
    	LeaveCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\olescm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       olescm.cxx
//
//  Contents:   Functions shared between OLE32 and the SCM
//
//  Classes:
//
//  Functions:
//
//  History:    10-03-95   kevinro   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <ole2sp.h>
#include <ole2com.h>

static const WCHAR wszOle32Dll[] = L"OLE32.DLL";

#define OLE32_DLL wszOle32Dll
#define OLE32_BYTE_LEN sizeof(OLE32_DLL)
#define OLE32_CHAR_LEN (sizeof(OLE32_DLL) / sizeof(WCHAR) - 1)

//
// Threading Model Registry Constants
//

const WCHAR wszDllThreadModel[] = L"ThreadingModel";

const WCHAR wszAptModel[]       = L"Apartment";
const WCHAR wszBothModel[]      = L"Both";
const WCHAR wszFreeModel[]      = L"Free";
const WCHAR wszNeutralModel[]   = L"Neutral";

// Thread model match table. The table's first index is the threading
// model of the process and can be either APT_THREADED or
// FREE_THREADED. The second index is any one of the types of threading
// model's for DLLs.
BOOL afThreadModelMatch[2][4] =
    {{TRUE, FALSE, TRUE, TRUE},
     {FALSE, TRUE, FALSE, TRUE}};

//+---------------------------------------------------------------------------
//
//  Function:   CompareDllName
//
//  Synopsis:   Give a DLL path, this sees if the path is equal to a given
//              DLL name or the last component of the is the same as the
//              DLL name.
//
//  Arguments:  [pwszPath] -- DLL path
//              [pwszDllName] -- name of DLL to compare with
//
//  Returns:    TRUE - The input path is equal or its last component is equal
//                     to the input Dll name.
//              FALSE - Not equal at all.
//
//  History:    6-15-95   ricksa    Created
//
//  Notes:      This is a helper function used by the routines that convert
//              ole2.dll to ole32.dll and to convert paths that end in ole32.dll
//              into ole32.dll.
//
//----------------------------------------------------------------------------
BOOL
wCompareDllName(LPCWSTR pwszPath, LPCWSTR pwszDllName, DWORD dwDllNameLen)
{
    BOOL fResult = TRUE;

    if (lstrcmpiW(pwszDllName, pwszPath) != 0)
    {
        // Check if the last component is the same path
        DWORD dwPathLen = lstrlenW(pwszPath);

        if (dwPathLen > dwDllNameLen)
        {
            // Point to the last where the slash would be if the substitute
            // path is the last component
            LPCWSTR pwszLastComponent = pwszPath + dwPathLen - (dwDllNameLen + 1);

            // Is there a slash in that position
            if ((*pwszLastComponent == '\\') || (*pwszLastComponent == '/'))
            {
                // Point to where the last component should be
                pwszLastComponent++;

                // Does the last component match?
                if (lstrcmpiW(pwszLastComponent, pwszDllName) == 0)
                {
                    goto CompareDllName_Exit;
                }
            }
        }

        fResult = FALSE;
    }

CompareDllName_Exit:

    return fResult;
}

//+-------------------------------------------------------------------------
//
//  Function:   wThreadModelMatch
//
//  Synopsis:   Determines whether caller and DLL thread models match
//
//  Arguments:  [dwCallerThreadModel] - Caller thread model
//              [dwDllThreadModel] - DLL thread model
//
//  Returns:    TRUE - DLL can be loaded caller
//              FALSE - DLL cannot be loaded into caller.
//
//  Algorithm:  If the caller's thread model is apartment, then check
//              whether the DLL is one of apartment, single threaded or
//              both threaded. If it is, then return TRUE. Otherwise,
//              for free threading return TRUE if the DLL model is either
//              both or free threaded. If neither of the above is TRUE
//              then return FALSE.
//
//  History:    10-Nov-94 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL wThreadModelMatch(
    DWORD dwCallerThreadModel,
    DWORD dwDllThreadModel,
    DWORD dwContext)
{
    BOOL fResult = afThreadModelMatch[dwCallerThreadModel] [dwDllThreadModel];

    if (dwContext & CLSCTX_PS_DLL)
    {
        fResult = TRUE;
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//
//  Function:   wQueryStripRegValue
//
//  Synopsis:   Get the DLL information for a 32 bit DLL and
//              strip off any leading and trailing "
//
//  Arguments:  [hkey] - class handle
//              [pwszSubKey] - key to open
//              [pwszValue] - where to return data
//              [pcbValue] - length of above buffer in bytes
//
//  Returns:    ERROR_SUCCESS - read DLL path information
//              Other - registry entries could not be found
//
//  Algorithm:  Read the value requested.
//              If first character is not ", exit
//              Otherwise, copy data after quote to beginning of buffer.
//
//
//  History:    05-Jan-94 BillMo     Created
//              26-Sep-95 BruceMa    Support environment variable expansion
//                                    for shell viewers
//
//--------------------------------------------------------------------------

LONG
wQueryStripRegValue(HKEY    hKey,        // handle of key to query
                    LPCWSTR pwszSubKey, // address of name of subkey to query
                    LPWSTR  pwszValue,  // address of buffer for returned string
                    PLONG   pcbValue)    // address of buffer for size of returned string
{
    HKEY  hSubKey;
    DWORD dwType;
    LONG  lErr ;

    Win4Assert(pwszValue != NULL);
    Win4Assert(pcbValue != NULL);

    //
    // Open the subkey if there is a string
    //
    if (pwszSubKey != NULL)
    {
        lErr = RegOpenKeyExW(hKey, pwszSubKey, NULL, KEY_READ, &hSubKey);
    }
    else
    {
        hSubKey = hKey;
        lErr = ERROR_SUCCESS;
    }

    // Read the value into the user's buffer
    if (lErr == ERROR_SUCCESS)
    {
        lErr = RegQueryValueExW(hSubKey, NULL , NULL, &dwType,
                               (BYTE *) pwszValue, (ULONG *) pcbValue);
        if (lErr == ERROR_SUCCESS)
        {
            WCHAR *pwszScan = pwszValue;        // used to scan along string
            WCHAR *pwszDest = pwszValue;        // used as destination when copying

            // if the name is quoted then ...
            if (*pwszScan == '\"')
            {
                pwszScan++;

                // copy all non-quote characters down to base of buffer
                // until end of quoted string
                while (*pwszScan != '\0' && *pwszScan != '\"')
                {
                    *pwszDest++ = *pwszScan++;
                }

                // terminate string and get length in bytes including nul
                *pwszDest++ = '\0';
                *pcbValue = (int)(pwszDest - pwszValue) * sizeof(WCHAR);
            }

            // find first non-white space character
            pwszScan = pwszValue;
            while (_istspace(*pwszScan))
                pwszScan++;

            // if there are no non-white space characters this will be true
            if (*pwszScan == L'\0')
            {
                lErr = ERROR_FILE_NOT_FOUND;
                *pcbValue = 0;
            }

            // If the value type is REG_EXPAND_SZ then do environment variable
            // expansion
            if (dwType == REG_EXPAND_SZ)
            {
                // Expand any embedded environemnt variable expressions
                WCHAR wszTemp[MAX_PATH];

                lstrcpyW(wszTemp, pwszValue);
                *pcbValue = ExpandEnvironmentStrings(wszTemp, pwszValue,MAX_PATH);
            }
        }

        //
        // Only close the sub key if we actually opened it.
        //
        if (hSubKey != hKey)
        {
            RegCloseKey(hSubKey);
        }

    }
    return lErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDllInfo
//
//  Synopsis:   Get the DLL information for a 32 bit DLL
//
//  Arguments:  [hClsRegEntry] - class handle
//              [pwszKey] - key to open
//              [pwszDllName] - where to return DLL path
//              [pclDllName] - length of above buffer
//              [pulDllThreadType] - where to return DLL threading information
//
//  Returns:    ERROR_SUCCESS - read DLL path information
//              Other - registry entries could not be found
//
//  Algorithm:  Open the DLL key. Then read the DLL path name. Finally read
//              the threading model information if it is specified.
//
//  History:    09-Nov-94 Ricksa    Created
//
//--------------------------------------------------------------------------
LONG wGetDllInfo(
    HKEY     hClsRegEntry,
    LPCWSTR  pwszKey,
    LPWSTR   pwszDllName,
    LONG*    pclDllName,
    ULONG*   pulDllThreadType)
{
    HKEY hDllEntry = NULL;

    //
    // Attempt to open the specified registry key.
    //
    
    LONG lerr = RegOpenKeyExW(hClsRegEntry, pwszKey, 0, KEY_READ, &hDllEntry);
    if (ERROR_SUCCESS == lerr)
    {
        //
        // Try to read the DLL name.
        //
        
        lerr = wQueryStripRegValue(hDllEntry, NULL, pwszDllName, pclDllName);
        if (ERROR_SUCCESS == lerr)
        {
            //
            // A DLL name is registered.  If the DLL is OLE32.DLL, then we
            // know all about and don't have to dig more info from the
            // the registry.  Otherwise, we do need to keep digging.
            //
            
            if (wCompareDllName(pwszDllName, OLE32_DLL, OLE32_CHAR_LEN))
            {
                memcpy(pwszDllName, OLE32_DLL, OLE32_BYTE_LEN);
                *pclDllName       = OLE32_CHAR_LEN;
                *pulDllThreadType = BOTH_THREADED;
            }
            else
            {
                //
                // Assume there is no registry entry.
                //
                
                *pulDllThreadType = SINGLE_THREADED;

                //
                // Buffer to hold entry for the registry data.
                //
                
                WCHAR wszModelBuf[MAX_PATH];
                DWORD cdwModelBuf = sizeof(wszModelBuf);
                DWORD dwRegEntType;

                //
                // Read the DLL threading model from the registry.
                //

                lerr = RegQueryValueExW(hDllEntry, 
                                        wszDllThreadModel, 
                                        NULL,
                                        &dwRegEntType, 
                                        (LPBYTE) &wszModelBuf[0], 
                                        &cdwModelBuf);

                //
                // If there is a thread model descriptor, set the thread
                // type accordingly.
                //
                
                if (ERROR_SUCCESS == lerr)
                {
                    if (REG_SZ != dwRegEntType)
                    {
		       Win4Assert(L"ThreadingModel Key Type incorrect");
		    }                    
                    else if (0 == lstrcmpiW(wszAptModel, wszModelBuf))
                    {
                        //
                        // An APARTMENT model object.
                        //
                        
                        *pulDllThreadType = APT_THREADED;
                    }                    
                    else if (0 == lstrcmpiW(wszBothModel, wszModelBuf))
                    {
                        //
                        // A BOTH model object.
                        //
                        
                        *pulDllThreadType = BOTH_THREADED;
                    }
                    else if (lstrcmpiW(wszFreeModel, wszModelBuf) == 0)
                    {
                        //
                        // A FREE_THREADED model object.
                        //
                        
                        *pulDllThreadType = FREE_THREADED;
                    }
                    else if (0 == lstrcmpiW(wszNeutralModel, wszModelBuf))
                    {
                        //
                        // A NEUTRAL_THREADED object.
                        //
                        
                        *pulDllThreadType = NEUTRAL_THREADED;
                    }
                    else
                    {
		       Win4Assert(L"ThreadingModel Value incorrect");
                    }
                }

                //
                // When we get to this point, we got a DLL entry so we remap
                // any errors to success because they only mean that we could
                // not get a model from the registry.
                //
                
                lerr = ERROR_SUCCESS;
            }
        }
        
        RegCloseKey(hDllEntry);
    }

    return lerr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\outfuncs.h ===
#ifndef __OUTFUNCS_H__
#define __OUTFUNCS_H__
// Array of callback functions which will be called to print buffer
#define BUFFER_MAX_FUNCTIONS 5

typedef VOID (*StringOutFunc) (const char *);

#if defined(__cplusplus)
extern "C"
{
#endif
void AddOutputFunction(StringOutFunc pfunc);
void DelOutputFunction(StringOutFunc pfunc);
void CallOutputFunctions(const char *buffer);
void OutputLogFileA(const char *buf);
void WriteToDebugScreen(BOOL flag);
void WriteToLogFile(LPCTSTR lpfn);
void OpenDebugSinks();
void CloseDebugSinks();

#if defined(__cplusplus)
}
#endif

#endif // __OUTFUNCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\oletype.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       oletype.cxx
//
//  Contents:   individual methods for priting OLE types
//
//  Functions:  see oleprint.hxx
//
//  History:    11-Jul-95   t-stevan    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <ole2sp.h>
#include <ole2com.h>
#if DBG==1
#include "oleprint.hxx"
#include "sym.hxx"

// temporary string buffer size
#define TEMP_SIZE 64

// our constant strings
const char *pscNullString = "<NULL>";
const char *pscTrue = "true";
const char *pscTRUE = "TRUE";
const char *pscFalse = "false";
const char *pscFALSE = "FALSE";

const char *pscHexPrefix = "0x";
const char *pscPointerPrefix = "<";
const char *pscBadPointerPrefix = "BAD PTR : ";
const char *pscPointerSuffix = ">";

const char *pscStructPrefix = "{ ";
const char *pscStructDelim  = " , ";
const char *pscStructSuffix = " }";

// These functions are in com\util\guid2str.c
extern "C" void FormatHexNum( unsigned long ulValue, unsigned long chChars, char *pchStr);
extern "C" int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax);

// *** Global Data ***
CSym *g_pSym = NULL;            // manage symbol stuff

//+---------------------------------------------------------------------------
//
//  Function:   FormatHex
//
//  Synopsis:  Wrapper around FormatHexNum to control if leading zeros are printed
//
//  Arguments:  [ulValue]               -       DWORD value to print out
//                              [chChars]               -       number of characters to print out, starting from right of number
//                              [fLeadZeros]    -       whether or not to print leading zeros
//                              [pchStr]                -       pointer of string to put printed out value, must have room for
//                                                                      chChars+1 chars (chChars digits and null byte)
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void FormatHex(unsigned long ulValue, unsigned long chChars, BOOL fLeadZeros, char *pchStr)
{
        if(!fLeadZeros)
        {
                unsigned long ulmask = 0xf<<((chChars-1)<<4);

                // determine how many leading zeros there are
                while(!(ulValue & ulmask) && (chChars > 1))
                {
                        chChars--;
                        ulmask >>=4;
                }

                FormatHexNum(ulValue, chChars, pchStr);

                // tag on null byte
                pchStr[chChars] = '\0';

        }
        else
        {
                FormatHexNum(ulValue, chChars, pchStr);

                // tag on null byte
                pchStr[chChars] = '\0';
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   IntToString
//
//  Synopsis:  Prints out a integer to a string (base 10)
//
//  Arguments:  [n]                             -       integer to print out
//                              [pStr]                  -       pointer of string to put printed out value
//                              [nMax]                  -       maximum number of characters
//                              [fUnsigned]             -       whether or not value is unsigned
//
//      Returns:        pStr
//
//  History:    15-Jul-95   t-stevan   Created
//
//      NOtes:          nMax should be enough to hold the printed out string
//----------------------------------------------------------------------------
char *IntToString(unsigned long n, char *pStr, int nMax, BOOL fUnsigned)
{
        char *pChar;
        BOOL fSign= FALSE;
        int nCount;

        //      Special case, n = 0
        if(n == 0)
        {
                *pStr = '0';
                *(pStr+1) = '\0';

                return pStr;
        }

        if(!fUnsigned)
        {
                // if the value is signed, figure out what the sign of it is, and
                // then take absolute value
                if((fSign = ((int) n) < 0))
                {
                        n = -((int)n);
                }
        }


        // initialize pChar to point to the last character in pStr
        pChar = &(pStr[nMax-1]);
        // tag on null byte
        *pChar = '\0';
        pChar--;
        // null byte counts!
        nCount=1;

        //      loop until n == 0
        while(n && nCount <= nMax)
        {
                // write digit
                *pChar = '0'+(char)(n%10);
                // move to next digit
                pChar--;
                // increase digit count
                nCount++;
                // divide n by 10
                n/=10;
        }

        if(nCount > nMax)
        {
                return pStr;    // we failed, but still return pStr
        }

        if(fSign)
        {
                *pStr = '-';    // tag on sign
                memmove(pStr+1, pChar+1, nCount); // move string to front
        }
        else
        {
                memmove(pStr, pChar+1, nCount); // move string to front
        }

        return pStr;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteIntCommon
//
//  Synopsis:  Common functionality for printing out integer values
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [param]                 -       integer to print
//                              [fUnsigned]             -       whether or not value is unsigned
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteIntCommon(CTextBufferA &buf, unsigned int param, BOOL fUnsigned)
{
        char temp[TEMP_SIZE];

        IntToString(param, temp, TEMP_SIZE, fUnsigned);
        //      _ltoa((int) param, temp, 10);

        // do write op
        buf << temp;
}

//+---------------------------------------------------------------------------
//
//  Function:   WritePointerCommon
//
//  Synopsis:  Common functionality for printing pointers
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pPointer]              -       pointer to print out
//                              [fCaps]                 -       whether or not to use capitalized hex digits (ABCDEF)
//                              [fKnownBad]             -       whether or not the pointer is known to be bad
//                              [fXlatSym]              -       whether or not we should attempt to address->symbol
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WritePointerCommon(CTextBufferA &buf, void *pPointer, BOOL fCaps, BOOL fKnownBad, BOOL fXlatSym)
{
        char temp[TEMP_SIZE];

        if(pPointer == NULL)
        {
                buf << pscNullString;
                return;
        }

        if(fKnownBad)
        {
                // we know it's a bad pointer
                buf << pscPointerPrefix;
                buf << pscBadPointerPrefix;
        }
        else
        {
                buf << pscPointerPrefix;

                // validate pointer
                __try
                {
                        // try a read operation
                        temp[0] =       *((char *)pPointer);
                }
                __except (ExceptionFilter(_exception_code()))
                {
                        // bad pointer
                        buf << pscBadPointerPrefix;
                        fKnownBad = TRUE;
                }
        }

        if(!fKnownBad && fXlatSym)
        {
                // see if we can find a symbol for the pointer
                char symbol[MAXNAMELENGTH];
                DWORD64 dwDisplacement;

                if(g_pSym != NULL)
                {
                        if (g_pSym->GetSymNameFromAddr((DWORD64) pPointer, &dwDisplacement, symbol, MAXNAMELENGTH))
                        {
                                // found a symbol. Woo hoo!
                                WriteStringCommon(buf, symbol);

                                if(dwDisplacement != 0)
                                {
                                        buf << '+';

                                        buf << pscHexPrefix;

                                        // no leading zeros
                                        FormatHex((unsigned long) dwDisplacement, 8, FALSE, temp);

                                        buf << temp;
                                }

                                buf << pscPointerSuffix;

                                return;
                        }
                }
        }

        // add the hex prefix
        buf << pscHexPrefix;

        FormatHex((unsigned long) (ULONG_PTR) pPointer, 8, TRUE, temp);

        if(fCaps)
        {
            CharUpperBuffA (temp, lstrlenA (temp));
        }
        else
        {
            CharLowerBuffA (temp, lstrlenA (temp));
        }

        // do write op
        buf << temp;

        // write suffix
        buf << pscPointerSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteLargeCommon
//
//  Synopsis:  Common functionality for printing out a 64-bitinteger values
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [param]                 -       integer to print
//                              [fUnsigned]             -       whether or not value is unsigned (currently ignored)
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//      Note:           currently 64-bit integers are printed out as unsigned hex numbers
//----------------------------------------------------------------------------
void WriteLargeCommon(CTextBufferA &buf, const __int64 *pInt, BOOL fUnsigned)
{
        char temp[TEMP_SIZE];

        __try // catch bad pointers
        {
                // right now we ignore the fUnsigned parameter and print out
                // as an unsigned hex integer
                FormatHex((unsigned long) ((*pInt)>>32), 8, FALSE,  temp);

                buf << pscHexPrefix;
                buf << temp;

                FormatHex((unsigned long) ((*pInt)&0xffffffff), 8, TRUE, temp);

                buf << temp;
        }
        __except (ExceptionFilter(_exception_code()))
        {
                // bad pointer, just print out the pointer passed
                WritePointerCommon(buf, (void *) pInt, FALSE, TRUE, FALSE);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteHexCommon
//
//  Synopsis:  Common functionality for printing out hex integer values
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [param]                 -       integer to print
//                              [fCaps]                 -       whether or not to print capital hex digits (ABCDEF)
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteHexCommon(CTextBufferA &buf, ULONG param, BOOL fCaps)
{
        char temp[TEMP_SIZE];

        buf << pscHexPrefix;

        // write out number
        FormatHex((unsigned long) param, 8, TRUE, temp);

        if(fCaps)
        {
            CharUpperBuffA (temp, lstrlenA (temp));
        }
        else
        {
            CharLowerBuffA (temp, lstrlenA (temp));
        }

        // do write op
        buf << temp;

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteBoolCommon
//
//  Synopsis:  Common functionality for printing out boolean values
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [param]                 -       integer to print
//                              [fCaps]                 -       whether or not to print capital characters
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteBoolCommon(CTextBufferA &buf, BOOL param, BOOL fCaps)
{
        const char *pTrue, *pFalse;

        if(fCaps)
        {
                pTrue = pscTRUE;
                pFalse = pscFALSE;
        }
        else
        {
                pTrue = pscTrue;
                pFalse = pscFalse;
        }

        if(param)
        {
                buf << pTrue;
        }
        else
        {
                buf << pFalse;
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteStringCommon
//
//  Synopsis:  Common functionality for printing out ASCII strings
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pString]               -       pointer to ASCII string
//                              [fQuote]                -       whether or not to enclose the string in quotes
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteStringCommon(CTextBufferA &buf, const char *pString, BOOL fQuote)
{
        BufferContext bc;

        // take a snapshot of the buffer first
        buf.SnapShot(bc);

        __try
        {
                if(fQuote)
                {
                        buf << '\"';
                }

                buf << pString;

                if(fQuote)
                {
                        buf << '\"';
                }
        }
        __except (ExceptionFilter(_exception_code()))
        {
                // bad pointer
                // first try to rever the buffer
                buf.Revert(bc);

                WritePointerCommon(buf, (void *) pString, FALSE, TRUE, FALSE);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteWideStringCommon
//
//  Synopsis:  Common functionality for printing out Unicode strings
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pwsStr]                -       pointer to Unicode string
//                              [fQuote]                -       whether or not to enclose the string in quotes
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteWideStringCommon(CTextBufferA& buf, const WCHAR *pwsStr, BOOL fQuote)
{
        BufferContext bc;

        // take a snapshot of the buffer first
        buf.SnapShot(bc);

        __try
        {
                if(fQuote)
                {
                        buf << '\"';
                }

                while(*pwsStr != 0)
                {
                        if(*pwsStr & 0xff00)
                        {
                                // if high byte has info, set to
                                // 0x13, which is two !'s
                                buf << (char) 0x13;
                        }
                        else
                        {
                                buf << (char) (*pwsStr &0xff);
                        }

                        pwsStr++;
                }

                if(fQuote)
                {
                        buf << '\"';
                }
        }
        __except (ExceptionFilter(_exception_code()))
        {
                // bad pointer
                // try to revert the buffer
                buf.Revert(bc);

                WritePointerCommon(buf, (void *) pwsStr, FALSE, TRUE, FALSE);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteGUIDCommon
//
//  Synopsis:  Common functionality for printing out GUIDs
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pGUID]                 -       pointer to GUID to print
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteGUIDCommon(CTextBufferA& buf, const GUID *pGUID)
{
        char temp[GUIDSTR_MAX+1];
        BufferContext bc;

        // take a snapshot of the buffer first
        buf.SnapShot(bc);

        __try
        {
                StrFromGUID(*pGUID, temp, GUIDSTR_MAX);

                // tack on null byte
                temp[GUIDSTR_MAX - 1] = '\0';

                // write the string out
                buf << temp;
        }
        __except (ExceptionFilter(_exception_code()))
        {
                // bad pointer
                // try to revert the buffer
                buf.Revert(bc);

                WritePointerCommon(buf, (void *) pGUID, FALSE, TRUE, FALSE);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteFILETIME
//
//  Synopsis:  Prints out a FILETIME structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pFileTime]             -       pointer to FILETIME structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteFILETIME(CTextBufferA& buf, FILETIME *pFileTime)
{
        SYSTEMTIME sysTime;

        buf << pscStructPrefix;

        if(FileTimeToSystemTime(pFileTime, &sysTime))
        {
                char temp[TEMP_SIZE];

                IntToString(sysTime.wMonth, temp, TEMP_SIZE, TRUE);

                buf << temp;
                buf << '/';

                IntToString(sysTime.wDay, temp, TEMP_SIZE, TRUE);

                buf << temp;
                buf << '/';

                IntToString(sysTime.wYear, temp, TEMP_SIZE, TRUE);

                buf << temp;
                buf << ' ';

                IntToString(sysTime.wHour, temp, TEMP_SIZE, TRUE);

                buf << temp;
                buf << ':';

                if(sysTime.wMinute == 0)
                {
                        buf << "00";
                }
                else
                {
                        IntToString(sysTime.wMinute, temp, TEMP_SIZE, TRUE);

                        buf << temp;
                }
        }
        else
        {
                buf << "dwLowDateTime= ";

                WriteHexCommon(buf, pFileTime->dwLowDateTime, FALSE);

                buf << pscStructDelim;

                buf << "dwHighDateTime= ";

                WriteHexCommon(buf, pFileTime->dwHighDateTime, FALSE);

        }

        buf << pscStructSuffix;

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteRECT
//
//  Synopsis:  Prints out a RECT structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pRECT]         -       pointer to RECT structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteRECT(CTextBufferA& buf, RECT *pRect)
{
        buf << pscStructPrefix;

        buf << "left= ";

        WriteIntCommon(buf, pRect->left, FALSE);

        buf << pscStructDelim;

        buf << "top= ";

        WriteIntCommon(buf, pRect->top, FALSE);

        buf << pscStructDelim;

        buf << "right= ";

        WriteIntCommon(buf, pRect->right, FALSE);

        buf << pscStructDelim;

        buf << "bottom= ";

        WriteIntCommon(buf, pRect->bottom, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteSIZE
//
//  Synopsis:  Prints out a SIZE structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pSIZE]         -       pointer to SIZE structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteSIZE(CTextBufferA& buf, SIZE *pSize)
{
        buf << pscStructPrefix;

        buf << "cx= ";

        WriteIntCommon(buf, pSize->cx, FALSE);

        buf << pscStructDelim;

        buf << "cy= ";

        WriteIntCommon(buf, pSize->cy, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteLOGPALETTE
//
//  Synopsis:  Prints out a LOGPALETTE structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pLOGPALETTE]           -       pointer to LOGPALETTE structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteLOGPALETTE(CTextBufferA& buf, LOGPALETTE *pPal)
{
        buf << pscStructPrefix;

        buf << "palVersion= ";

        WriteHexCommon(buf, pPal->palVersion, TRUE);

        buf << pscStructDelim;

        buf << "palNumEntries= ";

        WriteIntCommon(buf, pPal->palNumEntries, TRUE);

        buf << pscStructDelim;

        buf << "palPalEntry[]= ";

        WritePointerCommon(buf, pPal->palPalEntry, FALSE, FALSE, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WritePOINT
//
//  Synopsis:  Prints out a POINT structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pPOINT]                -       pointer to POINT structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WritePOINT(CTextBufferA& buf, POINT *pPoint)
{
        buf << pscStructPrefix;

        buf << "x= ";

        WriteIntCommon(buf, pPoint->x, FALSE);

        buf << pscStructDelim;

        buf << "y= ";

        WriteIntCommon(buf, pPoint->y, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteMSG
//
//  Synopsis:  Prints out a MSG structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pMSG]          -       pointer to MSG structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteMSG(CTextBufferA& buf, MSG *pMsg)
{
        buf << pscStructPrefix;

        buf << "hwnd= ";

        WriteHexCommon(buf, (ULONG)(ULONG_PTR) pMsg->hwnd, FALSE);

        buf << pscStructDelim;

        buf << "message= ";

        WriteIntCommon(buf, pMsg->message, TRUE);

        buf << pscStructDelim;

        buf << "wParam= ";

        WriteHexCommon(buf, (ULONG)(ULONG_PTR)pMsg->wParam, FALSE);

        buf << pscStructDelim;

        buf << "lParam= ";

        WriteHexCommon(buf, (ULONG)(ULONG_PTR)pMsg->lParam, FALSE);

        buf << pscStructDelim;

        buf << "time= ";

        WriteIntCommon(buf, pMsg->time, TRUE);

        buf << pscStructDelim;

        buf << "pt= ";

        WritePOINT(buf, &(pMsg->pt));

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteTYMED
//
//  Synopsis:  Prints out a TYMED enumeration
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [tymed]                 -       TYMED value
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteTYMED(CTextBufferA &buf, DWORD tymed)
{
        switch(tymed)
        {
                case TYMED_NULL:
                        buf << "TYMED_NULL";
                        break;

                case TYMED_GDI:
                        buf << "TYMED_GDI";
                        break;

                case TYMED_MFPICT:
                        buf << "TYMED_MFPICT";
                        break;

                case TYMED_ENHMF:
                        buf << "TYMED_ENHMF";
                        break;

                case TYMED_HGLOBAL:
                        buf << "TYMED_HGLOBAL";
                        break;

                case TYMED_FILE:
                        buf << "TYMED_FILE";
                        break;

                case TYMED_ISTREAM:
                        buf << "TYMED_ISTREAM";
                        break;

                case TYMED_ISTORAGE:
                        buf << "TYMED_ISTORAGE";
                        break;

                default:
                        {
                                char temp[TEMP_SIZE];

                                _ultoa(tymed, temp, 10);

                                buf << temp;
                        }
                        break;
        } // switch
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteSTGMEDIUM
//
//  Synopsis:  Prints out a STGMEDIUM structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pSTGMEDIUM]            -       pointer to STGMEDIUM structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteSTGMEDIUM(CTextBufferA& buf, STGMEDIUM *pStg)
{
        buf << pscStructPrefix;

        buf << "tymed= ";

        WriteTYMED(buf, pStg->tymed);

        buf << pscStructDelim;

        switch(pStg->tymed)
        {
                case TYMED_GDI:
                        buf <<  "hBitmap= ";
                        WriteHexCommon(buf, (ULONG) (ULONG_PTR)pStg->hBitmap, FALSE);
                        break;

                case TYMED_MFPICT:
                        buf << "hMetaFilePict= ";
                        WriteHexCommon(buf, (ULONG) (ULONG_PTR)pStg->hMetaFilePict, FALSE);
                        break;

                case TYMED_ENHMF:
                        buf << "hEnhMetaFile= ";
                        WriteHexCommon(buf, (ULONG) (ULONG_PTR)pStg->hEnhMetaFile, FALSE);
                        break;

                case TYMED_HGLOBAL:
                        buf << "hGlobal= ";
                        WriteHexCommon(buf, (ULONG) (ULONG_PTR)pStg->hGlobal, FALSE);
                        break;

                case TYMED_FILE:
                        buf << "lpszFileName= ";
                        WriteWideStringCommon(buf, pStg->lpszFileName, TRUE);
                        break;

                case TYMED_ISTREAM:
                        buf << "pstm= ";
                        WritePointerCommon(buf, (void *) pStg->pstm, FALSE, FALSE, FALSE);
                        break;

                case TYMED_ISTORAGE:
                        buf << "pstg= ";
                        WritePointerCommon(buf, (void *) pStg->pstg, FALSE, FALSE, FALSE);
                        break;

                default:
                        buf << "?= ????????";
                        break;
        } // switch

        buf << pscStructDelim;

        buf << "pUnkForRelease= ";

        WritePointerCommon(buf, (void *) pStg->pUnkForRelease, FALSE, FALSE, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteFORMATETC
//
//  Synopsis:  Prints out a FORMATETC structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//              [pFORMATETC]            -       pointer to FORMATETC structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteFORMATETC(CTextBufferA& buf, FORMATETC *pETC)
{
        buf << pscStructPrefix;

        // TODO: write out enum?
        buf << "cfFormat= ";

        if (NULL == pETC)
        {
            buf << "NULL";
        }
        else
        {
            WriteIntCommon(buf, pETC->cfFormat, FALSE);

            buf << pscStructDelim;

            buf << "ptd= ";

            WritePointerCommon(buf, (void *) pETC->ptd, FALSE, FALSE, FALSE);

            buf << pscStructDelim;

            buf << "dwAspect= ";

            WriteIntCommon(buf, pETC->dwAspect, TRUE);

            buf << pscStructDelim;

            buf << "lindex= ";

            WriteIntCommon(buf, pETC->lindex, FALSE);

            buf << pscStructDelim;

            buf << "tymed= ";

            WriteTYMED(buf, pETC->tymed);
        }

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteDVTARGETDEVICE
//
//  Synopsis:  Prints out a DVTARGETDEVICE structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pDVTARGETDEVICE]               -       pointer to DVTARGETDEVICE structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteDVTARGETDEVICE(CTextBufferA& buf, DVTARGETDEVICE *ptd)
{
        buf << pscStructPrefix;

        buf << "tdSize= ";

        WriteIntCommon(buf, ptd->tdSize, TRUE);

        buf << pscStructDelim;

        if(ptd->tdDriverNameOffset != 0)
        {
                buf << "tdDriverName= ";

                WriteStringCommon(buf, (const char *) (((BYTE *)ptd)+ptd->tdDriverNameOffset), TRUE);
        }
        else
        {
                buf << "tdDriverNameOffset= 0";
        }

        buf << pscStructDelim;

        if(ptd->tdDeviceNameOffset != 0)
        {
                buf << "tdDeviceName= ";

                WriteStringCommon(buf, (const char *) (((BYTE *)ptd)+ptd->tdDeviceNameOffset), TRUE);
        }
        else
        {
                buf << "tdDeviceNameOffset= 0";
        }

        buf << pscStructDelim;

        if(ptd->tdPortNameOffset != 0)
        {
                buf << "tdPortName= ";

                WriteStringCommon(buf, (const char *) (((BYTE *)ptd)+ptd->tdPortNameOffset), TRUE);
        }
        else
        {
                buf << "tdPortNameOffset= 0";
        }


        buf << pscStructDelim;

        if(ptd->tdExtDevmodeOffset != 0)
        {
                buf << "&tdExtDevmode= ";

                WritePointerCommon(buf, (void *) (((BYTE *)ptd)+ptd->tdExtDevmodeOffset), FALSE, FALSE, FALSE);
        }
        else
        {
                buf << "tdExtDevmodeOffset= 0";
        }

        buf << pscStructSuffix;

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteBIND_OPTS
//
//  Synopsis:  Prints out a BIND_OPTS structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pBIND_OPTS]            -       pointer to BIND_OPTS structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteBIND_OPTS(CTextBufferA& buf, BIND_OPTS *pOpts)
{
        buf << pscStructPrefix;

        buf << "cbStruct= ";

        WriteIntCommon(buf, pOpts->cbStruct, TRUE);

        buf << pscStructDelim;

        buf << "grfFlags= ";

        WriteHexCommon(buf, pOpts->grfFlags, FALSE);

        buf << pscStructDelim;

        buf << "grfMode= ";

        WriteHexCommon(buf, pOpts->grfMode, FALSE);

        buf << pscStructDelim;

        buf << "dwTickCountDeadLine= ";

        WriteIntCommon(buf, pOpts->dwTickCountDeadline, TRUE);

        buf << pscStructSuffix;

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteSTATSTG
//
//  Synopsis:  Prints out a STATSTG structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pSTATSTG]              -       pointer to STATSTG structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteSTATSTG(CTextBufferA& buf, STATSTG *pStat)
{
        buf << pscStructPrefix;

        buf << "pwcsName= ";

        WriteWideStringCommon(buf, pStat->pwcsName, TRUE);

        buf << pscStructDelim;

        buf << "type= ";

        WriteHexCommon(buf, pStat->type, FALSE);

        buf << pscStructDelim;

        buf << "cbSize= ";

        WriteLargeCommon(buf, (__int64 *) &(pStat->cbSize), TRUE);

        buf << pscStructDelim;

        buf << "mtime= ";

        WriteFILETIME(buf, &(pStat->mtime));

        buf << pscStructDelim;

        buf << "ctime= ";

        WriteFILETIME(buf, &(pStat->ctime));

        buf << pscStructDelim;

        buf << "atime= ";

        WriteFILETIME(buf, &(pStat->atime));

        buf << pscStructDelim;

        buf << "grfMode= ";

        WriteHexCommon(buf, pStat->grfMode, FALSE);

        buf << pscStructDelim;

        buf << "grfLocksSupported= ";

        WriteHexCommon(buf, pStat->grfLocksSupported, FALSE);

        buf << pscStructDelim;

        buf << "clsid= ";

        WriteGUIDCommon(buf, (const GUID *) &(pStat->clsid));

        buf << pscStructDelim;

        buf << "grfStateBits= ";

        WriteHexCommon(buf, pStat->grfStateBits, FALSE);

        buf << pscStructDelim;

        buf << "Reserved= ";

        WriteHexCommon(buf, pStat->reserved, FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteOLEINPLACEFRAMEINFO
//
//  Synopsis:  Prints out a OLEINPLACEFRAMEINFO structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pOLEINPLACEFRAMEINFO]          -       pointer to OLEINPLACEFRAMEINFO structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteOLEINPLACEFRAMEINFO(CTextBufferA& buf, OLEINPLACEFRAMEINFO *pInfo)
{
        buf << pscStructPrefix;

        buf << "cb= ";

        WriteIntCommon(buf, pInfo->cb, TRUE);

        buf << pscStructDelim;

        buf << "fMDIApp= ";

        WriteBoolCommon(buf, pInfo->fMDIApp, TRUE);

        buf << pscStructDelim;

        buf << "hwndFrame= ";

        WriteHexCommon(buf, (ULONG)(ULONG_PTR) pInfo->hwndFrame, FALSE);

        buf << pscStructDelim;

        buf << "haccel= ";

        WriteHexCommon(buf, (ULONG)(ULONG_PTR) pInfo->haccel, FALSE);

        buf << pscStructDelim,

        buf << "cAccelEntries= ";

        WriteIntCommon(buf, pInfo->cAccelEntries, TRUE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteOLEMENUGROUPWIDTHS
//
//  Synopsis:  Prints out a OLEMENUGROUPWIDTHS structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pOLEMENUGROUPWIDTHS]           -       pointer to OLEMENUGROUPWIDTHS structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteOLEMENUGROUPWIDTHS(CTextBufferA& buf, OLEMENUGROUPWIDTHS *pWidths)
{
        buf << pscStructPrefix;

        for(int i = 0; i < 5; i++)
        {
                WriteIntCommon(buf, pWidths->width[i], FALSE);

                buf << pscStructDelim;
        }

        WriteIntCommon(buf, pWidths->width[5], FALSE);

        buf << pscStructSuffix;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteINTERFACEINFO
//
//  Synopsis:  Prints out a INTERFACEINFO structure
//
//  Arguments:  [buf]                   -       text buffer to print text to
//                              [pINTERFACEINFO]                -       pointer to INTERFACEINFO structure
//
//      Returns:        nothing
//
//  History:    15-Jul-95   t-stevan   Created
//
//----------------------------------------------------------------------------
void WriteINTERFACEINFO(CTextBufferA &buf, INTERFACEINFO *pInfo)
{
        buf << pscStructPrefix;

        buf << "pUnk= ";

        WritePointerCommon(buf, pInfo->pUnk, FALSE, FALSE, FALSE);

        buf << pscStructDelim;

        buf << "iid= ";

        WriteGUIDCommon(buf, (const GUID *) &(pInfo->iid));

        buf << pscStructDelim;

        buf << "wMethod= ";

        WriteIntCommon(buf, pInfo->wMethod, TRUE);

        buf << pscStructSuffix;
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\common\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*   06-05-95  SVA   Added support for printing GUIDs.
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"

/* temporary work-around for compiler without 64-bit support */

#ifndef _INTEGRAL_MAX_BITS
#define _INTEGRAL_MAX_BITS  64
#endif  /* _INTEGRAL_MAX_BITS */

/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#if defined(_WIN64)
    #define get_ptr_arg(x) (void *)get_int64_arg(x)
#elif PTR_IS_INT
    #define get_ptr_arg(x) (void *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void *)get_long_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */
#define FL_I64        0x08000     /* __int64 value given */

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

/* Brief description of the table, since I can't find maketab.c - t-stevan     */
/* Each entry in form 0xYZ. Here Z is a character class used in the macro      */
/* find_char_class defined below. The character classes are defined in the     */
/* CHARTYPE enum. For example, 'I' maps to CH_TYPE. To find a particular entry */
/* Subtract the ASCI value for the space char from the character, and that is  */
/* the index to look up. The Y value is holds state transition information.    */
/* It is used in the macro find_next_state. */
static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x38, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x07, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
#if _INTEGRAL_MAX_BITS >= 64
LOCAL(__int64) get_int64_arg(va_list *pargptr);
#endif  /* _INTEGRAL_MAX_BITS >= 64    */

LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif

/* Defines for printing out GUIDs */
#ifndef GUID_DEFINED
#define GUID_DEFINED
			/* size is 16 */
typedef struct  _GUID
    {
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED

#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED

/* This is actually one less than the normal GUIDSTR_MAX */
/* Because we don't tag on a NULL byte */
#define OUTPUT_GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 /* + 1 */)

/* Make sure our buffer size is big enough to hold a GUID */
#if BUFFERSIZE < OUTPUT_GUIDSTR_MAX
#undef BUFFERSIZE
#define BUFFERSIZE OUTPUT_GUIDSTR_MAX
#endif

/* Function used to write a GUID to a string */
int StrFromGUID(REFGUID rguid, char * lpsz, int cbMax);

/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd = 0;     /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags;          /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth = 0;   /* selected field with -- 0 means default */
    int fwide;
    int precision = 0;  /* selected precision -- -1 means default */
    char prefix[2] = {0};  /* numeric prefix -- up to two characters */
    int prefixlen = 0;  /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output = 0;  /* non-zero = prodcue no output for this specifier */
    char *text = NULL;  /* pointer text to be printed, not zero terminated */
    int textlen = 0;    /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
        NORMAL_STATE:

            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

            case 'L':
#if !LONGDOUBLE_IS_DOUBLE
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
#endif
                flags |= FL_I64;        /* 'L' => __int64 */
                break;

            case 'I':
                /*
                 * In order to handle the I64 size modifier, we depart from
                 * the simple deterministic state machine. The code below
                 * scans
                 */
                if ( (*format == '6') && (*(format + 1) == '4') ) {
                    format += 2;
                    flags |= FL_I64;    /* I64 => __int64 */
                }
                else {
                    state = ST_NORMAL;
                    goto NORMAL_STATE;
                }
                break;

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
	    case 't':
#ifdef _UNICODE
		flags |= FL_WIDE;
#endif
		break;

            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    textlen = (int) strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int)(pwc - (wchar_t *) text);  /*string length*/
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int)(p - text);    /* length of the string */
                }
            }
            break;

            /* print a GUID */
            case 'I':
            {
                void *p;        /* temp */

                p = get_ptr_arg(&argptr);

			    if (p == NULL)
			    {
			   		/* null ptr passed, use special string */
			   		text = nullstring;
					textlen = (int) strlen(nullstring);
				}
				else
               	{
               		textlen = StrFromGUID(p, buffer, BUFFERSIZE);
               		text = buffer;
				}
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;

#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_LONG;       /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

#if _INTEGRAL_MAX_BITS >= 64
                unsigned __int64 number;    /* number to convert */
                int digit;              /* ascii value of digit */
                __int64 l;              /* temp long value */
#else  /* _INTEGRAL_MAX_BITS >= 64            */
                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */
#endif  /* _INTEGRAL_MAX_BITS >= 64            */

                /* 1. read argument into l, sign extend as needed */
#if _INTEGRAL_MAX_BITS >= 64
                if (flags & FL_I64)
                    l 